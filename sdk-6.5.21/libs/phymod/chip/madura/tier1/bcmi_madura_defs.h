#ifndef __BCMI_MADURA_DEFS_H__
#define __BCMI_MADURA_DEFS_H__
/*******************************************************************************
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_MADURA.
 * This file provides all basic definitions required to program the BCMI_MADURA.
 *
 * This file is autogenerated. Please do not edit.
 */

#ifndef _DV_TB_
/* include <phymod/acc/phymod_madura_iblk.h> */
#endif /*  */

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_CTL
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0000
 * DEVAD:    1
 * DESC:     ieee Control1 register
 * RESETVAL: 0x204c (8268)
 * ACCESS:   R/W
 * FIELDS:
 *     PMA_LOOPBACK     1 = Enable PMA local LoopbackNOTE : This IEEE bit is NOT operational. PMA Loopbackfuncitonality is supported through USER registers
 *     PMA_REMOTE_LOOPBACK 1 = Enable PMA remote LoopbackNOTE : This IEEE bit is NOT operational. PMA Remote Loopbackfuncitonality is supported through USER registers
 *     SPEED_SELECTION  0000 =  10 Gbps0010 =  40 Gbps0011 = 100 GbpsAll other codes are reserved
 *     SPEED_SELECTIONMSB 1.0.6     1.0.131         1      = bit 5:2 select speed1         0      = 1000 Mb/s0         1      = 100 Mb/s (not supported)0         0      = 10 Mb/s (not supported)
 *     POWER_DOWN       1 = Power down0 = Normal operationIn multi-pmd mode powers down each lane/port.In single-pmd mode powers down all lanes.
 *     SPEED_SELECTIONLSB 1.0.6     1.0.131         1      = bit 5:2 select speed1         0      = 1000 Mb/s0         1      = 100 Mb/s (not supported)0         0      = 10 Mb/s (not supported)
 *     RESET            1=Active high, Self clearing, cleared afteri2c read done when config = 10 and 11Madura in single PMD (100/40G): IEEE reset will reset all IEEE registers and corresponding Falcon core (ln_h*rstb*, ln_dp*rstb*)If only one port is configured, IEEE reset will reset all of Madura registers too.Madura in non-single PMD (any other mode): IEEE reset will reset all IEEE registers corresponding to this particular portand corresponding falcon lanes (ln_h*rstb* and ln_dp*rstb*).
 */
#define BCMI_MADURA_PMD_CTLr (0x00010000 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_CTL.
 */
typedef union BCMI_MADURA_PMD_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_ctl[1];
	uint32_t _pmd_ctl;
} BCMI_MADURA_PMD_CTLr_t;

#define BCMI_MADURA_PMD_CTLr_CLR(r) (r).pmd_ctl[0] = 0
#define BCMI_MADURA_PMD_CTLr_SET(r,d) (r).pmd_ctl[0] = d
#define BCMI_MADURA_PMD_CTLr_GET(r) (r).pmd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_CTLr_RESETf_GET(r) ((((r).pmd_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_PMD_CTLr_RESETf_SET(r,f) (r).pmd_ctl[0]=(((r).pmd_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONLSBf_GET(r) ((((r).pmd_ctl[0]) >> 13) & 0x1)
#define BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONLSBf_SET(r,f) (r).pmd_ctl[0]=(((r).pmd_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_PMD_CTLr_POWER_DOWNf_GET(r) ((((r).pmd_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_PMD_CTLr_POWER_DOWNf_SET(r,f) (r).pmd_ctl[0]=(((r).pmd_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONMSBf_GET(r) ((((r).pmd_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONMSBf_SET(r,f) (r).pmd_ctl[0]=(((r).pmd_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONf_GET(r) ((((r).pmd_ctl[0]) >> 2) & 0xf)
#define BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONf_SET(r,f) (r).pmd_ctl[0]=(((r).pmd_ctl[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_MADURA_PMD_CTLr_PMA_REMOTE_LOOPBACKf_GET(r) ((((r).pmd_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_PMD_CTLr_PMA_REMOTE_LOOPBACKf_SET(r,f) (r).pmd_ctl[0]=(((r).pmd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PMD_CTLr_PMA_LOOPBACKf_GET(r) (((r).pmd_ctl[0]) & 0x1)
#define BCMI_MADURA_PMD_CTLr_PMA_LOOPBACKf_SET(r,f) (r).pmd_ctl[0]=(((r).pmd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_CTL.
 */
#define BCMI_MADURA_READ_PMD_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_CTLr,_r._pmd_ctl)
#define BCMI_MADURA_WRITE_PMD_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_CTLr,_r._pmd_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_CTLr BCMI_MADURA_PMD_CTLr
#define PMD_CTLr_SIZE BCMI_MADURA_PMD_CTLr_SIZE
typedef BCMI_MADURA_PMD_CTLr_t PMD_CTLr_t;
#define PMD_CTLr_CLR BCMI_MADURA_PMD_CTLr_CLR
#define PMD_CTLr_SET BCMI_MADURA_PMD_CTLr_SET
#define PMD_CTLr_GET BCMI_MADURA_PMD_CTLr_GET
#define PMD_CTLr_RESETf_GET BCMI_MADURA_PMD_CTLr_RESETf_GET
#define PMD_CTLr_RESETf_SET BCMI_MADURA_PMD_CTLr_RESETf_SET
#define PMD_CTLr_SPEED_SELECTIONLSBf_GET BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONLSBf_GET
#define PMD_CTLr_SPEED_SELECTIONLSBf_SET BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONLSBf_SET
#define PMD_CTLr_POWER_DOWNf_GET BCMI_MADURA_PMD_CTLr_POWER_DOWNf_GET
#define PMD_CTLr_POWER_DOWNf_SET BCMI_MADURA_PMD_CTLr_POWER_DOWNf_SET
#define PMD_CTLr_SPEED_SELECTIONMSBf_GET BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONMSBf_GET
#define PMD_CTLr_SPEED_SELECTIONMSBf_SET BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONMSBf_SET
#define PMD_CTLr_SPEED_SELECTIONf_GET BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONf_GET
#define PMD_CTLr_SPEED_SELECTIONf_SET BCMI_MADURA_PMD_CTLr_SPEED_SELECTIONf_SET
#define PMD_CTLr_PMA_REMOTE_LOOPBACKf_GET BCMI_MADURA_PMD_CTLr_PMA_REMOTE_LOOPBACKf_GET
#define PMD_CTLr_PMA_REMOTE_LOOPBACKf_SET BCMI_MADURA_PMD_CTLr_PMA_REMOTE_LOOPBACKf_SET
#define PMD_CTLr_PMA_LOOPBACKf_GET BCMI_MADURA_PMD_CTLr_PMA_LOOPBACKf_GET
#define PMD_CTLr_PMA_LOOPBACKf_SET BCMI_MADURA_PMD_CTLr_PMA_LOOPBACKf_SET
#define READ_PMD_CTLr BCMI_MADURA_READ_PMD_CTLr
#define WRITE_PMD_CTLr BCMI_MADURA_WRITE_PMD_CTLr
#define MODIFY_PMD_CTLr BCMI_MADURA_MODIFY_PMD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_IDENTIFIER_0
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0002
 * DEVAD:    1
 * DESC:     PMD Identifier Register 0
 * RESETVAL: 0xae02 (44546)
 * ACCESS:   R/W
 * FIELDS:
 *     DEVICE_ID_0      PHY ID High
 */
#define BCMI_MADURA_PMD_IDENTIFIER_0r (0x00010002 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_IDENTIFIER_0r_SIZE 4

/*
 * This structure should be used to declare and program PMD_IDENTIFIER_0.
 */
typedef union BCMI_MADURA_PMD_IDENTIFIER_0r_s {
	uint32_t v[1];
	uint32_t pmd_identifier_0[1];
	uint32_t _pmd_identifier_0;
} BCMI_MADURA_PMD_IDENTIFIER_0r_t;

#define BCMI_MADURA_PMD_IDENTIFIER_0r_CLR(r) (r).pmd_identifier_0[0] = 0
#define BCMI_MADURA_PMD_IDENTIFIER_0r_SET(r,d) (r).pmd_identifier_0[0] = d
#define BCMI_MADURA_PMD_IDENTIFIER_0r_GET(r) (r).pmd_identifier_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_IDENTIFIER_0r_DEVICE_ID_0f_GET(r) (((r).pmd_identifier_0[0]) & 0xffff)
#define BCMI_MADURA_PMD_IDENTIFIER_0r_DEVICE_ID_0f_SET(r,f) (r).pmd_identifier_0[0]=(((r).pmd_identifier_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_IDENTIFIER_0.
 */
#define BCMI_MADURA_READ_PMD_IDENTIFIER_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_IDENTIFIER_0r,_r._pmd_identifier_0)
#define BCMI_MADURA_WRITE_PMD_IDENTIFIER_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_IDENTIFIER_0r,_r._pmd_identifier_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_IDENTIFIER_0r BCMI_MADURA_PMD_IDENTIFIER_0r
#define PMD_IDENTIFIER_0r_SIZE BCMI_MADURA_PMD_IDENTIFIER_0r_SIZE
typedef BCMI_MADURA_PMD_IDENTIFIER_0r_t PMD_IDENTIFIER_0r_t;
#define PMD_IDENTIFIER_0r_CLR BCMI_MADURA_PMD_IDENTIFIER_0r_CLR
#define PMD_IDENTIFIER_0r_SET BCMI_MADURA_PMD_IDENTIFIER_0r_SET
#define PMD_IDENTIFIER_0r_GET BCMI_MADURA_PMD_IDENTIFIER_0r_GET
#define PMD_IDENTIFIER_0r_DEVICE_ID_0f_GET BCMI_MADURA_PMD_IDENTIFIER_0r_DEVICE_ID_0f_GET
#define PMD_IDENTIFIER_0r_DEVICE_ID_0f_SET BCMI_MADURA_PMD_IDENTIFIER_0r_DEVICE_ID_0f_SET
#define READ_PMD_IDENTIFIER_0r BCMI_MADURA_READ_PMD_IDENTIFIER_0r
#define WRITE_PMD_IDENTIFIER_0r BCMI_MADURA_WRITE_PMD_IDENTIFIER_0r
#define MODIFY_PMD_IDENTIFIER_0r BCMI_MADURA_MODIFY_PMD_IDENTIFIER_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_IDENTIFIER_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_IDENTIFIER_1
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0003
 * DEVAD:    1
 * DESC:     PMD Identifier Register 1
 * RESETVAL: 0x52b0 (21168)
 * ACCESS:   R/W
 * FIELDS:
 *     DEVICE_ID_1      PHY ID LOW
 */
#define BCMI_MADURA_PMD_IDENTIFIER_1r (0x00010003 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_IDENTIFIER_1r_SIZE 4

/*
 * This structure should be used to declare and program PMD_IDENTIFIER_1.
 */
typedef union BCMI_MADURA_PMD_IDENTIFIER_1r_s {
	uint32_t v[1];
	uint32_t pmd_identifier_1[1];
	uint32_t _pmd_identifier_1;
} BCMI_MADURA_PMD_IDENTIFIER_1r_t;

#define BCMI_MADURA_PMD_IDENTIFIER_1r_CLR(r) (r).pmd_identifier_1[0] = 0
#define BCMI_MADURA_PMD_IDENTIFIER_1r_SET(r,d) (r).pmd_identifier_1[0] = d
#define BCMI_MADURA_PMD_IDENTIFIER_1r_GET(r) (r).pmd_identifier_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_IDENTIFIER_1r_DEVICE_ID_1f_GET(r) (((r).pmd_identifier_1[0]) & 0xffff)
#define BCMI_MADURA_PMD_IDENTIFIER_1r_DEVICE_ID_1f_SET(r,f) (r).pmd_identifier_1[0]=(((r).pmd_identifier_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_IDENTIFIER_1.
 */
#define BCMI_MADURA_READ_PMD_IDENTIFIER_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_IDENTIFIER_1r,_r._pmd_identifier_1)
#define BCMI_MADURA_WRITE_PMD_IDENTIFIER_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_IDENTIFIER_1r,_r._pmd_identifier_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_IDENTIFIER_1r BCMI_MADURA_PMD_IDENTIFIER_1r
#define PMD_IDENTIFIER_1r_SIZE BCMI_MADURA_PMD_IDENTIFIER_1r_SIZE
typedef BCMI_MADURA_PMD_IDENTIFIER_1r_t PMD_IDENTIFIER_1r_t;
#define PMD_IDENTIFIER_1r_CLR BCMI_MADURA_PMD_IDENTIFIER_1r_CLR
#define PMD_IDENTIFIER_1r_SET BCMI_MADURA_PMD_IDENTIFIER_1r_SET
#define PMD_IDENTIFIER_1r_GET BCMI_MADURA_PMD_IDENTIFIER_1r_GET
#define PMD_IDENTIFIER_1r_DEVICE_ID_1f_GET BCMI_MADURA_PMD_IDENTIFIER_1r_DEVICE_ID_1f_GET
#define PMD_IDENTIFIER_1r_DEVICE_ID_1f_SET BCMI_MADURA_PMD_IDENTIFIER_1r_DEVICE_ID_1f_SET
#define READ_PMD_IDENTIFIER_1r BCMI_MADURA_READ_PMD_IDENTIFIER_1r
#define WRITE_PMD_IDENTIFIER_1r BCMI_MADURA_WRITE_PMD_IDENTIFIER_1r
#define MODIFY_PMD_IDENTIFIER_1r BCMI_MADURA_MODIFY_PMD_IDENTIFIER_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_IDENTIFIER_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_SPD_ABIL
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0004
 * DEVAD:    1
 * DESC:     ieee PMD Speed Ability register
 * RESETVAL: 0x301 (769)
 * ACCESS:   R/W
 * FIELDS:
 *     TENG_CAPABLE     1 = PMD is capable of operating at 10G0 = PMD is NOT capable of operating at 10G
 *     ONEG_CAPABLE     1 = PMD is capable of operating at 1G0 = PMD is NOT capable of operating at 1G
 *     FORTYG_CAPABLE   1 = PMD is capable of operating at 40G
 *     ONE_HUNDREDG_CAPABLE 1 = PMD is capable of operating at 100G forpackage BCM82388 (bondsel[0]==1'b0) supports 100GAny other package (bondsel[0]==1'b1), does NOT support 100GReset value will depend on bondsel
 */
#define BCMI_MADURA_PMD_SPD_ABILr (0x00010004 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_SPD_ABILr_SIZE 4

/*
 * This structure should be used to declare and program PMD_SPD_ABIL.
 */
typedef union BCMI_MADURA_PMD_SPD_ABILr_s {
	uint32_t v[1];
	uint32_t pmd_spd_abil[1];
	uint32_t _pmd_spd_abil;
} BCMI_MADURA_PMD_SPD_ABILr_t;

#define BCMI_MADURA_PMD_SPD_ABILr_CLR(r) (r).pmd_spd_abil[0] = 0
#define BCMI_MADURA_PMD_SPD_ABILr_SET(r,d) (r).pmd_spd_abil[0] = d
#define BCMI_MADURA_PMD_SPD_ABILr_GET(r) (r).pmd_spd_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_SPD_ABILr_ONE_HUNDREDG_CAPABLEf_GET(r) ((((r).pmd_spd_abil[0]) >> 9) & 0x1)
#define BCMI_MADURA_PMD_SPD_ABILr_ONE_HUNDREDG_CAPABLEf_SET(r,f) (r).pmd_spd_abil[0]=(((r).pmd_spd_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_PMD_SPD_ABILr_FORTYG_CAPABLEf_GET(r) ((((r).pmd_spd_abil[0]) >> 8) & 0x1)
#define BCMI_MADURA_PMD_SPD_ABILr_FORTYG_CAPABLEf_SET(r,f) (r).pmd_spd_abil[0]=(((r).pmd_spd_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PMD_SPD_ABILr_ONEG_CAPABLEf_GET(r) ((((r).pmd_spd_abil[0]) >> 4) & 0x1)
#define BCMI_MADURA_PMD_SPD_ABILr_ONEG_CAPABLEf_SET(r,f) (r).pmd_spd_abil[0]=(((r).pmd_spd_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PMD_SPD_ABILr_TENG_CAPABLEf_GET(r) (((r).pmd_spd_abil[0]) & 0x1)
#define BCMI_MADURA_PMD_SPD_ABILr_TENG_CAPABLEf_SET(r,f) (r).pmd_spd_abil[0]=(((r).pmd_spd_abil[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_SPD_ABIL.
 */
#define BCMI_MADURA_READ_PMD_SPD_ABILr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_SPD_ABILr,_r._pmd_spd_abil)
#define BCMI_MADURA_WRITE_PMD_SPD_ABILr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_SPD_ABILr,_r._pmd_spd_abil)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_SPD_ABILr BCMI_MADURA_PMD_SPD_ABILr
#define PMD_SPD_ABILr_SIZE BCMI_MADURA_PMD_SPD_ABILr_SIZE
typedef BCMI_MADURA_PMD_SPD_ABILr_t PMD_SPD_ABILr_t;
#define PMD_SPD_ABILr_CLR BCMI_MADURA_PMD_SPD_ABILr_CLR
#define PMD_SPD_ABILr_SET BCMI_MADURA_PMD_SPD_ABILr_SET
#define PMD_SPD_ABILr_GET BCMI_MADURA_PMD_SPD_ABILr_GET
#define PMD_SPD_ABILr_ONE_HUNDREDG_CAPABLEf_GET BCMI_MADURA_PMD_SPD_ABILr_ONE_HUNDREDG_CAPABLEf_GET
#define PMD_SPD_ABILr_ONE_HUNDREDG_CAPABLEf_SET BCMI_MADURA_PMD_SPD_ABILr_ONE_HUNDREDG_CAPABLEf_SET
#define PMD_SPD_ABILr_FORTYG_CAPABLEf_GET BCMI_MADURA_PMD_SPD_ABILr_FORTYG_CAPABLEf_GET
#define PMD_SPD_ABILr_FORTYG_CAPABLEf_SET BCMI_MADURA_PMD_SPD_ABILr_FORTYG_CAPABLEf_SET
#define PMD_SPD_ABILr_ONEG_CAPABLEf_GET BCMI_MADURA_PMD_SPD_ABILr_ONEG_CAPABLEf_GET
#define PMD_SPD_ABILr_ONEG_CAPABLEf_SET BCMI_MADURA_PMD_SPD_ABILr_ONEG_CAPABLEf_SET
#define PMD_SPD_ABILr_TENG_CAPABLEf_GET BCMI_MADURA_PMD_SPD_ABILr_TENG_CAPABLEf_GET
#define PMD_SPD_ABILr_TENG_CAPABLEf_SET BCMI_MADURA_PMD_SPD_ABILr_TENG_CAPABLEf_SET
#define READ_PMD_SPD_ABILr BCMI_MADURA_READ_PMD_SPD_ABILr
#define WRITE_PMD_SPD_ABILr BCMI_MADURA_WRITE_PMD_SPD_ABILr
#define MODIFY_PMD_SPD_ABILr BCMI_MADURA_MODIFY_PMD_SPD_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_SPD_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DEVS_IN_PACKAGE1
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0005
 * DEVAD:    1
 * DESC:     ieee Device in Package 1 register
 * RESETVAL: 0x82 (130)
 * ACCESS:   R/W
 * FIELDS:
 *     CLAUSE_22REGISTERS_PRESENT 1 = Clause 22 registers present
 *     PMD_PMA_PRESENT  1 = PMD/PMA present in package
 *     WIS_PRESENT      1 = WIS present in package
 *     PCS_PRESENT      1 = PCS present in package
 *     PHY_XS_PRESENT   1 = PHY XS present in package
 *     DTE_XS_PRESENT   1 = DTE XS present in package
 *     TC_PRESENT       1 = TC present in package
 *     AN_PRESENT       1-Auto Neg present
 *     SEPERATE_PMA_1_PRESENT Seperate PMA 1  present
 *     SEPERATE_PMA_2_PRESENT Seperate PMA 2  present
 *     SEPERATE_PMA_3_PRESENT Seperate PMA 3  present
 *     SEPERATE_PMA_4_PRESENT Seperate PMA 4  present
 */
#define BCMI_MADURA_DEVS_IN_PACKAGE1r (0x00010005 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SIZE 4

/*
 * This structure should be used to declare and program DEVS_IN_PACKAGE1.
 */
typedef union BCMI_MADURA_DEVS_IN_PACKAGE1r_s {
	uint32_t v[1];
	uint32_t devs_in_package1[1];
	uint32_t _devs_in_package1;
} BCMI_MADURA_DEVS_IN_PACKAGE1r_t;

#define BCMI_MADURA_DEVS_IN_PACKAGE1r_CLR(r) (r).devs_in_package1[0] = 0
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SET(r,d) (r).devs_in_package1[0] = d
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_GET(r) (r).devs_in_package1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 11) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 10) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 9) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 8) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_AN_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 7) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_AN_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_TC_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 6) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_TC_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 5) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 4) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_PCS_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 3) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_PCS_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_WIS_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 2) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_WIS_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_GET(r) ((((r).devs_in_package1[0]) >> 1) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_GET(r) (((r).devs_in_package1[0]) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_SET(r,f) (r).devs_in_package1[0]=(((r).devs_in_package1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DEVS_IN_PACKAGE1.
 */
#define BCMI_MADURA_READ_DEVS_IN_PACKAGE1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DEVS_IN_PACKAGE1r,_r._devs_in_package1)
#define BCMI_MADURA_WRITE_DEVS_IN_PACKAGE1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DEVS_IN_PACKAGE1r,_r._devs_in_package1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DEVS_IN_PACKAGE1r BCMI_MADURA_DEVS_IN_PACKAGE1r
#define DEVS_IN_PACKAGE1r_SIZE BCMI_MADURA_DEVS_IN_PACKAGE1r_SIZE
typedef BCMI_MADURA_DEVS_IN_PACKAGE1r_t DEVS_IN_PACKAGE1r_t;
#define DEVS_IN_PACKAGE1r_CLR BCMI_MADURA_DEVS_IN_PACKAGE1r_CLR
#define DEVS_IN_PACKAGE1r_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_SET
#define DEVS_IN_PACKAGE1r_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_GET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_AN_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_AN_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_AN_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_AN_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_TC_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_TC_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_TC_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_TC_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_PCS_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_PCS_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_PCS_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_PCS_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_WIS_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_WIS_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_WIS_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_WIS_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_SET
#define DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_GET
#define DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_SET
#define READ_DEVS_IN_PACKAGE1r BCMI_MADURA_READ_DEVS_IN_PACKAGE1r
#define WRITE_DEVS_IN_PACKAGE1r BCMI_MADURA_WRITE_DEVS_IN_PACKAGE1r
#define MODIFY_DEVS_IN_PACKAGE1r BCMI_MADURA_MODIFY_DEVS_IN_PACKAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DEVS_IN_PACKAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DEVS_IN_PACKAGE2
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0006
 * DEVAD:    1
 * DESC:     ieee Device in Package 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLAUSE_22EXTENSION_PRESENT 1 = Clause 22 extension present inpackage
 *     VENDOR_SPECIFICDEVICE_1_PRESENT 1 = Vendor specific device present inpackage
 *     VENDOR_SPECIFICDEVICE_2_PRESENT 1 = Vendor specific device present inpackage
 */
#define BCMI_MADURA_DEVS_IN_PACKAGE2r (0x00010006 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DEVS_IN_PACKAGE2r_SIZE 4

/*
 * This structure should be used to declare and program DEVS_IN_PACKAGE2.
 */
typedef union BCMI_MADURA_DEVS_IN_PACKAGE2r_s {
	uint32_t v[1];
	uint32_t devs_in_package2[1];
	uint32_t _devs_in_package2;
} BCMI_MADURA_DEVS_IN_PACKAGE2r_t;

#define BCMI_MADURA_DEVS_IN_PACKAGE2r_CLR(r) (r).devs_in_package2[0] = 0
#define BCMI_MADURA_DEVS_IN_PACKAGE2r_SET(r,d) (r).devs_in_package2[0] = d
#define BCMI_MADURA_DEVS_IN_PACKAGE2r_GET(r) (r).devs_in_package2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_GET(r) ((((r).devs_in_package2[0]) >> 13) & 0x1)
#define BCMI_MADURA_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_SET(r,f) (r).devs_in_package2[0]=(((r).devs_in_package2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access DEVS_IN_PACKAGE2.
 */
#define BCMI_MADURA_READ_DEVS_IN_PACKAGE2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DEVS_IN_PACKAGE2r,_r._devs_in_package2)
#define BCMI_MADURA_WRITE_DEVS_IN_PACKAGE2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DEVS_IN_PACKAGE2r,_r._devs_in_package2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DEVS_IN_PACKAGE2r BCMI_MADURA_DEVS_IN_PACKAGE2r
#define DEVS_IN_PACKAGE2r_SIZE BCMI_MADURA_DEVS_IN_PACKAGE2r_SIZE
typedef BCMI_MADURA_DEVS_IN_PACKAGE2r_t DEVS_IN_PACKAGE2r_t;
#define DEVS_IN_PACKAGE2r_CLR BCMI_MADURA_DEVS_IN_PACKAGE2r_CLR
#define DEVS_IN_PACKAGE2r_SET BCMI_MADURA_DEVS_IN_PACKAGE2r_SET
#define DEVS_IN_PACKAGE2r_GET BCMI_MADURA_DEVS_IN_PACKAGE2r_GET
#define DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_GET BCMI_MADURA_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_GET
#define DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_SET BCMI_MADURA_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_SET
#define READ_DEVS_IN_PACKAGE2r BCMI_MADURA_READ_DEVS_IN_PACKAGE2r
#define WRITE_DEVS_IN_PACKAGE2r BCMI_MADURA_WRITE_DEVS_IN_PACKAGE2r
#define MODIFY_DEVS_IN_PACKAGE2r BCMI_MADURA_MODIFY_DEVS_IN_PACKAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DEVS_IN_PACKAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_CTL2
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0007
 * DEVAD:    1
 * DESC:     ieee Control2 register
 * RESETVAL: 0x2a (42)
 * ACCESS:   R/W
 * FIELDS:
 *     PMA_TYPESELECTION Select the PMA/PMD type from the advertised types in (a)bits 9 and [7:0] of PMA/PMD status 2 register (1.8), (b)PMA/PMD extended ability register (1.11) and (c)40G/100G PMA/PMD extended ability register (1.13). Allowed values are:6'b101110 = 100GBASE-CR46'b101101 = 100GBASE-KR46'b101011 = 100GBASE-ER46'b101010 = 100GBASE-LR46'b101001 = 100GBASE-SR106'b100011 = 40GBASE-LR46'b100010 = 40GBASE-SR46'b100001 = 40GBASE-CR46'b100000 = 40GBASE-KR46'b000111 = 10GBASE-SR6'b000110 = 10GBASE-LR6'b000101 = 10GBASE-ERReset value is 100G LR4
 */
#define BCMI_MADURA_PMD_CTL2r (0x00010007 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PMD_CTL2.
 */
typedef union BCMI_MADURA_PMD_CTL2r_s {
	uint32_t v[1];
	uint32_t pmd_ctl2[1];
	uint32_t _pmd_ctl2;
} BCMI_MADURA_PMD_CTL2r_t;

#define BCMI_MADURA_PMD_CTL2r_CLR(r) (r).pmd_ctl2[0] = 0
#define BCMI_MADURA_PMD_CTL2r_SET(r,d) (r).pmd_ctl2[0] = d
#define BCMI_MADURA_PMD_CTL2r_GET(r) (r).pmd_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_CTL2r_PMA_TYPESELECTIONf_GET(r) (((r).pmd_ctl2[0]) & 0x3f)
#define BCMI_MADURA_PMD_CTL2r_PMA_TYPESELECTIONf_SET(r,f) (r).pmd_ctl2[0]=(((r).pmd_ctl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access PMD_CTL2.
 */
#define BCMI_MADURA_READ_PMD_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_CTL2r,_r._pmd_ctl2)
#define BCMI_MADURA_WRITE_PMD_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_CTL2r,_r._pmd_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_CTL2r BCMI_MADURA_PMD_CTL2r
#define PMD_CTL2r_SIZE BCMI_MADURA_PMD_CTL2r_SIZE
typedef BCMI_MADURA_PMD_CTL2r_t PMD_CTL2r_t;
#define PMD_CTL2r_CLR BCMI_MADURA_PMD_CTL2r_CLR
#define PMD_CTL2r_SET BCMI_MADURA_PMD_CTL2r_SET
#define PMD_CTL2r_GET BCMI_MADURA_PMD_CTL2r_GET
#define PMD_CTL2r_PMA_TYPESELECTIONf_GET BCMI_MADURA_PMD_CTL2r_PMA_TYPESELECTIONf_GET
#define PMD_CTL2r_PMA_TYPESELECTIONf_SET BCMI_MADURA_PMD_CTL2r_PMA_TYPESELECTIONf_SET
#define READ_PMD_CTL2r BCMI_MADURA_READ_PMD_CTL2r
#define WRITE_PMD_CTL2r BCMI_MADURA_WRITE_PMD_CTL2r
#define MODIFY_PMD_CTL2r BCMI_MADURA_MODIFY_PMD_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  IEEE0_PMA_PMD_BLK0_STS
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0008
 * DEVAD:    1
 * DESC:     ieee Status 2 register
 * RESETVAL: 0x83e1 (33761)
 * ACCESS:   R/W
 * FIELDS:
 *     PMA_LOCAL_LOOPBACK_ABILITY 1 = Ability to perform local PMA loopback
 *     TENGBASE_EW_ABILITY 1 = Able to perform 10GBASE-EW
 *     TENGBASE_LW_ABILITY 1 = Able to perform 10GBASE-LW
 *     TENGBASE_SW_ABILITY 1 = Able to perform 10GBASE-SW
 *     TENGBASE_LX4_ABILITY 1 = Able to perform 10GBASE-LX4
 *     TENGBASE_ER_ABILITY 1 = Able to perform 10GBASE-ER
 *     TENGBASE_LR_ABILITY 1 = Able to perform 10GBASE-LR
 *     TENGBASE_SR_ABILITY 1 = Able to perform 10GBASE-SR
 *     PMD_TRANSMITDISABLE_ABILITY 1 = PMD has the ability to disable thetransmit path
 *     EXTENDED_ABILITIES 1 = PMD has extended abilities listed inregister 0x000B
 *     RECEIVE_LOCALFAULT 1 = Local fault condition detected onreceive path
 *     TRANSMIT_LOCALFAULT 1 = Local fault condition detected ontransmit path
 *     RECEIVE_LOCALFAULT_ABILITY 1 = Ability to detect local fault conditionon the receive path
 *     TRANSMIT_LOCALFAULT_ABILITY 1 = Ability to detect local fault conditionon the transmit path
 *     DEVICE_PRESENT   10 = Device responding at this address11 = No device responding at this address01 = No device responding at this address00 = No device responding at this address
 */
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr (0x00010008 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_SIZE 4

/*
 * This structure should be used to declare and program IEEE0_PMA_PMD_BLK0_STS.
 */
typedef union BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_s {
	uint32_t v[1];
	uint32_t ieee0_pma_pmd_blk0_sts[1];
	uint32_t _ieee0_pma_pmd_blk0_sts;
} BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_t;

#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_CLR(r) (r).ieee0_pma_pmd_blk0_sts[0] = 0
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_SET(r,d) (r).ieee0_pma_pmd_blk0_sts[0] = d
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_GET(r) (r).ieee0_pma_pmd_blk0_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_DEVICE_PRESENTf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 14) & 0x3)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_DEVICE_PRESENTf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULT_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULT_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULT_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULT_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULTf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULTf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULTf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULTf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_EXTENDED_ABILITIESf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_EXTENDED_ABILITIESf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMD_TRANSMITDISABLE_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMD_TRANSMITDISABLE_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SR_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 7) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SR_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LR_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 6) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LR_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_ER_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 5) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_ER_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LX4_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LX4_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SW_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SW_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LW_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LW_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_EW_ABILITYf_GET(r) ((((r).ieee0_pma_pmd_blk0_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_EW_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMA_LOCAL_LOOPBACK_ABILITYf_GET(r) (((r).ieee0_pma_pmd_blk0_sts[0]) & 0x1)
#define BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMA_LOCAL_LOOPBACK_ABILITYf_SET(r,f) (r).ieee0_pma_pmd_blk0_sts[0]=(((r).ieee0_pma_pmd_blk0_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access IEEE0_PMA_PMD_BLK0_STS.
 */
#define BCMI_MADURA_READ_IEEE0_PMA_PMD_BLK0_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr,_r._ieee0_pma_pmd_blk0_sts)
#define BCMI_MADURA_WRITE_IEEE0_PMA_PMD_BLK0_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr,_r._ieee0_pma_pmd_blk0_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define IEEE0_PMA_PMD_BLK0_STSr BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr
#define IEEE0_PMA_PMD_BLK0_STSr_SIZE BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_SIZE
typedef BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_t IEEE0_PMA_PMD_BLK0_STSr_t;
#define IEEE0_PMA_PMD_BLK0_STSr_CLR BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_CLR
#define IEEE0_PMA_PMD_BLK0_STSr_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_SET
#define IEEE0_PMA_PMD_BLK0_STSr_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_GET
#define IEEE0_PMA_PMD_BLK0_STSr_DEVICE_PRESENTf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_DEVICE_PRESENTf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_DEVICE_PRESENTf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_DEVICE_PRESENTf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULT_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULT_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULT_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULT_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULT_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULT_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULT_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULT_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULTf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULTf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULTf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TRANSMIT_LOCALFAULTf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULTf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULTf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULTf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_RECEIVE_LOCALFAULTf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_EXTENDED_ABILITIESf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_EXTENDED_ABILITIESf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_EXTENDED_ABILITIESf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_EXTENDED_ABILITIESf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_PMD_TRANSMITDISABLE_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMD_TRANSMITDISABLE_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_PMD_TRANSMITDISABLE_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMD_TRANSMITDISABLE_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SR_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SR_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SR_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SR_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LR_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LR_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LR_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LR_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_ER_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_ER_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_ER_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_ER_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LX4_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LX4_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LX4_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LX4_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SW_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SW_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SW_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_SW_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LW_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LW_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LW_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_LW_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_EW_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_EW_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_EW_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_TENGBASE_EW_ABILITYf_SET
#define IEEE0_PMA_PMD_BLK0_STSr_PMA_LOCAL_LOOPBACK_ABILITYf_GET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMA_LOCAL_LOOPBACK_ABILITYf_GET
#define IEEE0_PMA_PMD_BLK0_STSr_PMA_LOCAL_LOOPBACK_ABILITYf_SET BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr_PMA_LOCAL_LOOPBACK_ABILITYf_SET
#define READ_IEEE0_PMA_PMD_BLK0_STSr BCMI_MADURA_READ_IEEE0_PMA_PMD_BLK0_STSr
#define WRITE_IEEE0_PMA_PMD_BLK0_STSr BCMI_MADURA_WRITE_IEEE0_PMA_PMD_BLK0_STSr
#define MODIFY_IEEE0_PMA_PMD_BLK0_STSr BCMI_MADURA_MODIFY_IEEE0_PMA_PMD_BLK0_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_IEEE0_PMA_PMD_BLK0_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_TRANSMIT_DIS
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x0009
 * DEVAD:    1
 * DESC:     ieee Transmit Disable register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GLOBAL_PMDTRANSMIT_DISABLE 1 = Disable transmitter output.Disables the transmitter on all four lanes in single pmd.Disables the transmitter on the applicablelane in muti pmd mode.
 *     PMD_TRANSMITDISABLE_0 1 = Disable output on transmit lane0Used in single pmd. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_1 1 = Disable output on transmit lane1Used in single pmd modes. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_2 1 = Disable output on transmit lane2Used in single pmd modes. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_3 1 = Disable output on transmit lane3Used in single pmd. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_4 1 = Disable output on transmit lane4Used in single pmd. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_5 1 = Disable output on transmit lane5Used in single pmd modes. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_6 1 = Disable output on transmit lane6Used in single pmd modes. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_7 1 = Disable output on transmit lane7Used in single pmd. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_8 1 = Disable output on transmit lane8Used in single pmd modes. Not applicable in multi pmd mode.
 *     PMD_TRANSMITDISABLE_9 1 = Disable output on transmit lane9Used in single pmd. Not applicable in multi pmd mode.
 */
#define BCMI_MADURA_PMD_TRANSMIT_DISr (0x00010009 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_TRANSMIT_DISr_SIZE 4

/*
 * This structure should be used to declare and program PMD_TRANSMIT_DIS.
 */
typedef union BCMI_MADURA_PMD_TRANSMIT_DISr_s {
	uint32_t v[1];
	uint32_t pmd_transmit_dis[1];
	uint32_t _pmd_transmit_dis;
} BCMI_MADURA_PMD_TRANSMIT_DISr_t;

#define BCMI_MADURA_PMD_TRANSMIT_DISr_CLR(r) (r).pmd_transmit_dis[0] = 0
#define BCMI_MADURA_PMD_TRANSMIT_DISr_SET(r,d) (r).pmd_transmit_dis[0] = d
#define BCMI_MADURA_PMD_TRANSMIT_DISr_GET(r) (r).pmd_transmit_dis[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_9f_GET(r) ((((r).pmd_transmit_dis[0]) >> 10) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_9f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_8f_GET(r) ((((r).pmd_transmit_dis[0]) >> 9) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_8f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_7f_GET(r) ((((r).pmd_transmit_dis[0]) >> 8) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_7f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_6f_GET(r) ((((r).pmd_transmit_dis[0]) >> 7) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_6f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_5f_GET(r) ((((r).pmd_transmit_dis[0]) >> 6) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_5f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_4f_GET(r) ((((r).pmd_transmit_dis[0]) >> 5) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_4f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_3f_GET(r) ((((r).pmd_transmit_dis[0]) >> 4) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_3f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_2f_GET(r) ((((r).pmd_transmit_dis[0]) >> 3) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_2f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_1f_GET(r) ((((r).pmd_transmit_dis[0]) >> 2) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_1f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_0f_GET(r) ((((r).pmd_transmit_dis[0]) >> 1) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_0f_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PMD_TRANSMIT_DISr_GLOBAL_PMDTRANSMIT_DISABLEf_GET(r) (((r).pmd_transmit_dis[0]) & 0x1)
#define BCMI_MADURA_PMD_TRANSMIT_DISr_GLOBAL_PMDTRANSMIT_DISABLEf_SET(r,f) (r).pmd_transmit_dis[0]=(((r).pmd_transmit_dis[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_TRANSMIT_DIS.
 */
#define BCMI_MADURA_READ_PMD_TRANSMIT_DISr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_TRANSMIT_DISr,_r._pmd_transmit_dis)
#define BCMI_MADURA_WRITE_PMD_TRANSMIT_DISr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_TRANSMIT_DISr,_r._pmd_transmit_dis)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_TRANSMIT_DISr BCMI_MADURA_PMD_TRANSMIT_DISr
#define PMD_TRANSMIT_DISr_SIZE BCMI_MADURA_PMD_TRANSMIT_DISr_SIZE
typedef BCMI_MADURA_PMD_TRANSMIT_DISr_t PMD_TRANSMIT_DISr_t;
#define PMD_TRANSMIT_DISr_CLR BCMI_MADURA_PMD_TRANSMIT_DISr_CLR
#define PMD_TRANSMIT_DISr_SET BCMI_MADURA_PMD_TRANSMIT_DISr_SET
#define PMD_TRANSMIT_DISr_GET BCMI_MADURA_PMD_TRANSMIT_DISr_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_9f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_9f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_9f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_9f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_8f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_8f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_8f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_8f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_7f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_7f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_7f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_7f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_6f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_6f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_6f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_6f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_5f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_5f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_5f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_5f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_4f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_4f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_4f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_4f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_3f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_3f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_3f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_3f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_2f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_2f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_2f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_2f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_1f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_1f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_1f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_1f_SET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_0f_GET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_0f_GET
#define PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_0f_SET BCMI_MADURA_PMD_TRANSMIT_DISr_PMD_TRANSMITDISABLE_0f_SET
#define PMD_TRANSMIT_DISr_GLOBAL_PMDTRANSMIT_DISABLEf_GET BCMI_MADURA_PMD_TRANSMIT_DISr_GLOBAL_PMDTRANSMIT_DISABLEf_GET
#define PMD_TRANSMIT_DISr_GLOBAL_PMDTRANSMIT_DISABLEf_SET BCMI_MADURA_PMD_TRANSMIT_DISr_GLOBAL_PMDTRANSMIT_DISABLEf_SET
#define READ_PMD_TRANSMIT_DISr BCMI_MADURA_READ_PMD_TRANSMIT_DISr
#define WRITE_PMD_TRANSMIT_DISr BCMI_MADURA_WRITE_PMD_TRANSMIT_DISr
#define MODIFY_PMD_TRANSMIT_DISr BCMI_MADURA_MODIFY_PMD_TRANSMIT_DISr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_TRANSMIT_DISr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_RECEIVE_SIGNAL_DETECT
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x000a
 * DEVAD:    1
 * DESC:     ieee receive Signal Detect register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GLOBAL_PMDRECEIVE_SIGNAL_OK 1 = Signal OK on receive.In single pmd mode indicatesa signal is present on all four lanes.In multi pmd mode indicates a signal ispresent on the applicable lane.
 *     PMD_RECEIVESIGNAL_DETECT_0 1 = Signal detected on receive lane 0Not applicable in multi pmd mode.
 *     PMD_RECEIVESIGNAL_DETECT_1 1 = Signal detected on receive lane 1Not applicable in multi pmd mode.
 *     PMD_RECEIVESIGNAL_DETECT_2 1 = Signal detected on receive lane 2Not applicable in multi pmd mode.
 *     PMD_RECEIVESIGNAL_DETECT_3 1 = Signal detected on receive lane 3Not applicable in multi pmd mode.
 */
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr (0x0001000a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_SIZE 4

/*
 * This structure should be used to declare and program PMD_RECEIVE_SIGNAL_DETECT.
 */
typedef union BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_s {
	uint32_t v[1];
	uint32_t pmd_receive_signal_detect[1];
	uint32_t _pmd_receive_signal_detect;
} BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_t;

#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_CLR(r) (r).pmd_receive_signal_detect[0] = 0
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_SET(r,d) (r).pmd_receive_signal_detect[0] = d
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_GET(r) (r).pmd_receive_signal_detect[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_3f_GET(r) ((((r).pmd_receive_signal_detect[0]) >> 4) & 0x1)
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_3f_SET(r,f) (r).pmd_receive_signal_detect[0]=(((r).pmd_receive_signal_detect[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_2f_GET(r) ((((r).pmd_receive_signal_detect[0]) >> 3) & 0x1)
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_2f_SET(r,f) (r).pmd_receive_signal_detect[0]=(((r).pmd_receive_signal_detect[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_1f_GET(r) ((((r).pmd_receive_signal_detect[0]) >> 2) & 0x1)
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_1f_SET(r,f) (r).pmd_receive_signal_detect[0]=(((r).pmd_receive_signal_detect[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_0f_GET(r) ((((r).pmd_receive_signal_detect[0]) >> 1) & 0x1)
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_0f_SET(r,f) (r).pmd_receive_signal_detect[0]=(((r).pmd_receive_signal_detect[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_GLOBAL_PMDRECEIVE_SIGNAL_OKf_GET(r) (((r).pmd_receive_signal_detect[0]) & 0x1)
#define BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_GLOBAL_PMDRECEIVE_SIGNAL_OKf_SET(r,f) (r).pmd_receive_signal_detect[0]=(((r).pmd_receive_signal_detect[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_RECEIVE_SIGNAL_DETECT.
 */
#define BCMI_MADURA_READ_PMD_RECEIVE_SIGNAL_DETECTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr,_r._pmd_receive_signal_detect)
#define BCMI_MADURA_WRITE_PMD_RECEIVE_SIGNAL_DETECTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr,_r._pmd_receive_signal_detect)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_RECEIVE_SIGNAL_DETECTr BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr
#define PMD_RECEIVE_SIGNAL_DETECTr_SIZE BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_SIZE
typedef BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_t PMD_RECEIVE_SIGNAL_DETECTr_t;
#define PMD_RECEIVE_SIGNAL_DETECTr_CLR BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_CLR
#define PMD_RECEIVE_SIGNAL_DETECTr_SET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_SET
#define PMD_RECEIVE_SIGNAL_DETECTr_GET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_GET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_3f_GET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_3f_GET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_3f_SET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_3f_SET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_2f_GET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_2f_GET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_2f_SET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_2f_SET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_1f_GET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_1f_GET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_1f_SET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_1f_SET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_0f_GET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_0f_GET
#define PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_0f_SET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_PMD_RECEIVESIGNAL_DETECT_0f_SET
#define PMD_RECEIVE_SIGNAL_DETECTr_GLOBAL_PMDRECEIVE_SIGNAL_OKf_GET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_GLOBAL_PMDRECEIVE_SIGNAL_OKf_GET
#define PMD_RECEIVE_SIGNAL_DETECTr_GLOBAL_PMDRECEIVE_SIGNAL_OKf_SET BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr_GLOBAL_PMDRECEIVE_SIGNAL_OKf_SET
#define READ_PMD_RECEIVE_SIGNAL_DETECTr BCMI_MADURA_READ_PMD_RECEIVE_SIGNAL_DETECTr
#define WRITE_PMD_RECEIVE_SIGNAL_DETECTr BCMI_MADURA_WRITE_PMD_RECEIVE_SIGNAL_DETECTr
#define MODIFY_PMD_RECEIVE_SIGNAL_DETECTr BCMI_MADURA_MODIFY_PMD_RECEIVE_SIGNAL_DETECTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_RECEIVE_SIGNAL_DETECTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_EXTENDED_ABIL
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x000b
 * DEVAD:    1
 * DESC:     ieee Extended Ability register
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/W
 * FIELDS:
 *     TENGBASE_CX4_ABILITY 1 = PMD is able to perform 10GBASE-CX4Reset value is 0 in multi pmd modeReset value is 0 in single pmd mode
 *     TENGBASE_LRM_ABILITY 1 = PMD is able to perform 10GBASE-LRM
 *     TENGBASE_T_ABILITY 1 = PMD is able to perform 10GBASE-T
 *     TENGBASE_KX4_ABILITY 1 = PMD is able to perform TENGBASE-KX4
 *     TENGBASE_KR_ABILITY 1 = PMD is able to perform TENGBASE-KR
 *     GIGBASE_T_ABILITY 1 = PMD is able to perform 1000BASE-T
 *     GIGBASE_KX_ABILITY 1 = PMD is able to perform GIGBASE-KX
 *     HUNDREDBASE_TX_ABILITY 1 = PMD is able to perform 100BASE-TX
 *     TENBASE_T_ABILITY 1 = PMD is able to perform 10BASE-T
 *     FORTYGBASE_ABILITY 1 = PMD supports the extended 40G/100G abilitiesas defined in 40G Extended Ability Register (1.13).
 */
#define BCMI_MADURA_PMD_EXTENDED_ABILr (0x0001000b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_EXTENDED_ABILr_SIZE 4

/*
 * This structure should be used to declare and program PMD_EXTENDED_ABIL.
 */
typedef union BCMI_MADURA_PMD_EXTENDED_ABILr_s {
	uint32_t v[1];
	uint32_t pmd_extended_abil[1];
	uint32_t _pmd_extended_abil;
} BCMI_MADURA_PMD_EXTENDED_ABILr_t;

#define BCMI_MADURA_PMD_EXTENDED_ABILr_CLR(r) (r).pmd_extended_abil[0] = 0
#define BCMI_MADURA_PMD_EXTENDED_ABILr_SET(r,d) (r).pmd_extended_abil[0] = d
#define BCMI_MADURA_PMD_EXTENDED_ABILr_GET(r) (r).pmd_extended_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_EXTENDED_ABILr_FORTYGBASE_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 10) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_FORTYGBASE_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENBASE_T_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 8) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENBASE_T_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_HUNDREDBASE_TX_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 7) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_HUNDREDBASE_TX_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_KX_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 6) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_KX_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_T_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 5) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_T_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KR_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 4) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KR_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KX4_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 3) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KX4_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_T_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 2) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_T_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_LRM_ABILITYf_GET(r) ((((r).pmd_extended_abil[0]) >> 1) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_LRM_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_CX4_ABILITYf_GET(r) (((r).pmd_extended_abil[0]) & 0x1)
#define BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_CX4_ABILITYf_SET(r,f) (r).pmd_extended_abil[0]=(((r).pmd_extended_abil[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_EXTENDED_ABIL.
 */
#define BCMI_MADURA_READ_PMD_EXTENDED_ABILr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_EXTENDED_ABILr,_r._pmd_extended_abil)
#define BCMI_MADURA_WRITE_PMD_EXTENDED_ABILr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_EXTENDED_ABILr,_r._pmd_extended_abil)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_EXTENDED_ABILr BCMI_MADURA_PMD_EXTENDED_ABILr
#define PMD_EXTENDED_ABILr_SIZE BCMI_MADURA_PMD_EXTENDED_ABILr_SIZE
typedef BCMI_MADURA_PMD_EXTENDED_ABILr_t PMD_EXTENDED_ABILr_t;
#define PMD_EXTENDED_ABILr_CLR BCMI_MADURA_PMD_EXTENDED_ABILr_CLR
#define PMD_EXTENDED_ABILr_SET BCMI_MADURA_PMD_EXTENDED_ABILr_SET
#define PMD_EXTENDED_ABILr_GET BCMI_MADURA_PMD_EXTENDED_ABILr_GET
#define PMD_EXTENDED_ABILr_FORTYGBASE_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_FORTYGBASE_ABILITYf_GET
#define PMD_EXTENDED_ABILr_FORTYGBASE_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_FORTYGBASE_ABILITYf_SET
#define PMD_EXTENDED_ABILr_TENBASE_T_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_TENBASE_T_ABILITYf_GET
#define PMD_EXTENDED_ABILr_TENBASE_T_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_TENBASE_T_ABILITYf_SET
#define PMD_EXTENDED_ABILr_HUNDREDBASE_TX_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_HUNDREDBASE_TX_ABILITYf_GET
#define PMD_EXTENDED_ABILr_HUNDREDBASE_TX_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_HUNDREDBASE_TX_ABILITYf_SET
#define PMD_EXTENDED_ABILr_GIGBASE_KX_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_KX_ABILITYf_GET
#define PMD_EXTENDED_ABILr_GIGBASE_KX_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_KX_ABILITYf_SET
#define PMD_EXTENDED_ABILr_GIGBASE_T_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_T_ABILITYf_GET
#define PMD_EXTENDED_ABILr_GIGBASE_T_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_GIGBASE_T_ABILITYf_SET
#define PMD_EXTENDED_ABILr_TENGBASE_KR_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KR_ABILITYf_GET
#define PMD_EXTENDED_ABILr_TENGBASE_KR_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KR_ABILITYf_SET
#define PMD_EXTENDED_ABILr_TENGBASE_KX4_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KX4_ABILITYf_GET
#define PMD_EXTENDED_ABILr_TENGBASE_KX4_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_KX4_ABILITYf_SET
#define PMD_EXTENDED_ABILr_TENGBASE_T_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_T_ABILITYf_GET
#define PMD_EXTENDED_ABILr_TENGBASE_T_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_T_ABILITYf_SET
#define PMD_EXTENDED_ABILr_TENGBASE_LRM_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_LRM_ABILITYf_GET
#define PMD_EXTENDED_ABILr_TENGBASE_LRM_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_LRM_ABILITYf_SET
#define PMD_EXTENDED_ABILr_TENGBASE_CX4_ABILITYf_GET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_CX4_ABILITYf_GET
#define PMD_EXTENDED_ABILr_TENGBASE_CX4_ABILITYf_SET BCMI_MADURA_PMD_EXTENDED_ABILr_TENGBASE_CX4_ABILITYf_SET
#define READ_PMD_EXTENDED_ABILr BCMI_MADURA_READ_PMD_EXTENDED_ABILr
#define WRITE_PMD_EXTENDED_ABILr BCMI_MADURA_WRITE_PMD_EXTENDED_ABILr
#define MODIFY_PMD_EXTENDED_ABILr BCMI_MADURA_MODIFY_PMD_EXTENDED_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_EXTENDED_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FORTYG_PMD_EXTENDED_ABIL
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x000d
 * DEVAD:    1
 * DESC:     Fortyg PMD extended ability Register
 * RESETVAL: 0xec0f (60431)
 * ACCESS:   R/W
 * FIELDS:
 *     FORTYGBASE_KR4_ABILITY 1 = PMD is able to perform  40 Gb KR4
 *     FORTYGBASE_CR4_ABILITY 1 = PMD is able to perform  40 Gb CR4
 *     FORTYGBASE_SR4_ABILITY 1 = PMD is able to perform  40 Gb SR4
 *     FORTYGBASE_LR4_ABILITY 1 = PMD is able to perform  40 Gb LR4
 *     FORTYGBASE_FR_ABILITY 1 = PMD is able to perform  40 Gb FR
 *     ONE_HUNDREDGBASE_CR10_ABILITY 1 = PMD is able to perform  100 Gb CR10
 *     ONE_HUNDREDGBASE_SR10_ABILITY 1 = PMD is able to perform  100 Gb SR10
 *     ONE_HUNDREDGBASE_LR4_ABILITY 1 = PMD is able to perform  100 Gb LR4
 *     ONE_HUNDREDGBASE_ER4_ABILITY 1 = PMD is able to perform  100 Gb ER4
 *     ONE_HUNDREDGBASE_KP4_ABILITY 1 = PMD is able to perform  100 Gb KP4
 *     ONE_HUNDREDGBASE_KR4_ABILITY 1 = PMD is able to perform  100 Gb KR4
 *     ONE_HUNDREDGBASE_CR4_ABILITY 1 = PMD is able to perform  100 Gb CR4
 *     PMA_REMOTE_LOOPBACK_ABILITY 1 = PMA is able to perform remote loopback
 */
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr (0x0001000d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_SIZE 4

/*
 * This structure should be used to declare and program FORTYG_PMD_EXTENDED_ABIL.
 */
typedef union BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_s {
	uint32_t v[1];
	uint32_t fortyg_pmd_extended_abil[1];
	uint32_t _fortyg_pmd_extended_abil;
} BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_t;

#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_CLR(r) (r).fortyg_pmd_extended_abil[0] = 0
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_SET(r,d) (r).fortyg_pmd_extended_abil[0] = d
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_GET(r) (r).fortyg_pmd_extended_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_PMA_REMOTE_LOOPBACK_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 15) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_PMA_REMOTE_LOOPBACK_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 14) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KR4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 13) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KR4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KP4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 12) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KP4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_ER4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 11) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_ER4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_LR4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 10) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_LR4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_SR10_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 9) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_SR10_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR10_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 8) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR10_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_FR_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 4) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_FR_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_LR4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 3) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_LR4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_SR4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 2) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_SR4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_CR4_ABILITYf_GET(r) ((((r).fortyg_pmd_extended_abil[0]) >> 1) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_CR4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_KR4_ABILITYf_GET(r) (((r).fortyg_pmd_extended_abil[0]) & 0x1)
#define BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_KR4_ABILITYf_SET(r,f) (r).fortyg_pmd_extended_abil[0]=(((r).fortyg_pmd_extended_abil[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FORTYG_PMD_EXTENDED_ABIL.
 */
#define BCMI_MADURA_READ_FORTYG_PMD_EXTENDED_ABILr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr,_r._fortyg_pmd_extended_abil)
#define BCMI_MADURA_WRITE_FORTYG_PMD_EXTENDED_ABILr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr,_r._fortyg_pmd_extended_abil)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FORTYG_PMD_EXTENDED_ABILr BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr
#define FORTYG_PMD_EXTENDED_ABILr_SIZE BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_SIZE
typedef BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_t FORTYG_PMD_EXTENDED_ABILr_t;
#define FORTYG_PMD_EXTENDED_ABILr_CLR BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_CLR
#define FORTYG_PMD_EXTENDED_ABILr_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_SET
#define FORTYG_PMD_EXTENDED_ABILr_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_GET
#define FORTYG_PMD_EXTENDED_ABILr_PMA_REMOTE_LOOPBACK_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_PMA_REMOTE_LOOPBACK_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_PMA_REMOTE_LOOPBACK_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_PMA_REMOTE_LOOPBACK_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KR4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KR4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KR4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KR4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KP4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KP4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KP4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_KP4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_ER4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_ER4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_ER4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_ER4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_LR4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_LR4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_LR4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_LR4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_SR10_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_SR10_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_SR10_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_SR10_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR10_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR10_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR10_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_ONE_HUNDREDGBASE_CR10_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_FR_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_FR_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_FR_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_FR_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_LR4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_LR4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_LR4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_LR4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_SR4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_SR4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_SR4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_SR4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_CR4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_CR4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_CR4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_CR4_ABILITYf_SET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_KR4_ABILITYf_GET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_KR4_ABILITYf_GET
#define FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_KR4_ABILITYf_SET BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr_FORTYGBASE_KR4_ABILITYf_SET
#define READ_FORTYG_PMD_EXTENDED_ABILr BCMI_MADURA_READ_FORTYG_PMD_EXTENDED_ABILr
#define WRITE_FORTYG_PMD_EXTENDED_ABILr BCMI_MADURA_WRITE_FORTYG_PMD_EXTENDED_ABILr
#define MODIFY_FORTYG_PMD_EXTENDED_ABILr BCMI_MADURA_MODIFY_FORTYG_PMD_EXTENDED_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FORTYG_PMD_EXTENDED_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_OUI_ID0
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x000e
 * DEVAD:    1
 * DESC:     PMD OUI ID0 Register
 * RESETVAL: 0xae02 (44546)
 * ACCESS:   R/W
 * FIELDS:
 *     DEVICE_ID_0      PHY ID High
 */
#define BCMI_MADURA_PMD_OUI_ID0r (0x0001000e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_OUI_ID0r_SIZE 4

/*
 * This structure should be used to declare and program PMD_OUI_ID0.
 */
typedef union BCMI_MADURA_PMD_OUI_ID0r_s {
	uint32_t v[1];
	uint32_t pmd_oui_id0[1];
	uint32_t _pmd_oui_id0;
} BCMI_MADURA_PMD_OUI_ID0r_t;

#define BCMI_MADURA_PMD_OUI_ID0r_CLR(r) (r).pmd_oui_id0[0] = 0
#define BCMI_MADURA_PMD_OUI_ID0r_SET(r,d) (r).pmd_oui_id0[0] = d
#define BCMI_MADURA_PMD_OUI_ID0r_GET(r) (r).pmd_oui_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_OUI_ID0r_DEVICE_ID_0f_GET(r) (((r).pmd_oui_id0[0]) & 0xffff)
#define BCMI_MADURA_PMD_OUI_ID0r_DEVICE_ID_0f_SET(r,f) (r).pmd_oui_id0[0]=(((r).pmd_oui_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_OUI_ID0.
 */
#define BCMI_MADURA_READ_PMD_OUI_ID0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_OUI_ID0r,_r._pmd_oui_id0)
#define BCMI_MADURA_WRITE_PMD_OUI_ID0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_OUI_ID0r,_r._pmd_oui_id0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_OUI_ID0r BCMI_MADURA_PMD_OUI_ID0r
#define PMD_OUI_ID0r_SIZE BCMI_MADURA_PMD_OUI_ID0r_SIZE
typedef BCMI_MADURA_PMD_OUI_ID0r_t PMD_OUI_ID0r_t;
#define PMD_OUI_ID0r_CLR BCMI_MADURA_PMD_OUI_ID0r_CLR
#define PMD_OUI_ID0r_SET BCMI_MADURA_PMD_OUI_ID0r_SET
#define PMD_OUI_ID0r_GET BCMI_MADURA_PMD_OUI_ID0r_GET
#define PMD_OUI_ID0r_DEVICE_ID_0f_GET BCMI_MADURA_PMD_OUI_ID0r_DEVICE_ID_0f_GET
#define PMD_OUI_ID0r_DEVICE_ID_0f_SET BCMI_MADURA_PMD_OUI_ID0r_DEVICE_ID_0f_SET
#define READ_PMD_OUI_ID0r BCMI_MADURA_READ_PMD_OUI_ID0r
#define WRITE_PMD_OUI_ID0r BCMI_MADURA_WRITE_PMD_OUI_ID0r
#define MODIFY_PMD_OUI_ID0r BCMI_MADURA_MODIFY_PMD_OUI_ID0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_OUI_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_OUI_ID1
 * BLOCKS:   IEEE0_PMA_PMD_BLK0
 * REGADDR:  0x000f
 * DEVAD:    1
 * DESC:     PMD OUI ID1 Reg
 * RESETVAL: 0x52b0 (21168)
 * ACCESS:   R/W
 * FIELDS:
 *     DEVICE_ID_1      PHY ID LOW
 */
#define BCMI_MADURA_PMD_OUI_ID1r (0x0001000f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_OUI_ID1r_SIZE 4

/*
 * This structure should be used to declare and program PMD_OUI_ID1.
 */
typedef union BCMI_MADURA_PMD_OUI_ID1r_s {
	uint32_t v[1];
	uint32_t pmd_oui_id1[1];
	uint32_t _pmd_oui_id1;
} BCMI_MADURA_PMD_OUI_ID1r_t;

#define BCMI_MADURA_PMD_OUI_ID1r_CLR(r) (r).pmd_oui_id1[0] = 0
#define BCMI_MADURA_PMD_OUI_ID1r_SET(r,d) (r).pmd_oui_id1[0] = d
#define BCMI_MADURA_PMD_OUI_ID1r_GET(r) (r).pmd_oui_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_OUI_ID1r_DEVICE_ID_1f_GET(r) (((r).pmd_oui_id1[0]) & 0xffff)
#define BCMI_MADURA_PMD_OUI_ID1r_DEVICE_ID_1f_SET(r,f) (r).pmd_oui_id1[0]=(((r).pmd_oui_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_OUI_ID1.
 */
#define BCMI_MADURA_READ_PMD_OUI_ID1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_OUI_ID1r,_r._pmd_oui_id1)
#define BCMI_MADURA_WRITE_PMD_OUI_ID1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_OUI_ID1r,_r._pmd_oui_id1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_OUI_ID1r BCMI_MADURA_PMD_OUI_ID1r
#define PMD_OUI_ID1r_SIZE BCMI_MADURA_PMD_OUI_ID1r_SIZE
typedef BCMI_MADURA_PMD_OUI_ID1r_t PMD_OUI_ID1r_t;
#define PMD_OUI_ID1r_CLR BCMI_MADURA_PMD_OUI_ID1r_CLR
#define PMD_OUI_ID1r_SET BCMI_MADURA_PMD_OUI_ID1r_SET
#define PMD_OUI_ID1r_GET BCMI_MADURA_PMD_OUI_ID1r_GET
#define PMD_OUI_ID1r_DEVICE_ID_1f_GET BCMI_MADURA_PMD_OUI_ID1r_DEVICE_ID_1f_GET
#define PMD_OUI_ID1r_DEVICE_ID_1f_SET BCMI_MADURA_PMD_OUI_ID1r_DEVICE_ID_1f_SET
#define READ_PMD_OUI_ID1r BCMI_MADURA_READ_PMD_OUI_ID1r
#define WRITE_PMD_OUI_ID1r BCMI_MADURA_WRITE_PMD_OUI_ID1r
#define MODIFY_PMD_OUI_ID1r BCMI_MADURA_MODIFY_PMD_OUI_ID1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_OUI_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_CTL
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00c8
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_BYP_CORR_EN  1 = FEC decoder performs detection without error correction0 = FEC decoder performs detection and error correction
 *     FEC_BYP_IND_EN   1 = FEC decoder does not indicate errors to the PCS layer0 = FEC decoder indicates errors to the PCSThis feature is not supported in this chip. Always program 0.
 */
#define BCMI_MADURA_FEC_CTLr (0x000100c8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program FEC_CTL.
 */
typedef union BCMI_MADURA_FEC_CTLr_s {
	uint32_t v[1];
	uint32_t fec_ctl[1];
	uint32_t _fec_ctl;
} BCMI_MADURA_FEC_CTLr_t;

#define BCMI_MADURA_FEC_CTLr_CLR(r) (r).fec_ctl[0] = 0
#define BCMI_MADURA_FEC_CTLr_SET(r,d) (r).fec_ctl[0] = d
#define BCMI_MADURA_FEC_CTLr_GET(r) (r).fec_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_CTLr_FEC_BYP_IND_ENf_GET(r) ((((r).fec_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_FEC_CTLr_FEC_BYP_IND_ENf_SET(r,f) (r).fec_ctl[0]=(((r).fec_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FEC_CTLr_FEC_BYP_CORR_ENf_GET(r) (((r).fec_ctl[0]) & 0x1)
#define BCMI_MADURA_FEC_CTLr_FEC_BYP_CORR_ENf_SET(r,f) (r).fec_ctl[0]=(((r).fec_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FEC_CTL.
 */
#define BCMI_MADURA_READ_FEC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_CTLr,_r._fec_ctl)
#define BCMI_MADURA_WRITE_FEC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_CTLr,_r._fec_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_CTLr BCMI_MADURA_FEC_CTLr
#define FEC_CTLr_SIZE BCMI_MADURA_FEC_CTLr_SIZE
typedef BCMI_MADURA_FEC_CTLr_t FEC_CTLr_t;
#define FEC_CTLr_CLR BCMI_MADURA_FEC_CTLr_CLR
#define FEC_CTLr_SET BCMI_MADURA_FEC_CTLr_SET
#define FEC_CTLr_GET BCMI_MADURA_FEC_CTLr_GET
#define FEC_CTLr_FEC_BYP_IND_ENf_GET BCMI_MADURA_FEC_CTLr_FEC_BYP_IND_ENf_GET
#define FEC_CTLr_FEC_BYP_IND_ENf_SET BCMI_MADURA_FEC_CTLr_FEC_BYP_IND_ENf_SET
#define FEC_CTLr_FEC_BYP_CORR_ENf_GET BCMI_MADURA_FEC_CTLr_FEC_BYP_CORR_ENf_GET
#define FEC_CTLr_FEC_BYP_CORR_ENf_SET BCMI_MADURA_FEC_CTLr_FEC_BYP_CORR_ENf_SET
#define READ_FEC_CTLr BCMI_MADURA_READ_FEC_CTLr
#define WRITE_FEC_CTLr BCMI_MADURA_WRITE_FEC_CTLr
#define MODIFY_FEC_CTLr BCMI_MADURA_MODIFY_FEC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_STS
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00c9
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_STATUS
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_BYP_CORR_ABILITY 1 = FEC decoder has ability to bypass error correction0 = FEC decoder does not have ability to bypass error correction
 *     FEC_BYP_IND_ABILITY 1 = FEC decoder has ability to bypass error indication0 = FEC decoder does not have ability to bypass error indicationThis feature is not supported in this chip.
 *     HIGH_SER         1 = FEC errors have exceeded threshold0 = FEC errors have not exceeded thresholdfec_byp_ind_en = 1 is not supported in this chip.Will always read a 0
 *     FEC_ALIGN_STATUS 1 = RS FEC receive lanes locked and aligned0 = RS FEC receive lanes not locked and aligned
 *     PCS_ALIGN_STATUS 1 = FEC transmitter has locked and aligned all PCS lanes0 = FEC transmitter has not locked and aligned all PCS lanes
 */
#define BCMI_MADURA_FEC_STSr (0x000100c9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_STSr_SIZE 4

/*
 * This structure should be used to declare and program FEC_STS.
 */
typedef union BCMI_MADURA_FEC_STSr_s {
	uint32_t v[1];
	uint32_t fec_sts[1];
	uint32_t _fec_sts;
} BCMI_MADURA_FEC_STSr_t;

#define BCMI_MADURA_FEC_STSr_CLR(r) (r).fec_sts[0] = 0
#define BCMI_MADURA_FEC_STSr_SET(r,d) (r).fec_sts[0] = d
#define BCMI_MADURA_FEC_STSr_GET(r) (r).fec_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_STSr_PCS_ALIGN_STATUSf_GET(r) ((((r).fec_sts[0]) >> 15) & 0x1)
#define BCMI_MADURA_FEC_STSr_PCS_ALIGN_STATUSf_SET(r,f) (r).fec_sts[0]=(((r).fec_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_FEC_STSr_FEC_ALIGN_STATUSf_GET(r) ((((r).fec_sts[0]) >> 14) & 0x1)
#define BCMI_MADURA_FEC_STSr_FEC_ALIGN_STATUSf_SET(r,f) (r).fec_sts[0]=(((r).fec_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_FEC_STSr_HIGH_SERf_GET(r) ((((r).fec_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_FEC_STSr_HIGH_SERf_SET(r,f) (r).fec_sts[0]=(((r).fec_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FEC_STSr_FEC_BYP_IND_ABILITYf_GET(r) ((((r).fec_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_FEC_STSr_FEC_BYP_IND_ABILITYf_SET(r,f) (r).fec_sts[0]=(((r).fec_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FEC_STSr_FEC_BYP_CORR_ABILITYf_GET(r) (((r).fec_sts[0]) & 0x1)
#define BCMI_MADURA_FEC_STSr_FEC_BYP_CORR_ABILITYf_SET(r,f) (r).fec_sts[0]=(((r).fec_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FEC_STS.
 */
#define BCMI_MADURA_READ_FEC_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_STSr,_r._fec_sts)
#define BCMI_MADURA_WRITE_FEC_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_STSr,_r._fec_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_STSr BCMI_MADURA_FEC_STSr
#define FEC_STSr_SIZE BCMI_MADURA_FEC_STSr_SIZE
typedef BCMI_MADURA_FEC_STSr_t FEC_STSr_t;
#define FEC_STSr_CLR BCMI_MADURA_FEC_STSr_CLR
#define FEC_STSr_SET BCMI_MADURA_FEC_STSr_SET
#define FEC_STSr_GET BCMI_MADURA_FEC_STSr_GET
#define FEC_STSr_PCS_ALIGN_STATUSf_GET BCMI_MADURA_FEC_STSr_PCS_ALIGN_STATUSf_GET
#define FEC_STSr_PCS_ALIGN_STATUSf_SET BCMI_MADURA_FEC_STSr_PCS_ALIGN_STATUSf_SET
#define FEC_STSr_FEC_ALIGN_STATUSf_GET BCMI_MADURA_FEC_STSr_FEC_ALIGN_STATUSf_GET
#define FEC_STSr_FEC_ALIGN_STATUSf_SET BCMI_MADURA_FEC_STSr_FEC_ALIGN_STATUSf_SET
#define FEC_STSr_HIGH_SERf_GET BCMI_MADURA_FEC_STSr_HIGH_SERf_GET
#define FEC_STSr_HIGH_SERf_SET BCMI_MADURA_FEC_STSr_HIGH_SERf_SET
#define FEC_STSr_FEC_BYP_IND_ABILITYf_GET BCMI_MADURA_FEC_STSr_FEC_BYP_IND_ABILITYf_GET
#define FEC_STSr_FEC_BYP_IND_ABILITYf_SET BCMI_MADURA_FEC_STSr_FEC_BYP_IND_ABILITYf_SET
#define FEC_STSr_FEC_BYP_CORR_ABILITYf_GET BCMI_MADURA_FEC_STSr_FEC_BYP_CORR_ABILITYf_GET
#define FEC_STSr_FEC_BYP_CORR_ABILITYf_SET BCMI_MADURA_FEC_STSr_FEC_BYP_CORR_ABILITYf_SET
#define READ_FEC_STSr BCMI_MADURA_READ_FEC_STSr
#define WRITE_FEC_STSr BCMI_MADURA_WRITE_FEC_STSr
#define MODIFY_FEC_STSr BCMI_MADURA_MODIFY_FEC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_CORR_CW_CNT_LWR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00ca
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_CORR_CW_CNT_LOWER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_CORR_CW_CNT_LOWER These bits shall be reset to all zeros when the register is read by the management function or upon PHY reset. These bits shall be held at all ones in the case of overflow. Registers 1.202, 1.203 are used to read the value of a 32-bit counter. When registers 1.202 and 1.203 are used to read the 32-bit counter value, the register 1.202 is read first, the value of the register 1.203 is latched when (and only when) register 1.202 is read and reads of register 1.203 returns the latched value rather than the current value of the counter.
 */
#define BCMI_MADURA_FEC_CORR_CW_CNT_LWRr (0x000100ca | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_CORR_CW_CNT_LWR.
 */
typedef union BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_s {
	uint32_t v[1];
	uint32_t fec_corr_cw_cnt_lwr[1];
	uint32_t _fec_corr_cw_cnt_lwr;
} BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_t;

#define BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_CLR(r) (r).fec_corr_cw_cnt_lwr[0] = 0
#define BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_SET(r,d) (r).fec_corr_cw_cnt_lwr[0] = d
#define BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_GET(r) (r).fec_corr_cw_cnt_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_FEC_CORR_CW_CNT_LOWERf_GET(r) (((r).fec_corr_cw_cnt_lwr[0]) & 0xffff)
#define BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_FEC_CORR_CW_CNT_LOWERf_SET(r,f) (r).fec_corr_cw_cnt_lwr[0]=(((r).fec_corr_cw_cnt_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_CORR_CW_CNT_LWR.
 */
#define BCMI_MADURA_READ_FEC_CORR_CW_CNT_LWRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_CORR_CW_CNT_LWRr,_r._fec_corr_cw_cnt_lwr)
#define BCMI_MADURA_WRITE_FEC_CORR_CW_CNT_LWRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_CORR_CW_CNT_LWRr,_r._fec_corr_cw_cnt_lwr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_CORR_CW_CNT_LWRr BCMI_MADURA_FEC_CORR_CW_CNT_LWRr
#define FEC_CORR_CW_CNT_LWRr_SIZE BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_SIZE
typedef BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_t FEC_CORR_CW_CNT_LWRr_t;
#define FEC_CORR_CW_CNT_LWRr_CLR BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_CLR
#define FEC_CORR_CW_CNT_LWRr_SET BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_SET
#define FEC_CORR_CW_CNT_LWRr_GET BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_GET
#define FEC_CORR_CW_CNT_LWRr_FEC_CORR_CW_CNT_LOWERf_GET BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_FEC_CORR_CW_CNT_LOWERf_GET
#define FEC_CORR_CW_CNT_LWRr_FEC_CORR_CW_CNT_LOWERf_SET BCMI_MADURA_FEC_CORR_CW_CNT_LWRr_FEC_CORR_CW_CNT_LOWERf_SET
#define READ_FEC_CORR_CW_CNT_LWRr BCMI_MADURA_READ_FEC_CORR_CW_CNT_LWRr
#define WRITE_FEC_CORR_CW_CNT_LWRr BCMI_MADURA_WRITE_FEC_CORR_CW_CNT_LWRr
#define MODIFY_FEC_CORR_CW_CNT_LWRr BCMI_MADURA_MODIFY_FEC_CORR_CW_CNT_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_CORR_CW_CNT_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_CORR_CW_CNT_UPR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00cb
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_CORR_CW_CNT_UPPER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_CORR_CW_CNT_UPPER See description for 1.202
 */
#define BCMI_MADURA_FEC_CORR_CW_CNT_UPRr (0x000100cb | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_CORR_CW_CNT_UPR.
 */
typedef union BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_s {
	uint32_t v[1];
	uint32_t fec_corr_cw_cnt_upr[1];
	uint32_t _fec_corr_cw_cnt_upr;
} BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_t;

#define BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_CLR(r) (r).fec_corr_cw_cnt_upr[0] = 0
#define BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_SET(r,d) (r).fec_corr_cw_cnt_upr[0] = d
#define BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_GET(r) (r).fec_corr_cw_cnt_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_FEC_CORR_CW_CNT_UPPERf_GET(r) (((r).fec_corr_cw_cnt_upr[0]) & 0xffff)
#define BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_FEC_CORR_CW_CNT_UPPERf_SET(r,f) (r).fec_corr_cw_cnt_upr[0]=(((r).fec_corr_cw_cnt_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_CORR_CW_CNT_UPR.
 */
#define BCMI_MADURA_READ_FEC_CORR_CW_CNT_UPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_CORR_CW_CNT_UPRr,_r._fec_corr_cw_cnt_upr)
#define BCMI_MADURA_WRITE_FEC_CORR_CW_CNT_UPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_CORR_CW_CNT_UPRr,_r._fec_corr_cw_cnt_upr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_CORR_CW_CNT_UPRr BCMI_MADURA_FEC_CORR_CW_CNT_UPRr
#define FEC_CORR_CW_CNT_UPRr_SIZE BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_SIZE
typedef BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_t FEC_CORR_CW_CNT_UPRr_t;
#define FEC_CORR_CW_CNT_UPRr_CLR BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_CLR
#define FEC_CORR_CW_CNT_UPRr_SET BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_SET
#define FEC_CORR_CW_CNT_UPRr_GET BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_GET
#define FEC_CORR_CW_CNT_UPRr_FEC_CORR_CW_CNT_UPPERf_GET BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_FEC_CORR_CW_CNT_UPPERf_GET
#define FEC_CORR_CW_CNT_UPRr_FEC_CORR_CW_CNT_UPPERf_SET BCMI_MADURA_FEC_CORR_CW_CNT_UPRr_FEC_CORR_CW_CNT_UPPERf_SET
#define READ_FEC_CORR_CW_CNT_UPRr BCMI_MADURA_READ_FEC_CORR_CW_CNT_UPRr
#define WRITE_FEC_CORR_CW_CNT_UPRr BCMI_MADURA_WRITE_FEC_CORR_CW_CNT_UPRr
#define MODIFY_FEC_CORR_CW_CNT_UPRr BCMI_MADURA_MODIFY_FEC_CORR_CW_CNT_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_CORR_CW_CNT_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_UNCORR_CW_CNT_LWR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00cc
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_UNCORR_CW_CNT_LOWER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_UNCORR_CW_CNT_LOWER These bits shall be reset to all zeros when the register is read by the management function or upon PHY reset. These bits shall be held at all ones in the case of overflow. Registers 1.204, 1.205 are used to read the value of a 32-bit counter. When registers 1.204 and 1.205 are used to read the 32-bit counter value, the register 1.204 is read first, the value of the register 1.205 is latched when (and only when) register 1.204 is read and reads of register 1.205 returns the latched value rather than the current value of the counter.
 */
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr (0x000100cc | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_UNCORR_CW_CNT_LWR.
 */
typedef union BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_s {
	uint32_t v[1];
	uint32_t fec_uncorr_cw_cnt_lwr[1];
	uint32_t _fec_uncorr_cw_cnt_lwr;
} BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_t;

#define BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_CLR(r) (r).fec_uncorr_cw_cnt_lwr[0] = 0
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_SET(r,d) (r).fec_uncorr_cw_cnt_lwr[0] = d
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_GET(r) (r).fec_uncorr_cw_cnt_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_FEC_UNCORR_CW_CNT_LOWERf_GET(r) (((r).fec_uncorr_cw_cnt_lwr[0]) & 0xffff)
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_FEC_UNCORR_CW_CNT_LOWERf_SET(r,f) (r).fec_uncorr_cw_cnt_lwr[0]=(((r).fec_uncorr_cw_cnt_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_UNCORR_CW_CNT_LWR.
 */
#define BCMI_MADURA_READ_FEC_UNCORR_CW_CNT_LWRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr,_r._fec_uncorr_cw_cnt_lwr)
#define BCMI_MADURA_WRITE_FEC_UNCORR_CW_CNT_LWRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr,_r._fec_uncorr_cw_cnt_lwr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_UNCORR_CW_CNT_LWRr BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr
#define FEC_UNCORR_CW_CNT_LWRr_SIZE BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_SIZE
typedef BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_t FEC_UNCORR_CW_CNT_LWRr_t;
#define FEC_UNCORR_CW_CNT_LWRr_CLR BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_CLR
#define FEC_UNCORR_CW_CNT_LWRr_SET BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_SET
#define FEC_UNCORR_CW_CNT_LWRr_GET BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_GET
#define FEC_UNCORR_CW_CNT_LWRr_FEC_UNCORR_CW_CNT_LOWERf_GET BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_FEC_UNCORR_CW_CNT_LOWERf_GET
#define FEC_UNCORR_CW_CNT_LWRr_FEC_UNCORR_CW_CNT_LOWERf_SET BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr_FEC_UNCORR_CW_CNT_LOWERf_SET
#define READ_FEC_UNCORR_CW_CNT_LWRr BCMI_MADURA_READ_FEC_UNCORR_CW_CNT_LWRr
#define WRITE_FEC_UNCORR_CW_CNT_LWRr BCMI_MADURA_WRITE_FEC_UNCORR_CW_CNT_LWRr
#define MODIFY_FEC_UNCORR_CW_CNT_LWRr BCMI_MADURA_MODIFY_FEC_UNCORR_CW_CNT_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_UNCORR_CW_CNT_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_UNCORR_CW_CNT_UPR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00cd
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_UNCORR_CW_CNT_UPPER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_UNCORR_CW_CNT_UPPER Same description as above
 */
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr (0x000100cd | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_UNCORR_CW_CNT_UPR.
 */
typedef union BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_s {
	uint32_t v[1];
	uint32_t fec_uncorr_cw_cnt_upr[1];
	uint32_t _fec_uncorr_cw_cnt_upr;
} BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_t;

#define BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_CLR(r) (r).fec_uncorr_cw_cnt_upr[0] = 0
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_SET(r,d) (r).fec_uncorr_cw_cnt_upr[0] = d
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_GET(r) (r).fec_uncorr_cw_cnt_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_FEC_UNCORR_CW_CNT_UPPERf_GET(r) (((r).fec_uncorr_cw_cnt_upr[0]) & 0xffff)
#define BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_FEC_UNCORR_CW_CNT_UPPERf_SET(r,f) (r).fec_uncorr_cw_cnt_upr[0]=(((r).fec_uncorr_cw_cnt_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_UNCORR_CW_CNT_UPR.
 */
#define BCMI_MADURA_READ_FEC_UNCORR_CW_CNT_UPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr,_r._fec_uncorr_cw_cnt_upr)
#define BCMI_MADURA_WRITE_FEC_UNCORR_CW_CNT_UPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr,_r._fec_uncorr_cw_cnt_upr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_UNCORR_CW_CNT_UPRr BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr
#define FEC_UNCORR_CW_CNT_UPRr_SIZE BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_SIZE
typedef BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_t FEC_UNCORR_CW_CNT_UPRr_t;
#define FEC_UNCORR_CW_CNT_UPRr_CLR BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_CLR
#define FEC_UNCORR_CW_CNT_UPRr_SET BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_SET
#define FEC_UNCORR_CW_CNT_UPRr_GET BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_GET
#define FEC_UNCORR_CW_CNT_UPRr_FEC_UNCORR_CW_CNT_UPPERf_GET BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_FEC_UNCORR_CW_CNT_UPPERf_GET
#define FEC_UNCORR_CW_CNT_UPRr_FEC_UNCORR_CW_CNT_UPPERf_SET BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr_FEC_UNCORR_CW_CNT_UPPERf_SET
#define READ_FEC_UNCORR_CW_CNT_UPRr BCMI_MADURA_READ_FEC_UNCORR_CW_CNT_UPRr
#define WRITE_FEC_UNCORR_CW_CNT_UPRr BCMI_MADURA_WRITE_FEC_UNCORR_CW_CNT_UPRr
#define MODIFY_FEC_UNCORR_CW_CNT_UPRr BCMI_MADURA_MODIFY_FEC_UNCORR_CW_CNT_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_UNCORR_CW_CNT_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_LN_MAP
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00ce
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_LANE_MAPPING
 * RESETVAL: 0xe4 (228)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_LANE_0_MAPPING RS-FEC lane mapped to PMA lane 0
 *     FEC_LANE_1_MAPPING RS-FEC lane mapped to PMA lane 1
 *     FEC_LANE_2_MAPPING RS-FEC lane mapped to PMA lane 2
 *     FEC_LANE_3_MAPPING RS-FEC lane mapped to PMA lane 3
 */
#define BCMI_MADURA_FEC_LN_MAPr (0x000100ce | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_LN_MAPr_SIZE 4

/*
 * This structure should be used to declare and program FEC_LN_MAP.
 */
typedef union BCMI_MADURA_FEC_LN_MAPr_s {
	uint32_t v[1];
	uint32_t fec_ln_map[1];
	uint32_t _fec_ln_map;
} BCMI_MADURA_FEC_LN_MAPr_t;

#define BCMI_MADURA_FEC_LN_MAPr_CLR(r) (r).fec_ln_map[0] = 0
#define BCMI_MADURA_FEC_LN_MAPr_SET(r,d) (r).fec_ln_map[0] = d
#define BCMI_MADURA_FEC_LN_MAPr_GET(r) (r).fec_ln_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_3_MAPPINGf_GET(r) ((((r).fec_ln_map[0]) >> 6) & 0x3)
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_3_MAPPINGf_SET(r,f) (r).fec_ln_map[0]=(((r).fec_ln_map[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_2_MAPPINGf_GET(r) ((((r).fec_ln_map[0]) >> 4) & 0x3)
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_2_MAPPINGf_SET(r,f) (r).fec_ln_map[0]=(((r).fec_ln_map[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_1_MAPPINGf_GET(r) ((((r).fec_ln_map[0]) >> 2) & 0x3)
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_1_MAPPINGf_SET(r,f) (r).fec_ln_map[0]=(((r).fec_ln_map[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_0_MAPPINGf_GET(r) (((r).fec_ln_map[0]) & 0x3)
#define BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_0_MAPPINGf_SET(r,f) (r).fec_ln_map[0]=(((r).fec_ln_map[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access FEC_LN_MAP.
 */
#define BCMI_MADURA_READ_FEC_LN_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_LN_MAPr,_r._fec_ln_map)
#define BCMI_MADURA_WRITE_FEC_LN_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_LN_MAPr,_r._fec_ln_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_LN_MAPr BCMI_MADURA_FEC_LN_MAPr
#define FEC_LN_MAPr_SIZE BCMI_MADURA_FEC_LN_MAPr_SIZE
typedef BCMI_MADURA_FEC_LN_MAPr_t FEC_LN_MAPr_t;
#define FEC_LN_MAPr_CLR BCMI_MADURA_FEC_LN_MAPr_CLR
#define FEC_LN_MAPr_SET BCMI_MADURA_FEC_LN_MAPr_SET
#define FEC_LN_MAPr_GET BCMI_MADURA_FEC_LN_MAPr_GET
#define FEC_LN_MAPr_FEC_LANE_3_MAPPINGf_GET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_3_MAPPINGf_GET
#define FEC_LN_MAPr_FEC_LANE_3_MAPPINGf_SET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_3_MAPPINGf_SET
#define FEC_LN_MAPr_FEC_LANE_2_MAPPINGf_GET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_2_MAPPINGf_GET
#define FEC_LN_MAPr_FEC_LANE_2_MAPPINGf_SET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_2_MAPPINGf_SET
#define FEC_LN_MAPr_FEC_LANE_1_MAPPINGf_GET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_1_MAPPINGf_GET
#define FEC_LN_MAPr_FEC_LANE_1_MAPPINGf_SET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_1_MAPPINGf_SET
#define FEC_LN_MAPr_FEC_LANE_0_MAPPINGf_GET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_0_MAPPINGf_GET
#define FEC_LN_MAPr_FEC_LANE_0_MAPPINGf_SET BCMI_MADURA_FEC_LN_MAPr_FEC_LANE_0_MAPPINGf_SET
#define READ_FEC_LN_MAPr BCMI_MADURA_READ_FEC_LN_MAPr
#define WRITE_FEC_LN_MAPr BCMI_MADURA_WRITE_FEC_LN_MAPr
#define MODIFY_FEC_LN_MAPr BCMI_MADURA_MODIFY_FEC_LN_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_LN_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_0_LWR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d2
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_0_LOWER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_0_LOWER Symbol errors detected in FEC lane 0 are counted and shown in register 1.210 and 1.211. These bits shall be reset to all zeros when the register is read by the management function or upon PHY reset. These bits shall be held at all ones in the case of overflow. Registers 1.210, 1.211 are used to read the value of a 32-bit counter. When registers 1.210 and 1.211 are used to read the 32-bit counter value, the register 1.210 is read first, the value of the register 1.211 is latched when (and only when) register 1.210 is read and reads of register 1.211 returns the latched value rather than the current value of the counter.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr (0x000100d2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_0_LWR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_0_lwr[1];
	uint32_t _fec_sym_err_cnt_ln_0_lwr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_CLR(r) (r).fec_sym_err_cnt_ln_0_lwr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_SET(r,d) (r).fec_sym_err_cnt_ln_0_lwr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_GET(r) (r).fec_sym_err_cnt_ln_0_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_FEC_SYM_ERR_CNT_LN_0_LOWERf_GET(r) (((r).fec_sym_err_cnt_ln_0_lwr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_FEC_SYM_ERR_CNT_LN_0_LOWERf_SET(r,f) (r).fec_sym_err_cnt_ln_0_lwr[0]=(((r).fec_sym_err_cnt_ln_0_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_0_LWR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_0_LWRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr,_r._fec_sym_err_cnt_ln_0_lwr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_0_LWRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr,_r._fec_sym_err_cnt_ln_0_lwr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_0_LWRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr
#define FEC_SYM_ERR_CNT_LN_0_LWRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_t FEC_SYM_ERR_CNT_LN_0_LWRr_t;
#define FEC_SYM_ERR_CNT_LN_0_LWRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_CLR
#define FEC_SYM_ERR_CNT_LN_0_LWRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_SET
#define FEC_SYM_ERR_CNT_LN_0_LWRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_GET
#define FEC_SYM_ERR_CNT_LN_0_LWRr_FEC_SYM_ERR_CNT_LN_0_LOWERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_FEC_SYM_ERR_CNT_LN_0_LOWERf_GET
#define FEC_SYM_ERR_CNT_LN_0_LWRr_FEC_SYM_ERR_CNT_LN_0_LOWERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr_FEC_SYM_ERR_CNT_LN_0_LOWERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_0_LWRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_0_LWRr
#define WRITE_FEC_SYM_ERR_CNT_LN_0_LWRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_0_LWRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_0_LWRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_0_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_0_UPR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d3
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_0_UPPER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_0_UPPER See description for 1.210
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr (0x000100d3 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_0_UPR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_0_upr[1];
	uint32_t _fec_sym_err_cnt_ln_0_upr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_CLR(r) (r).fec_sym_err_cnt_ln_0_upr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_SET(r,d) (r).fec_sym_err_cnt_ln_0_upr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_GET(r) (r).fec_sym_err_cnt_ln_0_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_FEC_SYM_ERR_CNT_LN_0_UPPERf_GET(r) (((r).fec_sym_err_cnt_ln_0_upr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_FEC_SYM_ERR_CNT_LN_0_UPPERf_SET(r,f) (r).fec_sym_err_cnt_ln_0_upr[0]=(((r).fec_sym_err_cnt_ln_0_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_0_UPR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_0_UPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr,_r._fec_sym_err_cnt_ln_0_upr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_0_UPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr,_r._fec_sym_err_cnt_ln_0_upr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_0_UPRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr
#define FEC_SYM_ERR_CNT_LN_0_UPRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_t FEC_SYM_ERR_CNT_LN_0_UPRr_t;
#define FEC_SYM_ERR_CNT_LN_0_UPRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_CLR
#define FEC_SYM_ERR_CNT_LN_0_UPRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_SET
#define FEC_SYM_ERR_CNT_LN_0_UPRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_GET
#define FEC_SYM_ERR_CNT_LN_0_UPRr_FEC_SYM_ERR_CNT_LN_0_UPPERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_FEC_SYM_ERR_CNT_LN_0_UPPERf_GET
#define FEC_SYM_ERR_CNT_LN_0_UPRr_FEC_SYM_ERR_CNT_LN_0_UPPERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr_FEC_SYM_ERR_CNT_LN_0_UPPERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_0_UPRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_0_UPRr
#define WRITE_FEC_SYM_ERR_CNT_LN_0_UPRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_0_UPRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_0_UPRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_0_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_0_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_1_LWR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d4
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_1_LOWER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_1_LOWER Symbol errors detected in FEC lane 1 are counted and shown in register 1.212 and 1.213. These bits shall be reset to all zeros when the register is read by the management function or upon PHY reset. These bits shall be held at all ones in the case of overflow. Registers 1.212, 1.213 are used to read the value of a 32-bit counter. When registers 1.212 and 1.213 are used to read the 32-bit counter value, the register 1.212 is read first, the value of the register 1.213 is latched when (and only when) register 1.212 is read and reads of register 1.213 returns the latched value rather than the current value of the counter.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr (0x000100d4 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_1_LWR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_1_lwr[1];
	uint32_t _fec_sym_err_cnt_ln_1_lwr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_CLR(r) (r).fec_sym_err_cnt_ln_1_lwr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_SET(r,d) (r).fec_sym_err_cnt_ln_1_lwr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_GET(r) (r).fec_sym_err_cnt_ln_1_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_FEC_SYM_ERR_CNT_LN_1_LOWERf_GET(r) (((r).fec_sym_err_cnt_ln_1_lwr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_FEC_SYM_ERR_CNT_LN_1_LOWERf_SET(r,f) (r).fec_sym_err_cnt_ln_1_lwr[0]=(((r).fec_sym_err_cnt_ln_1_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_1_LWR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_1_LWRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr,_r._fec_sym_err_cnt_ln_1_lwr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_1_LWRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr,_r._fec_sym_err_cnt_ln_1_lwr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_1_LWRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr
#define FEC_SYM_ERR_CNT_LN_1_LWRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_t FEC_SYM_ERR_CNT_LN_1_LWRr_t;
#define FEC_SYM_ERR_CNT_LN_1_LWRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_CLR
#define FEC_SYM_ERR_CNT_LN_1_LWRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_SET
#define FEC_SYM_ERR_CNT_LN_1_LWRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_GET
#define FEC_SYM_ERR_CNT_LN_1_LWRr_FEC_SYM_ERR_CNT_LN_1_LOWERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_FEC_SYM_ERR_CNT_LN_1_LOWERf_GET
#define FEC_SYM_ERR_CNT_LN_1_LWRr_FEC_SYM_ERR_CNT_LN_1_LOWERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr_FEC_SYM_ERR_CNT_LN_1_LOWERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_1_LWRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_1_LWRr
#define WRITE_FEC_SYM_ERR_CNT_LN_1_LWRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_1_LWRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_1_LWRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_1_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_1_UPR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d5
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_1_UPPER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_1_UPPER See description for 1.212
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr (0x000100d5 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_1_UPR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_1_upr[1];
	uint32_t _fec_sym_err_cnt_ln_1_upr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_CLR(r) (r).fec_sym_err_cnt_ln_1_upr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_SET(r,d) (r).fec_sym_err_cnt_ln_1_upr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_GET(r) (r).fec_sym_err_cnt_ln_1_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_FEC_SYM_ERR_CNT_LN_1_UPPERf_GET(r) (((r).fec_sym_err_cnt_ln_1_upr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_FEC_SYM_ERR_CNT_LN_1_UPPERf_SET(r,f) (r).fec_sym_err_cnt_ln_1_upr[0]=(((r).fec_sym_err_cnt_ln_1_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_1_UPR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_1_UPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr,_r._fec_sym_err_cnt_ln_1_upr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_1_UPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr,_r._fec_sym_err_cnt_ln_1_upr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_1_UPRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr
#define FEC_SYM_ERR_CNT_LN_1_UPRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_t FEC_SYM_ERR_CNT_LN_1_UPRr_t;
#define FEC_SYM_ERR_CNT_LN_1_UPRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_CLR
#define FEC_SYM_ERR_CNT_LN_1_UPRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_SET
#define FEC_SYM_ERR_CNT_LN_1_UPRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_GET
#define FEC_SYM_ERR_CNT_LN_1_UPRr_FEC_SYM_ERR_CNT_LN_1_UPPERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_FEC_SYM_ERR_CNT_LN_1_UPPERf_GET
#define FEC_SYM_ERR_CNT_LN_1_UPRr_FEC_SYM_ERR_CNT_LN_1_UPPERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr_FEC_SYM_ERR_CNT_LN_1_UPPERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_1_UPRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_1_UPRr
#define WRITE_FEC_SYM_ERR_CNT_LN_1_UPRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_1_UPRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_1_UPRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_1_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_1_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_2_LWR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d6
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_2_LOWER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_2_LOWER Symbol errors detected in FEC lane 2 are counted and shown in register 1.214 and 1.215. These bits shall be reset to all zeros when the register is read by the management function or upon PHY reset. These bits shall be held at all ones in the case of overflow. Registers 1.214, 1.215 are used to read the value of a 32-bit counter. When registers 1.214 and 1.215 are used to read the 32-bit counter value, the register 1.214 is read first, the value of the register 1.215 is latched when (and only when) register 1.214 is read and reads of register 1.215 returns the latched value rather than the current value of the counter.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr (0x000100d6 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_2_LWR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_2_lwr[1];
	uint32_t _fec_sym_err_cnt_ln_2_lwr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_CLR(r) (r).fec_sym_err_cnt_ln_2_lwr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_SET(r,d) (r).fec_sym_err_cnt_ln_2_lwr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_GET(r) (r).fec_sym_err_cnt_ln_2_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_FEC_SYM_ERR_CNT_LN_2_LOWERf_GET(r) (((r).fec_sym_err_cnt_ln_2_lwr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_FEC_SYM_ERR_CNT_LN_2_LOWERf_SET(r,f) (r).fec_sym_err_cnt_ln_2_lwr[0]=(((r).fec_sym_err_cnt_ln_2_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_2_LWR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_2_LWRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr,_r._fec_sym_err_cnt_ln_2_lwr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_2_LWRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr,_r._fec_sym_err_cnt_ln_2_lwr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_2_LWRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr
#define FEC_SYM_ERR_CNT_LN_2_LWRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_t FEC_SYM_ERR_CNT_LN_2_LWRr_t;
#define FEC_SYM_ERR_CNT_LN_2_LWRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_CLR
#define FEC_SYM_ERR_CNT_LN_2_LWRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_SET
#define FEC_SYM_ERR_CNT_LN_2_LWRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_GET
#define FEC_SYM_ERR_CNT_LN_2_LWRr_FEC_SYM_ERR_CNT_LN_2_LOWERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_FEC_SYM_ERR_CNT_LN_2_LOWERf_GET
#define FEC_SYM_ERR_CNT_LN_2_LWRr_FEC_SYM_ERR_CNT_LN_2_LOWERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr_FEC_SYM_ERR_CNT_LN_2_LOWERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_2_LWRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_2_LWRr
#define WRITE_FEC_SYM_ERR_CNT_LN_2_LWRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_2_LWRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_2_LWRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_2_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_2_UPR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d7
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_2_UPPER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_2_UPPER See description for 1.214
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr (0x000100d7 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_2_UPR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_2_upr[1];
	uint32_t _fec_sym_err_cnt_ln_2_upr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_CLR(r) (r).fec_sym_err_cnt_ln_2_upr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_SET(r,d) (r).fec_sym_err_cnt_ln_2_upr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_GET(r) (r).fec_sym_err_cnt_ln_2_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_FEC_SYM_ERR_CNT_LN_2_UPPERf_GET(r) (((r).fec_sym_err_cnt_ln_2_upr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_FEC_SYM_ERR_CNT_LN_2_UPPERf_SET(r,f) (r).fec_sym_err_cnt_ln_2_upr[0]=(((r).fec_sym_err_cnt_ln_2_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_2_UPR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_2_UPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr,_r._fec_sym_err_cnt_ln_2_upr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_2_UPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr,_r._fec_sym_err_cnt_ln_2_upr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_2_UPRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr
#define FEC_SYM_ERR_CNT_LN_2_UPRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_t FEC_SYM_ERR_CNT_LN_2_UPRr_t;
#define FEC_SYM_ERR_CNT_LN_2_UPRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_CLR
#define FEC_SYM_ERR_CNT_LN_2_UPRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_SET
#define FEC_SYM_ERR_CNT_LN_2_UPRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_GET
#define FEC_SYM_ERR_CNT_LN_2_UPRr_FEC_SYM_ERR_CNT_LN_2_UPPERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_FEC_SYM_ERR_CNT_LN_2_UPPERf_GET
#define FEC_SYM_ERR_CNT_LN_2_UPRr_FEC_SYM_ERR_CNT_LN_2_UPPERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr_FEC_SYM_ERR_CNT_LN_2_UPPERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_2_UPRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_2_UPRr
#define WRITE_FEC_SYM_ERR_CNT_LN_2_UPRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_2_UPRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_2_UPRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_2_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_2_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_3_LWR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d8
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_3_LOWER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_3_LOWER Symbol errors detected in FEC lane 3 are counted and shown in register 1.216 and 1.217. These bits shall be reset to all zeros when the register is read by the management function or upon PHY reset. These bits shall be held at all ones in the case of overflow. Registers 1.216, 1.217 are used to read the value of a 32-bit counter. When registers 1.216 and 1.217 are used to read the 32-bit counter value, the register 1.216 is read first, the value of the register 1.217 is latched when (and only when) register 1.216 is read and reads of register 1.217 returns the latched value rather than the current value of the counter.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr (0x000100d8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_3_LWR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_3_lwr[1];
	uint32_t _fec_sym_err_cnt_ln_3_lwr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_CLR(r) (r).fec_sym_err_cnt_ln_3_lwr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_SET(r,d) (r).fec_sym_err_cnt_ln_3_lwr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_GET(r) (r).fec_sym_err_cnt_ln_3_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_FEC_SYM_ERR_CNT_LN_3_LOWERf_GET(r) (((r).fec_sym_err_cnt_ln_3_lwr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_FEC_SYM_ERR_CNT_LN_3_LOWERf_SET(r,f) (r).fec_sym_err_cnt_ln_3_lwr[0]=(((r).fec_sym_err_cnt_ln_3_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_3_LWR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_3_LWRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr,_r._fec_sym_err_cnt_ln_3_lwr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_3_LWRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr,_r._fec_sym_err_cnt_ln_3_lwr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_3_LWRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr
#define FEC_SYM_ERR_CNT_LN_3_LWRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_t FEC_SYM_ERR_CNT_LN_3_LWRr_t;
#define FEC_SYM_ERR_CNT_LN_3_LWRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_CLR
#define FEC_SYM_ERR_CNT_LN_3_LWRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_SET
#define FEC_SYM_ERR_CNT_LN_3_LWRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_GET
#define FEC_SYM_ERR_CNT_LN_3_LWRr_FEC_SYM_ERR_CNT_LN_3_LOWERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_FEC_SYM_ERR_CNT_LN_3_LOWERf_GET
#define FEC_SYM_ERR_CNT_LN_3_LWRr_FEC_SYM_ERR_CNT_LN_3_LOWERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr_FEC_SYM_ERR_CNT_LN_3_LOWERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_3_LWRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_3_LWRr
#define WRITE_FEC_SYM_ERR_CNT_LN_3_LWRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_3_LWRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_3_LWRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_3_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_SYM_ERR_CNT_LN_3_UPR
 * BLOCKS:   IEEE_CL91_RX
 * REGADDR:  0x00d9
 * DEVAD:    1
 * DESC:     IEEE_CL91_RX_FEC_SYM_ERR_CNT_LN_3_UPPER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYM_ERR_CNT_LN_3_UPPER See description for 1.216
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr (0x000100d9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_SIZE 4

/*
 * This structure should be used to declare and program FEC_SYM_ERR_CNT_LN_3_UPR.
 */
typedef union BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_s {
	uint32_t v[1];
	uint32_t fec_sym_err_cnt_ln_3_upr[1];
	uint32_t _fec_sym_err_cnt_ln_3_upr;
} BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_t;

#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_CLR(r) (r).fec_sym_err_cnt_ln_3_upr[0] = 0
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_SET(r,d) (r).fec_sym_err_cnt_ln_3_upr[0] = d
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_GET(r) (r).fec_sym_err_cnt_ln_3_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_FEC_SYM_ERR_CNT_LN_3_UPPERf_GET(r) (((r).fec_sym_err_cnt_ln_3_upr[0]) & 0xffff)
#define BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_FEC_SYM_ERR_CNT_LN_3_UPPERf_SET(r,f) (r).fec_sym_err_cnt_ln_3_upr[0]=(((r).fec_sym_err_cnt_ln_3_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FEC_SYM_ERR_CNT_LN_3_UPR.
 */
#define BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_3_UPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr,_r._fec_sym_err_cnt_ln_3_upr)
#define BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_3_UPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr,_r._fec_sym_err_cnt_ln_3_upr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_SYM_ERR_CNT_LN_3_UPRr BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr
#define FEC_SYM_ERR_CNT_LN_3_UPRr_SIZE BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_SIZE
typedef BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_t FEC_SYM_ERR_CNT_LN_3_UPRr_t;
#define FEC_SYM_ERR_CNT_LN_3_UPRr_CLR BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_CLR
#define FEC_SYM_ERR_CNT_LN_3_UPRr_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_SET
#define FEC_SYM_ERR_CNT_LN_3_UPRr_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_GET
#define FEC_SYM_ERR_CNT_LN_3_UPRr_FEC_SYM_ERR_CNT_LN_3_UPPERf_GET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_FEC_SYM_ERR_CNT_LN_3_UPPERf_GET
#define FEC_SYM_ERR_CNT_LN_3_UPRr_FEC_SYM_ERR_CNT_LN_3_UPPERf_SET BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr_FEC_SYM_ERR_CNT_LN_3_UPPERf_SET
#define READ_FEC_SYM_ERR_CNT_LN_3_UPRr BCMI_MADURA_READ_FEC_SYM_ERR_CNT_LN_3_UPRr
#define WRITE_FEC_SYM_ERR_CNT_LN_3_UPRr BCMI_MADURA_WRITE_FEC_SYM_ERR_CNT_LN_3_UPRr
#define MODIFY_FEC_SYM_ERR_CNT_LN_3_UPRr BCMI_MADURA_MODIFY_FEC_SYM_ERR_CNT_LN_3_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_SYM_ERR_CNT_LN_3_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_0
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00e6
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_0 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 0 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_0r (0x000100e6 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_0r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_0.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_0r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_0[1];
	uint32_t _bip_err_cnt_ln_0;
} BCMI_MADURA_BIP_ERR_CNT_LN_0r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_0r_CLR(r) (r).bip_err_cnt_ln_0[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_0r_SET(r,d) (r).bip_err_cnt_ln_0[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_0r_GET(r) (r).bip_err_cnt_ln_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_0r_BIP_ERR_CNT_LN_0f_GET(r) (((r).bip_err_cnt_ln_0[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_0r_BIP_ERR_CNT_LN_0f_SET(r,f) (r).bip_err_cnt_ln_0[0]=(((r).bip_err_cnt_ln_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_0.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_0r,_r._bip_err_cnt_ln_0)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_0r,_r._bip_err_cnt_ln_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_0r BCMI_MADURA_BIP_ERR_CNT_LN_0r
#define BIP_ERR_CNT_LN_0r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_0r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_0r_t BIP_ERR_CNT_LN_0r_t;
#define BIP_ERR_CNT_LN_0r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_0r_CLR
#define BIP_ERR_CNT_LN_0r_SET BCMI_MADURA_BIP_ERR_CNT_LN_0r_SET
#define BIP_ERR_CNT_LN_0r_GET BCMI_MADURA_BIP_ERR_CNT_LN_0r_GET
#define BIP_ERR_CNT_LN_0r_BIP_ERR_CNT_LN_0f_GET BCMI_MADURA_BIP_ERR_CNT_LN_0r_BIP_ERR_CNT_LN_0f_GET
#define BIP_ERR_CNT_LN_0r_BIP_ERR_CNT_LN_0f_SET BCMI_MADURA_BIP_ERR_CNT_LN_0r_BIP_ERR_CNT_LN_0f_SET
#define READ_BIP_ERR_CNT_LN_0r BCMI_MADURA_READ_BIP_ERR_CNT_LN_0r
#define WRITE_BIP_ERR_CNT_LN_0r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_0r
#define MODIFY_BIP_ERR_CNT_LN_0r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_1
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00e7
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_1 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 1 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_1r (0x000100e7 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_1r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_1.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_1r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_1[1];
	uint32_t _bip_err_cnt_ln_1;
} BCMI_MADURA_BIP_ERR_CNT_LN_1r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_1r_CLR(r) (r).bip_err_cnt_ln_1[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_1r_SET(r,d) (r).bip_err_cnt_ln_1[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_1r_GET(r) (r).bip_err_cnt_ln_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_1r_BIP_ERR_CNT_LN_1f_GET(r) (((r).bip_err_cnt_ln_1[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_1r_BIP_ERR_CNT_LN_1f_SET(r,f) (r).bip_err_cnt_ln_1[0]=(((r).bip_err_cnt_ln_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_1.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_1r,_r._bip_err_cnt_ln_1)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_1r,_r._bip_err_cnt_ln_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_1r BCMI_MADURA_BIP_ERR_CNT_LN_1r
#define BIP_ERR_CNT_LN_1r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_1r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_1r_t BIP_ERR_CNT_LN_1r_t;
#define BIP_ERR_CNT_LN_1r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_1r_CLR
#define BIP_ERR_CNT_LN_1r_SET BCMI_MADURA_BIP_ERR_CNT_LN_1r_SET
#define BIP_ERR_CNT_LN_1r_GET BCMI_MADURA_BIP_ERR_CNT_LN_1r_GET
#define BIP_ERR_CNT_LN_1r_BIP_ERR_CNT_LN_1f_GET BCMI_MADURA_BIP_ERR_CNT_LN_1r_BIP_ERR_CNT_LN_1f_GET
#define BIP_ERR_CNT_LN_1r_BIP_ERR_CNT_LN_1f_SET BCMI_MADURA_BIP_ERR_CNT_LN_1r_BIP_ERR_CNT_LN_1f_SET
#define READ_BIP_ERR_CNT_LN_1r BCMI_MADURA_READ_BIP_ERR_CNT_LN_1r
#define WRITE_BIP_ERR_CNT_LN_1r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_1r
#define MODIFY_BIP_ERR_CNT_LN_1r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_2
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00e8
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_2 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 2 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_2r (0x000100e8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_2r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_2.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_2r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_2[1];
	uint32_t _bip_err_cnt_ln_2;
} BCMI_MADURA_BIP_ERR_CNT_LN_2r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_2r_CLR(r) (r).bip_err_cnt_ln_2[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_2r_SET(r,d) (r).bip_err_cnt_ln_2[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_2r_GET(r) (r).bip_err_cnt_ln_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_2r_BIP_ERR_CNT_LN_2f_GET(r) (((r).bip_err_cnt_ln_2[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_2r_BIP_ERR_CNT_LN_2f_SET(r,f) (r).bip_err_cnt_ln_2[0]=(((r).bip_err_cnt_ln_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_2.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_2r,_r._bip_err_cnt_ln_2)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_2r,_r._bip_err_cnt_ln_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_2r BCMI_MADURA_BIP_ERR_CNT_LN_2r
#define BIP_ERR_CNT_LN_2r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_2r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_2r_t BIP_ERR_CNT_LN_2r_t;
#define BIP_ERR_CNT_LN_2r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_2r_CLR
#define BIP_ERR_CNT_LN_2r_SET BCMI_MADURA_BIP_ERR_CNT_LN_2r_SET
#define BIP_ERR_CNT_LN_2r_GET BCMI_MADURA_BIP_ERR_CNT_LN_2r_GET
#define BIP_ERR_CNT_LN_2r_BIP_ERR_CNT_LN_2f_GET BCMI_MADURA_BIP_ERR_CNT_LN_2r_BIP_ERR_CNT_LN_2f_GET
#define BIP_ERR_CNT_LN_2r_BIP_ERR_CNT_LN_2f_SET BCMI_MADURA_BIP_ERR_CNT_LN_2r_BIP_ERR_CNT_LN_2f_SET
#define READ_BIP_ERR_CNT_LN_2r BCMI_MADURA_READ_BIP_ERR_CNT_LN_2r
#define WRITE_BIP_ERR_CNT_LN_2r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_2r
#define MODIFY_BIP_ERR_CNT_LN_2r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_3
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00e9
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_3 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 3 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_3r (0x000100e9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_3r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_3.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_3r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_3[1];
	uint32_t _bip_err_cnt_ln_3;
} BCMI_MADURA_BIP_ERR_CNT_LN_3r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_3r_CLR(r) (r).bip_err_cnt_ln_3[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_3r_SET(r,d) (r).bip_err_cnt_ln_3[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_3r_GET(r) (r).bip_err_cnt_ln_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_3r_BIP_ERR_CNT_LN_3f_GET(r) (((r).bip_err_cnt_ln_3[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_3r_BIP_ERR_CNT_LN_3f_SET(r,f) (r).bip_err_cnt_ln_3[0]=(((r).bip_err_cnt_ln_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_3.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_3r,_r._bip_err_cnt_ln_3)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_3r,_r._bip_err_cnt_ln_3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_3r BCMI_MADURA_BIP_ERR_CNT_LN_3r
#define BIP_ERR_CNT_LN_3r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_3r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_3r_t BIP_ERR_CNT_LN_3r_t;
#define BIP_ERR_CNT_LN_3r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_3r_CLR
#define BIP_ERR_CNT_LN_3r_SET BCMI_MADURA_BIP_ERR_CNT_LN_3r_SET
#define BIP_ERR_CNT_LN_3r_GET BCMI_MADURA_BIP_ERR_CNT_LN_3r_GET
#define BIP_ERR_CNT_LN_3r_BIP_ERR_CNT_LN_3f_GET BCMI_MADURA_BIP_ERR_CNT_LN_3r_BIP_ERR_CNT_LN_3f_GET
#define BIP_ERR_CNT_LN_3r_BIP_ERR_CNT_LN_3f_SET BCMI_MADURA_BIP_ERR_CNT_LN_3r_BIP_ERR_CNT_LN_3f_SET
#define READ_BIP_ERR_CNT_LN_3r BCMI_MADURA_READ_BIP_ERR_CNT_LN_3r
#define WRITE_BIP_ERR_CNT_LN_3r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_3r
#define MODIFY_BIP_ERR_CNT_LN_3r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_4
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00ea
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_4 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 4 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_4r (0x000100ea | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_4r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_4.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_4r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_4[1];
	uint32_t _bip_err_cnt_ln_4;
} BCMI_MADURA_BIP_ERR_CNT_LN_4r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_4r_CLR(r) (r).bip_err_cnt_ln_4[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_4r_SET(r,d) (r).bip_err_cnt_ln_4[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_4r_GET(r) (r).bip_err_cnt_ln_4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_4r_BIP_ERR_CNT_LN_4f_GET(r) (((r).bip_err_cnt_ln_4[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_4r_BIP_ERR_CNT_LN_4f_SET(r,f) (r).bip_err_cnt_ln_4[0]=(((r).bip_err_cnt_ln_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_4.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_4r,_r._bip_err_cnt_ln_4)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_4r,_r._bip_err_cnt_ln_4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_4r BCMI_MADURA_BIP_ERR_CNT_LN_4r
#define BIP_ERR_CNT_LN_4r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_4r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_4r_t BIP_ERR_CNT_LN_4r_t;
#define BIP_ERR_CNT_LN_4r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_4r_CLR
#define BIP_ERR_CNT_LN_4r_SET BCMI_MADURA_BIP_ERR_CNT_LN_4r_SET
#define BIP_ERR_CNT_LN_4r_GET BCMI_MADURA_BIP_ERR_CNT_LN_4r_GET
#define BIP_ERR_CNT_LN_4r_BIP_ERR_CNT_LN_4f_GET BCMI_MADURA_BIP_ERR_CNT_LN_4r_BIP_ERR_CNT_LN_4f_GET
#define BIP_ERR_CNT_LN_4r_BIP_ERR_CNT_LN_4f_SET BCMI_MADURA_BIP_ERR_CNT_LN_4r_BIP_ERR_CNT_LN_4f_SET
#define READ_BIP_ERR_CNT_LN_4r BCMI_MADURA_READ_BIP_ERR_CNT_LN_4r
#define WRITE_BIP_ERR_CNT_LN_4r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_4r
#define MODIFY_BIP_ERR_CNT_LN_4r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_5
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00eb
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_5 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 5 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_5r (0x000100eb | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_5r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_5.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_5r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_5[1];
	uint32_t _bip_err_cnt_ln_5;
} BCMI_MADURA_BIP_ERR_CNT_LN_5r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_5r_CLR(r) (r).bip_err_cnt_ln_5[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_5r_SET(r,d) (r).bip_err_cnt_ln_5[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_5r_GET(r) (r).bip_err_cnt_ln_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_5r_BIP_ERR_CNT_LN_5f_GET(r) (((r).bip_err_cnt_ln_5[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_5r_BIP_ERR_CNT_LN_5f_SET(r,f) (r).bip_err_cnt_ln_5[0]=(((r).bip_err_cnt_ln_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_5.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_5r,_r._bip_err_cnt_ln_5)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_5r,_r._bip_err_cnt_ln_5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_5r BCMI_MADURA_BIP_ERR_CNT_LN_5r
#define BIP_ERR_CNT_LN_5r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_5r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_5r_t BIP_ERR_CNT_LN_5r_t;
#define BIP_ERR_CNT_LN_5r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_5r_CLR
#define BIP_ERR_CNT_LN_5r_SET BCMI_MADURA_BIP_ERR_CNT_LN_5r_SET
#define BIP_ERR_CNT_LN_5r_GET BCMI_MADURA_BIP_ERR_CNT_LN_5r_GET
#define BIP_ERR_CNT_LN_5r_BIP_ERR_CNT_LN_5f_GET BCMI_MADURA_BIP_ERR_CNT_LN_5r_BIP_ERR_CNT_LN_5f_GET
#define BIP_ERR_CNT_LN_5r_BIP_ERR_CNT_LN_5f_SET BCMI_MADURA_BIP_ERR_CNT_LN_5r_BIP_ERR_CNT_LN_5f_SET
#define READ_BIP_ERR_CNT_LN_5r BCMI_MADURA_READ_BIP_ERR_CNT_LN_5r
#define WRITE_BIP_ERR_CNT_LN_5r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_5r
#define MODIFY_BIP_ERR_CNT_LN_5r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_6
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00ec
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_6 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 6 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_6r (0x000100ec | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_6r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_6.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_6r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_6[1];
	uint32_t _bip_err_cnt_ln_6;
} BCMI_MADURA_BIP_ERR_CNT_LN_6r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_6r_CLR(r) (r).bip_err_cnt_ln_6[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_6r_SET(r,d) (r).bip_err_cnt_ln_6[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_6r_GET(r) (r).bip_err_cnt_ln_6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_6r_BIP_ERR_CNT_LN_6f_GET(r) (((r).bip_err_cnt_ln_6[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_6r_BIP_ERR_CNT_LN_6f_SET(r,f) (r).bip_err_cnt_ln_6[0]=(((r).bip_err_cnt_ln_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_6.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_6r,_r._bip_err_cnt_ln_6)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_6r,_r._bip_err_cnt_ln_6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_6r BCMI_MADURA_BIP_ERR_CNT_LN_6r
#define BIP_ERR_CNT_LN_6r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_6r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_6r_t BIP_ERR_CNT_LN_6r_t;
#define BIP_ERR_CNT_LN_6r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_6r_CLR
#define BIP_ERR_CNT_LN_6r_SET BCMI_MADURA_BIP_ERR_CNT_LN_6r_SET
#define BIP_ERR_CNT_LN_6r_GET BCMI_MADURA_BIP_ERR_CNT_LN_6r_GET
#define BIP_ERR_CNT_LN_6r_BIP_ERR_CNT_LN_6f_GET BCMI_MADURA_BIP_ERR_CNT_LN_6r_BIP_ERR_CNT_LN_6f_GET
#define BIP_ERR_CNT_LN_6r_BIP_ERR_CNT_LN_6f_SET BCMI_MADURA_BIP_ERR_CNT_LN_6r_BIP_ERR_CNT_LN_6f_SET
#define READ_BIP_ERR_CNT_LN_6r BCMI_MADURA_READ_BIP_ERR_CNT_LN_6r
#define WRITE_BIP_ERR_CNT_LN_6r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_6r
#define MODIFY_BIP_ERR_CNT_LN_6r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_7
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00ed
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_7 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 7 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_7r (0x000100ed | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_7r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_7.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_7r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_7[1];
	uint32_t _bip_err_cnt_ln_7;
} BCMI_MADURA_BIP_ERR_CNT_LN_7r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_7r_CLR(r) (r).bip_err_cnt_ln_7[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_7r_SET(r,d) (r).bip_err_cnt_ln_7[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_7r_GET(r) (r).bip_err_cnt_ln_7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_7r_BIP_ERR_CNT_LN_7f_GET(r) (((r).bip_err_cnt_ln_7[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_7r_BIP_ERR_CNT_LN_7f_SET(r,f) (r).bip_err_cnt_ln_7[0]=(((r).bip_err_cnt_ln_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_7.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_7r,_r._bip_err_cnt_ln_7)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_7r,_r._bip_err_cnt_ln_7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_7r BCMI_MADURA_BIP_ERR_CNT_LN_7r
#define BIP_ERR_CNT_LN_7r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_7r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_7r_t BIP_ERR_CNT_LN_7r_t;
#define BIP_ERR_CNT_LN_7r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_7r_CLR
#define BIP_ERR_CNT_LN_7r_SET BCMI_MADURA_BIP_ERR_CNT_LN_7r_SET
#define BIP_ERR_CNT_LN_7r_GET BCMI_MADURA_BIP_ERR_CNT_LN_7r_GET
#define BIP_ERR_CNT_LN_7r_BIP_ERR_CNT_LN_7f_GET BCMI_MADURA_BIP_ERR_CNT_LN_7r_BIP_ERR_CNT_LN_7f_GET
#define BIP_ERR_CNT_LN_7r_BIP_ERR_CNT_LN_7f_SET BCMI_MADURA_BIP_ERR_CNT_LN_7r_BIP_ERR_CNT_LN_7f_SET
#define READ_BIP_ERR_CNT_LN_7r BCMI_MADURA_READ_BIP_ERR_CNT_LN_7r
#define WRITE_BIP_ERR_CNT_LN_7r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_7r
#define MODIFY_BIP_ERR_CNT_LN_7r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_8
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00ee
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_8 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 8 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_8r (0x000100ee | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_8r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_8.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_8r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_8[1];
	uint32_t _bip_err_cnt_ln_8;
} BCMI_MADURA_BIP_ERR_CNT_LN_8r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_8r_CLR(r) (r).bip_err_cnt_ln_8[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_8r_SET(r,d) (r).bip_err_cnt_ln_8[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_8r_GET(r) (r).bip_err_cnt_ln_8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_8r_BIP_ERR_CNT_LN_8f_GET(r) (((r).bip_err_cnt_ln_8[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_8r_BIP_ERR_CNT_LN_8f_SET(r,f) (r).bip_err_cnt_ln_8[0]=(((r).bip_err_cnt_ln_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_8.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_8r,_r._bip_err_cnt_ln_8)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_8r,_r._bip_err_cnt_ln_8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_8r BCMI_MADURA_BIP_ERR_CNT_LN_8r
#define BIP_ERR_CNT_LN_8r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_8r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_8r_t BIP_ERR_CNT_LN_8r_t;
#define BIP_ERR_CNT_LN_8r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_8r_CLR
#define BIP_ERR_CNT_LN_8r_SET BCMI_MADURA_BIP_ERR_CNT_LN_8r_SET
#define BIP_ERR_CNT_LN_8r_GET BCMI_MADURA_BIP_ERR_CNT_LN_8r_GET
#define BIP_ERR_CNT_LN_8r_BIP_ERR_CNT_LN_8f_GET BCMI_MADURA_BIP_ERR_CNT_LN_8r_BIP_ERR_CNT_LN_8f_GET
#define BIP_ERR_CNT_LN_8r_BIP_ERR_CNT_LN_8f_SET BCMI_MADURA_BIP_ERR_CNT_LN_8r_BIP_ERR_CNT_LN_8f_SET
#define READ_BIP_ERR_CNT_LN_8r BCMI_MADURA_READ_BIP_ERR_CNT_LN_8r
#define WRITE_BIP_ERR_CNT_LN_8r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_8r
#define MODIFY_BIP_ERR_CNT_LN_8r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_9
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00ef
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_9 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 9 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_9r (0x000100ef | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_9r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_9.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_9r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_9[1];
	uint32_t _bip_err_cnt_ln_9;
} BCMI_MADURA_BIP_ERR_CNT_LN_9r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_9r_CLR(r) (r).bip_err_cnt_ln_9[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_9r_SET(r,d) (r).bip_err_cnt_ln_9[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_9r_GET(r) (r).bip_err_cnt_ln_9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_9r_BIP_ERR_CNT_LN_9f_GET(r) (((r).bip_err_cnt_ln_9[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_9r_BIP_ERR_CNT_LN_9f_SET(r,f) (r).bip_err_cnt_ln_9[0]=(((r).bip_err_cnt_ln_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_9.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_9r,_r._bip_err_cnt_ln_9)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_9r,_r._bip_err_cnt_ln_9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_9r BCMI_MADURA_BIP_ERR_CNT_LN_9r
#define BIP_ERR_CNT_LN_9r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_9r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_9r_t BIP_ERR_CNT_LN_9r_t;
#define BIP_ERR_CNT_LN_9r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_9r_CLR
#define BIP_ERR_CNT_LN_9r_SET BCMI_MADURA_BIP_ERR_CNT_LN_9r_SET
#define BIP_ERR_CNT_LN_9r_GET BCMI_MADURA_BIP_ERR_CNT_LN_9r_GET
#define BIP_ERR_CNT_LN_9r_BIP_ERR_CNT_LN_9f_GET BCMI_MADURA_BIP_ERR_CNT_LN_9r_BIP_ERR_CNT_LN_9f_GET
#define BIP_ERR_CNT_LN_9r_BIP_ERR_CNT_LN_9f_SET BCMI_MADURA_BIP_ERR_CNT_LN_9r_BIP_ERR_CNT_LN_9f_SET
#define READ_BIP_ERR_CNT_LN_9r BCMI_MADURA_READ_BIP_ERR_CNT_LN_9r
#define WRITE_BIP_ERR_CNT_LN_9r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_9r
#define MODIFY_BIP_ERR_CNT_LN_9r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_10
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f0
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_10 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 10 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_10r (0x000100f0 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_10r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_10.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_10r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_10[1];
	uint32_t _bip_err_cnt_ln_10;
} BCMI_MADURA_BIP_ERR_CNT_LN_10r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_10r_CLR(r) (r).bip_err_cnt_ln_10[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_10r_SET(r,d) (r).bip_err_cnt_ln_10[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_10r_GET(r) (r).bip_err_cnt_ln_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_10r_BIP_ERR_CNT_LN_10f_GET(r) (((r).bip_err_cnt_ln_10[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_10r_BIP_ERR_CNT_LN_10f_SET(r,f) (r).bip_err_cnt_ln_10[0]=(((r).bip_err_cnt_ln_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_10.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_10r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_10r,_r._bip_err_cnt_ln_10)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_10r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_10r,_r._bip_err_cnt_ln_10)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_10r BCMI_MADURA_BIP_ERR_CNT_LN_10r
#define BIP_ERR_CNT_LN_10r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_10r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_10r_t BIP_ERR_CNT_LN_10r_t;
#define BIP_ERR_CNT_LN_10r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_10r_CLR
#define BIP_ERR_CNT_LN_10r_SET BCMI_MADURA_BIP_ERR_CNT_LN_10r_SET
#define BIP_ERR_CNT_LN_10r_GET BCMI_MADURA_BIP_ERR_CNT_LN_10r_GET
#define BIP_ERR_CNT_LN_10r_BIP_ERR_CNT_LN_10f_GET BCMI_MADURA_BIP_ERR_CNT_LN_10r_BIP_ERR_CNT_LN_10f_GET
#define BIP_ERR_CNT_LN_10r_BIP_ERR_CNT_LN_10f_SET BCMI_MADURA_BIP_ERR_CNT_LN_10r_BIP_ERR_CNT_LN_10f_SET
#define READ_BIP_ERR_CNT_LN_10r BCMI_MADURA_READ_BIP_ERR_CNT_LN_10r
#define WRITE_BIP_ERR_CNT_LN_10r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_10r
#define MODIFY_BIP_ERR_CNT_LN_10r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_11
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f1
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_11 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 11 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_11r (0x000100f1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_11r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_11.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_11r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_11[1];
	uint32_t _bip_err_cnt_ln_11;
} BCMI_MADURA_BIP_ERR_CNT_LN_11r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_11r_CLR(r) (r).bip_err_cnt_ln_11[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_11r_SET(r,d) (r).bip_err_cnt_ln_11[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_11r_GET(r) (r).bip_err_cnt_ln_11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_11r_BIP_ERR_CNT_LN_11f_GET(r) (((r).bip_err_cnt_ln_11[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_11r_BIP_ERR_CNT_LN_11f_SET(r,f) (r).bip_err_cnt_ln_11[0]=(((r).bip_err_cnt_ln_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_11.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_11r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_11r,_r._bip_err_cnt_ln_11)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_11r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_11r,_r._bip_err_cnt_ln_11)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_11r BCMI_MADURA_BIP_ERR_CNT_LN_11r
#define BIP_ERR_CNT_LN_11r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_11r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_11r_t BIP_ERR_CNT_LN_11r_t;
#define BIP_ERR_CNT_LN_11r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_11r_CLR
#define BIP_ERR_CNT_LN_11r_SET BCMI_MADURA_BIP_ERR_CNT_LN_11r_SET
#define BIP_ERR_CNT_LN_11r_GET BCMI_MADURA_BIP_ERR_CNT_LN_11r_GET
#define BIP_ERR_CNT_LN_11r_BIP_ERR_CNT_LN_11f_GET BCMI_MADURA_BIP_ERR_CNT_LN_11r_BIP_ERR_CNT_LN_11f_GET
#define BIP_ERR_CNT_LN_11r_BIP_ERR_CNT_LN_11f_SET BCMI_MADURA_BIP_ERR_CNT_LN_11r_BIP_ERR_CNT_LN_11f_SET
#define READ_BIP_ERR_CNT_LN_11r BCMI_MADURA_READ_BIP_ERR_CNT_LN_11r
#define WRITE_BIP_ERR_CNT_LN_11r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_11r
#define MODIFY_BIP_ERR_CNT_LN_11r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_12
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f2
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_12 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 12 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_12r (0x000100f2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_12r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_12.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_12r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_12[1];
	uint32_t _bip_err_cnt_ln_12;
} BCMI_MADURA_BIP_ERR_CNT_LN_12r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_12r_CLR(r) (r).bip_err_cnt_ln_12[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_12r_SET(r,d) (r).bip_err_cnt_ln_12[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_12r_GET(r) (r).bip_err_cnt_ln_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_12r_BIP_ERR_CNT_LN_12f_GET(r) (((r).bip_err_cnt_ln_12[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_12r_BIP_ERR_CNT_LN_12f_SET(r,f) (r).bip_err_cnt_ln_12[0]=(((r).bip_err_cnt_ln_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_12.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_12r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_12r,_r._bip_err_cnt_ln_12)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_12r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_12r,_r._bip_err_cnt_ln_12)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_12r BCMI_MADURA_BIP_ERR_CNT_LN_12r
#define BIP_ERR_CNT_LN_12r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_12r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_12r_t BIP_ERR_CNT_LN_12r_t;
#define BIP_ERR_CNT_LN_12r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_12r_CLR
#define BIP_ERR_CNT_LN_12r_SET BCMI_MADURA_BIP_ERR_CNT_LN_12r_SET
#define BIP_ERR_CNT_LN_12r_GET BCMI_MADURA_BIP_ERR_CNT_LN_12r_GET
#define BIP_ERR_CNT_LN_12r_BIP_ERR_CNT_LN_12f_GET BCMI_MADURA_BIP_ERR_CNT_LN_12r_BIP_ERR_CNT_LN_12f_GET
#define BIP_ERR_CNT_LN_12r_BIP_ERR_CNT_LN_12f_SET BCMI_MADURA_BIP_ERR_CNT_LN_12r_BIP_ERR_CNT_LN_12f_SET
#define READ_BIP_ERR_CNT_LN_12r BCMI_MADURA_READ_BIP_ERR_CNT_LN_12r
#define WRITE_BIP_ERR_CNT_LN_12r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_12r
#define MODIFY_BIP_ERR_CNT_LN_12r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_12r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_13
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f3
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_13 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 13 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_13r (0x000100f3 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_13r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_13.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_13r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_13[1];
	uint32_t _bip_err_cnt_ln_13;
} BCMI_MADURA_BIP_ERR_CNT_LN_13r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_13r_CLR(r) (r).bip_err_cnt_ln_13[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_13r_SET(r,d) (r).bip_err_cnt_ln_13[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_13r_GET(r) (r).bip_err_cnt_ln_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_13r_BIP_ERR_CNT_LN_13f_GET(r) (((r).bip_err_cnt_ln_13[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_13r_BIP_ERR_CNT_LN_13f_SET(r,f) (r).bip_err_cnt_ln_13[0]=(((r).bip_err_cnt_ln_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_13.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_13r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_13r,_r._bip_err_cnt_ln_13)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_13r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_13r,_r._bip_err_cnt_ln_13)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_13r BCMI_MADURA_BIP_ERR_CNT_LN_13r
#define BIP_ERR_CNT_LN_13r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_13r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_13r_t BIP_ERR_CNT_LN_13r_t;
#define BIP_ERR_CNT_LN_13r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_13r_CLR
#define BIP_ERR_CNT_LN_13r_SET BCMI_MADURA_BIP_ERR_CNT_LN_13r_SET
#define BIP_ERR_CNT_LN_13r_GET BCMI_MADURA_BIP_ERR_CNT_LN_13r_GET
#define BIP_ERR_CNT_LN_13r_BIP_ERR_CNT_LN_13f_GET BCMI_MADURA_BIP_ERR_CNT_LN_13r_BIP_ERR_CNT_LN_13f_GET
#define BIP_ERR_CNT_LN_13r_BIP_ERR_CNT_LN_13f_SET BCMI_MADURA_BIP_ERR_CNT_LN_13r_BIP_ERR_CNT_LN_13f_SET
#define READ_BIP_ERR_CNT_LN_13r BCMI_MADURA_READ_BIP_ERR_CNT_LN_13r
#define WRITE_BIP_ERR_CNT_LN_13r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_13r
#define MODIFY_BIP_ERR_CNT_LN_13r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_13r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_14
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f4
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_14 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 14 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_14r (0x000100f4 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_14r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_14.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_14r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_14[1];
	uint32_t _bip_err_cnt_ln_14;
} BCMI_MADURA_BIP_ERR_CNT_LN_14r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_14r_CLR(r) (r).bip_err_cnt_ln_14[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_14r_SET(r,d) (r).bip_err_cnt_ln_14[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_14r_GET(r) (r).bip_err_cnt_ln_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_14r_BIP_ERR_CNT_LN_14f_GET(r) (((r).bip_err_cnt_ln_14[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_14r_BIP_ERR_CNT_LN_14f_SET(r,f) (r).bip_err_cnt_ln_14[0]=(((r).bip_err_cnt_ln_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_14.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_14r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_14r,_r._bip_err_cnt_ln_14)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_14r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_14r,_r._bip_err_cnt_ln_14)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_14r BCMI_MADURA_BIP_ERR_CNT_LN_14r
#define BIP_ERR_CNT_LN_14r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_14r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_14r_t BIP_ERR_CNT_LN_14r_t;
#define BIP_ERR_CNT_LN_14r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_14r_CLR
#define BIP_ERR_CNT_LN_14r_SET BCMI_MADURA_BIP_ERR_CNT_LN_14r_SET
#define BIP_ERR_CNT_LN_14r_GET BCMI_MADURA_BIP_ERR_CNT_LN_14r_GET
#define BIP_ERR_CNT_LN_14r_BIP_ERR_CNT_LN_14f_GET BCMI_MADURA_BIP_ERR_CNT_LN_14r_BIP_ERR_CNT_LN_14f_GET
#define BIP_ERR_CNT_LN_14r_BIP_ERR_CNT_LN_14f_SET BCMI_MADURA_BIP_ERR_CNT_LN_14r_BIP_ERR_CNT_LN_14f_SET
#define READ_BIP_ERR_CNT_LN_14r BCMI_MADURA_READ_BIP_ERR_CNT_LN_14r
#define WRITE_BIP_ERR_CNT_LN_14r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_14r
#define MODIFY_BIP_ERR_CNT_LN_14r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_14r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_15
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f5
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_15 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 15 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_15r (0x000100f5 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_15r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_15.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_15r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_15[1];
	uint32_t _bip_err_cnt_ln_15;
} BCMI_MADURA_BIP_ERR_CNT_LN_15r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_15r_CLR(r) (r).bip_err_cnt_ln_15[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_15r_SET(r,d) (r).bip_err_cnt_ln_15[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_15r_GET(r) (r).bip_err_cnt_ln_15[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_15r_BIP_ERR_CNT_LN_15f_GET(r) (((r).bip_err_cnt_ln_15[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_15r_BIP_ERR_CNT_LN_15f_SET(r,f) (r).bip_err_cnt_ln_15[0]=(((r).bip_err_cnt_ln_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_15.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_15r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_15r,_r._bip_err_cnt_ln_15)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_15r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_15r,_r._bip_err_cnt_ln_15)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_15r BCMI_MADURA_BIP_ERR_CNT_LN_15r
#define BIP_ERR_CNT_LN_15r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_15r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_15r_t BIP_ERR_CNT_LN_15r_t;
#define BIP_ERR_CNT_LN_15r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_15r_CLR
#define BIP_ERR_CNT_LN_15r_SET BCMI_MADURA_BIP_ERR_CNT_LN_15r_SET
#define BIP_ERR_CNT_LN_15r_GET BCMI_MADURA_BIP_ERR_CNT_LN_15r_GET
#define BIP_ERR_CNT_LN_15r_BIP_ERR_CNT_LN_15f_GET BCMI_MADURA_BIP_ERR_CNT_LN_15r_BIP_ERR_CNT_LN_15f_GET
#define BIP_ERR_CNT_LN_15r_BIP_ERR_CNT_LN_15f_SET BCMI_MADURA_BIP_ERR_CNT_LN_15r_BIP_ERR_CNT_LN_15f_SET
#define READ_BIP_ERR_CNT_LN_15r BCMI_MADURA_READ_BIP_ERR_CNT_LN_15r
#define WRITE_BIP_ERR_CNT_LN_15r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_15r
#define MODIFY_BIP_ERR_CNT_LN_15r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_15r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_16
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f6
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_16 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 16 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_16r (0x000100f6 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_16r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_16.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_16r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_16[1];
	uint32_t _bip_err_cnt_ln_16;
} BCMI_MADURA_BIP_ERR_CNT_LN_16r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_16r_CLR(r) (r).bip_err_cnt_ln_16[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_16r_SET(r,d) (r).bip_err_cnt_ln_16[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_16r_GET(r) (r).bip_err_cnt_ln_16[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_16r_BIP_ERR_CNT_LN_16f_GET(r) (((r).bip_err_cnt_ln_16[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_16r_BIP_ERR_CNT_LN_16f_SET(r,f) (r).bip_err_cnt_ln_16[0]=(((r).bip_err_cnt_ln_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_16.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_16r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_16r,_r._bip_err_cnt_ln_16)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_16r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_16r,_r._bip_err_cnt_ln_16)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_16r BCMI_MADURA_BIP_ERR_CNT_LN_16r
#define BIP_ERR_CNT_LN_16r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_16r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_16r_t BIP_ERR_CNT_LN_16r_t;
#define BIP_ERR_CNT_LN_16r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_16r_CLR
#define BIP_ERR_CNT_LN_16r_SET BCMI_MADURA_BIP_ERR_CNT_LN_16r_SET
#define BIP_ERR_CNT_LN_16r_GET BCMI_MADURA_BIP_ERR_CNT_LN_16r_GET
#define BIP_ERR_CNT_LN_16r_BIP_ERR_CNT_LN_16f_GET BCMI_MADURA_BIP_ERR_CNT_LN_16r_BIP_ERR_CNT_LN_16f_GET
#define BIP_ERR_CNT_LN_16r_BIP_ERR_CNT_LN_16f_SET BCMI_MADURA_BIP_ERR_CNT_LN_16r_BIP_ERR_CNT_LN_16f_SET
#define READ_BIP_ERR_CNT_LN_16r BCMI_MADURA_READ_BIP_ERR_CNT_LN_16r
#define WRITE_BIP_ERR_CNT_LN_16r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_16r
#define MODIFY_BIP_ERR_CNT_LN_16r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_16r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_17
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f7
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_17 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 17 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_17r (0x000100f7 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_17r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_17.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_17r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_17[1];
	uint32_t _bip_err_cnt_ln_17;
} BCMI_MADURA_BIP_ERR_CNT_LN_17r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_17r_CLR(r) (r).bip_err_cnt_ln_17[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_17r_SET(r,d) (r).bip_err_cnt_ln_17[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_17r_GET(r) (r).bip_err_cnt_ln_17[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_17r_BIP_ERR_CNT_LN_17f_GET(r) (((r).bip_err_cnt_ln_17[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_17r_BIP_ERR_CNT_LN_17f_SET(r,f) (r).bip_err_cnt_ln_17[0]=(((r).bip_err_cnt_ln_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_17.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_17r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_17r,_r._bip_err_cnt_ln_17)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_17r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_17r,_r._bip_err_cnt_ln_17)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_17r BCMI_MADURA_BIP_ERR_CNT_LN_17r
#define BIP_ERR_CNT_LN_17r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_17r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_17r_t BIP_ERR_CNT_LN_17r_t;
#define BIP_ERR_CNT_LN_17r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_17r_CLR
#define BIP_ERR_CNT_LN_17r_SET BCMI_MADURA_BIP_ERR_CNT_LN_17r_SET
#define BIP_ERR_CNT_LN_17r_GET BCMI_MADURA_BIP_ERR_CNT_LN_17r_GET
#define BIP_ERR_CNT_LN_17r_BIP_ERR_CNT_LN_17f_GET BCMI_MADURA_BIP_ERR_CNT_LN_17r_BIP_ERR_CNT_LN_17f_GET
#define BIP_ERR_CNT_LN_17r_BIP_ERR_CNT_LN_17f_SET BCMI_MADURA_BIP_ERR_CNT_LN_17r_BIP_ERR_CNT_LN_17f_SET
#define READ_BIP_ERR_CNT_LN_17r BCMI_MADURA_READ_BIP_ERR_CNT_LN_17r
#define WRITE_BIP_ERR_CNT_LN_17r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_17r
#define MODIFY_BIP_ERR_CNT_LN_17r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_17r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_18
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f8
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_18 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 18 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_18r (0x000100f8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_18r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_18.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_18r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_18[1];
	uint32_t _bip_err_cnt_ln_18;
} BCMI_MADURA_BIP_ERR_CNT_LN_18r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_18r_CLR(r) (r).bip_err_cnt_ln_18[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_18r_SET(r,d) (r).bip_err_cnt_ln_18[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_18r_GET(r) (r).bip_err_cnt_ln_18[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_18r_BIP_ERR_CNT_LN_18f_GET(r) (((r).bip_err_cnt_ln_18[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_18r_BIP_ERR_CNT_LN_18f_SET(r,f) (r).bip_err_cnt_ln_18[0]=(((r).bip_err_cnt_ln_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_18.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_18r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_18r,_r._bip_err_cnt_ln_18)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_18r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_18r,_r._bip_err_cnt_ln_18)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_18r BCMI_MADURA_BIP_ERR_CNT_LN_18r
#define BIP_ERR_CNT_LN_18r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_18r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_18r_t BIP_ERR_CNT_LN_18r_t;
#define BIP_ERR_CNT_LN_18r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_18r_CLR
#define BIP_ERR_CNT_LN_18r_SET BCMI_MADURA_BIP_ERR_CNT_LN_18r_SET
#define BIP_ERR_CNT_LN_18r_GET BCMI_MADURA_BIP_ERR_CNT_LN_18r_GET
#define BIP_ERR_CNT_LN_18r_BIP_ERR_CNT_LN_18f_GET BCMI_MADURA_BIP_ERR_CNT_LN_18r_BIP_ERR_CNT_LN_18f_GET
#define BIP_ERR_CNT_LN_18r_BIP_ERR_CNT_LN_18f_SET BCMI_MADURA_BIP_ERR_CNT_LN_18r_BIP_ERR_CNT_LN_18f_SET
#define READ_BIP_ERR_CNT_LN_18r BCMI_MADURA_READ_BIP_ERR_CNT_LN_18r
#define WRITE_BIP_ERR_CNT_LN_18r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_18r
#define MODIFY_BIP_ERR_CNT_LN_18r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_18r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BIP_ERR_CNT_LN_19
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00f9
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_BIP_ERR_CNT_LN_19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERR_CNT_LN_19 The RS-FEC(CL-91) calculates a BIP(Bit Interleaved Parity) value for each PCS lane. Errors detected in PCS lane 19 are counted and shown in this register. The 16-bit counter shall be reset to all zeros when this register is read or upon PMA/PMD reset. The counter shall be held at all ones in the case of overflow.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_19r (0x000100f9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BIP_ERR_CNT_LN_19r_SIZE 4

/*
 * This structure should be used to declare and program BIP_ERR_CNT_LN_19.
 */
typedef union BCMI_MADURA_BIP_ERR_CNT_LN_19r_s {
	uint32_t v[1];
	uint32_t bip_err_cnt_ln_19[1];
	uint32_t _bip_err_cnt_ln_19;
} BCMI_MADURA_BIP_ERR_CNT_LN_19r_t;

#define BCMI_MADURA_BIP_ERR_CNT_LN_19r_CLR(r) (r).bip_err_cnt_ln_19[0] = 0
#define BCMI_MADURA_BIP_ERR_CNT_LN_19r_SET(r,d) (r).bip_err_cnt_ln_19[0] = d
#define BCMI_MADURA_BIP_ERR_CNT_LN_19r_GET(r) (r).bip_err_cnt_ln_19[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BIP_ERR_CNT_LN_19r_BIP_ERR_CNT_LN_19f_GET(r) (((r).bip_err_cnt_ln_19[0]) & 0xffff)
#define BCMI_MADURA_BIP_ERR_CNT_LN_19r_BIP_ERR_CNT_LN_19f_SET(r,f) (r).bip_err_cnt_ln_19[0]=(((r).bip_err_cnt_ln_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access BIP_ERR_CNT_LN_19.
 */
#define BCMI_MADURA_READ_BIP_ERR_CNT_LN_19r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_19r,_r._bip_err_cnt_ln_19)
#define BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_19r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BIP_ERR_CNT_LN_19r,_r._bip_err_cnt_ln_19)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BIP_ERR_CNT_LN_19r BCMI_MADURA_BIP_ERR_CNT_LN_19r
#define BIP_ERR_CNT_LN_19r_SIZE BCMI_MADURA_BIP_ERR_CNT_LN_19r_SIZE
typedef BCMI_MADURA_BIP_ERR_CNT_LN_19r_t BIP_ERR_CNT_LN_19r_t;
#define BIP_ERR_CNT_LN_19r_CLR BCMI_MADURA_BIP_ERR_CNT_LN_19r_CLR
#define BIP_ERR_CNT_LN_19r_SET BCMI_MADURA_BIP_ERR_CNT_LN_19r_SET
#define BIP_ERR_CNT_LN_19r_GET BCMI_MADURA_BIP_ERR_CNT_LN_19r_GET
#define BIP_ERR_CNT_LN_19r_BIP_ERR_CNT_LN_19f_GET BCMI_MADURA_BIP_ERR_CNT_LN_19r_BIP_ERR_CNT_LN_19f_GET
#define BIP_ERR_CNT_LN_19r_BIP_ERR_CNT_LN_19f_SET BCMI_MADURA_BIP_ERR_CNT_LN_19r_BIP_ERR_CNT_LN_19f_SET
#define READ_BIP_ERR_CNT_LN_19r BCMI_MADURA_READ_BIP_ERR_CNT_LN_19r
#define WRITE_BIP_ERR_CNT_LN_19r BCMI_MADURA_WRITE_BIP_ERR_CNT_LN_19r
#define MODIFY_BIP_ERR_CNT_LN_19r BCMI_MADURA_MODIFY_BIP_ERR_CNT_LN_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BIP_ERR_CNT_LN_19r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_0_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00fa
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_0_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_0_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 0, the detected PCS lane number is recorded in this register. The contents of the lane 0 mapping register is valid when lane 0 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_0_MAPr (0x000100fa | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_0_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_0_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_0_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_0_map[1];
	uint32_t _pcs_ln_0_map;
} BCMI_MADURA_PCS_LN_0_MAPr_t;

#define BCMI_MADURA_PCS_LN_0_MAPr_CLR(r) (r).pcs_ln_0_map[0] = 0
#define BCMI_MADURA_PCS_LN_0_MAPr_SET(r,d) (r).pcs_ln_0_map[0] = d
#define BCMI_MADURA_PCS_LN_0_MAPr_GET(r) (r).pcs_ln_0_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_0_MAPr_PCS_LN_0_MAPPINGf_GET(r) (((r).pcs_ln_0_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_0_MAPr_PCS_LN_0_MAPPINGf_SET(r,f) (r).pcs_ln_0_map[0]=(((r).pcs_ln_0_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_0_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_0_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_0_MAPr,_r._pcs_ln_0_map)
#define BCMI_MADURA_WRITE_PCS_LN_0_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_0_MAPr,_r._pcs_ln_0_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_0_MAPr BCMI_MADURA_PCS_LN_0_MAPr
#define PCS_LN_0_MAPr_SIZE BCMI_MADURA_PCS_LN_0_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_0_MAPr_t PCS_LN_0_MAPr_t;
#define PCS_LN_0_MAPr_CLR BCMI_MADURA_PCS_LN_0_MAPr_CLR
#define PCS_LN_0_MAPr_SET BCMI_MADURA_PCS_LN_0_MAPr_SET
#define PCS_LN_0_MAPr_GET BCMI_MADURA_PCS_LN_0_MAPr_GET
#define PCS_LN_0_MAPr_PCS_LN_0_MAPPINGf_GET BCMI_MADURA_PCS_LN_0_MAPr_PCS_LN_0_MAPPINGf_GET
#define PCS_LN_0_MAPr_PCS_LN_0_MAPPINGf_SET BCMI_MADURA_PCS_LN_0_MAPr_PCS_LN_0_MAPPINGf_SET
#define READ_PCS_LN_0_MAPr BCMI_MADURA_READ_PCS_LN_0_MAPr
#define WRITE_PCS_LN_0_MAPr BCMI_MADURA_WRITE_PCS_LN_0_MAPr
#define MODIFY_PCS_LN_0_MAPr BCMI_MADURA_MODIFY_PCS_LN_0_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_0_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_1_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00fb
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_1_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_1_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 1, the detected PCS lane number is recorded in this register. The contents of the lane 1 mapping register is valid when lane 1 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_1_MAPr (0x000100fb | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_1_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_1_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_1_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_1_map[1];
	uint32_t _pcs_ln_1_map;
} BCMI_MADURA_PCS_LN_1_MAPr_t;

#define BCMI_MADURA_PCS_LN_1_MAPr_CLR(r) (r).pcs_ln_1_map[0] = 0
#define BCMI_MADURA_PCS_LN_1_MAPr_SET(r,d) (r).pcs_ln_1_map[0] = d
#define BCMI_MADURA_PCS_LN_1_MAPr_GET(r) (r).pcs_ln_1_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_1_MAPr_PCS_LN_1_MAPPINGf_GET(r) (((r).pcs_ln_1_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_1_MAPr_PCS_LN_1_MAPPINGf_SET(r,f) (r).pcs_ln_1_map[0]=(((r).pcs_ln_1_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_1_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_1_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_1_MAPr,_r._pcs_ln_1_map)
#define BCMI_MADURA_WRITE_PCS_LN_1_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_1_MAPr,_r._pcs_ln_1_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_1_MAPr BCMI_MADURA_PCS_LN_1_MAPr
#define PCS_LN_1_MAPr_SIZE BCMI_MADURA_PCS_LN_1_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_1_MAPr_t PCS_LN_1_MAPr_t;
#define PCS_LN_1_MAPr_CLR BCMI_MADURA_PCS_LN_1_MAPr_CLR
#define PCS_LN_1_MAPr_SET BCMI_MADURA_PCS_LN_1_MAPr_SET
#define PCS_LN_1_MAPr_GET BCMI_MADURA_PCS_LN_1_MAPr_GET
#define PCS_LN_1_MAPr_PCS_LN_1_MAPPINGf_GET BCMI_MADURA_PCS_LN_1_MAPr_PCS_LN_1_MAPPINGf_GET
#define PCS_LN_1_MAPr_PCS_LN_1_MAPPINGf_SET BCMI_MADURA_PCS_LN_1_MAPr_PCS_LN_1_MAPPINGf_SET
#define READ_PCS_LN_1_MAPr BCMI_MADURA_READ_PCS_LN_1_MAPr
#define WRITE_PCS_LN_1_MAPr BCMI_MADURA_WRITE_PCS_LN_1_MAPr
#define MODIFY_PCS_LN_1_MAPr BCMI_MADURA_MODIFY_PCS_LN_1_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_1_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_2_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00fc
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_2_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_2_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 2, the detected PCS lane number is recorded in this register. The contents of the lane 2 mapping register is valid when lane 2 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_2_MAPr (0x000100fc | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_2_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_2_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_2_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_2_map[1];
	uint32_t _pcs_ln_2_map;
} BCMI_MADURA_PCS_LN_2_MAPr_t;

#define BCMI_MADURA_PCS_LN_2_MAPr_CLR(r) (r).pcs_ln_2_map[0] = 0
#define BCMI_MADURA_PCS_LN_2_MAPr_SET(r,d) (r).pcs_ln_2_map[0] = d
#define BCMI_MADURA_PCS_LN_2_MAPr_GET(r) (r).pcs_ln_2_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_2_MAPr_PCS_LN_2_MAPPINGf_GET(r) (((r).pcs_ln_2_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_2_MAPr_PCS_LN_2_MAPPINGf_SET(r,f) (r).pcs_ln_2_map[0]=(((r).pcs_ln_2_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_2_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_2_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_2_MAPr,_r._pcs_ln_2_map)
#define BCMI_MADURA_WRITE_PCS_LN_2_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_2_MAPr,_r._pcs_ln_2_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_2_MAPr BCMI_MADURA_PCS_LN_2_MAPr
#define PCS_LN_2_MAPr_SIZE BCMI_MADURA_PCS_LN_2_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_2_MAPr_t PCS_LN_2_MAPr_t;
#define PCS_LN_2_MAPr_CLR BCMI_MADURA_PCS_LN_2_MAPr_CLR
#define PCS_LN_2_MAPr_SET BCMI_MADURA_PCS_LN_2_MAPr_SET
#define PCS_LN_2_MAPr_GET BCMI_MADURA_PCS_LN_2_MAPr_GET
#define PCS_LN_2_MAPr_PCS_LN_2_MAPPINGf_GET BCMI_MADURA_PCS_LN_2_MAPr_PCS_LN_2_MAPPINGf_GET
#define PCS_LN_2_MAPr_PCS_LN_2_MAPPINGf_SET BCMI_MADURA_PCS_LN_2_MAPr_PCS_LN_2_MAPPINGf_SET
#define READ_PCS_LN_2_MAPr BCMI_MADURA_READ_PCS_LN_2_MAPr
#define WRITE_PCS_LN_2_MAPr BCMI_MADURA_WRITE_PCS_LN_2_MAPr
#define MODIFY_PCS_LN_2_MAPr BCMI_MADURA_MODIFY_PCS_LN_2_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_2_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_3_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00fd
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_3_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_3_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 3, the detected PCS lane number is recorded in this register. The contents of the lane 3 mapping register is valid when lane 3 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_3_MAPr (0x000100fd | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_3_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_3_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_3_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_3_map[1];
	uint32_t _pcs_ln_3_map;
} BCMI_MADURA_PCS_LN_3_MAPr_t;

#define BCMI_MADURA_PCS_LN_3_MAPr_CLR(r) (r).pcs_ln_3_map[0] = 0
#define BCMI_MADURA_PCS_LN_3_MAPr_SET(r,d) (r).pcs_ln_3_map[0] = d
#define BCMI_MADURA_PCS_LN_3_MAPr_GET(r) (r).pcs_ln_3_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_3_MAPr_PCS_LN_3_MAPPINGf_GET(r) (((r).pcs_ln_3_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_3_MAPr_PCS_LN_3_MAPPINGf_SET(r,f) (r).pcs_ln_3_map[0]=(((r).pcs_ln_3_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_3_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_3_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_3_MAPr,_r._pcs_ln_3_map)
#define BCMI_MADURA_WRITE_PCS_LN_3_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_3_MAPr,_r._pcs_ln_3_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_3_MAPr BCMI_MADURA_PCS_LN_3_MAPr
#define PCS_LN_3_MAPr_SIZE BCMI_MADURA_PCS_LN_3_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_3_MAPr_t PCS_LN_3_MAPr_t;
#define PCS_LN_3_MAPr_CLR BCMI_MADURA_PCS_LN_3_MAPr_CLR
#define PCS_LN_3_MAPr_SET BCMI_MADURA_PCS_LN_3_MAPr_SET
#define PCS_LN_3_MAPr_GET BCMI_MADURA_PCS_LN_3_MAPr_GET
#define PCS_LN_3_MAPr_PCS_LN_3_MAPPINGf_GET BCMI_MADURA_PCS_LN_3_MAPr_PCS_LN_3_MAPPINGf_GET
#define PCS_LN_3_MAPr_PCS_LN_3_MAPPINGf_SET BCMI_MADURA_PCS_LN_3_MAPr_PCS_LN_3_MAPPINGf_SET
#define READ_PCS_LN_3_MAPr BCMI_MADURA_READ_PCS_LN_3_MAPr
#define WRITE_PCS_LN_3_MAPr BCMI_MADURA_WRITE_PCS_LN_3_MAPr
#define MODIFY_PCS_LN_3_MAPr BCMI_MADURA_MODIFY_PCS_LN_3_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_3_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_4_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00fe
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_4_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_4_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 4, the detected PCS lane number is recorded in this register. The contents of the lane 4 mapping register is valid when lane 4 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_4_MAPr (0x000100fe | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_4_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_4_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_4_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_4_map[1];
	uint32_t _pcs_ln_4_map;
} BCMI_MADURA_PCS_LN_4_MAPr_t;

#define BCMI_MADURA_PCS_LN_4_MAPr_CLR(r) (r).pcs_ln_4_map[0] = 0
#define BCMI_MADURA_PCS_LN_4_MAPr_SET(r,d) (r).pcs_ln_4_map[0] = d
#define BCMI_MADURA_PCS_LN_4_MAPr_GET(r) (r).pcs_ln_4_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_4_MAPr_PCS_LN_4_MAPPINGf_GET(r) (((r).pcs_ln_4_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_4_MAPr_PCS_LN_4_MAPPINGf_SET(r,f) (r).pcs_ln_4_map[0]=(((r).pcs_ln_4_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_4_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_4_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_4_MAPr,_r._pcs_ln_4_map)
#define BCMI_MADURA_WRITE_PCS_LN_4_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_4_MAPr,_r._pcs_ln_4_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_4_MAPr BCMI_MADURA_PCS_LN_4_MAPr
#define PCS_LN_4_MAPr_SIZE BCMI_MADURA_PCS_LN_4_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_4_MAPr_t PCS_LN_4_MAPr_t;
#define PCS_LN_4_MAPr_CLR BCMI_MADURA_PCS_LN_4_MAPr_CLR
#define PCS_LN_4_MAPr_SET BCMI_MADURA_PCS_LN_4_MAPr_SET
#define PCS_LN_4_MAPr_GET BCMI_MADURA_PCS_LN_4_MAPr_GET
#define PCS_LN_4_MAPr_PCS_LN_4_MAPPINGf_GET BCMI_MADURA_PCS_LN_4_MAPr_PCS_LN_4_MAPPINGf_GET
#define PCS_LN_4_MAPr_PCS_LN_4_MAPPINGf_SET BCMI_MADURA_PCS_LN_4_MAPr_PCS_LN_4_MAPPINGf_SET
#define READ_PCS_LN_4_MAPr BCMI_MADURA_READ_PCS_LN_4_MAPr
#define WRITE_PCS_LN_4_MAPr BCMI_MADURA_WRITE_PCS_LN_4_MAPr
#define MODIFY_PCS_LN_4_MAPr BCMI_MADURA_MODIFY_PCS_LN_4_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_4_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_5_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x00ff
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_5_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_5_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 5, the detected PCS lane number is recorded in this register. The contents of the lane 5 mapping register is valid when lane 5 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_5_MAPr (0x000100ff | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_5_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_5_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_5_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_5_map[1];
	uint32_t _pcs_ln_5_map;
} BCMI_MADURA_PCS_LN_5_MAPr_t;

#define BCMI_MADURA_PCS_LN_5_MAPr_CLR(r) (r).pcs_ln_5_map[0] = 0
#define BCMI_MADURA_PCS_LN_5_MAPr_SET(r,d) (r).pcs_ln_5_map[0] = d
#define BCMI_MADURA_PCS_LN_5_MAPr_GET(r) (r).pcs_ln_5_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_5_MAPr_PCS_LN_5_MAPPINGf_GET(r) (((r).pcs_ln_5_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_5_MAPr_PCS_LN_5_MAPPINGf_SET(r,f) (r).pcs_ln_5_map[0]=(((r).pcs_ln_5_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_5_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_5_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_5_MAPr,_r._pcs_ln_5_map)
#define BCMI_MADURA_WRITE_PCS_LN_5_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_5_MAPr,_r._pcs_ln_5_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_5_MAPr BCMI_MADURA_PCS_LN_5_MAPr
#define PCS_LN_5_MAPr_SIZE BCMI_MADURA_PCS_LN_5_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_5_MAPr_t PCS_LN_5_MAPr_t;
#define PCS_LN_5_MAPr_CLR BCMI_MADURA_PCS_LN_5_MAPr_CLR
#define PCS_LN_5_MAPr_SET BCMI_MADURA_PCS_LN_5_MAPr_SET
#define PCS_LN_5_MAPr_GET BCMI_MADURA_PCS_LN_5_MAPr_GET
#define PCS_LN_5_MAPr_PCS_LN_5_MAPPINGf_GET BCMI_MADURA_PCS_LN_5_MAPr_PCS_LN_5_MAPPINGf_GET
#define PCS_LN_5_MAPr_PCS_LN_5_MAPPINGf_SET BCMI_MADURA_PCS_LN_5_MAPr_PCS_LN_5_MAPPINGf_SET
#define READ_PCS_LN_5_MAPr BCMI_MADURA_READ_PCS_LN_5_MAPr
#define WRITE_PCS_LN_5_MAPr BCMI_MADURA_WRITE_PCS_LN_5_MAPr
#define MODIFY_PCS_LN_5_MAPr BCMI_MADURA_MODIFY_PCS_LN_5_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_5_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_6_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0100
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_6_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_6_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 6, the detected PCS lane number is recorded in this register. The contents of the lane 6 mapping register is valid when lane 6 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_6_MAPr (0x00010100 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_6_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_6_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_6_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_6_map[1];
	uint32_t _pcs_ln_6_map;
} BCMI_MADURA_PCS_LN_6_MAPr_t;

#define BCMI_MADURA_PCS_LN_6_MAPr_CLR(r) (r).pcs_ln_6_map[0] = 0
#define BCMI_MADURA_PCS_LN_6_MAPr_SET(r,d) (r).pcs_ln_6_map[0] = d
#define BCMI_MADURA_PCS_LN_6_MAPr_GET(r) (r).pcs_ln_6_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_6_MAPr_PCS_LN_6_MAPPINGf_GET(r) (((r).pcs_ln_6_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_6_MAPr_PCS_LN_6_MAPPINGf_SET(r,f) (r).pcs_ln_6_map[0]=(((r).pcs_ln_6_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_6_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_6_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_6_MAPr,_r._pcs_ln_6_map)
#define BCMI_MADURA_WRITE_PCS_LN_6_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_6_MAPr,_r._pcs_ln_6_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_6_MAPr BCMI_MADURA_PCS_LN_6_MAPr
#define PCS_LN_6_MAPr_SIZE BCMI_MADURA_PCS_LN_6_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_6_MAPr_t PCS_LN_6_MAPr_t;
#define PCS_LN_6_MAPr_CLR BCMI_MADURA_PCS_LN_6_MAPr_CLR
#define PCS_LN_6_MAPr_SET BCMI_MADURA_PCS_LN_6_MAPr_SET
#define PCS_LN_6_MAPr_GET BCMI_MADURA_PCS_LN_6_MAPr_GET
#define PCS_LN_6_MAPr_PCS_LN_6_MAPPINGf_GET BCMI_MADURA_PCS_LN_6_MAPr_PCS_LN_6_MAPPINGf_GET
#define PCS_LN_6_MAPr_PCS_LN_6_MAPPINGf_SET BCMI_MADURA_PCS_LN_6_MAPr_PCS_LN_6_MAPPINGf_SET
#define READ_PCS_LN_6_MAPr BCMI_MADURA_READ_PCS_LN_6_MAPr
#define WRITE_PCS_LN_6_MAPr BCMI_MADURA_WRITE_PCS_LN_6_MAPr
#define MODIFY_PCS_LN_6_MAPr BCMI_MADURA_MODIFY_PCS_LN_6_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_6_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_7_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0101
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_7_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_7_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 7, the detected PCS lane number is recorded in this register. The contents of the lane 7 mapping register is valid when lane 7 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_7_MAPr (0x00010101 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_7_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_7_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_7_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_7_map[1];
	uint32_t _pcs_ln_7_map;
} BCMI_MADURA_PCS_LN_7_MAPr_t;

#define BCMI_MADURA_PCS_LN_7_MAPr_CLR(r) (r).pcs_ln_7_map[0] = 0
#define BCMI_MADURA_PCS_LN_7_MAPr_SET(r,d) (r).pcs_ln_7_map[0] = d
#define BCMI_MADURA_PCS_LN_7_MAPr_GET(r) (r).pcs_ln_7_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_7_MAPr_PCS_LN_7_MAPPINGf_GET(r) (((r).pcs_ln_7_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_7_MAPr_PCS_LN_7_MAPPINGf_SET(r,f) (r).pcs_ln_7_map[0]=(((r).pcs_ln_7_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_7_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_7_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_7_MAPr,_r._pcs_ln_7_map)
#define BCMI_MADURA_WRITE_PCS_LN_7_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_7_MAPr,_r._pcs_ln_7_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_7_MAPr BCMI_MADURA_PCS_LN_7_MAPr
#define PCS_LN_7_MAPr_SIZE BCMI_MADURA_PCS_LN_7_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_7_MAPr_t PCS_LN_7_MAPr_t;
#define PCS_LN_7_MAPr_CLR BCMI_MADURA_PCS_LN_7_MAPr_CLR
#define PCS_LN_7_MAPr_SET BCMI_MADURA_PCS_LN_7_MAPr_SET
#define PCS_LN_7_MAPr_GET BCMI_MADURA_PCS_LN_7_MAPr_GET
#define PCS_LN_7_MAPr_PCS_LN_7_MAPPINGf_GET BCMI_MADURA_PCS_LN_7_MAPr_PCS_LN_7_MAPPINGf_GET
#define PCS_LN_7_MAPr_PCS_LN_7_MAPPINGf_SET BCMI_MADURA_PCS_LN_7_MAPr_PCS_LN_7_MAPPINGf_SET
#define READ_PCS_LN_7_MAPr BCMI_MADURA_READ_PCS_LN_7_MAPr
#define WRITE_PCS_LN_7_MAPr BCMI_MADURA_WRITE_PCS_LN_7_MAPr
#define MODIFY_PCS_LN_7_MAPr BCMI_MADURA_MODIFY_PCS_LN_7_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_7_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_8_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0102
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_8_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_8_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 8, the detected PCS lane number is recorded in this register. The contents of the lane 8 mapping register is valid when lane 8 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_8_MAPr (0x00010102 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_8_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_8_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_8_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_8_map[1];
	uint32_t _pcs_ln_8_map;
} BCMI_MADURA_PCS_LN_8_MAPr_t;

#define BCMI_MADURA_PCS_LN_8_MAPr_CLR(r) (r).pcs_ln_8_map[0] = 0
#define BCMI_MADURA_PCS_LN_8_MAPr_SET(r,d) (r).pcs_ln_8_map[0] = d
#define BCMI_MADURA_PCS_LN_8_MAPr_GET(r) (r).pcs_ln_8_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_8_MAPr_PCS_LN_8_MAPPINGf_GET(r) (((r).pcs_ln_8_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_8_MAPr_PCS_LN_8_MAPPINGf_SET(r,f) (r).pcs_ln_8_map[0]=(((r).pcs_ln_8_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_8_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_8_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_8_MAPr,_r._pcs_ln_8_map)
#define BCMI_MADURA_WRITE_PCS_LN_8_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_8_MAPr,_r._pcs_ln_8_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_8_MAPr BCMI_MADURA_PCS_LN_8_MAPr
#define PCS_LN_8_MAPr_SIZE BCMI_MADURA_PCS_LN_8_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_8_MAPr_t PCS_LN_8_MAPr_t;
#define PCS_LN_8_MAPr_CLR BCMI_MADURA_PCS_LN_8_MAPr_CLR
#define PCS_LN_8_MAPr_SET BCMI_MADURA_PCS_LN_8_MAPr_SET
#define PCS_LN_8_MAPr_GET BCMI_MADURA_PCS_LN_8_MAPr_GET
#define PCS_LN_8_MAPr_PCS_LN_8_MAPPINGf_GET BCMI_MADURA_PCS_LN_8_MAPr_PCS_LN_8_MAPPINGf_GET
#define PCS_LN_8_MAPr_PCS_LN_8_MAPPINGf_SET BCMI_MADURA_PCS_LN_8_MAPr_PCS_LN_8_MAPPINGf_SET
#define READ_PCS_LN_8_MAPr BCMI_MADURA_READ_PCS_LN_8_MAPr
#define WRITE_PCS_LN_8_MAPr BCMI_MADURA_WRITE_PCS_LN_8_MAPr
#define MODIFY_PCS_LN_8_MAPr BCMI_MADURA_MODIFY_PCS_LN_8_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_8_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_9_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0103
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_9_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_9_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 9, the detected PCS lane number is recorded in this register. The contents of the lane 9 mapping register is valid when lane 9 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_9_MAPr (0x00010103 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_9_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_9_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_9_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_9_map[1];
	uint32_t _pcs_ln_9_map;
} BCMI_MADURA_PCS_LN_9_MAPr_t;

#define BCMI_MADURA_PCS_LN_9_MAPr_CLR(r) (r).pcs_ln_9_map[0] = 0
#define BCMI_MADURA_PCS_LN_9_MAPr_SET(r,d) (r).pcs_ln_9_map[0] = d
#define BCMI_MADURA_PCS_LN_9_MAPr_GET(r) (r).pcs_ln_9_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_9_MAPr_PCS_LN_9_MAPPINGf_GET(r) (((r).pcs_ln_9_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_9_MAPr_PCS_LN_9_MAPPINGf_SET(r,f) (r).pcs_ln_9_map[0]=(((r).pcs_ln_9_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_9_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_9_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_9_MAPr,_r._pcs_ln_9_map)
#define BCMI_MADURA_WRITE_PCS_LN_9_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_9_MAPr,_r._pcs_ln_9_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_9_MAPr BCMI_MADURA_PCS_LN_9_MAPr
#define PCS_LN_9_MAPr_SIZE BCMI_MADURA_PCS_LN_9_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_9_MAPr_t PCS_LN_9_MAPr_t;
#define PCS_LN_9_MAPr_CLR BCMI_MADURA_PCS_LN_9_MAPr_CLR
#define PCS_LN_9_MAPr_SET BCMI_MADURA_PCS_LN_9_MAPr_SET
#define PCS_LN_9_MAPr_GET BCMI_MADURA_PCS_LN_9_MAPr_GET
#define PCS_LN_9_MAPr_PCS_LN_9_MAPPINGf_GET BCMI_MADURA_PCS_LN_9_MAPr_PCS_LN_9_MAPPINGf_GET
#define PCS_LN_9_MAPr_PCS_LN_9_MAPPINGf_SET BCMI_MADURA_PCS_LN_9_MAPr_PCS_LN_9_MAPPINGf_SET
#define READ_PCS_LN_9_MAPr BCMI_MADURA_READ_PCS_LN_9_MAPr
#define WRITE_PCS_LN_9_MAPr BCMI_MADURA_WRITE_PCS_LN_9_MAPr
#define MODIFY_PCS_LN_9_MAPr BCMI_MADURA_MODIFY_PCS_LN_9_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_9_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_10_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0104
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_10_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_10_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 10, the detected PCS lane number is recorded in this register. The contents of the lane 10 mapping register is valid when lane 10 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_10_MAPr (0x00010104 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_10_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_10_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_10_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_10_map[1];
	uint32_t _pcs_ln_10_map;
} BCMI_MADURA_PCS_LN_10_MAPr_t;

#define BCMI_MADURA_PCS_LN_10_MAPr_CLR(r) (r).pcs_ln_10_map[0] = 0
#define BCMI_MADURA_PCS_LN_10_MAPr_SET(r,d) (r).pcs_ln_10_map[0] = d
#define BCMI_MADURA_PCS_LN_10_MAPr_GET(r) (r).pcs_ln_10_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_10_MAPr_PCS_LN_10_MAPPINGf_GET(r) (((r).pcs_ln_10_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_10_MAPr_PCS_LN_10_MAPPINGf_SET(r,f) (r).pcs_ln_10_map[0]=(((r).pcs_ln_10_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_10_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_10_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_10_MAPr,_r._pcs_ln_10_map)
#define BCMI_MADURA_WRITE_PCS_LN_10_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_10_MAPr,_r._pcs_ln_10_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_10_MAPr BCMI_MADURA_PCS_LN_10_MAPr
#define PCS_LN_10_MAPr_SIZE BCMI_MADURA_PCS_LN_10_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_10_MAPr_t PCS_LN_10_MAPr_t;
#define PCS_LN_10_MAPr_CLR BCMI_MADURA_PCS_LN_10_MAPr_CLR
#define PCS_LN_10_MAPr_SET BCMI_MADURA_PCS_LN_10_MAPr_SET
#define PCS_LN_10_MAPr_GET BCMI_MADURA_PCS_LN_10_MAPr_GET
#define PCS_LN_10_MAPr_PCS_LN_10_MAPPINGf_GET BCMI_MADURA_PCS_LN_10_MAPr_PCS_LN_10_MAPPINGf_GET
#define PCS_LN_10_MAPr_PCS_LN_10_MAPPINGf_SET BCMI_MADURA_PCS_LN_10_MAPr_PCS_LN_10_MAPPINGf_SET
#define READ_PCS_LN_10_MAPr BCMI_MADURA_READ_PCS_LN_10_MAPr
#define WRITE_PCS_LN_10_MAPr BCMI_MADURA_WRITE_PCS_LN_10_MAPr
#define MODIFY_PCS_LN_10_MAPr BCMI_MADURA_MODIFY_PCS_LN_10_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_10_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_11_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0105
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_11_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_11_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 11, the detected PCS lane number is recorded in this register. The contents of the lane 11 mapping register is valid when lane 11 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_11_MAPr (0x00010105 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_11_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_11_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_11_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_11_map[1];
	uint32_t _pcs_ln_11_map;
} BCMI_MADURA_PCS_LN_11_MAPr_t;

#define BCMI_MADURA_PCS_LN_11_MAPr_CLR(r) (r).pcs_ln_11_map[0] = 0
#define BCMI_MADURA_PCS_LN_11_MAPr_SET(r,d) (r).pcs_ln_11_map[0] = d
#define BCMI_MADURA_PCS_LN_11_MAPr_GET(r) (r).pcs_ln_11_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_11_MAPr_PCS_LN_11_MAPPINGf_GET(r) (((r).pcs_ln_11_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_11_MAPr_PCS_LN_11_MAPPINGf_SET(r,f) (r).pcs_ln_11_map[0]=(((r).pcs_ln_11_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_11_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_11_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_11_MAPr,_r._pcs_ln_11_map)
#define BCMI_MADURA_WRITE_PCS_LN_11_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_11_MAPr,_r._pcs_ln_11_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_11_MAPr BCMI_MADURA_PCS_LN_11_MAPr
#define PCS_LN_11_MAPr_SIZE BCMI_MADURA_PCS_LN_11_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_11_MAPr_t PCS_LN_11_MAPr_t;
#define PCS_LN_11_MAPr_CLR BCMI_MADURA_PCS_LN_11_MAPr_CLR
#define PCS_LN_11_MAPr_SET BCMI_MADURA_PCS_LN_11_MAPr_SET
#define PCS_LN_11_MAPr_GET BCMI_MADURA_PCS_LN_11_MAPr_GET
#define PCS_LN_11_MAPr_PCS_LN_11_MAPPINGf_GET BCMI_MADURA_PCS_LN_11_MAPr_PCS_LN_11_MAPPINGf_GET
#define PCS_LN_11_MAPr_PCS_LN_11_MAPPINGf_SET BCMI_MADURA_PCS_LN_11_MAPr_PCS_LN_11_MAPPINGf_SET
#define READ_PCS_LN_11_MAPr BCMI_MADURA_READ_PCS_LN_11_MAPr
#define WRITE_PCS_LN_11_MAPr BCMI_MADURA_WRITE_PCS_LN_11_MAPr
#define MODIFY_PCS_LN_11_MAPr BCMI_MADURA_MODIFY_PCS_LN_11_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_11_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_12_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0106
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_12_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_12_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 12, the detected PCS lane number is recorded in this register. The contents of the lane 12 mapping register is valid when lane 12 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_12_MAPr (0x00010106 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_12_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_12_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_12_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_12_map[1];
	uint32_t _pcs_ln_12_map;
} BCMI_MADURA_PCS_LN_12_MAPr_t;

#define BCMI_MADURA_PCS_LN_12_MAPr_CLR(r) (r).pcs_ln_12_map[0] = 0
#define BCMI_MADURA_PCS_LN_12_MAPr_SET(r,d) (r).pcs_ln_12_map[0] = d
#define BCMI_MADURA_PCS_LN_12_MAPr_GET(r) (r).pcs_ln_12_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_12_MAPr_PCS_LN_12_MAPPINGf_GET(r) (((r).pcs_ln_12_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_12_MAPr_PCS_LN_12_MAPPINGf_SET(r,f) (r).pcs_ln_12_map[0]=(((r).pcs_ln_12_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_12_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_12_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_12_MAPr,_r._pcs_ln_12_map)
#define BCMI_MADURA_WRITE_PCS_LN_12_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_12_MAPr,_r._pcs_ln_12_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_12_MAPr BCMI_MADURA_PCS_LN_12_MAPr
#define PCS_LN_12_MAPr_SIZE BCMI_MADURA_PCS_LN_12_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_12_MAPr_t PCS_LN_12_MAPr_t;
#define PCS_LN_12_MAPr_CLR BCMI_MADURA_PCS_LN_12_MAPr_CLR
#define PCS_LN_12_MAPr_SET BCMI_MADURA_PCS_LN_12_MAPr_SET
#define PCS_LN_12_MAPr_GET BCMI_MADURA_PCS_LN_12_MAPr_GET
#define PCS_LN_12_MAPr_PCS_LN_12_MAPPINGf_GET BCMI_MADURA_PCS_LN_12_MAPr_PCS_LN_12_MAPPINGf_GET
#define PCS_LN_12_MAPr_PCS_LN_12_MAPPINGf_SET BCMI_MADURA_PCS_LN_12_MAPr_PCS_LN_12_MAPPINGf_SET
#define READ_PCS_LN_12_MAPr BCMI_MADURA_READ_PCS_LN_12_MAPr
#define WRITE_PCS_LN_12_MAPr BCMI_MADURA_WRITE_PCS_LN_12_MAPr
#define MODIFY_PCS_LN_12_MAPr BCMI_MADURA_MODIFY_PCS_LN_12_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_12_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_13_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0107
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_13_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_13_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 13, the detected PCS lane number is recorded in this register. The contents of the lane 13 mapping register is valid when lane 13 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_13_MAPr (0x00010107 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_13_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_13_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_13_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_13_map[1];
	uint32_t _pcs_ln_13_map;
} BCMI_MADURA_PCS_LN_13_MAPr_t;

#define BCMI_MADURA_PCS_LN_13_MAPr_CLR(r) (r).pcs_ln_13_map[0] = 0
#define BCMI_MADURA_PCS_LN_13_MAPr_SET(r,d) (r).pcs_ln_13_map[0] = d
#define BCMI_MADURA_PCS_LN_13_MAPr_GET(r) (r).pcs_ln_13_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_13_MAPr_PCS_LN_13_MAPPINGf_GET(r) (((r).pcs_ln_13_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_13_MAPr_PCS_LN_13_MAPPINGf_SET(r,f) (r).pcs_ln_13_map[0]=(((r).pcs_ln_13_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_13_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_13_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_13_MAPr,_r._pcs_ln_13_map)
#define BCMI_MADURA_WRITE_PCS_LN_13_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_13_MAPr,_r._pcs_ln_13_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_13_MAPr BCMI_MADURA_PCS_LN_13_MAPr
#define PCS_LN_13_MAPr_SIZE BCMI_MADURA_PCS_LN_13_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_13_MAPr_t PCS_LN_13_MAPr_t;
#define PCS_LN_13_MAPr_CLR BCMI_MADURA_PCS_LN_13_MAPr_CLR
#define PCS_LN_13_MAPr_SET BCMI_MADURA_PCS_LN_13_MAPr_SET
#define PCS_LN_13_MAPr_GET BCMI_MADURA_PCS_LN_13_MAPr_GET
#define PCS_LN_13_MAPr_PCS_LN_13_MAPPINGf_GET BCMI_MADURA_PCS_LN_13_MAPr_PCS_LN_13_MAPPINGf_GET
#define PCS_LN_13_MAPr_PCS_LN_13_MAPPINGf_SET BCMI_MADURA_PCS_LN_13_MAPr_PCS_LN_13_MAPPINGf_SET
#define READ_PCS_LN_13_MAPr BCMI_MADURA_READ_PCS_LN_13_MAPr
#define WRITE_PCS_LN_13_MAPr BCMI_MADURA_WRITE_PCS_LN_13_MAPr
#define MODIFY_PCS_LN_13_MAPr BCMI_MADURA_MODIFY_PCS_LN_13_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_13_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_14_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0108
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_14_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_14_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 14, the detected PCS lane number is recorded in this register. The contents of the lane 14 mapping register is valid when lane 14 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_14_MAPr (0x00010108 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_14_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_14_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_14_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_14_map[1];
	uint32_t _pcs_ln_14_map;
} BCMI_MADURA_PCS_LN_14_MAPr_t;

#define BCMI_MADURA_PCS_LN_14_MAPr_CLR(r) (r).pcs_ln_14_map[0] = 0
#define BCMI_MADURA_PCS_LN_14_MAPr_SET(r,d) (r).pcs_ln_14_map[0] = d
#define BCMI_MADURA_PCS_LN_14_MAPr_GET(r) (r).pcs_ln_14_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_14_MAPr_PCS_LN_14_MAPPINGf_GET(r) (((r).pcs_ln_14_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_14_MAPr_PCS_LN_14_MAPPINGf_SET(r,f) (r).pcs_ln_14_map[0]=(((r).pcs_ln_14_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_14_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_14_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_14_MAPr,_r._pcs_ln_14_map)
#define BCMI_MADURA_WRITE_PCS_LN_14_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_14_MAPr,_r._pcs_ln_14_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_14_MAPr BCMI_MADURA_PCS_LN_14_MAPr
#define PCS_LN_14_MAPr_SIZE BCMI_MADURA_PCS_LN_14_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_14_MAPr_t PCS_LN_14_MAPr_t;
#define PCS_LN_14_MAPr_CLR BCMI_MADURA_PCS_LN_14_MAPr_CLR
#define PCS_LN_14_MAPr_SET BCMI_MADURA_PCS_LN_14_MAPr_SET
#define PCS_LN_14_MAPr_GET BCMI_MADURA_PCS_LN_14_MAPr_GET
#define PCS_LN_14_MAPr_PCS_LN_14_MAPPINGf_GET BCMI_MADURA_PCS_LN_14_MAPr_PCS_LN_14_MAPPINGf_GET
#define PCS_LN_14_MAPr_PCS_LN_14_MAPPINGf_SET BCMI_MADURA_PCS_LN_14_MAPr_PCS_LN_14_MAPPINGf_SET
#define READ_PCS_LN_14_MAPr BCMI_MADURA_READ_PCS_LN_14_MAPr
#define WRITE_PCS_LN_14_MAPr BCMI_MADURA_WRITE_PCS_LN_14_MAPr
#define MODIFY_PCS_LN_14_MAPr BCMI_MADURA_MODIFY_PCS_LN_14_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_14_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_15_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0109
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_15_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_15_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 15, the detected PCS lane number is recorded in this register. The contents of the lane 15 mapping register is valid when lane 15 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_15_MAPr (0x00010109 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_15_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_15_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_15_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_15_map[1];
	uint32_t _pcs_ln_15_map;
} BCMI_MADURA_PCS_LN_15_MAPr_t;

#define BCMI_MADURA_PCS_LN_15_MAPr_CLR(r) (r).pcs_ln_15_map[0] = 0
#define BCMI_MADURA_PCS_LN_15_MAPr_SET(r,d) (r).pcs_ln_15_map[0] = d
#define BCMI_MADURA_PCS_LN_15_MAPr_GET(r) (r).pcs_ln_15_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_15_MAPr_PCS_LN_15_MAPPINGf_GET(r) (((r).pcs_ln_15_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_15_MAPr_PCS_LN_15_MAPPINGf_SET(r,f) (r).pcs_ln_15_map[0]=(((r).pcs_ln_15_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_15_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_15_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_15_MAPr,_r._pcs_ln_15_map)
#define BCMI_MADURA_WRITE_PCS_LN_15_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_15_MAPr,_r._pcs_ln_15_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_15_MAPr BCMI_MADURA_PCS_LN_15_MAPr
#define PCS_LN_15_MAPr_SIZE BCMI_MADURA_PCS_LN_15_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_15_MAPr_t PCS_LN_15_MAPr_t;
#define PCS_LN_15_MAPr_CLR BCMI_MADURA_PCS_LN_15_MAPr_CLR
#define PCS_LN_15_MAPr_SET BCMI_MADURA_PCS_LN_15_MAPr_SET
#define PCS_LN_15_MAPr_GET BCMI_MADURA_PCS_LN_15_MAPr_GET
#define PCS_LN_15_MAPr_PCS_LN_15_MAPPINGf_GET BCMI_MADURA_PCS_LN_15_MAPr_PCS_LN_15_MAPPINGf_GET
#define PCS_LN_15_MAPr_PCS_LN_15_MAPPINGf_SET BCMI_MADURA_PCS_LN_15_MAPr_PCS_LN_15_MAPPINGf_SET
#define READ_PCS_LN_15_MAPr BCMI_MADURA_READ_PCS_LN_15_MAPr
#define WRITE_PCS_LN_15_MAPr BCMI_MADURA_WRITE_PCS_LN_15_MAPr
#define MODIFY_PCS_LN_15_MAPr BCMI_MADURA_MODIFY_PCS_LN_15_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_15_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_16_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x010a
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_16_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_16_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 16, the detected PCS lane number is recorded in this register. The contents of the lane 16 mapping register is valid when lane 16 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_16_MAPr (0x0001010a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_16_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_16_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_16_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_16_map[1];
	uint32_t _pcs_ln_16_map;
} BCMI_MADURA_PCS_LN_16_MAPr_t;

#define BCMI_MADURA_PCS_LN_16_MAPr_CLR(r) (r).pcs_ln_16_map[0] = 0
#define BCMI_MADURA_PCS_LN_16_MAPr_SET(r,d) (r).pcs_ln_16_map[0] = d
#define BCMI_MADURA_PCS_LN_16_MAPr_GET(r) (r).pcs_ln_16_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_16_MAPr_PCS_LN_16_MAPPINGf_GET(r) (((r).pcs_ln_16_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_16_MAPr_PCS_LN_16_MAPPINGf_SET(r,f) (r).pcs_ln_16_map[0]=(((r).pcs_ln_16_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_16_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_16_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_16_MAPr,_r._pcs_ln_16_map)
#define BCMI_MADURA_WRITE_PCS_LN_16_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_16_MAPr,_r._pcs_ln_16_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_16_MAPr BCMI_MADURA_PCS_LN_16_MAPr
#define PCS_LN_16_MAPr_SIZE BCMI_MADURA_PCS_LN_16_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_16_MAPr_t PCS_LN_16_MAPr_t;
#define PCS_LN_16_MAPr_CLR BCMI_MADURA_PCS_LN_16_MAPr_CLR
#define PCS_LN_16_MAPr_SET BCMI_MADURA_PCS_LN_16_MAPr_SET
#define PCS_LN_16_MAPr_GET BCMI_MADURA_PCS_LN_16_MAPr_GET
#define PCS_LN_16_MAPr_PCS_LN_16_MAPPINGf_GET BCMI_MADURA_PCS_LN_16_MAPr_PCS_LN_16_MAPPINGf_GET
#define PCS_LN_16_MAPr_PCS_LN_16_MAPPINGf_SET BCMI_MADURA_PCS_LN_16_MAPr_PCS_LN_16_MAPPINGf_SET
#define READ_PCS_LN_16_MAPr BCMI_MADURA_READ_PCS_LN_16_MAPr
#define WRITE_PCS_LN_16_MAPr BCMI_MADURA_WRITE_PCS_LN_16_MAPr
#define MODIFY_PCS_LN_16_MAPr BCMI_MADURA_MODIFY_PCS_LN_16_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_16_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_17_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x010b
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_17_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_17_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 17, the detected PCS lane number is recorded in this register. The contents of the lane 17 mapping register is valid when lane 17 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_17_MAPr (0x0001010b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_17_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_17_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_17_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_17_map[1];
	uint32_t _pcs_ln_17_map;
} BCMI_MADURA_PCS_LN_17_MAPr_t;

#define BCMI_MADURA_PCS_LN_17_MAPr_CLR(r) (r).pcs_ln_17_map[0] = 0
#define BCMI_MADURA_PCS_LN_17_MAPr_SET(r,d) (r).pcs_ln_17_map[0] = d
#define BCMI_MADURA_PCS_LN_17_MAPr_GET(r) (r).pcs_ln_17_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_17_MAPr_PCS_LN_17_MAPPINGf_GET(r) (((r).pcs_ln_17_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_17_MAPr_PCS_LN_17_MAPPINGf_SET(r,f) (r).pcs_ln_17_map[0]=(((r).pcs_ln_17_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_17_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_17_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_17_MAPr,_r._pcs_ln_17_map)
#define BCMI_MADURA_WRITE_PCS_LN_17_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_17_MAPr,_r._pcs_ln_17_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_17_MAPr BCMI_MADURA_PCS_LN_17_MAPr
#define PCS_LN_17_MAPr_SIZE BCMI_MADURA_PCS_LN_17_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_17_MAPr_t PCS_LN_17_MAPr_t;
#define PCS_LN_17_MAPr_CLR BCMI_MADURA_PCS_LN_17_MAPr_CLR
#define PCS_LN_17_MAPr_SET BCMI_MADURA_PCS_LN_17_MAPr_SET
#define PCS_LN_17_MAPr_GET BCMI_MADURA_PCS_LN_17_MAPr_GET
#define PCS_LN_17_MAPr_PCS_LN_17_MAPPINGf_GET BCMI_MADURA_PCS_LN_17_MAPr_PCS_LN_17_MAPPINGf_GET
#define PCS_LN_17_MAPr_PCS_LN_17_MAPPINGf_SET BCMI_MADURA_PCS_LN_17_MAPr_PCS_LN_17_MAPPINGf_SET
#define READ_PCS_LN_17_MAPr BCMI_MADURA_READ_PCS_LN_17_MAPr
#define WRITE_PCS_LN_17_MAPr BCMI_MADURA_WRITE_PCS_LN_17_MAPr
#define MODIFY_PCS_LN_17_MAPr BCMI_MADURA_MODIFY_PCS_LN_17_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_17_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_18_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x010c
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_18_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_18_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 18, the detected PCS lane number is recorded in this register. The contents of the lane 18 mapping register is valid when lane 18 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_18_MAPr (0x0001010c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_18_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_18_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_18_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_18_map[1];
	uint32_t _pcs_ln_18_map;
} BCMI_MADURA_PCS_LN_18_MAPr_t;

#define BCMI_MADURA_PCS_LN_18_MAPr_CLR(r) (r).pcs_ln_18_map[0] = 0
#define BCMI_MADURA_PCS_LN_18_MAPr_SET(r,d) (r).pcs_ln_18_map[0] = d
#define BCMI_MADURA_PCS_LN_18_MAPr_GET(r) (r).pcs_ln_18_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_18_MAPr_PCS_LN_18_MAPPINGf_GET(r) (((r).pcs_ln_18_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_18_MAPr_PCS_LN_18_MAPPINGf_SET(r,f) (r).pcs_ln_18_map[0]=(((r).pcs_ln_18_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_18_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_18_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_18_MAPr,_r._pcs_ln_18_map)
#define BCMI_MADURA_WRITE_PCS_LN_18_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_18_MAPr,_r._pcs_ln_18_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_18_MAPr BCMI_MADURA_PCS_LN_18_MAPr
#define PCS_LN_18_MAPr_SIZE BCMI_MADURA_PCS_LN_18_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_18_MAPr_t PCS_LN_18_MAPr_t;
#define PCS_LN_18_MAPr_CLR BCMI_MADURA_PCS_LN_18_MAPr_CLR
#define PCS_LN_18_MAPr_SET BCMI_MADURA_PCS_LN_18_MAPr_SET
#define PCS_LN_18_MAPr_GET BCMI_MADURA_PCS_LN_18_MAPr_GET
#define PCS_LN_18_MAPr_PCS_LN_18_MAPPINGf_GET BCMI_MADURA_PCS_LN_18_MAPr_PCS_LN_18_MAPPINGf_GET
#define PCS_LN_18_MAPr_PCS_LN_18_MAPPINGf_SET BCMI_MADURA_PCS_LN_18_MAPr_PCS_LN_18_MAPPINGf_SET
#define READ_PCS_LN_18_MAPr BCMI_MADURA_READ_PCS_LN_18_MAPr
#define WRITE_PCS_LN_18_MAPr BCMI_MADURA_WRITE_PCS_LN_18_MAPr
#define MODIFY_PCS_LN_18_MAPr BCMI_MADURA_MODIFY_PCS_LN_18_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_18_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_LN_19_MAP
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x010d
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_LN_19_MAPPING
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LN_19_MAPPING When the RS-FEC instance of the multi-lane PCS(CL-82) detects and locks the alignment marker for service interface lane 19, the detected PCS lane number is recorded in this register. The contents of the lane 19 mapping register is valid when lane 19 aligned bit is set to one and is invalid otherwise.
 */
#define BCMI_MADURA_PCS_LN_19_MAPr (0x0001010d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_LN_19_MAPr_SIZE 4

/*
 * This structure should be used to declare and program PCS_LN_19_MAP.
 */
typedef union BCMI_MADURA_PCS_LN_19_MAPr_s {
	uint32_t v[1];
	uint32_t pcs_ln_19_map[1];
	uint32_t _pcs_ln_19_map;
} BCMI_MADURA_PCS_LN_19_MAPr_t;

#define BCMI_MADURA_PCS_LN_19_MAPr_CLR(r) (r).pcs_ln_19_map[0] = 0
#define BCMI_MADURA_PCS_LN_19_MAPr_SET(r,d) (r).pcs_ln_19_map[0] = d
#define BCMI_MADURA_PCS_LN_19_MAPr_GET(r) (r).pcs_ln_19_map[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_LN_19_MAPr_PCS_LN_19_MAPPINGf_GET(r) (((r).pcs_ln_19_map[0]) & 0x1f)
#define BCMI_MADURA_PCS_LN_19_MAPr_PCS_LN_19_MAPPINGf_SET(r,f) (r).pcs_ln_19_map[0]=(((r).pcs_ln_19_map[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PCS_LN_19_MAP.
 */
#define BCMI_MADURA_READ_PCS_LN_19_MAPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_LN_19_MAPr,_r._pcs_ln_19_map)
#define BCMI_MADURA_WRITE_PCS_LN_19_MAPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_LN_19_MAPr,_r._pcs_ln_19_map)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_LN_19_MAPr BCMI_MADURA_PCS_LN_19_MAPr
#define PCS_LN_19_MAPr_SIZE BCMI_MADURA_PCS_LN_19_MAPr_SIZE
typedef BCMI_MADURA_PCS_LN_19_MAPr_t PCS_LN_19_MAPr_t;
#define PCS_LN_19_MAPr_CLR BCMI_MADURA_PCS_LN_19_MAPr_CLR
#define PCS_LN_19_MAPr_SET BCMI_MADURA_PCS_LN_19_MAPr_SET
#define PCS_LN_19_MAPr_GET BCMI_MADURA_PCS_LN_19_MAPr_GET
#define PCS_LN_19_MAPr_PCS_LN_19_MAPPINGf_GET BCMI_MADURA_PCS_LN_19_MAPr_PCS_LN_19_MAPPINGf_GET
#define PCS_LN_19_MAPr_PCS_LN_19_MAPPINGf_SET BCMI_MADURA_PCS_LN_19_MAPr_PCS_LN_19_MAPPINGf_SET
#define READ_PCS_LN_19_MAPr BCMI_MADURA_READ_PCS_LN_19_MAPr
#define WRITE_PCS_LN_19_MAPr BCMI_MADURA_WRITE_PCS_LN_19_MAPr
#define MODIFY_PCS_LN_19_MAPr BCMI_MADURA_MODIFY_PCS_LN_19_MAPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_LN_19_MAPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_ALIGN_STS1
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0118
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_ALIGN_STATUS1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_BLK_LOCK_STATUS_7_0 Bits 7:0 correspond to PCS lanes 7:0When read as a one, the bit indicates that the RS-FEC transmit function has achieved block lock for that lane.When read as a zero, the bit indicates that the RS-FEC transmit function has not achieved block lock for that lane
 */
#define BCMI_MADURA_PCS_ALIGN_STS1r (0x00010118 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_ALIGN_STS1r_SIZE 4

/*
 * This structure should be used to declare and program PCS_ALIGN_STS1.
 */
typedef union BCMI_MADURA_PCS_ALIGN_STS1r_s {
	uint32_t v[1];
	uint32_t pcs_align_sts1[1];
	uint32_t _pcs_align_sts1;
} BCMI_MADURA_PCS_ALIGN_STS1r_t;

#define BCMI_MADURA_PCS_ALIGN_STS1r_CLR(r) (r).pcs_align_sts1[0] = 0
#define BCMI_MADURA_PCS_ALIGN_STS1r_SET(r,d) (r).pcs_align_sts1[0] = d
#define BCMI_MADURA_PCS_ALIGN_STS1r_GET(r) (r).pcs_align_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_ALIGN_STS1r_PCS_BLK_LOCK_STATUS_7_0f_GET(r) (((r).pcs_align_sts1[0]) & 0xff)
#define BCMI_MADURA_PCS_ALIGN_STS1r_PCS_BLK_LOCK_STATUS_7_0f_SET(r,f) (r).pcs_align_sts1[0]=(((r).pcs_align_sts1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PCS_ALIGN_STS1.
 */
#define BCMI_MADURA_READ_PCS_ALIGN_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_ALIGN_STS1r,_r._pcs_align_sts1)
#define BCMI_MADURA_WRITE_PCS_ALIGN_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_ALIGN_STS1r,_r._pcs_align_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_ALIGN_STS1r BCMI_MADURA_PCS_ALIGN_STS1r
#define PCS_ALIGN_STS1r_SIZE BCMI_MADURA_PCS_ALIGN_STS1r_SIZE
typedef BCMI_MADURA_PCS_ALIGN_STS1r_t PCS_ALIGN_STS1r_t;
#define PCS_ALIGN_STS1r_CLR BCMI_MADURA_PCS_ALIGN_STS1r_CLR
#define PCS_ALIGN_STS1r_SET BCMI_MADURA_PCS_ALIGN_STS1r_SET
#define PCS_ALIGN_STS1r_GET BCMI_MADURA_PCS_ALIGN_STS1r_GET
#define PCS_ALIGN_STS1r_PCS_BLK_LOCK_STATUS_7_0f_GET BCMI_MADURA_PCS_ALIGN_STS1r_PCS_BLK_LOCK_STATUS_7_0f_GET
#define PCS_ALIGN_STS1r_PCS_BLK_LOCK_STATUS_7_0f_SET BCMI_MADURA_PCS_ALIGN_STS1r_PCS_BLK_LOCK_STATUS_7_0f_SET
#define READ_PCS_ALIGN_STS1r BCMI_MADURA_READ_PCS_ALIGN_STS1r
#define WRITE_PCS_ALIGN_STS1r BCMI_MADURA_WRITE_PCS_ALIGN_STS1r
#define MODIFY_PCS_ALIGN_STS1r BCMI_MADURA_MODIFY_PCS_ALIGN_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_ALIGN_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_ALIGN_STS2
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x0119
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_ALIGN_STATUS2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_BLK_LOCK_STATUS_19_8 Bits 11:0 correspond to PCS lanes 19:8When read as a one, the bit indicates that the RS-FEC transmit function has achieved block lock for that lane.When read as a zero, the bit indicates that the RS-FEC transmit function has not achieved block lock for that lane
 */
#define BCMI_MADURA_PCS_ALIGN_STS2r (0x00010119 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_ALIGN_STS2r_SIZE 4

/*
 * This structure should be used to declare and program PCS_ALIGN_STS2.
 */
typedef union BCMI_MADURA_PCS_ALIGN_STS2r_s {
	uint32_t v[1];
	uint32_t pcs_align_sts2[1];
	uint32_t _pcs_align_sts2;
} BCMI_MADURA_PCS_ALIGN_STS2r_t;

#define BCMI_MADURA_PCS_ALIGN_STS2r_CLR(r) (r).pcs_align_sts2[0] = 0
#define BCMI_MADURA_PCS_ALIGN_STS2r_SET(r,d) (r).pcs_align_sts2[0] = d
#define BCMI_MADURA_PCS_ALIGN_STS2r_GET(r) (r).pcs_align_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_ALIGN_STS2r_PCS_BLK_LOCK_STATUS_19_8f_GET(r) (((r).pcs_align_sts2[0]) & 0xfff)
#define BCMI_MADURA_PCS_ALIGN_STS2r_PCS_BLK_LOCK_STATUS_19_8f_SET(r,f) (r).pcs_align_sts2[0]=(((r).pcs_align_sts2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access PCS_ALIGN_STS2.
 */
#define BCMI_MADURA_READ_PCS_ALIGN_STS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_ALIGN_STS2r,_r._pcs_align_sts2)
#define BCMI_MADURA_WRITE_PCS_ALIGN_STS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_ALIGN_STS2r,_r._pcs_align_sts2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_ALIGN_STS2r BCMI_MADURA_PCS_ALIGN_STS2r
#define PCS_ALIGN_STS2r_SIZE BCMI_MADURA_PCS_ALIGN_STS2r_SIZE
typedef BCMI_MADURA_PCS_ALIGN_STS2r_t PCS_ALIGN_STS2r_t;
#define PCS_ALIGN_STS2r_CLR BCMI_MADURA_PCS_ALIGN_STS2r_CLR
#define PCS_ALIGN_STS2r_SET BCMI_MADURA_PCS_ALIGN_STS2r_SET
#define PCS_ALIGN_STS2r_GET BCMI_MADURA_PCS_ALIGN_STS2r_GET
#define PCS_ALIGN_STS2r_PCS_BLK_LOCK_STATUS_19_8f_GET BCMI_MADURA_PCS_ALIGN_STS2r_PCS_BLK_LOCK_STATUS_19_8f_GET
#define PCS_ALIGN_STS2r_PCS_BLK_LOCK_STATUS_19_8f_SET BCMI_MADURA_PCS_ALIGN_STS2r_PCS_BLK_LOCK_STATUS_19_8f_SET
#define READ_PCS_ALIGN_STS2r BCMI_MADURA_READ_PCS_ALIGN_STS2r
#define WRITE_PCS_ALIGN_STS2r BCMI_MADURA_WRITE_PCS_ALIGN_STS2r
#define MODIFY_PCS_ALIGN_STS2r BCMI_MADURA_MODIFY_PCS_ALIGN_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_ALIGN_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_ALIGN_STS3
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x011a
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_ALIGN_STATUS3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_AM_LOCK_STATUS_7_0 Bits 7:0 correspond to PCS lanes 7:0When read as a one, the bit indicates that the RS-FEC transmit function has achieved alignment marker lock for that lane.When read as a zero, the bit indicates that the RS-FEC transmit function has not achieved alignment marker lock for that lane.
 */
#define BCMI_MADURA_PCS_ALIGN_STS3r (0x0001011a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_ALIGN_STS3r_SIZE 4

/*
 * This structure should be used to declare and program PCS_ALIGN_STS3.
 */
typedef union BCMI_MADURA_PCS_ALIGN_STS3r_s {
	uint32_t v[1];
	uint32_t pcs_align_sts3[1];
	uint32_t _pcs_align_sts3;
} BCMI_MADURA_PCS_ALIGN_STS3r_t;

#define BCMI_MADURA_PCS_ALIGN_STS3r_CLR(r) (r).pcs_align_sts3[0] = 0
#define BCMI_MADURA_PCS_ALIGN_STS3r_SET(r,d) (r).pcs_align_sts3[0] = d
#define BCMI_MADURA_PCS_ALIGN_STS3r_GET(r) (r).pcs_align_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_ALIGN_STS3r_PCS_AM_LOCK_STATUS_7_0f_GET(r) (((r).pcs_align_sts3[0]) & 0xff)
#define BCMI_MADURA_PCS_ALIGN_STS3r_PCS_AM_LOCK_STATUS_7_0f_SET(r,f) (r).pcs_align_sts3[0]=(((r).pcs_align_sts3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PCS_ALIGN_STS3.
 */
#define BCMI_MADURA_READ_PCS_ALIGN_STS3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_ALIGN_STS3r,_r._pcs_align_sts3)
#define BCMI_MADURA_WRITE_PCS_ALIGN_STS3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_ALIGN_STS3r,_r._pcs_align_sts3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_ALIGN_STS3r BCMI_MADURA_PCS_ALIGN_STS3r
#define PCS_ALIGN_STS3r_SIZE BCMI_MADURA_PCS_ALIGN_STS3r_SIZE
typedef BCMI_MADURA_PCS_ALIGN_STS3r_t PCS_ALIGN_STS3r_t;
#define PCS_ALIGN_STS3r_CLR BCMI_MADURA_PCS_ALIGN_STS3r_CLR
#define PCS_ALIGN_STS3r_SET BCMI_MADURA_PCS_ALIGN_STS3r_SET
#define PCS_ALIGN_STS3r_GET BCMI_MADURA_PCS_ALIGN_STS3r_GET
#define PCS_ALIGN_STS3r_PCS_AM_LOCK_STATUS_7_0f_GET BCMI_MADURA_PCS_ALIGN_STS3r_PCS_AM_LOCK_STATUS_7_0f_GET
#define PCS_ALIGN_STS3r_PCS_AM_LOCK_STATUS_7_0f_SET BCMI_MADURA_PCS_ALIGN_STS3r_PCS_AM_LOCK_STATUS_7_0f_SET
#define READ_PCS_ALIGN_STS3r BCMI_MADURA_READ_PCS_ALIGN_STS3r
#define WRITE_PCS_ALIGN_STS3r BCMI_MADURA_WRITE_PCS_ALIGN_STS3r
#define MODIFY_PCS_ALIGN_STS3r BCMI_MADURA_MODIFY_PCS_ALIGN_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_ALIGN_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_ALIGN_STS4
 * BLOCKS:   IEEE_CL91_TX
 * REGADDR:  0x011b
 * DEVAD:    1
 * DESC:     IEEE_CL91_TX_PCS_ALIGN_STATUS4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_AM_LOCK_STATUS_19_8 Bits 11:0 correspond to PCS lanes 19:8When read as a one, the bit indicates that the RS-FEC transmit function has achieved alignment marker lock for that lane.When read as a zero, the bit indicates that the RS-FEC transmit function has not achieved alignment marker lock for that lane.
 */
#define BCMI_MADURA_PCS_ALIGN_STS4r (0x0001011b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_ALIGN_STS4r_SIZE 4

/*
 * This structure should be used to declare and program PCS_ALIGN_STS4.
 */
typedef union BCMI_MADURA_PCS_ALIGN_STS4r_s {
	uint32_t v[1];
	uint32_t pcs_align_sts4[1];
	uint32_t _pcs_align_sts4;
} BCMI_MADURA_PCS_ALIGN_STS4r_t;

#define BCMI_MADURA_PCS_ALIGN_STS4r_CLR(r) (r).pcs_align_sts4[0] = 0
#define BCMI_MADURA_PCS_ALIGN_STS4r_SET(r,d) (r).pcs_align_sts4[0] = d
#define BCMI_MADURA_PCS_ALIGN_STS4r_GET(r) (r).pcs_align_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_ALIGN_STS4r_PCS_AM_LOCK_STATUS_19_8f_GET(r) (((r).pcs_align_sts4[0]) & 0xfff)
#define BCMI_MADURA_PCS_ALIGN_STS4r_PCS_AM_LOCK_STATUS_19_8f_SET(r,f) (r).pcs_align_sts4[0]=(((r).pcs_align_sts4[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access PCS_ALIGN_STS4.
 */
#define BCMI_MADURA_READ_PCS_ALIGN_STS4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_ALIGN_STS4r,_r._pcs_align_sts4)
#define BCMI_MADURA_WRITE_PCS_ALIGN_STS4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_ALIGN_STS4r,_r._pcs_align_sts4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_ALIGN_STS4r BCMI_MADURA_PCS_ALIGN_STS4r
#define PCS_ALIGN_STS4r_SIZE BCMI_MADURA_PCS_ALIGN_STS4r_SIZE
typedef BCMI_MADURA_PCS_ALIGN_STS4r_t PCS_ALIGN_STS4r_t;
#define PCS_ALIGN_STS4r_CLR BCMI_MADURA_PCS_ALIGN_STS4r_CLR
#define PCS_ALIGN_STS4r_SET BCMI_MADURA_PCS_ALIGN_STS4r_SET
#define PCS_ALIGN_STS4r_GET BCMI_MADURA_PCS_ALIGN_STS4r_GET
#define PCS_ALIGN_STS4r_PCS_AM_LOCK_STATUS_19_8f_GET BCMI_MADURA_PCS_ALIGN_STS4r_PCS_AM_LOCK_STATUS_19_8f_GET
#define PCS_ALIGN_STS4r_PCS_AM_LOCK_STATUS_19_8f_SET BCMI_MADURA_PCS_ALIGN_STS4r_PCS_AM_LOCK_STATUS_19_8f_SET
#define READ_PCS_ALIGN_STS4r BCMI_MADURA_READ_PCS_ALIGN_STS4r
#define WRITE_PCS_ALIGN_STS4r BCMI_MADURA_WRITE_PCS_ALIGN_STS4r
#define MODIFY_PCS_ALIGN_STS4r BCMI_MADURA_MODIFY_PCS_ALIGN_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_ALIGN_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLICE
 * BLOCKS:   DEV1_SLICE
 * REGADDR:  0x8000
 * DEVAD:    1
 * DESC:     SLICE_REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_SEL         Set unicast/multicast/broadcast by setting 1 for the corresponding lane(s)4'b0001 - Unicast lane 04'b0010 - Unicast lane 14'b0100 - Unicast lane 24'b1000 - Unicast lane 34'b0011 - Multicast lanes 0,14'b1100 - Multicast lanes 2,34'b1111 - Broadcast lanes 0,1,2,3
 *     PORT_SEL         Madura Port Select3'b000 - Port 03'b001 - Port 13'b010 - Port 23'b011 - Port 33'b100 - Port 43'b101 - Port 53'b110 - Port 63'b111 - Port 7NOTE1: For a port-based access, bits 11:8 and 3:0 of slice register should be set to zeroes. Please see NOTE2 for an exception to this ruleNOTE2: For an AN port-based access, bits 11:10 will have to be setto choose line/system side AN
 *     REG_TYPE_SEL     Register Type Select1'b0 - IEEE PMD (port based) OR Falcon/Falcon-IF/DP (lane based)1'b1 - AN (IEEE/Non-IEEE) (port based)
 *     SLICE_0_SEL      Slice 0 / Lower Slice Select1'b0 - Slice 0 / Lower 100g Slice (related to lanes 0-3) not selected1'b1 - Slice 0 /Lower 100g Slice (related to lanes 0-3) selected
 *     SLICE_1_SEL      Slice 1 / Upper Slice Select1'b0 - Slice 1 / Upper 100g Slice (related to lanes 4-7) not selected1'b1 - Slice 1 / Upper 100g Slice (related to lanes 4-7) selected
 *     SYS_SEL          System Side Side Select1'b0 - System Side not selected1'b1 - System Side selected
 *     LIN_SEL          Line Side Select1'b0 - Line Side not selected1'b1 - Line Side selected
 *     PLL_SEL          Core/PLL number.This is used to address the PLL and core registers associated with the PLLif there are multiple PLLs in this core. Registers that are not replicatedper core/PLL will not use these bits in their decode. Pll/falcon core select
 */
#define BCMI_MADURA_SLICEr (0x00018000 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLICEr_SIZE 4

/*
 * This structure should be used to declare and program SLICE.
 */
typedef union BCMI_MADURA_SLICEr_s {
	uint32_t v[1];
	uint32_t slice[1];
	uint32_t _slice;
} BCMI_MADURA_SLICEr_t;

#define BCMI_MADURA_SLICEr_CLR(r) (r).slice[0] = 0
#define BCMI_MADURA_SLICEr_SET(r,d) (r).slice[0] = d
#define BCMI_MADURA_SLICEr_GET(r) (r).slice[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLICEr_PLL_SELf_GET(r) ((((r).slice[0]) >> 12) & 0x1)
#define BCMI_MADURA_SLICEr_PLL_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_SLICEr_LIN_SELf_GET(r) ((((r).slice[0]) >> 11) & 0x1)
#define BCMI_MADURA_SLICEr_LIN_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_SLICEr_SYS_SELf_GET(r) ((((r).slice[0]) >> 10) & 0x1)
#define BCMI_MADURA_SLICEr_SYS_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_SLICEr_SLICE_1_SELf_GET(r) ((((r).slice[0]) >> 9) & 0x1)
#define BCMI_MADURA_SLICEr_SLICE_1_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_SLICEr_SLICE_0_SELf_GET(r) ((((r).slice[0]) >> 8) & 0x1)
#define BCMI_MADURA_SLICEr_SLICE_0_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_SLICEr_REG_TYPE_SELf_GET(r) ((((r).slice[0]) >> 7) & 0x1)
#define BCMI_MADURA_SLICEr_REG_TYPE_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_SLICEr_PORT_SELf_GET(r) ((((r).slice[0]) >> 4) & 0x7)
#define BCMI_MADURA_SLICEr_PORT_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_SLICEr_LANE_SELf_GET(r) (((r).slice[0]) & 0xf)
#define BCMI_MADURA_SLICEr_LANE_SELf_SET(r,f) (r).slice[0]=(((r).slice[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SLICE.
 */
#define BCMI_MADURA_READ_SLICEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLICEr,_r._slice)
#define BCMI_MADURA_WRITE_SLICEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLICEr,_r._slice)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLICEr BCMI_MADURA_SLICEr
#define SLICEr_SIZE BCMI_MADURA_SLICEr_SIZE
typedef BCMI_MADURA_SLICEr_t SLICEr_t;
#define SLICEr_CLR BCMI_MADURA_SLICEr_CLR
#define SLICEr_SET BCMI_MADURA_SLICEr_SET
#define SLICEr_GET BCMI_MADURA_SLICEr_GET
#define SLICEr_PLL_SELf_GET BCMI_MADURA_SLICEr_PLL_SELf_GET
#define SLICEr_PLL_SELf_SET BCMI_MADURA_SLICEr_PLL_SELf_SET
#define SLICEr_LIN_SELf_GET BCMI_MADURA_SLICEr_LIN_SELf_GET
#define SLICEr_LIN_SELf_SET BCMI_MADURA_SLICEr_LIN_SELf_SET
#define SLICEr_SYS_SELf_GET BCMI_MADURA_SLICEr_SYS_SELf_GET
#define SLICEr_SYS_SELf_SET BCMI_MADURA_SLICEr_SYS_SELf_SET
#define SLICEr_SLICE_1_SELf_GET BCMI_MADURA_SLICEr_SLICE_1_SELf_GET
#define SLICEr_SLICE_1_SELf_SET BCMI_MADURA_SLICEr_SLICE_1_SELf_SET
#define SLICEr_SLICE_0_SELf_GET BCMI_MADURA_SLICEr_SLICE_0_SELf_GET
#define SLICEr_SLICE_0_SELf_SET BCMI_MADURA_SLICEr_SLICE_0_SELf_SET
#define SLICEr_REG_TYPE_SELf_GET BCMI_MADURA_SLICEr_REG_TYPE_SELf_GET
#define SLICEr_REG_TYPE_SELf_SET BCMI_MADURA_SLICEr_REG_TYPE_SELf_SET
#define SLICEr_PORT_SELf_GET BCMI_MADURA_SLICEr_PORT_SELf_GET
#define SLICEr_PORT_SELf_SET BCMI_MADURA_SLICEr_PORT_SELf_SET
#define SLICEr_LANE_SELf_GET BCMI_MADURA_SLICEr_LANE_SELf_GET
#define SLICEr_LANE_SELf_SET BCMI_MADURA_SLICEr_LANE_SELf_SET
#define READ_SLICEr BCMI_MADURA_READ_SLICEr
#define WRITE_SLICEr BCMI_MADURA_WRITE_SLICEr
#define MODIFY_SLICEr BCMI_MADURA_MODIFY_SLICEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLICEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_CTL
 * BLOCKS:   UC_PMI_ARB_MASK
 * REGADDR:  0x8010
 * DEVAD:    1
 * DESC:     PMI write mask for micro intiated arbiter access
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DATA             Write mask to be used for PMI-Arbiter interface when micro accesses Falcon registers through arbiter.Note: Partial masks to grey-coded AFE registers is illegal
 */
#define BCMI_MADURA_UC_CTLr (0x00018010 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program UC_CTL.
 */
typedef union BCMI_MADURA_UC_CTLr_s {
	uint32_t v[1];
	uint32_t uc_ctl[1];
	uint32_t _uc_ctl;
} BCMI_MADURA_UC_CTLr_t;

#define BCMI_MADURA_UC_CTLr_CLR(r) (r).uc_ctl[0] = 0
#define BCMI_MADURA_UC_CTLr_SET(r,d) (r).uc_ctl[0] = d
#define BCMI_MADURA_UC_CTLr_GET(r) (r).uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_CTLr_DATAf_GET(r) (((r).uc_ctl[0]) & 0xffff)
#define BCMI_MADURA_UC_CTLr_DATAf_SET(r,f) (r).uc_ctl[0]=(((r).uc_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_CTL.
 */
#define BCMI_MADURA_READ_UC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_CTLr,_r._uc_ctl)
#define BCMI_MADURA_WRITE_UC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_CTLr,_r._uc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CTLr BCMI_MADURA_UC_CTLr
#define UC_CTLr_SIZE BCMI_MADURA_UC_CTLr_SIZE
typedef BCMI_MADURA_UC_CTLr_t UC_CTLr_t;
#define UC_CTLr_CLR BCMI_MADURA_UC_CTLr_CLR
#define UC_CTLr_SET BCMI_MADURA_UC_CTLr_SET
#define UC_CTLr_GET BCMI_MADURA_UC_CTLr_GET
#define UC_CTLr_DATAf_GET BCMI_MADURA_UC_CTLr_DATAf_GET
#define UC_CTLr_DATAf_SET BCMI_MADURA_UC_CTLr_DATAf_SET
#define READ_UC_CTLr BCMI_MADURA_READ_UC_CTLr
#define WRITE_UC_CTLr BCMI_MADURA_WRITE_UC_CTLr
#define MODIFY_UC_CTLr BCMI_MADURA_MODIFY_UC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDICS_PMI_ARB_MASK_CTL
 * BLOCKS:   MDICS_PMI_ARB_MASK
 * REGADDR:  0x8020
 * DEVAD:    1
 * DESC:     PMI write mask for MDIO/I2C transactions initated through arbiter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DATA             Write mask to be used for PMI-Arbiter interfacewhen MDIO/I2C accesses Falcon registers through arbiter.There is only ONE register for MDIO/I2C. In Madura, only one of the above interfaceswill be present at a time, which is selected externally through the mdio_sel pin.This register will get self cleared on a subsequent write from MDIO/I2C to any Sys/Line Falcon registers.Masked writes to Falcon are supported for Broadcast/Multicast writes in Madura, with the exception to *AFE* registers.Masked writes to *AFE* registers must have mask for the entire field, bit wise masked write is not allowed.
 */
#define BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr (0x00018020 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MDICS_PMI_ARB_MASK_CTL.
 */
typedef union BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t mdics_pmi_arb_mask_ctl[1];
	uint32_t _mdics_pmi_arb_mask_ctl;
} BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_t;

#define BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_CLR(r) (r).mdics_pmi_arb_mask_ctl[0] = 0
#define BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_SET(r,d) (r).mdics_pmi_arb_mask_ctl[0] = d
#define BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_GET(r) (r).mdics_pmi_arb_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_DATAf_GET(r) (((r).mdics_pmi_arb_mask_ctl[0]) & 0xffff)
#define BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_DATAf_SET(r,f) (r).mdics_pmi_arb_mask_ctl[0]=(((r).mdics_pmi_arb_mask_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MDICS_PMI_ARB_MASK_CTL.
 */
#define BCMI_MADURA_READ_MDICS_PMI_ARB_MASK_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr,_r._mdics_pmi_arb_mask_ctl)
#define BCMI_MADURA_WRITE_MDICS_PMI_ARB_MASK_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr,_r._mdics_pmi_arb_mask_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDICS_PMI_ARB_MASK_CTLr BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr
#define MDICS_PMI_ARB_MASK_CTLr_SIZE BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_SIZE
typedef BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_t MDICS_PMI_ARB_MASK_CTLr_t;
#define MDICS_PMI_ARB_MASK_CTLr_CLR BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_CLR
#define MDICS_PMI_ARB_MASK_CTLr_SET BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_SET
#define MDICS_PMI_ARB_MASK_CTLr_GET BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_GET
#define MDICS_PMI_ARB_MASK_CTLr_DATAf_GET BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_DATAf_GET
#define MDICS_PMI_ARB_MASK_CTLr_DATAf_SET BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr_DATAf_SET
#define READ_MDICS_PMI_ARB_MASK_CTLr BCMI_MADURA_READ_MDICS_PMI_ARB_MASK_CTLr
#define WRITE_MDICS_PMI_ARB_MASK_CTLr BCMI_MADURA_WRITE_MDICS_PMI_ARB_MASK_CTLr
#define MODIFY_MDICS_PMI_ARB_MASK_CTLr BCMI_MADURA_MODIFY_MDICS_PMI_ARB_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDICS_PMI_ARB_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OTP_CON_CTL
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8100
 * DEVAD:    1
 * DESC:     one time programmable controller register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_OTP_SFT_RESET  The one time programmable memory controller soft reset
 */
#define BCMI_MADURA_OTP_CON_CTLr (0x00018100 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OTP_CON_CTLr_SIZE 4

/*
 * This structure should be used to declare and program OTP_CON_CTL.
 */
typedef union BCMI_MADURA_OTP_CON_CTLr_s {
	uint32_t v[1];
	uint32_t otp_con_ctl[1];
	uint32_t _otp_con_ctl;
} BCMI_MADURA_OTP_CON_CTLr_t;

#define BCMI_MADURA_OTP_CON_CTLr_CLR(r) (r).otp_con_ctl[0] = 0
#define BCMI_MADURA_OTP_CON_CTLr_SET(r,d) (r).otp_con_ctl[0] = d
#define BCMI_MADURA_OTP_CON_CTLr_GET(r) (r).otp_con_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OTP_CON_CTLr_I_OTP_SFT_RESETf_GET(r) (((r).otp_con_ctl[0]) & 0x1)
#define BCMI_MADURA_OTP_CON_CTLr_I_OTP_SFT_RESETf_SET(r,f) (r).otp_con_ctl[0]=(((r).otp_con_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access OTP_CON_CTL.
 */
#define BCMI_MADURA_READ_OTP_CON_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OTP_CON_CTLr,_r._otp_con_ctl)
#define BCMI_MADURA_WRITE_OTP_CON_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OTP_CON_CTLr,_r._otp_con_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OTP_CON_CTLr BCMI_MADURA_OTP_CON_CTLr
#define OTP_CON_CTLr_SIZE BCMI_MADURA_OTP_CON_CTLr_SIZE
typedef BCMI_MADURA_OTP_CON_CTLr_t OTP_CON_CTLr_t;
#define OTP_CON_CTLr_CLR BCMI_MADURA_OTP_CON_CTLr_CLR
#define OTP_CON_CTLr_SET BCMI_MADURA_OTP_CON_CTLr_SET
#define OTP_CON_CTLr_GET BCMI_MADURA_OTP_CON_CTLr_GET
#define OTP_CON_CTLr_I_OTP_SFT_RESETf_GET BCMI_MADURA_OTP_CON_CTLr_I_OTP_SFT_RESETf_GET
#define OTP_CON_CTLr_I_OTP_SFT_RESETf_SET BCMI_MADURA_OTP_CON_CTLr_I_OTP_SFT_RESETf_SET
#define READ_OTP_CON_CTLr BCMI_MADURA_READ_OTP_CON_CTLr
#define WRITE_OTP_CON_CTLr BCMI_MADURA_WRITE_OTP_CON_CTLr
#define MODIFY_OTP_CON_CTLr BCMI_MADURA_MODIFY_OTP_CON_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OTP_CON_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OTP_CON_STS
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8101
 * DEVAD:    1
 * DESC:     one time programmable memory status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OTP_FOUT_DONE    The fout bits of the one time programmable memory are available for reading
 */
#define BCMI_MADURA_OTP_CON_STSr (0x00018101 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OTP_CON_STSr_SIZE 4

/*
 * This structure should be used to declare and program OTP_CON_STS.
 */
typedef union BCMI_MADURA_OTP_CON_STSr_s {
	uint32_t v[1];
	uint32_t otp_con_sts[1];
	uint32_t _otp_con_sts;
} BCMI_MADURA_OTP_CON_STSr_t;

#define BCMI_MADURA_OTP_CON_STSr_CLR(r) (r).otp_con_sts[0] = 0
#define BCMI_MADURA_OTP_CON_STSr_SET(r,d) (r).otp_con_sts[0] = d
#define BCMI_MADURA_OTP_CON_STSr_GET(r) (r).otp_con_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OTP_CON_STSr_OTP_FOUT_DONEf_GET(r) (((r).otp_con_sts[0]) & 0x1)
#define BCMI_MADURA_OTP_CON_STSr_OTP_FOUT_DONEf_SET(r,f) (r).otp_con_sts[0]=(((r).otp_con_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access OTP_CON_STS.
 */
#define BCMI_MADURA_READ_OTP_CON_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OTP_CON_STSr,_r._otp_con_sts)
#define BCMI_MADURA_WRITE_OTP_CON_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OTP_CON_STSr,_r._otp_con_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OTP_CON_STSr BCMI_MADURA_OTP_CON_STSr
#define OTP_CON_STSr_SIZE BCMI_MADURA_OTP_CON_STSr_SIZE
typedef BCMI_MADURA_OTP_CON_STSr_t OTP_CON_STSr_t;
#define OTP_CON_STSr_CLR BCMI_MADURA_OTP_CON_STSr_CLR
#define OTP_CON_STSr_SET BCMI_MADURA_OTP_CON_STSr_SET
#define OTP_CON_STSr_GET BCMI_MADURA_OTP_CON_STSr_GET
#define OTP_CON_STSr_OTP_FOUT_DONEf_GET BCMI_MADURA_OTP_CON_STSr_OTP_FOUT_DONEf_GET
#define OTP_CON_STSr_OTP_FOUT_DONEf_SET BCMI_MADURA_OTP_CON_STSr_OTP_FOUT_DONEf_SET
#define READ_OTP_CON_STSr BCMI_MADURA_READ_OTP_CON_STSr
#define WRITE_OTP_CON_STSr BCMI_MADURA_WRITE_OTP_CON_STSr
#define MODIFY_OTP_CON_STSr BCMI_MADURA_MODIFY_OTP_CON_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OTP_CON_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OTP_FOUT0
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8102
 * DEVAD:    1
 * DESC:     the fout bits from OTP memory, debug related
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FOUT_15_0        The data bits stored in the OTP
 */
#define BCMI_MADURA_OTP_FOUT0r (0x00018102 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OTP_FOUT0r_SIZE 4

/*
 * This structure should be used to declare and program OTP_FOUT0.
 */
typedef union BCMI_MADURA_OTP_FOUT0r_s {
	uint32_t v[1];
	uint32_t otp_fout0[1];
	uint32_t _otp_fout0;
} BCMI_MADURA_OTP_FOUT0r_t;

#define BCMI_MADURA_OTP_FOUT0r_CLR(r) (r).otp_fout0[0] = 0
#define BCMI_MADURA_OTP_FOUT0r_SET(r,d) (r).otp_fout0[0] = d
#define BCMI_MADURA_OTP_FOUT0r_GET(r) (r).otp_fout0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OTP_FOUT0r_FOUT_15_0f_GET(r) (((r).otp_fout0[0]) & 0xffff)
#define BCMI_MADURA_OTP_FOUT0r_FOUT_15_0f_SET(r,f) (r).otp_fout0[0]=(((r).otp_fout0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access OTP_FOUT0.
 */
#define BCMI_MADURA_READ_OTP_FOUT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OTP_FOUT0r,_r._otp_fout0)
#define BCMI_MADURA_WRITE_OTP_FOUT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OTP_FOUT0r,_r._otp_fout0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OTP_FOUT0r BCMI_MADURA_OTP_FOUT0r
#define OTP_FOUT0r_SIZE BCMI_MADURA_OTP_FOUT0r_SIZE
typedef BCMI_MADURA_OTP_FOUT0r_t OTP_FOUT0r_t;
#define OTP_FOUT0r_CLR BCMI_MADURA_OTP_FOUT0r_CLR
#define OTP_FOUT0r_SET BCMI_MADURA_OTP_FOUT0r_SET
#define OTP_FOUT0r_GET BCMI_MADURA_OTP_FOUT0r_GET
#define OTP_FOUT0r_FOUT_15_0f_GET BCMI_MADURA_OTP_FOUT0r_FOUT_15_0f_GET
#define OTP_FOUT0r_FOUT_15_0f_SET BCMI_MADURA_OTP_FOUT0r_FOUT_15_0f_SET
#define READ_OTP_FOUT0r BCMI_MADURA_READ_OTP_FOUT0r
#define WRITE_OTP_FOUT0r BCMI_MADURA_WRITE_OTP_FOUT0r
#define MODIFY_OTP_FOUT0r BCMI_MADURA_MODIFY_OTP_FOUT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OTP_FOUT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OTP_FOUT1
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8103
 * DEVAD:    1
 * DESC:     the fout bits from OTP memory, debug related
 * RESETVAL: 0x400 (1024)
 * ACCESS:   R/W
 * FIELDS:
 *     FOUT_31_16       The data bits stored in the OTP
 */
#define BCMI_MADURA_OTP_FOUT1r (0x00018103 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OTP_FOUT1r_SIZE 4

/*
 * This structure should be used to declare and program OTP_FOUT1.
 */
typedef union BCMI_MADURA_OTP_FOUT1r_s {
	uint32_t v[1];
	uint32_t otp_fout1[1];
	uint32_t _otp_fout1;
} BCMI_MADURA_OTP_FOUT1r_t;

#define BCMI_MADURA_OTP_FOUT1r_CLR(r) (r).otp_fout1[0] = 0
#define BCMI_MADURA_OTP_FOUT1r_SET(r,d) (r).otp_fout1[0] = d
#define BCMI_MADURA_OTP_FOUT1r_GET(r) (r).otp_fout1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OTP_FOUT1r_FOUT_31_16f_GET(r) (((r).otp_fout1[0]) & 0xffff)
#define BCMI_MADURA_OTP_FOUT1r_FOUT_31_16f_SET(r,f) (r).otp_fout1[0]=(((r).otp_fout1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access OTP_FOUT1.
 */
#define BCMI_MADURA_READ_OTP_FOUT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OTP_FOUT1r,_r._otp_fout1)
#define BCMI_MADURA_WRITE_OTP_FOUT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OTP_FOUT1r,_r._otp_fout1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OTP_FOUT1r BCMI_MADURA_OTP_FOUT1r
#define OTP_FOUT1r_SIZE BCMI_MADURA_OTP_FOUT1r_SIZE
typedef BCMI_MADURA_OTP_FOUT1r_t OTP_FOUT1r_t;
#define OTP_FOUT1r_CLR BCMI_MADURA_OTP_FOUT1r_CLR
#define OTP_FOUT1r_SET BCMI_MADURA_OTP_FOUT1r_SET
#define OTP_FOUT1r_GET BCMI_MADURA_OTP_FOUT1r_GET
#define OTP_FOUT1r_FOUT_31_16f_GET BCMI_MADURA_OTP_FOUT1r_FOUT_31_16f_GET
#define OTP_FOUT1r_FOUT_31_16f_SET BCMI_MADURA_OTP_FOUT1r_FOUT_31_16f_SET
#define READ_OTP_FOUT1r BCMI_MADURA_READ_OTP_FOUT1r
#define WRITE_OTP_FOUT1r BCMI_MADURA_WRITE_OTP_FOUT1r
#define MODIFY_OTP_FOUT1r BCMI_MADURA_MODIFY_OTP_FOUT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OTP_FOUT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OTP_FOUT2
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8104
 * DEVAD:    1
 * DESC:     the fout bits from OTP memory, debug related
 * RESETVAL: 0x615c (24924)
 * ACCESS:   R/W
 * FIELDS:
 *     FOUT_47_32       The data bits stored in the OTP
 */
#define BCMI_MADURA_OTP_FOUT2r (0x00018104 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OTP_FOUT2r_SIZE 4

/*
 * This structure should be used to declare and program OTP_FOUT2.
 */
typedef union BCMI_MADURA_OTP_FOUT2r_s {
	uint32_t v[1];
	uint32_t otp_fout2[1];
	uint32_t _otp_fout2;
} BCMI_MADURA_OTP_FOUT2r_t;

#define BCMI_MADURA_OTP_FOUT2r_CLR(r) (r).otp_fout2[0] = 0
#define BCMI_MADURA_OTP_FOUT2r_SET(r,d) (r).otp_fout2[0] = d
#define BCMI_MADURA_OTP_FOUT2r_GET(r) (r).otp_fout2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OTP_FOUT2r_FOUT_47_32f_GET(r) (((r).otp_fout2[0]) & 0xffff)
#define BCMI_MADURA_OTP_FOUT2r_FOUT_47_32f_SET(r,f) (r).otp_fout2[0]=(((r).otp_fout2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access OTP_FOUT2.
 */
#define BCMI_MADURA_READ_OTP_FOUT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OTP_FOUT2r,_r._otp_fout2)
#define BCMI_MADURA_WRITE_OTP_FOUT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OTP_FOUT2r,_r._otp_fout2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OTP_FOUT2r BCMI_MADURA_OTP_FOUT2r
#define OTP_FOUT2r_SIZE BCMI_MADURA_OTP_FOUT2r_SIZE
typedef BCMI_MADURA_OTP_FOUT2r_t OTP_FOUT2r_t;
#define OTP_FOUT2r_CLR BCMI_MADURA_OTP_FOUT2r_CLR
#define OTP_FOUT2r_SET BCMI_MADURA_OTP_FOUT2r_SET
#define OTP_FOUT2r_GET BCMI_MADURA_OTP_FOUT2r_GET
#define OTP_FOUT2r_FOUT_47_32f_GET BCMI_MADURA_OTP_FOUT2r_FOUT_47_32f_GET
#define OTP_FOUT2r_FOUT_47_32f_SET BCMI_MADURA_OTP_FOUT2r_FOUT_47_32f_SET
#define READ_OTP_FOUT2r BCMI_MADURA_READ_OTP_FOUT2r
#define WRITE_OTP_FOUT2r BCMI_MADURA_WRITE_OTP_FOUT2r
#define MODIFY_OTP_FOUT2r BCMI_MADURA_MODIFY_OTP_FOUT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OTP_FOUT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OTP_FOUT3
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8105
 * DEVAD:    1
 * DESC:     the fout bits from OTP memory, debug related
 * RESETVAL: 0xa5 (165)
 * ACCESS:   R/W
 * FIELDS:
 *     FOUT_63_48       The data bits stored in the OTP
 */
#define BCMI_MADURA_OTP_FOUT3r (0x00018105 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OTP_FOUT3r_SIZE 4

/*
 * This structure should be used to declare and program OTP_FOUT3.
 */
typedef union BCMI_MADURA_OTP_FOUT3r_s {
	uint32_t v[1];
	uint32_t otp_fout3[1];
	uint32_t _otp_fout3;
} BCMI_MADURA_OTP_FOUT3r_t;

#define BCMI_MADURA_OTP_FOUT3r_CLR(r) (r).otp_fout3[0] = 0
#define BCMI_MADURA_OTP_FOUT3r_SET(r,d) (r).otp_fout3[0] = d
#define BCMI_MADURA_OTP_FOUT3r_GET(r) (r).otp_fout3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OTP_FOUT3r_FOUT_63_48f_GET(r) (((r).otp_fout3[0]) & 0xffff)
#define BCMI_MADURA_OTP_FOUT3r_FOUT_63_48f_SET(r,f) (r).otp_fout3[0]=(((r).otp_fout3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access OTP_FOUT3.
 */
#define BCMI_MADURA_READ_OTP_FOUT3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OTP_FOUT3r,_r._otp_fout3)
#define BCMI_MADURA_WRITE_OTP_FOUT3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OTP_FOUT3r,_r._otp_fout3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OTP_FOUT3r BCMI_MADURA_OTP_FOUT3r
#define OTP_FOUT3r_SIZE BCMI_MADURA_OTP_FOUT3r_SIZE
typedef BCMI_MADURA_OTP_FOUT3r_t OTP_FOUT3r_t;
#define OTP_FOUT3r_CLR BCMI_MADURA_OTP_FOUT3r_CLR
#define OTP_FOUT3r_SET BCMI_MADURA_OTP_FOUT3r_SET
#define OTP_FOUT3r_GET BCMI_MADURA_OTP_FOUT3r_GET
#define OTP_FOUT3r_FOUT_63_48f_GET BCMI_MADURA_OTP_FOUT3r_FOUT_63_48f_GET
#define OTP_FOUT3r_FOUT_63_48f_SET BCMI_MADURA_OTP_FOUT3r_FOUT_63_48f_SET
#define READ_OTP_FOUT3r BCMI_MADURA_READ_OTP_FOUT3r
#define WRITE_OTP_FOUT3r BCMI_MADURA_WRITE_OTP_FOUT3r
#define MODIFY_OTP_FOUT3r BCMI_MADURA_MODIFY_OTP_FOUT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OTP_FOUT3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PVTMON_CTL0
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8120
 * DEVAD:    1
 * DESC:     process voltage temperature sensor controls
 * RESETVAL: 0x14 (20)
 * ACCESS:   R/W
 * FIELDS:
 *     CTRL_I_PWRDN     Power down the PVTMON circuits
 *     CTRL_I_VDDCMON   Power down the VDDC monitor circuit
 *     CTRL_I_ADC_RESETB ADC reset active low
 *     CTRL_I_PVTMON_SEL PVT monitor selections
 */
#define BCMI_MADURA_PVTMON_CTL0r (0x00018120 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PVTMON_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program PVTMON_CTL0.
 */
typedef union BCMI_MADURA_PVTMON_CTL0r_s {
	uint32_t v[1];
	uint32_t pvtmon_ctl0[1];
	uint32_t _pvtmon_ctl0;
} BCMI_MADURA_PVTMON_CTL0r_t;

#define BCMI_MADURA_PVTMON_CTL0r_CLR(r) (r).pvtmon_ctl0[0] = 0
#define BCMI_MADURA_PVTMON_CTL0r_SET(r,d) (r).pvtmon_ctl0[0] = d
#define BCMI_MADURA_PVTMON_CTL0r_GET(r) (r).pvtmon_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PVTMON_SELf_GET(r) ((((r).pvtmon_ctl0[0]) >> 4) & 0x7)
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PVTMON_SELf_SET(r,f) (r).pvtmon_ctl0[0]=(((r).pvtmon_ctl0[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_ADC_RESETBf_GET(r) ((((r).pvtmon_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_ADC_RESETBf_SET(r,f) (r).pvtmon_ctl0[0]=(((r).pvtmon_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_VDDCMONf_GET(r) ((((r).pvtmon_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_VDDCMONf_SET(r,f) (r).pvtmon_ctl0[0]=(((r).pvtmon_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PWRDNf_GET(r) (((r).pvtmon_ctl0[0]) & 0x1)
#define BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PWRDNf_SET(r,f) (r).pvtmon_ctl0[0]=(((r).pvtmon_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PVTMON_CTL0.
 */
#define BCMI_MADURA_READ_PVTMON_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PVTMON_CTL0r,_r._pvtmon_ctl0)
#define BCMI_MADURA_WRITE_PVTMON_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PVTMON_CTL0r,_r._pvtmon_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PVTMON_CTL0r BCMI_MADURA_PVTMON_CTL0r
#define PVTMON_CTL0r_SIZE BCMI_MADURA_PVTMON_CTL0r_SIZE
typedef BCMI_MADURA_PVTMON_CTL0r_t PVTMON_CTL0r_t;
#define PVTMON_CTL0r_CLR BCMI_MADURA_PVTMON_CTL0r_CLR
#define PVTMON_CTL0r_SET BCMI_MADURA_PVTMON_CTL0r_SET
#define PVTMON_CTL0r_GET BCMI_MADURA_PVTMON_CTL0r_GET
#define PVTMON_CTL0r_CTRL_I_PVTMON_SELf_GET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PVTMON_SELf_GET
#define PVTMON_CTL0r_CTRL_I_PVTMON_SELf_SET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PVTMON_SELf_SET
#define PVTMON_CTL0r_CTRL_I_ADC_RESETBf_GET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_ADC_RESETBf_GET
#define PVTMON_CTL0r_CTRL_I_ADC_RESETBf_SET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_ADC_RESETBf_SET
#define PVTMON_CTL0r_CTRL_I_VDDCMONf_GET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_VDDCMONf_GET
#define PVTMON_CTL0r_CTRL_I_VDDCMONf_SET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_VDDCMONf_SET
#define PVTMON_CTL0r_CTRL_I_PWRDNf_GET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PWRDNf_GET
#define PVTMON_CTL0r_CTRL_I_PWRDNf_SET BCMI_MADURA_PVTMON_CTL0r_CTRL_I_PWRDNf_SET
#define READ_PVTMON_CTL0r BCMI_MADURA_READ_PVTMON_CTL0r
#define WRITE_PVTMON_CTL0r BCMI_MADURA_WRITE_PVTMON_CTL0r
#define MODIFY_PVTMON_CTL0r BCMI_MADURA_MODIFY_PVTMON_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PVTMON_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PVTMON_CTL1
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8121
 * DEVAD:    1
 * DESC:     process voltage temperature sensor controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CTRL_16_16_CON_PAD connect pad_DAC and pad_ADC
 *     CTRL_17_17_BURNIN_EN Enable burn-in clk
 *     CTRL_27_27_DAC_RESET Force DAC output voltage to min, high active
 *     CTRL_28_28_DAC_SET Force DAC output voltage to max, high active
 *     CTRL_23_20_VDDCMON_REFADJ_MIN0 band gap adjustments
 *     CTRL_26_24_VDDCMON_REFADJ_MIN1 Adjustment of VDDCMON voltage threshold:Vmin1Vwarn1 (Default) Vmin1 (Default)
 *     CTRL_18_RSVD     reserved for the future use
 *     CTRL_31_29_VDDCMON_REFADJ_MAX Adjustment of VDDCMON voltage threshold:Vmax
 *     CTRL_19_RSVD     reserved for the future use
 */
#define BCMI_MADURA_PVTMON_CTL1r (0x00018121 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PVTMON_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PVTMON_CTL1.
 */
typedef union BCMI_MADURA_PVTMON_CTL1r_s {
	uint32_t v[1];
	uint32_t pvtmon_ctl1[1];
	uint32_t _pvtmon_ctl1;
} BCMI_MADURA_PVTMON_CTL1r_t;

#define BCMI_MADURA_PVTMON_CTL1r_CLR(r) (r).pvtmon_ctl1[0] = 0
#define BCMI_MADURA_PVTMON_CTL1r_SET(r,d) (r).pvtmon_ctl1[0] = d
#define BCMI_MADURA_PVTMON_CTL1r_GET(r) (r).pvtmon_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_19_RSVDf_GET(r) ((((r).pvtmon_ctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_19_RSVDf_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_31_29_VDDCMON_REFADJ_MAXf_GET(r) ((((r).pvtmon_ctl1[0]) >> 12) & 0x7)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_31_29_VDDCMON_REFADJ_MAXf_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_18_RSVDf_GET(r) ((((r).pvtmon_ctl1[0]) >> 11) & 0x1)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_18_RSVDf_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_26_24_VDDCMON_REFADJ_MIN1f_GET(r) ((((r).pvtmon_ctl1[0]) >> 8) & 0x7)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_26_24_VDDCMON_REFADJ_MIN1f_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_23_20_VDDCMON_REFADJ_MIN0f_GET(r) ((((r).pvtmon_ctl1[0]) >> 4) & 0xf)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_23_20_VDDCMON_REFADJ_MIN0f_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_28_28_DAC_SETf_GET(r) ((((r).pvtmon_ctl1[0]) >> 3) & 0x1)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_28_28_DAC_SETf_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_27_27_DAC_RESETf_GET(r) ((((r).pvtmon_ctl1[0]) >> 2) & 0x1)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_27_27_DAC_RESETf_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_17_17_BURNIN_ENf_GET(r) ((((r).pvtmon_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_17_17_BURNIN_ENf_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_16_16_CON_PADf_GET(r) (((r).pvtmon_ctl1[0]) & 0x1)
#define BCMI_MADURA_PVTMON_CTL1r_CTRL_16_16_CON_PADf_SET(r,f) (r).pvtmon_ctl1[0]=(((r).pvtmon_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PVTMON_CTL1.
 */
#define BCMI_MADURA_READ_PVTMON_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PVTMON_CTL1r,_r._pvtmon_ctl1)
#define BCMI_MADURA_WRITE_PVTMON_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PVTMON_CTL1r,_r._pvtmon_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PVTMON_CTL1r BCMI_MADURA_PVTMON_CTL1r
#define PVTMON_CTL1r_SIZE BCMI_MADURA_PVTMON_CTL1r_SIZE
typedef BCMI_MADURA_PVTMON_CTL1r_t PVTMON_CTL1r_t;
#define PVTMON_CTL1r_CLR BCMI_MADURA_PVTMON_CTL1r_CLR
#define PVTMON_CTL1r_SET BCMI_MADURA_PVTMON_CTL1r_SET
#define PVTMON_CTL1r_GET BCMI_MADURA_PVTMON_CTL1r_GET
#define PVTMON_CTL1r_CTRL_19_RSVDf_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_19_RSVDf_GET
#define PVTMON_CTL1r_CTRL_19_RSVDf_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_19_RSVDf_SET
#define PVTMON_CTL1r_CTRL_31_29_VDDCMON_REFADJ_MAXf_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_31_29_VDDCMON_REFADJ_MAXf_GET
#define PVTMON_CTL1r_CTRL_31_29_VDDCMON_REFADJ_MAXf_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_31_29_VDDCMON_REFADJ_MAXf_SET
#define PVTMON_CTL1r_CTRL_18_RSVDf_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_18_RSVDf_GET
#define PVTMON_CTL1r_CTRL_18_RSVDf_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_18_RSVDf_SET
#define PVTMON_CTL1r_CTRL_26_24_VDDCMON_REFADJ_MIN1f_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_26_24_VDDCMON_REFADJ_MIN1f_GET
#define PVTMON_CTL1r_CTRL_26_24_VDDCMON_REFADJ_MIN1f_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_26_24_VDDCMON_REFADJ_MIN1f_SET
#define PVTMON_CTL1r_CTRL_23_20_VDDCMON_REFADJ_MIN0f_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_23_20_VDDCMON_REFADJ_MIN0f_GET
#define PVTMON_CTL1r_CTRL_23_20_VDDCMON_REFADJ_MIN0f_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_23_20_VDDCMON_REFADJ_MIN0f_SET
#define PVTMON_CTL1r_CTRL_28_28_DAC_SETf_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_28_28_DAC_SETf_GET
#define PVTMON_CTL1r_CTRL_28_28_DAC_SETf_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_28_28_DAC_SETf_SET
#define PVTMON_CTL1r_CTRL_27_27_DAC_RESETf_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_27_27_DAC_RESETf_GET
#define PVTMON_CTL1r_CTRL_27_27_DAC_RESETf_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_27_27_DAC_RESETf_SET
#define PVTMON_CTL1r_CTRL_17_17_BURNIN_ENf_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_17_17_BURNIN_ENf_GET
#define PVTMON_CTL1r_CTRL_17_17_BURNIN_ENf_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_17_17_BURNIN_ENf_SET
#define PVTMON_CTL1r_CTRL_16_16_CON_PADf_GET BCMI_MADURA_PVTMON_CTL1r_CTRL_16_16_CON_PADf_GET
#define PVTMON_CTL1r_CTRL_16_16_CON_PADf_SET BCMI_MADURA_PVTMON_CTL1r_CTRL_16_16_CON_PADf_SET
#define READ_PVTMON_CTL1r BCMI_MADURA_READ_PVTMON_CTL1r
#define WRITE_PVTMON_CTL1r BCMI_MADURA_WRITE_PVTMON_CTL1r
#define MODIFY_PVTMON_CTL1r BCMI_MADURA_MODIFY_PVTMON_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PVTMON_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PVTMON_CTL2
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8122
 * DEVAD:    1
 * DESC:     process voltage temperature sensor controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CTRL_14_13_ADC_INSEL_14_13 This is a multiplexer selection that allows to select the ADC input
 *     CTRL_15_15_DAC_EN Enable DAC
 */
#define BCMI_MADURA_PVTMON_CTL2r (0x00018122 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PVTMON_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PVTMON_CTL2.
 */
typedef union BCMI_MADURA_PVTMON_CTL2r_s {
	uint32_t v[1];
	uint32_t pvtmon_ctl2[1];
	uint32_t _pvtmon_ctl2;
} BCMI_MADURA_PVTMON_CTL2r_t;

#define BCMI_MADURA_PVTMON_CTL2r_CLR(r) (r).pvtmon_ctl2[0] = 0
#define BCMI_MADURA_PVTMON_CTL2r_SET(r,d) (r).pvtmon_ctl2[0] = d
#define BCMI_MADURA_PVTMON_CTL2r_GET(r) (r).pvtmon_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PVTMON_CTL2r_CTRL_15_15_DAC_ENf_GET(r) ((((r).pvtmon_ctl2[0]) >> 2) & 0x1)
#define BCMI_MADURA_PVTMON_CTL2r_CTRL_15_15_DAC_ENf_SET(r,f) (r).pvtmon_ctl2[0]=(((r).pvtmon_ctl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PVTMON_CTL2r_CTRL_14_13_ADC_INSEL_14_13f_GET(r) (((r).pvtmon_ctl2[0]) & 0x3)
#define BCMI_MADURA_PVTMON_CTL2r_CTRL_14_13_ADC_INSEL_14_13f_SET(r,f) (r).pvtmon_ctl2[0]=(((r).pvtmon_ctl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PVTMON_CTL2.
 */
#define BCMI_MADURA_READ_PVTMON_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PVTMON_CTL2r,_r._pvtmon_ctl2)
#define BCMI_MADURA_WRITE_PVTMON_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PVTMON_CTL2r,_r._pvtmon_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PVTMON_CTL2r BCMI_MADURA_PVTMON_CTL2r
#define PVTMON_CTL2r_SIZE BCMI_MADURA_PVTMON_CTL2r_SIZE
typedef BCMI_MADURA_PVTMON_CTL2r_t PVTMON_CTL2r_t;
#define PVTMON_CTL2r_CLR BCMI_MADURA_PVTMON_CTL2r_CLR
#define PVTMON_CTL2r_SET BCMI_MADURA_PVTMON_CTL2r_SET
#define PVTMON_CTL2r_GET BCMI_MADURA_PVTMON_CTL2r_GET
#define PVTMON_CTL2r_CTRL_15_15_DAC_ENf_GET BCMI_MADURA_PVTMON_CTL2r_CTRL_15_15_DAC_ENf_GET
#define PVTMON_CTL2r_CTRL_15_15_DAC_ENf_SET BCMI_MADURA_PVTMON_CTL2r_CTRL_15_15_DAC_ENf_SET
#define PVTMON_CTL2r_CTRL_14_13_ADC_INSEL_14_13f_GET BCMI_MADURA_PVTMON_CTL2r_CTRL_14_13_ADC_INSEL_14_13f_GET
#define PVTMON_CTL2r_CTRL_14_13_ADC_INSEL_14_13f_SET BCMI_MADURA_PVTMON_CTL2r_CTRL_14_13_ADC_INSEL_14_13f_SET
#define READ_PVTMON_CTL2r BCMI_MADURA_READ_PVTMON_CTL2r
#define WRITE_PVTMON_CTL2r BCMI_MADURA_WRITE_PVTMON_CTL2r
#define MODIFY_PVTMON_CTL2r BCMI_MADURA_MODIFY_PVTMON_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PVTMON_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PVTMON_CTL3
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8123
 * DEVAD:    1
 * DESC:     process voltage temperature sensor controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CTRL_2_0_BG_ADJ  band gap adjustments
 *     CTRL_6_3_VTEST_SEL Selects 16 internal test voltages for quick ADC tests
 *     CTRL_9_7_RMON_SEL Resistor monitor select
 *     CTRL_12_10_MODE  Resistor monitor select
 */
#define BCMI_MADURA_PVTMON_CTL3r (0x00018123 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PVTMON_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PVTMON_CTL3.
 */
typedef union BCMI_MADURA_PVTMON_CTL3r_s {
	uint32_t v[1];
	uint32_t pvtmon_ctl3[1];
	uint32_t _pvtmon_ctl3;
} BCMI_MADURA_PVTMON_CTL3r_t;

#define BCMI_MADURA_PVTMON_CTL3r_CLR(r) (r).pvtmon_ctl3[0] = 0
#define BCMI_MADURA_PVTMON_CTL3r_SET(r,d) (r).pvtmon_ctl3[0] = d
#define BCMI_MADURA_PVTMON_CTL3r_GET(r) (r).pvtmon_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_12_10_MODEf_GET(r) ((((r).pvtmon_ctl3[0]) >> 12) & 0x7)
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_12_10_MODEf_SET(r,f) (r).pvtmon_ctl3[0]=(((r).pvtmon_ctl3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_9_7_RMON_SELf_GET(r) ((((r).pvtmon_ctl3[0]) >> 8) & 0x7)
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_9_7_RMON_SELf_SET(r,f) (r).pvtmon_ctl3[0]=(((r).pvtmon_ctl3[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_6_3_VTEST_SELf_GET(r) ((((r).pvtmon_ctl3[0]) >> 4) & 0xf)
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_6_3_VTEST_SELf_SET(r,f) (r).pvtmon_ctl3[0]=(((r).pvtmon_ctl3[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_2_0_BG_ADJf_GET(r) (((r).pvtmon_ctl3[0]) & 0x7)
#define BCMI_MADURA_PVTMON_CTL3r_CTRL_2_0_BG_ADJf_SET(r,f) (r).pvtmon_ctl3[0]=(((r).pvtmon_ctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access PVTMON_CTL3.
 */
#define BCMI_MADURA_READ_PVTMON_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PVTMON_CTL3r,_r._pvtmon_ctl3)
#define BCMI_MADURA_WRITE_PVTMON_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PVTMON_CTL3r,_r._pvtmon_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PVTMON_CTL3r BCMI_MADURA_PVTMON_CTL3r
#define PVTMON_CTL3r_SIZE BCMI_MADURA_PVTMON_CTL3r_SIZE
typedef BCMI_MADURA_PVTMON_CTL3r_t PVTMON_CTL3r_t;
#define PVTMON_CTL3r_CLR BCMI_MADURA_PVTMON_CTL3r_CLR
#define PVTMON_CTL3r_SET BCMI_MADURA_PVTMON_CTL3r_SET
#define PVTMON_CTL3r_GET BCMI_MADURA_PVTMON_CTL3r_GET
#define PVTMON_CTL3r_CTRL_12_10_MODEf_GET BCMI_MADURA_PVTMON_CTL3r_CTRL_12_10_MODEf_GET
#define PVTMON_CTL3r_CTRL_12_10_MODEf_SET BCMI_MADURA_PVTMON_CTL3r_CTRL_12_10_MODEf_SET
#define PVTMON_CTL3r_CTRL_9_7_RMON_SELf_GET BCMI_MADURA_PVTMON_CTL3r_CTRL_9_7_RMON_SELf_GET
#define PVTMON_CTL3r_CTRL_9_7_RMON_SELf_SET BCMI_MADURA_PVTMON_CTL3r_CTRL_9_7_RMON_SELf_SET
#define PVTMON_CTL3r_CTRL_6_3_VTEST_SELf_GET BCMI_MADURA_PVTMON_CTL3r_CTRL_6_3_VTEST_SELf_GET
#define PVTMON_CTL3r_CTRL_6_3_VTEST_SELf_SET BCMI_MADURA_PVTMON_CTL3r_CTRL_6_3_VTEST_SELf_SET
#define PVTMON_CTL3r_CTRL_2_0_BG_ADJf_GET BCMI_MADURA_PVTMON_CTL3r_CTRL_2_0_BG_ADJf_GET
#define PVTMON_CTL3r_CTRL_2_0_BG_ADJf_SET BCMI_MADURA_PVTMON_CTL3r_CTRL_2_0_BG_ADJf_SET
#define READ_PVTMON_CTL3r BCMI_MADURA_READ_PVTMON_CTL3r
#define WRITE_PVTMON_CTL3r BCMI_MADURA_WRITE_PVTMON_CTL3r
#define MODIFY_PVTMON_CTL3r BCMI_MADURA_MODIFY_PVTMON_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PVTMON_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PVTMON_CTL4
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8124
 * DEVAD:    1
 * DESC:     process voltage temperature sensor controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CTRL_DAC_DATA    DAC data for digital to analog conversion
 */
#define BCMI_MADURA_PVTMON_CTL4r (0x00018124 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PVTMON_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program PVTMON_CTL4.
 */
typedef union BCMI_MADURA_PVTMON_CTL4r_s {
	uint32_t v[1];
	uint32_t pvtmon_ctl4[1];
	uint32_t _pvtmon_ctl4;
} BCMI_MADURA_PVTMON_CTL4r_t;

#define BCMI_MADURA_PVTMON_CTL4r_CLR(r) (r).pvtmon_ctl4[0] = 0
#define BCMI_MADURA_PVTMON_CTL4r_SET(r,d) (r).pvtmon_ctl4[0] = d
#define BCMI_MADURA_PVTMON_CTL4r_GET(r) (r).pvtmon_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PVTMON_CTL4r_CTRL_DAC_DATAf_GET(r) (((r).pvtmon_ctl4[0]) & 0x3ff)
#define BCMI_MADURA_PVTMON_CTL4r_CTRL_DAC_DATAf_SET(r,f) (r).pvtmon_ctl4[0]=(((r).pvtmon_ctl4[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PVTMON_CTL4.
 */
#define BCMI_MADURA_READ_PVTMON_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PVTMON_CTL4r,_r._pvtmon_ctl4)
#define BCMI_MADURA_WRITE_PVTMON_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PVTMON_CTL4r,_r._pvtmon_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PVTMON_CTL4r BCMI_MADURA_PVTMON_CTL4r
#define PVTMON_CTL4r_SIZE BCMI_MADURA_PVTMON_CTL4r_SIZE
typedef BCMI_MADURA_PVTMON_CTL4r_t PVTMON_CTL4r_t;
#define PVTMON_CTL4r_CLR BCMI_MADURA_PVTMON_CTL4r_CLR
#define PVTMON_CTL4r_SET BCMI_MADURA_PVTMON_CTL4r_SET
#define PVTMON_CTL4r_GET BCMI_MADURA_PVTMON_CTL4r_GET
#define PVTMON_CTL4r_CTRL_DAC_DATAf_GET BCMI_MADURA_PVTMON_CTL4r_CTRL_DAC_DATAf_GET
#define PVTMON_CTL4r_CTRL_DAC_DATAf_SET BCMI_MADURA_PVTMON_CTL4r_CTRL_DAC_DATAf_SET
#define READ_PVTMON_CTL4r BCMI_MADURA_READ_PVTMON_CTL4r
#define WRITE_PVTMON_CTL4r BCMI_MADURA_WRITE_PVTMON_CTL4r
#define MODIFY_PVTMON_CTL4r BCMI_MADURA_MODIFY_PVTMON_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PVTMON_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PVTMON_STS0
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8125
 * DEVAD:    1
 * DESC:     process voltage temperature sensor controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     STS_O_VDDC_MINB0 set when i_VDDC < Vmin0
 *     STS_O_VDDC_WARNINGB0 set when VDDC < Vwarn0
 *     STS_O_VDDC_MINB1 set when i_VDDC < Vmin1
 *     STS_O_VDDC_WARNINGB1 set when VDDC < Vwarn1
 *     STS_O_VDDC_MAXB0 set when i_VDDC > Vmax0
 *     STS_O_VDDC_MAXB1 set when i_VDDC > Vmax1
 */
#define BCMI_MADURA_PVTMON_STS0r (0x00018125 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PVTMON_STS0r_SIZE 4

/*
 * This structure should be used to declare and program PVTMON_STS0.
 */
typedef union BCMI_MADURA_PVTMON_STS0r_s {
	uint32_t v[1];
	uint32_t pvtmon_sts0[1];
	uint32_t _pvtmon_sts0;
} BCMI_MADURA_PVTMON_STS0r_t;

#define BCMI_MADURA_PVTMON_STS0r_CLR(r) (r).pvtmon_sts0[0] = 0
#define BCMI_MADURA_PVTMON_STS0r_SET(r,d) (r).pvtmon_sts0[0] = d
#define BCMI_MADURA_PVTMON_STS0r_GET(r) (r).pvtmon_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB1f_GET(r) ((((r).pvtmon_sts0[0]) >> 5) & 0x1)
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB1f_SET(r,f) (r).pvtmon_sts0[0]=(((r).pvtmon_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB0f_GET(r) ((((r).pvtmon_sts0[0]) >> 4) & 0x1)
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB0f_SET(r,f) (r).pvtmon_sts0[0]=(((r).pvtmon_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB1f_GET(r) ((((r).pvtmon_sts0[0]) >> 3) & 0x1)
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB1f_SET(r,f) (r).pvtmon_sts0[0]=(((r).pvtmon_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB1f_GET(r) ((((r).pvtmon_sts0[0]) >> 2) & 0x1)
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB1f_SET(r,f) (r).pvtmon_sts0[0]=(((r).pvtmon_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB0f_GET(r) ((((r).pvtmon_sts0[0]) >> 1) & 0x1)
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB0f_SET(r,f) (r).pvtmon_sts0[0]=(((r).pvtmon_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB0f_GET(r) (((r).pvtmon_sts0[0]) & 0x1)
#define BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB0f_SET(r,f) (r).pvtmon_sts0[0]=(((r).pvtmon_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PVTMON_STS0.
 */
#define BCMI_MADURA_READ_PVTMON_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PVTMON_STS0r,_r._pvtmon_sts0)
#define BCMI_MADURA_WRITE_PVTMON_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PVTMON_STS0r,_r._pvtmon_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PVTMON_STS0r BCMI_MADURA_PVTMON_STS0r
#define PVTMON_STS0r_SIZE BCMI_MADURA_PVTMON_STS0r_SIZE
typedef BCMI_MADURA_PVTMON_STS0r_t PVTMON_STS0r_t;
#define PVTMON_STS0r_CLR BCMI_MADURA_PVTMON_STS0r_CLR
#define PVTMON_STS0r_SET BCMI_MADURA_PVTMON_STS0r_SET
#define PVTMON_STS0r_GET BCMI_MADURA_PVTMON_STS0r_GET
#define PVTMON_STS0r_STS_O_VDDC_MAXB1f_GET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB1f_GET
#define PVTMON_STS0r_STS_O_VDDC_MAXB1f_SET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB1f_SET
#define PVTMON_STS0r_STS_O_VDDC_MAXB0f_GET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB0f_GET
#define PVTMON_STS0r_STS_O_VDDC_MAXB0f_SET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MAXB0f_SET
#define PVTMON_STS0r_STS_O_VDDC_WARNINGB1f_GET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB1f_GET
#define PVTMON_STS0r_STS_O_VDDC_WARNINGB1f_SET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB1f_SET
#define PVTMON_STS0r_STS_O_VDDC_MINB1f_GET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB1f_GET
#define PVTMON_STS0r_STS_O_VDDC_MINB1f_SET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB1f_SET
#define PVTMON_STS0r_STS_O_VDDC_WARNINGB0f_GET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB0f_GET
#define PVTMON_STS0r_STS_O_VDDC_WARNINGB0f_SET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_WARNINGB0f_SET
#define PVTMON_STS0r_STS_O_VDDC_MINB0f_GET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB0f_GET
#define PVTMON_STS0r_STS_O_VDDC_MINB0f_SET BCMI_MADURA_PVTMON_STS0r_STS_O_VDDC_MINB0f_SET
#define READ_PVTMON_STS0r BCMI_MADURA_READ_PVTMON_STS0r
#define WRITE_PVTMON_STS0r BCMI_MADURA_WRITE_PVTMON_STS0r
#define MODIFY_PVTMON_STS0r BCMI_MADURA_MODIFY_PVTMON_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PVTMON_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PVTMON_STS1
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8126
 * DEVAD:    1
 * DESC:     process voltage temperature sensor controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     STS_O_ADC_DATA   ADC sampled data, select the inputs to    the ADC correctly before reading this data
 *     STS_O_ADC_STROBE ADC strobe
 */
#define BCMI_MADURA_PVTMON_STS1r (0x00018126 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PVTMON_STS1r_SIZE 4

/*
 * This structure should be used to declare and program PVTMON_STS1.
 */
typedef union BCMI_MADURA_PVTMON_STS1r_s {
	uint32_t v[1];
	uint32_t pvtmon_sts1[1];
	uint32_t _pvtmon_sts1;
} BCMI_MADURA_PVTMON_STS1r_t;

#define BCMI_MADURA_PVTMON_STS1r_CLR(r) (r).pvtmon_sts1[0] = 0
#define BCMI_MADURA_PVTMON_STS1r_SET(r,d) (r).pvtmon_sts1[0] = d
#define BCMI_MADURA_PVTMON_STS1r_GET(r) (r).pvtmon_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_STROBEf_GET(r) ((((r).pvtmon_sts1[0]) >> 12) & 0x1)
#define BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_STROBEf_SET(r,f) (r).pvtmon_sts1[0]=(((r).pvtmon_sts1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_DATAf_GET(r) (((r).pvtmon_sts1[0]) & 0x3ff)
#define BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_DATAf_SET(r,f) (r).pvtmon_sts1[0]=(((r).pvtmon_sts1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PVTMON_STS1.
 */
#define BCMI_MADURA_READ_PVTMON_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PVTMON_STS1r,_r._pvtmon_sts1)
#define BCMI_MADURA_WRITE_PVTMON_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PVTMON_STS1r,_r._pvtmon_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PVTMON_STS1r BCMI_MADURA_PVTMON_STS1r
#define PVTMON_STS1r_SIZE BCMI_MADURA_PVTMON_STS1r_SIZE
typedef BCMI_MADURA_PVTMON_STS1r_t PVTMON_STS1r_t;
#define PVTMON_STS1r_CLR BCMI_MADURA_PVTMON_STS1r_CLR
#define PVTMON_STS1r_SET BCMI_MADURA_PVTMON_STS1r_SET
#define PVTMON_STS1r_GET BCMI_MADURA_PVTMON_STS1r_GET
#define PVTMON_STS1r_STS_O_ADC_STROBEf_GET BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_STROBEf_GET
#define PVTMON_STS1r_STS_O_ADC_STROBEf_SET BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_STROBEf_SET
#define PVTMON_STS1r_STS_O_ADC_DATAf_GET BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_DATAf_GET
#define PVTMON_STS1r_STS_O_ADC_DATAf_SET BCMI_MADURA_PVTMON_STS1r_STS_O_ADC_DATAf_SET
#define READ_PVTMON_STS1r BCMI_MADURA_READ_PVTMON_STS1r
#define WRITE_PVTMON_STS1r BCMI_MADURA_WRITE_PVTMON_STS1r
#define MODIFY_PVTMON_STS1r BCMI_MADURA_MODIFY_PVTMON_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PVTMON_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_CTL_0_TO_15
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8140
 * DEVAD:    1
 * DESC:     i_vr_cntl_0_to_15 voltage regulator control bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_CNTL0       1st 16 control bits for  voltage regulator
 */
#define BCMI_MADURA_I_VR_CTL_0_TO_15r (0x00018140 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_CTL_0_TO_15r_SIZE 4

/*
 * This structure should be used to declare and program I_VR_CTL_0_TO_15.
 */
typedef union BCMI_MADURA_I_VR_CTL_0_TO_15r_s {
	uint32_t v[1];
	uint32_t i_vr_ctl_0_to_15[1];
	uint32_t _i_vr_ctl_0_to_15;
} BCMI_MADURA_I_VR_CTL_0_TO_15r_t;

#define BCMI_MADURA_I_VR_CTL_0_TO_15r_CLR(r) (r).i_vr_ctl_0_to_15[0] = 0
#define BCMI_MADURA_I_VR_CTL_0_TO_15r_SET(r,d) (r).i_vr_ctl_0_to_15[0] = d
#define BCMI_MADURA_I_VR_CTL_0_TO_15r_GET(r) (r).i_vr_ctl_0_to_15[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_CTL_0_TO_15r_I_VR_CNTL0f_GET(r) (((r).i_vr_ctl_0_to_15[0]) & 0xffff)
#define BCMI_MADURA_I_VR_CTL_0_TO_15r_I_VR_CNTL0f_SET(r,f) (r).i_vr_ctl_0_to_15[0]=(((r).i_vr_ctl_0_to_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access I_VR_CTL_0_TO_15.
 */
#define BCMI_MADURA_READ_I_VR_CTL_0_TO_15r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_CTL_0_TO_15r,_r._i_vr_ctl_0_to_15)
#define BCMI_MADURA_WRITE_I_VR_CTL_0_TO_15r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_CTL_0_TO_15r,_r._i_vr_ctl_0_to_15)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_CTL_0_TO_15r BCMI_MADURA_I_VR_CTL_0_TO_15r
#define I_VR_CTL_0_TO_15r_SIZE BCMI_MADURA_I_VR_CTL_0_TO_15r_SIZE
typedef BCMI_MADURA_I_VR_CTL_0_TO_15r_t I_VR_CTL_0_TO_15r_t;
#define I_VR_CTL_0_TO_15r_CLR BCMI_MADURA_I_VR_CTL_0_TO_15r_CLR
#define I_VR_CTL_0_TO_15r_SET BCMI_MADURA_I_VR_CTL_0_TO_15r_SET
#define I_VR_CTL_0_TO_15r_GET BCMI_MADURA_I_VR_CTL_0_TO_15r_GET
#define I_VR_CTL_0_TO_15r_I_VR_CNTL0f_GET BCMI_MADURA_I_VR_CTL_0_TO_15r_I_VR_CNTL0f_GET
#define I_VR_CTL_0_TO_15r_I_VR_CNTL0f_SET BCMI_MADURA_I_VR_CTL_0_TO_15r_I_VR_CNTL0f_SET
#define READ_I_VR_CTL_0_TO_15r BCMI_MADURA_READ_I_VR_CTL_0_TO_15r
#define WRITE_I_VR_CTL_0_TO_15r BCMI_MADURA_WRITE_I_VR_CTL_0_TO_15r
#define MODIFY_I_VR_CTL_0_TO_15r BCMI_MADURA_MODIFY_I_VR_CTL_0_TO_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_CTL_0_TO_15r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_CTL_16_TO_18
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8141
 * DEVAD:    1
 * DESC:     i_vr_cntl_16_to_18 voltage regulator control bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_CNTL1       voltage regulator control bits
 */
#define BCMI_MADURA_I_VR_CTL_16_TO_18r (0x00018141 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_CTL_16_TO_18r_SIZE 4

/*
 * This structure should be used to declare and program I_VR_CTL_16_TO_18.
 */
typedef union BCMI_MADURA_I_VR_CTL_16_TO_18r_s {
	uint32_t v[1];
	uint32_t i_vr_ctl_16_to_18[1];
	uint32_t _i_vr_ctl_16_to_18;
} BCMI_MADURA_I_VR_CTL_16_TO_18r_t;

#define BCMI_MADURA_I_VR_CTL_16_TO_18r_CLR(r) (r).i_vr_ctl_16_to_18[0] = 0
#define BCMI_MADURA_I_VR_CTL_16_TO_18r_SET(r,d) (r).i_vr_ctl_16_to_18[0] = d
#define BCMI_MADURA_I_VR_CTL_16_TO_18r_GET(r) (r).i_vr_ctl_16_to_18[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_CTL_16_TO_18r_I_VR_CNTL1f_GET(r) (((r).i_vr_ctl_16_to_18[0]) & 0x7)
#define BCMI_MADURA_I_VR_CTL_16_TO_18r_I_VR_CNTL1f_SET(r,f) (r).i_vr_ctl_16_to_18[0]=(((r).i_vr_ctl_16_to_18[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access I_VR_CTL_16_TO_18.
 */
#define BCMI_MADURA_READ_I_VR_CTL_16_TO_18r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_CTL_16_TO_18r,_r._i_vr_ctl_16_to_18)
#define BCMI_MADURA_WRITE_I_VR_CTL_16_TO_18r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_CTL_16_TO_18r,_r._i_vr_ctl_16_to_18)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_CTL_16_TO_18r BCMI_MADURA_I_VR_CTL_16_TO_18r
#define I_VR_CTL_16_TO_18r_SIZE BCMI_MADURA_I_VR_CTL_16_TO_18r_SIZE
typedef BCMI_MADURA_I_VR_CTL_16_TO_18r_t I_VR_CTL_16_TO_18r_t;
#define I_VR_CTL_16_TO_18r_CLR BCMI_MADURA_I_VR_CTL_16_TO_18r_CLR
#define I_VR_CTL_16_TO_18r_SET BCMI_MADURA_I_VR_CTL_16_TO_18r_SET
#define I_VR_CTL_16_TO_18r_GET BCMI_MADURA_I_VR_CTL_16_TO_18r_GET
#define I_VR_CTL_16_TO_18r_I_VR_CNTL1f_GET BCMI_MADURA_I_VR_CTL_16_TO_18r_I_VR_CNTL1f_GET
#define I_VR_CTL_16_TO_18r_I_VR_CNTL1f_SET BCMI_MADURA_I_VR_CTL_16_TO_18r_I_VR_CNTL1f_SET
#define READ_I_VR_CTL_16_TO_18r BCMI_MADURA_READ_I_VR_CTL_16_TO_18r
#define WRITE_I_VR_CTL_16_TO_18r BCMI_MADURA_WRITE_I_VR_CTL_16_TO_18r
#define MODIFY_I_VR_CTL_16_TO_18r BCMI_MADURA_MODIFY_I_VR_CTL_16_TO_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_CTL_16_TO_18r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_PWRDN_CTL
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8142
 * DEVAD:    1
 * DESC:     i_vr_pwrdn_cntl voltage regulator control bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_PWRDN       power down the voltage regulator
 */
#define BCMI_MADURA_I_VR_PWRDN_CTLr (0x00018142 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_PWRDN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program I_VR_PWRDN_CTL.
 */
typedef union BCMI_MADURA_I_VR_PWRDN_CTLr_s {
	uint32_t v[1];
	uint32_t i_vr_pwrdn_ctl[1];
	uint32_t _i_vr_pwrdn_ctl;
} BCMI_MADURA_I_VR_PWRDN_CTLr_t;

#define BCMI_MADURA_I_VR_PWRDN_CTLr_CLR(r) (r).i_vr_pwrdn_ctl[0] = 0
#define BCMI_MADURA_I_VR_PWRDN_CTLr_SET(r,d) (r).i_vr_pwrdn_ctl[0] = d
#define BCMI_MADURA_I_VR_PWRDN_CTLr_GET(r) (r).i_vr_pwrdn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_PWRDN_CTLr_I_VR_PWRDNf_GET(r) (((r).i_vr_pwrdn_ctl[0]) & 0x1)
#define BCMI_MADURA_I_VR_PWRDN_CTLr_I_VR_PWRDNf_SET(r,f) (r).i_vr_pwrdn_ctl[0]=(((r).i_vr_pwrdn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access I_VR_PWRDN_CTL.
 */
#define BCMI_MADURA_READ_I_VR_PWRDN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_PWRDN_CTLr,_r._i_vr_pwrdn_ctl)
#define BCMI_MADURA_WRITE_I_VR_PWRDN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_PWRDN_CTLr,_r._i_vr_pwrdn_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_PWRDN_CTLr BCMI_MADURA_I_VR_PWRDN_CTLr
#define I_VR_PWRDN_CTLr_SIZE BCMI_MADURA_I_VR_PWRDN_CTLr_SIZE
typedef BCMI_MADURA_I_VR_PWRDN_CTLr_t I_VR_PWRDN_CTLr_t;
#define I_VR_PWRDN_CTLr_CLR BCMI_MADURA_I_VR_PWRDN_CTLr_CLR
#define I_VR_PWRDN_CTLr_SET BCMI_MADURA_I_VR_PWRDN_CTLr_SET
#define I_VR_PWRDN_CTLr_GET BCMI_MADURA_I_VR_PWRDN_CTLr_GET
#define I_VR_PWRDN_CTLr_I_VR_PWRDNf_GET BCMI_MADURA_I_VR_PWRDN_CTLr_I_VR_PWRDNf_GET
#define I_VR_PWRDN_CTLr_I_VR_PWRDNf_SET BCMI_MADURA_I_VR_PWRDN_CTLr_I_VR_PWRDNf_SET
#define READ_I_VR_PWRDN_CTLr BCMI_MADURA_READ_I_VR_PWRDN_CTLr
#define WRITE_I_VR_PWRDN_CTLr BCMI_MADURA_WRITE_I_VR_PWRDN_CTLr
#define MODIFY_I_VR_PWRDN_CTLr BCMI_MADURA_MODIFY_I_VR_PWRDN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_PWRDN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_CTL_EN
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8143
 * DEVAD:    1
 * DESC:     i_vr_cntl_enable enable the voltage regulator
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_CNTL_EN     The voltage regulator enable
 */
#define BCMI_MADURA_I_VR_CTL_ENr (0x00018143 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_CTL_ENr_SIZE 4

/*
 * This structure should be used to declare and program I_VR_CTL_EN.
 */
typedef union BCMI_MADURA_I_VR_CTL_ENr_s {
	uint32_t v[1];
	uint32_t i_vr_ctl_en[1];
	uint32_t _i_vr_ctl_en;
} BCMI_MADURA_I_VR_CTL_ENr_t;

#define BCMI_MADURA_I_VR_CTL_ENr_CLR(r) (r).i_vr_ctl_en[0] = 0
#define BCMI_MADURA_I_VR_CTL_ENr_SET(r,d) (r).i_vr_ctl_en[0] = d
#define BCMI_MADURA_I_VR_CTL_ENr_GET(r) (r).i_vr_ctl_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_CTL_ENr_I_VR_CNTL_ENf_GET(r) (((r).i_vr_ctl_en[0]) & 0x1)
#define BCMI_MADURA_I_VR_CTL_ENr_I_VR_CNTL_ENf_SET(r,f) (r).i_vr_ctl_en[0]=(((r).i_vr_ctl_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access I_VR_CTL_EN.
 */
#define BCMI_MADURA_READ_I_VR_CTL_ENr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_CTL_ENr,_r._i_vr_ctl_en)
#define BCMI_MADURA_WRITE_I_VR_CTL_ENr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_CTL_ENr,_r._i_vr_ctl_en)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_CTL_ENr BCMI_MADURA_I_VR_CTL_ENr
#define I_VR_CTL_ENr_SIZE BCMI_MADURA_I_VR_CTL_ENr_SIZE
typedef BCMI_MADURA_I_VR_CTL_ENr_t I_VR_CTL_ENr_t;
#define I_VR_CTL_ENr_CLR BCMI_MADURA_I_VR_CTL_ENr_CLR
#define I_VR_CTL_ENr_SET BCMI_MADURA_I_VR_CTL_ENr_SET
#define I_VR_CTL_ENr_GET BCMI_MADURA_I_VR_CTL_ENr_GET
#define I_VR_CTL_ENr_I_VR_CNTL_ENf_GET BCMI_MADURA_I_VR_CTL_ENr_I_VR_CNTL_ENf_GET
#define I_VR_CTL_ENr_I_VR_CNTL_ENf_SET BCMI_MADURA_I_VR_CTL_ENr_I_VR_CNTL_ENf_SET
#define READ_I_VR_CTL_ENr BCMI_MADURA_READ_I_VR_CTL_ENr
#define WRITE_I_VR_CTL_ENr BCMI_MADURA_WRITE_I_VR_CTL_ENr
#define MODIFY_I_VR_CTL_ENr BCMI_MADURA_MODIFY_I_VR_CTL_ENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_CTL_ENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_CTL_0_TO_15_2NDLDO
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8144
 * DEVAD:    1
 * DESC:     i_vr_cntl_0_to_15_2ndLDO voltage regulator control bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_CNTL0_2NDLDO 1st 16 control bits for  voltage regulator
 */
#define BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr (0x00018144 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_SIZE 4

/*
 * This structure should be used to declare and program I_VR_CTL_0_TO_15_2NDLDO.
 */
typedef union BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_s {
	uint32_t v[1];
	uint32_t i_vr_ctl_0_to_15_2ndldo[1];
	uint32_t _i_vr_ctl_0_to_15_2ndldo;
} BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_t;

#define BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_CLR(r) (r).i_vr_ctl_0_to_15_2ndldo[0] = 0
#define BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_SET(r,d) (r).i_vr_ctl_0_to_15_2ndldo[0] = d
#define BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_GET(r) (r).i_vr_ctl_0_to_15_2ndldo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_I_VR_CNTL0_2NDLDOf_GET(r) (((r).i_vr_ctl_0_to_15_2ndldo[0]) & 0xffff)
#define BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_I_VR_CNTL0_2NDLDOf_SET(r,f) (r).i_vr_ctl_0_to_15_2ndldo[0]=(((r).i_vr_ctl_0_to_15_2ndldo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access I_VR_CTL_0_TO_15_2NDLDO.
 */
#define BCMI_MADURA_READ_I_VR_CTL_0_TO_15_2NDLDOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr,_r._i_vr_ctl_0_to_15_2ndldo)
#define BCMI_MADURA_WRITE_I_VR_CTL_0_TO_15_2NDLDOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr,_r._i_vr_ctl_0_to_15_2ndldo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_CTL_0_TO_15_2NDLDOr BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr
#define I_VR_CTL_0_TO_15_2NDLDOr_SIZE BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_SIZE
typedef BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_t I_VR_CTL_0_TO_15_2NDLDOr_t;
#define I_VR_CTL_0_TO_15_2NDLDOr_CLR BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_CLR
#define I_VR_CTL_0_TO_15_2NDLDOr_SET BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_SET
#define I_VR_CTL_0_TO_15_2NDLDOr_GET BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_GET
#define I_VR_CTL_0_TO_15_2NDLDOr_I_VR_CNTL0_2NDLDOf_GET BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_I_VR_CNTL0_2NDLDOf_GET
#define I_VR_CTL_0_TO_15_2NDLDOr_I_VR_CNTL0_2NDLDOf_SET BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr_I_VR_CNTL0_2NDLDOf_SET
#define READ_I_VR_CTL_0_TO_15_2NDLDOr BCMI_MADURA_READ_I_VR_CTL_0_TO_15_2NDLDOr
#define WRITE_I_VR_CTL_0_TO_15_2NDLDOr BCMI_MADURA_WRITE_I_VR_CTL_0_TO_15_2NDLDOr
#define MODIFY_I_VR_CTL_0_TO_15_2NDLDOr BCMI_MADURA_MODIFY_I_VR_CTL_0_TO_15_2NDLDOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_CTL_0_TO_15_2NDLDOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_CTL_16_TO_18_2NDLDO
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8145
 * DEVAD:    1
 * DESC:     i_vr_cntl_16_to_18_2ndLDO voltage regulator control bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_CNTL1_2NDLDO voltage regulator control bits
 */
#define BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr (0x00018145 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_SIZE 4

/*
 * This structure should be used to declare and program I_VR_CTL_16_TO_18_2NDLDO.
 */
typedef union BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_s {
	uint32_t v[1];
	uint32_t i_vr_ctl_16_to_18_2ndldo[1];
	uint32_t _i_vr_ctl_16_to_18_2ndldo;
} BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_t;

#define BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_CLR(r) (r).i_vr_ctl_16_to_18_2ndldo[0] = 0
#define BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_SET(r,d) (r).i_vr_ctl_16_to_18_2ndldo[0] = d
#define BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_GET(r) (r).i_vr_ctl_16_to_18_2ndldo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_I_VR_CNTL1_2NDLDOf_GET(r) (((r).i_vr_ctl_16_to_18_2ndldo[0]) & 0x7)
#define BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_I_VR_CNTL1_2NDLDOf_SET(r,f) (r).i_vr_ctl_16_to_18_2ndldo[0]=(((r).i_vr_ctl_16_to_18_2ndldo[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access I_VR_CTL_16_TO_18_2NDLDO.
 */
#define BCMI_MADURA_READ_I_VR_CTL_16_TO_18_2NDLDOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr,_r._i_vr_ctl_16_to_18_2ndldo)
#define BCMI_MADURA_WRITE_I_VR_CTL_16_TO_18_2NDLDOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr,_r._i_vr_ctl_16_to_18_2ndldo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_CTL_16_TO_18_2NDLDOr BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr
#define I_VR_CTL_16_TO_18_2NDLDOr_SIZE BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_SIZE
typedef BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_t I_VR_CTL_16_TO_18_2NDLDOr_t;
#define I_VR_CTL_16_TO_18_2NDLDOr_CLR BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_CLR
#define I_VR_CTL_16_TO_18_2NDLDOr_SET BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_SET
#define I_VR_CTL_16_TO_18_2NDLDOr_GET BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_GET
#define I_VR_CTL_16_TO_18_2NDLDOr_I_VR_CNTL1_2NDLDOf_GET BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_I_VR_CNTL1_2NDLDOf_GET
#define I_VR_CTL_16_TO_18_2NDLDOr_I_VR_CNTL1_2NDLDOf_SET BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr_I_VR_CNTL1_2NDLDOf_SET
#define READ_I_VR_CTL_16_TO_18_2NDLDOr BCMI_MADURA_READ_I_VR_CTL_16_TO_18_2NDLDOr
#define WRITE_I_VR_CTL_16_TO_18_2NDLDOr BCMI_MADURA_WRITE_I_VR_CTL_16_TO_18_2NDLDOr
#define MODIFY_I_VR_CTL_16_TO_18_2NDLDOr BCMI_MADURA_MODIFY_I_VR_CTL_16_TO_18_2NDLDOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_CTL_16_TO_18_2NDLDOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_PWRDN_CTL_2NDLDO
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8146
 * DEVAD:    1
 * DESC:     i_vr_pwrdn_cntl_2ndLDO voltage regulator control bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_PWRDN_2NDLDO power down the voltage regulator
 */
#define BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr (0x00018146 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_SIZE 4

/*
 * This structure should be used to declare and program I_VR_PWRDN_CTL_2NDLDO.
 */
typedef union BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_s {
	uint32_t v[1];
	uint32_t i_vr_pwrdn_ctl_2ndldo[1];
	uint32_t _i_vr_pwrdn_ctl_2ndldo;
} BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_t;

#define BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_CLR(r) (r).i_vr_pwrdn_ctl_2ndldo[0] = 0
#define BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_SET(r,d) (r).i_vr_pwrdn_ctl_2ndldo[0] = d
#define BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_GET(r) (r).i_vr_pwrdn_ctl_2ndldo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_I_VR_PWRDN_2NDLDOf_GET(r) (((r).i_vr_pwrdn_ctl_2ndldo[0]) & 0x1)
#define BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_I_VR_PWRDN_2NDLDOf_SET(r,f) (r).i_vr_pwrdn_ctl_2ndldo[0]=(((r).i_vr_pwrdn_ctl_2ndldo[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access I_VR_PWRDN_CTL_2NDLDO.
 */
#define BCMI_MADURA_READ_I_VR_PWRDN_CTL_2NDLDOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr,_r._i_vr_pwrdn_ctl_2ndldo)
#define BCMI_MADURA_WRITE_I_VR_PWRDN_CTL_2NDLDOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr,_r._i_vr_pwrdn_ctl_2ndldo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_PWRDN_CTL_2NDLDOr BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr
#define I_VR_PWRDN_CTL_2NDLDOr_SIZE BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_SIZE
typedef BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_t I_VR_PWRDN_CTL_2NDLDOr_t;
#define I_VR_PWRDN_CTL_2NDLDOr_CLR BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_CLR
#define I_VR_PWRDN_CTL_2NDLDOr_SET BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_SET
#define I_VR_PWRDN_CTL_2NDLDOr_GET BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_GET
#define I_VR_PWRDN_CTL_2NDLDOr_I_VR_PWRDN_2NDLDOf_GET BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_I_VR_PWRDN_2NDLDOf_GET
#define I_VR_PWRDN_CTL_2NDLDOr_I_VR_PWRDN_2NDLDOf_SET BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr_I_VR_PWRDN_2NDLDOf_SET
#define READ_I_VR_PWRDN_CTL_2NDLDOr BCMI_MADURA_READ_I_VR_PWRDN_CTL_2NDLDOr
#define WRITE_I_VR_PWRDN_CTL_2NDLDOr BCMI_MADURA_WRITE_I_VR_PWRDN_CTL_2NDLDOr
#define MODIFY_I_VR_PWRDN_CTL_2NDLDOr BCMI_MADURA_MODIFY_I_VR_PWRDN_CTL_2NDLDOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_PWRDN_CTL_2NDLDOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  I_VR_CTL_EN_2NDLDO
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8147
 * DEVAD:    1
 * DESC:     i_vr_cntl_enable_2ndLDO enable the voltage regulator
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_VR_CNTL_EN_2NDLDO The voltage regulator enable
 */
#define BCMI_MADURA_I_VR_CTL_EN_2NDLDOr (0x00018147 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_SIZE 4

/*
 * This structure should be used to declare and program I_VR_CTL_EN_2NDLDO.
 */
typedef union BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_s {
	uint32_t v[1];
	uint32_t i_vr_ctl_en_2ndldo[1];
	uint32_t _i_vr_ctl_en_2ndldo;
} BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_t;

#define BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_CLR(r) (r).i_vr_ctl_en_2ndldo[0] = 0
#define BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_SET(r,d) (r).i_vr_ctl_en_2ndldo[0] = d
#define BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_GET(r) (r).i_vr_ctl_en_2ndldo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_I_VR_CNTL_EN_2NDLDOf_GET(r) (((r).i_vr_ctl_en_2ndldo[0]) & 0x1)
#define BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_I_VR_CNTL_EN_2NDLDOf_SET(r,f) (r).i_vr_ctl_en_2ndldo[0]=(((r).i_vr_ctl_en_2ndldo[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access I_VR_CTL_EN_2NDLDO.
 */
#define BCMI_MADURA_READ_I_VR_CTL_EN_2NDLDOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_I_VR_CTL_EN_2NDLDOr,_r._i_vr_ctl_en_2ndldo)
#define BCMI_MADURA_WRITE_I_VR_CTL_EN_2NDLDOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_I_VR_CTL_EN_2NDLDOr,_r._i_vr_ctl_en_2ndldo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define I_VR_CTL_EN_2NDLDOr BCMI_MADURA_I_VR_CTL_EN_2NDLDOr
#define I_VR_CTL_EN_2NDLDOr_SIZE BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_SIZE
typedef BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_t I_VR_CTL_EN_2NDLDOr_t;
#define I_VR_CTL_EN_2NDLDOr_CLR BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_CLR
#define I_VR_CTL_EN_2NDLDOr_SET BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_SET
#define I_VR_CTL_EN_2NDLDOr_GET BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_GET
#define I_VR_CTL_EN_2NDLDOr_I_VR_CNTL_EN_2NDLDOf_GET BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_I_VR_CNTL_EN_2NDLDOf_GET
#define I_VR_CTL_EN_2NDLDOr_I_VR_CNTL_EN_2NDLDOf_SET BCMI_MADURA_I_VR_CTL_EN_2NDLDOr_I_VR_CNTL_EN_2NDLDOf_SET
#define READ_I_VR_CTL_EN_2NDLDOr BCMI_MADURA_READ_I_VR_CTL_EN_2NDLDOr
#define WRITE_I_VR_CTL_EN_2NDLDOr BCMI_MADURA_WRITE_I_VR_CTL_EN_2NDLDOr
#define MODIFY_I_VR_CTL_EN_2NDLDOr BCMI_MADURA_MODIFY_I_VR_CTL_EN_2NDLDOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_I_VR_CTL_EN_2NDLDOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RESCAL_STS1
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8148
 * DEVAD:    1
 * DESC:     status register-1 holds various debug signals
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     O_RESCAL_CTRL_DFS This displays the default values of the rescal controls
 *     O_VALID          used for debug purposes
 */
#define BCMI_MADURA_RESCAL_STS1r (0x00018148 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RESCAL_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RESCAL_STS1.
 */
typedef union BCMI_MADURA_RESCAL_STS1r_s {
	uint32_t v[1];
	uint32_t rescal_sts1[1];
	uint32_t _rescal_sts1;
} BCMI_MADURA_RESCAL_STS1r_t;

#define BCMI_MADURA_RESCAL_STS1r_CLR(r) (r).rescal_sts1[0] = 0
#define BCMI_MADURA_RESCAL_STS1r_SET(r,d) (r).rescal_sts1[0] = d
#define BCMI_MADURA_RESCAL_STS1r_GET(r) (r).rescal_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RESCAL_STS1r_O_VALIDf_GET(r) ((((r).rescal_sts1[0]) >> 13) & 0x1)
#define BCMI_MADURA_RESCAL_STS1r_O_VALIDf_SET(r,f) (r).rescal_sts1[0]=(((r).rescal_sts1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_RESCAL_STS1r_O_RESCAL_CTRL_DFSf_GET(r) (((r).rescal_sts1[0]) & 0x1fff)
#define BCMI_MADURA_RESCAL_STS1r_O_RESCAL_CTRL_DFSf_SET(r,f) (r).rescal_sts1[0]=(((r).rescal_sts1[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RESCAL_STS1.
 */
#define BCMI_MADURA_READ_RESCAL_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RESCAL_STS1r,_r._rescal_sts1)
#define BCMI_MADURA_WRITE_RESCAL_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RESCAL_STS1r,_r._rescal_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RESCAL_STS1r BCMI_MADURA_RESCAL_STS1r
#define RESCAL_STS1r_SIZE BCMI_MADURA_RESCAL_STS1r_SIZE
typedef BCMI_MADURA_RESCAL_STS1r_t RESCAL_STS1r_t;
#define RESCAL_STS1r_CLR BCMI_MADURA_RESCAL_STS1r_CLR
#define RESCAL_STS1r_SET BCMI_MADURA_RESCAL_STS1r_SET
#define RESCAL_STS1r_GET BCMI_MADURA_RESCAL_STS1r_GET
#define RESCAL_STS1r_O_VALIDf_GET BCMI_MADURA_RESCAL_STS1r_O_VALIDf_GET
#define RESCAL_STS1r_O_VALIDf_SET BCMI_MADURA_RESCAL_STS1r_O_VALIDf_SET
#define RESCAL_STS1r_O_RESCAL_CTRL_DFSf_GET BCMI_MADURA_RESCAL_STS1r_O_RESCAL_CTRL_DFSf_GET
#define RESCAL_STS1r_O_RESCAL_CTRL_DFSf_SET BCMI_MADURA_RESCAL_STS1r_O_RESCAL_CTRL_DFSf_SET
#define READ_RESCAL_STS1r BCMI_MADURA_READ_RESCAL_STS1r
#define WRITE_RESCAL_STS1r BCMI_MADURA_WRITE_RESCAL_STS1r
#define MODIFY_RESCAL_STS1r BCMI_MADURA_MODIFY_RESCAL_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RESCAL_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RESCAL_STS2
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8149
 * DEVAD:    1
 * DESC:     status register-2 holds various debug signals
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     O_RESCAL_STATE   This displays the default values of the rescal controls
 *     O_RESCALCOMP     used for debug purposes
 *     O_PREV_COMP_CNT  This used for debug purpose, if needed
 *     O_CURR_COMP_CNT  This used for debug purpose, if needed
 */
#define BCMI_MADURA_RESCAL_STS2r (0x00018149 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RESCAL_STS2r_SIZE 4

/*
 * This structure should be used to declare and program RESCAL_STS2.
 */
typedef union BCMI_MADURA_RESCAL_STS2r_s {
	uint32_t v[1];
	uint32_t rescal_sts2[1];
	uint32_t _rescal_sts2;
} BCMI_MADURA_RESCAL_STS2r_t;

#define BCMI_MADURA_RESCAL_STS2r_CLR(r) (r).rescal_sts2[0] = 0
#define BCMI_MADURA_RESCAL_STS2r_SET(r,d) (r).rescal_sts2[0] = d
#define BCMI_MADURA_RESCAL_STS2r_GET(r) (r).rescal_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RESCAL_STS2r_O_CURR_COMP_CNTf_GET(r) ((((r).rescal_sts2[0]) >> 8) & 0x3f)
#define BCMI_MADURA_RESCAL_STS2r_O_CURR_COMP_CNTf_SET(r,f) (r).rescal_sts2[0]=(((r).rescal_sts2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_RESCAL_STS2r_O_PREV_COMP_CNTf_GET(r) ((((r).rescal_sts2[0]) >> 4) & 0xf)
#define BCMI_MADURA_RESCAL_STS2r_O_PREV_COMP_CNTf_SET(r,f) (r).rescal_sts2[0]=(((r).rescal_sts2[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_RESCAL_STS2r_O_RESCALCOMPf_GET(r) ((((r).rescal_sts2[0]) >> 3) & 0x1)
#define BCMI_MADURA_RESCAL_STS2r_O_RESCALCOMPf_SET(r,f) (r).rescal_sts2[0]=(((r).rescal_sts2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_RESCAL_STS2r_O_RESCAL_STATEf_GET(r) (((r).rescal_sts2[0]) & 0x7)
#define BCMI_MADURA_RESCAL_STS2r_O_RESCAL_STATEf_SET(r,f) (r).rescal_sts2[0]=(((r).rescal_sts2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RESCAL_STS2.
 */
#define BCMI_MADURA_READ_RESCAL_STS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RESCAL_STS2r,_r._rescal_sts2)
#define BCMI_MADURA_WRITE_RESCAL_STS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RESCAL_STS2r,_r._rescal_sts2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RESCAL_STS2r BCMI_MADURA_RESCAL_STS2r
#define RESCAL_STS2r_SIZE BCMI_MADURA_RESCAL_STS2r_SIZE
typedef BCMI_MADURA_RESCAL_STS2r_t RESCAL_STS2r_t;
#define RESCAL_STS2r_CLR BCMI_MADURA_RESCAL_STS2r_CLR
#define RESCAL_STS2r_SET BCMI_MADURA_RESCAL_STS2r_SET
#define RESCAL_STS2r_GET BCMI_MADURA_RESCAL_STS2r_GET
#define RESCAL_STS2r_O_CURR_COMP_CNTf_GET BCMI_MADURA_RESCAL_STS2r_O_CURR_COMP_CNTf_GET
#define RESCAL_STS2r_O_CURR_COMP_CNTf_SET BCMI_MADURA_RESCAL_STS2r_O_CURR_COMP_CNTf_SET
#define RESCAL_STS2r_O_PREV_COMP_CNTf_GET BCMI_MADURA_RESCAL_STS2r_O_PREV_COMP_CNTf_GET
#define RESCAL_STS2r_O_PREV_COMP_CNTf_SET BCMI_MADURA_RESCAL_STS2r_O_PREV_COMP_CNTf_SET
#define RESCAL_STS2r_O_RESCALCOMPf_GET BCMI_MADURA_RESCAL_STS2r_O_RESCALCOMPf_GET
#define RESCAL_STS2r_O_RESCALCOMPf_SET BCMI_MADURA_RESCAL_STS2r_O_RESCALCOMPf_SET
#define RESCAL_STS2r_O_RESCAL_STATEf_GET BCMI_MADURA_RESCAL_STS2r_O_RESCAL_STATEf_GET
#define RESCAL_STS2r_O_RESCAL_STATEf_SET BCMI_MADURA_RESCAL_STS2r_O_RESCAL_STATEf_SET
#define READ_RESCAL_STS2r BCMI_MADURA_READ_RESCAL_STS2r
#define WRITE_RESCAL_STS2r BCMI_MADURA_WRITE_RESCAL_STS2r
#define MODIFY_RESCAL_STS2r BCMI_MADURA_MODIFY_RESCAL_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RESCAL_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RESCAL_STS3
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8150
 * DEVAD:    1
 * DESC:     status register-3 holds result of rescal computation
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     O_PON            This displays the default values of the rescal controls
 *     O_DONE           1'b1: this indicates the pon bits are valid this a live status bit, 1'b0: pon bits being computed
 */
#define BCMI_MADURA_RESCAL_STS3r (0x00018150 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RESCAL_STS3r_SIZE 4

/*
 * This structure should be used to declare and program RESCAL_STS3.
 */
typedef union BCMI_MADURA_RESCAL_STS3r_s {
	uint32_t v[1];
	uint32_t rescal_sts3[1];
	uint32_t _rescal_sts3;
} BCMI_MADURA_RESCAL_STS3r_t;

#define BCMI_MADURA_RESCAL_STS3r_CLR(r) (r).rescal_sts3[0] = 0
#define BCMI_MADURA_RESCAL_STS3r_SET(r,d) (r).rescal_sts3[0] = d
#define BCMI_MADURA_RESCAL_STS3r_GET(r) (r).rescal_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RESCAL_STS3r_O_DONEf_GET(r) ((((r).rescal_sts3[0]) >> 4) & 0x1)
#define BCMI_MADURA_RESCAL_STS3r_O_DONEf_SET(r,f) (r).rescal_sts3[0]=(((r).rescal_sts3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_RESCAL_STS3r_O_PONf_GET(r) (((r).rescal_sts3[0]) & 0xf)
#define BCMI_MADURA_RESCAL_STS3r_O_PONf_SET(r,f) (r).rescal_sts3[0]=(((r).rescal_sts3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RESCAL_STS3.
 */
#define BCMI_MADURA_READ_RESCAL_STS3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RESCAL_STS3r,_r._rescal_sts3)
#define BCMI_MADURA_WRITE_RESCAL_STS3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RESCAL_STS3r,_r._rescal_sts3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RESCAL_STS3r BCMI_MADURA_RESCAL_STS3r
#define RESCAL_STS3r_SIZE BCMI_MADURA_RESCAL_STS3r_SIZE
typedef BCMI_MADURA_RESCAL_STS3r_t RESCAL_STS3r_t;
#define RESCAL_STS3r_CLR BCMI_MADURA_RESCAL_STS3r_CLR
#define RESCAL_STS3r_SET BCMI_MADURA_RESCAL_STS3r_SET
#define RESCAL_STS3r_GET BCMI_MADURA_RESCAL_STS3r_GET
#define RESCAL_STS3r_O_DONEf_GET BCMI_MADURA_RESCAL_STS3r_O_DONEf_GET
#define RESCAL_STS3r_O_DONEf_SET BCMI_MADURA_RESCAL_STS3r_O_DONEf_SET
#define RESCAL_STS3r_O_PONf_GET BCMI_MADURA_RESCAL_STS3r_O_PONf_GET
#define RESCAL_STS3r_O_PONf_SET BCMI_MADURA_RESCAL_STS3r_O_PONf_SET
#define READ_RESCAL_STS3r BCMI_MADURA_READ_RESCAL_STS3r
#define WRITE_RESCAL_STS3r BCMI_MADURA_WRITE_RESCAL_STS3r
#define MODIFY_RESCAL_STS3r BCMI_MADURA_MODIFY_RESCAL_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RESCAL_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RESCAL_CTL0
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8151
 * DEVAD:    1
 * DESC:     control register for the rescal block
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_RESCAL_CTRL    The is resistor based process calibration control register
 */
#define BCMI_MADURA_RESCAL_CTL0r (0x00018151 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RESCAL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RESCAL_CTL0.
 */
typedef union BCMI_MADURA_RESCAL_CTL0r_s {
	uint32_t v[1];
	uint32_t rescal_ctl0[1];
	uint32_t _rescal_ctl0;
} BCMI_MADURA_RESCAL_CTL0r_t;

#define BCMI_MADURA_RESCAL_CTL0r_CLR(r) (r).rescal_ctl0[0] = 0
#define BCMI_MADURA_RESCAL_CTL0r_SET(r,d) (r).rescal_ctl0[0] = d
#define BCMI_MADURA_RESCAL_CTL0r_GET(r) (r).rescal_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RESCAL_CTL0r_I_RESCAL_CTRLf_GET(r) (((r).rescal_ctl0[0]) & 0x1fff)
#define BCMI_MADURA_RESCAL_CTL0r_I_RESCAL_CTRLf_SET(r,f) (r).rescal_ctl0[0]=(((r).rescal_ctl0[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RESCAL_CTL0.
 */
#define BCMI_MADURA_READ_RESCAL_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RESCAL_CTL0r,_r._rescal_ctl0)
#define BCMI_MADURA_WRITE_RESCAL_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RESCAL_CTL0r,_r._rescal_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RESCAL_CTL0r BCMI_MADURA_RESCAL_CTL0r
#define RESCAL_CTL0r_SIZE BCMI_MADURA_RESCAL_CTL0r_SIZE
typedef BCMI_MADURA_RESCAL_CTL0r_t RESCAL_CTL0r_t;
#define RESCAL_CTL0r_CLR BCMI_MADURA_RESCAL_CTL0r_CLR
#define RESCAL_CTL0r_SET BCMI_MADURA_RESCAL_CTL0r_SET
#define RESCAL_CTL0r_GET BCMI_MADURA_RESCAL_CTL0r_GET
#define RESCAL_CTL0r_I_RESCAL_CTRLf_GET BCMI_MADURA_RESCAL_CTL0r_I_RESCAL_CTRLf_GET
#define RESCAL_CTL0r_I_RESCAL_CTRLf_SET BCMI_MADURA_RESCAL_CTL0r_I_RESCAL_CTRLf_SET
#define READ_RESCAL_CTL0r BCMI_MADURA_READ_RESCAL_CTL0r
#define WRITE_RESCAL_CTL0r BCMI_MADURA_WRITE_RESCAL_CTL0r
#define MODIFY_RESCAL_CTL0r BCMI_MADURA_MODIFY_RESCAL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RESCAL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RESCAL_CTL1
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8152
 * DEVAD:    1
 * DESC:     control register for the rescal block
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     I_PWRDN          This signal should be toggled from one to zero to start the process calibration
 *     I_DIAG_ON        1'b1: freeze the internal digital operation, 1'b0: normal operation
 */
#define BCMI_MADURA_RESCAL_CTL1r (0x00018152 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RESCAL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program RESCAL_CTL1.
 */
typedef union BCMI_MADURA_RESCAL_CTL1r_s {
	uint32_t v[1];
	uint32_t rescal_ctl1[1];
	uint32_t _rescal_ctl1;
} BCMI_MADURA_RESCAL_CTL1r_t;

#define BCMI_MADURA_RESCAL_CTL1r_CLR(r) (r).rescal_ctl1[0] = 0
#define BCMI_MADURA_RESCAL_CTL1r_SET(r,d) (r).rescal_ctl1[0] = d
#define BCMI_MADURA_RESCAL_CTL1r_GET(r) (r).rescal_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RESCAL_CTL1r_I_DIAG_ONf_GET(r) ((((r).rescal_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_RESCAL_CTL1r_I_DIAG_ONf_SET(r,f) (r).rescal_ctl1[0]=(((r).rescal_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_RESCAL_CTL1r_I_PWRDNf_GET(r) (((r).rescal_ctl1[0]) & 0x1)
#define BCMI_MADURA_RESCAL_CTL1r_I_PWRDNf_SET(r,f) (r).rescal_ctl1[0]=(((r).rescal_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RESCAL_CTL1.
 */
#define BCMI_MADURA_READ_RESCAL_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RESCAL_CTL1r,_r._rescal_ctl1)
#define BCMI_MADURA_WRITE_RESCAL_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RESCAL_CTL1r,_r._rescal_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RESCAL_CTL1r BCMI_MADURA_RESCAL_CTL1r
#define RESCAL_CTL1r_SIZE BCMI_MADURA_RESCAL_CTL1r_SIZE
typedef BCMI_MADURA_RESCAL_CTL1r_t RESCAL_CTL1r_t;
#define RESCAL_CTL1r_CLR BCMI_MADURA_RESCAL_CTL1r_CLR
#define RESCAL_CTL1r_SET BCMI_MADURA_RESCAL_CTL1r_SET
#define RESCAL_CTL1r_GET BCMI_MADURA_RESCAL_CTL1r_GET
#define RESCAL_CTL1r_I_DIAG_ONf_GET BCMI_MADURA_RESCAL_CTL1r_I_DIAG_ONf_GET
#define RESCAL_CTL1r_I_DIAG_ONf_SET BCMI_MADURA_RESCAL_CTL1r_I_DIAG_ONf_SET
#define RESCAL_CTL1r_I_PWRDNf_GET BCMI_MADURA_RESCAL_CTL1r_I_PWRDNf_GET
#define RESCAL_CTL1r_I_PWRDNf_SET BCMI_MADURA_RESCAL_CTL1r_I_PWRDNf_SET
#define READ_RESCAL_CTL1r BCMI_MADURA_READ_RESCAL_CTL1r
#define WRITE_RESCAL_CTL1r BCMI_MADURA_WRITE_RESCAL_CTL1r
#define MODIFY_RESCAL_CTL1r BCMI_MADURA_MODIFY_RESCAL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RESCAL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LIB_ROSC_EN_CTL
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8153
 * DEVAD:    1
 * DESC:     ring oscillaor enable controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ROSC_EN          Connects to LIB Ring Osc En[11:0]
 */
#define BCMI_MADURA_LIB_ROSC_EN_CTLr (0x00018153 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LIB_ROSC_EN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LIB_ROSC_EN_CTL.
 */
typedef union BCMI_MADURA_LIB_ROSC_EN_CTLr_s {
	uint32_t v[1];
	uint32_t lib_rosc_en_ctl[1];
	uint32_t _lib_rosc_en_ctl;
} BCMI_MADURA_LIB_ROSC_EN_CTLr_t;

#define BCMI_MADURA_LIB_ROSC_EN_CTLr_CLR(r) (r).lib_rosc_en_ctl[0] = 0
#define BCMI_MADURA_LIB_ROSC_EN_CTLr_SET(r,d) (r).lib_rosc_en_ctl[0] = d
#define BCMI_MADURA_LIB_ROSC_EN_CTLr_GET(r) (r).lib_rosc_en_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LIB_ROSC_EN_CTLr_ROSC_ENf_GET(r) (((r).lib_rosc_en_ctl[0]) & 0xfff)
#define BCMI_MADURA_LIB_ROSC_EN_CTLr_ROSC_ENf_SET(r,f) (r).lib_rosc_en_ctl[0]=(((r).lib_rosc_en_ctl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access LIB_ROSC_EN_CTL.
 */
#define BCMI_MADURA_READ_LIB_ROSC_EN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LIB_ROSC_EN_CTLr,_r._lib_rosc_en_ctl)
#define BCMI_MADURA_WRITE_LIB_ROSC_EN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LIB_ROSC_EN_CTLr,_r._lib_rosc_en_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LIB_ROSC_EN_CTLr BCMI_MADURA_LIB_ROSC_EN_CTLr
#define LIB_ROSC_EN_CTLr_SIZE BCMI_MADURA_LIB_ROSC_EN_CTLr_SIZE
typedef BCMI_MADURA_LIB_ROSC_EN_CTLr_t LIB_ROSC_EN_CTLr_t;
#define LIB_ROSC_EN_CTLr_CLR BCMI_MADURA_LIB_ROSC_EN_CTLr_CLR
#define LIB_ROSC_EN_CTLr_SET BCMI_MADURA_LIB_ROSC_EN_CTLr_SET
#define LIB_ROSC_EN_CTLr_GET BCMI_MADURA_LIB_ROSC_EN_CTLr_GET
#define LIB_ROSC_EN_CTLr_ROSC_ENf_GET BCMI_MADURA_LIB_ROSC_EN_CTLr_ROSC_ENf_GET
#define LIB_ROSC_EN_CTLr_ROSC_ENf_SET BCMI_MADURA_LIB_ROSC_EN_CTLr_ROSC_ENf_SET
#define READ_LIB_ROSC_EN_CTLr BCMI_MADURA_READ_LIB_ROSC_EN_CTLr
#define WRITE_LIB_ROSC_EN_CTLr BCMI_MADURA_WRITE_LIB_ROSC_EN_CTLr
#define MODIFY_LIB_ROSC_EN_CTLr BCMI_MADURA_MODIFY_LIB_ROSC_EN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LIB_ROSC_EN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LIB_ROSC_SEL_CTL
 * BLOCKS:   HARD_IPS
 * REGADDR:  0x8154
 * DEVAD:    1
 * DESC:     ring oscillaor sel controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ROSC_SEL         Connects to LIB Ring Osc Sel[11:0]
 */
#define BCMI_MADURA_LIB_ROSC_SEL_CTLr (0x00018154 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LIB_ROSC_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LIB_ROSC_SEL_CTL.
 */
typedef union BCMI_MADURA_LIB_ROSC_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t lib_rosc_sel_ctl[1];
	uint32_t _lib_rosc_sel_ctl;
} BCMI_MADURA_LIB_ROSC_SEL_CTLr_t;

#define BCMI_MADURA_LIB_ROSC_SEL_CTLr_CLR(r) (r).lib_rosc_sel_ctl[0] = 0
#define BCMI_MADURA_LIB_ROSC_SEL_CTLr_SET(r,d) (r).lib_rosc_sel_ctl[0] = d
#define BCMI_MADURA_LIB_ROSC_SEL_CTLr_GET(r) (r).lib_rosc_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LIB_ROSC_SEL_CTLr_ROSC_SELf_GET(r) (((r).lib_rosc_sel_ctl[0]) & 0xfff)
#define BCMI_MADURA_LIB_ROSC_SEL_CTLr_ROSC_SELf_SET(r,f) (r).lib_rosc_sel_ctl[0]=(((r).lib_rosc_sel_ctl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access LIB_ROSC_SEL_CTL.
 */
#define BCMI_MADURA_READ_LIB_ROSC_SEL_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LIB_ROSC_SEL_CTLr,_r._lib_rosc_sel_ctl)
#define BCMI_MADURA_WRITE_LIB_ROSC_SEL_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LIB_ROSC_SEL_CTLr,_r._lib_rosc_sel_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LIB_ROSC_SEL_CTLr BCMI_MADURA_LIB_ROSC_SEL_CTLr
#define LIB_ROSC_SEL_CTLr_SIZE BCMI_MADURA_LIB_ROSC_SEL_CTLr_SIZE
typedef BCMI_MADURA_LIB_ROSC_SEL_CTLr_t LIB_ROSC_SEL_CTLr_t;
#define LIB_ROSC_SEL_CTLr_CLR BCMI_MADURA_LIB_ROSC_SEL_CTLr_CLR
#define LIB_ROSC_SEL_CTLr_SET BCMI_MADURA_LIB_ROSC_SEL_CTLr_SET
#define LIB_ROSC_SEL_CTLr_GET BCMI_MADURA_LIB_ROSC_SEL_CTLr_GET
#define LIB_ROSC_SEL_CTLr_ROSC_SELf_GET BCMI_MADURA_LIB_ROSC_SEL_CTLr_ROSC_SELf_GET
#define LIB_ROSC_SEL_CTLr_ROSC_SELf_SET BCMI_MADURA_LIB_ROSC_SEL_CTLr_ROSC_SELf_SET
#define READ_LIB_ROSC_SEL_CTLr BCMI_MADURA_READ_LIB_ROSC_SEL_CTLr
#define WRITE_LIB_ROSC_SEL_CTLr BCMI_MADURA_WRITE_LIB_ROSC_SEL_CTLr
#define MODIFY_LIB_ROSC_SEL_CTLr BCMI_MADURA_MODIFY_LIB_ROSC_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LIB_ROSC_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CLK_SCALER_CTL
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8200
 * DEVAD:    1
 * DESC:     main clock and reset control
 * RESETVAL: 0x800 (2048)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCK_SCALER_RATIO com_ck/uc_ck (input) clock scaler ratioBits 11:8 are the integer portion of the ratio.Bits 7:0 are the decimal portion of the ratio.Here are some examples.<IMG SRC="clock_scaler.gif">
 */
#define BCMI_MADURA_CLK_SCALER_CTLr (0x00018200 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CLK_SCALER_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CLK_SCALER_CTL.
 */
typedef union BCMI_MADURA_CLK_SCALER_CTLr_s {
	uint32_t v[1];
	uint32_t clk_scaler_ctl[1];
	uint32_t _clk_scaler_ctl;
} BCMI_MADURA_CLK_SCALER_CTLr_t;

#define BCMI_MADURA_CLK_SCALER_CTLr_CLR(r) (r).clk_scaler_ctl[0] = 0
#define BCMI_MADURA_CLK_SCALER_CTLr_SET(r,d) (r).clk_scaler_ctl[0] = d
#define BCMI_MADURA_CLK_SCALER_CTLr_GET(r) (r).clk_scaler_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CLK_SCALER_CTLr_CLOCK_SCALER_RATIOf_GET(r) (((r).clk_scaler_ctl[0]) & 0xfff)
#define BCMI_MADURA_CLK_SCALER_CTLr_CLOCK_SCALER_RATIOf_SET(r,f) (r).clk_scaler_ctl[0]=(((r).clk_scaler_ctl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access CLK_SCALER_CTL.
 */
#define BCMI_MADURA_READ_CLK_SCALER_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CLK_SCALER_CTLr,_r._clk_scaler_ctl)
#define BCMI_MADURA_WRITE_CLK_SCALER_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CLK_SCALER_CTLr,_r._clk_scaler_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CLK_SCALER_CTLr BCMI_MADURA_CLK_SCALER_CTLr
#define CLK_SCALER_CTLr_SIZE BCMI_MADURA_CLK_SCALER_CTLr_SIZE
typedef BCMI_MADURA_CLK_SCALER_CTLr_t CLK_SCALER_CTLr_t;
#define CLK_SCALER_CTLr_CLR BCMI_MADURA_CLK_SCALER_CTLr_CLR
#define CLK_SCALER_CTLr_SET BCMI_MADURA_CLK_SCALER_CTLr_SET
#define CLK_SCALER_CTLr_GET BCMI_MADURA_CLK_SCALER_CTLr_GET
#define CLK_SCALER_CTLr_CLOCK_SCALER_RATIOf_GET BCMI_MADURA_CLK_SCALER_CTLr_CLOCK_SCALER_RATIOf_GET
#define CLK_SCALER_CTLr_CLOCK_SCALER_RATIOf_SET BCMI_MADURA_CLK_SCALER_CTLr_CLOCK_SCALER_RATIOf_SET
#define READ_CLK_SCALER_CTLr BCMI_MADURA_READ_CLK_SCALER_CTLr
#define WRITE_CLK_SCALER_CTLr BCMI_MADURA_WRITE_CLK_SCALER_CTLr
#define MODIFY_CLK_SCALER_CTLr BCMI_MADURA_MODIFY_CLK_SCALER_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CLK_SCALER_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GEN_CTL1
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8201
 * DEVAD:    1
 * DESC:     General control register 1.
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     RESETB           Hard reset (Active low).This is the main hard reset for the chip.When programmed to 0 this will reset the entire chip including registers.This is a self clearing bit.
 *     REG_RSTB         Register reset (Active low).This will reset all the configuration registers in the entire chip including Digital, Analog and Core21 IP.This is a self clearing bit.
 *     MODCTRL_RSTB     Module Controller reset. Active low.
 */
#define BCMI_MADURA_GEN_CTL1r (0x00018201 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GEN_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program GEN_CTL1.
 */
typedef union BCMI_MADURA_GEN_CTL1r_s {
	uint32_t v[1];
	uint32_t gen_ctl1[1];
	uint32_t _gen_ctl1;
} BCMI_MADURA_GEN_CTL1r_t;

#define BCMI_MADURA_GEN_CTL1r_CLR(r) (r).gen_ctl1[0] = 0
#define BCMI_MADURA_GEN_CTL1r_SET(r,d) (r).gen_ctl1[0] = d
#define BCMI_MADURA_GEN_CTL1r_GET(r) (r).gen_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GEN_CTL1r_MODCTRL_RSTBf_GET(r) ((((r).gen_ctl1[0]) >> 6) & 0x1)
#define BCMI_MADURA_GEN_CTL1r_MODCTRL_RSTBf_SET(r,f) (r).gen_ctl1[0]=(((r).gen_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_GEN_CTL1r_REG_RSTBf_GET(r) ((((r).gen_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_GEN_CTL1r_REG_RSTBf_SET(r,f) (r).gen_ctl1[0]=(((r).gen_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GEN_CTL1r_RESETBf_GET(r) (((r).gen_ctl1[0]) & 0x1)
#define BCMI_MADURA_GEN_CTL1r_RESETBf_SET(r,f) (r).gen_ctl1[0]=(((r).gen_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GEN_CTL1.
 */
#define BCMI_MADURA_READ_GEN_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GEN_CTL1r,_r._gen_ctl1)
#define BCMI_MADURA_WRITE_GEN_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GEN_CTL1r,_r._gen_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GEN_CTL1r BCMI_MADURA_GEN_CTL1r
#define GEN_CTL1r_SIZE BCMI_MADURA_GEN_CTL1r_SIZE
typedef BCMI_MADURA_GEN_CTL1r_t GEN_CTL1r_t;
#define GEN_CTL1r_CLR BCMI_MADURA_GEN_CTL1r_CLR
#define GEN_CTL1r_SET BCMI_MADURA_GEN_CTL1r_SET
#define GEN_CTL1r_GET BCMI_MADURA_GEN_CTL1r_GET
#define GEN_CTL1r_MODCTRL_RSTBf_GET BCMI_MADURA_GEN_CTL1r_MODCTRL_RSTBf_GET
#define GEN_CTL1r_MODCTRL_RSTBf_SET BCMI_MADURA_GEN_CTL1r_MODCTRL_RSTBf_SET
#define GEN_CTL1r_REG_RSTBf_GET BCMI_MADURA_GEN_CTL1r_REG_RSTBf_GET
#define GEN_CTL1r_REG_RSTBf_SET BCMI_MADURA_GEN_CTL1r_REG_RSTBf_SET
#define GEN_CTL1r_RESETBf_GET BCMI_MADURA_GEN_CTL1r_RESETBf_GET
#define GEN_CTL1r_RESETBf_SET BCMI_MADURA_GEN_CTL1r_RESETBf_SET
#define READ_GEN_CTL1r BCMI_MADURA_READ_GEN_CTL1r
#define WRITE_GEN_CTL1r BCMI_MADURA_WRITE_GEN_CTL1r
#define MODIFY_GEN_CTL1r BCMI_MADURA_MODIFY_GEN_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GEN_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GEN_CTL2
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8202
 * DEVAD:    1
 * DESC:     General control register 2.
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_RSTB         Reset for Master M0 micro (Active low).
 *     MST_UCP_RSTB     Reset for Master M0 micro peripherals(Active low).
 */
#define BCMI_MADURA_GEN_CTL2r (0x00018202 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GEN_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program GEN_CTL2.
 */
typedef union BCMI_MADURA_GEN_CTL2r_s {
	uint32_t v[1];
	uint32_t gen_ctl2[1];
	uint32_t _gen_ctl2;
} BCMI_MADURA_GEN_CTL2r_t;

#define BCMI_MADURA_GEN_CTL2r_CLR(r) (r).gen_ctl2[0] = 0
#define BCMI_MADURA_GEN_CTL2r_SET(r,d) (r).gen_ctl2[0] = d
#define BCMI_MADURA_GEN_CTL2r_GET(r) (r).gen_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GEN_CTL2r_MST_UCP_RSTBf_GET(r) ((((r).gen_ctl2[0]) >> 1) & 0x1)
#define BCMI_MADURA_GEN_CTL2r_MST_UCP_RSTBf_SET(r,f) (r).gen_ctl2[0]=(((r).gen_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GEN_CTL2r_MST_RSTBf_GET(r) (((r).gen_ctl2[0]) & 0x1)
#define BCMI_MADURA_GEN_CTL2r_MST_RSTBf_SET(r,f) (r).gen_ctl2[0]=(((r).gen_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)
#define BCMI_MADURA_GEN_CTL2r_SPI2X_RSTBf_SET(r,f) (r).gen_ctl2[0]=(((r).gen_ctl2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 1))
#define BCMI_MADURA_GEN_CTL2r_SPI_RSTBf_SET(r,f) (r).gen_ctl2[0]=(((r).gen_ctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 1))

/*
 * These macros can be used to access GEN_CTL2.
 */
#define BCMI_MADURA_READ_GEN_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GEN_CTL2r,_r._gen_ctl2)
#define BCMI_MADURA_WRITE_GEN_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GEN_CTL2r,_r._gen_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GEN_CTL2r BCMI_MADURA_GEN_CTL2r
#define GEN_CTL2r_SIZE BCMI_MADURA_GEN_CTL2r_SIZE
typedef BCMI_MADURA_GEN_CTL2r_t GEN_CTL2r_t;
#define GEN_CTL2r_CLR BCMI_MADURA_GEN_CTL2r_CLR
#define GEN_CTL2r_SET BCMI_MADURA_GEN_CTL2r_SET
#define GEN_CTL2r_GET BCMI_MADURA_GEN_CTL2r_GET
#define GEN_CTL2r_MST_UCP_RSTBf_GET BCMI_MADURA_GEN_CTL2r_MST_UCP_RSTBf_GET
#define GEN_CTL2r_MST_UCP_RSTBf_SET BCMI_MADURA_GEN_CTL2r_MST_UCP_RSTBf_SET
#define GEN_CTL2r_MST_RSTBf_GET BCMI_MADURA_GEN_CTL2r_MST_RSTBf_GET
#define GEN_CTL2r_MST_RSTBf_SET BCMI_MADURA_GEN_CTL2r_MST_RSTBf_SET
#define READ_GEN_CTL2r BCMI_MADURA_READ_GEN_CTL2r
#define WRITE_GEN_CTL2r BCMI_MADURA_WRITE_GEN_CTL2r
#define MODIFY_GEN_CTL2r BCMI_MADURA_MODIFY_GEN_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GEN_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GEN_CTL3
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8203
 * DEVAD:    1
 * DESC:     General control register 3.
 * RESETVAL: 0x3200 (12800)
 * ACCESS:   R/W
 * FIELDS:
 *     QSFP_MODE        Used QSFP+ module controller instead of Legacy Gallerado controller
 *     UCSPI_SLOW       Selects the SPIROM and pvtmon_ck clock frequency.1'b1 --> Approximatley 2Mhz;1'b0 --> Approximatley 4Mhz;
 *     QSFP_SEL0B       Active Low Select to read NVRAM for QSFP module 0Do not ever set qsfp_sel0b and qsfp_sel1b both to 0
 *     QSFP_SEL1B       Active Low Select to read NVRAM for QSFP module 1Do not ever set qsfp_sel0b and qsfp_sel1b both to 0
 */
#define BCMI_MADURA_GEN_CTL3r (0x00018203 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GEN_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program GEN_CTL3.
 */
typedef union BCMI_MADURA_GEN_CTL3r_s {
	uint32_t v[1];
	uint32_t gen_ctl3[1];
	uint32_t _gen_ctl3;
} BCMI_MADURA_GEN_CTL3r_t;

#define BCMI_MADURA_GEN_CTL3r_CLR(r) (r).gen_ctl3[0] = 0
#define BCMI_MADURA_GEN_CTL3r_SET(r,d) (r).gen_ctl3[0] = d
#define BCMI_MADURA_GEN_CTL3r_GET(r) (r).gen_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GEN_CTL3r_QSFP_SEL1Bf_GET(r) ((((r).gen_ctl3[0]) >> 13) & 0x1)
#define BCMI_MADURA_GEN_CTL3r_QSFP_SEL1Bf_SET(r,f) (r).gen_ctl3[0]=(((r).gen_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_GEN_CTL3r_QSFP_SEL0Bf_GET(r) ((((r).gen_ctl3[0]) >> 12) & 0x1)
#define BCMI_MADURA_GEN_CTL3r_QSFP_SEL0Bf_SET(r,f) (r).gen_ctl3[0]=(((r).gen_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_GEN_CTL3r_UCSPI_SLOWf_GET(r) ((((r).gen_ctl3[0]) >> 9) & 0x1)
#define BCMI_MADURA_GEN_CTL3r_UCSPI_SLOWf_SET(r,f) (r).gen_ctl3[0]=(((r).gen_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_GEN_CTL3r_QSFP_MODEf_GET(r) (((r).gen_ctl3[0]) & 0x1)
#define BCMI_MADURA_GEN_CTL3r_QSFP_MODEf_SET(r,f) (r).gen_ctl3[0]=(((r).gen_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GEN_CTL3.
 */
#define BCMI_MADURA_READ_GEN_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GEN_CTL3r,_r._gen_ctl3)
#define BCMI_MADURA_WRITE_GEN_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GEN_CTL3r,_r._gen_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GEN_CTL3r BCMI_MADURA_GEN_CTL3r
#define GEN_CTL3r_SIZE BCMI_MADURA_GEN_CTL3r_SIZE
typedef BCMI_MADURA_GEN_CTL3r_t GEN_CTL3r_t;
#define GEN_CTL3r_CLR BCMI_MADURA_GEN_CTL3r_CLR
#define GEN_CTL3r_SET BCMI_MADURA_GEN_CTL3r_SET
#define GEN_CTL3r_GET BCMI_MADURA_GEN_CTL3r_GET
#define GEN_CTL3r_QSFP_SEL1Bf_GET BCMI_MADURA_GEN_CTL3r_QSFP_SEL1Bf_GET
#define GEN_CTL3r_QSFP_SEL1Bf_SET BCMI_MADURA_GEN_CTL3r_QSFP_SEL1Bf_SET
#define GEN_CTL3r_QSFP_SEL0Bf_GET BCMI_MADURA_GEN_CTL3r_QSFP_SEL0Bf_GET
#define GEN_CTL3r_QSFP_SEL0Bf_SET BCMI_MADURA_GEN_CTL3r_QSFP_SEL0Bf_SET
#define GEN_CTL3r_UCSPI_SLOWf_GET BCMI_MADURA_GEN_CTL3r_UCSPI_SLOWf_GET
#define GEN_CTL3r_UCSPI_SLOWf_SET BCMI_MADURA_GEN_CTL3r_UCSPI_SLOWf_SET
#define GEN_CTL3r_QSFP_MODEf_GET BCMI_MADURA_GEN_CTL3r_QSFP_MODEf_GET
#define GEN_CTL3r_QSFP_MODEf_SET BCMI_MADURA_GEN_CTL3r_QSFP_MODEf_SET
#define READ_GEN_CTL3r BCMI_MADURA_READ_GEN_CTL3r
#define WRITE_GEN_CTL3r BCMI_MADURA_WRITE_GEN_CTL3r
#define MODIFY_GEN_CTL3r BCMI_MADURA_MODIFY_GEN_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GEN_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_PHYAD_CTL
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8204
 * DEVAD:    1
 * DESC:     MDIO Phy Address Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BRDCST_EN   Enable MDIO broadcast
 *     MDIO_MULTI_EN    Enable multiple MDIOs
 *     MULTI_PORT_PHYAD Multiple port phy address
 */
#define BCMI_MADURA_MDIO_PHYAD_CTLr (0x00018204 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_PHYAD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_PHYAD_CTL.
 */
typedef union BCMI_MADURA_MDIO_PHYAD_CTLr_s {
	uint32_t v[1];
	uint32_t mdio_phyad_ctl[1];
	uint32_t _mdio_phyad_ctl;
} BCMI_MADURA_MDIO_PHYAD_CTLr_t;

#define BCMI_MADURA_MDIO_PHYAD_CTLr_CLR(r) (r).mdio_phyad_ctl[0] = 0
#define BCMI_MADURA_MDIO_PHYAD_CTLr_SET(r,d) (r).mdio_phyad_ctl[0] = d
#define BCMI_MADURA_MDIO_PHYAD_CTLr_GET(r) (r).mdio_phyad_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_PHYAD_CTLr_MULTI_PORT_PHYADf_GET(r) ((((r).mdio_phyad_ctl[0]) >> 2) & 0x1f)
#define BCMI_MADURA_MDIO_PHYAD_CTLr_MULTI_PORT_PHYADf_SET(r,f) (r).mdio_phyad_ctl[0]=(((r).mdio_phyad_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2)) | (31 << (16 + 2))
#define BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_MULTI_ENf_GET(r) ((((r).mdio_phyad_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_MULTI_ENf_SET(r,f) (r).mdio_phyad_ctl[0]=(((r).mdio_phyad_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_BRDCST_ENf_GET(r) (((r).mdio_phyad_ctl[0]) & 0x1)
#define BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_BRDCST_ENf_SET(r,f) (r).mdio_phyad_ctl[0]=(((r).mdio_phyad_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_PHYAD_CTL.
 */
#define BCMI_MADURA_READ_MDIO_PHYAD_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_PHYAD_CTLr,_r._mdio_phyad_ctl)
#define BCMI_MADURA_WRITE_MDIO_PHYAD_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_PHYAD_CTLr,_r._mdio_phyad_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_PHYAD_CTLr BCMI_MADURA_MDIO_PHYAD_CTLr
#define MDIO_PHYAD_CTLr_SIZE BCMI_MADURA_MDIO_PHYAD_CTLr_SIZE
typedef BCMI_MADURA_MDIO_PHYAD_CTLr_t MDIO_PHYAD_CTLr_t;
#define MDIO_PHYAD_CTLr_CLR BCMI_MADURA_MDIO_PHYAD_CTLr_CLR
#define MDIO_PHYAD_CTLr_SET BCMI_MADURA_MDIO_PHYAD_CTLr_SET
#define MDIO_PHYAD_CTLr_GET BCMI_MADURA_MDIO_PHYAD_CTLr_GET
#define MDIO_PHYAD_CTLr_MULTI_PORT_PHYADf_GET BCMI_MADURA_MDIO_PHYAD_CTLr_MULTI_PORT_PHYADf_GET
#define MDIO_PHYAD_CTLr_MULTI_PORT_PHYADf_SET BCMI_MADURA_MDIO_PHYAD_CTLr_MULTI_PORT_PHYADf_SET
#define MDIO_PHYAD_CTLr_MDIO_MULTI_ENf_GET BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_MULTI_ENf_GET
#define MDIO_PHYAD_CTLr_MDIO_MULTI_ENf_SET BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_MULTI_ENf_SET
#define MDIO_PHYAD_CTLr_MDIO_BRDCST_ENf_GET BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_BRDCST_ENf_GET
#define MDIO_PHYAD_CTLr_MDIO_BRDCST_ENf_SET BCMI_MADURA_MDIO_PHYAD_CTLr_MDIO_BRDCST_ENf_SET
#define READ_MDIO_PHYAD_CTLr BCMI_MADURA_READ_MDIO_PHYAD_CTLr
#define WRITE_MDIO_PHYAD_CTLr BCMI_MADURA_WRITE_MDIO_PHYAD_CTLr
#define MODIFY_MDIO_PHYAD_CTLr BCMI_MADURA_MODIFY_MDIO_PHYAD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_PHYAD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SPI_CODE_LOAD_EN
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8210
 * DEVAD:    1
 * DESC:     M0 SPI code load enable
 * RESETVAL: 0xf3 (243)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_CODE_DOWNLOAD_EN Setting this will enable loading of code into master code ram during SPI download. The start pointer needs to be programmed first. A rising edge on this signal"will initialize the start pointer".
 *     CODE_BROADCAST_EN Setting this will enable broadcast of code into all Falcon M0.
 *     SLV_CODE_DOWNLOAD_EN Setting this will enable loading of code into Falcon M0 code rambit 7:4 corresponding to slave 4:1slave 1: slice 0 system side Falconslave 2: slice 0 line side Falconslave 3: slice 1 system side Falconslave 4: slice 1 line side Falcon
 */
#define BCMI_MADURA_SPI_CODE_LOAD_ENr (0x00018210 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SPI_CODE_LOAD_ENr_SIZE 4

/*
 * This structure should be used to declare and program SPI_CODE_LOAD_EN.
 */
typedef union BCMI_MADURA_SPI_CODE_LOAD_ENr_s {
	uint32_t v[1];
	uint32_t spi_code_load_en[1];
	uint32_t _spi_code_load_en;
} BCMI_MADURA_SPI_CODE_LOAD_ENr_t;

#define BCMI_MADURA_SPI_CODE_LOAD_ENr_CLR(r) (r).spi_code_load_en[0] = 0
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_SET(r,d) (r).spi_code_load_en[0] = d
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_GET(r) (r).spi_code_load_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_SLV_CODE_DOWNLOAD_ENf_GET(r) ((((r).spi_code_load_en[0]) >> 4) & 0xf)
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_SLV_CODE_DOWNLOAD_ENf_SET(r,f) (r).spi_code_load_en[0]=(((r).spi_code_load_en[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_CODE_BROADCAST_ENf_GET(r) ((((r).spi_code_load_en[0]) >> 1) & 0x1)
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_CODE_BROADCAST_ENf_SET(r,f) (r).spi_code_load_en[0]=(((r).spi_code_load_en[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_MST_CODE_DOWNLOAD_ENf_GET(r) (((r).spi_code_load_en[0]) & 0x1)
#define BCMI_MADURA_SPI_CODE_LOAD_ENr_MST_CODE_DOWNLOAD_ENf_SET(r,f) (r).spi_code_load_en[0]=(((r).spi_code_load_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SPI_CODE_LOAD_EN.
 */
#define BCMI_MADURA_READ_SPI_CODE_LOAD_ENr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SPI_CODE_LOAD_ENr,_r._spi_code_load_en)
#define BCMI_MADURA_WRITE_SPI_CODE_LOAD_ENr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SPI_CODE_LOAD_ENr,_r._spi_code_load_en)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SPI_CODE_LOAD_ENr BCMI_MADURA_SPI_CODE_LOAD_ENr
#define SPI_CODE_LOAD_ENr_SIZE BCMI_MADURA_SPI_CODE_LOAD_ENr_SIZE
typedef BCMI_MADURA_SPI_CODE_LOAD_ENr_t SPI_CODE_LOAD_ENr_t;
#define SPI_CODE_LOAD_ENr_CLR BCMI_MADURA_SPI_CODE_LOAD_ENr_CLR
#define SPI_CODE_LOAD_ENr_SET BCMI_MADURA_SPI_CODE_LOAD_ENr_SET
#define SPI_CODE_LOAD_ENr_GET BCMI_MADURA_SPI_CODE_LOAD_ENr_GET
#define SPI_CODE_LOAD_ENr_SLV_CODE_DOWNLOAD_ENf_GET BCMI_MADURA_SPI_CODE_LOAD_ENr_SLV_CODE_DOWNLOAD_ENf_GET
#define SPI_CODE_LOAD_ENr_SLV_CODE_DOWNLOAD_ENf_SET BCMI_MADURA_SPI_CODE_LOAD_ENr_SLV_CODE_DOWNLOAD_ENf_SET
#define SPI_CODE_LOAD_ENr_CODE_BROADCAST_ENf_GET BCMI_MADURA_SPI_CODE_LOAD_ENr_CODE_BROADCAST_ENf_GET
#define SPI_CODE_LOAD_ENr_CODE_BROADCAST_ENf_SET BCMI_MADURA_SPI_CODE_LOAD_ENr_CODE_BROADCAST_ENf_SET
#define SPI_CODE_LOAD_ENr_MST_CODE_DOWNLOAD_ENf_GET BCMI_MADURA_SPI_CODE_LOAD_ENr_MST_CODE_DOWNLOAD_ENf_GET
#define SPI_CODE_LOAD_ENr_MST_CODE_DOWNLOAD_ENf_SET BCMI_MADURA_SPI_CODE_LOAD_ENr_MST_CODE_DOWNLOAD_ENf_SET
#define READ_SPI_CODE_LOAD_ENr BCMI_MADURA_READ_SPI_CODE_LOAD_ENr
#define WRITE_SPI_CODE_LOAD_ENr BCMI_MADURA_WRITE_SPI_CODE_LOAD_ENr
#define MODIFY_SPI_CODE_LOAD_ENr BCMI_MADURA_MODIFY_SPI_CODE_LOAD_ENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SPI_CODE_LOAD_ENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SPI_EEPROM_CTL0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8211
 * DEVAD:    1
 * DESC:     Offset and Count for EEPROM download
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_EEPROM_COUNT Number of 8KB pages to download from EEPROM for Master M0
 *     SPI_MST_OEB      Outputs of SPI master - mosi, ssn and sclk can be tristated when" not in use. 0 - outputs are enabled. 1 - Outputs are tristated".
 *     MST_EEPROM_OFFSET Offset into EEPROM from which to start downloading in units of 8KB pages for Master M0.
 */
#define BCMI_MADURA_SPI_EEPROM_CTL0r (0x00018211 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SPI_EEPROM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SPI_EEPROM_CTL0.
 */
typedef union BCMI_MADURA_SPI_EEPROM_CTL0r_s {
	uint32_t v[1];
	uint32_t spi_eeprom_ctl0[1];
	uint32_t _spi_eeprom_ctl0;
} BCMI_MADURA_SPI_EEPROM_CTL0r_t;

#define BCMI_MADURA_SPI_EEPROM_CTL0r_CLR(r) (r).spi_eeprom_ctl0[0] = 0
#define BCMI_MADURA_SPI_EEPROM_CTL0r_SET(r,d) (r).spi_eeprom_ctl0[0] = d
#define BCMI_MADURA_SPI_EEPROM_CTL0r_GET(r) (r).spi_eeprom_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_OFFSETf_GET(r) ((((r).spi_eeprom_ctl0[0]) >> 4) & 0xf)
#define BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_OFFSETf_SET(r,f) (r).spi_eeprom_ctl0[0]=(((r).spi_eeprom_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_SPI_EEPROM_CTL0r_SPI_MST_OEBf_GET(r) ((((r).spi_eeprom_ctl0[0]) >> 3) & 0x1)
#define BCMI_MADURA_SPI_EEPROM_CTL0r_SPI_MST_OEBf_SET(r,f) (r).spi_eeprom_ctl0[0]=(((r).spi_eeprom_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_COUNTf_GET(r) (((r).spi_eeprom_ctl0[0]) & 0x7)
#define BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_COUNTf_SET(r,f) (r).spi_eeprom_ctl0[0]=(((r).spi_eeprom_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SPI_EEPROM_CTL0.
 */
#define BCMI_MADURA_READ_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SPI_EEPROM_CTL0r,_r._spi_eeprom_ctl0)
#define BCMI_MADURA_WRITE_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SPI_EEPROM_CTL0r,_r._spi_eeprom_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SPI_EEPROM_CTL0r BCMI_MADURA_SPI_EEPROM_CTL0r
#define SPI_EEPROM_CTL0r_SIZE BCMI_MADURA_SPI_EEPROM_CTL0r_SIZE
typedef BCMI_MADURA_SPI_EEPROM_CTL0r_t SPI_EEPROM_CTL0r_t;
#define SPI_EEPROM_CTL0r_CLR BCMI_MADURA_SPI_EEPROM_CTL0r_CLR
#define SPI_EEPROM_CTL0r_SET BCMI_MADURA_SPI_EEPROM_CTL0r_SET
#define SPI_EEPROM_CTL0r_GET BCMI_MADURA_SPI_EEPROM_CTL0r_GET
#define SPI_EEPROM_CTL0r_MST_EEPROM_OFFSETf_GET BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_OFFSETf_GET
#define SPI_EEPROM_CTL0r_MST_EEPROM_OFFSETf_SET BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_OFFSETf_SET
#define SPI_EEPROM_CTL0r_SPI_MST_OEBf_GET BCMI_MADURA_SPI_EEPROM_CTL0r_SPI_MST_OEBf_GET
#define SPI_EEPROM_CTL0r_SPI_MST_OEBf_SET BCMI_MADURA_SPI_EEPROM_CTL0r_SPI_MST_OEBf_SET
#define SPI_EEPROM_CTL0r_MST_EEPROM_COUNTf_GET BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_COUNTf_GET
#define SPI_EEPROM_CTL0r_MST_EEPROM_COUNTf_SET BCMI_MADURA_SPI_EEPROM_CTL0r_MST_EEPROM_COUNTf_SET
#define READ_SPI_EEPROM_CTL0r BCMI_MADURA_READ_SPI_EEPROM_CTL0r
#define WRITE_SPI_EEPROM_CTL0r BCMI_MADURA_WRITE_SPI_EEPROM_CTL0r
#define MODIFY_SPI_EEPROM_CTL0r BCMI_MADURA_MODIFY_SPI_EEPROM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SPI_EEPROM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MSCR
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8212
 * DEVAD:    1
 * DESC:     Micro subsystem configuration register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     HRESP_MASK       When programmed to 0, HRESP signal going to M0 will be 0.When programmed to 1, HRESP issued by the peripherals will be seen by M0.
 *     GLOBAL_INTR_MASK Global interrupt mask
 */
#define BCMI_MADURA_MSCRr (0x00018212 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MSCRr_SIZE 4

/*
 * This structure should be used to declare and program MSCR.
 */
typedef union BCMI_MADURA_MSCRr_s {
	uint32_t v[1];
	uint32_t mscr[1];
	uint32_t _mscr;
} BCMI_MADURA_MSCRr_t;

#define BCMI_MADURA_MSCRr_CLR(r) (r).mscr[0] = 0
#define BCMI_MADURA_MSCRr_SET(r,d) (r).mscr[0] = d
#define BCMI_MADURA_MSCRr_GET(r) (r).mscr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MSCRr_GLOBAL_INTR_MASKf_GET(r) ((((r).mscr[0]) >> 15) & 0x1)
#define BCMI_MADURA_MSCRr_GLOBAL_INTR_MASKf_SET(r,f) (r).mscr[0]=(((r).mscr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_MSCRr_HRESP_MASKf_GET(r) ((((r).mscr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MSCRr_HRESP_MASKf_SET(r,f) (r).mscr[0]=(((r).mscr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access MSCR.
 */
#define BCMI_MADURA_READ_MSCRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MSCRr,_r._mscr)
#define BCMI_MADURA_WRITE_MSCRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MSCRr,_r._mscr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MSCRr BCMI_MADURA_MSCRr
#define MSCRr_SIZE BCMI_MADURA_MSCRr_SIZE
typedef BCMI_MADURA_MSCRr_t MSCRr_t;
#define MSCRr_CLR BCMI_MADURA_MSCRr_CLR
#define MSCRr_SET BCMI_MADURA_MSCRr_SET
#define MSCRr_GET BCMI_MADURA_MSCRr_GET
#define MSCRr_GLOBAL_INTR_MASKf_GET BCMI_MADURA_MSCRr_GLOBAL_INTR_MASKf_GET
#define MSCRr_GLOBAL_INTR_MASKf_SET BCMI_MADURA_MSCRr_GLOBAL_INTR_MASKf_SET
#define MSCRr_HRESP_MASKf_GET BCMI_MADURA_MSCRr_HRESP_MASKf_GET
#define MSCRr_HRESP_MASKf_SET BCMI_MADURA_MSCRr_HRESP_MASKf_SET
#define READ_MSCRr BCMI_MADURA_READ_MSCRr
#define WRITE_MSCRr BCMI_MADURA_WRITE_MSCRr
#define MODIFY_MSCRr BCMI_MADURA_MODIFY_MSCRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MSCRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BOOT
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8213
 * DEVAD:    1
 * DESC:     Flags about booting status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERBOOT_BUSY     micro sets this bit to indicate that serial boot is in progress
 *     SERBOOT_DONE_ONCE records that boot from SPI has been done once
 */
#define BCMI_MADURA_BOOTr (0x00018213 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BOOTr_SIZE 4

/*
 * This structure should be used to declare and program BOOT.
 */
typedef union BCMI_MADURA_BOOTr_s {
	uint32_t v[1];
	uint32_t boot[1];
	uint32_t _boot;
} BCMI_MADURA_BOOTr_t;

#define BCMI_MADURA_BOOTr_CLR(r) (r).boot[0] = 0
#define BCMI_MADURA_BOOTr_SET(r,d) (r).boot[0] = d
#define BCMI_MADURA_BOOTr_GET(r) (r).boot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BOOTr_SERBOOT_DONE_ONCEf_GET(r) ((((r).boot[0]) >> 2) & 0x1)
#define BCMI_MADURA_BOOTr_SERBOOT_DONE_ONCEf_SET(r,f) (r).boot[0]=(((r).boot[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_BOOTr_SERBOOT_BUSYf_GET(r) ((((r).boot[0]) >> 1) & 0x1)
#define BCMI_MADURA_BOOTr_SERBOOT_BUSYf_SET(r,f) (r).boot[0]=(((r).boot[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access BOOT.
 */
#define BCMI_MADURA_READ_BOOTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BOOTr,_r._boot)
#define BCMI_MADURA_WRITE_BOOTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BOOTr,_r._boot)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BOOTr BCMI_MADURA_BOOTr
#define BOOTr_SIZE BCMI_MADURA_BOOTr_SIZE
typedef BCMI_MADURA_BOOTr_t BOOTr_t;
#define BOOTr_CLR BCMI_MADURA_BOOTr_CLR
#define BOOTr_SET BCMI_MADURA_BOOTr_SET
#define BOOTr_GET BCMI_MADURA_BOOTr_GET
#define BOOTr_SERBOOT_DONE_ONCEf_GET BCMI_MADURA_BOOTr_SERBOOT_DONE_ONCEf_GET
#define BOOTr_SERBOOT_DONE_ONCEf_SET BCMI_MADURA_BOOTr_SERBOOT_DONE_ONCEf_SET
#define BOOTr_SERBOOT_BUSYf_GET BCMI_MADURA_BOOTr_SERBOOT_BUSYf_GET
#define BOOTr_SERBOOT_BUSYf_SET BCMI_MADURA_BOOTr_SERBOOT_BUSYf_SET
#define READ_BOOTr BCMI_MADURA_READ_BOOTr
#define WRITE_BOOTr BCMI_MADURA_WRITE_BOOTr
#define MODIFY_BOOTr BCMI_MADURA_MODIFY_BOOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BOOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AHB_ERR
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8214
 * DEVAD:    1
 * DESC:     latch bits for illegal hsize accesses to arbiter and PMI HP
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_AHB_ARB_8B_LH This latch is set when Master M0 tries to make an 8-bit access to arbiter register.The latch is cleared upon read.
 *     MST_AHB_ARB_32B_LH This latch is set when Master M0 tries to make an 32-bit access to arbiter register.The latch is cleared upon read.
 *     AHB_SPIM_32B_LH  This latch is set when M0 tries to make an 32-bit access to SPI master register.The latch is cleared upon read.
 *     AHB_SPIM_16B_LH  This latch is set when M0 tries to make an 16-bit access to SPI master register.The latch is cleared upon read.
 *     MST_AHB_DEF_LH   This latch is set when master M0 tries to make an access to default peripheral.The latch is cleared upon read.
 *     MST_CRAM_8B_W_LH This latch is set when master M0 tries to perform a 8-bit write to Code RAM.The latch is cleared upon read.
 *     MST_CRAM_16B_W_LH This latch is set when master M0 tries to perform a 16-bit write to Code RAM.The latch is cleared upon read.
 */
#define BCMI_MADURA_AHB_ERRr (0x00018214 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AHB_ERRr_SIZE 4

/*
 * This structure should be used to declare and program AHB_ERR.
 */
typedef union BCMI_MADURA_AHB_ERRr_s {
	uint32_t v[1];
	uint32_t ahb_err[1];
	uint32_t _ahb_err;
} BCMI_MADURA_AHB_ERRr_t;

#define BCMI_MADURA_AHB_ERRr_CLR(r) (r).ahb_err[0] = 0
#define BCMI_MADURA_AHB_ERRr_SET(r,d) (r).ahb_err[0] = d
#define BCMI_MADURA_AHB_ERRr_GET(r) (r).ahb_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AHB_ERRr_MST_CRAM_16B_W_LHf_GET(r) ((((r).ahb_err[0]) >> 6) & 0x1)
#define BCMI_MADURA_AHB_ERRr_MST_CRAM_16B_W_LHf_SET(r,f) (r).ahb_err[0]=(((r).ahb_err[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AHB_ERRr_MST_CRAM_8B_W_LHf_GET(r) ((((r).ahb_err[0]) >> 5) & 0x1)
#define BCMI_MADURA_AHB_ERRr_MST_CRAM_8B_W_LHf_SET(r,f) (r).ahb_err[0]=(((r).ahb_err[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AHB_ERRr_MST_AHB_DEF_LHf_GET(r) ((((r).ahb_err[0]) >> 4) & 0x1)
#define BCMI_MADURA_AHB_ERRr_MST_AHB_DEF_LHf_SET(r,f) (r).ahb_err[0]=(((r).ahb_err[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AHB_ERRr_AHB_SPIM_16B_LHf_GET(r) ((((r).ahb_err[0]) >> 3) & 0x1)
#define BCMI_MADURA_AHB_ERRr_AHB_SPIM_16B_LHf_SET(r,f) (r).ahb_err[0]=(((r).ahb_err[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AHB_ERRr_AHB_SPIM_32B_LHf_GET(r) ((((r).ahb_err[0]) >> 2) & 0x1)
#define BCMI_MADURA_AHB_ERRr_AHB_SPIM_32B_LHf_SET(r,f) (r).ahb_err[0]=(((r).ahb_err[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_32B_LHf_GET(r) ((((r).ahb_err[0]) >> 1) & 0x1)
#define BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_32B_LHf_SET(r,f) (r).ahb_err[0]=(((r).ahb_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_8B_LHf_GET(r) (((r).ahb_err[0]) & 0x1)
#define BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_8B_LHf_SET(r,f) (r).ahb_err[0]=(((r).ahb_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AHB_ERR.
 */
#define BCMI_MADURA_READ_AHB_ERRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AHB_ERRr,_r._ahb_err)
#define BCMI_MADURA_WRITE_AHB_ERRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AHB_ERRr,_r._ahb_err)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AHB_ERRr BCMI_MADURA_AHB_ERRr
#define AHB_ERRr_SIZE BCMI_MADURA_AHB_ERRr_SIZE
typedef BCMI_MADURA_AHB_ERRr_t AHB_ERRr_t;
#define AHB_ERRr_CLR BCMI_MADURA_AHB_ERRr_CLR
#define AHB_ERRr_SET BCMI_MADURA_AHB_ERRr_SET
#define AHB_ERRr_GET BCMI_MADURA_AHB_ERRr_GET
#define AHB_ERRr_MST_CRAM_16B_W_LHf_GET BCMI_MADURA_AHB_ERRr_MST_CRAM_16B_W_LHf_GET
#define AHB_ERRr_MST_CRAM_16B_W_LHf_SET BCMI_MADURA_AHB_ERRr_MST_CRAM_16B_W_LHf_SET
#define AHB_ERRr_MST_CRAM_8B_W_LHf_GET BCMI_MADURA_AHB_ERRr_MST_CRAM_8B_W_LHf_GET
#define AHB_ERRr_MST_CRAM_8B_W_LHf_SET BCMI_MADURA_AHB_ERRr_MST_CRAM_8B_W_LHf_SET
#define AHB_ERRr_MST_AHB_DEF_LHf_GET BCMI_MADURA_AHB_ERRr_MST_AHB_DEF_LHf_GET
#define AHB_ERRr_MST_AHB_DEF_LHf_SET BCMI_MADURA_AHB_ERRr_MST_AHB_DEF_LHf_SET
#define AHB_ERRr_AHB_SPIM_16B_LHf_GET BCMI_MADURA_AHB_ERRr_AHB_SPIM_16B_LHf_GET
#define AHB_ERRr_AHB_SPIM_16B_LHf_SET BCMI_MADURA_AHB_ERRr_AHB_SPIM_16B_LHf_SET
#define AHB_ERRr_AHB_SPIM_32B_LHf_GET BCMI_MADURA_AHB_ERRr_AHB_SPIM_32B_LHf_GET
#define AHB_ERRr_AHB_SPIM_32B_LHf_SET BCMI_MADURA_AHB_ERRr_AHB_SPIM_32B_LHf_SET
#define AHB_ERRr_MST_AHB_ARB_32B_LHf_GET BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_32B_LHf_GET
#define AHB_ERRr_MST_AHB_ARB_32B_LHf_SET BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_32B_LHf_SET
#define AHB_ERRr_MST_AHB_ARB_8B_LHf_GET BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_8B_LHf_GET
#define AHB_ERRr_MST_AHB_ARB_8B_LHf_SET BCMI_MADURA_AHB_ERRr_MST_AHB_ARB_8B_LHf_SET
#define READ_AHB_ERRr BCMI_MADURA_READ_AHB_ERRr
#define WRITE_AHB_ERRr BCMI_MADURA_WRITE_AHB_ERRr
#define MODIFY_AHB_ERRr BCMI_MADURA_MODIFY_AHB_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AHB_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FIRMWARE_VERSION
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8216
 * DEVAD:    1
 * DESC:     Firmware Version
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     FIRMWARE_VERSION_VAL Indicates the firmware version
 */
#define BCMI_MADURA_FIRMWARE_VERSIONr (0x00018216 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FIRMWARE_VERSIONr_SIZE 4

/*
 * This structure should be used to declare and program FIRMWARE_VERSION.
 */
typedef union BCMI_MADURA_FIRMWARE_VERSIONr_s {
	uint32_t v[1];
	uint32_t firmware_version[1];
	uint32_t _firmware_version;
} BCMI_MADURA_FIRMWARE_VERSIONr_t;

#define BCMI_MADURA_FIRMWARE_VERSIONr_CLR(r) (r).firmware_version[0] = 0
#define BCMI_MADURA_FIRMWARE_VERSIONr_SET(r,d) (r).firmware_version[0] = d
#define BCMI_MADURA_FIRMWARE_VERSIONr_GET(r) (r).firmware_version[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FIRMWARE_VERSIONr_FIRMWARE_VERSION_VALf_GET(r) (((r).firmware_version[0]) & 0xffff)
#define BCMI_MADURA_FIRMWARE_VERSIONr_FIRMWARE_VERSION_VALf_SET(r,f) (r).firmware_version[0]=(((r).firmware_version[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FIRMWARE_VERSION.
 */
#define BCMI_MADURA_READ_FIRMWARE_VERSIONr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FIRMWARE_VERSIONr,_r._firmware_version)
#define BCMI_MADURA_WRITE_FIRMWARE_VERSIONr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FIRMWARE_VERSIONr,_r._firmware_version)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FIRMWARE_VERSIONr BCMI_MADURA_FIRMWARE_VERSIONr
#define FIRMWARE_VERSIONr_SIZE BCMI_MADURA_FIRMWARE_VERSIONr_SIZE
typedef BCMI_MADURA_FIRMWARE_VERSIONr_t FIRMWARE_VERSIONr_t;
#define FIRMWARE_VERSIONr_CLR BCMI_MADURA_FIRMWARE_VERSIONr_CLR
#define FIRMWARE_VERSIONr_SET BCMI_MADURA_FIRMWARE_VERSIONr_SET
#define FIRMWARE_VERSIONr_GET BCMI_MADURA_FIRMWARE_VERSIONr_GET
#define FIRMWARE_VERSIONr_FIRMWARE_VERSION_VALf_GET BCMI_MADURA_FIRMWARE_VERSIONr_FIRMWARE_VERSION_VALf_GET
#define FIRMWARE_VERSIONr_FIRMWARE_VERSION_VALf_SET BCMI_MADURA_FIRMWARE_VERSIONr_FIRMWARE_VERSION_VALf_SET
#define READ_FIRMWARE_VERSIONr BCMI_MADURA_READ_FIRMWARE_VERSIONr
#define WRITE_FIRMWARE_VERSIONr BCMI_MADURA_WRITE_FIRMWARE_VERSIONr
#define MODIFY_FIRMWARE_VERSIONr BCMI_MADURA_MODIFY_FIRMWARE_VERSIONr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FIRMWARE_VERSIONr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FIRMWARE_EN
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8217
 * DEVAD:    1
 * DESC:     Firmware enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FW_ENABLE_VAL    When set to 1, special firmware features are enabled
 */
#define BCMI_MADURA_FIRMWARE_ENr (0x00018217 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FIRMWARE_ENr_SIZE 4

/*
 * This structure should be used to declare and program FIRMWARE_EN.
 */
typedef union BCMI_MADURA_FIRMWARE_ENr_s {
	uint32_t v[1];
	uint32_t firmware_en[1];
	uint32_t _firmware_en;
} BCMI_MADURA_FIRMWARE_ENr_t;

#define BCMI_MADURA_FIRMWARE_ENr_CLR(r) (r).firmware_en[0] = 0
#define BCMI_MADURA_FIRMWARE_ENr_SET(r,d) (r).firmware_en[0] = d
#define BCMI_MADURA_FIRMWARE_ENr_GET(r) (r).firmware_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FIRMWARE_ENr_FW_ENABLE_VALf_GET(r) (((r).firmware_en[0]) & 0xffff)
#define BCMI_MADURA_FIRMWARE_ENr_FW_ENABLE_VALf_SET(r,f) (r).firmware_en[0]=(((r).firmware_en[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FIRMWARE_EN.
 */
#define BCMI_MADURA_READ_FIRMWARE_ENr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FIRMWARE_ENr,_r._firmware_en)
#define BCMI_MADURA_WRITE_FIRMWARE_ENr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FIRMWARE_ENr,_r._firmware_en)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FIRMWARE_ENr BCMI_MADURA_FIRMWARE_ENr
#define FIRMWARE_ENr_SIZE BCMI_MADURA_FIRMWARE_ENr_SIZE
typedef BCMI_MADURA_FIRMWARE_ENr_t FIRMWARE_ENr_t;
#define FIRMWARE_ENr_CLR BCMI_MADURA_FIRMWARE_ENr_CLR
#define FIRMWARE_ENr_SET BCMI_MADURA_FIRMWARE_ENr_SET
#define FIRMWARE_ENr_GET BCMI_MADURA_FIRMWARE_ENr_GET
#define FIRMWARE_ENr_FW_ENABLE_VALf_GET BCMI_MADURA_FIRMWARE_ENr_FW_ENABLE_VALf_GET
#define FIRMWARE_ENr_FW_ENABLE_VALf_SET BCMI_MADURA_FIRMWARE_ENr_FW_ENABLE_VALf_SET
#define READ_FIRMWARE_ENr BCMI_MADURA_READ_FIRMWARE_ENr
#define WRITE_FIRMWARE_ENr BCMI_MADURA_WRITE_FIRMWARE_ENr
#define MODIFY_FIRMWARE_ENr BCMI_MADURA_MODIFY_FIRMWARE_ENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FIRMWARE_ENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FIRMWARE_FEATURES
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8218
 * DEVAD:    1
 * DESC:     Firmware features
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FW_FEATURES      firmware features
 */
#define BCMI_MADURA_FIRMWARE_FEATURESr (0x00018218 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FIRMWARE_FEATURESr_SIZE 4

/*
 * This structure should be used to declare and program FIRMWARE_FEATURES.
 */
typedef union BCMI_MADURA_FIRMWARE_FEATURESr_s {
	uint32_t v[1];
	uint32_t firmware_features[1];
	uint32_t _firmware_features;
} BCMI_MADURA_FIRMWARE_FEATURESr_t;

#define BCMI_MADURA_FIRMWARE_FEATURESr_CLR(r) (r).firmware_features[0] = 0
#define BCMI_MADURA_FIRMWARE_FEATURESr_SET(r,d) (r).firmware_features[0] = d
#define BCMI_MADURA_FIRMWARE_FEATURESr_GET(r) (r).firmware_features[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FIRMWARE_FEATURESr_FW_FEATURESf_GET(r) (((r).firmware_features[0]) & 0xffff)
#define BCMI_MADURA_FIRMWARE_FEATURESr_FW_FEATURESf_SET(r,f) (r).firmware_features[0]=(((r).firmware_features[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FIRMWARE_FEATURES.
 */
#define BCMI_MADURA_READ_FIRMWARE_FEATURESr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FIRMWARE_FEATURESr,_r._firmware_features)
#define BCMI_MADURA_WRITE_FIRMWARE_FEATURESr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FIRMWARE_FEATURESr,_r._firmware_features)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FIRMWARE_FEATURESr BCMI_MADURA_FIRMWARE_FEATURESr
#define FIRMWARE_FEATURESr_SIZE BCMI_MADURA_FIRMWARE_FEATURESr_SIZE
typedef BCMI_MADURA_FIRMWARE_FEATURESr_t FIRMWARE_FEATURESr_t;
#define FIRMWARE_FEATURESr_CLR BCMI_MADURA_FIRMWARE_FEATURESr_CLR
#define FIRMWARE_FEATURESr_SET BCMI_MADURA_FIRMWARE_FEATURESr_SET
#define FIRMWARE_FEATURESr_GET BCMI_MADURA_FIRMWARE_FEATURESr_GET
#define FIRMWARE_FEATURESr_FW_FEATURESf_GET BCMI_MADURA_FIRMWARE_FEATURESr_FW_FEATURESf_GET
#define FIRMWARE_FEATURESr_FW_FEATURESf_SET BCMI_MADURA_FIRMWARE_FEATURESr_FW_FEATURESf_SET
#define READ_FIRMWARE_FEATURESr BCMI_MADURA_READ_FIRMWARE_FEATURESr
#define WRITE_FIRMWARE_FEATURESr BCMI_MADURA_WRITE_FIRMWARE_FEATURESr
#define MODIFY_FIRMWARE_FEATURESr BCMI_MADURA_MODIFY_FIRMWARE_FEATURESr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FIRMWARE_FEATURESr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV1_SPI_EEPROM_CTL0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8219
 * DEVAD:    1
 * DESC:     Offset and Count for slice 0 system side Falcon EEPROM download
 * RESETVAL: 0x25 (37)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV1_EEPROM_COUNT Number of 8KB pages to download from EEPROM for slice 0 system side Falcon M0.
 *     SLV1_EEPROM_OFFSET Offset into EEPROM from which to start downloading in units of 8KB pages for slice 0 system side Falcon M0.
 */
#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r (0x00018219 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SLV1_SPI_EEPROM_CTL0.
 */
typedef union BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_s {
	uint32_t v[1];
	uint32_t slv1_spi_eeprom_ctl0[1];
	uint32_t _slv1_spi_eeprom_ctl0;
} BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_t;

#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_CLR(r) (r).slv1_spi_eeprom_ctl0[0] = 0
#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SET(r,d) (r).slv1_spi_eeprom_ctl0[0] = d
#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_GET(r) (r).slv1_spi_eeprom_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_OFFSETf_GET(r) ((((r).slv1_spi_eeprom_ctl0[0]) >> 4) & 0xf)
#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_OFFSETf_SET(r,f) (r).slv1_spi_eeprom_ctl0[0]=(((r).slv1_spi_eeprom_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_COUNTf_GET(r) (((r).slv1_spi_eeprom_ctl0[0]) & 0x7)
#define BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_COUNTf_SET(r,f) (r).slv1_spi_eeprom_ctl0[0]=(((r).slv1_spi_eeprom_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SLV1_SPI_EEPROM_CTL0.
 */
#define BCMI_MADURA_READ_SLV1_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r,_r._slv1_spi_eeprom_ctl0)
#define BCMI_MADURA_WRITE_SLV1_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r,_r._slv1_spi_eeprom_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV1_SPI_EEPROM_CTL0r BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r
#define SLV1_SPI_EEPROM_CTL0r_SIZE BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SIZE
typedef BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_t SLV1_SPI_EEPROM_CTL0r_t;
#define SLV1_SPI_EEPROM_CTL0r_CLR BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_CLR
#define SLV1_SPI_EEPROM_CTL0r_SET BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SET
#define SLV1_SPI_EEPROM_CTL0r_GET BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_GET
#define SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_OFFSETf_GET BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_OFFSETf_GET
#define SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_OFFSETf_SET BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_OFFSETf_SET
#define SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_COUNTf_GET BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_COUNTf_GET
#define SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_COUNTf_SET BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r_SLV1_EEPROM_COUNTf_SET
#define READ_SLV1_SPI_EEPROM_CTL0r BCMI_MADURA_READ_SLV1_SPI_EEPROM_CTL0r
#define WRITE_SLV1_SPI_EEPROM_CTL0r BCMI_MADURA_WRITE_SLV1_SPI_EEPROM_CTL0r
#define MODIFY_SLV1_SPI_EEPROM_CTL0r BCMI_MADURA_MODIFY_SLV1_SPI_EEPROM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV1_SPI_EEPROM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV2_SPI_EEPROM_CTL0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x821a
 * DEVAD:    1
 * DESC:     Offset and Count for slice 0 line side Falcon EEPROM download
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV2_EEPROM_COUNT Number of 8KB pages to download from EEPROM for slice 0 line side Falcon M0.
 *     SLV2_EEPROM_OFFSET Offset into EEPROM from which to start downloading in units of 8KB pages for slice 0 line side Falcon M0.
 */
#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r (0x0001821a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SLV2_SPI_EEPROM_CTL0.
 */
typedef union BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_s {
	uint32_t v[1];
	uint32_t slv2_spi_eeprom_ctl0[1];
	uint32_t _slv2_spi_eeprom_ctl0;
} BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_t;

#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_CLR(r) (r).slv2_spi_eeprom_ctl0[0] = 0
#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SET(r,d) (r).slv2_spi_eeprom_ctl0[0] = d
#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_GET(r) (r).slv2_spi_eeprom_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_OFFSETf_GET(r) ((((r).slv2_spi_eeprom_ctl0[0]) >> 4) & 0xf)
#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_OFFSETf_SET(r,f) (r).slv2_spi_eeprom_ctl0[0]=(((r).slv2_spi_eeprom_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_COUNTf_GET(r) (((r).slv2_spi_eeprom_ctl0[0]) & 0x7)
#define BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_COUNTf_SET(r,f) (r).slv2_spi_eeprom_ctl0[0]=(((r).slv2_spi_eeprom_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SLV2_SPI_EEPROM_CTL0.
 */
#define BCMI_MADURA_READ_SLV2_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r,_r._slv2_spi_eeprom_ctl0)
#define BCMI_MADURA_WRITE_SLV2_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r,_r._slv2_spi_eeprom_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV2_SPI_EEPROM_CTL0r BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r
#define SLV2_SPI_EEPROM_CTL0r_SIZE BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SIZE
typedef BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_t SLV2_SPI_EEPROM_CTL0r_t;
#define SLV2_SPI_EEPROM_CTL0r_CLR BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_CLR
#define SLV2_SPI_EEPROM_CTL0r_SET BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SET
#define SLV2_SPI_EEPROM_CTL0r_GET BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_GET
#define SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_OFFSETf_GET BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_OFFSETf_GET
#define SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_OFFSETf_SET BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_OFFSETf_SET
#define SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_COUNTf_GET BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_COUNTf_GET
#define SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_COUNTf_SET BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r_SLV2_EEPROM_COUNTf_SET
#define READ_SLV2_SPI_EEPROM_CTL0r BCMI_MADURA_READ_SLV2_SPI_EEPROM_CTL0r
#define WRITE_SLV2_SPI_EEPROM_CTL0r BCMI_MADURA_WRITE_SLV2_SPI_EEPROM_CTL0r
#define MODIFY_SLV2_SPI_EEPROM_CTL0r BCMI_MADURA_MODIFY_SLV2_SPI_EEPROM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV2_SPI_EEPROM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV3_SPI_EEPROM_CTL0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x821b
 * DEVAD:    1
 * DESC:     Offset and Count for slice 1 system side Falcon EEPROM download
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV3_EEPROM_COUNT Number of 8KB pages to download from EEPROM for slice 1 system side Falcon M0.
 *     SLV3_EEPROM_OFFSET Offset into EEPROM from which to start downloading in units of 8KB pages for slice 1 system side Falcon M0.
 */
#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r (0x0001821b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SLV3_SPI_EEPROM_CTL0.
 */
typedef union BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_s {
	uint32_t v[1];
	uint32_t slv3_spi_eeprom_ctl0[1];
	uint32_t _slv3_spi_eeprom_ctl0;
} BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_t;

#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_CLR(r) (r).slv3_spi_eeprom_ctl0[0] = 0
#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SET(r,d) (r).slv3_spi_eeprom_ctl0[0] = d
#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_GET(r) (r).slv3_spi_eeprom_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_OFFSETf_GET(r) ((((r).slv3_spi_eeprom_ctl0[0]) >> 4) & 0xf)
#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_OFFSETf_SET(r,f) (r).slv3_spi_eeprom_ctl0[0]=(((r).slv3_spi_eeprom_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_COUNTf_GET(r) (((r).slv3_spi_eeprom_ctl0[0]) & 0x7)
#define BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_COUNTf_SET(r,f) (r).slv3_spi_eeprom_ctl0[0]=(((r).slv3_spi_eeprom_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SLV3_SPI_EEPROM_CTL0.
 */
#define BCMI_MADURA_READ_SLV3_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r,_r._slv3_spi_eeprom_ctl0)
#define BCMI_MADURA_WRITE_SLV3_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r,_r._slv3_spi_eeprom_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV3_SPI_EEPROM_CTL0r BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r
#define SLV3_SPI_EEPROM_CTL0r_SIZE BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SIZE
typedef BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_t SLV3_SPI_EEPROM_CTL0r_t;
#define SLV3_SPI_EEPROM_CTL0r_CLR BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_CLR
#define SLV3_SPI_EEPROM_CTL0r_SET BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SET
#define SLV3_SPI_EEPROM_CTL0r_GET BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_GET
#define SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_OFFSETf_GET BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_OFFSETf_GET
#define SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_OFFSETf_SET BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_OFFSETf_SET
#define SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_COUNTf_GET BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_COUNTf_GET
#define SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_COUNTf_SET BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r_SLV3_EEPROM_COUNTf_SET
#define READ_SLV3_SPI_EEPROM_CTL0r BCMI_MADURA_READ_SLV3_SPI_EEPROM_CTL0r
#define WRITE_SLV3_SPI_EEPROM_CTL0r BCMI_MADURA_WRITE_SLV3_SPI_EEPROM_CTL0r
#define MODIFY_SLV3_SPI_EEPROM_CTL0r BCMI_MADURA_MODIFY_SLV3_SPI_EEPROM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV3_SPI_EEPROM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV4_SPI_EEPROM_CTL0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x821c
 * DEVAD:    1
 * DESC:     Offset and Count for slice 1 line side Falcon EEPROM download
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV4_EEPROM_COUNT Number of 8KB pages to download from EEPROM for slice 1 line side Falcon M0.
 *     SLV4_EEPROM_OFFSET Offset into EEPROM from which to start downloading in units of 8KB pages for slice 1 line side Falcon M0.
 */
#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r (0x0001821c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SLV4_SPI_EEPROM_CTL0.
 */
typedef union BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_s {
	uint32_t v[1];
	uint32_t slv4_spi_eeprom_ctl0[1];
	uint32_t _slv4_spi_eeprom_ctl0;
} BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_t;

#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_CLR(r) (r).slv4_spi_eeprom_ctl0[0] = 0
#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SET(r,d) (r).slv4_spi_eeprom_ctl0[0] = d
#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_GET(r) (r).slv4_spi_eeprom_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_OFFSETf_GET(r) ((((r).slv4_spi_eeprom_ctl0[0]) >> 4) & 0xf)
#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_OFFSETf_SET(r,f) (r).slv4_spi_eeprom_ctl0[0]=(((r).slv4_spi_eeprom_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_COUNTf_GET(r) (((r).slv4_spi_eeprom_ctl0[0]) & 0x7)
#define BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_COUNTf_SET(r,f) (r).slv4_spi_eeprom_ctl0[0]=(((r).slv4_spi_eeprom_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SLV4_SPI_EEPROM_CTL0.
 */
#define BCMI_MADURA_READ_SLV4_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r,_r._slv4_spi_eeprom_ctl0)
#define BCMI_MADURA_WRITE_SLV4_SPI_EEPROM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r,_r._slv4_spi_eeprom_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV4_SPI_EEPROM_CTL0r BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r
#define SLV4_SPI_EEPROM_CTL0r_SIZE BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SIZE
typedef BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_t SLV4_SPI_EEPROM_CTL0r_t;
#define SLV4_SPI_EEPROM_CTL0r_CLR BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_CLR
#define SLV4_SPI_EEPROM_CTL0r_SET BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SET
#define SLV4_SPI_EEPROM_CTL0r_GET BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_GET
#define SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_OFFSETf_GET BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_OFFSETf_GET
#define SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_OFFSETf_SET BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_OFFSETf_SET
#define SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_COUNTf_GET BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_COUNTf_GET
#define SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_COUNTf_SET BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r_SLV4_EEPROM_COUNTf_SET
#define READ_SLV4_SPI_EEPROM_CTL0r BCMI_MADURA_READ_SLV4_SPI_EEPROM_CTL0r
#define WRITE_SLV4_SPI_EEPROM_CTL0r BCMI_MADURA_WRITE_SLV4_SPI_EEPROM_CTL0r
#define MODIFY_SLV4_SPI_EEPROM_CTL0r BCMI_MADURA_MODIFY_SLV4_SPI_EEPROM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV4_SPI_EEPROM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SPI_MST_CODE_START_PTR
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8220
 * DEVAD:    1
 * DESC:     Master M0 SPI download start Pointer
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_CODE_START_PTR Byte address in the M0 Master code RAM to start loading the program from external EEPROM. Complete 32-bit M0 address for this is obtained by prepending  16'b0001_0000_0000_0000 (code ram base)
 */
#define BCMI_MADURA_SPI_MST_CODE_START_PTRr (0x00018220 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SPI_MST_CODE_START_PTRr_SIZE 4

/*
 * This structure should be used to declare and program SPI_MST_CODE_START_PTR.
 */
typedef union BCMI_MADURA_SPI_MST_CODE_START_PTRr_s {
	uint32_t v[1];
	uint32_t spi_mst_code_start_ptr[1];
	uint32_t _spi_mst_code_start_ptr;
} BCMI_MADURA_SPI_MST_CODE_START_PTRr_t;

#define BCMI_MADURA_SPI_MST_CODE_START_PTRr_CLR(r) (r).spi_mst_code_start_ptr[0] = 0
#define BCMI_MADURA_SPI_MST_CODE_START_PTRr_SET(r,d) (r).spi_mst_code_start_ptr[0] = d
#define BCMI_MADURA_SPI_MST_CODE_START_PTRr_GET(r) (r).spi_mst_code_start_ptr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SPI_MST_CODE_START_PTRr_MST_CODE_START_PTRf_GET(r) (((r).spi_mst_code_start_ptr[0]) & 0xffff)
#define BCMI_MADURA_SPI_MST_CODE_START_PTRr_MST_CODE_START_PTRf_SET(r,f) (r).spi_mst_code_start_ptr[0]=(((r).spi_mst_code_start_ptr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SPI_MST_CODE_START_PTR.
 */
#define BCMI_MADURA_READ_SPI_MST_CODE_START_PTRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SPI_MST_CODE_START_PTRr,_r._spi_mst_code_start_ptr)
#define BCMI_MADURA_WRITE_SPI_MST_CODE_START_PTRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SPI_MST_CODE_START_PTRr,_r._spi_mst_code_start_ptr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SPI_MST_CODE_START_PTRr BCMI_MADURA_SPI_MST_CODE_START_PTRr
#define SPI_MST_CODE_START_PTRr_SIZE BCMI_MADURA_SPI_MST_CODE_START_PTRr_SIZE
typedef BCMI_MADURA_SPI_MST_CODE_START_PTRr_t SPI_MST_CODE_START_PTRr_t;
#define SPI_MST_CODE_START_PTRr_CLR BCMI_MADURA_SPI_MST_CODE_START_PTRr_CLR
#define SPI_MST_CODE_START_PTRr_SET BCMI_MADURA_SPI_MST_CODE_START_PTRr_SET
#define SPI_MST_CODE_START_PTRr_GET BCMI_MADURA_SPI_MST_CODE_START_PTRr_GET
#define SPI_MST_CODE_START_PTRr_MST_CODE_START_PTRf_GET BCMI_MADURA_SPI_MST_CODE_START_PTRr_MST_CODE_START_PTRf_GET
#define SPI_MST_CODE_START_PTRr_MST_CODE_START_PTRf_SET BCMI_MADURA_SPI_MST_CODE_START_PTRr_MST_CODE_START_PTRf_SET
#define READ_SPI_MST_CODE_START_PTRr BCMI_MADURA_READ_SPI_MST_CODE_START_PTRr
#define WRITE_SPI_MST_CODE_START_PTRr BCMI_MADURA_WRITE_SPI_MST_CODE_START_PTRr
#define MODIFY_SPI_MST_CODE_START_PTRr BCMI_MADURA_MODIFY_SPI_MST_CODE_START_PTRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SPI_MST_CODE_START_PTRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MSGOUT
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8221
 * DEVAD:    1
 * DESC:     Outgoing message from Master micro to external world
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_MSGOUT_VAL   message from Master micro to external world. Note EISR contains the interrupt for msgout.This register will clear on read.
 */
#define BCMI_MADURA_MST_MSGOUTr (0x00018221 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MSGOUTr_SIZE 4

/*
 * This structure should be used to declare and program MST_MSGOUT.
 */
typedef union BCMI_MADURA_MST_MSGOUTr_s {
	uint32_t v[1];
	uint32_t mst_msgout[1];
	uint32_t _mst_msgout;
} BCMI_MADURA_MST_MSGOUTr_t;

#define BCMI_MADURA_MST_MSGOUTr_CLR(r) (r).mst_msgout[0] = 0
#define BCMI_MADURA_MST_MSGOUTr_SET(r,d) (r).mst_msgout[0] = d
#define BCMI_MADURA_MST_MSGOUTr_GET(r) (r).mst_msgout[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MSGOUTr_MST_MSGOUT_VALf_GET(r) (((r).mst_msgout[0]) & 0xffff)
#define BCMI_MADURA_MST_MSGOUTr_MST_MSGOUT_VALf_SET(r,f) (r).mst_msgout[0]=(((r).mst_msgout[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MSGOUT.
 */
#define BCMI_MADURA_READ_MST_MSGOUTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MSGOUTr,_r._mst_msgout)
#define BCMI_MADURA_WRITE_MST_MSGOUTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MSGOUTr,_r._mst_msgout)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MSGOUTr BCMI_MADURA_MST_MSGOUTr
#define MST_MSGOUTr_SIZE BCMI_MADURA_MST_MSGOUTr_SIZE
typedef BCMI_MADURA_MST_MSGOUTr_t MST_MSGOUTr_t;
#define MST_MSGOUTr_CLR BCMI_MADURA_MST_MSGOUTr_CLR
#define MST_MSGOUTr_SET BCMI_MADURA_MST_MSGOUTr_SET
#define MST_MSGOUTr_GET BCMI_MADURA_MST_MSGOUTr_GET
#define MST_MSGOUTr_MST_MSGOUT_VALf_GET BCMI_MADURA_MST_MSGOUTr_MST_MSGOUT_VALf_GET
#define MST_MSGOUTr_MST_MSGOUT_VALf_SET BCMI_MADURA_MST_MSGOUTr_MST_MSGOUT_VALf_SET
#define READ_MST_MSGOUTr BCMI_MADURA_READ_MST_MSGOUTr
#define WRITE_MST_MSGOUTr BCMI_MADURA_WRITE_MST_MSGOUTr
#define MODIFY_MST_MSGOUTr BCMI_MADURA_MODIFY_MST_MSGOUTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MSGOUTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MSGIN
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8222
 * DEVAD:    1
 * DESC:     Incoming message from external world to Master micro
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_MSGIN_VAL    message from external world to Master micro.
 */
#define BCMI_MADURA_MST_MSGINr (0x00018222 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MSGINr_SIZE 4

/*
 * This structure should be used to declare and program MST_MSGIN.
 */
typedef union BCMI_MADURA_MST_MSGINr_s {
	uint32_t v[1];
	uint32_t mst_msgin[1];
	uint32_t _mst_msgin;
} BCMI_MADURA_MST_MSGINr_t;

#define BCMI_MADURA_MST_MSGINr_CLR(r) (r).mst_msgin[0] = 0
#define BCMI_MADURA_MST_MSGINr_SET(r,d) (r).mst_msgin[0] = d
#define BCMI_MADURA_MST_MSGINr_GET(r) (r).mst_msgin[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MSGINr_MST_MSGIN_VALf_GET(r) (((r).mst_msgin[0]) & 0xffff)
#define BCMI_MADURA_MST_MSGINr_MST_MSGIN_VALf_SET(r,f) (r).mst_msgin[0]=(((r).mst_msgin[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MSGIN.
 */
#define BCMI_MADURA_READ_MST_MSGINr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MSGINr,_r._mst_msgin)
#define BCMI_MADURA_WRITE_MST_MSGINr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MSGINr,_r._mst_msgin)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MSGINr BCMI_MADURA_MST_MSGINr
#define MST_MSGINr_SIZE BCMI_MADURA_MST_MSGINr_SIZE
typedef BCMI_MADURA_MST_MSGINr_t MST_MSGINr_t;
#define MST_MSGINr_CLR BCMI_MADURA_MST_MSGINr_CLR
#define MST_MSGINr_SET BCMI_MADURA_MST_MSGINr_SET
#define MST_MSGINr_GET BCMI_MADURA_MST_MSGINr_GET
#define MST_MSGINr_MST_MSGIN_VALf_GET BCMI_MADURA_MST_MSGINr_MST_MSGIN_VALf_GET
#define MST_MSGINr_MST_MSGIN_VALf_SET BCMI_MADURA_MST_MSGINr_MST_MSGIN_VALf_SET
#define READ_MST_MSGINr BCMI_MADURA_READ_MST_MSGINr
#define WRITE_MST_MSGINr BCMI_MADURA_WRITE_MST_MSGINr
#define MODIFY_MST_MSGINr BCMI_MADURA_MODIFY_MST_MSGINr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MSGINr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC_INTR
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8223
 * DEVAD:    1
 * DESC:     Master M0 writes to this register to create ext. interrupt
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_MISC_INTR_VAL Master M0 writes to this register to create interrupt to external worldThis register will clear on read.
 */
#define BCMI_MADURA_MST_MISC_INTRr (0x00018223 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC_INTRr_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC_INTR.
 */
typedef union BCMI_MADURA_MST_MISC_INTRr_s {
	uint32_t v[1];
	uint32_t mst_misc_intr[1];
	uint32_t _mst_misc_intr;
} BCMI_MADURA_MST_MISC_INTRr_t;

#define BCMI_MADURA_MST_MISC_INTRr_CLR(r) (r).mst_misc_intr[0] = 0
#define BCMI_MADURA_MST_MISC_INTRr_SET(r,d) (r).mst_misc_intr[0] = d
#define BCMI_MADURA_MST_MISC_INTRr_GET(r) (r).mst_misc_intr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC_INTRr_MST_MISC_INTR_VALf_GET(r) (((r).mst_misc_intr[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC_INTRr_MST_MISC_INTR_VALf_SET(r,f) (r).mst_misc_intr[0]=(((r).mst_misc_intr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC_INTR.
 */
#define BCMI_MADURA_READ_MST_MISC_INTRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC_INTRr,_r._mst_misc_intr)
#define BCMI_MADURA_WRITE_MST_MISC_INTRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC_INTRr,_r._mst_misc_intr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC_INTRr BCMI_MADURA_MST_MISC_INTRr
#define MST_MISC_INTRr_SIZE BCMI_MADURA_MST_MISC_INTRr_SIZE
typedef BCMI_MADURA_MST_MISC_INTRr_t MST_MISC_INTRr_t;
#define MST_MISC_INTRr_CLR BCMI_MADURA_MST_MISC_INTRr_CLR
#define MST_MISC_INTRr_SET BCMI_MADURA_MST_MISC_INTRr_SET
#define MST_MISC_INTRr_GET BCMI_MADURA_MST_MISC_INTRr_GET
#define MST_MISC_INTRr_MST_MISC_INTR_VALf_GET BCMI_MADURA_MST_MISC_INTRr_MST_MISC_INTR_VALf_GET
#define MST_MISC_INTRr_MST_MISC_INTR_VALf_SET BCMI_MADURA_MST_MISC_INTRr_MST_MISC_INTR_VALf_SET
#define READ_MST_MISC_INTRr BCMI_MADURA_READ_MST_MISC_INTRr
#define WRITE_MST_MISC_INTRr BCMI_MADURA_WRITE_MST_MISC_INTRr
#define MODIFY_MST_MISC_INTRr BCMI_MADURA_MODIFY_MST_MISC_INTRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC_INTRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_RUNNING_CHKSUM
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8224
 * DEVAD:    1
 * DESC:     Master M0 running checksum
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_RUNNING_CHKSUM_VAL When master m0 code is downloaded through mdio or spim the current value of checksum is updated by the boot code in this register.
 */
#define BCMI_MADURA_MST_RUNNING_CHKSUMr (0x00018224 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_RUNNING_CHKSUMr_SIZE 4

/*
 * This structure should be used to declare and program MST_RUNNING_CHKSUM.
 */
typedef union BCMI_MADURA_MST_RUNNING_CHKSUMr_s {
	uint32_t v[1];
	uint32_t mst_running_chksum[1];
	uint32_t _mst_running_chksum;
} BCMI_MADURA_MST_RUNNING_CHKSUMr_t;

#define BCMI_MADURA_MST_RUNNING_CHKSUMr_CLR(r) (r).mst_running_chksum[0] = 0
#define BCMI_MADURA_MST_RUNNING_CHKSUMr_SET(r,d) (r).mst_running_chksum[0] = d
#define BCMI_MADURA_MST_RUNNING_CHKSUMr_GET(r) (r).mst_running_chksum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_RUNNING_CHKSUMr_MST_RUNNING_CHKSUM_VALf_GET(r) (((r).mst_running_chksum[0]) & 0xffff)
#define BCMI_MADURA_MST_RUNNING_CHKSUMr_MST_RUNNING_CHKSUM_VALf_SET(r,f) (r).mst_running_chksum[0]=(((r).mst_running_chksum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_RUNNING_CHKSUM.
 */
#define BCMI_MADURA_READ_MST_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_RUNNING_CHKSUMr,_r._mst_running_chksum)
#define BCMI_MADURA_WRITE_MST_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_RUNNING_CHKSUMr,_r._mst_running_chksum)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_RUNNING_CHKSUMr BCMI_MADURA_MST_RUNNING_CHKSUMr
#define MST_RUNNING_CHKSUMr_SIZE BCMI_MADURA_MST_RUNNING_CHKSUMr_SIZE
typedef BCMI_MADURA_MST_RUNNING_CHKSUMr_t MST_RUNNING_CHKSUMr_t;
#define MST_RUNNING_CHKSUMr_CLR BCMI_MADURA_MST_RUNNING_CHKSUMr_CLR
#define MST_RUNNING_CHKSUMr_SET BCMI_MADURA_MST_RUNNING_CHKSUMr_SET
#define MST_RUNNING_CHKSUMr_GET BCMI_MADURA_MST_RUNNING_CHKSUMr_GET
#define MST_RUNNING_CHKSUMr_MST_RUNNING_CHKSUM_VALf_GET BCMI_MADURA_MST_RUNNING_CHKSUMr_MST_RUNNING_CHKSUM_VALf_GET
#define MST_RUNNING_CHKSUMr_MST_RUNNING_CHKSUM_VALf_SET BCMI_MADURA_MST_RUNNING_CHKSUMr_MST_RUNNING_CHKSUM_VALf_SET
#define READ_MST_RUNNING_CHKSUMr BCMI_MADURA_READ_MST_RUNNING_CHKSUMr
#define WRITE_MST_RUNNING_CHKSUMr BCMI_MADURA_WRITE_MST_RUNNING_CHKSUMr
#define MODIFY_MST_RUNNING_CHKSUMr BCMI_MADURA_MODIFY_MST_RUNNING_CHKSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_RUNNING_CHKSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_RUNNING_BYTE_CNT
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8225
 * DEVAD:    1
 * DESC:     Master M0 running byte count
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_RUNNING_BYTE_CNT_VAL When master m0 code is downloaded through mdio, the current value of accumulated bytes is updated by the boot code in this register.
 */
#define BCMI_MADURA_MST_RUNNING_BYTE_CNTr (0x00018225 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_RUNNING_BYTE_CNTr_SIZE 4

/*
 * This structure should be used to declare and program MST_RUNNING_BYTE_CNT.
 */
typedef union BCMI_MADURA_MST_RUNNING_BYTE_CNTr_s {
	uint32_t v[1];
	uint32_t mst_running_byte_cnt[1];
	uint32_t _mst_running_byte_cnt;
} BCMI_MADURA_MST_RUNNING_BYTE_CNTr_t;

#define BCMI_MADURA_MST_RUNNING_BYTE_CNTr_CLR(r) (r).mst_running_byte_cnt[0] = 0
#define BCMI_MADURA_MST_RUNNING_BYTE_CNTr_SET(r,d) (r).mst_running_byte_cnt[0] = d
#define BCMI_MADURA_MST_RUNNING_BYTE_CNTr_GET(r) (r).mst_running_byte_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_RUNNING_BYTE_CNTr_MST_RUNNING_BYTE_CNT_VALf_GET(r) (((r).mst_running_byte_cnt[0]) & 0xffff)
#define BCMI_MADURA_MST_RUNNING_BYTE_CNTr_MST_RUNNING_BYTE_CNT_VALf_SET(r,f) (r).mst_running_byte_cnt[0]=(((r).mst_running_byte_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_RUNNING_BYTE_CNT.
 */
#define BCMI_MADURA_READ_MST_RUNNING_BYTE_CNTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_RUNNING_BYTE_CNTr,_r._mst_running_byte_cnt)
#define BCMI_MADURA_WRITE_MST_RUNNING_BYTE_CNTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_RUNNING_BYTE_CNTr,_r._mst_running_byte_cnt)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_RUNNING_BYTE_CNTr BCMI_MADURA_MST_RUNNING_BYTE_CNTr
#define MST_RUNNING_BYTE_CNTr_SIZE BCMI_MADURA_MST_RUNNING_BYTE_CNTr_SIZE
typedef BCMI_MADURA_MST_RUNNING_BYTE_CNTr_t MST_RUNNING_BYTE_CNTr_t;
#define MST_RUNNING_BYTE_CNTr_CLR BCMI_MADURA_MST_RUNNING_BYTE_CNTr_CLR
#define MST_RUNNING_BYTE_CNTr_SET BCMI_MADURA_MST_RUNNING_BYTE_CNTr_SET
#define MST_RUNNING_BYTE_CNTr_GET BCMI_MADURA_MST_RUNNING_BYTE_CNTr_GET
#define MST_RUNNING_BYTE_CNTr_MST_RUNNING_BYTE_CNT_VALf_GET BCMI_MADURA_MST_RUNNING_BYTE_CNTr_MST_RUNNING_BYTE_CNT_VALf_GET
#define MST_RUNNING_BYTE_CNTr_MST_RUNNING_BYTE_CNT_VALf_SET BCMI_MADURA_MST_RUNNING_BYTE_CNTr_MST_RUNNING_BYTE_CNT_VALf_SET
#define READ_MST_RUNNING_BYTE_CNTr BCMI_MADURA_READ_MST_RUNNING_BYTE_CNTr
#define WRITE_MST_RUNNING_BYTE_CNTr BCMI_MADURA_WRITE_MST_RUNNING_BYTE_CNTr
#define MODIFY_MST_RUNNING_BYTE_CNTr BCMI_MADURA_MODIFY_MST_RUNNING_BYTE_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_RUNNING_BYTE_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_CFG0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8226
 * DEVAD:    1
 * DESC:     Master M0 General purpose configuration register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CONTROL0         Master config 0 register
 */
#define BCMI_MADURA_MST_CFG0r (0x00018226 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program MST_CFG0.
 */
typedef union BCMI_MADURA_MST_CFG0r_s {
	uint32_t v[1];
	uint32_t mst_cfg0[1];
	uint32_t _mst_cfg0;
} BCMI_MADURA_MST_CFG0r_t;

#define BCMI_MADURA_MST_CFG0r_CLR(r) (r).mst_cfg0[0] = 0
#define BCMI_MADURA_MST_CFG0r_SET(r,d) (r).mst_cfg0[0] = d
#define BCMI_MADURA_MST_CFG0r_GET(r) (r).mst_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_CFG0r_CONTROL0f_GET(r) (((r).mst_cfg0[0]) & 0xffff)
#define BCMI_MADURA_MST_CFG0r_CONTROL0f_SET(r,f) (r).mst_cfg0[0]=(((r).mst_cfg0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_CFG0.
 */
#define BCMI_MADURA_READ_MST_CFG0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_CFG0r,_r._mst_cfg0)
#define BCMI_MADURA_WRITE_MST_CFG0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_CFG0r,_r._mst_cfg0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_CFG0r BCMI_MADURA_MST_CFG0r
#define MST_CFG0r_SIZE BCMI_MADURA_MST_CFG0r_SIZE
typedef BCMI_MADURA_MST_CFG0r_t MST_CFG0r_t;
#define MST_CFG0r_CLR BCMI_MADURA_MST_CFG0r_CLR
#define MST_CFG0r_SET BCMI_MADURA_MST_CFG0r_SET
#define MST_CFG0r_GET BCMI_MADURA_MST_CFG0r_GET
#define MST_CFG0r_CONTROL0f_GET BCMI_MADURA_MST_CFG0r_CONTROL0f_GET
#define MST_CFG0r_CONTROL0f_SET BCMI_MADURA_MST_CFG0r_CONTROL0f_SET
#define READ_MST_CFG0r BCMI_MADURA_READ_MST_CFG0r
#define WRITE_MST_CFG0r BCMI_MADURA_WRITE_MST_CFG0r
#define MODIFY_MST_CFG0r BCMI_MADURA_MODIFY_MST_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_CFG1
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8227
 * DEVAD:    1
 * DESC:     Master M0 General purpose configuration register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CONTROL1         Master config 1 register
 */
#define BCMI_MADURA_MST_CFG1r (0x00018227 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program MST_CFG1.
 */
typedef union BCMI_MADURA_MST_CFG1r_s {
	uint32_t v[1];
	uint32_t mst_cfg1[1];
	uint32_t _mst_cfg1;
} BCMI_MADURA_MST_CFG1r_t;

#define BCMI_MADURA_MST_CFG1r_CLR(r) (r).mst_cfg1[0] = 0
#define BCMI_MADURA_MST_CFG1r_SET(r,d) (r).mst_cfg1[0] = d
#define BCMI_MADURA_MST_CFG1r_GET(r) (r).mst_cfg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_CFG1r_CONTROL1f_GET(r) (((r).mst_cfg1[0]) & 0xffff)
#define BCMI_MADURA_MST_CFG1r_CONTROL1f_SET(r,f) (r).mst_cfg1[0]=(((r).mst_cfg1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_CFG1.
 */
#define BCMI_MADURA_READ_MST_CFG1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_CFG1r,_r._mst_cfg1)
#define BCMI_MADURA_WRITE_MST_CFG1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_CFG1r,_r._mst_cfg1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_CFG1r BCMI_MADURA_MST_CFG1r
#define MST_CFG1r_SIZE BCMI_MADURA_MST_CFG1r_SIZE
typedef BCMI_MADURA_MST_CFG1r_t MST_CFG1r_t;
#define MST_CFG1r_CLR BCMI_MADURA_MST_CFG1r_CLR
#define MST_CFG1r_SET BCMI_MADURA_MST_CFG1r_SET
#define MST_CFG1r_GET BCMI_MADURA_MST_CFG1r_GET
#define MST_CFG1r_CONTROL1f_GET BCMI_MADURA_MST_CFG1r_CONTROL1f_GET
#define MST_CFG1r_CONTROL1f_SET BCMI_MADURA_MST_CFG1r_CONTROL1f_SET
#define READ_MST_CFG1r BCMI_MADURA_READ_MST_CFG1r
#define WRITE_MST_CFG1r BCMI_MADURA_WRITE_MST_CFG1r
#define MODIFY_MST_CFG1r BCMI_MADURA_MODIFY_MST_CFG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_CFG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8228
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC0            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC0r (0x00018228 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC0r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC0.
 */
typedef union BCMI_MADURA_MST_MISC0r_s {
	uint32_t v[1];
	uint32_t mst_misc0[1];
	uint32_t _mst_misc0;
} BCMI_MADURA_MST_MISC0r_t;

#define BCMI_MADURA_MST_MISC0r_CLR(r) (r).mst_misc0[0] = 0
#define BCMI_MADURA_MST_MISC0r_SET(r,d) (r).mst_misc0[0] = d
#define BCMI_MADURA_MST_MISC0r_GET(r) (r).mst_misc0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC0r_MISC0f_GET(r) (((r).mst_misc0[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC0r_MISC0f_SET(r,f) (r).mst_misc0[0]=(((r).mst_misc0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC0.
 */
#define BCMI_MADURA_READ_MST_MISC0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC0r,_r._mst_misc0)
#define BCMI_MADURA_WRITE_MST_MISC0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC0r,_r._mst_misc0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC0r BCMI_MADURA_MST_MISC0r
#define MST_MISC0r_SIZE BCMI_MADURA_MST_MISC0r_SIZE
typedef BCMI_MADURA_MST_MISC0r_t MST_MISC0r_t;
#define MST_MISC0r_CLR BCMI_MADURA_MST_MISC0r_CLR
#define MST_MISC0r_SET BCMI_MADURA_MST_MISC0r_SET
#define MST_MISC0r_GET BCMI_MADURA_MST_MISC0r_GET
#define MST_MISC0r_MISC0f_GET BCMI_MADURA_MST_MISC0r_MISC0f_GET
#define MST_MISC0r_MISC0f_SET BCMI_MADURA_MST_MISC0r_MISC0f_SET
#define READ_MST_MISC0r BCMI_MADURA_READ_MST_MISC0r
#define WRITE_MST_MISC0r BCMI_MADURA_WRITE_MST_MISC0r
#define MODIFY_MST_MISC0r BCMI_MADURA_MODIFY_MST_MISC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC1
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8229
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC1            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC1r (0x00018229 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC1r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC1.
 */
typedef union BCMI_MADURA_MST_MISC1r_s {
	uint32_t v[1];
	uint32_t mst_misc1[1];
	uint32_t _mst_misc1;
} BCMI_MADURA_MST_MISC1r_t;

#define BCMI_MADURA_MST_MISC1r_CLR(r) (r).mst_misc1[0] = 0
#define BCMI_MADURA_MST_MISC1r_SET(r,d) (r).mst_misc1[0] = d
#define BCMI_MADURA_MST_MISC1r_GET(r) (r).mst_misc1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC1r_MISC1f_GET(r) (((r).mst_misc1[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC1r_MISC1f_SET(r,f) (r).mst_misc1[0]=(((r).mst_misc1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC1.
 */
#define BCMI_MADURA_READ_MST_MISC1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC1r,_r._mst_misc1)
#define BCMI_MADURA_WRITE_MST_MISC1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC1r,_r._mst_misc1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC1r BCMI_MADURA_MST_MISC1r
#define MST_MISC1r_SIZE BCMI_MADURA_MST_MISC1r_SIZE
typedef BCMI_MADURA_MST_MISC1r_t MST_MISC1r_t;
#define MST_MISC1r_CLR BCMI_MADURA_MST_MISC1r_CLR
#define MST_MISC1r_SET BCMI_MADURA_MST_MISC1r_SET
#define MST_MISC1r_GET BCMI_MADURA_MST_MISC1r_GET
#define MST_MISC1r_MISC1f_GET BCMI_MADURA_MST_MISC1r_MISC1f_GET
#define MST_MISC1r_MISC1f_SET BCMI_MADURA_MST_MISC1r_MISC1f_SET
#define READ_MST_MISC1r BCMI_MADURA_READ_MST_MISC1r
#define WRITE_MST_MISC1r BCMI_MADURA_WRITE_MST_MISC1r
#define MODIFY_MST_MISC1r BCMI_MADURA_MODIFY_MST_MISC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC2
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x822a
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC2            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC2r (0x0001822a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC2r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC2.
 */
typedef union BCMI_MADURA_MST_MISC2r_s {
	uint32_t v[1];
	uint32_t mst_misc2[1];
	uint32_t _mst_misc2;
} BCMI_MADURA_MST_MISC2r_t;

#define BCMI_MADURA_MST_MISC2r_CLR(r) (r).mst_misc2[0] = 0
#define BCMI_MADURA_MST_MISC2r_SET(r,d) (r).mst_misc2[0] = d
#define BCMI_MADURA_MST_MISC2r_GET(r) (r).mst_misc2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC2r_MISC2f_GET(r) (((r).mst_misc2[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC2r_MISC2f_SET(r,f) (r).mst_misc2[0]=(((r).mst_misc2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC2.
 */
#define BCMI_MADURA_READ_MST_MISC2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC2r,_r._mst_misc2)
#define BCMI_MADURA_WRITE_MST_MISC2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC2r,_r._mst_misc2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC2r BCMI_MADURA_MST_MISC2r
#define MST_MISC2r_SIZE BCMI_MADURA_MST_MISC2r_SIZE
typedef BCMI_MADURA_MST_MISC2r_t MST_MISC2r_t;
#define MST_MISC2r_CLR BCMI_MADURA_MST_MISC2r_CLR
#define MST_MISC2r_SET BCMI_MADURA_MST_MISC2r_SET
#define MST_MISC2r_GET BCMI_MADURA_MST_MISC2r_GET
#define MST_MISC2r_MISC2f_GET BCMI_MADURA_MST_MISC2r_MISC2f_GET
#define MST_MISC2r_MISC2f_SET BCMI_MADURA_MST_MISC2r_MISC2f_SET
#define READ_MST_MISC2r BCMI_MADURA_READ_MST_MISC2r
#define WRITE_MST_MISC2r BCMI_MADURA_WRITE_MST_MISC2r
#define MODIFY_MST_MISC2r BCMI_MADURA_MODIFY_MST_MISC2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC3
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x822b
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC3            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC3r (0x0001822b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC3r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC3.
 */
typedef union BCMI_MADURA_MST_MISC3r_s {
	uint32_t v[1];
	uint32_t mst_misc3[1];
	uint32_t _mst_misc3;
} BCMI_MADURA_MST_MISC3r_t;

#define BCMI_MADURA_MST_MISC3r_CLR(r) (r).mst_misc3[0] = 0
#define BCMI_MADURA_MST_MISC3r_SET(r,d) (r).mst_misc3[0] = d
#define BCMI_MADURA_MST_MISC3r_GET(r) (r).mst_misc3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC3r_MISC3f_GET(r) (((r).mst_misc3[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC3r_MISC3f_SET(r,f) (r).mst_misc3[0]=(((r).mst_misc3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC3.
 */
#define BCMI_MADURA_READ_MST_MISC3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC3r,_r._mst_misc3)
#define BCMI_MADURA_WRITE_MST_MISC3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC3r,_r._mst_misc3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC3r BCMI_MADURA_MST_MISC3r
#define MST_MISC3r_SIZE BCMI_MADURA_MST_MISC3r_SIZE
typedef BCMI_MADURA_MST_MISC3r_t MST_MISC3r_t;
#define MST_MISC3r_CLR BCMI_MADURA_MST_MISC3r_CLR
#define MST_MISC3r_SET BCMI_MADURA_MST_MISC3r_SET
#define MST_MISC3r_GET BCMI_MADURA_MST_MISC3r_GET
#define MST_MISC3r_MISC3f_GET BCMI_MADURA_MST_MISC3r_MISC3f_GET
#define MST_MISC3r_MISC3f_SET BCMI_MADURA_MST_MISC3r_MISC3f_SET
#define READ_MST_MISC3r BCMI_MADURA_READ_MST_MISC3r
#define WRITE_MST_MISC3r BCMI_MADURA_WRITE_MST_MISC3r
#define MODIFY_MST_MISC3r BCMI_MADURA_MODIFY_MST_MISC3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC4
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x822c
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC4            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC4r (0x0001822c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC4r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC4.
 */
typedef union BCMI_MADURA_MST_MISC4r_s {
	uint32_t v[1];
	uint32_t mst_misc4[1];
	uint32_t _mst_misc4;
} BCMI_MADURA_MST_MISC4r_t;

#define BCMI_MADURA_MST_MISC4r_CLR(r) (r).mst_misc4[0] = 0
#define BCMI_MADURA_MST_MISC4r_SET(r,d) (r).mst_misc4[0] = d
#define BCMI_MADURA_MST_MISC4r_GET(r) (r).mst_misc4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC4r_MISC4f_GET(r) (((r).mst_misc4[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC4r_MISC4f_SET(r,f) (r).mst_misc4[0]=(((r).mst_misc4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC4.
 */
#define BCMI_MADURA_READ_MST_MISC4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC4r,_r._mst_misc4)
#define BCMI_MADURA_WRITE_MST_MISC4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC4r,_r._mst_misc4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC4r BCMI_MADURA_MST_MISC4r
#define MST_MISC4r_SIZE BCMI_MADURA_MST_MISC4r_SIZE
typedef BCMI_MADURA_MST_MISC4r_t MST_MISC4r_t;
#define MST_MISC4r_CLR BCMI_MADURA_MST_MISC4r_CLR
#define MST_MISC4r_SET BCMI_MADURA_MST_MISC4r_SET
#define MST_MISC4r_GET BCMI_MADURA_MST_MISC4r_GET
#define MST_MISC4r_MISC4f_GET BCMI_MADURA_MST_MISC4r_MISC4f_GET
#define MST_MISC4r_MISC4f_SET BCMI_MADURA_MST_MISC4r_MISC4f_SET
#define READ_MST_MISC4r BCMI_MADURA_READ_MST_MISC4r
#define WRITE_MST_MISC4r BCMI_MADURA_WRITE_MST_MISC4r
#define MODIFY_MST_MISC4r BCMI_MADURA_MODIFY_MST_MISC4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC5
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x822d
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC5            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC5r (0x0001822d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC5r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC5.
 */
typedef union BCMI_MADURA_MST_MISC5r_s {
	uint32_t v[1];
	uint32_t mst_misc5[1];
	uint32_t _mst_misc5;
} BCMI_MADURA_MST_MISC5r_t;

#define BCMI_MADURA_MST_MISC5r_CLR(r) (r).mst_misc5[0] = 0
#define BCMI_MADURA_MST_MISC5r_SET(r,d) (r).mst_misc5[0] = d
#define BCMI_MADURA_MST_MISC5r_GET(r) (r).mst_misc5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC5r_MISC5f_GET(r) (((r).mst_misc5[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC5r_MISC5f_SET(r,f) (r).mst_misc5[0]=(((r).mst_misc5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC5.
 */
#define BCMI_MADURA_READ_MST_MISC5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC5r,_r._mst_misc5)
#define BCMI_MADURA_WRITE_MST_MISC5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC5r,_r._mst_misc5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC5r BCMI_MADURA_MST_MISC5r
#define MST_MISC5r_SIZE BCMI_MADURA_MST_MISC5r_SIZE
typedef BCMI_MADURA_MST_MISC5r_t MST_MISC5r_t;
#define MST_MISC5r_CLR BCMI_MADURA_MST_MISC5r_CLR
#define MST_MISC5r_SET BCMI_MADURA_MST_MISC5r_SET
#define MST_MISC5r_GET BCMI_MADURA_MST_MISC5r_GET
#define MST_MISC5r_MISC5f_GET BCMI_MADURA_MST_MISC5r_MISC5f_GET
#define MST_MISC5r_MISC5f_SET BCMI_MADURA_MST_MISC5r_MISC5f_SET
#define READ_MST_MISC5r BCMI_MADURA_READ_MST_MISC5r
#define WRITE_MST_MISC5r BCMI_MADURA_WRITE_MST_MISC5r
#define MODIFY_MST_MISC5r BCMI_MADURA_MODIFY_MST_MISC5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC6
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x822e
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC6            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC6r (0x0001822e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC6r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC6.
 */
typedef union BCMI_MADURA_MST_MISC6r_s {
	uint32_t v[1];
	uint32_t mst_misc6[1];
	uint32_t _mst_misc6;
} BCMI_MADURA_MST_MISC6r_t;

#define BCMI_MADURA_MST_MISC6r_CLR(r) (r).mst_misc6[0] = 0
#define BCMI_MADURA_MST_MISC6r_SET(r,d) (r).mst_misc6[0] = d
#define BCMI_MADURA_MST_MISC6r_GET(r) (r).mst_misc6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC6r_MISC6f_GET(r) (((r).mst_misc6[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC6r_MISC6f_SET(r,f) (r).mst_misc6[0]=(((r).mst_misc6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC6.
 */
#define BCMI_MADURA_READ_MST_MISC6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC6r,_r._mst_misc6)
#define BCMI_MADURA_WRITE_MST_MISC6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC6r,_r._mst_misc6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC6r BCMI_MADURA_MST_MISC6r
#define MST_MISC6r_SIZE BCMI_MADURA_MST_MISC6r_SIZE
typedef BCMI_MADURA_MST_MISC6r_t MST_MISC6r_t;
#define MST_MISC6r_CLR BCMI_MADURA_MST_MISC6r_CLR
#define MST_MISC6r_SET BCMI_MADURA_MST_MISC6r_SET
#define MST_MISC6r_GET BCMI_MADURA_MST_MISC6r_GET
#define MST_MISC6r_MISC6f_GET BCMI_MADURA_MST_MISC6r_MISC6f_GET
#define MST_MISC6r_MISC6f_SET BCMI_MADURA_MST_MISC6r_MISC6f_SET
#define READ_MST_MISC6r BCMI_MADURA_READ_MST_MISC6r
#define WRITE_MST_MISC6r BCMI_MADURA_WRITE_MST_MISC6r
#define MODIFY_MST_MISC6r BCMI_MADURA_MODIFY_MST_MISC6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_MISC7
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x822f
 * DEVAD:    1
 * DESC:     Master M0 General purpose miscellaneous register 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISC7            Miscellaneous
 */
#define BCMI_MADURA_MST_MISC7r (0x0001822f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_MISC7r_SIZE 4

/*
 * This structure should be used to declare and program MST_MISC7.
 */
typedef union BCMI_MADURA_MST_MISC7r_s {
	uint32_t v[1];
	uint32_t mst_misc7[1];
	uint32_t _mst_misc7;
} BCMI_MADURA_MST_MISC7r_t;

#define BCMI_MADURA_MST_MISC7r_CLR(r) (r).mst_misc7[0] = 0
#define BCMI_MADURA_MST_MISC7r_SET(r,d) (r).mst_misc7[0] = d
#define BCMI_MADURA_MST_MISC7r_GET(r) (r).mst_misc7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_MISC7r_MISC7f_GET(r) (((r).mst_misc7[0]) & 0xffff)
#define BCMI_MADURA_MST_MISC7r_MISC7f_SET(r,f) (r).mst_misc7[0]=(((r).mst_misc7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_MISC7.
 */
#define BCMI_MADURA_READ_MST_MISC7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_MISC7r,_r._mst_misc7)
#define BCMI_MADURA_WRITE_MST_MISC7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_MISC7r,_r._mst_misc7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_MISC7r BCMI_MADURA_MST_MISC7r
#define MST_MISC7r_SIZE BCMI_MADURA_MST_MISC7r_SIZE
typedef BCMI_MADURA_MST_MISC7r_t MST_MISC7r_t;
#define MST_MISC7r_CLR BCMI_MADURA_MST_MISC7r_CLR
#define MST_MISC7r_SET BCMI_MADURA_MST_MISC7r_SET
#define MST_MISC7r_GET BCMI_MADURA_MST_MISC7r_GET
#define MST_MISC7r_MISC7f_GET BCMI_MADURA_MST_MISC7r_MISC7f_GET
#define MST_MISC7r_MISC7f_SET BCMI_MADURA_MST_MISC7r_MISC7f_SET
#define READ_MST_MISC7r BCMI_MADURA_READ_MST_MISC7r
#define WRITE_MST_MISC7r BCMI_MADURA_WRITE_MST_MISC7r
#define MODIFY_MST_MISC7r BCMI_MADURA_MODIFY_MST_MISC7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_MISC7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV1_RUNNING_CHKSUM
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8230
 * DEVAD:    1
 * DESC:     Master M0 running checksum
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV1_RUNNING_CHKSUM_VAL When slice 0 system side Falcon M0 code is downloaded through mdio or spim the current value of checksum is updated by the boot code in this register.
 */
#define BCMI_MADURA_SLV1_RUNNING_CHKSUMr (0x00018230 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SIZE 4

/*
 * This structure should be used to declare and program SLV1_RUNNING_CHKSUM.
 */
typedef union BCMI_MADURA_SLV1_RUNNING_CHKSUMr_s {
	uint32_t v[1];
	uint32_t slv1_running_chksum[1];
	uint32_t _slv1_running_chksum;
} BCMI_MADURA_SLV1_RUNNING_CHKSUMr_t;

#define BCMI_MADURA_SLV1_RUNNING_CHKSUMr_CLR(r) (r).slv1_running_chksum[0] = 0
#define BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SET(r,d) (r).slv1_running_chksum[0] = d
#define BCMI_MADURA_SLV1_RUNNING_CHKSUMr_GET(r) (r).slv1_running_chksum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SLV1_RUNNING_CHKSUM_VALf_GET(r) (((r).slv1_running_chksum[0]) & 0xffff)
#define BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SLV1_RUNNING_CHKSUM_VALf_SET(r,f) (r).slv1_running_chksum[0]=(((r).slv1_running_chksum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SLV1_RUNNING_CHKSUM.
 */
#define BCMI_MADURA_READ_SLV1_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV1_RUNNING_CHKSUMr,_r._slv1_running_chksum)
#define BCMI_MADURA_WRITE_SLV1_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV1_RUNNING_CHKSUMr,_r._slv1_running_chksum)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV1_RUNNING_CHKSUMr BCMI_MADURA_SLV1_RUNNING_CHKSUMr
#define SLV1_RUNNING_CHKSUMr_SIZE BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SIZE
typedef BCMI_MADURA_SLV1_RUNNING_CHKSUMr_t SLV1_RUNNING_CHKSUMr_t;
#define SLV1_RUNNING_CHKSUMr_CLR BCMI_MADURA_SLV1_RUNNING_CHKSUMr_CLR
#define SLV1_RUNNING_CHKSUMr_SET BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SET
#define SLV1_RUNNING_CHKSUMr_GET BCMI_MADURA_SLV1_RUNNING_CHKSUMr_GET
#define SLV1_RUNNING_CHKSUMr_SLV1_RUNNING_CHKSUM_VALf_GET BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SLV1_RUNNING_CHKSUM_VALf_GET
#define SLV1_RUNNING_CHKSUMr_SLV1_RUNNING_CHKSUM_VALf_SET BCMI_MADURA_SLV1_RUNNING_CHKSUMr_SLV1_RUNNING_CHKSUM_VALf_SET
#define READ_SLV1_RUNNING_CHKSUMr BCMI_MADURA_READ_SLV1_RUNNING_CHKSUMr
#define WRITE_SLV1_RUNNING_CHKSUMr BCMI_MADURA_WRITE_SLV1_RUNNING_CHKSUMr
#define MODIFY_SLV1_RUNNING_CHKSUMr BCMI_MADURA_MODIFY_SLV1_RUNNING_CHKSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV1_RUNNING_CHKSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV2_RUNNING_CHKSUM
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8231
 * DEVAD:    1
 * DESC:     Master M0 running checksum
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV2_RUNNING_CHKSUM_VAL When slice 0 line side Falcon M0 code is downloaded through mdio or spim the current value of checksum is updated by the boot code in this register.
 */
#define BCMI_MADURA_SLV2_RUNNING_CHKSUMr (0x00018231 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SIZE 4

/*
 * This structure should be used to declare and program SLV2_RUNNING_CHKSUM.
 */
typedef union BCMI_MADURA_SLV2_RUNNING_CHKSUMr_s {
	uint32_t v[1];
	uint32_t slv2_running_chksum[1];
	uint32_t _slv2_running_chksum;
} BCMI_MADURA_SLV2_RUNNING_CHKSUMr_t;

#define BCMI_MADURA_SLV2_RUNNING_CHKSUMr_CLR(r) (r).slv2_running_chksum[0] = 0
#define BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SET(r,d) (r).slv2_running_chksum[0] = d
#define BCMI_MADURA_SLV2_RUNNING_CHKSUMr_GET(r) (r).slv2_running_chksum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SLV2_RUNNING_CHKSUM_VALf_GET(r) (((r).slv2_running_chksum[0]) & 0xffff)
#define BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SLV2_RUNNING_CHKSUM_VALf_SET(r,f) (r).slv2_running_chksum[0]=(((r).slv2_running_chksum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SLV2_RUNNING_CHKSUM.
 */
#define BCMI_MADURA_READ_SLV2_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV2_RUNNING_CHKSUMr,_r._slv2_running_chksum)
#define BCMI_MADURA_WRITE_SLV2_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV2_RUNNING_CHKSUMr,_r._slv2_running_chksum)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV2_RUNNING_CHKSUMr BCMI_MADURA_SLV2_RUNNING_CHKSUMr
#define SLV2_RUNNING_CHKSUMr_SIZE BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SIZE
typedef BCMI_MADURA_SLV2_RUNNING_CHKSUMr_t SLV2_RUNNING_CHKSUMr_t;
#define SLV2_RUNNING_CHKSUMr_CLR BCMI_MADURA_SLV2_RUNNING_CHKSUMr_CLR
#define SLV2_RUNNING_CHKSUMr_SET BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SET
#define SLV2_RUNNING_CHKSUMr_GET BCMI_MADURA_SLV2_RUNNING_CHKSUMr_GET
#define SLV2_RUNNING_CHKSUMr_SLV2_RUNNING_CHKSUM_VALf_GET BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SLV2_RUNNING_CHKSUM_VALf_GET
#define SLV2_RUNNING_CHKSUMr_SLV2_RUNNING_CHKSUM_VALf_SET BCMI_MADURA_SLV2_RUNNING_CHKSUMr_SLV2_RUNNING_CHKSUM_VALf_SET
#define READ_SLV2_RUNNING_CHKSUMr BCMI_MADURA_READ_SLV2_RUNNING_CHKSUMr
#define WRITE_SLV2_RUNNING_CHKSUMr BCMI_MADURA_WRITE_SLV2_RUNNING_CHKSUMr
#define MODIFY_SLV2_RUNNING_CHKSUMr BCMI_MADURA_MODIFY_SLV2_RUNNING_CHKSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV2_RUNNING_CHKSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV3_RUNNING_CHKSUM
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8232
 * DEVAD:    1
 * DESC:     Master M0 running checksum
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV3_RUNNING_CHKSUM_VAL When slice 1 system side Falcon M0 code is downloaded through mdio or spim the current value of checksum is updated by the boot code in this register.
 */
#define BCMI_MADURA_SLV3_RUNNING_CHKSUMr (0x00018232 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SIZE 4

/*
 * This structure should be used to declare and program SLV3_RUNNING_CHKSUM.
 */
typedef union BCMI_MADURA_SLV3_RUNNING_CHKSUMr_s {
	uint32_t v[1];
	uint32_t slv3_running_chksum[1];
	uint32_t _slv3_running_chksum;
} BCMI_MADURA_SLV3_RUNNING_CHKSUMr_t;

#define BCMI_MADURA_SLV3_RUNNING_CHKSUMr_CLR(r) (r).slv3_running_chksum[0] = 0
#define BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SET(r,d) (r).slv3_running_chksum[0] = d
#define BCMI_MADURA_SLV3_RUNNING_CHKSUMr_GET(r) (r).slv3_running_chksum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SLV3_RUNNING_CHKSUM_VALf_GET(r) (((r).slv3_running_chksum[0]) & 0xffff)
#define BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SLV3_RUNNING_CHKSUM_VALf_SET(r,f) (r).slv3_running_chksum[0]=(((r).slv3_running_chksum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SLV3_RUNNING_CHKSUM.
 */
#define BCMI_MADURA_READ_SLV3_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV3_RUNNING_CHKSUMr,_r._slv3_running_chksum)
#define BCMI_MADURA_WRITE_SLV3_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV3_RUNNING_CHKSUMr,_r._slv3_running_chksum)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV3_RUNNING_CHKSUMr BCMI_MADURA_SLV3_RUNNING_CHKSUMr
#define SLV3_RUNNING_CHKSUMr_SIZE BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SIZE
typedef BCMI_MADURA_SLV3_RUNNING_CHKSUMr_t SLV3_RUNNING_CHKSUMr_t;
#define SLV3_RUNNING_CHKSUMr_CLR BCMI_MADURA_SLV3_RUNNING_CHKSUMr_CLR
#define SLV3_RUNNING_CHKSUMr_SET BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SET
#define SLV3_RUNNING_CHKSUMr_GET BCMI_MADURA_SLV3_RUNNING_CHKSUMr_GET
#define SLV3_RUNNING_CHKSUMr_SLV3_RUNNING_CHKSUM_VALf_GET BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SLV3_RUNNING_CHKSUM_VALf_GET
#define SLV3_RUNNING_CHKSUMr_SLV3_RUNNING_CHKSUM_VALf_SET BCMI_MADURA_SLV3_RUNNING_CHKSUMr_SLV3_RUNNING_CHKSUM_VALf_SET
#define READ_SLV3_RUNNING_CHKSUMr BCMI_MADURA_READ_SLV3_RUNNING_CHKSUMr
#define WRITE_SLV3_RUNNING_CHKSUMr BCMI_MADURA_WRITE_SLV3_RUNNING_CHKSUMr
#define MODIFY_SLV3_RUNNING_CHKSUMr BCMI_MADURA_MODIFY_SLV3_RUNNING_CHKSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV3_RUNNING_CHKSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV4_RUNNING_CHKSUM
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8233
 * DEVAD:    1
 * DESC:     Master M0 running checksum
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV4_RUNNING_CHKSUM_VAL When slice 1 line side Falcon M0 code is downloaded through mdio or spim the current value of checksum is updated by the boot code in this register.
 */
#define BCMI_MADURA_SLV4_RUNNING_CHKSUMr (0x00018233 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SIZE 4

/*
 * This structure should be used to declare and program SLV4_RUNNING_CHKSUM.
 */
typedef union BCMI_MADURA_SLV4_RUNNING_CHKSUMr_s {
	uint32_t v[1];
	uint32_t slv4_running_chksum[1];
	uint32_t _slv4_running_chksum;
} BCMI_MADURA_SLV4_RUNNING_CHKSUMr_t;

#define BCMI_MADURA_SLV4_RUNNING_CHKSUMr_CLR(r) (r).slv4_running_chksum[0] = 0
#define BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SET(r,d) (r).slv4_running_chksum[0] = d
#define BCMI_MADURA_SLV4_RUNNING_CHKSUMr_GET(r) (r).slv4_running_chksum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SLV4_RUNNING_CHKSUM_VALf_GET(r) (((r).slv4_running_chksum[0]) & 0xffff)
#define BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SLV4_RUNNING_CHKSUM_VALf_SET(r,f) (r).slv4_running_chksum[0]=(((r).slv4_running_chksum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SLV4_RUNNING_CHKSUM.
 */
#define BCMI_MADURA_READ_SLV4_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV4_RUNNING_CHKSUMr,_r._slv4_running_chksum)
#define BCMI_MADURA_WRITE_SLV4_RUNNING_CHKSUMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV4_RUNNING_CHKSUMr,_r._slv4_running_chksum)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV4_RUNNING_CHKSUMr BCMI_MADURA_SLV4_RUNNING_CHKSUMr
#define SLV4_RUNNING_CHKSUMr_SIZE BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SIZE
typedef BCMI_MADURA_SLV4_RUNNING_CHKSUMr_t SLV4_RUNNING_CHKSUMr_t;
#define SLV4_RUNNING_CHKSUMr_CLR BCMI_MADURA_SLV4_RUNNING_CHKSUMr_CLR
#define SLV4_RUNNING_CHKSUMr_SET BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SET
#define SLV4_RUNNING_CHKSUMr_GET BCMI_MADURA_SLV4_RUNNING_CHKSUMr_GET
#define SLV4_RUNNING_CHKSUMr_SLV4_RUNNING_CHKSUM_VALf_GET BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SLV4_RUNNING_CHKSUM_VALf_GET
#define SLV4_RUNNING_CHKSUMr_SLV4_RUNNING_CHKSUM_VALf_SET BCMI_MADURA_SLV4_RUNNING_CHKSUMr_SLV4_RUNNING_CHKSUM_VALf_SET
#define READ_SLV4_RUNNING_CHKSUMr BCMI_MADURA_READ_SLV4_RUNNING_CHKSUMr
#define WRITE_SLV4_RUNNING_CHKSUMr BCMI_MADURA_WRITE_SLV4_RUNNING_CHKSUMr
#define MODIFY_SLV4_RUNNING_CHKSUMr BCMI_MADURA_MODIFY_SLV4_RUNNING_CHKSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV4_RUNNING_CHKSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SLV_RUNNING_BYTE_CNT
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8235
 * DEVAD:    1
 * DESC:     Master M0 running byte count
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLV_RUNNING_BYTE_CNT_VAL When slave m0 code is downloaded through mdio, the current value of accumulated bytes is updated by the boot code in this register.
 */
#define BCMI_MADURA_SLV_RUNNING_BYTE_CNTr (0x00018235 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SLV_RUNNING_BYTE_CNT.
 */
typedef union BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_s {
	uint32_t v[1];
	uint32_t slv_running_byte_cnt[1];
	uint32_t _slv_running_byte_cnt;
} BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_t;

#define BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_CLR(r) (r).slv_running_byte_cnt[0] = 0
#define BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SET(r,d) (r).slv_running_byte_cnt[0] = d
#define BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_GET(r) (r).slv_running_byte_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SLV_RUNNING_BYTE_CNT_VALf_GET(r) (((r).slv_running_byte_cnt[0]) & 0xffff)
#define BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SLV_RUNNING_BYTE_CNT_VALf_SET(r,f) (r).slv_running_byte_cnt[0]=(((r).slv_running_byte_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SLV_RUNNING_BYTE_CNT.
 */
#define BCMI_MADURA_READ_SLV_RUNNING_BYTE_CNTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SLV_RUNNING_BYTE_CNTr,_r._slv_running_byte_cnt)
#define BCMI_MADURA_WRITE_SLV_RUNNING_BYTE_CNTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SLV_RUNNING_BYTE_CNTr,_r._slv_running_byte_cnt)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SLV_RUNNING_BYTE_CNTr BCMI_MADURA_SLV_RUNNING_BYTE_CNTr
#define SLV_RUNNING_BYTE_CNTr_SIZE BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SIZE
typedef BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_t SLV_RUNNING_BYTE_CNTr_t;
#define SLV_RUNNING_BYTE_CNTr_CLR BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_CLR
#define SLV_RUNNING_BYTE_CNTr_SET BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SET
#define SLV_RUNNING_BYTE_CNTr_GET BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_GET
#define SLV_RUNNING_BYTE_CNTr_SLV_RUNNING_BYTE_CNT_VALf_GET BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SLV_RUNNING_BYTE_CNT_VALf_GET
#define SLV_RUNNING_BYTE_CNTr_SLV_RUNNING_BYTE_CNT_VALf_SET BCMI_MADURA_SLV_RUNNING_BYTE_CNTr_SLV_RUNNING_BYTE_CNT_VALf_SET
#define READ_SLV_RUNNING_BYTE_CNTr BCMI_MADURA_READ_SLV_RUNNING_BYTE_CNTr
#define WRITE_SLV_RUNNING_BYTE_CNTr BCMI_MADURA_WRITE_SLV_RUNNING_BYTE_CNTr
#define MODIFY_SLV_RUNNING_BYTE_CNTr BCMI_MADURA_MODIFY_SLV_RUNNING_BYTE_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SLV_RUNNING_BYTE_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG0
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8260
 * DEVAD:    1
 * DESC:     General purpose register 0 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG0_DATA      Data
 */
#define BCMI_MADURA_GPREG0r (0x00018260 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG0r_SIZE 4

/*
 * This structure should be used to declare and program GPREG0.
 */
typedef union BCMI_MADURA_GPREG0r_s {
	uint32_t v[1];
	uint32_t gpreg0[1];
	uint32_t _gpreg0;
} BCMI_MADURA_GPREG0r_t;

#define BCMI_MADURA_GPREG0r_CLR(r) (r).gpreg0[0] = 0
#define BCMI_MADURA_GPREG0r_SET(r,d) (r).gpreg0[0] = d
#define BCMI_MADURA_GPREG0r_GET(r) (r).gpreg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG0r_GPREG0_DATAf_GET(r) (((r).gpreg0[0]) & 0xffff)
#define BCMI_MADURA_GPREG0r_GPREG0_DATAf_SET(r,f) (r).gpreg0[0]=(((r).gpreg0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG0.
 */
#define BCMI_MADURA_READ_GPREG0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG0r,_r._gpreg0)
#define BCMI_MADURA_WRITE_GPREG0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG0r,_r._gpreg0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG0r BCMI_MADURA_GPREG0r
#define GPREG0r_SIZE BCMI_MADURA_GPREG0r_SIZE
typedef BCMI_MADURA_GPREG0r_t GPREG0r_t;
#define GPREG0r_CLR BCMI_MADURA_GPREG0r_CLR
#define GPREG0r_SET BCMI_MADURA_GPREG0r_SET
#define GPREG0r_GET BCMI_MADURA_GPREG0r_GET
#define GPREG0r_GPREG0_DATAf_GET BCMI_MADURA_GPREG0r_GPREG0_DATAf_GET
#define GPREG0r_GPREG0_DATAf_SET BCMI_MADURA_GPREG0r_GPREG0_DATAf_SET
#define READ_GPREG0r BCMI_MADURA_READ_GPREG0r
#define WRITE_GPREG0r BCMI_MADURA_WRITE_GPREG0r
#define MODIFY_GPREG0r BCMI_MADURA_MODIFY_GPREG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG1
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8261
 * DEVAD:    1
 * DESC:     General purpose register 1 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG1_DATA      Data
 */
#define BCMI_MADURA_GPREG1r (0x00018261 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG1r_SIZE 4

/*
 * This structure should be used to declare and program GPREG1.
 */
typedef union BCMI_MADURA_GPREG1r_s {
	uint32_t v[1];
	uint32_t gpreg1[1];
	uint32_t _gpreg1;
} BCMI_MADURA_GPREG1r_t;

#define BCMI_MADURA_GPREG1r_CLR(r) (r).gpreg1[0] = 0
#define BCMI_MADURA_GPREG1r_SET(r,d) (r).gpreg1[0] = d
#define BCMI_MADURA_GPREG1r_GET(r) (r).gpreg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG1r_GPREG1_DATAf_GET(r) (((r).gpreg1[0]) & 0xffff)
#define BCMI_MADURA_GPREG1r_GPREG1_DATAf_SET(r,f) (r).gpreg1[0]=(((r).gpreg1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG1.
 */
#define BCMI_MADURA_READ_GPREG1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG1r,_r._gpreg1)
#define BCMI_MADURA_WRITE_GPREG1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG1r,_r._gpreg1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG1r BCMI_MADURA_GPREG1r
#define GPREG1r_SIZE BCMI_MADURA_GPREG1r_SIZE
typedef BCMI_MADURA_GPREG1r_t GPREG1r_t;
#define GPREG1r_CLR BCMI_MADURA_GPREG1r_CLR
#define GPREG1r_SET BCMI_MADURA_GPREG1r_SET
#define GPREG1r_GET BCMI_MADURA_GPREG1r_GET
#define GPREG1r_GPREG1_DATAf_GET BCMI_MADURA_GPREG1r_GPREG1_DATAf_GET
#define GPREG1r_GPREG1_DATAf_SET BCMI_MADURA_GPREG1r_GPREG1_DATAf_SET
#define READ_GPREG1r BCMI_MADURA_READ_GPREG1r
#define WRITE_GPREG1r BCMI_MADURA_WRITE_GPREG1r
#define MODIFY_GPREG1r BCMI_MADURA_MODIFY_GPREG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG2
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8262
 * DEVAD:    1
 * DESC:     General purpose register 2 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG2_DATA      Data
 */
#define BCMI_MADURA_GPREG2r (0x00018262 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG2r_SIZE 4

/*
 * This structure should be used to declare and program GPREG2.
 */
typedef union BCMI_MADURA_GPREG2r_s {
	uint32_t v[1];
	uint32_t gpreg2[1];
	uint32_t _gpreg2;
} BCMI_MADURA_GPREG2r_t;

#define BCMI_MADURA_GPREG2r_CLR(r) (r).gpreg2[0] = 0
#define BCMI_MADURA_GPREG2r_SET(r,d) (r).gpreg2[0] = d
#define BCMI_MADURA_GPREG2r_GET(r) (r).gpreg2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG2r_GPREG2_DATAf_GET(r) (((r).gpreg2[0]) & 0xffff)
#define BCMI_MADURA_GPREG2r_GPREG2_DATAf_SET(r,f) (r).gpreg2[0]=(((r).gpreg2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG2.
 */
#define BCMI_MADURA_READ_GPREG2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG2r,_r._gpreg2)
#define BCMI_MADURA_WRITE_GPREG2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG2r,_r._gpreg2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG2r BCMI_MADURA_GPREG2r
#define GPREG2r_SIZE BCMI_MADURA_GPREG2r_SIZE
typedef BCMI_MADURA_GPREG2r_t GPREG2r_t;
#define GPREG2r_CLR BCMI_MADURA_GPREG2r_CLR
#define GPREG2r_SET BCMI_MADURA_GPREG2r_SET
#define GPREG2r_GET BCMI_MADURA_GPREG2r_GET
#define GPREG2r_GPREG2_DATAf_GET BCMI_MADURA_GPREG2r_GPREG2_DATAf_GET
#define GPREG2r_GPREG2_DATAf_SET BCMI_MADURA_GPREG2r_GPREG2_DATAf_SET
#define READ_GPREG2r BCMI_MADURA_READ_GPREG2r
#define WRITE_GPREG2r BCMI_MADURA_WRITE_GPREG2r
#define MODIFY_GPREG2r BCMI_MADURA_MODIFY_GPREG2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG3
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8263
 * DEVAD:    1
 * DESC:     General purpose register 3 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG3_DATA      Data
 */
#define BCMI_MADURA_GPREG3r (0x00018263 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG3r_SIZE 4

/*
 * This structure should be used to declare and program GPREG3.
 */
typedef union BCMI_MADURA_GPREG3r_s {
	uint32_t v[1];
	uint32_t gpreg3[1];
	uint32_t _gpreg3;
} BCMI_MADURA_GPREG3r_t;

#define BCMI_MADURA_GPREG3r_CLR(r) (r).gpreg3[0] = 0
#define BCMI_MADURA_GPREG3r_SET(r,d) (r).gpreg3[0] = d
#define BCMI_MADURA_GPREG3r_GET(r) (r).gpreg3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG3r_GPREG3_DATAf_GET(r) (((r).gpreg3[0]) & 0xffff)
#define BCMI_MADURA_GPREG3r_GPREG3_DATAf_SET(r,f) (r).gpreg3[0]=(((r).gpreg3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG3.
 */
#define BCMI_MADURA_READ_GPREG3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG3r,_r._gpreg3)
#define BCMI_MADURA_WRITE_GPREG3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG3r,_r._gpreg3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG3r BCMI_MADURA_GPREG3r
#define GPREG3r_SIZE BCMI_MADURA_GPREG3r_SIZE
typedef BCMI_MADURA_GPREG3r_t GPREG3r_t;
#define GPREG3r_CLR BCMI_MADURA_GPREG3r_CLR
#define GPREG3r_SET BCMI_MADURA_GPREG3r_SET
#define GPREG3r_GET BCMI_MADURA_GPREG3r_GET
#define GPREG3r_GPREG3_DATAf_GET BCMI_MADURA_GPREG3r_GPREG3_DATAf_GET
#define GPREG3r_GPREG3_DATAf_SET BCMI_MADURA_GPREG3r_GPREG3_DATAf_SET
#define READ_GPREG3r BCMI_MADURA_READ_GPREG3r
#define WRITE_GPREG3r BCMI_MADURA_WRITE_GPREG3r
#define MODIFY_GPREG3r BCMI_MADURA_MODIFY_GPREG3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG4
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8264
 * DEVAD:    1
 * DESC:     General purpose register 4 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG4_DATA      Data
 */
#define BCMI_MADURA_GPREG4r (0x00018264 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG4r_SIZE 4

/*
 * This structure should be used to declare and program GPREG4.
 */
typedef union BCMI_MADURA_GPREG4r_s {
	uint32_t v[1];
	uint32_t gpreg4[1];
	uint32_t _gpreg4;
} BCMI_MADURA_GPREG4r_t;

#define BCMI_MADURA_GPREG4r_CLR(r) (r).gpreg4[0] = 0
#define BCMI_MADURA_GPREG4r_SET(r,d) (r).gpreg4[0] = d
#define BCMI_MADURA_GPREG4r_GET(r) (r).gpreg4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG4r_GPREG4_DATAf_GET(r) (((r).gpreg4[0]) & 0xffff)
#define BCMI_MADURA_GPREG4r_GPREG4_DATAf_SET(r,f) (r).gpreg4[0]=(((r).gpreg4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG4.
 */
#define BCMI_MADURA_READ_GPREG4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG4r,_r._gpreg4)
#define BCMI_MADURA_WRITE_GPREG4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG4r,_r._gpreg4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG4r BCMI_MADURA_GPREG4r
#define GPREG4r_SIZE BCMI_MADURA_GPREG4r_SIZE
typedef BCMI_MADURA_GPREG4r_t GPREG4r_t;
#define GPREG4r_CLR BCMI_MADURA_GPREG4r_CLR
#define GPREG4r_SET BCMI_MADURA_GPREG4r_SET
#define GPREG4r_GET BCMI_MADURA_GPREG4r_GET
#define GPREG4r_GPREG4_DATAf_GET BCMI_MADURA_GPREG4r_GPREG4_DATAf_GET
#define GPREG4r_GPREG4_DATAf_SET BCMI_MADURA_GPREG4r_GPREG4_DATAf_SET
#define READ_GPREG4r BCMI_MADURA_READ_GPREG4r
#define WRITE_GPREG4r BCMI_MADURA_WRITE_GPREG4r
#define MODIFY_GPREG4r BCMI_MADURA_MODIFY_GPREG4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG5
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8265
 * DEVAD:    1
 * DESC:     General purpose register 5 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG5_DATA      Data
 */
#define BCMI_MADURA_GPREG5r (0x00018265 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG5r_SIZE 4

/*
 * This structure should be used to declare and program GPREG5.
 */
typedef union BCMI_MADURA_GPREG5r_s {
	uint32_t v[1];
	uint32_t gpreg5[1];
	uint32_t _gpreg5;
} BCMI_MADURA_GPREG5r_t;

#define BCMI_MADURA_GPREG5r_CLR(r) (r).gpreg5[0] = 0
#define BCMI_MADURA_GPREG5r_SET(r,d) (r).gpreg5[0] = d
#define BCMI_MADURA_GPREG5r_GET(r) (r).gpreg5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG5r_GPREG5_DATAf_GET(r) (((r).gpreg5[0]) & 0xffff)
#define BCMI_MADURA_GPREG5r_GPREG5_DATAf_SET(r,f) (r).gpreg5[0]=(((r).gpreg5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG5.
 */
#define BCMI_MADURA_READ_GPREG5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG5r,_r._gpreg5)
#define BCMI_MADURA_WRITE_GPREG5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG5r,_r._gpreg5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG5r BCMI_MADURA_GPREG5r
#define GPREG5r_SIZE BCMI_MADURA_GPREG5r_SIZE
typedef BCMI_MADURA_GPREG5r_t GPREG5r_t;
#define GPREG5r_CLR BCMI_MADURA_GPREG5r_CLR
#define GPREG5r_SET BCMI_MADURA_GPREG5r_SET
#define GPREG5r_GET BCMI_MADURA_GPREG5r_GET
#define GPREG5r_GPREG5_DATAf_GET BCMI_MADURA_GPREG5r_GPREG5_DATAf_GET
#define GPREG5r_GPREG5_DATAf_SET BCMI_MADURA_GPREG5r_GPREG5_DATAf_SET
#define READ_GPREG5r BCMI_MADURA_READ_GPREG5r
#define WRITE_GPREG5r BCMI_MADURA_WRITE_GPREG5r
#define MODIFY_GPREG5r BCMI_MADURA_MODIFY_GPREG5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG6
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8266
 * DEVAD:    1
 * DESC:     General purpose register 6 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG6_DATA      Data
 */
#define BCMI_MADURA_GPREG6r (0x00018266 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG6r_SIZE 4

/*
 * This structure should be used to declare and program GPREG6.
 */
typedef union BCMI_MADURA_GPREG6r_s {
	uint32_t v[1];
	uint32_t gpreg6[1];
	uint32_t _gpreg6;
} BCMI_MADURA_GPREG6r_t;

#define BCMI_MADURA_GPREG6r_CLR(r) (r).gpreg6[0] = 0
#define BCMI_MADURA_GPREG6r_SET(r,d) (r).gpreg6[0] = d
#define BCMI_MADURA_GPREG6r_GET(r) (r).gpreg6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG6r_GPREG6_DATAf_GET(r) (((r).gpreg6[0]) & 0xffff)
#define BCMI_MADURA_GPREG6r_GPREG6_DATAf_SET(r,f) (r).gpreg6[0]=(((r).gpreg6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG6.
 */
#define BCMI_MADURA_READ_GPREG6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG6r,_r._gpreg6)
#define BCMI_MADURA_WRITE_GPREG6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG6r,_r._gpreg6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG6r BCMI_MADURA_GPREG6r
#define GPREG6r_SIZE BCMI_MADURA_GPREG6r_SIZE
typedef BCMI_MADURA_GPREG6r_t GPREG6r_t;
#define GPREG6r_CLR BCMI_MADURA_GPREG6r_CLR
#define GPREG6r_SET BCMI_MADURA_GPREG6r_SET
#define GPREG6r_GET BCMI_MADURA_GPREG6r_GET
#define GPREG6r_GPREG6_DATAf_GET BCMI_MADURA_GPREG6r_GPREG6_DATAf_GET
#define GPREG6r_GPREG6_DATAf_SET BCMI_MADURA_GPREG6r_GPREG6_DATAf_SET
#define READ_GPREG6r BCMI_MADURA_READ_GPREG6r
#define WRITE_GPREG6r BCMI_MADURA_WRITE_GPREG6r
#define MODIFY_GPREG6r BCMI_MADURA_MODIFY_GPREG6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG7
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8267
 * DEVAD:    1
 * DESC:     General purpose register 7 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG7_DATA      Data
 */
#define BCMI_MADURA_GPREG7r (0x00018267 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG7r_SIZE 4

/*
 * This structure should be used to declare and program GPREG7.
 */
typedef union BCMI_MADURA_GPREG7r_s {
	uint32_t v[1];
	uint32_t gpreg7[1];
	uint32_t _gpreg7;
} BCMI_MADURA_GPREG7r_t;

#define BCMI_MADURA_GPREG7r_CLR(r) (r).gpreg7[0] = 0
#define BCMI_MADURA_GPREG7r_SET(r,d) (r).gpreg7[0] = d
#define BCMI_MADURA_GPREG7r_GET(r) (r).gpreg7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG7r_GPREG7_DATAf_GET(r) (((r).gpreg7[0]) & 0xffff)
#define BCMI_MADURA_GPREG7r_GPREG7_DATAf_SET(r,f) (r).gpreg7[0]=(((r).gpreg7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG7.
 */
#define BCMI_MADURA_READ_GPREG7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG7r,_r._gpreg7)
#define BCMI_MADURA_WRITE_GPREG7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG7r,_r._gpreg7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG7r BCMI_MADURA_GPREG7r
#define GPREG7r_SIZE BCMI_MADURA_GPREG7r_SIZE
typedef BCMI_MADURA_GPREG7r_t GPREG7r_t;
#define GPREG7r_CLR BCMI_MADURA_GPREG7r_CLR
#define GPREG7r_SET BCMI_MADURA_GPREG7r_SET
#define GPREG7r_GET BCMI_MADURA_GPREG7r_GET
#define GPREG7r_GPREG7_DATAf_GET BCMI_MADURA_GPREG7r_GPREG7_DATAf_GET
#define GPREG7r_GPREG7_DATAf_SET BCMI_MADURA_GPREG7r_GPREG7_DATAf_SET
#define READ_GPREG7r BCMI_MADURA_READ_GPREG7r
#define WRITE_GPREG7r BCMI_MADURA_WRITE_GPREG7r
#define MODIFY_GPREG7r BCMI_MADURA_MODIFY_GPREG7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG8
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8268
 * DEVAD:    1
 * DESC:     General purpose register 8 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG8_DATA      Data
 */
#define BCMI_MADURA_GPREG8r (0x00018268 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG8r_SIZE 4

/*
 * This structure should be used to declare and program GPREG8.
 */
typedef union BCMI_MADURA_GPREG8r_s {
	uint32_t v[1];
	uint32_t gpreg8[1];
	uint32_t _gpreg8;
} BCMI_MADURA_GPREG8r_t;

#define BCMI_MADURA_GPREG8r_CLR(r) (r).gpreg8[0] = 0
#define BCMI_MADURA_GPREG8r_SET(r,d) (r).gpreg8[0] = d
#define BCMI_MADURA_GPREG8r_GET(r) (r).gpreg8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG8r_GPREG8_DATAf_GET(r) (((r).gpreg8[0]) & 0xffff)
#define BCMI_MADURA_GPREG8r_GPREG8_DATAf_SET(r,f) (r).gpreg8[0]=(((r).gpreg8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG8.
 */
#define BCMI_MADURA_READ_GPREG8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG8r,_r._gpreg8)
#define BCMI_MADURA_WRITE_GPREG8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG8r,_r._gpreg8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG8r BCMI_MADURA_GPREG8r
#define GPREG8r_SIZE BCMI_MADURA_GPREG8r_SIZE
typedef BCMI_MADURA_GPREG8r_t GPREG8r_t;
#define GPREG8r_CLR BCMI_MADURA_GPREG8r_CLR
#define GPREG8r_SET BCMI_MADURA_GPREG8r_SET
#define GPREG8r_GET BCMI_MADURA_GPREG8r_GET
#define GPREG8r_GPREG8_DATAf_GET BCMI_MADURA_GPREG8r_GPREG8_DATAf_GET
#define GPREG8r_GPREG8_DATAf_SET BCMI_MADURA_GPREG8r_GPREG8_DATAf_SET
#define READ_GPREG8r BCMI_MADURA_READ_GPREG8r
#define WRITE_GPREG8r BCMI_MADURA_WRITE_GPREG8r
#define MODIFY_GPREG8r BCMI_MADURA_MODIFY_GPREG8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREG9
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8269
 * DEVAD:    1
 * DESC:     General purpose register 9 for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG9_DATA      Data
 */
#define BCMI_MADURA_GPREG9r (0x00018269 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREG9r_SIZE 4

/*
 * This structure should be used to declare and program GPREG9.
 */
typedef union BCMI_MADURA_GPREG9r_s {
	uint32_t v[1];
	uint32_t gpreg9[1];
	uint32_t _gpreg9;
} BCMI_MADURA_GPREG9r_t;

#define BCMI_MADURA_GPREG9r_CLR(r) (r).gpreg9[0] = 0
#define BCMI_MADURA_GPREG9r_SET(r,d) (r).gpreg9[0] = d
#define BCMI_MADURA_GPREG9r_GET(r) (r).gpreg9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREG9r_GPREG9_DATAf_GET(r) (((r).gpreg9[0]) & 0xffff)
#define BCMI_MADURA_GPREG9r_GPREG9_DATAf_SET(r,f) (r).gpreg9[0]=(((r).gpreg9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREG9.
 */
#define BCMI_MADURA_READ_GPREG9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREG9r,_r._gpreg9)
#define BCMI_MADURA_WRITE_GPREG9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREG9r,_r._gpreg9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREG9r BCMI_MADURA_GPREG9r
#define GPREG9r_SIZE BCMI_MADURA_GPREG9r_SIZE
typedef BCMI_MADURA_GPREG9r_t GPREG9r_t;
#define GPREG9r_CLR BCMI_MADURA_GPREG9r_CLR
#define GPREG9r_SET BCMI_MADURA_GPREG9r_SET
#define GPREG9r_GET BCMI_MADURA_GPREG9r_GET
#define GPREG9r_GPREG9_DATAf_GET BCMI_MADURA_GPREG9r_GPREG9_DATAf_GET
#define GPREG9r_GPREG9_DATAf_SET BCMI_MADURA_GPREG9r_GPREG9_DATAf_SET
#define READ_GPREG9r BCMI_MADURA_READ_GPREG9r
#define WRITE_GPREG9r BCMI_MADURA_WRITE_GPREG9r
#define MODIFY_GPREG9r BCMI_MADURA_MODIFY_GPREG9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREG9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREGA
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x826a
 * DEVAD:    1
 * DESC:     General purpose register A for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREGA_DATA      Data
 */
#define BCMI_MADURA_GPREGAr (0x0001826a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREGAr_SIZE 4

/*
 * This structure should be used to declare and program GPREGA.
 */
typedef union BCMI_MADURA_GPREGAr_s {
	uint32_t v[1];
	uint32_t gprega[1];
	uint32_t _gprega;
} BCMI_MADURA_GPREGAr_t;

#define BCMI_MADURA_GPREGAr_CLR(r) (r).gprega[0] = 0
#define BCMI_MADURA_GPREGAr_SET(r,d) (r).gprega[0] = d
#define BCMI_MADURA_GPREGAr_GET(r) (r).gprega[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREGAr_GPREGA_DATAf_GET(r) (((r).gprega[0]) & 0xffff)
#define BCMI_MADURA_GPREGAr_GPREGA_DATAf_SET(r,f) (r).gprega[0]=(((r).gprega[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREGA.
 */
#define BCMI_MADURA_READ_GPREGAr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREGAr,_r._gprega)
#define BCMI_MADURA_WRITE_GPREGAr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREGAr,_r._gprega)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREGAr BCMI_MADURA_GPREGAr
#define GPREGAr_SIZE BCMI_MADURA_GPREGAr_SIZE
typedef BCMI_MADURA_GPREGAr_t GPREGAr_t;
#define GPREGAr_CLR BCMI_MADURA_GPREGAr_CLR
#define GPREGAr_SET BCMI_MADURA_GPREGAr_SET
#define GPREGAr_GET BCMI_MADURA_GPREGAr_GET
#define GPREGAr_GPREGA_DATAf_GET BCMI_MADURA_GPREGAr_GPREGA_DATAf_GET
#define GPREGAr_GPREGA_DATAf_SET BCMI_MADURA_GPREGAr_GPREGA_DATAf_SET
#define READ_GPREGAr BCMI_MADURA_READ_GPREGAr
#define WRITE_GPREGAr BCMI_MADURA_WRITE_GPREGAr
#define MODIFY_GPREGAr BCMI_MADURA_MODIFY_GPREGAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREGAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREGB
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x826b
 * DEVAD:    1
 * DESC:     General purpose register B for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREGB_DATA      Data
 */
#define BCMI_MADURA_GPREGBr (0x0001826b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREGBr_SIZE 4

/*
 * This structure should be used to declare and program GPREGB.
 */
typedef union BCMI_MADURA_GPREGBr_s {
	uint32_t v[1];
	uint32_t gpregb[1];
	uint32_t _gpregb;
} BCMI_MADURA_GPREGBr_t;

#define BCMI_MADURA_GPREGBr_CLR(r) (r).gpregb[0] = 0
#define BCMI_MADURA_GPREGBr_SET(r,d) (r).gpregb[0] = d
#define BCMI_MADURA_GPREGBr_GET(r) (r).gpregb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREGBr_GPREGB_DATAf_GET(r) (((r).gpregb[0]) & 0xffff)
#define BCMI_MADURA_GPREGBr_GPREGB_DATAf_SET(r,f) (r).gpregb[0]=(((r).gpregb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREGB.
 */
#define BCMI_MADURA_READ_GPREGBr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREGBr,_r._gpregb)
#define BCMI_MADURA_WRITE_GPREGBr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREGBr,_r._gpregb)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREGBr BCMI_MADURA_GPREGBr
#define GPREGBr_SIZE BCMI_MADURA_GPREGBr_SIZE
typedef BCMI_MADURA_GPREGBr_t GPREGBr_t;
#define GPREGBr_CLR BCMI_MADURA_GPREGBr_CLR
#define GPREGBr_SET BCMI_MADURA_GPREGBr_SET
#define GPREGBr_GET BCMI_MADURA_GPREGBr_GET
#define GPREGBr_GPREGB_DATAf_GET BCMI_MADURA_GPREGBr_GPREGB_DATAf_GET
#define GPREGBr_GPREGB_DATAf_SET BCMI_MADURA_GPREGBr_GPREGB_DATAf_SET
#define READ_GPREGBr BCMI_MADURA_READ_GPREGBr
#define WRITE_GPREGBr BCMI_MADURA_WRITE_GPREGBr
#define MODIFY_GPREGBr BCMI_MADURA_MODIFY_GPREGBr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREGBr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREGC
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x826c
 * DEVAD:    1
 * DESC:     General purpose register C for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREGC_DATA      Data
 */
#define BCMI_MADURA_GPREGCr (0x0001826c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREGCr_SIZE 4

/*
 * This structure should be used to declare and program GPREGC.
 */
typedef union BCMI_MADURA_GPREGCr_s {
	uint32_t v[1];
	uint32_t gpregc[1];
	uint32_t _gpregc;
} BCMI_MADURA_GPREGCr_t;

#define BCMI_MADURA_GPREGCr_CLR(r) (r).gpregc[0] = 0
#define BCMI_MADURA_GPREGCr_SET(r,d) (r).gpregc[0] = d
#define BCMI_MADURA_GPREGCr_GET(r) (r).gpregc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREGCr_GPREGC_DATAf_GET(r) (((r).gpregc[0]) & 0xffff)
#define BCMI_MADURA_GPREGCr_GPREGC_DATAf_SET(r,f) (r).gpregc[0]=(((r).gpregc[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREGC.
 */
#define BCMI_MADURA_READ_GPREGCr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREGCr,_r._gpregc)
#define BCMI_MADURA_WRITE_GPREGCr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREGCr,_r._gpregc)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREGCr BCMI_MADURA_GPREGCr
#define GPREGCr_SIZE BCMI_MADURA_GPREGCr_SIZE
typedef BCMI_MADURA_GPREGCr_t GPREGCr_t;
#define GPREGCr_CLR BCMI_MADURA_GPREGCr_CLR
#define GPREGCr_SET BCMI_MADURA_GPREGCr_SET
#define GPREGCr_GET BCMI_MADURA_GPREGCr_GET
#define GPREGCr_GPREGC_DATAf_GET BCMI_MADURA_GPREGCr_GPREGC_DATAf_GET
#define GPREGCr_GPREGC_DATAf_SET BCMI_MADURA_GPREGCr_GPREGC_DATAf_SET
#define READ_GPREGCr BCMI_MADURA_READ_GPREGCr
#define WRITE_GPREGCr BCMI_MADURA_WRITE_GPREGCr
#define MODIFY_GPREGCr BCMI_MADURA_MODIFY_GPREGCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREGCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREGD
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x826d
 * DEVAD:    1
 * DESC:     General purpose register D for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREGD_DATA      Data
 */
#define BCMI_MADURA_GPREGDr (0x0001826d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREGDr_SIZE 4

/*
 * This structure should be used to declare and program GPREGD.
 */
typedef union BCMI_MADURA_GPREGDr_s {
	uint32_t v[1];
	uint32_t gpregd[1];
	uint32_t _gpregd;
} BCMI_MADURA_GPREGDr_t;

#define BCMI_MADURA_GPREGDr_CLR(r) (r).gpregd[0] = 0
#define BCMI_MADURA_GPREGDr_SET(r,d) (r).gpregd[0] = d
#define BCMI_MADURA_GPREGDr_GET(r) (r).gpregd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREGDr_GPREGD_DATAf_GET(r) (((r).gpregd[0]) & 0xffff)
#define BCMI_MADURA_GPREGDr_GPREGD_DATAf_SET(r,f) (r).gpregd[0]=(((r).gpregd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREGD.
 */
#define BCMI_MADURA_READ_GPREGDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREGDr,_r._gpregd)
#define BCMI_MADURA_WRITE_GPREGDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREGDr,_r._gpregd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREGDr BCMI_MADURA_GPREGDr
#define GPREGDr_SIZE BCMI_MADURA_GPREGDr_SIZE
typedef BCMI_MADURA_GPREGDr_t GPREGDr_t;
#define GPREGDr_CLR BCMI_MADURA_GPREGDr_CLR
#define GPREGDr_SET BCMI_MADURA_GPREGDr_SET
#define GPREGDr_GET BCMI_MADURA_GPREGDr_GET
#define GPREGDr_GPREGD_DATAf_GET BCMI_MADURA_GPREGDr_GPREGD_DATAf_GET
#define GPREGDr_GPREGD_DATAf_SET BCMI_MADURA_GPREGDr_GPREGD_DATAf_SET
#define READ_GPREGDr BCMI_MADURA_READ_GPREGDr
#define WRITE_GPREGDr BCMI_MADURA_WRITE_GPREGDr
#define MODIFY_GPREGDr BCMI_MADURA_MODIFY_GPREGDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREGDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREGE
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x826e
 * DEVAD:    1
 * DESC:     General purpose register D for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREGE_DATA      Data
 */
#define BCMI_MADURA_GPREGEr (0x0001826e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREGEr_SIZE 4

/*
 * This structure should be used to declare and program GPREGE.
 */
typedef union BCMI_MADURA_GPREGEr_s {
	uint32_t v[1];
	uint32_t gprege[1];
	uint32_t _gprege;
} BCMI_MADURA_GPREGEr_t;

#define BCMI_MADURA_GPREGEr_CLR(r) (r).gprege[0] = 0
#define BCMI_MADURA_GPREGEr_SET(r,d) (r).gprege[0] = d
#define BCMI_MADURA_GPREGEr_GET(r) (r).gprege[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREGEr_GPREGE_DATAf_GET(r) (((r).gprege[0]) & 0xffff)
#define BCMI_MADURA_GPREGEr_GPREGE_DATAf_SET(r,f) (r).gprege[0]=(((r).gprege[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREGE.
 */
#define BCMI_MADURA_READ_GPREGEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREGEr,_r._gprege)
#define BCMI_MADURA_WRITE_GPREGEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREGEr,_r._gprege)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREGEr BCMI_MADURA_GPREGEr
#define GPREGEr_SIZE BCMI_MADURA_GPREGEr_SIZE
typedef BCMI_MADURA_GPREGEr_t GPREGEr_t;
#define GPREGEr_CLR BCMI_MADURA_GPREGEr_CLR
#define GPREGEr_SET BCMI_MADURA_GPREGEr_SET
#define GPREGEr_GET BCMI_MADURA_GPREGEr_GET
#define GPREGEr_GPREGE_DATAf_GET BCMI_MADURA_GPREGEr_GPREGE_DATAf_GET
#define GPREGEr_GPREGE_DATAf_SET BCMI_MADURA_GPREGEr_GPREGE_DATAf_SET
#define READ_GPREGEr BCMI_MADURA_READ_GPREGEr
#define WRITE_GPREGEr BCMI_MADURA_WRITE_GPREGEr
#define MODIFY_GPREGEr BCMI_MADURA_MODIFY_GPREGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPREGF
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x826f
 * DEVAD:    1
 * DESC:     General purpose register F for micro/external communication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREGF_DATA      Data
 */
#define BCMI_MADURA_GPREGFr (0x0001826f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPREGFr_SIZE 4

/*
 * This structure should be used to declare and program GPREGF.
 */
typedef union BCMI_MADURA_GPREGFr_s {
	uint32_t v[1];
	uint32_t gpregf[1];
	uint32_t _gpregf;
} BCMI_MADURA_GPREGFr_t;

#define BCMI_MADURA_GPREGFr_CLR(r) (r).gpregf[0] = 0
#define BCMI_MADURA_GPREGFr_SET(r,d) (r).gpregf[0] = d
#define BCMI_MADURA_GPREGFr_GET(r) (r).gpregf[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPREGFr_GPREGF_DATAf_GET(r) (((r).gpregf[0]) & 0xffff)
#define BCMI_MADURA_GPREGFr_GPREGF_DATAf_SET(r,f) (r).gpregf[0]=(((r).gpregf[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access GPREGF.
 */
#define BCMI_MADURA_READ_GPREGFr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPREGFr,_r._gpregf)
#define BCMI_MADURA_WRITE_GPREGFr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPREGFr,_r._gpregf)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPREGFr BCMI_MADURA_GPREGFr
#define GPREGFr_SIZE BCMI_MADURA_GPREGFr_SIZE
typedef BCMI_MADURA_GPREGFr_t GPREGFr_t;
#define GPREGFr_CLR BCMI_MADURA_GPREGFr_CLR
#define GPREGFr_SET BCMI_MADURA_GPREGFr_SET
#define GPREGFr_GET BCMI_MADURA_GPREGFr_GET
#define GPREGFr_GPREGF_DATAf_GET BCMI_MADURA_GPREGFr_GPREGF_DATAf_GET
#define GPREGFr_GPREGF_DATAf_SET BCMI_MADURA_GPREGFr_GPREGF_DATAf_SET
#define READ_GPREGFr BCMI_MADURA_READ_GPREGFr
#define WRITE_GPREGFr BCMI_MADURA_WRITE_GPREGFr
#define MODIFY_GPREGFr BCMI_MADURA_MODIFY_GPREGFr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPREGFr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMI_WDOG_CTL
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8270
 * DEVAD:    1
 * DESC:     Enables for the PMI watchdog timers
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_PMI_WDOG_EN  enable watchdog timer to act upon NO ACK from PMI and generate forced ack to terminate the PMI transaction between mux PMI and M0
 */
#define BCMI_MADURA_PMI_WDOG_CTLr (0x00018270 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMI_WDOG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMI_WDOG_CTL.
 */
typedef union BCMI_MADURA_PMI_WDOG_CTLr_s {
	uint32_t v[1];
	uint32_t pmi_wdog_ctl[1];
	uint32_t _pmi_wdog_ctl;
} BCMI_MADURA_PMI_WDOG_CTLr_t;

#define BCMI_MADURA_PMI_WDOG_CTLr_CLR(r) (r).pmi_wdog_ctl[0] = 0
#define BCMI_MADURA_PMI_WDOG_CTLr_SET(r,d) (r).pmi_wdog_ctl[0] = d
#define BCMI_MADURA_PMI_WDOG_CTLr_GET(r) (r).pmi_wdog_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMI_WDOG_CTLr_MST_PMI_WDOG_ENf_GET(r) (((r).pmi_wdog_ctl[0]) & 0x1)
#define BCMI_MADURA_PMI_WDOG_CTLr_MST_PMI_WDOG_ENf_SET(r,f) (r).pmi_wdog_ctl[0]=(((r).pmi_wdog_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMI_WDOG_CTL.
 */
#define BCMI_MADURA_READ_PMI_WDOG_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMI_WDOG_CTLr,_r._pmi_wdog_ctl)
#define BCMI_MADURA_WRITE_PMI_WDOG_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMI_WDOG_CTLr,_r._pmi_wdog_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMI_WDOG_CTLr BCMI_MADURA_PMI_WDOG_CTLr
#define PMI_WDOG_CTLr_SIZE BCMI_MADURA_PMI_WDOG_CTLr_SIZE
typedef BCMI_MADURA_PMI_WDOG_CTLr_t PMI_WDOG_CTLr_t;
#define PMI_WDOG_CTLr_CLR BCMI_MADURA_PMI_WDOG_CTLr_CLR
#define PMI_WDOG_CTLr_SET BCMI_MADURA_PMI_WDOG_CTLr_SET
#define PMI_WDOG_CTLr_GET BCMI_MADURA_PMI_WDOG_CTLr_GET
#define PMI_WDOG_CTLr_MST_PMI_WDOG_ENf_GET BCMI_MADURA_PMI_WDOG_CTLr_MST_PMI_WDOG_ENf_GET
#define PMI_WDOG_CTLr_MST_PMI_WDOG_ENf_SET BCMI_MADURA_PMI_WDOG_CTLr_MST_PMI_WDOG_ENf_SET
#define READ_PMI_WDOG_CTLr BCMI_MADURA_READ_PMI_WDOG_CTLr
#define WRITE_PMI_WDOG_CTLr BCMI_MADURA_WRITE_PMI_WDOG_CTLr
#define MODIFY_PMI_WDOG_CTLr BCMI_MADURA_MODIFY_PMI_WDOG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMI_WDOG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_FW_WDOG_CTL1
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8271
 * DEVAD:    1
 * DESC:     controls for master M0 firmware watchdog
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_FW_WDOG_EN   enable firmware watchdog timer for master m0. Write 1 to enable
 *     MST_FW_WDOG_START Write 1 to start/restart the timer. Self clearing
 *     MST_FW_WDOG_CK_SCALE 00: count on every posedge of a clock derived by dividing com_ck by 1638401: count on every posedge of a clock derived by dividing com_ck by 204810: count on every posedge of a clock derived by dividing com_ck by 819211: count on every posedge of a clock derived by dividing com_ck by 16384
 */
#define BCMI_MADURA_MST_FW_WDOG_CTL1r (0x00018271 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_FW_WDOG_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program MST_FW_WDOG_CTL1.
 */
typedef union BCMI_MADURA_MST_FW_WDOG_CTL1r_s {
	uint32_t v[1];
	uint32_t mst_fw_wdog_ctl1[1];
	uint32_t _mst_fw_wdog_ctl1;
} BCMI_MADURA_MST_FW_WDOG_CTL1r_t;

#define BCMI_MADURA_MST_FW_WDOG_CTL1r_CLR(r) (r).mst_fw_wdog_ctl1[0] = 0
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_SET(r,d) (r).mst_fw_wdog_ctl1[0] = d
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_GET(r) (r).mst_fw_wdog_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_CK_SCALEf_GET(r) ((((r).mst_fw_wdog_ctl1[0]) >> 4) & 0x3)
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_CK_SCALEf_SET(r,f) (r).mst_fw_wdog_ctl1[0]=(((r).mst_fw_wdog_ctl1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_STARTf_GET(r) ((((r).mst_fw_wdog_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_STARTf_SET(r,f) (r).mst_fw_wdog_ctl1[0]=(((r).mst_fw_wdog_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_ENf_GET(r) (((r).mst_fw_wdog_ctl1[0]) & 0x1)
#define BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_ENf_SET(r,f) (r).mst_fw_wdog_ctl1[0]=(((r).mst_fw_wdog_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MST_FW_WDOG_CTL1.
 */
#define BCMI_MADURA_READ_MST_FW_WDOG_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_FW_WDOG_CTL1r,_r._mst_fw_wdog_ctl1)
#define BCMI_MADURA_WRITE_MST_FW_WDOG_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_FW_WDOG_CTL1r,_r._mst_fw_wdog_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_FW_WDOG_CTL1r BCMI_MADURA_MST_FW_WDOG_CTL1r
#define MST_FW_WDOG_CTL1r_SIZE BCMI_MADURA_MST_FW_WDOG_CTL1r_SIZE
typedef BCMI_MADURA_MST_FW_WDOG_CTL1r_t MST_FW_WDOG_CTL1r_t;
#define MST_FW_WDOG_CTL1r_CLR BCMI_MADURA_MST_FW_WDOG_CTL1r_CLR
#define MST_FW_WDOG_CTL1r_SET BCMI_MADURA_MST_FW_WDOG_CTL1r_SET
#define MST_FW_WDOG_CTL1r_GET BCMI_MADURA_MST_FW_WDOG_CTL1r_GET
#define MST_FW_WDOG_CTL1r_MST_FW_WDOG_CK_SCALEf_GET BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_CK_SCALEf_GET
#define MST_FW_WDOG_CTL1r_MST_FW_WDOG_CK_SCALEf_SET BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_CK_SCALEf_SET
#define MST_FW_WDOG_CTL1r_MST_FW_WDOG_STARTf_GET BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_STARTf_GET
#define MST_FW_WDOG_CTL1r_MST_FW_WDOG_STARTf_SET BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_STARTf_SET
#define MST_FW_WDOG_CTL1r_MST_FW_WDOG_ENf_GET BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_ENf_GET
#define MST_FW_WDOG_CTL1r_MST_FW_WDOG_ENf_SET BCMI_MADURA_MST_FW_WDOG_CTL1r_MST_FW_WDOG_ENf_SET
#define READ_MST_FW_WDOG_CTL1r BCMI_MADURA_READ_MST_FW_WDOG_CTL1r
#define WRITE_MST_FW_WDOG_CTL1r BCMI_MADURA_WRITE_MST_FW_WDOG_CTL1r
#define MODIFY_MST_FW_WDOG_CTL1r BCMI_MADURA_MODIFY_MST_FW_WDOG_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_FW_WDOG_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_FW_WDOG_CTL2
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8272
 * DEVAD:    1
 * DESC:     count for master M0 firmware watchdog
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_FW_WDOG_CNT  Watchdog timer count
 */
#define BCMI_MADURA_MST_FW_WDOG_CTL2r (0x00018272 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_FW_WDOG_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program MST_FW_WDOG_CTL2.
 */
typedef union BCMI_MADURA_MST_FW_WDOG_CTL2r_s {
	uint32_t v[1];
	uint32_t mst_fw_wdog_ctl2[1];
	uint32_t _mst_fw_wdog_ctl2;
} BCMI_MADURA_MST_FW_WDOG_CTL2r_t;

#define BCMI_MADURA_MST_FW_WDOG_CTL2r_CLR(r) (r).mst_fw_wdog_ctl2[0] = 0
#define BCMI_MADURA_MST_FW_WDOG_CTL2r_SET(r,d) (r).mst_fw_wdog_ctl2[0] = d
#define BCMI_MADURA_MST_FW_WDOG_CTL2r_GET(r) (r).mst_fw_wdog_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_FW_WDOG_CTL2r_MST_FW_WDOG_CNTf_GET(r) (((r).mst_fw_wdog_ctl2[0]) & 0xffff)
#define BCMI_MADURA_MST_FW_WDOG_CTL2r_MST_FW_WDOG_CNTf_SET(r,f) (r).mst_fw_wdog_ctl2[0]=(((r).mst_fw_wdog_ctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_FW_WDOG_CTL2.
 */
#define BCMI_MADURA_READ_MST_FW_WDOG_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_FW_WDOG_CTL2r,_r._mst_fw_wdog_ctl2)
#define BCMI_MADURA_WRITE_MST_FW_WDOG_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_FW_WDOG_CTL2r,_r._mst_fw_wdog_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_FW_WDOG_CTL2r BCMI_MADURA_MST_FW_WDOG_CTL2r
#define MST_FW_WDOG_CTL2r_SIZE BCMI_MADURA_MST_FW_WDOG_CTL2r_SIZE
typedef BCMI_MADURA_MST_FW_WDOG_CTL2r_t MST_FW_WDOG_CTL2r_t;
#define MST_FW_WDOG_CTL2r_CLR BCMI_MADURA_MST_FW_WDOG_CTL2r_CLR
#define MST_FW_WDOG_CTL2r_SET BCMI_MADURA_MST_FW_WDOG_CTL2r_SET
#define MST_FW_WDOG_CTL2r_GET BCMI_MADURA_MST_FW_WDOG_CTL2r_GET
#define MST_FW_WDOG_CTL2r_MST_FW_WDOG_CNTf_GET BCMI_MADURA_MST_FW_WDOG_CTL2r_MST_FW_WDOG_CNTf_GET
#define MST_FW_WDOG_CTL2r_MST_FW_WDOG_CNTf_SET BCMI_MADURA_MST_FW_WDOG_CTL2r_MST_FW_WDOG_CNTf_SET
#define READ_MST_FW_WDOG_CTL2r BCMI_MADURA_READ_MST_FW_WDOG_CTL2r
#define WRITE_MST_FW_WDOG_CTL2r BCMI_MADURA_WRITE_MST_FW_WDOG_CTL2r
#define MODIFY_MST_FW_WDOG_CTL2r BCMI_MADURA_MODIFY_MST_FW_WDOG_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_FW_WDOG_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_FW_WDOG_EXPIRE_STAT
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8273
 * DEVAD:    1
 * DESC:     expiry status for master M0 firmware watchdog
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_FW_WDOG_EXP_LH Latch High status of master m0 firmware watchdog timer expiry. Clear on read
 */
#define BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr (0x00018273 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_SIZE 4

/*
 * This structure should be used to declare and program MST_FW_WDOG_EXPIRE_STAT.
 */
typedef union BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_s {
	uint32_t v[1];
	uint32_t mst_fw_wdog_expire_stat[1];
	uint32_t _mst_fw_wdog_expire_stat;
} BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_t;

#define BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_CLR(r) (r).mst_fw_wdog_expire_stat[0] = 0
#define BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_SET(r,d) (r).mst_fw_wdog_expire_stat[0] = d
#define BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_GET(r) (r).mst_fw_wdog_expire_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_MST_FW_WDOG_EXP_LHf_GET(r) (((r).mst_fw_wdog_expire_stat[0]) & 0x1)
#define BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_MST_FW_WDOG_EXP_LHf_SET(r,f) (r).mst_fw_wdog_expire_stat[0]=(((r).mst_fw_wdog_expire_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MST_FW_WDOG_EXPIRE_STAT.
 */
#define BCMI_MADURA_READ_MST_FW_WDOG_EXPIRE_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr,_r._mst_fw_wdog_expire_stat)
#define BCMI_MADURA_WRITE_MST_FW_WDOG_EXPIRE_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr,_r._mst_fw_wdog_expire_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_FW_WDOG_EXPIRE_STATr BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr
#define MST_FW_WDOG_EXPIRE_STATr_SIZE BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_SIZE
typedef BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_t MST_FW_WDOG_EXPIRE_STATr_t;
#define MST_FW_WDOG_EXPIRE_STATr_CLR BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_CLR
#define MST_FW_WDOG_EXPIRE_STATr_SET BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_SET
#define MST_FW_WDOG_EXPIRE_STATr_GET BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_GET
#define MST_FW_WDOG_EXPIRE_STATr_MST_FW_WDOG_EXP_LHf_GET BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_MST_FW_WDOG_EXP_LHf_GET
#define MST_FW_WDOG_EXPIRE_STATr_MST_FW_WDOG_EXP_LHf_SET BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr_MST_FW_WDOG_EXP_LHf_SET
#define READ_MST_FW_WDOG_EXPIRE_STATr BCMI_MADURA_READ_MST_FW_WDOG_EXPIRE_STATr
#define WRITE_MST_FW_WDOG_EXPIRE_STATr BCMI_MADURA_WRITE_MST_FW_WDOG_EXPIRE_STATr
#define MODIFY_MST_FW_WDOG_EXPIRE_STATr BCMI_MADURA_MODIFY_MST_FW_WDOG_EXPIRE_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_FW_WDOG_EXPIRE_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_FW_WDOG_STAT2
 * BLOCKS:   GEN_CNTRLS
 * REGADDR:  0x8274
 * DEVAD:    1
 * DESC:     live count for master M0 firmware watchdog
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_FW_WDOG_LIVE_CNT Current value of the master m0 firmware watchdog timer count.
 */
#define BCMI_MADURA_MST_FW_WDOG_STAT2r (0x00018274 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_FW_WDOG_STAT2r_SIZE 4

/*
 * This structure should be used to declare and program MST_FW_WDOG_STAT2.
 */
typedef union BCMI_MADURA_MST_FW_WDOG_STAT2r_s {
	uint32_t v[1];
	uint32_t mst_fw_wdog_stat2[1];
	uint32_t _mst_fw_wdog_stat2;
} BCMI_MADURA_MST_FW_WDOG_STAT2r_t;

#define BCMI_MADURA_MST_FW_WDOG_STAT2r_CLR(r) (r).mst_fw_wdog_stat2[0] = 0
#define BCMI_MADURA_MST_FW_WDOG_STAT2r_SET(r,d) (r).mst_fw_wdog_stat2[0] = d
#define BCMI_MADURA_MST_FW_WDOG_STAT2r_GET(r) (r).mst_fw_wdog_stat2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_FW_WDOG_STAT2r_MST_FW_WDOG_LIVE_CNTf_GET(r) (((r).mst_fw_wdog_stat2[0]) & 0xffff)
#define BCMI_MADURA_MST_FW_WDOG_STAT2r_MST_FW_WDOG_LIVE_CNTf_SET(r,f) (r).mst_fw_wdog_stat2[0]=(((r).mst_fw_wdog_stat2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_FW_WDOG_STAT2.
 */
#define BCMI_MADURA_READ_MST_FW_WDOG_STAT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_FW_WDOG_STAT2r,_r._mst_fw_wdog_stat2)
#define BCMI_MADURA_WRITE_MST_FW_WDOG_STAT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_FW_WDOG_STAT2r,_r._mst_fw_wdog_stat2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_FW_WDOG_STAT2r BCMI_MADURA_MST_FW_WDOG_STAT2r
#define MST_FW_WDOG_STAT2r_SIZE BCMI_MADURA_MST_FW_WDOG_STAT2r_SIZE
typedef BCMI_MADURA_MST_FW_WDOG_STAT2r_t MST_FW_WDOG_STAT2r_t;
#define MST_FW_WDOG_STAT2r_CLR BCMI_MADURA_MST_FW_WDOG_STAT2r_CLR
#define MST_FW_WDOG_STAT2r_SET BCMI_MADURA_MST_FW_WDOG_STAT2r_SET
#define MST_FW_WDOG_STAT2r_GET BCMI_MADURA_MST_FW_WDOG_STAT2r_GET
#define MST_FW_WDOG_STAT2r_MST_FW_WDOG_LIVE_CNTf_GET BCMI_MADURA_MST_FW_WDOG_STAT2r_MST_FW_WDOG_LIVE_CNTf_GET
#define MST_FW_WDOG_STAT2r_MST_FW_WDOG_LIVE_CNTf_SET BCMI_MADURA_MST_FW_WDOG_STAT2r_MST_FW_WDOG_LIVE_CNTf_SET
#define READ_MST_FW_WDOG_STAT2r BCMI_MADURA_READ_MST_FW_WDOG_STAT2r
#define WRITE_MST_FW_WDOG_STAT2r BCMI_MADURA_WRITE_MST_FW_WDOG_STAT2r
#define MODIFY_MST_FW_WDOG_STAT2r BCMI_MADURA_MODIFY_MST_FW_WDOG_STAT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_FW_WDOG_STAT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_BOOT_POR
 * BLOCKS:   MICRO_BOOT
 * REGADDR:  0x82ff
 * DEVAD:    1
 * DESC:     Micro boot registers
 * RESETVAL: 0x80ff (33023)
 * ACCESS:   R/W
 * FIELDS:
 *     GPREG            General purpose register that is reset only by crstb
 *     SLV_RST_EN       When this bit is set, master M0 will keep all slave M0 in reset before downloading its code and enable it afterwards. Should be made 0 only for debuggingThis bit is reset only by crstb.  However, this bit is writeable.bit 11:8 corresponding to slave 4:1slave 1: slice 0 system side Falconslave 2: slice 0 line side Falconslave 3: slice 1 system side Falconslave 4: slice 1 line side Falcon
 *     SLV_DWLD_DONE    Micro asserts this bit once EEPROM/I2C/MDIO download is over for slave M0.This bit is reset only by crstb.  However, this bit is writeable.bit 11:8 corresponding to slave 4:1slave 1: slice 0 system side Falconslave 2: slice 0 line side Falconslave 3: slice 1 system side Falconslave 4: slice 1 line side Falcon
 *     MST_DWLD_DONE    Micro asserts this bit once EEPROM/I2C/MDIO download is over for master M0.This bit is reset only by crstb.  However, this bit is writeable.
 *     SERBOOT          Reflects the status of SER_BOOT pin at HW PORwill be updated 1 clock after reset1 = micro should download firmware from EEPROM or I2C/MDIO writes0 = micro should use internal ROM for firmwareNote: this bit is reset only by crstb.  However, this bit is writeable
 *     SPI_PORT_USED    Reflects the status of SPI DOWNLD mode1 = EEPROM used for microcode download0 = MDIO/I2C used for microcode download
 */
#define BCMI_MADURA_UC_BOOT_PORr (0x000182ff | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_BOOT_PORr_SIZE 4

/*
 * This structure should be used to declare and program UC_BOOT_POR.
 */
typedef union BCMI_MADURA_UC_BOOT_PORr_s {
	uint32_t v[1];
	uint32_t uc_boot_por[1];
	uint32_t _uc_boot_por;
} BCMI_MADURA_UC_BOOT_PORr_t;

#define BCMI_MADURA_UC_BOOT_PORr_CLR(r) (r).uc_boot_por[0] = 0
#define BCMI_MADURA_UC_BOOT_PORr_SET(r,d) (r).uc_boot_por[0] = d
#define BCMI_MADURA_UC_BOOT_PORr_GET(r) (r).uc_boot_por[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_BOOT_PORr_SPI_PORT_USEDf_GET(r) ((((r).uc_boot_por[0]) >> 15) & 0x1)
#define BCMI_MADURA_UC_BOOT_PORr_SPI_PORT_USEDf_SET(r,f) (r).uc_boot_por[0]=(((r).uc_boot_por[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_UC_BOOT_PORr_SERBOOTf_GET(r) ((((r).uc_boot_por[0]) >> 14) & 0x1)
#define BCMI_MADURA_UC_BOOT_PORr_SERBOOTf_SET(r,f) (r).uc_boot_por[0]=(((r).uc_boot_por[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_UC_BOOT_PORr_MST_DWLD_DONEf_GET(r) ((((r).uc_boot_por[0]) >> 13) & 0x1)
#define BCMI_MADURA_UC_BOOT_PORr_MST_DWLD_DONEf_SET(r,f) (r).uc_boot_por[0]=(((r).uc_boot_por[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_UC_BOOT_PORr_SLV_DWLD_DONEf_GET(r) ((((r).uc_boot_por[0]) >> 8) & 0xf)
#define BCMI_MADURA_UC_BOOT_PORr_SLV_DWLD_DONEf_SET(r,f) (r).uc_boot_por[0]=(((r).uc_boot_por[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_UC_BOOT_PORr_SLV_RST_ENf_GET(r) ((((r).uc_boot_por[0]) >> 4) & 0xf)
#define BCMI_MADURA_UC_BOOT_PORr_SLV_RST_ENf_SET(r,f) (r).uc_boot_por[0]=(((r).uc_boot_por[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_UC_BOOT_PORr_GPREGf_GET(r) (((r).uc_boot_por[0]) & 0xf)
#define BCMI_MADURA_UC_BOOT_PORr_GPREGf_SET(r,f) (r).uc_boot_por[0]=(((r).uc_boot_por[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access UC_BOOT_POR.
 */
#define BCMI_MADURA_READ_UC_BOOT_PORr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_BOOT_PORr,_r._uc_boot_por)
#define BCMI_MADURA_WRITE_UC_BOOT_PORr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_BOOT_PORr,_r._uc_boot_por)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_BOOT_PORr BCMI_MADURA_UC_BOOT_PORr
#define UC_BOOT_PORr_SIZE BCMI_MADURA_UC_BOOT_PORr_SIZE
typedef BCMI_MADURA_UC_BOOT_PORr_t UC_BOOT_PORr_t;
#define UC_BOOT_PORr_CLR BCMI_MADURA_UC_BOOT_PORr_CLR
#define UC_BOOT_PORr_SET BCMI_MADURA_UC_BOOT_PORr_SET
#define UC_BOOT_PORr_GET BCMI_MADURA_UC_BOOT_PORr_GET
#define UC_BOOT_PORr_SPI_PORT_USEDf_GET BCMI_MADURA_UC_BOOT_PORr_SPI_PORT_USEDf_GET
#define UC_BOOT_PORr_SPI_PORT_USEDf_SET BCMI_MADURA_UC_BOOT_PORr_SPI_PORT_USEDf_SET
#define UC_BOOT_PORr_SERBOOTf_GET BCMI_MADURA_UC_BOOT_PORr_SERBOOTf_GET
#define UC_BOOT_PORr_SERBOOTf_SET BCMI_MADURA_UC_BOOT_PORr_SERBOOTf_SET
#define UC_BOOT_PORr_MST_DWLD_DONEf_GET BCMI_MADURA_UC_BOOT_PORr_MST_DWLD_DONEf_GET
#define UC_BOOT_PORr_MST_DWLD_DONEf_SET BCMI_MADURA_UC_BOOT_PORr_MST_DWLD_DONEf_SET
#define UC_BOOT_PORr_SLV_DWLD_DONEf_GET BCMI_MADURA_UC_BOOT_PORr_SLV_DWLD_DONEf_GET
#define UC_BOOT_PORr_SLV_DWLD_DONEf_SET BCMI_MADURA_UC_BOOT_PORr_SLV_DWLD_DONEf_SET
#define UC_BOOT_PORr_SLV_RST_ENf_GET BCMI_MADURA_UC_BOOT_PORr_SLV_RST_ENf_GET
#define UC_BOOT_PORr_SLV_RST_ENf_SET BCMI_MADURA_UC_BOOT_PORr_SLV_RST_ENf_SET
#define UC_BOOT_PORr_GPREGf_GET BCMI_MADURA_UC_BOOT_PORr_GPREGf_GET
#define UC_BOOT_PORr_GPREGf_SET BCMI_MADURA_UC_BOOT_PORr_GPREGf_SET
#define READ_UC_BOOT_PORr BCMI_MADURA_READ_UC_BOOT_PORr
#define WRITE_UC_BOOT_PORr BCMI_MADURA_WRITE_UC_BOOT_PORr
#define MODIFY_UC_BOOT_PORr BCMI_MADURA_MODIFY_UC_BOOT_PORr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_BOOT_PORr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_CRAM_MEM_ADD_CTL
 * BLOCKS:   M0ACCESS_ADDR
 * REGADDR:  0x8400
 * DEVAD:    1
 * DESC:     Address for backdoor access to master code ram
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_CRAM_MEM_ADD Byte address for back-door access to the master code ram. For code ram access, initialize this with an address that is a multiple of 4 (0,4,8,....). The correct sequence for back door write to code ram is to initalize the address, write into the lsb data register and then write into msb data register. The address register will automatically increment after the msb write by 4.The correct sequence for back door read to code ram is to initalize the address, read from the lsb data register and then read from msb data register. The address register will automatically increment after the lsb read by 4.Note: It is illegal to program the address register to an out-of-bounds location or with a value that is a non-multiple of 4. No hardware checks are present for the illegal scenarios.
 */
#define BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr (0x00018400 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MST_CRAM_MEM_ADD_CTL.
 */
typedef union BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_s {
	uint32_t v[1];
	uint32_t mst_cram_mem_add_ctl[1];
	uint32_t _mst_cram_mem_add_ctl;
} BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_t;

#define BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_CLR(r) (r).mst_cram_mem_add_ctl[0] = 0
#define BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_SET(r,d) (r).mst_cram_mem_add_ctl[0] = d
#define BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_GET(r) (r).mst_cram_mem_add_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_MST_CRAM_MEM_ADDf_GET(r) (((r).mst_cram_mem_add_ctl[0]) & 0x3fff)
#define BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_MST_CRAM_MEM_ADDf_SET(r,f) (r).mst_cram_mem_add_ctl[0]=(((r).mst_cram_mem_add_ctl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access MST_CRAM_MEM_ADD_CTL.
 */
#define BCMI_MADURA_READ_MST_CRAM_MEM_ADD_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr,_r._mst_cram_mem_add_ctl)
#define BCMI_MADURA_WRITE_MST_CRAM_MEM_ADD_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr,_r._mst_cram_mem_add_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_CRAM_MEM_ADD_CTLr BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr
#define MST_CRAM_MEM_ADD_CTLr_SIZE BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_SIZE
typedef BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_t MST_CRAM_MEM_ADD_CTLr_t;
#define MST_CRAM_MEM_ADD_CTLr_CLR BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_CLR
#define MST_CRAM_MEM_ADD_CTLr_SET BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_SET
#define MST_CRAM_MEM_ADD_CTLr_GET BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_GET
#define MST_CRAM_MEM_ADD_CTLr_MST_CRAM_MEM_ADDf_GET BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_MST_CRAM_MEM_ADDf_GET
#define MST_CRAM_MEM_ADD_CTLr_MST_CRAM_MEM_ADDf_SET BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr_MST_CRAM_MEM_ADDf_SET
#define READ_MST_CRAM_MEM_ADD_CTLr BCMI_MADURA_READ_MST_CRAM_MEM_ADD_CTLr
#define WRITE_MST_CRAM_MEM_ADD_CTLr BCMI_MADURA_WRITE_MST_CRAM_MEM_ADD_CTLr
#define MODIFY_MST_CRAM_MEM_ADD_CTLr BCMI_MADURA_MODIFY_MST_CRAM_MEM_ADD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_CRAM_MEM_ADD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_DRAM_MEM_ADD_CTL
 * BLOCKS:   M0ACCESS_ADDR
 * REGADDR:  0x8401
 * DEVAD:    1
 * DESC:     Address for backdoor access to master data ram
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_DRAM_MEM_ADD For data ram access, initalize this with an even address. The address register will automatically increment by 2 after a data register read or write.Note: It is illegal to program the address register to an out-of-bounds location or with a value that is a non-multiple of 2. No hardware checks are present for the illegal scenarios.
 */
#define BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr (0x00018401 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MST_DRAM_MEM_ADD_CTL.
 */
typedef union BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_s {
	uint32_t v[1];
	uint32_t mst_dram_mem_add_ctl[1];
	uint32_t _mst_dram_mem_add_ctl;
} BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_t;

#define BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_CLR(r) (r).mst_dram_mem_add_ctl[0] = 0
#define BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_SET(r,d) (r).mst_dram_mem_add_ctl[0] = d
#define BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_GET(r) (r).mst_dram_mem_add_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_MST_DRAM_MEM_ADDf_GET(r) (((r).mst_dram_mem_add_ctl[0]) & 0xfff)
#define BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_MST_DRAM_MEM_ADDf_SET(r,f) (r).mst_dram_mem_add_ctl[0]=(((r).mst_dram_mem_add_ctl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access MST_DRAM_MEM_ADD_CTL.
 */
#define BCMI_MADURA_READ_MST_DRAM_MEM_ADD_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr,_r._mst_dram_mem_add_ctl)
#define BCMI_MADURA_WRITE_MST_DRAM_MEM_ADD_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr,_r._mst_dram_mem_add_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_DRAM_MEM_ADD_CTLr BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr
#define MST_DRAM_MEM_ADD_CTLr_SIZE BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_SIZE
typedef BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_t MST_DRAM_MEM_ADD_CTLr_t;
#define MST_DRAM_MEM_ADD_CTLr_CLR BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_CLR
#define MST_DRAM_MEM_ADD_CTLr_SET BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_SET
#define MST_DRAM_MEM_ADD_CTLr_GET BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_GET
#define MST_DRAM_MEM_ADD_CTLr_MST_DRAM_MEM_ADDf_GET BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_MST_DRAM_MEM_ADDf_GET
#define MST_DRAM_MEM_ADD_CTLr_MST_DRAM_MEM_ADDf_SET BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr_MST_DRAM_MEM_ADDf_SET
#define READ_MST_DRAM_MEM_ADD_CTLr BCMI_MADURA_READ_MST_DRAM_MEM_ADD_CTLr
#define WRITE_MST_DRAM_MEM_ADD_CTLr BCMI_MADURA_WRITE_MST_DRAM_MEM_ADD_CTLr
#define MODIFY_MST_DRAM_MEM_ADD_CTLr BCMI_MADURA_MODIFY_MST_DRAM_MEM_ADD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_DRAM_MEM_ADD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_VT_ADD_CTL
 * BLOCKS:   M0ACCESS_ADDR
 * REGADDR:  0x8402
 * DEVAD:    1
 * DESC:     Address for backdoor access to master vector table
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_VT_ADD       For Vector table access, initalize this with an even address. The address register will automatically increment by 2 after a vector table read or write.Note: It is illegal to program the address register to an out-of-bounds location or with a value that is a non-multiple of 2. No hardware checks are present for the illegal scenarios.
 */
#define BCMI_MADURA_MST_VT_ADD_CTLr (0x00018402 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_VT_ADD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MST_VT_ADD_CTL.
 */
typedef union BCMI_MADURA_MST_VT_ADD_CTLr_s {
	uint32_t v[1];
	uint32_t mst_vt_add_ctl[1];
	uint32_t _mst_vt_add_ctl;
} BCMI_MADURA_MST_VT_ADD_CTLr_t;

#define BCMI_MADURA_MST_VT_ADD_CTLr_CLR(r) (r).mst_vt_add_ctl[0] = 0
#define BCMI_MADURA_MST_VT_ADD_CTLr_SET(r,d) (r).mst_vt_add_ctl[0] = d
#define BCMI_MADURA_MST_VT_ADD_CTLr_GET(r) (r).mst_vt_add_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_VT_ADD_CTLr_MST_VT_ADDf_GET(r) (((r).mst_vt_add_ctl[0]) & 0x3ff)
#define BCMI_MADURA_MST_VT_ADD_CTLr_MST_VT_ADDf_SET(r,f) (r).mst_vt_add_ctl[0]=(((r).mst_vt_add_ctl[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access MST_VT_ADD_CTL.
 */
#define BCMI_MADURA_READ_MST_VT_ADD_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_VT_ADD_CTLr,_r._mst_vt_add_ctl)
#define BCMI_MADURA_WRITE_MST_VT_ADD_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_VT_ADD_CTLr,_r._mst_vt_add_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_VT_ADD_CTLr BCMI_MADURA_MST_VT_ADD_CTLr
#define MST_VT_ADD_CTLr_SIZE BCMI_MADURA_MST_VT_ADD_CTLr_SIZE
typedef BCMI_MADURA_MST_VT_ADD_CTLr_t MST_VT_ADD_CTLr_t;
#define MST_VT_ADD_CTLr_CLR BCMI_MADURA_MST_VT_ADD_CTLr_CLR
#define MST_VT_ADD_CTLr_SET BCMI_MADURA_MST_VT_ADD_CTLr_SET
#define MST_VT_ADD_CTLr_GET BCMI_MADURA_MST_VT_ADD_CTLr_GET
#define MST_VT_ADD_CTLr_MST_VT_ADDf_GET BCMI_MADURA_MST_VT_ADD_CTLr_MST_VT_ADDf_GET
#define MST_VT_ADD_CTLr_MST_VT_ADDf_SET BCMI_MADURA_MST_VT_ADD_CTLr_MST_VT_ADDf_SET
#define READ_MST_VT_ADD_CTLr BCMI_MADURA_READ_MST_VT_ADD_CTLr
#define WRITE_MST_VT_ADD_CTLr BCMI_MADURA_WRITE_MST_VT_ADD_CTLr
#define MODIFY_MST_VT_ADD_CTLr BCMI_MADURA_MODIFY_MST_VT_ADD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_VT_ADD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_CRAM_LSB_WDATA_CTL
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8410
 * DEVAD:    1
 * DESC:     Master M0 code ram back door LSB write data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_CRAM_LSB_WDATA LSB of the 32-bit write data for back door write to Master M0 code ram.The correct sequence for back door write to code ram is to initalize the address, write into the lsb data register and then write into msb data register.
 */
#define BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr (0x00018410 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MST_CRAM_LSB_WDATA_CTL.
 */
typedef union BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_s {
	uint32_t v[1];
	uint32_t mst_cram_lsb_wdata_ctl[1];
	uint32_t _mst_cram_lsb_wdata_ctl;
} BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_t;

#define BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_CLR(r) (r).mst_cram_lsb_wdata_ctl[0] = 0
#define BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_SET(r,d) (r).mst_cram_lsb_wdata_ctl[0] = d
#define BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_GET(r) (r).mst_cram_lsb_wdata_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_MST_CRAM_LSB_WDATAf_GET(r) (((r).mst_cram_lsb_wdata_ctl[0]) & 0xffff)
#define BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_MST_CRAM_LSB_WDATAf_SET(r,f) (r).mst_cram_lsb_wdata_ctl[0]=(((r).mst_cram_lsb_wdata_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_CRAM_LSB_WDATA_CTL.
 */
#define BCMI_MADURA_READ_MST_CRAM_LSB_WDATA_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr,_r._mst_cram_lsb_wdata_ctl)
#define BCMI_MADURA_WRITE_MST_CRAM_LSB_WDATA_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr,_r._mst_cram_lsb_wdata_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_CRAM_LSB_WDATA_CTLr BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr
#define MST_CRAM_LSB_WDATA_CTLr_SIZE BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_SIZE
typedef BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_t MST_CRAM_LSB_WDATA_CTLr_t;
#define MST_CRAM_LSB_WDATA_CTLr_CLR BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_CLR
#define MST_CRAM_LSB_WDATA_CTLr_SET BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_SET
#define MST_CRAM_LSB_WDATA_CTLr_GET BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_GET
#define MST_CRAM_LSB_WDATA_CTLr_MST_CRAM_LSB_WDATAf_GET BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_MST_CRAM_LSB_WDATAf_GET
#define MST_CRAM_LSB_WDATA_CTLr_MST_CRAM_LSB_WDATAf_SET BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr_MST_CRAM_LSB_WDATAf_SET
#define READ_MST_CRAM_LSB_WDATA_CTLr BCMI_MADURA_READ_MST_CRAM_LSB_WDATA_CTLr
#define WRITE_MST_CRAM_LSB_WDATA_CTLr BCMI_MADURA_WRITE_MST_CRAM_LSB_WDATA_CTLr
#define MODIFY_MST_CRAM_LSB_WDATA_CTLr BCMI_MADURA_MODIFY_MST_CRAM_LSB_WDATA_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_CRAM_LSB_WDATA_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_CRAM_LSB_RDATA_STAT
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8411
 * DEVAD:    1
 * DESC:     Master M0 code ram back door LSB read data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_CRAM_LSB_RDATA LSB of the 32-bit read data for back door read from Master M0 code ram.The correct sequence for back door read from code ram is to initalize the address, read from lsb data register and then read from the msb data register.
 */
#define BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr (0x00018411 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_SIZE 4

/*
 * This structure should be used to declare and program MST_CRAM_LSB_RDATA_STAT.
 */
typedef union BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_s {
	uint32_t v[1];
	uint32_t mst_cram_lsb_rdata_stat[1];
	uint32_t _mst_cram_lsb_rdata_stat;
} BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_t;

#define BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_CLR(r) (r).mst_cram_lsb_rdata_stat[0] = 0
#define BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_SET(r,d) (r).mst_cram_lsb_rdata_stat[0] = d
#define BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_GET(r) (r).mst_cram_lsb_rdata_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_MST_CRAM_LSB_RDATAf_GET(r) (((r).mst_cram_lsb_rdata_stat[0]) & 0xffff)
#define BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_MST_CRAM_LSB_RDATAf_SET(r,f) (r).mst_cram_lsb_rdata_stat[0]=(((r).mst_cram_lsb_rdata_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_CRAM_LSB_RDATA_STAT.
 */
#define BCMI_MADURA_READ_MST_CRAM_LSB_RDATA_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr,_r._mst_cram_lsb_rdata_stat)
#define BCMI_MADURA_WRITE_MST_CRAM_LSB_RDATA_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr,_r._mst_cram_lsb_rdata_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_CRAM_LSB_RDATA_STATr BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr
#define MST_CRAM_LSB_RDATA_STATr_SIZE BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_SIZE
typedef BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_t MST_CRAM_LSB_RDATA_STATr_t;
#define MST_CRAM_LSB_RDATA_STATr_CLR BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_CLR
#define MST_CRAM_LSB_RDATA_STATr_SET BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_SET
#define MST_CRAM_LSB_RDATA_STATr_GET BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_GET
#define MST_CRAM_LSB_RDATA_STATr_MST_CRAM_LSB_RDATAf_GET BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_MST_CRAM_LSB_RDATAf_GET
#define MST_CRAM_LSB_RDATA_STATr_MST_CRAM_LSB_RDATAf_SET BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr_MST_CRAM_LSB_RDATAf_SET
#define READ_MST_CRAM_LSB_RDATA_STATr BCMI_MADURA_READ_MST_CRAM_LSB_RDATA_STATr
#define WRITE_MST_CRAM_LSB_RDATA_STATr BCMI_MADURA_WRITE_MST_CRAM_LSB_RDATA_STATr
#define MODIFY_MST_CRAM_LSB_RDATA_STATr BCMI_MADURA_MODIFY_MST_CRAM_LSB_RDATA_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_CRAM_LSB_RDATA_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_CRAM_MSB_WDATA_CTL
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8412
 * DEVAD:    1
 * DESC:     Master M0 code ram back door MSB write data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_CRAM_MSB_WDATA MSB of the 32-bit write data for back door write to Master M0 code ram.The correct sequence for back door write to code ram is to initalize the address, write into the lsb data register and then write into msb data register.
 */
#define BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr (0x00018412 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MST_CRAM_MSB_WDATA_CTL.
 */
typedef union BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_s {
	uint32_t v[1];
	uint32_t mst_cram_msb_wdata_ctl[1];
	uint32_t _mst_cram_msb_wdata_ctl;
} BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_t;

#define BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_CLR(r) (r).mst_cram_msb_wdata_ctl[0] = 0
#define BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_SET(r,d) (r).mst_cram_msb_wdata_ctl[0] = d
#define BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_GET(r) (r).mst_cram_msb_wdata_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_MST_CRAM_MSB_WDATAf_GET(r) (((r).mst_cram_msb_wdata_ctl[0]) & 0xffff)
#define BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_MST_CRAM_MSB_WDATAf_SET(r,f) (r).mst_cram_msb_wdata_ctl[0]=(((r).mst_cram_msb_wdata_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_CRAM_MSB_WDATA_CTL.
 */
#define BCMI_MADURA_READ_MST_CRAM_MSB_WDATA_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr,_r._mst_cram_msb_wdata_ctl)
#define BCMI_MADURA_WRITE_MST_CRAM_MSB_WDATA_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr,_r._mst_cram_msb_wdata_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_CRAM_MSB_WDATA_CTLr BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr
#define MST_CRAM_MSB_WDATA_CTLr_SIZE BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_SIZE
typedef BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_t MST_CRAM_MSB_WDATA_CTLr_t;
#define MST_CRAM_MSB_WDATA_CTLr_CLR BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_CLR
#define MST_CRAM_MSB_WDATA_CTLr_SET BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_SET
#define MST_CRAM_MSB_WDATA_CTLr_GET BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_GET
#define MST_CRAM_MSB_WDATA_CTLr_MST_CRAM_MSB_WDATAf_GET BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_MST_CRAM_MSB_WDATAf_GET
#define MST_CRAM_MSB_WDATA_CTLr_MST_CRAM_MSB_WDATAf_SET BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr_MST_CRAM_MSB_WDATAf_SET
#define READ_MST_CRAM_MSB_WDATA_CTLr BCMI_MADURA_READ_MST_CRAM_MSB_WDATA_CTLr
#define WRITE_MST_CRAM_MSB_WDATA_CTLr BCMI_MADURA_WRITE_MST_CRAM_MSB_WDATA_CTLr
#define MODIFY_MST_CRAM_MSB_WDATA_CTLr BCMI_MADURA_MODIFY_MST_CRAM_MSB_WDATA_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_CRAM_MSB_WDATA_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_CRAM_MSB_RDATA_STAT
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8413
 * DEVAD:    1
 * DESC:     Master M0 code ram back door MSB read data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_CRAM_MSB_RDATA MSB of the 32-bit read data for back door read from Master M0 code ram.The correct sequence for back door read from code ram is to initalize the address, read from lsb data register and then read from the msb data register.
 */
#define BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr (0x00018413 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_SIZE 4

/*
 * This structure should be used to declare and program MST_CRAM_MSB_RDATA_STAT.
 */
typedef union BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_s {
	uint32_t v[1];
	uint32_t mst_cram_msb_rdata_stat[1];
	uint32_t _mst_cram_msb_rdata_stat;
} BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_t;

#define BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_CLR(r) (r).mst_cram_msb_rdata_stat[0] = 0
#define BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_SET(r,d) (r).mst_cram_msb_rdata_stat[0] = d
#define BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_GET(r) (r).mst_cram_msb_rdata_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_MST_CRAM_MSB_RDATAf_GET(r) (((r).mst_cram_msb_rdata_stat[0]) & 0xffff)
#define BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_MST_CRAM_MSB_RDATAf_SET(r,f) (r).mst_cram_msb_rdata_stat[0]=(((r).mst_cram_msb_rdata_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_CRAM_MSB_RDATA_STAT.
 */
#define BCMI_MADURA_READ_MST_CRAM_MSB_RDATA_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr,_r._mst_cram_msb_rdata_stat)
#define BCMI_MADURA_WRITE_MST_CRAM_MSB_RDATA_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr,_r._mst_cram_msb_rdata_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_CRAM_MSB_RDATA_STATr BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr
#define MST_CRAM_MSB_RDATA_STATr_SIZE BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_SIZE
typedef BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_t MST_CRAM_MSB_RDATA_STATr_t;
#define MST_CRAM_MSB_RDATA_STATr_CLR BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_CLR
#define MST_CRAM_MSB_RDATA_STATr_SET BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_SET
#define MST_CRAM_MSB_RDATA_STATr_GET BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_GET
#define MST_CRAM_MSB_RDATA_STATr_MST_CRAM_MSB_RDATAf_GET BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_MST_CRAM_MSB_RDATAf_GET
#define MST_CRAM_MSB_RDATA_STATr_MST_CRAM_MSB_RDATAf_SET BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr_MST_CRAM_MSB_RDATAf_SET
#define READ_MST_CRAM_MSB_RDATA_STATr BCMI_MADURA_READ_MST_CRAM_MSB_RDATA_STATr
#define WRITE_MST_CRAM_MSB_RDATA_STATr BCMI_MADURA_WRITE_MST_CRAM_MSB_RDATA_STATr
#define MODIFY_MST_CRAM_MSB_RDATA_STATr BCMI_MADURA_MODIFY_MST_CRAM_MSB_RDATA_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_CRAM_MSB_RDATA_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_DRAM_WDATA_CTL
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8414
 * DEVAD:    1
 * DESC:     Master M0 data ram back door write data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_DRAM_WDATA   Write data for back door write to Master M0 Data ram.
 */
#define BCMI_MADURA_MST_DRAM_WDATA_CTLr (0x00018414 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_DRAM_WDATA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MST_DRAM_WDATA_CTL.
 */
typedef union BCMI_MADURA_MST_DRAM_WDATA_CTLr_s {
	uint32_t v[1];
	uint32_t mst_dram_wdata_ctl[1];
	uint32_t _mst_dram_wdata_ctl;
} BCMI_MADURA_MST_DRAM_WDATA_CTLr_t;

#define BCMI_MADURA_MST_DRAM_WDATA_CTLr_CLR(r) (r).mst_dram_wdata_ctl[0] = 0
#define BCMI_MADURA_MST_DRAM_WDATA_CTLr_SET(r,d) (r).mst_dram_wdata_ctl[0] = d
#define BCMI_MADURA_MST_DRAM_WDATA_CTLr_GET(r) (r).mst_dram_wdata_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_DRAM_WDATA_CTLr_MST_DRAM_WDATAf_GET(r) (((r).mst_dram_wdata_ctl[0]) & 0xffff)
#define BCMI_MADURA_MST_DRAM_WDATA_CTLr_MST_DRAM_WDATAf_SET(r,f) (r).mst_dram_wdata_ctl[0]=(((r).mst_dram_wdata_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_DRAM_WDATA_CTL.
 */
#define BCMI_MADURA_READ_MST_DRAM_WDATA_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_DRAM_WDATA_CTLr,_r._mst_dram_wdata_ctl)
#define BCMI_MADURA_WRITE_MST_DRAM_WDATA_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_DRAM_WDATA_CTLr,_r._mst_dram_wdata_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_DRAM_WDATA_CTLr BCMI_MADURA_MST_DRAM_WDATA_CTLr
#define MST_DRAM_WDATA_CTLr_SIZE BCMI_MADURA_MST_DRAM_WDATA_CTLr_SIZE
typedef BCMI_MADURA_MST_DRAM_WDATA_CTLr_t MST_DRAM_WDATA_CTLr_t;
#define MST_DRAM_WDATA_CTLr_CLR BCMI_MADURA_MST_DRAM_WDATA_CTLr_CLR
#define MST_DRAM_WDATA_CTLr_SET BCMI_MADURA_MST_DRAM_WDATA_CTLr_SET
#define MST_DRAM_WDATA_CTLr_GET BCMI_MADURA_MST_DRAM_WDATA_CTLr_GET
#define MST_DRAM_WDATA_CTLr_MST_DRAM_WDATAf_GET BCMI_MADURA_MST_DRAM_WDATA_CTLr_MST_DRAM_WDATAf_GET
#define MST_DRAM_WDATA_CTLr_MST_DRAM_WDATAf_SET BCMI_MADURA_MST_DRAM_WDATA_CTLr_MST_DRAM_WDATAf_SET
#define READ_MST_DRAM_WDATA_CTLr BCMI_MADURA_READ_MST_DRAM_WDATA_CTLr
#define WRITE_MST_DRAM_WDATA_CTLr BCMI_MADURA_WRITE_MST_DRAM_WDATA_CTLr
#define MODIFY_MST_DRAM_WDATA_CTLr BCMI_MADURA_MODIFY_MST_DRAM_WDATA_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_DRAM_WDATA_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_DRAM_RDATA_STAT
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8415
 * DEVAD:    1
 * DESC:     Master M0 data ram back door read data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_DRAM_RDATA   Read data for back door read from Master M0 Data ram.
 */
#define BCMI_MADURA_MST_DRAM_RDATA_STATr (0x00018415 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_DRAM_RDATA_STATr_SIZE 4

/*
 * This structure should be used to declare and program MST_DRAM_RDATA_STAT.
 */
typedef union BCMI_MADURA_MST_DRAM_RDATA_STATr_s {
	uint32_t v[1];
	uint32_t mst_dram_rdata_stat[1];
	uint32_t _mst_dram_rdata_stat;
} BCMI_MADURA_MST_DRAM_RDATA_STATr_t;

#define BCMI_MADURA_MST_DRAM_RDATA_STATr_CLR(r) (r).mst_dram_rdata_stat[0] = 0
#define BCMI_MADURA_MST_DRAM_RDATA_STATr_SET(r,d) (r).mst_dram_rdata_stat[0] = d
#define BCMI_MADURA_MST_DRAM_RDATA_STATr_GET(r) (r).mst_dram_rdata_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_DRAM_RDATA_STATr_MST_DRAM_RDATAf_GET(r) (((r).mst_dram_rdata_stat[0]) & 0xffff)
#define BCMI_MADURA_MST_DRAM_RDATA_STATr_MST_DRAM_RDATAf_SET(r,f) (r).mst_dram_rdata_stat[0]=(((r).mst_dram_rdata_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_DRAM_RDATA_STAT.
 */
#define BCMI_MADURA_READ_MST_DRAM_RDATA_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_DRAM_RDATA_STATr,_r._mst_dram_rdata_stat)
#define BCMI_MADURA_WRITE_MST_DRAM_RDATA_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_DRAM_RDATA_STATr,_r._mst_dram_rdata_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_DRAM_RDATA_STATr BCMI_MADURA_MST_DRAM_RDATA_STATr
#define MST_DRAM_RDATA_STATr_SIZE BCMI_MADURA_MST_DRAM_RDATA_STATr_SIZE
typedef BCMI_MADURA_MST_DRAM_RDATA_STATr_t MST_DRAM_RDATA_STATr_t;
#define MST_DRAM_RDATA_STATr_CLR BCMI_MADURA_MST_DRAM_RDATA_STATr_CLR
#define MST_DRAM_RDATA_STATr_SET BCMI_MADURA_MST_DRAM_RDATA_STATr_SET
#define MST_DRAM_RDATA_STATr_GET BCMI_MADURA_MST_DRAM_RDATA_STATr_GET
#define MST_DRAM_RDATA_STATr_MST_DRAM_RDATAf_GET BCMI_MADURA_MST_DRAM_RDATA_STATr_MST_DRAM_RDATAf_GET
#define MST_DRAM_RDATA_STATr_MST_DRAM_RDATAf_SET BCMI_MADURA_MST_DRAM_RDATA_STATr_MST_DRAM_RDATAf_SET
#define READ_MST_DRAM_RDATA_STATr BCMI_MADURA_READ_MST_DRAM_RDATA_STATr
#define WRITE_MST_DRAM_RDATA_STATr BCMI_MADURA_WRITE_MST_DRAM_RDATA_STATr
#define MODIFY_MST_DRAM_RDATA_STATr BCMI_MADURA_MODIFY_MST_DRAM_RDATA_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_DRAM_RDATA_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_VT_WDATA_CTL
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8416
 * DEVAD:    1
 * DESC:     Master M0 vector table back door write data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_VT_WDATA     write data for back door write to Master M0 Vector Table.
 */
#define BCMI_MADURA_MST_VT_WDATA_CTLr (0x00018416 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_VT_WDATA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MST_VT_WDATA_CTL.
 */
typedef union BCMI_MADURA_MST_VT_WDATA_CTLr_s {
	uint32_t v[1];
	uint32_t mst_vt_wdata_ctl[1];
	uint32_t _mst_vt_wdata_ctl;
} BCMI_MADURA_MST_VT_WDATA_CTLr_t;

#define BCMI_MADURA_MST_VT_WDATA_CTLr_CLR(r) (r).mst_vt_wdata_ctl[0] = 0
#define BCMI_MADURA_MST_VT_WDATA_CTLr_SET(r,d) (r).mst_vt_wdata_ctl[0] = d
#define BCMI_MADURA_MST_VT_WDATA_CTLr_GET(r) (r).mst_vt_wdata_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_VT_WDATA_CTLr_MST_VT_WDATAf_GET(r) (((r).mst_vt_wdata_ctl[0]) & 0xffff)
#define BCMI_MADURA_MST_VT_WDATA_CTLr_MST_VT_WDATAf_SET(r,f) (r).mst_vt_wdata_ctl[0]=(((r).mst_vt_wdata_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_VT_WDATA_CTL.
 */
#define BCMI_MADURA_READ_MST_VT_WDATA_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_VT_WDATA_CTLr,_r._mst_vt_wdata_ctl)
#define BCMI_MADURA_WRITE_MST_VT_WDATA_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_VT_WDATA_CTLr,_r._mst_vt_wdata_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_VT_WDATA_CTLr BCMI_MADURA_MST_VT_WDATA_CTLr
#define MST_VT_WDATA_CTLr_SIZE BCMI_MADURA_MST_VT_WDATA_CTLr_SIZE
typedef BCMI_MADURA_MST_VT_WDATA_CTLr_t MST_VT_WDATA_CTLr_t;
#define MST_VT_WDATA_CTLr_CLR BCMI_MADURA_MST_VT_WDATA_CTLr_CLR
#define MST_VT_WDATA_CTLr_SET BCMI_MADURA_MST_VT_WDATA_CTLr_SET
#define MST_VT_WDATA_CTLr_GET BCMI_MADURA_MST_VT_WDATA_CTLr_GET
#define MST_VT_WDATA_CTLr_MST_VT_WDATAf_GET BCMI_MADURA_MST_VT_WDATA_CTLr_MST_VT_WDATAf_GET
#define MST_VT_WDATA_CTLr_MST_VT_WDATAf_SET BCMI_MADURA_MST_VT_WDATA_CTLr_MST_VT_WDATAf_SET
#define READ_MST_VT_WDATA_CTLr BCMI_MADURA_READ_MST_VT_WDATA_CTLr
#define WRITE_MST_VT_WDATA_CTLr BCMI_MADURA_WRITE_MST_VT_WDATA_CTLr
#define MODIFY_MST_VT_WDATA_CTLr BCMI_MADURA_MODIFY_MST_VT_WDATA_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_VT_WDATA_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_VT_RDATA_STAT
 * BLOCKS:   M0ACCESS_DATA
 * REGADDR:  0x8417
 * DEVAD:    1
 * DESC:     Master M0 vector table back door read data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_VT_RDATA     read data for back door read from Master M0 Vector Table.
 */
#define BCMI_MADURA_MST_VT_RDATA_STATr (0x00018417 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_VT_RDATA_STATr_SIZE 4

/*
 * This structure should be used to declare and program MST_VT_RDATA_STAT.
 */
typedef union BCMI_MADURA_MST_VT_RDATA_STATr_s {
	uint32_t v[1];
	uint32_t mst_vt_rdata_stat[1];
	uint32_t _mst_vt_rdata_stat;
} BCMI_MADURA_MST_VT_RDATA_STATr_t;

#define BCMI_MADURA_MST_VT_RDATA_STATr_CLR(r) (r).mst_vt_rdata_stat[0] = 0
#define BCMI_MADURA_MST_VT_RDATA_STATr_SET(r,d) (r).mst_vt_rdata_stat[0] = d
#define BCMI_MADURA_MST_VT_RDATA_STATr_GET(r) (r).mst_vt_rdata_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_VT_RDATA_STATr_MST_VT_RDATAf_GET(r) (((r).mst_vt_rdata_stat[0]) & 0xffff)
#define BCMI_MADURA_MST_VT_RDATA_STATr_MST_VT_RDATAf_SET(r,f) (r).mst_vt_rdata_stat[0]=(((r).mst_vt_rdata_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MST_VT_RDATA_STAT.
 */
#define BCMI_MADURA_READ_MST_VT_RDATA_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_VT_RDATA_STATr,_r._mst_vt_rdata_stat)
#define BCMI_MADURA_WRITE_MST_VT_RDATA_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_VT_RDATA_STATr,_r._mst_vt_rdata_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_VT_RDATA_STATr BCMI_MADURA_MST_VT_RDATA_STATr
#define MST_VT_RDATA_STATr_SIZE BCMI_MADURA_MST_VT_RDATA_STATr_SIZE
typedef BCMI_MADURA_MST_VT_RDATA_STATr_t MST_VT_RDATA_STATr_t;
#define MST_VT_RDATA_STATr_CLR BCMI_MADURA_MST_VT_RDATA_STATr_CLR
#define MST_VT_RDATA_STATr_SET BCMI_MADURA_MST_VT_RDATA_STATr_SET
#define MST_VT_RDATA_STATr_GET BCMI_MADURA_MST_VT_RDATA_STATr_GET
#define MST_VT_RDATA_STATr_MST_VT_RDATAf_GET BCMI_MADURA_MST_VT_RDATA_STATr_MST_VT_RDATAf_GET
#define MST_VT_RDATA_STATr_MST_VT_RDATAf_SET BCMI_MADURA_MST_VT_RDATA_STATr_MST_VT_RDATAf_SET
#define READ_MST_VT_RDATA_STATr BCMI_MADURA_READ_MST_VT_RDATA_STATr
#define WRITE_MST_VT_RDATA_STATr BCMI_MADURA_WRITE_MST_VT_RDATA_STATr
#define MODIFY_MST_VT_RDATA_STATr BCMI_MADURA_MODIFY_MST_VT_RDATA_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_VT_RDATA_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODULE_CTL_CTL
 * BLOCKS:   MODULE_CNTRL
 * REGADDR:  0x8700
 * DEVAD:    1
 * DESC:     Module controller main control register
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     EXTEND_CMD       I2C slave extended command
 *     SLAVE_CMD        I2C slave command
 *     SL_DAT_CNT       I2C slave data width
 *     SL_ADD_CNT       I2C slave address width
 *     I2CFLUSH         Flush External module
 *     I2C_EN           Enable I2C master
 */
#define BCMI_MADURA_MODULE_CTL_CTLr (0x00018700 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODULE_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MODULE_CTL_CTL.
 */
typedef union BCMI_MADURA_MODULE_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t module_ctl_ctl[1];
	uint32_t _module_ctl_ctl;
} BCMI_MADURA_MODULE_CTL_CTLr_t;

#define BCMI_MADURA_MODULE_CTL_CTLr_CLR(r) (r).module_ctl_ctl[0] = 0
#define BCMI_MADURA_MODULE_CTL_CTLr_SET(r,d) (r).module_ctl_ctl[0] = d
#define BCMI_MADURA_MODULE_CTL_CTLr_GET(r) (r).module_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODULE_CTL_CTLr_I2C_ENf_GET(r) ((((r).module_ctl_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_MODULE_CTL_CTLr_I2C_ENf_SET(r,f) (r).module_ctl_ctl[0]=(((r).module_ctl_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_MODULE_CTL_CTLr_I2CFLUSHf_GET(r) ((((r).module_ctl_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_MODULE_CTL_CTLr_I2CFLUSHf_SET(r,f) (r).module_ctl_ctl[0]=(((r).module_ctl_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_MODULE_CTL_CTLr_SL_ADD_CNTf_GET(r) ((((r).module_ctl_ctl[0]) >> 13) & 0x1)
#define BCMI_MADURA_MODULE_CTL_CTLr_SL_ADD_CNTf_SET(r,f) (r).module_ctl_ctl[0]=(((r).module_ctl_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_MODULE_CTL_CTLr_SL_DAT_CNTf_GET(r) ((((r).module_ctl_ctl[0]) >> 12) & 0x1)
#define BCMI_MADURA_MODULE_CTL_CTLr_SL_DAT_CNTf_SET(r,f) (r).module_ctl_ctl[0]=(((r).module_ctl_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_MODULE_CTL_CTLr_SLAVE_CMDf_GET(r) ((((r).module_ctl_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_MODULE_CTL_CTLr_SLAVE_CMDf_SET(r,f) (r).module_ctl_ctl[0]=(((r).module_ctl_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MODULE_CTL_CTLr_EXTEND_CMDf_GET(r) (((r).module_ctl_ctl[0]) & 0x3)
#define BCMI_MADURA_MODULE_CTL_CTLr_EXTEND_CMDf_SET(r,f) (r).module_ctl_ctl[0]=(((r).module_ctl_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MODULE_CTL_CTL.
 */
#define BCMI_MADURA_READ_MODULE_CTL_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODULE_CTL_CTLr,_r._module_ctl_ctl)
#define BCMI_MADURA_WRITE_MODULE_CTL_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODULE_CTL_CTLr,_r._module_ctl_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODULE_CTL_CTLr BCMI_MADURA_MODULE_CTL_CTLr
#define MODULE_CTL_CTLr_SIZE BCMI_MADURA_MODULE_CTL_CTLr_SIZE
typedef BCMI_MADURA_MODULE_CTL_CTLr_t MODULE_CTL_CTLr_t;
#define MODULE_CTL_CTLr_CLR BCMI_MADURA_MODULE_CTL_CTLr_CLR
#define MODULE_CTL_CTLr_SET BCMI_MADURA_MODULE_CTL_CTLr_SET
#define MODULE_CTL_CTLr_GET BCMI_MADURA_MODULE_CTL_CTLr_GET
#define MODULE_CTL_CTLr_I2C_ENf_GET BCMI_MADURA_MODULE_CTL_CTLr_I2C_ENf_GET
#define MODULE_CTL_CTLr_I2C_ENf_SET BCMI_MADURA_MODULE_CTL_CTLr_I2C_ENf_SET
#define MODULE_CTL_CTLr_I2CFLUSHf_GET BCMI_MADURA_MODULE_CTL_CTLr_I2CFLUSHf_GET
#define MODULE_CTL_CTLr_I2CFLUSHf_SET BCMI_MADURA_MODULE_CTL_CTLr_I2CFLUSHf_SET
#define MODULE_CTL_CTLr_SL_ADD_CNTf_GET BCMI_MADURA_MODULE_CTL_CTLr_SL_ADD_CNTf_GET
#define MODULE_CTL_CTLr_SL_ADD_CNTf_SET BCMI_MADURA_MODULE_CTL_CTLr_SL_ADD_CNTf_SET
#define MODULE_CTL_CTLr_SL_DAT_CNTf_GET BCMI_MADURA_MODULE_CTL_CTLr_SL_DAT_CNTf_GET
#define MODULE_CTL_CTLr_SL_DAT_CNTf_SET BCMI_MADURA_MODULE_CTL_CTLr_SL_DAT_CNTf_SET
#define MODULE_CTL_CTLr_SLAVE_CMDf_GET BCMI_MADURA_MODULE_CTL_CTLr_SLAVE_CMDf_GET
#define MODULE_CTL_CTLr_SLAVE_CMDf_SET BCMI_MADURA_MODULE_CTL_CTLr_SLAVE_CMDf_SET
#define MODULE_CTL_CTLr_EXTEND_CMDf_GET BCMI_MADURA_MODULE_CTL_CTLr_EXTEND_CMDf_GET
#define MODULE_CTL_CTLr_EXTEND_CMDf_SET BCMI_MADURA_MODULE_CTL_CTLr_EXTEND_CMDf_SET
#define READ_MODULE_CTL_CTLr BCMI_MADURA_READ_MODULE_CTL_CTLr
#define WRITE_MODULE_CTL_CTLr BCMI_MADURA_WRITE_MODULE_CTL_CTLr
#define MODIFY_MODULE_CTL_CTLr BCMI_MADURA_MODIFY_MODULE_CTL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODULE_CTL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODULE_CTL_STS
 * BLOCKS:   MODULE_CNTRL
 * REGADDR:  0x8701
 * DEVAD:    1
 * DESC:     Module controller status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     XACTION_DONE     I2c master transaction done, set when transaction done, and cleared when new command issued
 *     I2CM_STAT        I2C master status
 *     SDA_LATCH_HIGH   SDA Latch High
 *     SDA_LATCH_LOW    SDA Latch Low
 *     SDA_LIVE_STATUS  SDA Live Status
 *     SCL_LATCH_HIGH   SCL Latch High
 *     SCL_LATCH_LOW    SCL Latch Low
 *     SCL_LIVE_STATUS  SCL Live Status
 */
#define BCMI_MADURA_MODULE_CTL_STSr (0x00018701 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODULE_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program MODULE_CTL_STS.
 */
typedef union BCMI_MADURA_MODULE_CTL_STSr_s {
	uint32_t v[1];
	uint32_t module_ctl_sts[1];
	uint32_t _module_ctl_sts;
} BCMI_MADURA_MODULE_CTL_STSr_t;

#define BCMI_MADURA_MODULE_CTL_STSr_CLR(r) (r).module_ctl_sts[0] = 0
#define BCMI_MADURA_MODULE_CTL_STSr_SET(r,d) (r).module_ctl_sts[0] = d
#define BCMI_MADURA_MODULE_CTL_STSr_GET(r) (r).module_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODULE_CTL_STSr_SCL_LIVE_STATUSf_GET(r) ((((r).module_ctl_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_MODULE_CTL_STSr_SCL_LIVE_STATUSf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_LOWf_GET(r) ((((r).module_ctl_sts[0]) >> 7) & 0x1)
#define BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_LOWf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_HIGHf_GET(r) ((((r).module_ctl_sts[0]) >> 6) & 0x1)
#define BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_HIGHf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MODULE_CTL_STSr_SDA_LIVE_STATUSf_GET(r) ((((r).module_ctl_sts[0]) >> 5) & 0x1)
#define BCMI_MADURA_MODULE_CTL_STSr_SDA_LIVE_STATUSf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_LOWf_GET(r) ((((r).module_ctl_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_LOWf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_HIGHf_GET(r) ((((r).module_ctl_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_HIGHf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MODULE_CTL_STSr_I2CM_STATf_GET(r) ((((r).module_ctl_sts[0]) >> 1) & 0x3)
#define BCMI_MADURA_MODULE_CTL_STSr_I2CM_STATf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x3 << 1)) | ((((uint32_t)f) & 0x3) << 1)) | (3 << (16 + 1))
#define BCMI_MADURA_MODULE_CTL_STSr_XACTION_DONEf_GET(r) (((r).module_ctl_sts[0]) & 0x1)
#define BCMI_MADURA_MODULE_CTL_STSr_XACTION_DONEf_SET(r,f) (r).module_ctl_sts[0]=(((r).module_ctl_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MODULE_CTL_STS.
 */
#define BCMI_MADURA_READ_MODULE_CTL_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODULE_CTL_STSr,_r._module_ctl_sts)
#define BCMI_MADURA_WRITE_MODULE_CTL_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODULE_CTL_STSr,_r._module_ctl_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODULE_CTL_STSr BCMI_MADURA_MODULE_CTL_STSr
#define MODULE_CTL_STSr_SIZE BCMI_MADURA_MODULE_CTL_STSr_SIZE
typedef BCMI_MADURA_MODULE_CTL_STSr_t MODULE_CTL_STSr_t;
#define MODULE_CTL_STSr_CLR BCMI_MADURA_MODULE_CTL_STSr_CLR
#define MODULE_CTL_STSr_SET BCMI_MADURA_MODULE_CTL_STSr_SET
#define MODULE_CTL_STSr_GET BCMI_MADURA_MODULE_CTL_STSr_GET
#define MODULE_CTL_STSr_SCL_LIVE_STATUSf_GET BCMI_MADURA_MODULE_CTL_STSr_SCL_LIVE_STATUSf_GET
#define MODULE_CTL_STSr_SCL_LIVE_STATUSf_SET BCMI_MADURA_MODULE_CTL_STSr_SCL_LIVE_STATUSf_SET
#define MODULE_CTL_STSr_SCL_LATCH_LOWf_GET BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_LOWf_GET
#define MODULE_CTL_STSr_SCL_LATCH_LOWf_SET BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_LOWf_SET
#define MODULE_CTL_STSr_SCL_LATCH_HIGHf_GET BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_HIGHf_GET
#define MODULE_CTL_STSr_SCL_LATCH_HIGHf_SET BCMI_MADURA_MODULE_CTL_STSr_SCL_LATCH_HIGHf_SET
#define MODULE_CTL_STSr_SDA_LIVE_STATUSf_GET BCMI_MADURA_MODULE_CTL_STSr_SDA_LIVE_STATUSf_GET
#define MODULE_CTL_STSr_SDA_LIVE_STATUSf_SET BCMI_MADURA_MODULE_CTL_STSr_SDA_LIVE_STATUSf_SET
#define MODULE_CTL_STSr_SDA_LATCH_LOWf_GET BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_LOWf_GET
#define MODULE_CTL_STSr_SDA_LATCH_LOWf_SET BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_LOWf_SET
#define MODULE_CTL_STSr_SDA_LATCH_HIGHf_GET BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_HIGHf_GET
#define MODULE_CTL_STSr_SDA_LATCH_HIGHf_SET BCMI_MADURA_MODULE_CTL_STSr_SDA_LATCH_HIGHf_SET
#define MODULE_CTL_STSr_I2CM_STATf_GET BCMI_MADURA_MODULE_CTL_STSr_I2CM_STATf_GET
#define MODULE_CTL_STSr_I2CM_STATf_SET BCMI_MADURA_MODULE_CTL_STSr_I2CM_STATf_SET
#define MODULE_CTL_STSr_XACTION_DONEf_GET BCMI_MADURA_MODULE_CTL_STSr_XACTION_DONEf_GET
#define MODULE_CTL_STSr_XACTION_DONEf_SET BCMI_MADURA_MODULE_CTL_STSr_XACTION_DONEf_SET
#define READ_MODULE_CTL_STSr BCMI_MADURA_READ_MODULE_CTL_STSr
#define WRITE_MODULE_CTL_STSr BCMI_MADURA_WRITE_MODULE_CTL_STSr
#define MODIFY_MODULE_CTL_STSr BCMI_MADURA_MODIFY_MODULE_CTL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODULE_CTL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  XFER_CNT
 * BLOCKS:   MODULE_CNTRL
 * REGADDR:  0x8702
 * DEVAD:    1
 * DESC:     Number of consecutive read or write through I2C bus
 * RESETVAL: 0x1ff (511)
 * ACCESS:   R/W
 * FIELDS:
 *     XFER_CNT         transfer count, should be lass than 4 for writeWhen chk_live_status is 1'b1, read this register returns the live status,i.e. the remaining number of transfers to be doneWhen chk_live_status is 1'b0, read this register returns the configuration0: 1 byte1: 2 byte...255: 256 byte
 *     PAGE_2LD         upper address page to be loadedbit 11:8 corresponding to page 3:0
 *     CHK_LIVE_STATUS  If set, read to xfer_cnt, slave_addr and xfer_addr returns live statusotherwise returns configuration value
 */
#define BCMI_MADURA_XFER_CNTr (0x00018702 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_XFER_CNTr_SIZE 4

/*
 * This structure should be used to declare and program XFER_CNT.
 */
typedef union BCMI_MADURA_XFER_CNTr_s {
	uint32_t v[1];
	uint32_t xfer_cnt[1];
	uint32_t _xfer_cnt;
} BCMI_MADURA_XFER_CNTr_t;

#define BCMI_MADURA_XFER_CNTr_CLR(r) (r).xfer_cnt[0] = 0
#define BCMI_MADURA_XFER_CNTr_SET(r,d) (r).xfer_cnt[0] = d
#define BCMI_MADURA_XFER_CNTr_GET(r) (r).xfer_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_XFER_CNTr_CHK_LIVE_STATUSf_GET(r) ((((r).xfer_cnt[0]) >> 12) & 0x1)
#define BCMI_MADURA_XFER_CNTr_CHK_LIVE_STATUSf_SET(r,f) (r).xfer_cnt[0]=(((r).xfer_cnt[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_XFER_CNTr_PAGE_2LDf_GET(r) ((((r).xfer_cnt[0]) >> 8) & 0xf)
#define BCMI_MADURA_XFER_CNTr_PAGE_2LDf_SET(r,f) (r).xfer_cnt[0]=(((r).xfer_cnt[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_XFER_CNTr_XFER_CNTf_GET(r) (((r).xfer_cnt[0]) & 0xff)
#define BCMI_MADURA_XFER_CNTr_XFER_CNTf_SET(r,f) (r).xfer_cnt[0]=(((r).xfer_cnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access XFER_CNT.
 */
#define BCMI_MADURA_READ_XFER_CNTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_XFER_CNTr,_r._xfer_cnt)
#define BCMI_MADURA_WRITE_XFER_CNTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_XFER_CNTr,_r._xfer_cnt)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define XFER_CNTr BCMI_MADURA_XFER_CNTr
#define XFER_CNTr_SIZE BCMI_MADURA_XFER_CNTr_SIZE
typedef BCMI_MADURA_XFER_CNTr_t XFER_CNTr_t;
#define XFER_CNTr_CLR BCMI_MADURA_XFER_CNTr_CLR
#define XFER_CNTr_SET BCMI_MADURA_XFER_CNTr_SET
#define XFER_CNTr_GET BCMI_MADURA_XFER_CNTr_GET
#define XFER_CNTr_CHK_LIVE_STATUSf_GET BCMI_MADURA_XFER_CNTr_CHK_LIVE_STATUSf_GET
#define XFER_CNTr_CHK_LIVE_STATUSf_SET BCMI_MADURA_XFER_CNTr_CHK_LIVE_STATUSf_SET
#define XFER_CNTr_PAGE_2LDf_GET BCMI_MADURA_XFER_CNTr_PAGE_2LDf_GET
#define XFER_CNTr_PAGE_2LDf_SET BCMI_MADURA_XFER_CNTr_PAGE_2LDf_SET
#define XFER_CNTr_XFER_CNTf_GET BCMI_MADURA_XFER_CNTr_XFER_CNTf_GET
#define XFER_CNTr_XFER_CNTf_SET BCMI_MADURA_XFER_CNTr_XFER_CNTf_SET
#define READ_XFER_CNTr BCMI_MADURA_READ_XFER_CNTr
#define WRITE_XFER_CNTr BCMI_MADURA_WRITE_XFER_CNTr
#define MODIFY_XFER_CNTr BCMI_MADURA_MODIFY_XFER_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_XFER_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADDR
 * BLOCKS:   MODULE_CNTRL
 * REGADDR:  0x8703
 * DEVAD:    1
 * DESC:     start of I2c Slave address to be accessed
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLAVE_ADDR       When chk_live_status is 1'b0, read this register returns the configurationi.e. the start I2c Slave address to be accessedWhen chk_live_status is 1'b1, read this register returns the live status,i.e. the next I2c Slave address to be accessed
 */
#define BCMI_MADURA_ADDRr (0x00018703 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program ADDR.
 */
typedef union BCMI_MADURA_ADDRr_s {
	uint32_t v[1];
	uint32_t addr[1];
	uint32_t _addr;
} BCMI_MADURA_ADDRr_t;

#define BCMI_MADURA_ADDRr_CLR(r) (r).addr[0] = 0
#define BCMI_MADURA_ADDRr_SET(r,d) (r).addr[0] = d
#define BCMI_MADURA_ADDRr_GET(r) (r).addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADDRr_SLAVE_ADDRf_GET(r) (((r).addr[0]) & 0xffff)
#define BCMI_MADURA_ADDRr_SLAVE_ADDRf_SET(r,f) (r).addr[0]=(((r).addr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access ADDR.
 */
#define BCMI_MADURA_READ_ADDRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADDRr,_r._addr)
#define BCMI_MADURA_WRITE_ADDRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADDRr,_r._addr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADDRr BCMI_MADURA_ADDRr
#define ADDRr_SIZE BCMI_MADURA_ADDRr_SIZE
typedef BCMI_MADURA_ADDRr_t ADDRr_t;
#define ADDRr_CLR BCMI_MADURA_ADDRr_CLR
#define ADDRr_SET BCMI_MADURA_ADDRr_SET
#define ADDRr_GET BCMI_MADURA_ADDRr_GET
#define ADDRr_SLAVE_ADDRf_GET BCMI_MADURA_ADDRr_SLAVE_ADDRf_GET
#define ADDRr_SLAVE_ADDRf_SET BCMI_MADURA_ADDRr_SLAVE_ADDRf_SET
#define READ_ADDRr BCMI_MADURA_READ_ADDRr
#define WRITE_ADDRr BCMI_MADURA_WRITE_ADDRr
#define MODIFY_ADDRr BCMI_MADURA_MODIFY_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  XFER_ADDR
 * BLOCKS:   MODULE_CNTRL
 * REGADDR:  0x8704
 * DEVAD:    1
 * DESC:     NVRAM start address to be accessed
 * RESETVAL: 0x8800 (34816)
 * ACCESS:   R/W
 * FIELDS:
 *     XFER_ADDR        When chk_live_status is 1'b0, read this register returns the configurationi.e. the NVRAM start address to be accessedWhen chk_live_status is 1'b1, read this register returns the live status,i.e. the next NVRAM address to be accessed
 */
#define BCMI_MADURA_XFER_ADDRr (0x00018704 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_XFER_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program XFER_ADDR.
 */
typedef union BCMI_MADURA_XFER_ADDRr_s {
	uint32_t v[1];
	uint32_t xfer_addr[1];
	uint32_t _xfer_addr;
} BCMI_MADURA_XFER_ADDRr_t;

#define BCMI_MADURA_XFER_ADDRr_CLR(r) (r).xfer_addr[0] = 0
#define BCMI_MADURA_XFER_ADDRr_SET(r,d) (r).xfer_addr[0] = d
#define BCMI_MADURA_XFER_ADDRr_GET(r) (r).xfer_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_XFER_ADDRr_XFER_ADDRf_GET(r) (((r).xfer_addr[0]) & 0xffff)
#define BCMI_MADURA_XFER_ADDRr_XFER_ADDRf_SET(r,f) (r).xfer_addr[0]=(((r).xfer_addr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access XFER_ADDR.
 */
#define BCMI_MADURA_READ_XFER_ADDRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_XFER_ADDRr,_r._xfer_addr)
#define BCMI_MADURA_WRITE_XFER_ADDRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_XFER_ADDRr,_r._xfer_addr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define XFER_ADDRr BCMI_MADURA_XFER_ADDRr
#define XFER_ADDRr_SIZE BCMI_MADURA_XFER_ADDRr_SIZE
typedef BCMI_MADURA_XFER_ADDRr_t XFER_ADDRr_t;
#define XFER_ADDRr_CLR BCMI_MADURA_XFER_ADDRr_CLR
#define XFER_ADDRr_SET BCMI_MADURA_XFER_ADDRr_SET
#define XFER_ADDRr_GET BCMI_MADURA_XFER_ADDRr_GET
#define XFER_ADDRr_XFER_ADDRf_GET BCMI_MADURA_XFER_ADDRr_XFER_ADDRf_GET
#define XFER_ADDRr_XFER_ADDRf_SET BCMI_MADURA_XFER_ADDRr_XFER_ADDRf_SET
#define READ_XFER_ADDRr BCMI_MADURA_READ_XFER_ADDRr
#define WRITE_XFER_ADDRr BCMI_MADURA_WRITE_XFER_ADDRr
#define MODIFY_XFER_ADDRr BCMI_MADURA_MODIFY_XFER_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_XFER_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DEV_ID
 * BLOCKS:   MODULE_CNTRL
 * REGADDR:  0x8705
 * DEVAD:    1
 * DESC:     slave device ID
 * RESETVAL: 0xa001 (40961)
 * ACCESS:   R/W
 * FIELDS:
 *     SLAVE_ADDR_MSB   start I2c Slave address to be accessed, MSB
 *     I2C_SPEED        I2C clock frequency
 *     SL_DEV_ADD       slave device ID
 */
#define BCMI_MADURA_DEV_IDr (0x00018705 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DEV_IDr_SIZE 4

/*
 * This structure should be used to declare and program DEV_ID.
 */
typedef union BCMI_MADURA_DEV_IDr_s {
	uint32_t v[1];
	uint32_t dev_id[1];
	uint32_t _dev_id;
} BCMI_MADURA_DEV_IDr_t;

#define BCMI_MADURA_DEV_IDr_CLR(r) (r).dev_id[0] = 0
#define BCMI_MADURA_DEV_IDr_SET(r,d) (r).dev_id[0] = d
#define BCMI_MADURA_DEV_IDr_GET(r) (r).dev_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DEV_IDr_SL_DEV_ADDf_GET(r) ((((r).dev_id[0]) >> 9) & 0x7f)
#define BCMI_MADURA_DEV_IDr_SL_DEV_ADDf_SET(r,f) (r).dev_id[0]=(((r).dev_id[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9)) | (127 << (16 + 9))
#define BCMI_MADURA_DEV_IDr_I2C_SPEEDf_GET(r) ((((r).dev_id[0]) >> 8) & 0x1)
#define BCMI_MADURA_DEV_IDr_I2C_SPEEDf_SET(r,f) (r).dev_id[0]=(((r).dev_id[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_DEV_IDr_SLAVE_ADDR_MSBf_GET(r) (((r).dev_id[0]) & 0xff)
#define BCMI_MADURA_DEV_IDr_SLAVE_ADDR_MSBf_SET(r,f) (r).dev_id[0]=(((r).dev_id[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DEV_ID.
 */
#define BCMI_MADURA_READ_DEV_IDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DEV_IDr,_r._dev_id)
#define BCMI_MADURA_WRITE_DEV_IDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DEV_IDr,_r._dev_id)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DEV_IDr BCMI_MADURA_DEV_IDr
#define DEV_IDr_SIZE BCMI_MADURA_DEV_IDr_SIZE
typedef BCMI_MADURA_DEV_IDr_t DEV_IDr_t;
#define DEV_IDr_CLR BCMI_MADURA_DEV_IDr_CLR
#define DEV_IDr_SET BCMI_MADURA_DEV_IDr_SET
#define DEV_IDr_GET BCMI_MADURA_DEV_IDr_GET
#define DEV_IDr_SL_DEV_ADDf_GET BCMI_MADURA_DEV_IDr_SL_DEV_ADDf_GET
#define DEV_IDr_SL_DEV_ADDf_SET BCMI_MADURA_DEV_IDr_SL_DEV_ADDf_SET
#define DEV_IDr_I2C_SPEEDf_GET BCMI_MADURA_DEV_IDr_I2C_SPEEDf_GET
#define DEV_IDr_I2C_SPEEDf_SET BCMI_MADURA_DEV_IDr_I2C_SPEEDf_SET
#define DEV_IDr_SLAVE_ADDR_MSBf_GET BCMI_MADURA_DEV_IDr_SLAVE_ADDR_MSBf_GET
#define DEV_IDr_SLAVE_ADDR_MSBf_SET BCMI_MADURA_DEV_IDr_SLAVE_ADDR_MSBf_SET
#define READ_DEV_IDr BCMI_MADURA_READ_DEV_IDr
#define WRITE_DEV_IDr BCMI_MADURA_WRITE_DEV_IDr
#define MODIFY_DEV_IDr BCMI_MADURA_MODIFY_DEV_IDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DEV_IDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_0_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a30
 * DEVAD:    1
 * DESC:     PAD bondsel_0 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_0_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     BONDSEL_0_INVERT_EN enable polarity invertion for pad input or output
 *     BONDSEL_0_OUT_FRCVAL the forced output value
 *     BONDSEL_0_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (bondsel_0_ibof) is set to 0{bondsel_0_ibof, bondsel_0_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_BONDSEL_0_CTLr (0x00018a30 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_0_CTLr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_0_CTL.
 */
typedef union BCMI_MADURA_BONDSEL_0_CTLr_s {
	uint32_t v[1];
	uint32_t bondsel_0_ctl[1];
	uint32_t _bondsel_0_ctl;
} BCMI_MADURA_BONDSEL_0_CTLr_t;

#define BCMI_MADURA_BONDSEL_0_CTLr_CLR(r) (r).bondsel_0_ctl[0] = 0
#define BCMI_MADURA_BONDSEL_0_CTLr_SET(r,d) (r).bondsel_0_ctl[0] = d
#define BCMI_MADURA_BONDSEL_0_CTLr_GET(r) (r).bondsel_0_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_DGLH_CNTf_GET(r) ((((r).bondsel_0_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_DGLH_CNTf_SET(r,f) (r).bondsel_0_ctl[0]=(((r).bondsel_0_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_OUT_FRCVALf_GET(r) ((((r).bondsel_0_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_OUT_FRCVALf_SET(r,f) (r).bondsel_0_ctl[0]=(((r).bondsel_0_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_INVERT_ENf_GET(r) ((((r).bondsel_0_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_INVERT_ENf_SET(r,f) (r).bondsel_0_ctl[0]=(((r).bondsel_0_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_IBOFf_GET(r) ((((r).bondsel_0_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_IBOFf_SET(r,f) (r).bondsel_0_ctl[0]=(((r).bondsel_0_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access BONDSEL_0_CTL.
 */
#define BCMI_MADURA_READ_BONDSEL_0_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_0_CTLr,_r._bondsel_0_ctl)
#define BCMI_MADURA_WRITE_BONDSEL_0_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_0_CTLr,_r._bondsel_0_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_0_CTLr BCMI_MADURA_BONDSEL_0_CTLr
#define BONDSEL_0_CTLr_SIZE BCMI_MADURA_BONDSEL_0_CTLr_SIZE
typedef BCMI_MADURA_BONDSEL_0_CTLr_t BONDSEL_0_CTLr_t;
#define BONDSEL_0_CTLr_CLR BCMI_MADURA_BONDSEL_0_CTLr_CLR
#define BONDSEL_0_CTLr_SET BCMI_MADURA_BONDSEL_0_CTLr_SET
#define BONDSEL_0_CTLr_GET BCMI_MADURA_BONDSEL_0_CTLr_GET
#define BONDSEL_0_CTLr_BONDSEL_0_DGLH_CNTf_GET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_DGLH_CNTf_GET
#define BONDSEL_0_CTLr_BONDSEL_0_DGLH_CNTf_SET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_DGLH_CNTf_SET
#define BONDSEL_0_CTLr_BONDSEL_0_OUT_FRCVALf_GET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_OUT_FRCVALf_GET
#define BONDSEL_0_CTLr_BONDSEL_0_OUT_FRCVALf_SET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_OUT_FRCVALf_SET
#define BONDSEL_0_CTLr_BONDSEL_0_INVERT_ENf_GET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_INVERT_ENf_GET
#define BONDSEL_0_CTLr_BONDSEL_0_INVERT_ENf_SET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_INVERT_ENf_SET
#define BONDSEL_0_CTLr_BONDSEL_0_IBOFf_GET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_IBOFf_GET
#define BONDSEL_0_CTLr_BONDSEL_0_IBOFf_SET BCMI_MADURA_BONDSEL_0_CTLr_BONDSEL_0_IBOFf_SET
#define READ_BONDSEL_0_CTLr BCMI_MADURA_READ_BONDSEL_0_CTLr
#define WRITE_BONDSEL_0_CTLr BCMI_MADURA_WRITE_BONDSEL_0_CTLr
#define MODIFY_BONDSEL_0_CTLr BCMI_MADURA_MODIFY_BONDSEL_0_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_0_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_0_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a31
 * DEVAD:    1
 * DESC:     PAD bondsel_0 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_0_DIN_LH pad input latch highstatus
 *     BONDSEL_0_DIN_LL pad input latch low status
 *     BONDSEL_0_DIN    live pad input value
 */
#define BCMI_MADURA_BONDSEL_0_STSr (0x00018a31 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_0_STSr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_0_STS.
 */
typedef union BCMI_MADURA_BONDSEL_0_STSr_s {
	uint32_t v[1];
	uint32_t bondsel_0_sts[1];
	uint32_t _bondsel_0_sts;
} BCMI_MADURA_BONDSEL_0_STSr_t;

#define BCMI_MADURA_BONDSEL_0_STSr_CLR(r) (r).bondsel_0_sts[0] = 0
#define BCMI_MADURA_BONDSEL_0_STSr_SET(r,d) (r).bondsel_0_sts[0] = d
#define BCMI_MADURA_BONDSEL_0_STSr_GET(r) (r).bondsel_0_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DINf_GET(r) ((((r).bondsel_0_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DINf_SET(r,f) (r).bondsel_0_sts[0]=(((r).bondsel_0_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LLf_GET(r) ((((r).bondsel_0_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LLf_SET(r,f) (r).bondsel_0_sts[0]=(((r).bondsel_0_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LHf_GET(r) (((r).bondsel_0_sts[0]) & 0x1)
#define BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LHf_SET(r,f) (r).bondsel_0_sts[0]=(((r).bondsel_0_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access BONDSEL_0_STS.
 */
#define BCMI_MADURA_READ_BONDSEL_0_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_0_STSr,_r._bondsel_0_sts)
#define BCMI_MADURA_WRITE_BONDSEL_0_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_0_STSr,_r._bondsel_0_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_0_STSr BCMI_MADURA_BONDSEL_0_STSr
#define BONDSEL_0_STSr_SIZE BCMI_MADURA_BONDSEL_0_STSr_SIZE
typedef BCMI_MADURA_BONDSEL_0_STSr_t BONDSEL_0_STSr_t;
#define BONDSEL_0_STSr_CLR BCMI_MADURA_BONDSEL_0_STSr_CLR
#define BONDSEL_0_STSr_SET BCMI_MADURA_BONDSEL_0_STSr_SET
#define BONDSEL_0_STSr_GET BCMI_MADURA_BONDSEL_0_STSr_GET
#define BONDSEL_0_STSr_BONDSEL_0_DINf_GET BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DINf_GET
#define BONDSEL_0_STSr_BONDSEL_0_DINf_SET BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DINf_SET
#define BONDSEL_0_STSr_BONDSEL_0_DIN_LLf_GET BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LLf_GET
#define BONDSEL_0_STSr_BONDSEL_0_DIN_LLf_SET BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LLf_SET
#define BONDSEL_0_STSr_BONDSEL_0_DIN_LHf_GET BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LHf_GET
#define BONDSEL_0_STSr_BONDSEL_0_DIN_LHf_SET BCMI_MADURA_BONDSEL_0_STSr_BONDSEL_0_DIN_LHf_SET
#define READ_BONDSEL_0_STSr BCMI_MADURA_READ_BONDSEL_0_STSr
#define WRITE_BONDSEL_0_STSr BCMI_MADURA_WRITE_BONDSEL_0_STSr
#define MODIFY_BONDSEL_0_STSr BCMI_MADURA_MODIFY_BONDSEL_0_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_0_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_1_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a32
 * DEVAD:    1
 * DESC:     PAD bondsel_1 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_1_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     BONDSEL_1_INVERT_EN enable polarity invertion for pad input or output
 *     BONDSEL_1_OUT_FRCVAL the forced output value
 *     BONDSEL_1_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (bondsel_1_ibof) is set to 0{bondsel_1_ibof, bondsel_1_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_BONDSEL_1_CTLr (0x00018a32 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_1_CTL.
 */
typedef union BCMI_MADURA_BONDSEL_1_CTLr_s {
	uint32_t v[1];
	uint32_t bondsel_1_ctl[1];
	uint32_t _bondsel_1_ctl;
} BCMI_MADURA_BONDSEL_1_CTLr_t;

#define BCMI_MADURA_BONDSEL_1_CTLr_CLR(r) (r).bondsel_1_ctl[0] = 0
#define BCMI_MADURA_BONDSEL_1_CTLr_SET(r,d) (r).bondsel_1_ctl[0] = d
#define BCMI_MADURA_BONDSEL_1_CTLr_GET(r) (r).bondsel_1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_DGLH_CNTf_GET(r) ((((r).bondsel_1_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_DGLH_CNTf_SET(r,f) (r).bondsel_1_ctl[0]=(((r).bondsel_1_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_OUT_FRCVALf_GET(r) ((((r).bondsel_1_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_OUT_FRCVALf_SET(r,f) (r).bondsel_1_ctl[0]=(((r).bondsel_1_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_INVERT_ENf_GET(r) ((((r).bondsel_1_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_INVERT_ENf_SET(r,f) (r).bondsel_1_ctl[0]=(((r).bondsel_1_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_IBOFf_GET(r) ((((r).bondsel_1_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_IBOFf_SET(r,f) (r).bondsel_1_ctl[0]=(((r).bondsel_1_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access BONDSEL_1_CTL.
 */
#define BCMI_MADURA_READ_BONDSEL_1_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_1_CTLr,_r._bondsel_1_ctl)
#define BCMI_MADURA_WRITE_BONDSEL_1_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_1_CTLr,_r._bondsel_1_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_1_CTLr BCMI_MADURA_BONDSEL_1_CTLr
#define BONDSEL_1_CTLr_SIZE BCMI_MADURA_BONDSEL_1_CTLr_SIZE
typedef BCMI_MADURA_BONDSEL_1_CTLr_t BONDSEL_1_CTLr_t;
#define BONDSEL_1_CTLr_CLR BCMI_MADURA_BONDSEL_1_CTLr_CLR
#define BONDSEL_1_CTLr_SET BCMI_MADURA_BONDSEL_1_CTLr_SET
#define BONDSEL_1_CTLr_GET BCMI_MADURA_BONDSEL_1_CTLr_GET
#define BONDSEL_1_CTLr_BONDSEL_1_DGLH_CNTf_GET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_DGLH_CNTf_GET
#define BONDSEL_1_CTLr_BONDSEL_1_DGLH_CNTf_SET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_DGLH_CNTf_SET
#define BONDSEL_1_CTLr_BONDSEL_1_OUT_FRCVALf_GET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_OUT_FRCVALf_GET
#define BONDSEL_1_CTLr_BONDSEL_1_OUT_FRCVALf_SET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_OUT_FRCVALf_SET
#define BONDSEL_1_CTLr_BONDSEL_1_INVERT_ENf_GET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_INVERT_ENf_GET
#define BONDSEL_1_CTLr_BONDSEL_1_INVERT_ENf_SET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_INVERT_ENf_SET
#define BONDSEL_1_CTLr_BONDSEL_1_IBOFf_GET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_IBOFf_GET
#define BONDSEL_1_CTLr_BONDSEL_1_IBOFf_SET BCMI_MADURA_BONDSEL_1_CTLr_BONDSEL_1_IBOFf_SET
#define READ_BONDSEL_1_CTLr BCMI_MADURA_READ_BONDSEL_1_CTLr
#define WRITE_BONDSEL_1_CTLr BCMI_MADURA_WRITE_BONDSEL_1_CTLr
#define MODIFY_BONDSEL_1_CTLr BCMI_MADURA_MODIFY_BONDSEL_1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_1_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a33
 * DEVAD:    1
 * DESC:     PAD bondsel_1 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_1_DIN_LH pad input latch highstatus
 *     BONDSEL_1_DIN_LL pad input latch low status
 *     BONDSEL_1_DIN    live pad input value
 */
#define BCMI_MADURA_BONDSEL_1_STSr (0x00018a33 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_1_STSr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_1_STS.
 */
typedef union BCMI_MADURA_BONDSEL_1_STSr_s {
	uint32_t v[1];
	uint32_t bondsel_1_sts[1];
	uint32_t _bondsel_1_sts;
} BCMI_MADURA_BONDSEL_1_STSr_t;

#define BCMI_MADURA_BONDSEL_1_STSr_CLR(r) (r).bondsel_1_sts[0] = 0
#define BCMI_MADURA_BONDSEL_1_STSr_SET(r,d) (r).bondsel_1_sts[0] = d
#define BCMI_MADURA_BONDSEL_1_STSr_GET(r) (r).bondsel_1_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DINf_GET(r) ((((r).bondsel_1_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DINf_SET(r,f) (r).bondsel_1_sts[0]=(((r).bondsel_1_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LLf_GET(r) ((((r).bondsel_1_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LLf_SET(r,f) (r).bondsel_1_sts[0]=(((r).bondsel_1_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LHf_GET(r) (((r).bondsel_1_sts[0]) & 0x1)
#define BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LHf_SET(r,f) (r).bondsel_1_sts[0]=(((r).bondsel_1_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access BONDSEL_1_STS.
 */
#define BCMI_MADURA_READ_BONDSEL_1_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_1_STSr,_r._bondsel_1_sts)
#define BCMI_MADURA_WRITE_BONDSEL_1_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_1_STSr,_r._bondsel_1_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_1_STSr BCMI_MADURA_BONDSEL_1_STSr
#define BONDSEL_1_STSr_SIZE BCMI_MADURA_BONDSEL_1_STSr_SIZE
typedef BCMI_MADURA_BONDSEL_1_STSr_t BONDSEL_1_STSr_t;
#define BONDSEL_1_STSr_CLR BCMI_MADURA_BONDSEL_1_STSr_CLR
#define BONDSEL_1_STSr_SET BCMI_MADURA_BONDSEL_1_STSr_SET
#define BONDSEL_1_STSr_GET BCMI_MADURA_BONDSEL_1_STSr_GET
#define BONDSEL_1_STSr_BONDSEL_1_DINf_GET BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DINf_GET
#define BONDSEL_1_STSr_BONDSEL_1_DINf_SET BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DINf_SET
#define BONDSEL_1_STSr_BONDSEL_1_DIN_LLf_GET BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LLf_GET
#define BONDSEL_1_STSr_BONDSEL_1_DIN_LLf_SET BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LLf_SET
#define BONDSEL_1_STSr_BONDSEL_1_DIN_LHf_GET BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LHf_GET
#define BONDSEL_1_STSr_BONDSEL_1_DIN_LHf_SET BCMI_MADURA_BONDSEL_1_STSr_BONDSEL_1_DIN_LHf_SET
#define READ_BONDSEL_1_STSr BCMI_MADURA_READ_BONDSEL_1_STSr
#define WRITE_BONDSEL_1_STSr BCMI_MADURA_WRITE_BONDSEL_1_STSr
#define MODIFY_BONDSEL_1_STSr BCMI_MADURA_MODIFY_BONDSEL_1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_1_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_2_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a34
 * DEVAD:    1
 * DESC:     PAD bondsel_2 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_2_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     BONDSEL_2_INVERT_EN enable polarity invertion for pad input or output
 *     BONDSEL_2_OUT_FRCVAL the forced output value
 *     BONDSEL_2_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (bondsel_2_ibof) is set to 0{bondsel_2_ibof, bondsel_2_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_BONDSEL_2_CTLr (0x00018a34 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_2_CTL.
 */
typedef union BCMI_MADURA_BONDSEL_2_CTLr_s {
	uint32_t v[1];
	uint32_t bondsel_2_ctl[1];
	uint32_t _bondsel_2_ctl;
} BCMI_MADURA_BONDSEL_2_CTLr_t;

#define BCMI_MADURA_BONDSEL_2_CTLr_CLR(r) (r).bondsel_2_ctl[0] = 0
#define BCMI_MADURA_BONDSEL_2_CTLr_SET(r,d) (r).bondsel_2_ctl[0] = d
#define BCMI_MADURA_BONDSEL_2_CTLr_GET(r) (r).bondsel_2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_DGLH_CNTf_GET(r) ((((r).bondsel_2_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_DGLH_CNTf_SET(r,f) (r).bondsel_2_ctl[0]=(((r).bondsel_2_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_OUT_FRCVALf_GET(r) ((((r).bondsel_2_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_OUT_FRCVALf_SET(r,f) (r).bondsel_2_ctl[0]=(((r).bondsel_2_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_INVERT_ENf_GET(r) ((((r).bondsel_2_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_INVERT_ENf_SET(r,f) (r).bondsel_2_ctl[0]=(((r).bondsel_2_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_IBOFf_GET(r) ((((r).bondsel_2_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_IBOFf_SET(r,f) (r).bondsel_2_ctl[0]=(((r).bondsel_2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access BONDSEL_2_CTL.
 */
#define BCMI_MADURA_READ_BONDSEL_2_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_2_CTLr,_r._bondsel_2_ctl)
#define BCMI_MADURA_WRITE_BONDSEL_2_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_2_CTLr,_r._bondsel_2_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_2_CTLr BCMI_MADURA_BONDSEL_2_CTLr
#define BONDSEL_2_CTLr_SIZE BCMI_MADURA_BONDSEL_2_CTLr_SIZE
typedef BCMI_MADURA_BONDSEL_2_CTLr_t BONDSEL_2_CTLr_t;
#define BONDSEL_2_CTLr_CLR BCMI_MADURA_BONDSEL_2_CTLr_CLR
#define BONDSEL_2_CTLr_SET BCMI_MADURA_BONDSEL_2_CTLr_SET
#define BONDSEL_2_CTLr_GET BCMI_MADURA_BONDSEL_2_CTLr_GET
#define BONDSEL_2_CTLr_BONDSEL_2_DGLH_CNTf_GET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_DGLH_CNTf_GET
#define BONDSEL_2_CTLr_BONDSEL_2_DGLH_CNTf_SET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_DGLH_CNTf_SET
#define BONDSEL_2_CTLr_BONDSEL_2_OUT_FRCVALf_GET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_OUT_FRCVALf_GET
#define BONDSEL_2_CTLr_BONDSEL_2_OUT_FRCVALf_SET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_OUT_FRCVALf_SET
#define BONDSEL_2_CTLr_BONDSEL_2_INVERT_ENf_GET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_INVERT_ENf_GET
#define BONDSEL_2_CTLr_BONDSEL_2_INVERT_ENf_SET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_INVERT_ENf_SET
#define BONDSEL_2_CTLr_BONDSEL_2_IBOFf_GET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_IBOFf_GET
#define BONDSEL_2_CTLr_BONDSEL_2_IBOFf_SET BCMI_MADURA_BONDSEL_2_CTLr_BONDSEL_2_IBOFf_SET
#define READ_BONDSEL_2_CTLr BCMI_MADURA_READ_BONDSEL_2_CTLr
#define WRITE_BONDSEL_2_CTLr BCMI_MADURA_WRITE_BONDSEL_2_CTLr
#define MODIFY_BONDSEL_2_CTLr BCMI_MADURA_MODIFY_BONDSEL_2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_2_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a35
 * DEVAD:    1
 * DESC:     PAD bondsel_2 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_2_DIN_LH pad input latch highstatus
 *     BONDSEL_2_DIN_LL pad input latch low status
 *     BONDSEL_2_DIN    live pad input value
 */
#define BCMI_MADURA_BONDSEL_2_STSr (0x00018a35 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_2_STSr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_2_STS.
 */
typedef union BCMI_MADURA_BONDSEL_2_STSr_s {
	uint32_t v[1];
	uint32_t bondsel_2_sts[1];
	uint32_t _bondsel_2_sts;
} BCMI_MADURA_BONDSEL_2_STSr_t;

#define BCMI_MADURA_BONDSEL_2_STSr_CLR(r) (r).bondsel_2_sts[0] = 0
#define BCMI_MADURA_BONDSEL_2_STSr_SET(r,d) (r).bondsel_2_sts[0] = d
#define BCMI_MADURA_BONDSEL_2_STSr_GET(r) (r).bondsel_2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DINf_GET(r) ((((r).bondsel_2_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DINf_SET(r,f) (r).bondsel_2_sts[0]=(((r).bondsel_2_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LLf_GET(r) ((((r).bondsel_2_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LLf_SET(r,f) (r).bondsel_2_sts[0]=(((r).bondsel_2_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LHf_GET(r) (((r).bondsel_2_sts[0]) & 0x1)
#define BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LHf_SET(r,f) (r).bondsel_2_sts[0]=(((r).bondsel_2_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access BONDSEL_2_STS.
 */
#define BCMI_MADURA_READ_BONDSEL_2_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_2_STSr,_r._bondsel_2_sts)
#define BCMI_MADURA_WRITE_BONDSEL_2_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_2_STSr,_r._bondsel_2_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_2_STSr BCMI_MADURA_BONDSEL_2_STSr
#define BONDSEL_2_STSr_SIZE BCMI_MADURA_BONDSEL_2_STSr_SIZE
typedef BCMI_MADURA_BONDSEL_2_STSr_t BONDSEL_2_STSr_t;
#define BONDSEL_2_STSr_CLR BCMI_MADURA_BONDSEL_2_STSr_CLR
#define BONDSEL_2_STSr_SET BCMI_MADURA_BONDSEL_2_STSr_SET
#define BONDSEL_2_STSr_GET BCMI_MADURA_BONDSEL_2_STSr_GET
#define BONDSEL_2_STSr_BONDSEL_2_DINf_GET BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DINf_GET
#define BONDSEL_2_STSr_BONDSEL_2_DINf_SET BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DINf_SET
#define BONDSEL_2_STSr_BONDSEL_2_DIN_LLf_GET BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LLf_GET
#define BONDSEL_2_STSr_BONDSEL_2_DIN_LLf_SET BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LLf_SET
#define BONDSEL_2_STSr_BONDSEL_2_DIN_LHf_GET BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LHf_GET
#define BONDSEL_2_STSr_BONDSEL_2_DIN_LHf_SET BCMI_MADURA_BONDSEL_2_STSr_BONDSEL_2_DIN_LHf_SET
#define READ_BONDSEL_2_STSr BCMI_MADURA_READ_BONDSEL_2_STSr
#define WRITE_BONDSEL_2_STSr BCMI_MADURA_WRITE_BONDSEL_2_STSr
#define MODIFY_BONDSEL_2_STSr BCMI_MADURA_MODIFY_BONDSEL_2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_3_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a36
 * DEVAD:    1
 * DESC:     PAD bondsel_3 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_3_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     BONDSEL_3_INVERT_EN enable polarity invertion for pad input or output
 *     BONDSEL_3_OUT_FRCVAL the forced output value
 *     BONDSEL_3_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (bondsel_3_ibof) is set to 0{bondsel_3_ibof, bondsel_3_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_BONDSEL_3_CTLr (0x00018a36 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_3_CTL.
 */
typedef union BCMI_MADURA_BONDSEL_3_CTLr_s {
	uint32_t v[1];
	uint32_t bondsel_3_ctl[1];
	uint32_t _bondsel_3_ctl;
} BCMI_MADURA_BONDSEL_3_CTLr_t;

#define BCMI_MADURA_BONDSEL_3_CTLr_CLR(r) (r).bondsel_3_ctl[0] = 0
#define BCMI_MADURA_BONDSEL_3_CTLr_SET(r,d) (r).bondsel_3_ctl[0] = d
#define BCMI_MADURA_BONDSEL_3_CTLr_GET(r) (r).bondsel_3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_DGLH_CNTf_GET(r) ((((r).bondsel_3_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_DGLH_CNTf_SET(r,f) (r).bondsel_3_ctl[0]=(((r).bondsel_3_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_OUT_FRCVALf_GET(r) ((((r).bondsel_3_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_OUT_FRCVALf_SET(r,f) (r).bondsel_3_ctl[0]=(((r).bondsel_3_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_INVERT_ENf_GET(r) ((((r).bondsel_3_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_INVERT_ENf_SET(r,f) (r).bondsel_3_ctl[0]=(((r).bondsel_3_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_IBOFf_GET(r) ((((r).bondsel_3_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_IBOFf_SET(r,f) (r).bondsel_3_ctl[0]=(((r).bondsel_3_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access BONDSEL_3_CTL.
 */
#define BCMI_MADURA_READ_BONDSEL_3_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_3_CTLr,_r._bondsel_3_ctl)
#define BCMI_MADURA_WRITE_BONDSEL_3_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_3_CTLr,_r._bondsel_3_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_3_CTLr BCMI_MADURA_BONDSEL_3_CTLr
#define BONDSEL_3_CTLr_SIZE BCMI_MADURA_BONDSEL_3_CTLr_SIZE
typedef BCMI_MADURA_BONDSEL_3_CTLr_t BONDSEL_3_CTLr_t;
#define BONDSEL_3_CTLr_CLR BCMI_MADURA_BONDSEL_3_CTLr_CLR
#define BONDSEL_3_CTLr_SET BCMI_MADURA_BONDSEL_3_CTLr_SET
#define BONDSEL_3_CTLr_GET BCMI_MADURA_BONDSEL_3_CTLr_GET
#define BONDSEL_3_CTLr_BONDSEL_3_DGLH_CNTf_GET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_DGLH_CNTf_GET
#define BONDSEL_3_CTLr_BONDSEL_3_DGLH_CNTf_SET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_DGLH_CNTf_SET
#define BONDSEL_3_CTLr_BONDSEL_3_OUT_FRCVALf_GET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_OUT_FRCVALf_GET
#define BONDSEL_3_CTLr_BONDSEL_3_OUT_FRCVALf_SET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_OUT_FRCVALf_SET
#define BONDSEL_3_CTLr_BONDSEL_3_INVERT_ENf_GET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_INVERT_ENf_GET
#define BONDSEL_3_CTLr_BONDSEL_3_INVERT_ENf_SET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_INVERT_ENf_SET
#define BONDSEL_3_CTLr_BONDSEL_3_IBOFf_GET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_IBOFf_GET
#define BONDSEL_3_CTLr_BONDSEL_3_IBOFf_SET BCMI_MADURA_BONDSEL_3_CTLr_BONDSEL_3_IBOFf_SET
#define READ_BONDSEL_3_CTLr BCMI_MADURA_READ_BONDSEL_3_CTLr
#define WRITE_BONDSEL_3_CTLr BCMI_MADURA_WRITE_BONDSEL_3_CTLr
#define MODIFY_BONDSEL_3_CTLr BCMI_MADURA_MODIFY_BONDSEL_3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BONDSEL_3_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a37
 * DEVAD:    1
 * DESC:     PAD bondsel_3 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BONDSEL_3_DIN_LH pad input latch highstatus
 *     BONDSEL_3_DIN_LL pad input latch low status
 *     BONDSEL_3_DIN    live pad input value
 */
#define BCMI_MADURA_BONDSEL_3_STSr (0x00018a37 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BONDSEL_3_STSr_SIZE 4

/*
 * This structure should be used to declare and program BONDSEL_3_STS.
 */
typedef union BCMI_MADURA_BONDSEL_3_STSr_s {
	uint32_t v[1];
	uint32_t bondsel_3_sts[1];
	uint32_t _bondsel_3_sts;
} BCMI_MADURA_BONDSEL_3_STSr_t;

#define BCMI_MADURA_BONDSEL_3_STSr_CLR(r) (r).bondsel_3_sts[0] = 0
#define BCMI_MADURA_BONDSEL_3_STSr_SET(r,d) (r).bondsel_3_sts[0] = d
#define BCMI_MADURA_BONDSEL_3_STSr_GET(r) (r).bondsel_3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DINf_GET(r) ((((r).bondsel_3_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DINf_SET(r,f) (r).bondsel_3_sts[0]=(((r).bondsel_3_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LLf_GET(r) ((((r).bondsel_3_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LLf_SET(r,f) (r).bondsel_3_sts[0]=(((r).bondsel_3_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LHf_GET(r) (((r).bondsel_3_sts[0]) & 0x1)
#define BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LHf_SET(r,f) (r).bondsel_3_sts[0]=(((r).bondsel_3_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access BONDSEL_3_STS.
 */
#define BCMI_MADURA_READ_BONDSEL_3_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BONDSEL_3_STSr,_r._bondsel_3_sts)
#define BCMI_MADURA_WRITE_BONDSEL_3_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BONDSEL_3_STSr,_r._bondsel_3_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BONDSEL_3_STSr BCMI_MADURA_BONDSEL_3_STSr
#define BONDSEL_3_STSr_SIZE BCMI_MADURA_BONDSEL_3_STSr_SIZE
typedef BCMI_MADURA_BONDSEL_3_STSr_t BONDSEL_3_STSr_t;
#define BONDSEL_3_STSr_CLR BCMI_MADURA_BONDSEL_3_STSr_CLR
#define BONDSEL_3_STSr_SET BCMI_MADURA_BONDSEL_3_STSr_SET
#define BONDSEL_3_STSr_GET BCMI_MADURA_BONDSEL_3_STSr_GET
#define BONDSEL_3_STSr_BONDSEL_3_DINf_GET BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DINf_GET
#define BONDSEL_3_STSr_BONDSEL_3_DINf_SET BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DINf_SET
#define BONDSEL_3_STSr_BONDSEL_3_DIN_LLf_GET BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LLf_GET
#define BONDSEL_3_STSr_BONDSEL_3_DIN_LLf_SET BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LLf_SET
#define BONDSEL_3_STSr_BONDSEL_3_DIN_LHf_GET BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LHf_GET
#define BONDSEL_3_STSr_BONDSEL_3_DIN_LHf_SET BCMI_MADURA_BONDSEL_3_STSr_BONDSEL_3_DIN_LHf_SET
#define READ_BONDSEL_3_STSr BCMI_MADURA_READ_BONDSEL_3_STSr
#define WRITE_BONDSEL_3_STSr BCMI_MADURA_WRITE_BONDSEL_3_STSr
#define MODIFY_BONDSEL_3_STSr BCMI_MADURA_MODIFY_BONDSEL_3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BONDSEL_3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDC_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a38
 * DEVAD:    1
 * DESC:     PAD mdc control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDC_IBOF         For input, this is deglitch bypassFor output, this is the output force enable
 *     MDC_INVERT_EN    enable polarity invertion for pad input or output
 *     MDC_OUT_FRCVAL   the forced output value
 *     MDC_DGLH_CNT     the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mdc_ibof) is set to 0{mdc_ibof, mdc_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MDC_CTLr (0x00018a38 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MDC_CTL.
 */
typedef union BCMI_MADURA_MDC_CTLr_s {
	uint32_t v[1];
	uint32_t mdc_ctl[1];
	uint32_t _mdc_ctl;
} BCMI_MADURA_MDC_CTLr_t;

#define BCMI_MADURA_MDC_CTLr_CLR(r) (r).mdc_ctl[0] = 0
#define BCMI_MADURA_MDC_CTLr_SET(r,d) (r).mdc_ctl[0] = d
#define BCMI_MADURA_MDC_CTLr_GET(r) (r).mdc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDC_CTLr_MDC_DGLH_CNTf_GET(r) ((((r).mdc_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MDC_CTLr_MDC_DGLH_CNTf_SET(r,f) (r).mdc_ctl[0]=(((r).mdc_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MDC_CTLr_MDC_OUT_FRCVALf_GET(r) ((((r).mdc_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MDC_CTLr_MDC_OUT_FRCVALf_SET(r,f) (r).mdc_ctl[0]=(((r).mdc_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MDC_CTLr_MDC_INVERT_ENf_GET(r) ((((r).mdc_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MDC_CTLr_MDC_INVERT_ENf_SET(r,f) (r).mdc_ctl[0]=(((r).mdc_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MDC_CTLr_MDC_IBOFf_GET(r) ((((r).mdc_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MDC_CTLr_MDC_IBOFf_SET(r,f) (r).mdc_ctl[0]=(((r).mdc_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access MDC_CTL.
 */
#define BCMI_MADURA_READ_MDC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDC_CTLr,_r._mdc_ctl)
#define BCMI_MADURA_WRITE_MDC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDC_CTLr,_r._mdc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDC_CTLr BCMI_MADURA_MDC_CTLr
#define MDC_CTLr_SIZE BCMI_MADURA_MDC_CTLr_SIZE
typedef BCMI_MADURA_MDC_CTLr_t MDC_CTLr_t;
#define MDC_CTLr_CLR BCMI_MADURA_MDC_CTLr_CLR
#define MDC_CTLr_SET BCMI_MADURA_MDC_CTLr_SET
#define MDC_CTLr_GET BCMI_MADURA_MDC_CTLr_GET
#define MDC_CTLr_MDC_DGLH_CNTf_GET BCMI_MADURA_MDC_CTLr_MDC_DGLH_CNTf_GET
#define MDC_CTLr_MDC_DGLH_CNTf_SET BCMI_MADURA_MDC_CTLr_MDC_DGLH_CNTf_SET
#define MDC_CTLr_MDC_OUT_FRCVALf_GET BCMI_MADURA_MDC_CTLr_MDC_OUT_FRCVALf_GET
#define MDC_CTLr_MDC_OUT_FRCVALf_SET BCMI_MADURA_MDC_CTLr_MDC_OUT_FRCVALf_SET
#define MDC_CTLr_MDC_INVERT_ENf_GET BCMI_MADURA_MDC_CTLr_MDC_INVERT_ENf_GET
#define MDC_CTLr_MDC_INVERT_ENf_SET BCMI_MADURA_MDC_CTLr_MDC_INVERT_ENf_SET
#define MDC_CTLr_MDC_IBOFf_GET BCMI_MADURA_MDC_CTLr_MDC_IBOFf_GET
#define MDC_CTLr_MDC_IBOFf_SET BCMI_MADURA_MDC_CTLr_MDC_IBOFf_SET
#define READ_MDC_CTLr BCMI_MADURA_READ_MDC_CTLr
#define WRITE_MDC_CTLr BCMI_MADURA_WRITE_MDC_CTLr
#define MODIFY_MDC_CTLr BCMI_MADURA_MODIFY_MDC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDC_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a39
 * DEVAD:    1
 * DESC:     PAD mdc status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDC_DIN_LH       pad input latch highstatus
 *     MDC_DIN_LL       pad input latch low status
 *     MDC_DIN          live pad input value
 */
#define BCMI_MADURA_MDC_STSr (0x00018a39 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDC_STSr_SIZE 4

/*
 * This structure should be used to declare and program MDC_STS.
 */
typedef union BCMI_MADURA_MDC_STSr_s {
	uint32_t v[1];
	uint32_t mdc_sts[1];
	uint32_t _mdc_sts;
} BCMI_MADURA_MDC_STSr_t;

#define BCMI_MADURA_MDC_STSr_CLR(r) (r).mdc_sts[0] = 0
#define BCMI_MADURA_MDC_STSr_SET(r,d) (r).mdc_sts[0] = d
#define BCMI_MADURA_MDC_STSr_GET(r) (r).mdc_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDC_STSr_MDC_DINf_GET(r) ((((r).mdc_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MDC_STSr_MDC_DINf_SET(r,f) (r).mdc_sts[0]=(((r).mdc_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MDC_STSr_MDC_DIN_LLf_GET(r) ((((r).mdc_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MDC_STSr_MDC_DIN_LLf_SET(r,f) (r).mdc_sts[0]=(((r).mdc_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MDC_STSr_MDC_DIN_LHf_GET(r) (((r).mdc_sts[0]) & 0x1)
#define BCMI_MADURA_MDC_STSr_MDC_DIN_LHf_SET(r,f) (r).mdc_sts[0]=(((r).mdc_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDC_STS.
 */
#define BCMI_MADURA_READ_MDC_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDC_STSr,_r._mdc_sts)
#define BCMI_MADURA_WRITE_MDC_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDC_STSr,_r._mdc_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDC_STSr BCMI_MADURA_MDC_STSr
#define MDC_STSr_SIZE BCMI_MADURA_MDC_STSr_SIZE
typedef BCMI_MADURA_MDC_STSr_t MDC_STSr_t;
#define MDC_STSr_CLR BCMI_MADURA_MDC_STSr_CLR
#define MDC_STSr_SET BCMI_MADURA_MDC_STSr_SET
#define MDC_STSr_GET BCMI_MADURA_MDC_STSr_GET
#define MDC_STSr_MDC_DINf_GET BCMI_MADURA_MDC_STSr_MDC_DINf_GET
#define MDC_STSr_MDC_DINf_SET BCMI_MADURA_MDC_STSr_MDC_DINf_SET
#define MDC_STSr_MDC_DIN_LLf_GET BCMI_MADURA_MDC_STSr_MDC_DIN_LLf_GET
#define MDC_STSr_MDC_DIN_LLf_SET BCMI_MADURA_MDC_STSr_MDC_DIN_LLf_SET
#define MDC_STSr_MDC_DIN_LHf_GET BCMI_MADURA_MDC_STSr_MDC_DIN_LHf_GET
#define MDC_STSr_MDC_DIN_LHf_SET BCMI_MADURA_MDC_STSr_MDC_DIN_LHf_SET
#define READ_MDC_STSr BCMI_MADURA_READ_MDC_STSr
#define WRITE_MDC_STSr BCMI_MADURA_WRITE_MDC_STSr
#define MODIFY_MDC_STSr BCMI_MADURA_MODIFY_MDC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a3a
 * DEVAD:    1
 * DESC:     PAD mdio control register
 * RESETVAL: 0xe0 (224)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_SEL0        mdio sel0
 *     MDIO_SEL1        mdio sel1
 *     MDIO_SEL2        mdio sel2
 *     MDIO_IBOF        For input, this is deglitch bypassFor output, this is the output force enable
 *     MDIO_INVERT_EN   enable polarity invertion for pad input or output
 *     MDIO_OUT_FRCVAL  the forced output value
 *     MDIO_DGLH_CNT    the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mdio_ibof) is set to 0{mdio_ibof, mdio_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MDIO_CTLr (0x00018a3a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_CTL.
 */
typedef union BCMI_MADURA_MDIO_CTLr_s {
	uint32_t v[1];
	uint32_t mdio_ctl[1];
	uint32_t _mdio_ctl;
} BCMI_MADURA_MDIO_CTLr_t;

#define BCMI_MADURA_MDIO_CTLr_CLR(r) (r).mdio_ctl[0] = 0
#define BCMI_MADURA_MDIO_CTLr_SET(r,d) (r).mdio_ctl[0] = d
#define BCMI_MADURA_MDIO_CTLr_GET(r) (r).mdio_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_CTLr_MDIO_DGLH_CNTf_GET(r) ((((r).mdio_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MDIO_CTLr_MDIO_DGLH_CNTf_SET(r,f) (r).mdio_ctl[0]=(((r).mdio_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MDIO_CTLr_MDIO_OUT_FRCVALf_GET(r) ((((r).mdio_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MDIO_CTLr_MDIO_OUT_FRCVALf_SET(r,f) (r).mdio_ctl[0]=(((r).mdio_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MDIO_CTLr_MDIO_INVERT_ENf_GET(r) ((((r).mdio_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MDIO_CTLr_MDIO_INVERT_ENf_SET(r,f) (r).mdio_ctl[0]=(((r).mdio_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MDIO_CTLr_MDIO_IBOFf_GET(r) ((((r).mdio_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MDIO_CTLr_MDIO_IBOFf_SET(r,f) (r).mdio_ctl[0]=(((r).mdio_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MDIO_CTLr_MDIO_SEL2f_GET(r) ((((r).mdio_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_MDIO_CTLr_MDIO_SEL2f_SET(r,f) (r).mdio_ctl[0]=(((r).mdio_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MDIO_CTLr_MDIO_SEL1f_GET(r) ((((r).mdio_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_MDIO_CTLr_MDIO_SEL1f_SET(r,f) (r).mdio_ctl[0]=(((r).mdio_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MDIO_CTLr_MDIO_SEL0f_GET(r) ((((r).mdio_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_MDIO_CTLr_MDIO_SEL0f_SET(r,f) (r).mdio_ctl[0]=(((r).mdio_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))

/*
 * These macros can be used to access MDIO_CTL.
 */
#define BCMI_MADURA_READ_MDIO_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_CTLr,_r._mdio_ctl)
#define BCMI_MADURA_WRITE_MDIO_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_CTLr,_r._mdio_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_CTLr BCMI_MADURA_MDIO_CTLr
#define MDIO_CTLr_SIZE BCMI_MADURA_MDIO_CTLr_SIZE
typedef BCMI_MADURA_MDIO_CTLr_t MDIO_CTLr_t;
#define MDIO_CTLr_CLR BCMI_MADURA_MDIO_CTLr_CLR
#define MDIO_CTLr_SET BCMI_MADURA_MDIO_CTLr_SET
#define MDIO_CTLr_GET BCMI_MADURA_MDIO_CTLr_GET
#define MDIO_CTLr_MDIO_DGLH_CNTf_GET BCMI_MADURA_MDIO_CTLr_MDIO_DGLH_CNTf_GET
#define MDIO_CTLr_MDIO_DGLH_CNTf_SET BCMI_MADURA_MDIO_CTLr_MDIO_DGLH_CNTf_SET
#define MDIO_CTLr_MDIO_OUT_FRCVALf_GET BCMI_MADURA_MDIO_CTLr_MDIO_OUT_FRCVALf_GET
#define MDIO_CTLr_MDIO_OUT_FRCVALf_SET BCMI_MADURA_MDIO_CTLr_MDIO_OUT_FRCVALf_SET
#define MDIO_CTLr_MDIO_INVERT_ENf_GET BCMI_MADURA_MDIO_CTLr_MDIO_INVERT_ENf_GET
#define MDIO_CTLr_MDIO_INVERT_ENf_SET BCMI_MADURA_MDIO_CTLr_MDIO_INVERT_ENf_SET
#define MDIO_CTLr_MDIO_IBOFf_GET BCMI_MADURA_MDIO_CTLr_MDIO_IBOFf_GET
#define MDIO_CTLr_MDIO_IBOFf_SET BCMI_MADURA_MDIO_CTLr_MDIO_IBOFf_SET
#define MDIO_CTLr_MDIO_SEL2f_GET BCMI_MADURA_MDIO_CTLr_MDIO_SEL2f_GET
#define MDIO_CTLr_MDIO_SEL2f_SET BCMI_MADURA_MDIO_CTLr_MDIO_SEL2f_SET
#define MDIO_CTLr_MDIO_SEL1f_GET BCMI_MADURA_MDIO_CTLr_MDIO_SEL1f_GET
#define MDIO_CTLr_MDIO_SEL1f_SET BCMI_MADURA_MDIO_CTLr_MDIO_SEL1f_SET
#define MDIO_CTLr_MDIO_SEL0f_GET BCMI_MADURA_MDIO_CTLr_MDIO_SEL0f_GET
#define MDIO_CTLr_MDIO_SEL0f_SET BCMI_MADURA_MDIO_CTLr_MDIO_SEL0f_SET
#define READ_MDIO_CTLr BCMI_MADURA_READ_MDIO_CTLr
#define WRITE_MDIO_CTLr BCMI_MADURA_WRITE_MDIO_CTLr
#define MODIFY_MDIO_CTLr BCMI_MADURA_MODIFY_MDIO_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a3b
 * DEVAD:    1
 * DESC:     PAD mdio status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DIN_LH      pad input latch highstatus
 *     MDIO_DIN_LL      pad input latch low status
 *     MDIO_DIN         live pad input value
 */
#define BCMI_MADURA_MDIO_STSr (0x00018a3b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_STSr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_STS.
 */
typedef union BCMI_MADURA_MDIO_STSr_s {
	uint32_t v[1];
	uint32_t mdio_sts[1];
	uint32_t _mdio_sts;
} BCMI_MADURA_MDIO_STSr_t;

#define BCMI_MADURA_MDIO_STSr_CLR(r) (r).mdio_sts[0] = 0
#define BCMI_MADURA_MDIO_STSr_SET(r,d) (r).mdio_sts[0] = d
#define BCMI_MADURA_MDIO_STSr_GET(r) (r).mdio_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_STSr_MDIO_DINf_GET(r) ((((r).mdio_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MDIO_STSr_MDIO_DINf_SET(r,f) (r).mdio_sts[0]=(((r).mdio_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MDIO_STSr_MDIO_DIN_LLf_GET(r) ((((r).mdio_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MDIO_STSr_MDIO_DIN_LLf_SET(r,f) (r).mdio_sts[0]=(((r).mdio_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MDIO_STSr_MDIO_DIN_LHf_GET(r) (((r).mdio_sts[0]) & 0x1)
#define BCMI_MADURA_MDIO_STSr_MDIO_DIN_LHf_SET(r,f) (r).mdio_sts[0]=(((r).mdio_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_STS.
 */
#define BCMI_MADURA_READ_MDIO_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_STSr,_r._mdio_sts)
#define BCMI_MADURA_WRITE_MDIO_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_STSr,_r._mdio_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_STSr BCMI_MADURA_MDIO_STSr
#define MDIO_STSr_SIZE BCMI_MADURA_MDIO_STSr_SIZE
typedef BCMI_MADURA_MDIO_STSr_t MDIO_STSr_t;
#define MDIO_STSr_CLR BCMI_MADURA_MDIO_STSr_CLR
#define MDIO_STSr_SET BCMI_MADURA_MDIO_STSr_SET
#define MDIO_STSr_GET BCMI_MADURA_MDIO_STSr_GET
#define MDIO_STSr_MDIO_DINf_GET BCMI_MADURA_MDIO_STSr_MDIO_DINf_GET
#define MDIO_STSr_MDIO_DINf_SET BCMI_MADURA_MDIO_STSr_MDIO_DINf_SET
#define MDIO_STSr_MDIO_DIN_LLf_GET BCMI_MADURA_MDIO_STSr_MDIO_DIN_LLf_GET
#define MDIO_STSr_MDIO_DIN_LLf_SET BCMI_MADURA_MDIO_STSr_MDIO_DIN_LLf_SET
#define MDIO_STSr_MDIO_DIN_LHf_GET BCMI_MADURA_MDIO_STSr_MDIO_DIN_LHf_GET
#define MDIO_STSr_MDIO_DIN_LHf_SET BCMI_MADURA_MDIO_STSr_MDIO_DIN_LHf_SET
#define READ_MDIO_STSr BCMI_MADURA_READ_MDIO_STSr
#define WRITE_MDIO_STSr BCMI_MADURA_WRITE_MDIO_STSr
#define MODIFY_MDIO_STSr BCMI_MADURA_MODIFY_MDIO_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR0_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a3c
 * DEVAD:    1
 * DESC:     PAD adr0 control register
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR0_PUP         adr0 pull-up
 *     ADR0_PDN         adr0 pull down
 *     ADR0_IND         adr0 ind
 *     ADR0_IBOF        For input, this is deglitch bypassFor output, this is the output force enable
 *     ADR0_INVERT_EN   enable polarity invertion for pad input or output
 *     ADR0_OUT_FRCVAL  the forced output value
 *     ADR0_DGLH_CNT    the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (adr0_ibof) is set to 0{adr0_ibof, adr0_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_ADR0_CTLr (0x00018a3c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR0_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ADR0_CTL.
 */
typedef union BCMI_MADURA_ADR0_CTLr_s {
	uint32_t v[1];
	uint32_t adr0_ctl[1];
	uint32_t _adr0_ctl;
} BCMI_MADURA_ADR0_CTLr_t;

#define BCMI_MADURA_ADR0_CTLr_CLR(r) (r).adr0_ctl[0] = 0
#define BCMI_MADURA_ADR0_CTLr_SET(r,d) (r).adr0_ctl[0] = d
#define BCMI_MADURA_ADR0_CTLr_GET(r) (r).adr0_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR0_CTLr_ADR0_DGLH_CNTf_GET(r) ((((r).adr0_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_ADR0_CTLr_ADR0_DGLH_CNTf_SET(r,f) (r).adr0_ctl[0]=(((r).adr0_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_ADR0_CTLr_ADR0_OUT_FRCVALf_GET(r) ((((r).adr0_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_ADR0_CTLr_ADR0_OUT_FRCVALf_SET(r,f) (r).adr0_ctl[0]=(((r).adr0_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_ADR0_CTLr_ADR0_INVERT_ENf_GET(r) ((((r).adr0_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_ADR0_CTLr_ADR0_INVERT_ENf_SET(r,f) (r).adr0_ctl[0]=(((r).adr0_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_ADR0_CTLr_ADR0_IBOFf_GET(r) ((((r).adr0_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_ADR0_CTLr_ADR0_IBOFf_SET(r,f) (r).adr0_ctl[0]=(((r).adr0_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ADR0_CTLr_ADR0_INDf_GET(r) ((((r).adr0_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_ADR0_CTLr_ADR0_INDf_SET(r,f) (r).adr0_ctl[0]=(((r).adr0_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ADR0_CTLr_ADR0_PDNf_GET(r) ((((r).adr0_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR0_CTLr_ADR0_PDNf_SET(r,f) (r).adr0_ctl[0]=(((r).adr0_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR0_CTLr_ADR0_PUPf_GET(r) ((((r).adr0_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR0_CTLr_ADR0_PUPf_SET(r,f) (r).adr0_ctl[0]=(((r).adr0_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access ADR0_CTL.
 */
#define BCMI_MADURA_READ_ADR0_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR0_CTLr,_r._adr0_ctl)
#define BCMI_MADURA_WRITE_ADR0_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR0_CTLr,_r._adr0_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR0_CTLr BCMI_MADURA_ADR0_CTLr
#define ADR0_CTLr_SIZE BCMI_MADURA_ADR0_CTLr_SIZE
typedef BCMI_MADURA_ADR0_CTLr_t ADR0_CTLr_t;
#define ADR0_CTLr_CLR BCMI_MADURA_ADR0_CTLr_CLR
#define ADR0_CTLr_SET BCMI_MADURA_ADR0_CTLr_SET
#define ADR0_CTLr_GET BCMI_MADURA_ADR0_CTLr_GET
#define ADR0_CTLr_ADR0_DGLH_CNTf_GET BCMI_MADURA_ADR0_CTLr_ADR0_DGLH_CNTf_GET
#define ADR0_CTLr_ADR0_DGLH_CNTf_SET BCMI_MADURA_ADR0_CTLr_ADR0_DGLH_CNTf_SET
#define ADR0_CTLr_ADR0_OUT_FRCVALf_GET BCMI_MADURA_ADR0_CTLr_ADR0_OUT_FRCVALf_GET
#define ADR0_CTLr_ADR0_OUT_FRCVALf_SET BCMI_MADURA_ADR0_CTLr_ADR0_OUT_FRCVALf_SET
#define ADR0_CTLr_ADR0_INVERT_ENf_GET BCMI_MADURA_ADR0_CTLr_ADR0_INVERT_ENf_GET
#define ADR0_CTLr_ADR0_INVERT_ENf_SET BCMI_MADURA_ADR0_CTLr_ADR0_INVERT_ENf_SET
#define ADR0_CTLr_ADR0_IBOFf_GET BCMI_MADURA_ADR0_CTLr_ADR0_IBOFf_GET
#define ADR0_CTLr_ADR0_IBOFf_SET BCMI_MADURA_ADR0_CTLr_ADR0_IBOFf_SET
#define ADR0_CTLr_ADR0_INDf_GET BCMI_MADURA_ADR0_CTLr_ADR0_INDf_GET
#define ADR0_CTLr_ADR0_INDf_SET BCMI_MADURA_ADR0_CTLr_ADR0_INDf_SET
#define ADR0_CTLr_ADR0_PDNf_GET BCMI_MADURA_ADR0_CTLr_ADR0_PDNf_GET
#define ADR0_CTLr_ADR0_PDNf_SET BCMI_MADURA_ADR0_CTLr_ADR0_PDNf_SET
#define ADR0_CTLr_ADR0_PUPf_GET BCMI_MADURA_ADR0_CTLr_ADR0_PUPf_GET
#define ADR0_CTLr_ADR0_PUPf_SET BCMI_MADURA_ADR0_CTLr_ADR0_PUPf_SET
#define READ_ADR0_CTLr BCMI_MADURA_READ_ADR0_CTLr
#define WRITE_ADR0_CTLr BCMI_MADURA_WRITE_ADR0_CTLr
#define MODIFY_ADR0_CTLr BCMI_MADURA_MODIFY_ADR0_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR0_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR0_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a3d
 * DEVAD:    1
 * DESC:     PAD adr0 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR0_DIN_LH      pad input latch highstatus
 *     ADR0_DIN_LL      pad input latch low status
 *     ADR0_DIN         live pad input value
 */
#define BCMI_MADURA_ADR0_STSr (0x00018a3d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR0_STSr_SIZE 4

/*
 * This structure should be used to declare and program ADR0_STS.
 */
typedef union BCMI_MADURA_ADR0_STSr_s {
	uint32_t v[1];
	uint32_t adr0_sts[1];
	uint32_t _adr0_sts;
} BCMI_MADURA_ADR0_STSr_t;

#define BCMI_MADURA_ADR0_STSr_CLR(r) (r).adr0_sts[0] = 0
#define BCMI_MADURA_ADR0_STSr_SET(r,d) (r).adr0_sts[0] = d
#define BCMI_MADURA_ADR0_STSr_GET(r) (r).adr0_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR0_STSr_ADR0_DINf_GET(r) ((((r).adr0_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR0_STSr_ADR0_DINf_SET(r,f) (r).adr0_sts[0]=(((r).adr0_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR0_STSr_ADR0_DIN_LLf_GET(r) ((((r).adr0_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR0_STSr_ADR0_DIN_LLf_SET(r,f) (r).adr0_sts[0]=(((r).adr0_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR0_STSr_ADR0_DIN_LHf_GET(r) (((r).adr0_sts[0]) & 0x1)
#define BCMI_MADURA_ADR0_STSr_ADR0_DIN_LHf_SET(r,f) (r).adr0_sts[0]=(((r).adr0_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR0_STS.
 */
#define BCMI_MADURA_READ_ADR0_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR0_STSr,_r._adr0_sts)
#define BCMI_MADURA_WRITE_ADR0_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR0_STSr,_r._adr0_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR0_STSr BCMI_MADURA_ADR0_STSr
#define ADR0_STSr_SIZE BCMI_MADURA_ADR0_STSr_SIZE
typedef BCMI_MADURA_ADR0_STSr_t ADR0_STSr_t;
#define ADR0_STSr_CLR BCMI_MADURA_ADR0_STSr_CLR
#define ADR0_STSr_SET BCMI_MADURA_ADR0_STSr_SET
#define ADR0_STSr_GET BCMI_MADURA_ADR0_STSr_GET
#define ADR0_STSr_ADR0_DINf_GET BCMI_MADURA_ADR0_STSr_ADR0_DINf_GET
#define ADR0_STSr_ADR0_DINf_SET BCMI_MADURA_ADR0_STSr_ADR0_DINf_SET
#define ADR0_STSr_ADR0_DIN_LLf_GET BCMI_MADURA_ADR0_STSr_ADR0_DIN_LLf_GET
#define ADR0_STSr_ADR0_DIN_LLf_SET BCMI_MADURA_ADR0_STSr_ADR0_DIN_LLf_SET
#define ADR0_STSr_ADR0_DIN_LHf_GET BCMI_MADURA_ADR0_STSr_ADR0_DIN_LHf_GET
#define ADR0_STSr_ADR0_DIN_LHf_SET BCMI_MADURA_ADR0_STSr_ADR0_DIN_LHf_SET
#define READ_ADR0_STSr BCMI_MADURA_READ_ADR0_STSr
#define WRITE_ADR0_STSr BCMI_MADURA_WRITE_ADR0_STSr
#define MODIFY_ADR0_STSr BCMI_MADURA_MODIFY_ADR0_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR0_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR1_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a3e
 * DEVAD:    1
 * DESC:     PAD adr1 control register
 * RESETVAL: 0x23 (35)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR1_OEB         adr1 output enable, active low
 *     ADR1_PUP         adr1 pull-up
 *     ADR1_PDN         adr1 pull down
 *     ADR1_IND         adr1 ind
 *     ADR1_SEL0        adr1 sel0
 *     ADR1_SEL1        adr1 sel1
 *     ADR1_SEL2        adr1 sel2
 *     ADR1_IBOF        For input, this is deglitch bypassFor output, this is the output force enable
 *     ADR1_INVERT_EN   enable polarity invertion for pad input or output
 *     ADR1_OUT_FRCVAL  the forced output value
 *     ADR1_DGLH_CNT    the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (adr1_ibof) is set to 0{adr1_ibof, adr1_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_ADR1_CTLr (0x00018a3e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ADR1_CTL.
 */
typedef union BCMI_MADURA_ADR1_CTLr_s {
	uint32_t v[1];
	uint32_t adr1_ctl[1];
	uint32_t _adr1_ctl;
} BCMI_MADURA_ADR1_CTLr_t;

#define BCMI_MADURA_ADR1_CTLr_CLR(r) (r).adr1_ctl[0] = 0
#define BCMI_MADURA_ADR1_CTLr_SET(r,d) (r).adr1_ctl[0] = d
#define BCMI_MADURA_ADR1_CTLr_GET(r) (r).adr1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR1_CTLr_ADR1_DGLH_CNTf_GET(r) ((((r).adr1_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_ADR1_CTLr_ADR1_DGLH_CNTf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_ADR1_CTLr_ADR1_OUT_FRCVALf_GET(r) ((((r).adr1_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_OUT_FRCVALf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_ADR1_CTLr_ADR1_INVERT_ENf_GET(r) ((((r).adr1_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_INVERT_ENf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_ADR1_CTLr_ADR1_IBOFf_GET(r) ((((r).adr1_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_IBOFf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ADR1_CTLr_ADR1_SEL2f_GET(r) ((((r).adr1_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_SEL2f_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_ADR1_CTLr_ADR1_SEL1f_GET(r) ((((r).adr1_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_SEL1f_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_ADR1_CTLr_ADR1_SEL0f_GET(r) ((((r).adr1_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_SEL0f_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_ADR1_CTLr_ADR1_INDf_GET(r) ((((r).adr1_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_INDf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ADR1_CTLr_ADR1_PDNf_GET(r) ((((r).adr1_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_PDNf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR1_CTLr_ADR1_PUPf_GET(r) ((((r).adr1_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_PUPf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR1_CTLr_ADR1_OEBf_GET(r) (((r).adr1_ctl[0]) & 0x1)
#define BCMI_MADURA_ADR1_CTLr_ADR1_OEBf_SET(r,f) (r).adr1_ctl[0]=(((r).adr1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR1_CTL.
 */
#define BCMI_MADURA_READ_ADR1_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR1_CTLr,_r._adr1_ctl)
#define BCMI_MADURA_WRITE_ADR1_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR1_CTLr,_r._adr1_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR1_CTLr BCMI_MADURA_ADR1_CTLr
#define ADR1_CTLr_SIZE BCMI_MADURA_ADR1_CTLr_SIZE
typedef BCMI_MADURA_ADR1_CTLr_t ADR1_CTLr_t;
#define ADR1_CTLr_CLR BCMI_MADURA_ADR1_CTLr_CLR
#define ADR1_CTLr_SET BCMI_MADURA_ADR1_CTLr_SET
#define ADR1_CTLr_GET BCMI_MADURA_ADR1_CTLr_GET
#define ADR1_CTLr_ADR1_DGLH_CNTf_GET BCMI_MADURA_ADR1_CTLr_ADR1_DGLH_CNTf_GET
#define ADR1_CTLr_ADR1_DGLH_CNTf_SET BCMI_MADURA_ADR1_CTLr_ADR1_DGLH_CNTf_SET
#define ADR1_CTLr_ADR1_OUT_FRCVALf_GET BCMI_MADURA_ADR1_CTLr_ADR1_OUT_FRCVALf_GET
#define ADR1_CTLr_ADR1_OUT_FRCVALf_SET BCMI_MADURA_ADR1_CTLr_ADR1_OUT_FRCVALf_SET
#define ADR1_CTLr_ADR1_INVERT_ENf_GET BCMI_MADURA_ADR1_CTLr_ADR1_INVERT_ENf_GET
#define ADR1_CTLr_ADR1_INVERT_ENf_SET BCMI_MADURA_ADR1_CTLr_ADR1_INVERT_ENf_SET
#define ADR1_CTLr_ADR1_IBOFf_GET BCMI_MADURA_ADR1_CTLr_ADR1_IBOFf_GET
#define ADR1_CTLr_ADR1_IBOFf_SET BCMI_MADURA_ADR1_CTLr_ADR1_IBOFf_SET
#define ADR1_CTLr_ADR1_SEL2f_GET BCMI_MADURA_ADR1_CTLr_ADR1_SEL2f_GET
#define ADR1_CTLr_ADR1_SEL2f_SET BCMI_MADURA_ADR1_CTLr_ADR1_SEL2f_SET
#define ADR1_CTLr_ADR1_SEL1f_GET BCMI_MADURA_ADR1_CTLr_ADR1_SEL1f_GET
#define ADR1_CTLr_ADR1_SEL1f_SET BCMI_MADURA_ADR1_CTLr_ADR1_SEL1f_SET
#define ADR1_CTLr_ADR1_SEL0f_GET BCMI_MADURA_ADR1_CTLr_ADR1_SEL0f_GET
#define ADR1_CTLr_ADR1_SEL0f_SET BCMI_MADURA_ADR1_CTLr_ADR1_SEL0f_SET
#define ADR1_CTLr_ADR1_INDf_GET BCMI_MADURA_ADR1_CTLr_ADR1_INDf_GET
#define ADR1_CTLr_ADR1_INDf_SET BCMI_MADURA_ADR1_CTLr_ADR1_INDf_SET
#define ADR1_CTLr_ADR1_PDNf_GET BCMI_MADURA_ADR1_CTLr_ADR1_PDNf_GET
#define ADR1_CTLr_ADR1_PDNf_SET BCMI_MADURA_ADR1_CTLr_ADR1_PDNf_SET
#define ADR1_CTLr_ADR1_PUPf_GET BCMI_MADURA_ADR1_CTLr_ADR1_PUPf_GET
#define ADR1_CTLr_ADR1_PUPf_SET BCMI_MADURA_ADR1_CTLr_ADR1_PUPf_SET
#define ADR1_CTLr_ADR1_OEBf_GET BCMI_MADURA_ADR1_CTLr_ADR1_OEBf_GET
#define ADR1_CTLr_ADR1_OEBf_SET BCMI_MADURA_ADR1_CTLr_ADR1_OEBf_SET
#define READ_ADR1_CTLr BCMI_MADURA_READ_ADR1_CTLr
#define WRITE_ADR1_CTLr BCMI_MADURA_WRITE_ADR1_CTLr
#define MODIFY_ADR1_CTLr BCMI_MADURA_MODIFY_ADR1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR1_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a3f
 * DEVAD:    1
 * DESC:     PAD adr1 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR1_DIN_LH      pad input latch highstatus
 *     ADR1_DIN_LL      pad input latch low status
 *     ADR1_DIN         live pad input value
 */
#define BCMI_MADURA_ADR1_STSr (0x00018a3f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR1_STSr_SIZE 4

/*
 * This structure should be used to declare and program ADR1_STS.
 */
typedef union BCMI_MADURA_ADR1_STSr_s {
	uint32_t v[1];
	uint32_t adr1_sts[1];
	uint32_t _adr1_sts;
} BCMI_MADURA_ADR1_STSr_t;

#define BCMI_MADURA_ADR1_STSr_CLR(r) (r).adr1_sts[0] = 0
#define BCMI_MADURA_ADR1_STSr_SET(r,d) (r).adr1_sts[0] = d
#define BCMI_MADURA_ADR1_STSr_GET(r) (r).adr1_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR1_STSr_ADR1_DINf_GET(r) ((((r).adr1_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR1_STSr_ADR1_DINf_SET(r,f) (r).adr1_sts[0]=(((r).adr1_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR1_STSr_ADR1_DIN_LLf_GET(r) ((((r).adr1_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR1_STSr_ADR1_DIN_LLf_SET(r,f) (r).adr1_sts[0]=(((r).adr1_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR1_STSr_ADR1_DIN_LHf_GET(r) (((r).adr1_sts[0]) & 0x1)
#define BCMI_MADURA_ADR1_STSr_ADR1_DIN_LHf_SET(r,f) (r).adr1_sts[0]=(((r).adr1_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR1_STS.
 */
#define BCMI_MADURA_READ_ADR1_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR1_STSr,_r._adr1_sts)
#define BCMI_MADURA_WRITE_ADR1_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR1_STSr,_r._adr1_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR1_STSr BCMI_MADURA_ADR1_STSr
#define ADR1_STSr_SIZE BCMI_MADURA_ADR1_STSr_SIZE
typedef BCMI_MADURA_ADR1_STSr_t ADR1_STSr_t;
#define ADR1_STSr_CLR BCMI_MADURA_ADR1_STSr_CLR
#define ADR1_STSr_SET BCMI_MADURA_ADR1_STSr_SET
#define ADR1_STSr_GET BCMI_MADURA_ADR1_STSr_GET
#define ADR1_STSr_ADR1_DINf_GET BCMI_MADURA_ADR1_STSr_ADR1_DINf_GET
#define ADR1_STSr_ADR1_DINf_SET BCMI_MADURA_ADR1_STSr_ADR1_DINf_SET
#define ADR1_STSr_ADR1_DIN_LLf_GET BCMI_MADURA_ADR1_STSr_ADR1_DIN_LLf_GET
#define ADR1_STSr_ADR1_DIN_LLf_SET BCMI_MADURA_ADR1_STSr_ADR1_DIN_LLf_SET
#define ADR1_STSr_ADR1_DIN_LHf_GET BCMI_MADURA_ADR1_STSr_ADR1_DIN_LHf_GET
#define ADR1_STSr_ADR1_DIN_LHf_SET BCMI_MADURA_ADR1_STSr_ADR1_DIN_LHf_SET
#define READ_ADR1_STSr BCMI_MADURA_READ_ADR1_STSr
#define WRITE_ADR1_STSr BCMI_MADURA_WRITE_ADR1_STSr
#define MODIFY_ADR1_STSr BCMI_MADURA_MODIFY_ADR1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR1_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR2_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a40
 * DEVAD:    1
 * DESC:     PAD adr2 control register
 * RESETVAL: 0x23 (35)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR2_OEB         adr2 output enable, active low
 *     ADR2_PUP         adr2 pull-up
 *     ADR2_PDN         adr2 pull down
 *     ADR2_IND         adr2 ind
 *     ADR2_SEL0        adr2 sel0
 *     ADR2_SEL1        adr2 sel1
 *     ADR2_SEL2        adr2 sel2
 *     ADR2_IBOF        For input, this is deglitch bypassFor output, this is the output force enable
 *     ADR2_INVERT_EN   enable polarity invertion for pad input or output
 *     ADR2_OUT_FRCVAL  the forced output value
 *     ADR2_DGLH_CNT    the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (adr2_ibof) is set to 0{adr2_ibof, adr2_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_ADR2_CTLr (0x00018a40 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ADR2_CTL.
 */
typedef union BCMI_MADURA_ADR2_CTLr_s {
	uint32_t v[1];
	uint32_t adr2_ctl[1];
	uint32_t _adr2_ctl;
} BCMI_MADURA_ADR2_CTLr_t;

#define BCMI_MADURA_ADR2_CTLr_CLR(r) (r).adr2_ctl[0] = 0
#define BCMI_MADURA_ADR2_CTLr_SET(r,d) (r).adr2_ctl[0] = d
#define BCMI_MADURA_ADR2_CTLr_GET(r) (r).adr2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR2_CTLr_ADR2_DGLH_CNTf_GET(r) ((((r).adr2_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_ADR2_CTLr_ADR2_DGLH_CNTf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_ADR2_CTLr_ADR2_OUT_FRCVALf_GET(r) ((((r).adr2_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_OUT_FRCVALf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_ADR2_CTLr_ADR2_INVERT_ENf_GET(r) ((((r).adr2_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_INVERT_ENf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_ADR2_CTLr_ADR2_IBOFf_GET(r) ((((r).adr2_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_IBOFf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ADR2_CTLr_ADR2_SEL2f_GET(r) ((((r).adr2_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_SEL2f_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_ADR2_CTLr_ADR2_SEL1f_GET(r) ((((r).adr2_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_SEL1f_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_ADR2_CTLr_ADR2_SEL0f_GET(r) ((((r).adr2_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_SEL0f_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_ADR2_CTLr_ADR2_INDf_GET(r) ((((r).adr2_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_INDf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ADR2_CTLr_ADR2_PDNf_GET(r) ((((r).adr2_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_PDNf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR2_CTLr_ADR2_PUPf_GET(r) ((((r).adr2_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_PUPf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR2_CTLr_ADR2_OEBf_GET(r) (((r).adr2_ctl[0]) & 0x1)
#define BCMI_MADURA_ADR2_CTLr_ADR2_OEBf_SET(r,f) (r).adr2_ctl[0]=(((r).adr2_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR2_CTL.
 */
#define BCMI_MADURA_READ_ADR2_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR2_CTLr,_r._adr2_ctl)
#define BCMI_MADURA_WRITE_ADR2_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR2_CTLr,_r._adr2_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR2_CTLr BCMI_MADURA_ADR2_CTLr
#define ADR2_CTLr_SIZE BCMI_MADURA_ADR2_CTLr_SIZE
typedef BCMI_MADURA_ADR2_CTLr_t ADR2_CTLr_t;
#define ADR2_CTLr_CLR BCMI_MADURA_ADR2_CTLr_CLR
#define ADR2_CTLr_SET BCMI_MADURA_ADR2_CTLr_SET
#define ADR2_CTLr_GET BCMI_MADURA_ADR2_CTLr_GET
#define ADR2_CTLr_ADR2_DGLH_CNTf_GET BCMI_MADURA_ADR2_CTLr_ADR2_DGLH_CNTf_GET
#define ADR2_CTLr_ADR2_DGLH_CNTf_SET BCMI_MADURA_ADR2_CTLr_ADR2_DGLH_CNTf_SET
#define ADR2_CTLr_ADR2_OUT_FRCVALf_GET BCMI_MADURA_ADR2_CTLr_ADR2_OUT_FRCVALf_GET
#define ADR2_CTLr_ADR2_OUT_FRCVALf_SET BCMI_MADURA_ADR2_CTLr_ADR2_OUT_FRCVALf_SET
#define ADR2_CTLr_ADR2_INVERT_ENf_GET BCMI_MADURA_ADR2_CTLr_ADR2_INVERT_ENf_GET
#define ADR2_CTLr_ADR2_INVERT_ENf_SET BCMI_MADURA_ADR2_CTLr_ADR2_INVERT_ENf_SET
#define ADR2_CTLr_ADR2_IBOFf_GET BCMI_MADURA_ADR2_CTLr_ADR2_IBOFf_GET
#define ADR2_CTLr_ADR2_IBOFf_SET BCMI_MADURA_ADR2_CTLr_ADR2_IBOFf_SET
#define ADR2_CTLr_ADR2_SEL2f_GET BCMI_MADURA_ADR2_CTLr_ADR2_SEL2f_GET
#define ADR2_CTLr_ADR2_SEL2f_SET BCMI_MADURA_ADR2_CTLr_ADR2_SEL2f_SET
#define ADR2_CTLr_ADR2_SEL1f_GET BCMI_MADURA_ADR2_CTLr_ADR2_SEL1f_GET
#define ADR2_CTLr_ADR2_SEL1f_SET BCMI_MADURA_ADR2_CTLr_ADR2_SEL1f_SET
#define ADR2_CTLr_ADR2_SEL0f_GET BCMI_MADURA_ADR2_CTLr_ADR2_SEL0f_GET
#define ADR2_CTLr_ADR2_SEL0f_SET BCMI_MADURA_ADR2_CTLr_ADR2_SEL0f_SET
#define ADR2_CTLr_ADR2_INDf_GET BCMI_MADURA_ADR2_CTLr_ADR2_INDf_GET
#define ADR2_CTLr_ADR2_INDf_SET BCMI_MADURA_ADR2_CTLr_ADR2_INDf_SET
#define ADR2_CTLr_ADR2_PDNf_GET BCMI_MADURA_ADR2_CTLr_ADR2_PDNf_GET
#define ADR2_CTLr_ADR2_PDNf_SET BCMI_MADURA_ADR2_CTLr_ADR2_PDNf_SET
#define ADR2_CTLr_ADR2_PUPf_GET BCMI_MADURA_ADR2_CTLr_ADR2_PUPf_GET
#define ADR2_CTLr_ADR2_PUPf_SET BCMI_MADURA_ADR2_CTLr_ADR2_PUPf_SET
#define ADR2_CTLr_ADR2_OEBf_GET BCMI_MADURA_ADR2_CTLr_ADR2_OEBf_GET
#define ADR2_CTLr_ADR2_OEBf_SET BCMI_MADURA_ADR2_CTLr_ADR2_OEBf_SET
#define READ_ADR2_CTLr BCMI_MADURA_READ_ADR2_CTLr
#define WRITE_ADR2_CTLr BCMI_MADURA_WRITE_ADR2_CTLr
#define MODIFY_ADR2_CTLr BCMI_MADURA_MODIFY_ADR2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR2_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a41
 * DEVAD:    1
 * DESC:     PAD adr2 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR2_DIN_LH      pad input latch highstatus
 *     ADR2_DIN_LL      pad input latch low status
 *     ADR2_DIN         live pad input value
 */
#define BCMI_MADURA_ADR2_STSr (0x00018a41 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR2_STSr_SIZE 4

/*
 * This structure should be used to declare and program ADR2_STS.
 */
typedef union BCMI_MADURA_ADR2_STSr_s {
	uint32_t v[1];
	uint32_t adr2_sts[1];
	uint32_t _adr2_sts;
} BCMI_MADURA_ADR2_STSr_t;

#define BCMI_MADURA_ADR2_STSr_CLR(r) (r).adr2_sts[0] = 0
#define BCMI_MADURA_ADR2_STSr_SET(r,d) (r).adr2_sts[0] = d
#define BCMI_MADURA_ADR2_STSr_GET(r) (r).adr2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR2_STSr_ADR2_DINf_GET(r) ((((r).adr2_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR2_STSr_ADR2_DINf_SET(r,f) (r).adr2_sts[0]=(((r).adr2_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR2_STSr_ADR2_DIN_LLf_GET(r) ((((r).adr2_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR2_STSr_ADR2_DIN_LLf_SET(r,f) (r).adr2_sts[0]=(((r).adr2_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR2_STSr_ADR2_DIN_LHf_GET(r) (((r).adr2_sts[0]) & 0x1)
#define BCMI_MADURA_ADR2_STSr_ADR2_DIN_LHf_SET(r,f) (r).adr2_sts[0]=(((r).adr2_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR2_STS.
 */
#define BCMI_MADURA_READ_ADR2_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR2_STSr,_r._adr2_sts)
#define BCMI_MADURA_WRITE_ADR2_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR2_STSr,_r._adr2_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR2_STSr BCMI_MADURA_ADR2_STSr
#define ADR2_STSr_SIZE BCMI_MADURA_ADR2_STSr_SIZE
typedef BCMI_MADURA_ADR2_STSr_t ADR2_STSr_t;
#define ADR2_STSr_CLR BCMI_MADURA_ADR2_STSr_CLR
#define ADR2_STSr_SET BCMI_MADURA_ADR2_STSr_SET
#define ADR2_STSr_GET BCMI_MADURA_ADR2_STSr_GET
#define ADR2_STSr_ADR2_DINf_GET BCMI_MADURA_ADR2_STSr_ADR2_DINf_GET
#define ADR2_STSr_ADR2_DINf_SET BCMI_MADURA_ADR2_STSr_ADR2_DINf_SET
#define ADR2_STSr_ADR2_DIN_LLf_GET BCMI_MADURA_ADR2_STSr_ADR2_DIN_LLf_GET
#define ADR2_STSr_ADR2_DIN_LLf_SET BCMI_MADURA_ADR2_STSr_ADR2_DIN_LLf_SET
#define ADR2_STSr_ADR2_DIN_LHf_GET BCMI_MADURA_ADR2_STSr_ADR2_DIN_LHf_GET
#define ADR2_STSr_ADR2_DIN_LHf_SET BCMI_MADURA_ADR2_STSr_ADR2_DIN_LHf_SET
#define READ_ADR2_STSr BCMI_MADURA_READ_ADR2_STSr
#define WRITE_ADR2_STSr BCMI_MADURA_WRITE_ADR2_STSr
#define MODIFY_ADR2_STSr BCMI_MADURA_MODIFY_ADR2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR3_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a42
 * DEVAD:    1
 * DESC:     PAD adr3 control register
 * RESETVAL: 0x23 (35)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR3_OEB         adr3 output enable, active low
 *     ADR3_PUP         adr3 pull-up
 *     ADR3_PDN         adr3 pull down
 *     ADR3_IND         adr3 ind
 *     ADR3_SEL0        adr3 sel0
 *     ADR3_SEL1        adr3 sel1
 *     ADR3_SEL2        adr3 sel2
 *     ADR3_IBOF        For input, this is deglitch bypassFor output, this is the output force enable
 *     ADR3_INVERT_EN   enable polarity invertion for pad input or output
 *     ADR3_OUT_FRCVAL  the forced output value
 *     ADR3_DGLH_CNT    the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (adr3_ibof) is set to 0{adr3_ibof, adr3_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_ADR3_CTLr (0x00018a42 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ADR3_CTL.
 */
typedef union BCMI_MADURA_ADR3_CTLr_s {
	uint32_t v[1];
	uint32_t adr3_ctl[1];
	uint32_t _adr3_ctl;
} BCMI_MADURA_ADR3_CTLr_t;

#define BCMI_MADURA_ADR3_CTLr_CLR(r) (r).adr3_ctl[0] = 0
#define BCMI_MADURA_ADR3_CTLr_SET(r,d) (r).adr3_ctl[0] = d
#define BCMI_MADURA_ADR3_CTLr_GET(r) (r).adr3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR3_CTLr_ADR3_DGLH_CNTf_GET(r) ((((r).adr3_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_ADR3_CTLr_ADR3_DGLH_CNTf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_ADR3_CTLr_ADR3_OUT_FRCVALf_GET(r) ((((r).adr3_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_OUT_FRCVALf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_ADR3_CTLr_ADR3_INVERT_ENf_GET(r) ((((r).adr3_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_INVERT_ENf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_ADR3_CTLr_ADR3_IBOFf_GET(r) ((((r).adr3_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_IBOFf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ADR3_CTLr_ADR3_SEL2f_GET(r) ((((r).adr3_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_SEL2f_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_ADR3_CTLr_ADR3_SEL1f_GET(r) ((((r).adr3_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_SEL1f_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_ADR3_CTLr_ADR3_SEL0f_GET(r) ((((r).adr3_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_SEL0f_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_ADR3_CTLr_ADR3_INDf_GET(r) ((((r).adr3_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_INDf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ADR3_CTLr_ADR3_PDNf_GET(r) ((((r).adr3_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_PDNf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR3_CTLr_ADR3_PUPf_GET(r) ((((r).adr3_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_PUPf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR3_CTLr_ADR3_OEBf_GET(r) (((r).adr3_ctl[0]) & 0x1)
#define BCMI_MADURA_ADR3_CTLr_ADR3_OEBf_SET(r,f) (r).adr3_ctl[0]=(((r).adr3_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR3_CTL.
 */
#define BCMI_MADURA_READ_ADR3_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR3_CTLr,_r._adr3_ctl)
#define BCMI_MADURA_WRITE_ADR3_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR3_CTLr,_r._adr3_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR3_CTLr BCMI_MADURA_ADR3_CTLr
#define ADR3_CTLr_SIZE BCMI_MADURA_ADR3_CTLr_SIZE
typedef BCMI_MADURA_ADR3_CTLr_t ADR3_CTLr_t;
#define ADR3_CTLr_CLR BCMI_MADURA_ADR3_CTLr_CLR
#define ADR3_CTLr_SET BCMI_MADURA_ADR3_CTLr_SET
#define ADR3_CTLr_GET BCMI_MADURA_ADR3_CTLr_GET
#define ADR3_CTLr_ADR3_DGLH_CNTf_GET BCMI_MADURA_ADR3_CTLr_ADR3_DGLH_CNTf_GET
#define ADR3_CTLr_ADR3_DGLH_CNTf_SET BCMI_MADURA_ADR3_CTLr_ADR3_DGLH_CNTf_SET
#define ADR3_CTLr_ADR3_OUT_FRCVALf_GET BCMI_MADURA_ADR3_CTLr_ADR3_OUT_FRCVALf_GET
#define ADR3_CTLr_ADR3_OUT_FRCVALf_SET BCMI_MADURA_ADR3_CTLr_ADR3_OUT_FRCVALf_SET
#define ADR3_CTLr_ADR3_INVERT_ENf_GET BCMI_MADURA_ADR3_CTLr_ADR3_INVERT_ENf_GET
#define ADR3_CTLr_ADR3_INVERT_ENf_SET BCMI_MADURA_ADR3_CTLr_ADR3_INVERT_ENf_SET
#define ADR3_CTLr_ADR3_IBOFf_GET BCMI_MADURA_ADR3_CTLr_ADR3_IBOFf_GET
#define ADR3_CTLr_ADR3_IBOFf_SET BCMI_MADURA_ADR3_CTLr_ADR3_IBOFf_SET
#define ADR3_CTLr_ADR3_SEL2f_GET BCMI_MADURA_ADR3_CTLr_ADR3_SEL2f_GET
#define ADR3_CTLr_ADR3_SEL2f_SET BCMI_MADURA_ADR3_CTLr_ADR3_SEL2f_SET
#define ADR3_CTLr_ADR3_SEL1f_GET BCMI_MADURA_ADR3_CTLr_ADR3_SEL1f_GET
#define ADR3_CTLr_ADR3_SEL1f_SET BCMI_MADURA_ADR3_CTLr_ADR3_SEL1f_SET
#define ADR3_CTLr_ADR3_SEL0f_GET BCMI_MADURA_ADR3_CTLr_ADR3_SEL0f_GET
#define ADR3_CTLr_ADR3_SEL0f_SET BCMI_MADURA_ADR3_CTLr_ADR3_SEL0f_SET
#define ADR3_CTLr_ADR3_INDf_GET BCMI_MADURA_ADR3_CTLr_ADR3_INDf_GET
#define ADR3_CTLr_ADR3_INDf_SET BCMI_MADURA_ADR3_CTLr_ADR3_INDf_SET
#define ADR3_CTLr_ADR3_PDNf_GET BCMI_MADURA_ADR3_CTLr_ADR3_PDNf_GET
#define ADR3_CTLr_ADR3_PDNf_SET BCMI_MADURA_ADR3_CTLr_ADR3_PDNf_SET
#define ADR3_CTLr_ADR3_PUPf_GET BCMI_MADURA_ADR3_CTLr_ADR3_PUPf_GET
#define ADR3_CTLr_ADR3_PUPf_SET BCMI_MADURA_ADR3_CTLr_ADR3_PUPf_SET
#define ADR3_CTLr_ADR3_OEBf_GET BCMI_MADURA_ADR3_CTLr_ADR3_OEBf_GET
#define ADR3_CTLr_ADR3_OEBf_SET BCMI_MADURA_ADR3_CTLr_ADR3_OEBf_SET
#define READ_ADR3_CTLr BCMI_MADURA_READ_ADR3_CTLr
#define WRITE_ADR3_CTLr BCMI_MADURA_WRITE_ADR3_CTLr
#define MODIFY_ADR3_CTLr BCMI_MADURA_MODIFY_ADR3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR3_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a43
 * DEVAD:    1
 * DESC:     PAD adr3 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR3_DIN_LH      pad input latch highstatus
 *     ADR3_DIN_LL      pad input latch low status
 *     ADR3_DIN         live pad input value
 */
#define BCMI_MADURA_ADR3_STSr (0x00018a43 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR3_STSr_SIZE 4

/*
 * This structure should be used to declare and program ADR3_STS.
 */
typedef union BCMI_MADURA_ADR3_STSr_s {
	uint32_t v[1];
	uint32_t adr3_sts[1];
	uint32_t _adr3_sts;
} BCMI_MADURA_ADR3_STSr_t;

#define BCMI_MADURA_ADR3_STSr_CLR(r) (r).adr3_sts[0] = 0
#define BCMI_MADURA_ADR3_STSr_SET(r,d) (r).adr3_sts[0] = d
#define BCMI_MADURA_ADR3_STSr_GET(r) (r).adr3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR3_STSr_ADR3_DINf_GET(r) ((((r).adr3_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR3_STSr_ADR3_DINf_SET(r,f) (r).adr3_sts[0]=(((r).adr3_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR3_STSr_ADR3_DIN_LLf_GET(r) ((((r).adr3_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR3_STSr_ADR3_DIN_LLf_SET(r,f) (r).adr3_sts[0]=(((r).adr3_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR3_STSr_ADR3_DIN_LHf_GET(r) (((r).adr3_sts[0]) & 0x1)
#define BCMI_MADURA_ADR3_STSr_ADR3_DIN_LHf_SET(r,f) (r).adr3_sts[0]=(((r).adr3_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR3_STS.
 */
#define BCMI_MADURA_READ_ADR3_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR3_STSr,_r._adr3_sts)
#define BCMI_MADURA_WRITE_ADR3_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR3_STSr,_r._adr3_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR3_STSr BCMI_MADURA_ADR3_STSr
#define ADR3_STSr_SIZE BCMI_MADURA_ADR3_STSr_SIZE
typedef BCMI_MADURA_ADR3_STSr_t ADR3_STSr_t;
#define ADR3_STSr_CLR BCMI_MADURA_ADR3_STSr_CLR
#define ADR3_STSr_SET BCMI_MADURA_ADR3_STSr_SET
#define ADR3_STSr_GET BCMI_MADURA_ADR3_STSr_GET
#define ADR3_STSr_ADR3_DINf_GET BCMI_MADURA_ADR3_STSr_ADR3_DINf_GET
#define ADR3_STSr_ADR3_DINf_SET BCMI_MADURA_ADR3_STSr_ADR3_DINf_SET
#define ADR3_STSr_ADR3_DIN_LLf_GET BCMI_MADURA_ADR3_STSr_ADR3_DIN_LLf_GET
#define ADR3_STSr_ADR3_DIN_LLf_SET BCMI_MADURA_ADR3_STSr_ADR3_DIN_LLf_SET
#define ADR3_STSr_ADR3_DIN_LHf_GET BCMI_MADURA_ADR3_STSr_ADR3_DIN_LHf_GET
#define ADR3_STSr_ADR3_DIN_LHf_SET BCMI_MADURA_ADR3_STSr_ADR3_DIN_LHf_SET
#define READ_ADR3_STSr BCMI_MADURA_READ_ADR3_STSr
#define WRITE_ADR3_STSr BCMI_MADURA_WRITE_ADR3_STSr
#define MODIFY_ADR3_STSr BCMI_MADURA_MODIFY_ADR3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR4_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a44
 * DEVAD:    1
 * DESC:     PAD adr4 control register
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR4_PUP         adr4 pull-up
 *     ADR4_PDN         adr4 pull down
 *     ADR4_IND         adr4 ind
 *     ADR4_IBOF        For input, this is deglitch bypassFor output, this is the output force enable
 *     ADR4_INVERT_EN   enable polarity invertion for pad input or output
 *     ADR4_OUT_FRCVAL  the forced output value
 *     ADR4_DGLH_CNT    the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (adr4_ibof) is set to 0{adr4_ibof, adr4_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_ADR4_CTLr (0x00018a44 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ADR4_CTL.
 */
typedef union BCMI_MADURA_ADR4_CTLr_s {
	uint32_t v[1];
	uint32_t adr4_ctl[1];
	uint32_t _adr4_ctl;
} BCMI_MADURA_ADR4_CTLr_t;

#define BCMI_MADURA_ADR4_CTLr_CLR(r) (r).adr4_ctl[0] = 0
#define BCMI_MADURA_ADR4_CTLr_SET(r,d) (r).adr4_ctl[0] = d
#define BCMI_MADURA_ADR4_CTLr_GET(r) (r).adr4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR4_CTLr_ADR4_DGLH_CNTf_GET(r) ((((r).adr4_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_ADR4_CTLr_ADR4_DGLH_CNTf_SET(r,f) (r).adr4_ctl[0]=(((r).adr4_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_ADR4_CTLr_ADR4_OUT_FRCVALf_GET(r) ((((r).adr4_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_ADR4_CTLr_ADR4_OUT_FRCVALf_SET(r,f) (r).adr4_ctl[0]=(((r).adr4_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_ADR4_CTLr_ADR4_INVERT_ENf_GET(r) ((((r).adr4_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_ADR4_CTLr_ADR4_INVERT_ENf_SET(r,f) (r).adr4_ctl[0]=(((r).adr4_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_ADR4_CTLr_ADR4_IBOFf_GET(r) ((((r).adr4_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_ADR4_CTLr_ADR4_IBOFf_SET(r,f) (r).adr4_ctl[0]=(((r).adr4_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ADR4_CTLr_ADR4_INDf_GET(r) ((((r).adr4_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_ADR4_CTLr_ADR4_INDf_SET(r,f) (r).adr4_ctl[0]=(((r).adr4_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ADR4_CTLr_ADR4_PDNf_GET(r) ((((r).adr4_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR4_CTLr_ADR4_PDNf_SET(r,f) (r).adr4_ctl[0]=(((r).adr4_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR4_CTLr_ADR4_PUPf_GET(r) ((((r).adr4_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR4_CTLr_ADR4_PUPf_SET(r,f) (r).adr4_ctl[0]=(((r).adr4_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access ADR4_CTL.
 */
#define BCMI_MADURA_READ_ADR4_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR4_CTLr,_r._adr4_ctl)
#define BCMI_MADURA_WRITE_ADR4_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR4_CTLr,_r._adr4_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR4_CTLr BCMI_MADURA_ADR4_CTLr
#define ADR4_CTLr_SIZE BCMI_MADURA_ADR4_CTLr_SIZE
typedef BCMI_MADURA_ADR4_CTLr_t ADR4_CTLr_t;
#define ADR4_CTLr_CLR BCMI_MADURA_ADR4_CTLr_CLR
#define ADR4_CTLr_SET BCMI_MADURA_ADR4_CTLr_SET
#define ADR4_CTLr_GET BCMI_MADURA_ADR4_CTLr_GET
#define ADR4_CTLr_ADR4_DGLH_CNTf_GET BCMI_MADURA_ADR4_CTLr_ADR4_DGLH_CNTf_GET
#define ADR4_CTLr_ADR4_DGLH_CNTf_SET BCMI_MADURA_ADR4_CTLr_ADR4_DGLH_CNTf_SET
#define ADR4_CTLr_ADR4_OUT_FRCVALf_GET BCMI_MADURA_ADR4_CTLr_ADR4_OUT_FRCVALf_GET
#define ADR4_CTLr_ADR4_OUT_FRCVALf_SET BCMI_MADURA_ADR4_CTLr_ADR4_OUT_FRCVALf_SET
#define ADR4_CTLr_ADR4_INVERT_ENf_GET BCMI_MADURA_ADR4_CTLr_ADR4_INVERT_ENf_GET
#define ADR4_CTLr_ADR4_INVERT_ENf_SET BCMI_MADURA_ADR4_CTLr_ADR4_INVERT_ENf_SET
#define ADR4_CTLr_ADR4_IBOFf_GET BCMI_MADURA_ADR4_CTLr_ADR4_IBOFf_GET
#define ADR4_CTLr_ADR4_IBOFf_SET BCMI_MADURA_ADR4_CTLr_ADR4_IBOFf_SET
#define ADR4_CTLr_ADR4_INDf_GET BCMI_MADURA_ADR4_CTLr_ADR4_INDf_GET
#define ADR4_CTLr_ADR4_INDf_SET BCMI_MADURA_ADR4_CTLr_ADR4_INDf_SET
#define ADR4_CTLr_ADR4_PDNf_GET BCMI_MADURA_ADR4_CTLr_ADR4_PDNf_GET
#define ADR4_CTLr_ADR4_PDNf_SET BCMI_MADURA_ADR4_CTLr_ADR4_PDNf_SET
#define ADR4_CTLr_ADR4_PUPf_GET BCMI_MADURA_ADR4_CTLr_ADR4_PUPf_GET
#define ADR4_CTLr_ADR4_PUPf_SET BCMI_MADURA_ADR4_CTLr_ADR4_PUPf_SET
#define READ_ADR4_CTLr BCMI_MADURA_READ_ADR4_CTLr
#define WRITE_ADR4_CTLr BCMI_MADURA_WRITE_ADR4_CTLr
#define MODIFY_ADR4_CTLr BCMI_MADURA_MODIFY_ADR4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ADR4_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a45
 * DEVAD:    1
 * DESC:     PAD adr4 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ADR4_DIN_LH      pad input latch highstatus
 *     ADR4_DIN_LL      pad input latch low status
 *     ADR4_DIN         live pad input value
 */
#define BCMI_MADURA_ADR4_STSr (0x00018a45 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ADR4_STSr_SIZE 4

/*
 * This structure should be used to declare and program ADR4_STS.
 */
typedef union BCMI_MADURA_ADR4_STSr_s {
	uint32_t v[1];
	uint32_t adr4_sts[1];
	uint32_t _adr4_sts;
} BCMI_MADURA_ADR4_STSr_t;

#define BCMI_MADURA_ADR4_STSr_CLR(r) (r).adr4_sts[0] = 0
#define BCMI_MADURA_ADR4_STSr_SET(r,d) (r).adr4_sts[0] = d
#define BCMI_MADURA_ADR4_STSr_GET(r) (r).adr4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ADR4_STSr_ADR4_DINf_GET(r) ((((r).adr4_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_ADR4_STSr_ADR4_DINf_SET(r,f) (r).adr4_sts[0]=(((r).adr4_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ADR4_STSr_ADR4_DIN_LLf_GET(r) ((((r).adr4_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_ADR4_STSr_ADR4_DIN_LLf_SET(r,f) (r).adr4_sts[0]=(((r).adr4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ADR4_STSr_ADR4_DIN_LHf_GET(r) (((r).adr4_sts[0]) & 0x1)
#define BCMI_MADURA_ADR4_STSr_ADR4_DIN_LHf_SET(r,f) (r).adr4_sts[0]=(((r).adr4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ADR4_STS.
 */
#define BCMI_MADURA_READ_ADR4_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ADR4_STSr,_r._adr4_sts)
#define BCMI_MADURA_WRITE_ADR4_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ADR4_STSr,_r._adr4_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ADR4_STSr BCMI_MADURA_ADR4_STSr
#define ADR4_STSr_SIZE BCMI_MADURA_ADR4_STSr_SIZE
typedef BCMI_MADURA_ADR4_STSr_t ADR4_STSr_t;
#define ADR4_STSr_CLR BCMI_MADURA_ADR4_STSr_CLR
#define ADR4_STSr_SET BCMI_MADURA_ADR4_STSr_SET
#define ADR4_STSr_GET BCMI_MADURA_ADR4_STSr_GET
#define ADR4_STSr_ADR4_DINf_GET BCMI_MADURA_ADR4_STSr_ADR4_DINf_GET
#define ADR4_STSr_ADR4_DINf_SET BCMI_MADURA_ADR4_STSr_ADR4_DINf_SET
#define ADR4_STSr_ADR4_DIN_LLf_GET BCMI_MADURA_ADR4_STSr_ADR4_DIN_LLf_GET
#define ADR4_STSr_ADR4_DIN_LLf_SET BCMI_MADURA_ADR4_STSr_ADR4_DIN_LLf_SET
#define ADR4_STSr_ADR4_DIN_LHf_GET BCMI_MADURA_ADR4_STSr_ADR4_DIN_LHf_GET
#define ADR4_STSr_ADR4_DIN_LHf_SET BCMI_MADURA_ADR4_STSr_ADR4_DIN_LHf_SET
#define READ_ADR4_STSr BCMI_MADURA_READ_ADR4_STSr
#define WRITE_ADR4_STSr BCMI_MADURA_WRITE_ADR4_STSr
#define MODIFY_ADR4_STSr BCMI_MADURA_MODIFY_ADR4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ADR4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISO_SROM_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a46
 * DEVAD:    1
 * DESC:     PAD miso_srom control register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     MISO_SROM_PUP    miso_srom pull-up
 *     MISO_SROM_PDN    miso_srom pull down
 *     MISO_SROM_IND    miso_srom ind
 *     MISO_SROM_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     MISO_SROM_INVERT_EN enable polarity invertion for pad input or output
 *     MISO_SROM_OUT_FRCVAL the forced output value
 *     MISO_SROM_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (miso_srom_ibof) is set to 0{miso_srom_ibof, miso_srom_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MISO_SROM_CTLr (0x00018a46 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISO_SROM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MISO_SROM_CTL.
 */
typedef union BCMI_MADURA_MISO_SROM_CTLr_s {
	uint32_t v[1];
	uint32_t miso_srom_ctl[1];
	uint32_t _miso_srom_ctl;
} BCMI_MADURA_MISO_SROM_CTLr_t;

#define BCMI_MADURA_MISO_SROM_CTLr_CLR(r) (r).miso_srom_ctl[0] = 0
#define BCMI_MADURA_MISO_SROM_CTLr_SET(r,d) (r).miso_srom_ctl[0] = d
#define BCMI_MADURA_MISO_SROM_CTLr_GET(r) (r).miso_srom_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_DGLH_CNTf_GET(r) ((((r).miso_srom_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_DGLH_CNTf_SET(r,f) (r).miso_srom_ctl[0]=(((r).miso_srom_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_OUT_FRCVALf_GET(r) ((((r).miso_srom_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_OUT_FRCVALf_SET(r,f) (r).miso_srom_ctl[0]=(((r).miso_srom_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INVERT_ENf_GET(r) ((((r).miso_srom_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INVERT_ENf_SET(r,f) (r).miso_srom_ctl[0]=(((r).miso_srom_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_IBOFf_GET(r) ((((r).miso_srom_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_IBOFf_SET(r,f) (r).miso_srom_ctl[0]=(((r).miso_srom_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INDf_GET(r) ((((r).miso_srom_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INDf_SET(r,f) (r).miso_srom_ctl[0]=(((r).miso_srom_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PDNf_GET(r) ((((r).miso_srom_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PDNf_SET(r,f) (r).miso_srom_ctl[0]=(((r).miso_srom_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PUPf_GET(r) ((((r).miso_srom_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PUPf_SET(r,f) (r).miso_srom_ctl[0]=(((r).miso_srom_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access MISO_SROM_CTL.
 */
#define BCMI_MADURA_READ_MISO_SROM_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISO_SROM_CTLr,_r._miso_srom_ctl)
#define BCMI_MADURA_WRITE_MISO_SROM_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISO_SROM_CTLr,_r._miso_srom_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISO_SROM_CTLr BCMI_MADURA_MISO_SROM_CTLr
#define MISO_SROM_CTLr_SIZE BCMI_MADURA_MISO_SROM_CTLr_SIZE
typedef BCMI_MADURA_MISO_SROM_CTLr_t MISO_SROM_CTLr_t;
#define MISO_SROM_CTLr_CLR BCMI_MADURA_MISO_SROM_CTLr_CLR
#define MISO_SROM_CTLr_SET BCMI_MADURA_MISO_SROM_CTLr_SET
#define MISO_SROM_CTLr_GET BCMI_MADURA_MISO_SROM_CTLr_GET
#define MISO_SROM_CTLr_MISO_SROM_DGLH_CNTf_GET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_DGLH_CNTf_GET
#define MISO_SROM_CTLr_MISO_SROM_DGLH_CNTf_SET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_DGLH_CNTf_SET
#define MISO_SROM_CTLr_MISO_SROM_OUT_FRCVALf_GET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_OUT_FRCVALf_GET
#define MISO_SROM_CTLr_MISO_SROM_OUT_FRCVALf_SET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_OUT_FRCVALf_SET
#define MISO_SROM_CTLr_MISO_SROM_INVERT_ENf_GET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INVERT_ENf_GET
#define MISO_SROM_CTLr_MISO_SROM_INVERT_ENf_SET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INVERT_ENf_SET
#define MISO_SROM_CTLr_MISO_SROM_IBOFf_GET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_IBOFf_GET
#define MISO_SROM_CTLr_MISO_SROM_IBOFf_SET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_IBOFf_SET
#define MISO_SROM_CTLr_MISO_SROM_INDf_GET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INDf_GET
#define MISO_SROM_CTLr_MISO_SROM_INDf_SET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_INDf_SET
#define MISO_SROM_CTLr_MISO_SROM_PDNf_GET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PDNf_GET
#define MISO_SROM_CTLr_MISO_SROM_PDNf_SET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PDNf_SET
#define MISO_SROM_CTLr_MISO_SROM_PUPf_GET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PUPf_GET
#define MISO_SROM_CTLr_MISO_SROM_PUPf_SET BCMI_MADURA_MISO_SROM_CTLr_MISO_SROM_PUPf_SET
#define READ_MISO_SROM_CTLr BCMI_MADURA_READ_MISO_SROM_CTLr
#define WRITE_MISO_SROM_CTLr BCMI_MADURA_WRITE_MISO_SROM_CTLr
#define MODIFY_MISO_SROM_CTLr BCMI_MADURA_MODIFY_MISO_SROM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISO_SROM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISO_SROM_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a47
 * DEVAD:    1
 * DESC:     PAD miso_srom status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MISO_SROM_DIN_LH pad input latch highstatus
 *     MISO_SROM_DIN_LL pad input latch low status
 *     MISO_SROM_DIN    live pad input value
 */
#define BCMI_MADURA_MISO_SROM_STSr (0x00018a47 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISO_SROM_STSr_SIZE 4

/*
 * This structure should be used to declare and program MISO_SROM_STS.
 */
typedef union BCMI_MADURA_MISO_SROM_STSr_s {
	uint32_t v[1];
	uint32_t miso_srom_sts[1];
	uint32_t _miso_srom_sts;
} BCMI_MADURA_MISO_SROM_STSr_t;

#define BCMI_MADURA_MISO_SROM_STSr_CLR(r) (r).miso_srom_sts[0] = 0
#define BCMI_MADURA_MISO_SROM_STSr_SET(r,d) (r).miso_srom_sts[0] = d
#define BCMI_MADURA_MISO_SROM_STSr_GET(r) (r).miso_srom_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DINf_GET(r) ((((r).miso_srom_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DINf_SET(r,f) (r).miso_srom_sts[0]=(((r).miso_srom_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LLf_GET(r) ((((r).miso_srom_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LLf_SET(r,f) (r).miso_srom_sts[0]=(((r).miso_srom_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LHf_GET(r) (((r).miso_srom_sts[0]) & 0x1)
#define BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LHf_SET(r,f) (r).miso_srom_sts[0]=(((r).miso_srom_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISO_SROM_STS.
 */
#define BCMI_MADURA_READ_MISO_SROM_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISO_SROM_STSr,_r._miso_srom_sts)
#define BCMI_MADURA_WRITE_MISO_SROM_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISO_SROM_STSr,_r._miso_srom_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISO_SROM_STSr BCMI_MADURA_MISO_SROM_STSr
#define MISO_SROM_STSr_SIZE BCMI_MADURA_MISO_SROM_STSr_SIZE
typedef BCMI_MADURA_MISO_SROM_STSr_t MISO_SROM_STSr_t;
#define MISO_SROM_STSr_CLR BCMI_MADURA_MISO_SROM_STSr_CLR
#define MISO_SROM_STSr_SET BCMI_MADURA_MISO_SROM_STSr_SET
#define MISO_SROM_STSr_GET BCMI_MADURA_MISO_SROM_STSr_GET
#define MISO_SROM_STSr_MISO_SROM_DINf_GET BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DINf_GET
#define MISO_SROM_STSr_MISO_SROM_DINf_SET BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DINf_SET
#define MISO_SROM_STSr_MISO_SROM_DIN_LLf_GET BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LLf_GET
#define MISO_SROM_STSr_MISO_SROM_DIN_LLf_SET BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LLf_SET
#define MISO_SROM_STSr_MISO_SROM_DIN_LHf_GET BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LHf_GET
#define MISO_SROM_STSr_MISO_SROM_DIN_LHf_SET BCMI_MADURA_MISO_SROM_STSr_MISO_SROM_DIN_LHf_SET
#define READ_MISO_SROM_STSr BCMI_MADURA_READ_MISO_SROM_STSr
#define WRITE_MISO_SROM_STSr BCMI_MADURA_WRITE_MISO_SROM_STSr
#define MODIFY_MISO_SROM_STSr BCMI_MADURA_MODIFY_MISO_SROM_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISO_SROM_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOSI_SROM_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a48
 * DEVAD:    1
 * DESC:     PAD mosi_srom control register
 * RESETVAL: 0x62 (98)
 * ACCESS:   R/W
 * FIELDS:
 *     MOSI_SROM_PUP    mosi_srom pull-up
 *     MOSI_SROM_PDN    mosi_srom pull down
 *     MOSI_SROM_IND    mosi_srom ind
 *     MOSI_SROM_SEL0   mosi_srom sel0
 *     MOSI_SROM_SEL1   mosi_srom sel1
 *     MOSI_SROM_SEL2   mosi_srom sel2
 *     MOSI_SROM_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     MOSI_SROM_INVERT_EN enable polarity invertion for pad input or output
 *     MOSI_SROM_OUT_FRCVAL the forced output value
 *     MOSI_SROM_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mosi_srom_ibof) is set to 0{mosi_srom_ibof, mosi_srom_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MOSI_SROM_CTLr (0x00018a48 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOSI_SROM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MOSI_SROM_CTL.
 */
typedef union BCMI_MADURA_MOSI_SROM_CTLr_s {
	uint32_t v[1];
	uint32_t mosi_srom_ctl[1];
	uint32_t _mosi_srom_ctl;
} BCMI_MADURA_MOSI_SROM_CTLr_t;

#define BCMI_MADURA_MOSI_SROM_CTLr_CLR(r) (r).mosi_srom_ctl[0] = 0
#define BCMI_MADURA_MOSI_SROM_CTLr_SET(r,d) (r).mosi_srom_ctl[0] = d
#define BCMI_MADURA_MOSI_SROM_CTLr_GET(r) (r).mosi_srom_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_DGLH_CNTf_GET(r) ((((r).mosi_srom_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_DGLH_CNTf_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_OUT_FRCVALf_GET(r) ((((r).mosi_srom_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_OUT_FRCVALf_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INVERT_ENf_GET(r) ((((r).mosi_srom_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INVERT_ENf_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_IBOFf_GET(r) ((((r).mosi_srom_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_IBOFf_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL2f_GET(r) ((((r).mosi_srom_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL2f_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL1f_GET(r) ((((r).mosi_srom_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL1f_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL0f_GET(r) ((((r).mosi_srom_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL0f_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INDf_GET(r) ((((r).mosi_srom_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INDf_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PDNf_GET(r) ((((r).mosi_srom_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PDNf_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PUPf_GET(r) ((((r).mosi_srom_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PUPf_SET(r,f) (r).mosi_srom_ctl[0]=(((r).mosi_srom_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access MOSI_SROM_CTL.
 */
#define BCMI_MADURA_READ_MOSI_SROM_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOSI_SROM_CTLr,_r._mosi_srom_ctl)
#define BCMI_MADURA_WRITE_MOSI_SROM_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOSI_SROM_CTLr,_r._mosi_srom_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOSI_SROM_CTLr BCMI_MADURA_MOSI_SROM_CTLr
#define MOSI_SROM_CTLr_SIZE BCMI_MADURA_MOSI_SROM_CTLr_SIZE
typedef BCMI_MADURA_MOSI_SROM_CTLr_t MOSI_SROM_CTLr_t;
#define MOSI_SROM_CTLr_CLR BCMI_MADURA_MOSI_SROM_CTLr_CLR
#define MOSI_SROM_CTLr_SET BCMI_MADURA_MOSI_SROM_CTLr_SET
#define MOSI_SROM_CTLr_GET BCMI_MADURA_MOSI_SROM_CTLr_GET
#define MOSI_SROM_CTLr_MOSI_SROM_DGLH_CNTf_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_DGLH_CNTf_GET
#define MOSI_SROM_CTLr_MOSI_SROM_DGLH_CNTf_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_DGLH_CNTf_SET
#define MOSI_SROM_CTLr_MOSI_SROM_OUT_FRCVALf_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_OUT_FRCVALf_GET
#define MOSI_SROM_CTLr_MOSI_SROM_OUT_FRCVALf_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_OUT_FRCVALf_SET
#define MOSI_SROM_CTLr_MOSI_SROM_INVERT_ENf_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INVERT_ENf_GET
#define MOSI_SROM_CTLr_MOSI_SROM_INVERT_ENf_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INVERT_ENf_SET
#define MOSI_SROM_CTLr_MOSI_SROM_IBOFf_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_IBOFf_GET
#define MOSI_SROM_CTLr_MOSI_SROM_IBOFf_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_IBOFf_SET
#define MOSI_SROM_CTLr_MOSI_SROM_SEL2f_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL2f_GET
#define MOSI_SROM_CTLr_MOSI_SROM_SEL2f_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL2f_SET
#define MOSI_SROM_CTLr_MOSI_SROM_SEL1f_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL1f_GET
#define MOSI_SROM_CTLr_MOSI_SROM_SEL1f_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL1f_SET
#define MOSI_SROM_CTLr_MOSI_SROM_SEL0f_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL0f_GET
#define MOSI_SROM_CTLr_MOSI_SROM_SEL0f_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_SEL0f_SET
#define MOSI_SROM_CTLr_MOSI_SROM_INDf_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INDf_GET
#define MOSI_SROM_CTLr_MOSI_SROM_INDf_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_INDf_SET
#define MOSI_SROM_CTLr_MOSI_SROM_PDNf_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PDNf_GET
#define MOSI_SROM_CTLr_MOSI_SROM_PDNf_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PDNf_SET
#define MOSI_SROM_CTLr_MOSI_SROM_PUPf_GET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PUPf_GET
#define MOSI_SROM_CTLr_MOSI_SROM_PUPf_SET BCMI_MADURA_MOSI_SROM_CTLr_MOSI_SROM_PUPf_SET
#define READ_MOSI_SROM_CTLr BCMI_MADURA_READ_MOSI_SROM_CTLr
#define WRITE_MOSI_SROM_CTLr BCMI_MADURA_WRITE_MOSI_SROM_CTLr
#define MODIFY_MOSI_SROM_CTLr BCMI_MADURA_MODIFY_MOSI_SROM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOSI_SROM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCK_SROM_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a4a
 * DEVAD:    1
 * DESC:     PAD sck_srom control register
 * RESETVAL: 0x62 (98)
 * ACCESS:   R/W
 * FIELDS:
 *     SCK_SROM_PUP     sck_srom pull-up
 *     SCK_SROM_PDN     sck_srom pull down
 *     SCK_SROM_IND     sck_srom ind
 *     SCK_SROM_SEL0    sck_srom sel0
 *     SCK_SROM_SEL1    sck_srom sel1
 *     SCK_SROM_SEL2    sck_srom sel2
 *     SCK_SROM_IBOF    For input, this is deglitch bypassFor output, this is the output force enable
 *     SCK_SROM_INVERT_EN enable polarity invertion for pad input or output
 *     SCK_SROM_OUT_FRCVAL the forced output value
 *     SCK_SROM_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (sck_srom_ibof) is set to 0{sck_srom_ibof, sck_srom_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_SCK_SROM_CTLr (0x00018a4a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCK_SROM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SCK_SROM_CTL.
 */
typedef union BCMI_MADURA_SCK_SROM_CTLr_s {
	uint32_t v[1];
	uint32_t sck_srom_ctl[1];
	uint32_t _sck_srom_ctl;
} BCMI_MADURA_SCK_SROM_CTLr_t;

#define BCMI_MADURA_SCK_SROM_CTLr_CLR(r) (r).sck_srom_ctl[0] = 0
#define BCMI_MADURA_SCK_SROM_CTLr_SET(r,d) (r).sck_srom_ctl[0] = d
#define BCMI_MADURA_SCK_SROM_CTLr_GET(r) (r).sck_srom_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_DGLH_CNTf_GET(r) ((((r).sck_srom_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_DGLH_CNTf_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_OUT_FRCVALf_GET(r) ((((r).sck_srom_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_OUT_FRCVALf_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INVERT_ENf_GET(r) ((((r).sck_srom_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INVERT_ENf_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_IBOFf_GET(r) ((((r).sck_srom_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_IBOFf_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL2f_GET(r) ((((r).sck_srom_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL2f_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL1f_GET(r) ((((r).sck_srom_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL1f_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL0f_GET(r) ((((r).sck_srom_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL0f_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INDf_GET(r) ((((r).sck_srom_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INDf_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PDNf_GET(r) ((((r).sck_srom_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PDNf_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PUPf_GET(r) ((((r).sck_srom_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PUPf_SET(r,f) (r).sck_srom_ctl[0]=(((r).sck_srom_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SCK_SROM_CTL.
 */
#define BCMI_MADURA_READ_SCK_SROM_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCK_SROM_CTLr,_r._sck_srom_ctl)
#define BCMI_MADURA_WRITE_SCK_SROM_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCK_SROM_CTLr,_r._sck_srom_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCK_SROM_CTLr BCMI_MADURA_SCK_SROM_CTLr
#define SCK_SROM_CTLr_SIZE BCMI_MADURA_SCK_SROM_CTLr_SIZE
typedef BCMI_MADURA_SCK_SROM_CTLr_t SCK_SROM_CTLr_t;
#define SCK_SROM_CTLr_CLR BCMI_MADURA_SCK_SROM_CTLr_CLR
#define SCK_SROM_CTLr_SET BCMI_MADURA_SCK_SROM_CTLr_SET
#define SCK_SROM_CTLr_GET BCMI_MADURA_SCK_SROM_CTLr_GET
#define SCK_SROM_CTLr_SCK_SROM_DGLH_CNTf_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_DGLH_CNTf_GET
#define SCK_SROM_CTLr_SCK_SROM_DGLH_CNTf_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_DGLH_CNTf_SET
#define SCK_SROM_CTLr_SCK_SROM_OUT_FRCVALf_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_OUT_FRCVALf_GET
#define SCK_SROM_CTLr_SCK_SROM_OUT_FRCVALf_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_OUT_FRCVALf_SET
#define SCK_SROM_CTLr_SCK_SROM_INVERT_ENf_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INVERT_ENf_GET
#define SCK_SROM_CTLr_SCK_SROM_INVERT_ENf_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INVERT_ENf_SET
#define SCK_SROM_CTLr_SCK_SROM_IBOFf_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_IBOFf_GET
#define SCK_SROM_CTLr_SCK_SROM_IBOFf_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_IBOFf_SET
#define SCK_SROM_CTLr_SCK_SROM_SEL2f_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL2f_GET
#define SCK_SROM_CTLr_SCK_SROM_SEL2f_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL2f_SET
#define SCK_SROM_CTLr_SCK_SROM_SEL1f_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL1f_GET
#define SCK_SROM_CTLr_SCK_SROM_SEL1f_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL1f_SET
#define SCK_SROM_CTLr_SCK_SROM_SEL0f_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL0f_GET
#define SCK_SROM_CTLr_SCK_SROM_SEL0f_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_SEL0f_SET
#define SCK_SROM_CTLr_SCK_SROM_INDf_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INDf_GET
#define SCK_SROM_CTLr_SCK_SROM_INDf_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_INDf_SET
#define SCK_SROM_CTLr_SCK_SROM_PDNf_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PDNf_GET
#define SCK_SROM_CTLr_SCK_SROM_PDNf_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PDNf_SET
#define SCK_SROM_CTLr_SCK_SROM_PUPf_GET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PUPf_GET
#define SCK_SROM_CTLr_SCK_SROM_PUPf_SET BCMI_MADURA_SCK_SROM_CTLr_SCK_SROM_PUPf_SET
#define READ_SCK_SROM_CTLr BCMI_MADURA_READ_SCK_SROM_CTLr
#define WRITE_SCK_SROM_CTLr BCMI_MADURA_WRITE_SCK_SROM_CTLr
#define MODIFY_SCK_SROM_CTLr BCMI_MADURA_MODIFY_SCK_SROM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCK_SROM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SS_N_SROM_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a4c
 * DEVAD:    1
 * DESC:     PAD ss_n_srom control register
 * RESETVAL: 0x62 (98)
 * ACCESS:   R/W
 * FIELDS:
 *     SS_N_SROM_PUP    ss_n_srom pull-up
 *     SS_N_SROM_PDN    ss_n_srom pull down
 *     SS_N_SROM_IND    ss_n_srom ind
 *     SS_N_SROM_SEL0   ss_n_srom sel0
 *     SS_N_SROM_SEL1   ss_n_srom sel1
 *     SS_N_SROM_SEL2   ss_n_srom sel2
 *     SS_N_SROM_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     SS_N_SROM_INVERT_EN enable polarity invertion for pad input or output
 *     SS_N_SROM_OUT_FRCVAL the forced output value
 *     SS_N_SROM_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (ss_n_srom_ibof) is set to 0{ss_n_srom_ibof, ss_n_srom_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_SS_N_SROM_CTLr (0x00018a4c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SS_N_SROM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SS_N_SROM_CTL.
 */
typedef union BCMI_MADURA_SS_N_SROM_CTLr_s {
	uint32_t v[1];
	uint32_t ss_n_srom_ctl[1];
	uint32_t _ss_n_srom_ctl;
} BCMI_MADURA_SS_N_SROM_CTLr_t;

#define BCMI_MADURA_SS_N_SROM_CTLr_CLR(r) (r).ss_n_srom_ctl[0] = 0
#define BCMI_MADURA_SS_N_SROM_CTLr_SET(r,d) (r).ss_n_srom_ctl[0] = d
#define BCMI_MADURA_SS_N_SROM_CTLr_GET(r) (r).ss_n_srom_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_DGLH_CNTf_GET(r) ((((r).ss_n_srom_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_DGLH_CNTf_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_OUT_FRCVALf_GET(r) ((((r).ss_n_srom_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_OUT_FRCVALf_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INVERT_ENf_GET(r) ((((r).ss_n_srom_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INVERT_ENf_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_IBOFf_GET(r) ((((r).ss_n_srom_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_IBOFf_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL2f_GET(r) ((((r).ss_n_srom_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL2f_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL1f_GET(r) ((((r).ss_n_srom_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL1f_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL0f_GET(r) ((((r).ss_n_srom_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL0f_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INDf_GET(r) ((((r).ss_n_srom_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INDf_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PDNf_GET(r) ((((r).ss_n_srom_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PDNf_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PUPf_GET(r) ((((r).ss_n_srom_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PUPf_SET(r,f) (r).ss_n_srom_ctl[0]=(((r).ss_n_srom_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SS_N_SROM_CTL.
 */
#define BCMI_MADURA_READ_SS_N_SROM_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SS_N_SROM_CTLr,_r._ss_n_srom_ctl)
#define BCMI_MADURA_WRITE_SS_N_SROM_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SS_N_SROM_CTLr,_r._ss_n_srom_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SS_N_SROM_CTLr BCMI_MADURA_SS_N_SROM_CTLr
#define SS_N_SROM_CTLr_SIZE BCMI_MADURA_SS_N_SROM_CTLr_SIZE
typedef BCMI_MADURA_SS_N_SROM_CTLr_t SS_N_SROM_CTLr_t;
#define SS_N_SROM_CTLr_CLR BCMI_MADURA_SS_N_SROM_CTLr_CLR
#define SS_N_SROM_CTLr_SET BCMI_MADURA_SS_N_SROM_CTLr_SET
#define SS_N_SROM_CTLr_GET BCMI_MADURA_SS_N_SROM_CTLr_GET
#define SS_N_SROM_CTLr_SS_N_SROM_DGLH_CNTf_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_DGLH_CNTf_GET
#define SS_N_SROM_CTLr_SS_N_SROM_DGLH_CNTf_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_DGLH_CNTf_SET
#define SS_N_SROM_CTLr_SS_N_SROM_OUT_FRCVALf_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_OUT_FRCVALf_GET
#define SS_N_SROM_CTLr_SS_N_SROM_OUT_FRCVALf_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_OUT_FRCVALf_SET
#define SS_N_SROM_CTLr_SS_N_SROM_INVERT_ENf_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INVERT_ENf_GET
#define SS_N_SROM_CTLr_SS_N_SROM_INVERT_ENf_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INVERT_ENf_SET
#define SS_N_SROM_CTLr_SS_N_SROM_IBOFf_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_IBOFf_GET
#define SS_N_SROM_CTLr_SS_N_SROM_IBOFf_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_IBOFf_SET
#define SS_N_SROM_CTLr_SS_N_SROM_SEL2f_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL2f_GET
#define SS_N_SROM_CTLr_SS_N_SROM_SEL2f_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL2f_SET
#define SS_N_SROM_CTLr_SS_N_SROM_SEL1f_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL1f_GET
#define SS_N_SROM_CTLr_SS_N_SROM_SEL1f_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL1f_SET
#define SS_N_SROM_CTLr_SS_N_SROM_SEL0f_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL0f_GET
#define SS_N_SROM_CTLr_SS_N_SROM_SEL0f_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_SEL0f_SET
#define SS_N_SROM_CTLr_SS_N_SROM_INDf_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INDf_GET
#define SS_N_SROM_CTLr_SS_N_SROM_INDf_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_INDf_SET
#define SS_N_SROM_CTLr_SS_N_SROM_PDNf_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PDNf_GET
#define SS_N_SROM_CTLr_SS_N_SROM_PDNf_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PDNf_SET
#define SS_N_SROM_CTLr_SS_N_SROM_PUPf_GET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PUPf_GET
#define SS_N_SROM_CTLr_SS_N_SROM_PUPf_SET BCMI_MADURA_SS_N_SROM_CTLr_SS_N_SROM_PUPf_SET
#define READ_SS_N_SROM_CTLr BCMI_MADURA_READ_SS_N_SROM_CTLr
#define WRITE_SS_N_SROM_CTLr BCMI_MADURA_WRITE_SS_N_SROM_CTLr
#define MODIFY_SS_N_SROM_CTLr BCMI_MADURA_MODIFY_SS_N_SROM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SS_N_SROM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SERBOOT_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a4e
 * DEVAD:    1
 * DESC:     PAD serboot control register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     SERBOOT_PUP      serboot pull-up
 *     SERBOOT_PDN      serboot pull down
 *     SERBOOT_IND      serboot ind
 *     SERBOOT_IBOF     For input, this is deglitch bypassFor output, this is the output force enable
 *     SERBOOT_INVERT_EN enable polarity invertion for pad input or output
 *     SERBOOT_OUT_FRCVAL the forced output value
 *     SERBOOT_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (serboot_ibof) is set to 0{serboot_ibof, serboot_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_SERBOOT_CTLr (0x00018a4e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SERBOOT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SERBOOT_CTL.
 */
typedef union BCMI_MADURA_SERBOOT_CTLr_s {
	uint32_t v[1];
	uint32_t serboot_ctl[1];
	uint32_t _serboot_ctl;
} BCMI_MADURA_SERBOOT_CTLr_t;

#define BCMI_MADURA_SERBOOT_CTLr_CLR(r) (r).serboot_ctl[0] = 0
#define BCMI_MADURA_SERBOOT_CTLr_SET(r,d) (r).serboot_ctl[0] = d
#define BCMI_MADURA_SERBOOT_CTLr_GET(r) (r).serboot_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_DGLH_CNTf_GET(r) ((((r).serboot_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_DGLH_CNTf_SET(r,f) (r).serboot_ctl[0]=(((r).serboot_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_OUT_FRCVALf_GET(r) ((((r).serboot_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_OUT_FRCVALf_SET(r,f) (r).serboot_ctl[0]=(((r).serboot_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INVERT_ENf_GET(r) ((((r).serboot_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INVERT_ENf_SET(r,f) (r).serboot_ctl[0]=(((r).serboot_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_IBOFf_GET(r) ((((r).serboot_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_IBOFf_SET(r,f) (r).serboot_ctl[0]=(((r).serboot_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INDf_GET(r) ((((r).serboot_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INDf_SET(r,f) (r).serboot_ctl[0]=(((r).serboot_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PDNf_GET(r) ((((r).serboot_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PDNf_SET(r,f) (r).serboot_ctl[0]=(((r).serboot_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PUPf_GET(r) ((((r).serboot_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PUPf_SET(r,f) (r).serboot_ctl[0]=(((r).serboot_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access SERBOOT_CTL.
 */
#define BCMI_MADURA_READ_SERBOOT_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SERBOOT_CTLr,_r._serboot_ctl)
#define BCMI_MADURA_WRITE_SERBOOT_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SERBOOT_CTLr,_r._serboot_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERBOOT_CTLr BCMI_MADURA_SERBOOT_CTLr
#define SERBOOT_CTLr_SIZE BCMI_MADURA_SERBOOT_CTLr_SIZE
typedef BCMI_MADURA_SERBOOT_CTLr_t SERBOOT_CTLr_t;
#define SERBOOT_CTLr_CLR BCMI_MADURA_SERBOOT_CTLr_CLR
#define SERBOOT_CTLr_SET BCMI_MADURA_SERBOOT_CTLr_SET
#define SERBOOT_CTLr_GET BCMI_MADURA_SERBOOT_CTLr_GET
#define SERBOOT_CTLr_SERBOOT_DGLH_CNTf_GET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_DGLH_CNTf_GET
#define SERBOOT_CTLr_SERBOOT_DGLH_CNTf_SET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_DGLH_CNTf_SET
#define SERBOOT_CTLr_SERBOOT_OUT_FRCVALf_GET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_OUT_FRCVALf_GET
#define SERBOOT_CTLr_SERBOOT_OUT_FRCVALf_SET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_OUT_FRCVALf_SET
#define SERBOOT_CTLr_SERBOOT_INVERT_ENf_GET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INVERT_ENf_GET
#define SERBOOT_CTLr_SERBOOT_INVERT_ENf_SET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INVERT_ENf_SET
#define SERBOOT_CTLr_SERBOOT_IBOFf_GET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_IBOFf_GET
#define SERBOOT_CTLr_SERBOOT_IBOFf_SET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_IBOFf_SET
#define SERBOOT_CTLr_SERBOOT_INDf_GET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INDf_GET
#define SERBOOT_CTLr_SERBOOT_INDf_SET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_INDf_SET
#define SERBOOT_CTLr_SERBOOT_PDNf_GET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PDNf_GET
#define SERBOOT_CTLr_SERBOOT_PDNf_SET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PDNf_SET
#define SERBOOT_CTLr_SERBOOT_PUPf_GET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PUPf_GET
#define SERBOOT_CTLr_SERBOOT_PUPf_SET BCMI_MADURA_SERBOOT_CTLr_SERBOOT_PUPf_SET
#define READ_SERBOOT_CTLr BCMI_MADURA_READ_SERBOOT_CTLr
#define WRITE_SERBOOT_CTLr BCMI_MADURA_WRITE_SERBOOT_CTLr
#define MODIFY_SERBOOT_CTLr BCMI_MADURA_MODIFY_SERBOOT_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SERBOOT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SERBOOT_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a4f
 * DEVAD:    1
 * DESC:     PAD serboot status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERBOOT_DIN_LH   pad input latch highstatus
 *     SERBOOT_DIN_LL   pad input latch low status
 *     SERBOOT_DIN      live pad input value
 */
#define BCMI_MADURA_SERBOOT_STSr (0x00018a4f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SERBOOT_STSr_SIZE 4

/*
 * This structure should be used to declare and program SERBOOT_STS.
 */
typedef union BCMI_MADURA_SERBOOT_STSr_s {
	uint32_t v[1];
	uint32_t serboot_sts[1];
	uint32_t _serboot_sts;
} BCMI_MADURA_SERBOOT_STSr_t;

#define BCMI_MADURA_SERBOOT_STSr_CLR(r) (r).serboot_sts[0] = 0
#define BCMI_MADURA_SERBOOT_STSr_SET(r,d) (r).serboot_sts[0] = d
#define BCMI_MADURA_SERBOOT_STSr_GET(r) (r).serboot_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SERBOOT_STSr_SERBOOT_DINf_GET(r) ((((r).serboot_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_SERBOOT_STSr_SERBOOT_DINf_SET(r,f) (r).serboot_sts[0]=(((r).serboot_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LLf_GET(r) ((((r).serboot_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LLf_SET(r,f) (r).serboot_sts[0]=(((r).serboot_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LHf_GET(r) (((r).serboot_sts[0]) & 0x1)
#define BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LHf_SET(r,f) (r).serboot_sts[0]=(((r).serboot_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SERBOOT_STS.
 */
#define BCMI_MADURA_READ_SERBOOT_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SERBOOT_STSr,_r._serboot_sts)
#define BCMI_MADURA_WRITE_SERBOOT_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SERBOOT_STSr,_r._serboot_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERBOOT_STSr BCMI_MADURA_SERBOOT_STSr
#define SERBOOT_STSr_SIZE BCMI_MADURA_SERBOOT_STSr_SIZE
typedef BCMI_MADURA_SERBOOT_STSr_t SERBOOT_STSr_t;
#define SERBOOT_STSr_CLR BCMI_MADURA_SERBOOT_STSr_CLR
#define SERBOOT_STSr_SET BCMI_MADURA_SERBOOT_STSr_SET
#define SERBOOT_STSr_GET BCMI_MADURA_SERBOOT_STSr_GET
#define SERBOOT_STSr_SERBOOT_DINf_GET BCMI_MADURA_SERBOOT_STSr_SERBOOT_DINf_GET
#define SERBOOT_STSr_SERBOOT_DINf_SET BCMI_MADURA_SERBOOT_STSr_SERBOOT_DINf_SET
#define SERBOOT_STSr_SERBOOT_DIN_LLf_GET BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LLf_GET
#define SERBOOT_STSr_SERBOOT_DIN_LLf_SET BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LLf_SET
#define SERBOOT_STSr_SERBOOT_DIN_LHf_GET BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LHf_GET
#define SERBOOT_STSr_SERBOOT_DIN_LHf_SET BCMI_MADURA_SERBOOT_STSr_SERBOOT_DIN_LHf_SET
#define READ_SERBOOT_STSr BCMI_MADURA_READ_SERBOOT_STSr
#define WRITE_SERBOOT_STSr BCMI_MADURA_WRITE_SERBOOT_STSr
#define MODIFY_SERBOOT_STSr BCMI_MADURA_MODIFY_SERBOOT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SERBOOT_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EXT_UC_RSTB_OUT_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a50
 * DEVAD:    1
 * DESC:     PAD ext_uc_rstb_out control register
 * RESETVAL: 0x60 (96)
 * ACCESS:   R/W
 * FIELDS:
 *     EXT_UC_RSTB_OUT_OEB ext_uc_rstb_out output enable, active low
 *     EXT_UC_RSTB_OUT_PUP ext_uc_rstb_out pull-up
 *     EXT_UC_RSTB_OUT_PDN ext_uc_rstb_out pull down
 *     EXT_UC_RSTB_OUT_IND ext_uc_rstb_out ind
 *     EXT_UC_RSTB_OUT_SEL0 ext_uc_rstb_out sel0
 *     EXT_UC_RSTB_OUT_SEL1 ext_uc_rstb_out sel1
 *     EXT_UC_RSTB_OUT_SEL2 ext_uc_rstb_out sel2
 *     EXT_UC_RSTB_OUT_IBOF For input, this is deglitch bypassFor output, this is the output force enable
 *     EXT_UC_RSTB_OUT_INVERT_EN enable polarity invertion for pad input or output
 *     EXT_UC_RSTB_OUT_OUT_FRCVAL the forced output value
 *     EXT_UC_RSTB_OUT_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (ext_uc_rstb_out_ibof) is set to 0{ext_uc_rstb_out_ibof, ext_uc_rstb_out_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr (0x00018a50 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program EXT_UC_RSTB_OUT_CTL.
 */
typedef union BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_s {
	uint32_t v[1];
	uint32_t ext_uc_rstb_out_ctl[1];
	uint32_t _ext_uc_rstb_out_ctl;
} BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_t;

#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_CLR(r) (r).ext_uc_rstb_out_ctl[0] = 0
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_SET(r,d) (r).ext_uc_rstb_out_ctl[0] = d
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_GET(r) (r).ext_uc_rstb_out_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_DGLH_CNTf_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_DGLH_CNTf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OUT_FRCVALf_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OUT_FRCVALf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INVERT_ENf_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INVERT_ENf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_IBOFf_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_IBOFf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL2f_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL2f_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL1f_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL1f_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL0f_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL0f_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INDf_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INDf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PDNf_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PDNf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PUPf_GET(r) ((((r).ext_uc_rstb_out_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PUPf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OEBf_GET(r) (((r).ext_uc_rstb_out_ctl[0]) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OEBf_SET(r,f) (r).ext_uc_rstb_out_ctl[0]=(((r).ext_uc_rstb_out_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EXT_UC_RSTB_OUT_CTL.
 */
#define BCMI_MADURA_READ_EXT_UC_RSTB_OUT_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr,_r._ext_uc_rstb_out_ctl)
#define BCMI_MADURA_WRITE_EXT_UC_RSTB_OUT_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr,_r._ext_uc_rstb_out_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EXT_UC_RSTB_OUT_CTLr BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr
#define EXT_UC_RSTB_OUT_CTLr_SIZE BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_SIZE
typedef BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_t EXT_UC_RSTB_OUT_CTLr_t;
#define EXT_UC_RSTB_OUT_CTLr_CLR BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_CLR
#define EXT_UC_RSTB_OUT_CTLr_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_SET
#define EXT_UC_RSTB_OUT_CTLr_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_DGLH_CNTf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_DGLH_CNTf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_DGLH_CNTf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_DGLH_CNTf_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OUT_FRCVALf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OUT_FRCVALf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OUT_FRCVALf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OUT_FRCVALf_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INVERT_ENf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INVERT_ENf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INVERT_ENf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INVERT_ENf_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_IBOFf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_IBOFf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_IBOFf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_IBOFf_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL2f_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL2f_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL2f_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL2f_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL1f_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL1f_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL1f_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL1f_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL0f_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL0f_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL0f_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_SEL0f_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INDf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INDf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INDf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_INDf_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PDNf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PDNf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PDNf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PDNf_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PUPf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PUPf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PUPf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_PUPf_SET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OEBf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OEBf_GET
#define EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OEBf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr_EXT_UC_RSTB_OUT_OEBf_SET
#define READ_EXT_UC_RSTB_OUT_CTLr BCMI_MADURA_READ_EXT_UC_RSTB_OUT_CTLr
#define WRITE_EXT_UC_RSTB_OUT_CTLr BCMI_MADURA_WRITE_EXT_UC_RSTB_OUT_CTLr
#define MODIFY_EXT_UC_RSTB_OUT_CTLr BCMI_MADURA_MODIFY_EXT_UC_RSTB_OUT_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EXT_UC_RSTB_OUT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EXT_UC_RSTB_OUT_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a51
 * DEVAD:    1
 * DESC:     PAD ext_uc_rstb_out status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EXT_UC_RSTB_OUT_DIN_LH pad input latch highstatus
 *     EXT_UC_RSTB_OUT_DIN_LL pad input latch low status
 *     EXT_UC_RSTB_OUT_DIN live pad input value
 */
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr (0x00018a51 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_SIZE 4

/*
 * This structure should be used to declare and program EXT_UC_RSTB_OUT_STS.
 */
typedef union BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_s {
	uint32_t v[1];
	uint32_t ext_uc_rstb_out_sts[1];
	uint32_t _ext_uc_rstb_out_sts;
} BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_t;

#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_CLR(r) (r).ext_uc_rstb_out_sts[0] = 0
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_SET(r,d) (r).ext_uc_rstb_out_sts[0] = d
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_GET(r) (r).ext_uc_rstb_out_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DINf_GET(r) ((((r).ext_uc_rstb_out_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DINf_SET(r,f) (r).ext_uc_rstb_out_sts[0]=(((r).ext_uc_rstb_out_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LLf_GET(r) ((((r).ext_uc_rstb_out_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LLf_SET(r,f) (r).ext_uc_rstb_out_sts[0]=(((r).ext_uc_rstb_out_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LHf_GET(r) (((r).ext_uc_rstb_out_sts[0]) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LHf_SET(r,f) (r).ext_uc_rstb_out_sts[0]=(((r).ext_uc_rstb_out_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EXT_UC_RSTB_OUT_STS.
 */
#define BCMI_MADURA_READ_EXT_UC_RSTB_OUT_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EXT_UC_RSTB_OUT_STSr,_r._ext_uc_rstb_out_sts)
#define BCMI_MADURA_WRITE_EXT_UC_RSTB_OUT_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EXT_UC_RSTB_OUT_STSr,_r._ext_uc_rstb_out_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EXT_UC_RSTB_OUT_STSr BCMI_MADURA_EXT_UC_RSTB_OUT_STSr
#define EXT_UC_RSTB_OUT_STSr_SIZE BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_SIZE
typedef BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_t EXT_UC_RSTB_OUT_STSr_t;
#define EXT_UC_RSTB_OUT_STSr_CLR BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_CLR
#define EXT_UC_RSTB_OUT_STSr_SET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_SET
#define EXT_UC_RSTB_OUT_STSr_GET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_GET
#define EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DINf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DINf_GET
#define EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DINf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DINf_SET
#define EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LLf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LLf_GET
#define EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LLf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LLf_SET
#define EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LHf_GET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LHf_GET
#define EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LHf_SET BCMI_MADURA_EXT_UC_RSTB_OUT_STSr_EXT_UC_RSTB_OUT_DIN_LHf_SET
#define READ_EXT_UC_RSTB_OUT_STSr BCMI_MADURA_READ_EXT_UC_RSTB_OUT_STSr
#define WRITE_EXT_UC_RSTB_OUT_STSr BCMI_MADURA_WRITE_EXT_UC_RSTB_OUT_STSr
#define MODIFY_EXT_UC_RSTB_OUT_STSr BCMI_MADURA_MODIFY_EXT_UC_RSTB_OUT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EXT_UC_RSTB_OUT_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EXT_UC_RSTB_IN_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a52
 * DEVAD:    1
 * DESC:     PAD ext_uc_rstb_in control register
 * RESETVAL: 0x5 (5)
 * ACCESS:   R/W
 * FIELDS:
 *     EXT_UC_RSTB_IN_OEB ext_uc_rstb_in output enable, active low
 *     EXT_UC_RSTB_IN_PUP ext_uc_rstb_in pull-up
 *     EXT_UC_RSTB_IN_PDN ext_uc_rstb_in pull down
 *     EXT_UC_RSTB_IN_IND ext_uc_rstb_in ind
 *     EXT_UC_RSTB_IN_SEL0 ext_uc_rstb_in sel0
 *     EXT_UC_RSTB_IN_SEL1 ext_uc_rstb_in sel1
 *     EXT_UC_RSTB_IN_SEL2 ext_uc_rstb_in sel2
 *     EXT_UC_RSTB_IN_IBOF For input, this is deglitch bypassFor output, this is the output force enable
 *     EXT_UC_RSTB_IN_INVERT_EN enable polarity invertion for pad input or output
 *     EXT_UC_RSTB_IN_OUT_FRCVAL the forced output value
 *     EXT_UC_RSTB_IN_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (ext_uc_rstb_in_ibof) is set to 0{ext_uc_rstb_in_ibof, ext_uc_rstb_in_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr (0x00018a52 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program EXT_UC_RSTB_IN_CTL.
 */
typedef union BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_s {
	uint32_t v[1];
	uint32_t ext_uc_rstb_in_ctl[1];
	uint32_t _ext_uc_rstb_in_ctl;
} BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_t;

#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_CLR(r) (r).ext_uc_rstb_in_ctl[0] = 0
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_SET(r,d) (r).ext_uc_rstb_in_ctl[0] = d
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_GET(r) (r).ext_uc_rstb_in_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_DGLH_CNTf_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_DGLH_CNTf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OUT_FRCVALf_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OUT_FRCVALf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INVERT_ENf_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INVERT_ENf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_IBOFf_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_IBOFf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL2f_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL2f_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL1f_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL1f_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL0f_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL0f_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INDf_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INDf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PDNf_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PDNf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PUPf_GET(r) ((((r).ext_uc_rstb_in_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PUPf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OEBf_GET(r) (((r).ext_uc_rstb_in_ctl[0]) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OEBf_SET(r,f) (r).ext_uc_rstb_in_ctl[0]=(((r).ext_uc_rstb_in_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EXT_UC_RSTB_IN_CTL.
 */
#define BCMI_MADURA_READ_EXT_UC_RSTB_IN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EXT_UC_RSTB_IN_CTLr,_r._ext_uc_rstb_in_ctl)
#define BCMI_MADURA_WRITE_EXT_UC_RSTB_IN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EXT_UC_RSTB_IN_CTLr,_r._ext_uc_rstb_in_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EXT_UC_RSTB_IN_CTLr BCMI_MADURA_EXT_UC_RSTB_IN_CTLr
#define EXT_UC_RSTB_IN_CTLr_SIZE BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_SIZE
typedef BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_t EXT_UC_RSTB_IN_CTLr_t;
#define EXT_UC_RSTB_IN_CTLr_CLR BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_CLR
#define EXT_UC_RSTB_IN_CTLr_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_SET
#define EXT_UC_RSTB_IN_CTLr_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_DGLH_CNTf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_DGLH_CNTf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_DGLH_CNTf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_DGLH_CNTf_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OUT_FRCVALf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OUT_FRCVALf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OUT_FRCVALf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OUT_FRCVALf_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INVERT_ENf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INVERT_ENf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INVERT_ENf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INVERT_ENf_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_IBOFf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_IBOFf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_IBOFf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_IBOFf_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL2f_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL2f_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL2f_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL2f_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL1f_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL1f_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL1f_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL1f_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL0f_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL0f_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL0f_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_SEL0f_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INDf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INDf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INDf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_INDf_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PDNf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PDNf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PDNf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PDNf_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PUPf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PUPf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PUPf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_PUPf_SET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OEBf_GET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OEBf_GET
#define EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OEBf_SET BCMI_MADURA_EXT_UC_RSTB_IN_CTLr_EXT_UC_RSTB_IN_OEBf_SET
#define READ_EXT_UC_RSTB_IN_CTLr BCMI_MADURA_READ_EXT_UC_RSTB_IN_CTLr
#define WRITE_EXT_UC_RSTB_IN_CTLr BCMI_MADURA_WRITE_EXT_UC_RSTB_IN_CTLr
#define MODIFY_EXT_UC_RSTB_IN_CTLr BCMI_MADURA_MODIFY_EXT_UC_RSTB_IN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EXT_UC_RSTB_IN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EXT_UC_RSTB_IN_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a53
 * DEVAD:    1
 * DESC:     PAD ext_uc_rstb_in status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EXT_UC_RSTB_IN_DIN_LH pad input latch highstatus
 *     EXT_UC_RSTB_IN_DIN_LL pad input latch low status
 *     EXT_UC_RSTB_IN_DIN live pad input value
 */
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr (0x00018a53 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_SIZE 4

/*
 * This structure should be used to declare and program EXT_UC_RSTB_IN_STS.
 */
typedef union BCMI_MADURA_EXT_UC_RSTB_IN_STSr_s {
	uint32_t v[1];
	uint32_t ext_uc_rstb_in_sts[1];
	uint32_t _ext_uc_rstb_in_sts;
} BCMI_MADURA_EXT_UC_RSTB_IN_STSr_t;

#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_CLR(r) (r).ext_uc_rstb_in_sts[0] = 0
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_SET(r,d) (r).ext_uc_rstb_in_sts[0] = d
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_GET(r) (r).ext_uc_rstb_in_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DINf_GET(r) ((((r).ext_uc_rstb_in_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DINf_SET(r,f) (r).ext_uc_rstb_in_sts[0]=(((r).ext_uc_rstb_in_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LLf_GET(r) ((((r).ext_uc_rstb_in_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LLf_SET(r,f) (r).ext_uc_rstb_in_sts[0]=(((r).ext_uc_rstb_in_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LHf_GET(r) (((r).ext_uc_rstb_in_sts[0]) & 0x1)
#define BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LHf_SET(r,f) (r).ext_uc_rstb_in_sts[0]=(((r).ext_uc_rstb_in_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EXT_UC_RSTB_IN_STS.
 */
#define BCMI_MADURA_READ_EXT_UC_RSTB_IN_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EXT_UC_RSTB_IN_STSr,_r._ext_uc_rstb_in_sts)
#define BCMI_MADURA_WRITE_EXT_UC_RSTB_IN_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EXT_UC_RSTB_IN_STSr,_r._ext_uc_rstb_in_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EXT_UC_RSTB_IN_STSr BCMI_MADURA_EXT_UC_RSTB_IN_STSr
#define EXT_UC_RSTB_IN_STSr_SIZE BCMI_MADURA_EXT_UC_RSTB_IN_STSr_SIZE
typedef BCMI_MADURA_EXT_UC_RSTB_IN_STSr_t EXT_UC_RSTB_IN_STSr_t;
#define EXT_UC_RSTB_IN_STSr_CLR BCMI_MADURA_EXT_UC_RSTB_IN_STSr_CLR
#define EXT_UC_RSTB_IN_STSr_SET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_SET
#define EXT_UC_RSTB_IN_STSr_GET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_GET
#define EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DINf_GET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DINf_GET
#define EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DINf_SET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DINf_SET
#define EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LLf_GET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LLf_GET
#define EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LLf_SET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LLf_SET
#define EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LHf_GET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LHf_GET
#define EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LHf_SET BCMI_MADURA_EXT_UC_RSTB_IN_STSr_EXT_UC_RSTB_IN_DIN_LHf_SET
#define READ_EXT_UC_RSTB_IN_STSr BCMI_MADURA_READ_EXT_UC_RSTB_IN_STSr
#define WRITE_EXT_UC_RSTB_IN_STSr BCMI_MADURA_WRITE_EXT_UC_RSTB_IN_STSr
#define MODIFY_EXT_UC_RSTB_IN_STSr BCMI_MADURA_MODIFY_EXT_UC_RSTB_IN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EXT_UC_RSTB_IN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_LOPWR_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a54
 * DEVAD:    1
 * DESC:     PAD mod_lopwr control register
 * RESETVAL: 0x60 (96)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_LOPWR_OEB    mod_lopwr output enable, active low
 *     MOD_LOPWR_PUP    mod_lopwr pull-up
 *     MOD_LOPWR_PDN    mod_lopwr pull down
 *     MOD_LOPWR_IND    mod_lopwr ind
 *     MOD_LOPWR_SEL0   mod_lopwr sel0
 *     MOD_LOPWR_SEL1   mod_lopwr sel1
 *     MOD_LOPWR_SEL2   mod_lopwr sel2
 *     MOD_LOPWR_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     MOD_LOPWR_INVERT_EN enable polarity invertion for pad input or output
 *     MOD_LOPWR_OUT_FRCVAL the forced output value
 *     MOD_LOPWR_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mod_lopwr_ibof) is set to 0{mod_lopwr_ibof, mod_lopwr_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MOD_LOPWR_CTLr (0x00018a54 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_LOPWR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MOD_LOPWR_CTL.
 */
typedef union BCMI_MADURA_MOD_LOPWR_CTLr_s {
	uint32_t v[1];
	uint32_t mod_lopwr_ctl[1];
	uint32_t _mod_lopwr_ctl;
} BCMI_MADURA_MOD_LOPWR_CTLr_t;

#define BCMI_MADURA_MOD_LOPWR_CTLr_CLR(r) (r).mod_lopwr_ctl[0] = 0
#define BCMI_MADURA_MOD_LOPWR_CTLr_SET(r,d) (r).mod_lopwr_ctl[0] = d
#define BCMI_MADURA_MOD_LOPWR_CTLr_GET(r) (r).mod_lopwr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_DGLH_CNTf_GET(r) ((((r).mod_lopwr_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_DGLH_CNTf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OUT_FRCVALf_GET(r) ((((r).mod_lopwr_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OUT_FRCVALf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INVERT_ENf_GET(r) ((((r).mod_lopwr_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INVERT_ENf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_IBOFf_GET(r) ((((r).mod_lopwr_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_IBOFf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL2f_GET(r) ((((r).mod_lopwr_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL2f_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL1f_GET(r) ((((r).mod_lopwr_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL1f_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL0f_GET(r) ((((r).mod_lopwr_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL0f_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INDf_GET(r) ((((r).mod_lopwr_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INDf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PDNf_GET(r) ((((r).mod_lopwr_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PDNf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PUPf_GET(r) ((((r).mod_lopwr_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PUPf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OEBf_GET(r) (((r).mod_lopwr_ctl[0]) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OEBf_SET(r,f) (r).mod_lopwr_ctl[0]=(((r).mod_lopwr_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_LOPWR_CTL.
 */
#define BCMI_MADURA_READ_MOD_LOPWR_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_LOPWR_CTLr,_r._mod_lopwr_ctl)
#define BCMI_MADURA_WRITE_MOD_LOPWR_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_LOPWR_CTLr,_r._mod_lopwr_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_LOPWR_CTLr BCMI_MADURA_MOD_LOPWR_CTLr
#define MOD_LOPWR_CTLr_SIZE BCMI_MADURA_MOD_LOPWR_CTLr_SIZE
typedef BCMI_MADURA_MOD_LOPWR_CTLr_t MOD_LOPWR_CTLr_t;
#define MOD_LOPWR_CTLr_CLR BCMI_MADURA_MOD_LOPWR_CTLr_CLR
#define MOD_LOPWR_CTLr_SET BCMI_MADURA_MOD_LOPWR_CTLr_SET
#define MOD_LOPWR_CTLr_GET BCMI_MADURA_MOD_LOPWR_CTLr_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_DGLH_CNTf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_DGLH_CNTf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_DGLH_CNTf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_DGLH_CNTf_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_OUT_FRCVALf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OUT_FRCVALf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_OUT_FRCVALf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OUT_FRCVALf_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_INVERT_ENf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INVERT_ENf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_INVERT_ENf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INVERT_ENf_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_IBOFf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_IBOFf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_IBOFf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_IBOFf_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_SEL2f_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL2f_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_SEL2f_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL2f_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_SEL1f_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL1f_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_SEL1f_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL1f_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_SEL0f_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL0f_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_SEL0f_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_SEL0f_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_INDf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INDf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_INDf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_INDf_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_PDNf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PDNf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_PDNf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PDNf_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_PUPf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PUPf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_PUPf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_PUPf_SET
#define MOD_LOPWR_CTLr_MOD_LOPWR_OEBf_GET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OEBf_GET
#define MOD_LOPWR_CTLr_MOD_LOPWR_OEBf_SET BCMI_MADURA_MOD_LOPWR_CTLr_MOD_LOPWR_OEBf_SET
#define READ_MOD_LOPWR_CTLr BCMI_MADURA_READ_MOD_LOPWR_CTLr
#define WRITE_MOD_LOPWR_CTLr BCMI_MADURA_WRITE_MOD_LOPWR_CTLr
#define MODIFY_MOD_LOPWR_CTLr BCMI_MADURA_MODIFY_MOD_LOPWR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_LOPWR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_LOPWR_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a55
 * DEVAD:    1
 * DESC:     PAD mod_lopwr status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_LOPWR_DIN_LH pad input latch highstatus
 *     MOD_LOPWR_DIN_LL pad input latch low status
 *     MOD_LOPWR_DIN    live pad input value
 */
#define BCMI_MADURA_MOD_LOPWR_STSr (0x00018a55 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_LOPWR_STSr_SIZE 4

/*
 * This structure should be used to declare and program MOD_LOPWR_STS.
 */
typedef union BCMI_MADURA_MOD_LOPWR_STSr_s {
	uint32_t v[1];
	uint32_t mod_lopwr_sts[1];
	uint32_t _mod_lopwr_sts;
} BCMI_MADURA_MOD_LOPWR_STSr_t;

#define BCMI_MADURA_MOD_LOPWR_STSr_CLR(r) (r).mod_lopwr_sts[0] = 0
#define BCMI_MADURA_MOD_LOPWR_STSr_SET(r,d) (r).mod_lopwr_sts[0] = d
#define BCMI_MADURA_MOD_LOPWR_STSr_GET(r) (r).mod_lopwr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DINf_GET(r) ((((r).mod_lopwr_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DINf_SET(r,f) (r).mod_lopwr_sts[0]=(((r).mod_lopwr_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LLf_GET(r) ((((r).mod_lopwr_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LLf_SET(r,f) (r).mod_lopwr_sts[0]=(((r).mod_lopwr_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LHf_GET(r) (((r).mod_lopwr_sts[0]) & 0x1)
#define BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LHf_SET(r,f) (r).mod_lopwr_sts[0]=(((r).mod_lopwr_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_LOPWR_STS.
 */
#define BCMI_MADURA_READ_MOD_LOPWR_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_LOPWR_STSr,_r._mod_lopwr_sts)
#define BCMI_MADURA_WRITE_MOD_LOPWR_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_LOPWR_STSr,_r._mod_lopwr_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_LOPWR_STSr BCMI_MADURA_MOD_LOPWR_STSr
#define MOD_LOPWR_STSr_SIZE BCMI_MADURA_MOD_LOPWR_STSr_SIZE
typedef BCMI_MADURA_MOD_LOPWR_STSr_t MOD_LOPWR_STSr_t;
#define MOD_LOPWR_STSr_CLR BCMI_MADURA_MOD_LOPWR_STSr_CLR
#define MOD_LOPWR_STSr_SET BCMI_MADURA_MOD_LOPWR_STSr_SET
#define MOD_LOPWR_STSr_GET BCMI_MADURA_MOD_LOPWR_STSr_GET
#define MOD_LOPWR_STSr_MOD_LOPWR_DINf_GET BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DINf_GET
#define MOD_LOPWR_STSr_MOD_LOPWR_DINf_SET BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DINf_SET
#define MOD_LOPWR_STSr_MOD_LOPWR_DIN_LLf_GET BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LLf_GET
#define MOD_LOPWR_STSr_MOD_LOPWR_DIN_LLf_SET BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LLf_SET
#define MOD_LOPWR_STSr_MOD_LOPWR_DIN_LHf_GET BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LHf_GET
#define MOD_LOPWR_STSr_MOD_LOPWR_DIN_LHf_SET BCMI_MADURA_MOD_LOPWR_STSr_MOD_LOPWR_DIN_LHf_SET
#define READ_MOD_LOPWR_STSr BCMI_MADURA_READ_MOD_LOPWR_STSr
#define WRITE_MOD_LOPWR_STSr BCMI_MADURA_WRITE_MOD_LOPWR_STSr
#define MODIFY_MOD_LOPWR_STSr BCMI_MADURA_MODIFY_MOD_LOPWR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_LOPWR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_ABS_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a56
 * DEVAD:    1
 * DESC:     PAD mod_abs control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_ABS_PUP      mod_abs pull-up
 *     MOD_ABS_PDN      mod_abs pull down
 *     MOD_ABS_IND      mod_abs ind
 *     MOD_ABS_IBOF     For input, this is deglitch bypassFor output, this is the output force enable
 *     MOD_ABS_INVERT_EN enable polarity invertion for pad input or output
 *     MOD_ABS_OUT_FRCVAL the forced output value
 *     MOD_ABS_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mod_abs_ibof) is set to 0{mod_abs_ibof, mod_abs_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MOD_ABS_CTLr (0x00018a56 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_ABS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MOD_ABS_CTL.
 */
typedef union BCMI_MADURA_MOD_ABS_CTLr_s {
	uint32_t v[1];
	uint32_t mod_abs_ctl[1];
	uint32_t _mod_abs_ctl;
} BCMI_MADURA_MOD_ABS_CTLr_t;

#define BCMI_MADURA_MOD_ABS_CTLr_CLR(r) (r).mod_abs_ctl[0] = 0
#define BCMI_MADURA_MOD_ABS_CTLr_SET(r,d) (r).mod_abs_ctl[0] = d
#define BCMI_MADURA_MOD_ABS_CTLr_GET(r) (r).mod_abs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_DGLH_CNTf_GET(r) ((((r).mod_abs_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_DGLH_CNTf_SET(r,f) (r).mod_abs_ctl[0]=(((r).mod_abs_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_OUT_FRCVALf_GET(r) ((((r).mod_abs_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_OUT_FRCVALf_SET(r,f) (r).mod_abs_ctl[0]=(((r).mod_abs_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INVERT_ENf_GET(r) ((((r).mod_abs_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INVERT_ENf_SET(r,f) (r).mod_abs_ctl[0]=(((r).mod_abs_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_IBOFf_GET(r) ((((r).mod_abs_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_IBOFf_SET(r,f) (r).mod_abs_ctl[0]=(((r).mod_abs_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INDf_GET(r) ((((r).mod_abs_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INDf_SET(r,f) (r).mod_abs_ctl[0]=(((r).mod_abs_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PDNf_GET(r) ((((r).mod_abs_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PDNf_SET(r,f) (r).mod_abs_ctl[0]=(((r).mod_abs_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PUPf_GET(r) ((((r).mod_abs_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PUPf_SET(r,f) (r).mod_abs_ctl[0]=(((r).mod_abs_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access MOD_ABS_CTL.
 */
#define BCMI_MADURA_READ_MOD_ABS_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_ABS_CTLr,_r._mod_abs_ctl)
#define BCMI_MADURA_WRITE_MOD_ABS_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_ABS_CTLr,_r._mod_abs_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_ABS_CTLr BCMI_MADURA_MOD_ABS_CTLr
#define MOD_ABS_CTLr_SIZE BCMI_MADURA_MOD_ABS_CTLr_SIZE
typedef BCMI_MADURA_MOD_ABS_CTLr_t MOD_ABS_CTLr_t;
#define MOD_ABS_CTLr_CLR BCMI_MADURA_MOD_ABS_CTLr_CLR
#define MOD_ABS_CTLr_SET BCMI_MADURA_MOD_ABS_CTLr_SET
#define MOD_ABS_CTLr_GET BCMI_MADURA_MOD_ABS_CTLr_GET
#define MOD_ABS_CTLr_MOD_ABS_DGLH_CNTf_GET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_DGLH_CNTf_GET
#define MOD_ABS_CTLr_MOD_ABS_DGLH_CNTf_SET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_DGLH_CNTf_SET
#define MOD_ABS_CTLr_MOD_ABS_OUT_FRCVALf_GET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_OUT_FRCVALf_GET
#define MOD_ABS_CTLr_MOD_ABS_OUT_FRCVALf_SET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_OUT_FRCVALf_SET
#define MOD_ABS_CTLr_MOD_ABS_INVERT_ENf_GET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INVERT_ENf_GET
#define MOD_ABS_CTLr_MOD_ABS_INVERT_ENf_SET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INVERT_ENf_SET
#define MOD_ABS_CTLr_MOD_ABS_IBOFf_GET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_IBOFf_GET
#define MOD_ABS_CTLr_MOD_ABS_IBOFf_SET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_IBOFf_SET
#define MOD_ABS_CTLr_MOD_ABS_INDf_GET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INDf_GET
#define MOD_ABS_CTLr_MOD_ABS_INDf_SET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_INDf_SET
#define MOD_ABS_CTLr_MOD_ABS_PDNf_GET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PDNf_GET
#define MOD_ABS_CTLr_MOD_ABS_PDNf_SET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PDNf_SET
#define MOD_ABS_CTLr_MOD_ABS_PUPf_GET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PUPf_GET
#define MOD_ABS_CTLr_MOD_ABS_PUPf_SET BCMI_MADURA_MOD_ABS_CTLr_MOD_ABS_PUPf_SET
#define READ_MOD_ABS_CTLr BCMI_MADURA_READ_MOD_ABS_CTLr
#define WRITE_MOD_ABS_CTLr BCMI_MADURA_WRITE_MOD_ABS_CTLr
#define MODIFY_MOD_ABS_CTLr BCMI_MADURA_MODIFY_MOD_ABS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_ABS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_ABS_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a57
 * DEVAD:    1
 * DESC:     PAD mod_abs status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_ABS_DIN_LH   pad input latch highstatus
 *     MOD_ABS_DIN_LL   pad input latch low status
 *     MOD_ABS_DIN      live pad input value
 */
#define BCMI_MADURA_MOD_ABS_STSr (0x00018a57 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_ABS_STSr_SIZE 4

/*
 * This structure should be used to declare and program MOD_ABS_STS.
 */
typedef union BCMI_MADURA_MOD_ABS_STSr_s {
	uint32_t v[1];
	uint32_t mod_abs_sts[1];
	uint32_t _mod_abs_sts;
} BCMI_MADURA_MOD_ABS_STSr_t;

#define BCMI_MADURA_MOD_ABS_STSr_CLR(r) (r).mod_abs_sts[0] = 0
#define BCMI_MADURA_MOD_ABS_STSr_SET(r,d) (r).mod_abs_sts[0] = d
#define BCMI_MADURA_MOD_ABS_STSr_GET(r) (r).mod_abs_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DINf_GET(r) ((((r).mod_abs_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DINf_SET(r,f) (r).mod_abs_sts[0]=(((r).mod_abs_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LLf_GET(r) ((((r).mod_abs_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LLf_SET(r,f) (r).mod_abs_sts[0]=(((r).mod_abs_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LHf_GET(r) (((r).mod_abs_sts[0]) & 0x1)
#define BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LHf_SET(r,f) (r).mod_abs_sts[0]=(((r).mod_abs_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_ABS_STS.
 */
#define BCMI_MADURA_READ_MOD_ABS_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_ABS_STSr,_r._mod_abs_sts)
#define BCMI_MADURA_WRITE_MOD_ABS_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_ABS_STSr,_r._mod_abs_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_ABS_STSr BCMI_MADURA_MOD_ABS_STSr
#define MOD_ABS_STSr_SIZE BCMI_MADURA_MOD_ABS_STSr_SIZE
typedef BCMI_MADURA_MOD_ABS_STSr_t MOD_ABS_STSr_t;
#define MOD_ABS_STSr_CLR BCMI_MADURA_MOD_ABS_STSr_CLR
#define MOD_ABS_STSr_SET BCMI_MADURA_MOD_ABS_STSr_SET
#define MOD_ABS_STSr_GET BCMI_MADURA_MOD_ABS_STSr_GET
#define MOD_ABS_STSr_MOD_ABS_DINf_GET BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DINf_GET
#define MOD_ABS_STSr_MOD_ABS_DINf_SET BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DINf_SET
#define MOD_ABS_STSr_MOD_ABS_DIN_LLf_GET BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LLf_GET
#define MOD_ABS_STSr_MOD_ABS_DIN_LLf_SET BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LLf_SET
#define MOD_ABS_STSr_MOD_ABS_DIN_LHf_GET BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LHf_GET
#define MOD_ABS_STSr_MOD_ABS_DIN_LHf_SET BCMI_MADURA_MOD_ABS_STSr_MOD_ABS_DIN_LHf_SET
#define READ_MOD_ABS_STSr BCMI_MADURA_READ_MOD_ABS_STSr
#define WRITE_MOD_ABS_STSr BCMI_MADURA_WRITE_MOD_ABS_STSr
#define MODIFY_MOD_ABS_STSr BCMI_MADURA_MODIFY_MOD_ABS_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_ABS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_RSTN_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a58
 * DEVAD:    1
 * DESC:     PAD mod_rstn control register
 * RESETVAL: 0x60 (96)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_RSTN_OEB     mod_rstn output enable, active low
 *     MOD_RSTN_PUP     mod_rstn pull-up
 *     MOD_RSTN_PDN     mod_rstn pull down
 *     MOD_RSTN_IND     mod_rstn ind
 *     MOD_RSTN_SEL0    mod_rstn sel0
 *     MOD_RSTN_SEL1    mod_rstn sel1
 *     MOD_RSTN_SEL2    mod_rstn sel2
 *     MOD_RSTN_IBOF    For input, this is deglitch bypassFor output, this is the output force enable
 *     MOD_RSTN_INVERT_EN enable polarity invertion for pad input or output
 *     MOD_RSTN_OUT_FRCVAL the forced output value
 *     MOD_RSTN_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mod_rstn_ibof) is set to 0{mod_rstn_ibof, mod_rstn_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MOD_RSTN_CTLr (0x00018a58 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_RSTN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MOD_RSTN_CTL.
 */
typedef union BCMI_MADURA_MOD_RSTN_CTLr_s {
	uint32_t v[1];
	uint32_t mod_rstn_ctl[1];
	uint32_t _mod_rstn_ctl;
} BCMI_MADURA_MOD_RSTN_CTLr_t;

#define BCMI_MADURA_MOD_RSTN_CTLr_CLR(r) (r).mod_rstn_ctl[0] = 0
#define BCMI_MADURA_MOD_RSTN_CTLr_SET(r,d) (r).mod_rstn_ctl[0] = d
#define BCMI_MADURA_MOD_RSTN_CTLr_GET(r) (r).mod_rstn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_DGLH_CNTf_GET(r) ((((r).mod_rstn_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_DGLH_CNTf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OUT_FRCVALf_GET(r) ((((r).mod_rstn_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OUT_FRCVALf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INVERT_ENf_GET(r) ((((r).mod_rstn_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INVERT_ENf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_IBOFf_GET(r) ((((r).mod_rstn_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_IBOFf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL2f_GET(r) ((((r).mod_rstn_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL2f_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL1f_GET(r) ((((r).mod_rstn_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL1f_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL0f_GET(r) ((((r).mod_rstn_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL0f_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INDf_GET(r) ((((r).mod_rstn_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INDf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PDNf_GET(r) ((((r).mod_rstn_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PDNf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PUPf_GET(r) ((((r).mod_rstn_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PUPf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OEBf_GET(r) (((r).mod_rstn_ctl[0]) & 0x1)
#define BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OEBf_SET(r,f) (r).mod_rstn_ctl[0]=(((r).mod_rstn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_RSTN_CTL.
 */
#define BCMI_MADURA_READ_MOD_RSTN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_RSTN_CTLr,_r._mod_rstn_ctl)
#define BCMI_MADURA_WRITE_MOD_RSTN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_RSTN_CTLr,_r._mod_rstn_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_RSTN_CTLr BCMI_MADURA_MOD_RSTN_CTLr
#define MOD_RSTN_CTLr_SIZE BCMI_MADURA_MOD_RSTN_CTLr_SIZE
typedef BCMI_MADURA_MOD_RSTN_CTLr_t MOD_RSTN_CTLr_t;
#define MOD_RSTN_CTLr_CLR BCMI_MADURA_MOD_RSTN_CTLr_CLR
#define MOD_RSTN_CTLr_SET BCMI_MADURA_MOD_RSTN_CTLr_SET
#define MOD_RSTN_CTLr_GET BCMI_MADURA_MOD_RSTN_CTLr_GET
#define MOD_RSTN_CTLr_MOD_RSTN_DGLH_CNTf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_DGLH_CNTf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_DGLH_CNTf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_DGLH_CNTf_SET
#define MOD_RSTN_CTLr_MOD_RSTN_OUT_FRCVALf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OUT_FRCVALf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_OUT_FRCVALf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OUT_FRCVALf_SET
#define MOD_RSTN_CTLr_MOD_RSTN_INVERT_ENf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INVERT_ENf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_INVERT_ENf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INVERT_ENf_SET
#define MOD_RSTN_CTLr_MOD_RSTN_IBOFf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_IBOFf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_IBOFf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_IBOFf_SET
#define MOD_RSTN_CTLr_MOD_RSTN_SEL2f_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL2f_GET
#define MOD_RSTN_CTLr_MOD_RSTN_SEL2f_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL2f_SET
#define MOD_RSTN_CTLr_MOD_RSTN_SEL1f_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL1f_GET
#define MOD_RSTN_CTLr_MOD_RSTN_SEL1f_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL1f_SET
#define MOD_RSTN_CTLr_MOD_RSTN_SEL0f_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL0f_GET
#define MOD_RSTN_CTLr_MOD_RSTN_SEL0f_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_SEL0f_SET
#define MOD_RSTN_CTLr_MOD_RSTN_INDf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INDf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_INDf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_INDf_SET
#define MOD_RSTN_CTLr_MOD_RSTN_PDNf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PDNf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_PDNf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PDNf_SET
#define MOD_RSTN_CTLr_MOD_RSTN_PUPf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PUPf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_PUPf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_PUPf_SET
#define MOD_RSTN_CTLr_MOD_RSTN_OEBf_GET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OEBf_GET
#define MOD_RSTN_CTLr_MOD_RSTN_OEBf_SET BCMI_MADURA_MOD_RSTN_CTLr_MOD_RSTN_OEBf_SET
#define READ_MOD_RSTN_CTLr BCMI_MADURA_READ_MOD_RSTN_CTLr
#define WRITE_MOD_RSTN_CTLr BCMI_MADURA_WRITE_MOD_RSTN_CTLr
#define MODIFY_MOD_RSTN_CTLr BCMI_MADURA_MODIFY_MOD_RSTN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_RSTN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_RSTN_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a59
 * DEVAD:    1
 * DESC:     PAD mod_rstn status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_RSTN_DIN_LH  pad input latch highstatus
 *     MOD_RSTN_DIN_LL  pad input latch low status
 *     MOD_RSTN_DIN     live pad input value
 */
#define BCMI_MADURA_MOD_RSTN_STSr (0x00018a59 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_RSTN_STSr_SIZE 4

/*
 * This structure should be used to declare and program MOD_RSTN_STS.
 */
typedef union BCMI_MADURA_MOD_RSTN_STSr_s {
	uint32_t v[1];
	uint32_t mod_rstn_sts[1];
	uint32_t _mod_rstn_sts;
} BCMI_MADURA_MOD_RSTN_STSr_t;

#define BCMI_MADURA_MOD_RSTN_STSr_CLR(r) (r).mod_rstn_sts[0] = 0
#define BCMI_MADURA_MOD_RSTN_STSr_SET(r,d) (r).mod_rstn_sts[0] = d
#define BCMI_MADURA_MOD_RSTN_STSr_GET(r) (r).mod_rstn_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DINf_GET(r) ((((r).mod_rstn_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DINf_SET(r,f) (r).mod_rstn_sts[0]=(((r).mod_rstn_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LLf_GET(r) ((((r).mod_rstn_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LLf_SET(r,f) (r).mod_rstn_sts[0]=(((r).mod_rstn_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LHf_GET(r) (((r).mod_rstn_sts[0]) & 0x1)
#define BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LHf_SET(r,f) (r).mod_rstn_sts[0]=(((r).mod_rstn_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_RSTN_STS.
 */
#define BCMI_MADURA_READ_MOD_RSTN_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_RSTN_STSr,_r._mod_rstn_sts)
#define BCMI_MADURA_WRITE_MOD_RSTN_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_RSTN_STSr,_r._mod_rstn_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_RSTN_STSr BCMI_MADURA_MOD_RSTN_STSr
#define MOD_RSTN_STSr_SIZE BCMI_MADURA_MOD_RSTN_STSr_SIZE
typedef BCMI_MADURA_MOD_RSTN_STSr_t MOD_RSTN_STSr_t;
#define MOD_RSTN_STSr_CLR BCMI_MADURA_MOD_RSTN_STSr_CLR
#define MOD_RSTN_STSr_SET BCMI_MADURA_MOD_RSTN_STSr_SET
#define MOD_RSTN_STSr_GET BCMI_MADURA_MOD_RSTN_STSr_GET
#define MOD_RSTN_STSr_MOD_RSTN_DINf_GET BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DINf_GET
#define MOD_RSTN_STSr_MOD_RSTN_DINf_SET BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DINf_SET
#define MOD_RSTN_STSr_MOD_RSTN_DIN_LLf_GET BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LLf_GET
#define MOD_RSTN_STSr_MOD_RSTN_DIN_LLf_SET BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LLf_SET
#define MOD_RSTN_STSr_MOD_RSTN_DIN_LHf_GET BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LHf_GET
#define MOD_RSTN_STSr_MOD_RSTN_DIN_LHf_SET BCMI_MADURA_MOD_RSTN_STSr_MOD_RSTN_DIN_LHf_SET
#define READ_MOD_RSTN_STSr BCMI_MADURA_READ_MOD_RSTN_STSr
#define WRITE_MOD_RSTN_STSr BCMI_MADURA_WRITE_MOD_RSTN_STSr
#define MODIFY_MOD_RSTN_STSr BCMI_MADURA_MODIFY_MOD_RSTN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_RSTN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_INTRN_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a5a
 * DEVAD:    1
 * DESC:     PAD mod_intrn control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_INTRN_PUP    mod_intrn pull-up
 *     MOD_INTRN_PDN    mod_intrn pull down
 *     MOD_INTRN_IND    mod_intrn ind
 *     MOD_INTRN_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     MOD_INTRN_INVERT_EN enable polarity invertion for pad input or output
 *     MOD_INTRN_OUT_FRCVAL the forced output value
 *     MOD_INTRN_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mod_intrn_ibof) is set to 0{mod_intrn_ibof, mod_intrn_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MOD_INTRN_CTLr (0x00018a5a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_INTRN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MOD_INTRN_CTL.
 */
typedef union BCMI_MADURA_MOD_INTRN_CTLr_s {
	uint32_t v[1];
	uint32_t mod_intrn_ctl[1];
	uint32_t _mod_intrn_ctl;
} BCMI_MADURA_MOD_INTRN_CTLr_t;

#define BCMI_MADURA_MOD_INTRN_CTLr_CLR(r) (r).mod_intrn_ctl[0] = 0
#define BCMI_MADURA_MOD_INTRN_CTLr_SET(r,d) (r).mod_intrn_ctl[0] = d
#define BCMI_MADURA_MOD_INTRN_CTLr_GET(r) (r).mod_intrn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_DGLH_CNTf_GET(r) ((((r).mod_intrn_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_DGLH_CNTf_SET(r,f) (r).mod_intrn_ctl[0]=(((r).mod_intrn_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_OUT_FRCVALf_GET(r) ((((r).mod_intrn_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_OUT_FRCVALf_SET(r,f) (r).mod_intrn_ctl[0]=(((r).mod_intrn_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INVERT_ENf_GET(r) ((((r).mod_intrn_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INVERT_ENf_SET(r,f) (r).mod_intrn_ctl[0]=(((r).mod_intrn_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_IBOFf_GET(r) ((((r).mod_intrn_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_IBOFf_SET(r,f) (r).mod_intrn_ctl[0]=(((r).mod_intrn_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INDf_GET(r) ((((r).mod_intrn_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INDf_SET(r,f) (r).mod_intrn_ctl[0]=(((r).mod_intrn_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PDNf_GET(r) ((((r).mod_intrn_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PDNf_SET(r,f) (r).mod_intrn_ctl[0]=(((r).mod_intrn_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PUPf_GET(r) ((((r).mod_intrn_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PUPf_SET(r,f) (r).mod_intrn_ctl[0]=(((r).mod_intrn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access MOD_INTRN_CTL.
 */
#define BCMI_MADURA_READ_MOD_INTRN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_INTRN_CTLr,_r._mod_intrn_ctl)
#define BCMI_MADURA_WRITE_MOD_INTRN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_INTRN_CTLr,_r._mod_intrn_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_INTRN_CTLr BCMI_MADURA_MOD_INTRN_CTLr
#define MOD_INTRN_CTLr_SIZE BCMI_MADURA_MOD_INTRN_CTLr_SIZE
typedef BCMI_MADURA_MOD_INTRN_CTLr_t MOD_INTRN_CTLr_t;
#define MOD_INTRN_CTLr_CLR BCMI_MADURA_MOD_INTRN_CTLr_CLR
#define MOD_INTRN_CTLr_SET BCMI_MADURA_MOD_INTRN_CTLr_SET
#define MOD_INTRN_CTLr_GET BCMI_MADURA_MOD_INTRN_CTLr_GET
#define MOD_INTRN_CTLr_MOD_INTRN_DGLH_CNTf_GET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_DGLH_CNTf_GET
#define MOD_INTRN_CTLr_MOD_INTRN_DGLH_CNTf_SET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_DGLH_CNTf_SET
#define MOD_INTRN_CTLr_MOD_INTRN_OUT_FRCVALf_GET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_OUT_FRCVALf_GET
#define MOD_INTRN_CTLr_MOD_INTRN_OUT_FRCVALf_SET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_OUT_FRCVALf_SET
#define MOD_INTRN_CTLr_MOD_INTRN_INVERT_ENf_GET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INVERT_ENf_GET
#define MOD_INTRN_CTLr_MOD_INTRN_INVERT_ENf_SET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INVERT_ENf_SET
#define MOD_INTRN_CTLr_MOD_INTRN_IBOFf_GET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_IBOFf_GET
#define MOD_INTRN_CTLr_MOD_INTRN_IBOFf_SET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_IBOFf_SET
#define MOD_INTRN_CTLr_MOD_INTRN_INDf_GET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INDf_GET
#define MOD_INTRN_CTLr_MOD_INTRN_INDf_SET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_INDf_SET
#define MOD_INTRN_CTLr_MOD_INTRN_PDNf_GET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PDNf_GET
#define MOD_INTRN_CTLr_MOD_INTRN_PDNf_SET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PDNf_SET
#define MOD_INTRN_CTLr_MOD_INTRN_PUPf_GET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PUPf_GET
#define MOD_INTRN_CTLr_MOD_INTRN_PUPf_SET BCMI_MADURA_MOD_INTRN_CTLr_MOD_INTRN_PUPf_SET
#define READ_MOD_INTRN_CTLr BCMI_MADURA_READ_MOD_INTRN_CTLr
#define WRITE_MOD_INTRN_CTLr BCMI_MADURA_WRITE_MOD_INTRN_CTLr
#define MODIFY_MOD_INTRN_CTLr BCMI_MADURA_MODIFY_MOD_INTRN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_INTRN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_INTRN_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a5b
 * DEVAD:    1
 * DESC:     PAD mod_intrn status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_INTRN_DIN_LH pad input latch highstatus
 *     MOD_INTRN_DIN_LL pad input latch low status
 *     MOD_INTRN_DIN    live pad input value
 */
#define BCMI_MADURA_MOD_INTRN_STSr (0x00018a5b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_INTRN_STSr_SIZE 4

/*
 * This structure should be used to declare and program MOD_INTRN_STS.
 */
typedef union BCMI_MADURA_MOD_INTRN_STSr_s {
	uint32_t v[1];
	uint32_t mod_intrn_sts[1];
	uint32_t _mod_intrn_sts;
} BCMI_MADURA_MOD_INTRN_STSr_t;

#define BCMI_MADURA_MOD_INTRN_STSr_CLR(r) (r).mod_intrn_sts[0] = 0
#define BCMI_MADURA_MOD_INTRN_STSr_SET(r,d) (r).mod_intrn_sts[0] = d
#define BCMI_MADURA_MOD_INTRN_STSr_GET(r) (r).mod_intrn_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DINf_GET(r) ((((r).mod_intrn_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DINf_SET(r,f) (r).mod_intrn_sts[0]=(((r).mod_intrn_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LLf_GET(r) ((((r).mod_intrn_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LLf_SET(r,f) (r).mod_intrn_sts[0]=(((r).mod_intrn_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LHf_GET(r) (((r).mod_intrn_sts[0]) & 0x1)
#define BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LHf_SET(r,f) (r).mod_intrn_sts[0]=(((r).mod_intrn_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_INTRN_STS.
 */
#define BCMI_MADURA_READ_MOD_INTRN_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_INTRN_STSr,_r._mod_intrn_sts)
#define BCMI_MADURA_WRITE_MOD_INTRN_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_INTRN_STSr,_r._mod_intrn_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_INTRN_STSr BCMI_MADURA_MOD_INTRN_STSr
#define MOD_INTRN_STSr_SIZE BCMI_MADURA_MOD_INTRN_STSr_SIZE
typedef BCMI_MADURA_MOD_INTRN_STSr_t MOD_INTRN_STSr_t;
#define MOD_INTRN_STSr_CLR BCMI_MADURA_MOD_INTRN_STSr_CLR
#define MOD_INTRN_STSr_SET BCMI_MADURA_MOD_INTRN_STSr_SET
#define MOD_INTRN_STSr_GET BCMI_MADURA_MOD_INTRN_STSr_GET
#define MOD_INTRN_STSr_MOD_INTRN_DINf_GET BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DINf_GET
#define MOD_INTRN_STSr_MOD_INTRN_DINf_SET BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DINf_SET
#define MOD_INTRN_STSr_MOD_INTRN_DIN_LLf_GET BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LLf_GET
#define MOD_INTRN_STSr_MOD_INTRN_DIN_LLf_SET BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LLf_SET
#define MOD_INTRN_STSr_MOD_INTRN_DIN_LHf_GET BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LHf_GET
#define MOD_INTRN_STSr_MOD_INTRN_DIN_LHf_SET BCMI_MADURA_MOD_INTRN_STSr_MOD_INTRN_DIN_LHf_SET
#define READ_MOD_INTRN_STSr BCMI_MADURA_READ_MOD_INTRN_STSr
#define WRITE_MOD_INTRN_STSr BCMI_MADURA_WRITE_MOD_INTRN_STSr
#define MODIFY_MOD_INTRN_STSr BCMI_MADURA_MODIFY_MOD_INTRN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_INTRN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_TX_DIS_LOPWR2_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a5c
 * DEVAD:    1
 * DESC:     PAD mod_tx_dis_lopwr2 control register
 * RESETVAL: 0x60 (96)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_TX_DIS_LOPWR2_OEB mod_tx_dis_lopwr2 output enable, active low
 *     MOD_TX_DIS_LOPWR2_PUP mod_tx_dis_lopwr2 pull-up
 *     MOD_TX_DIS_LOPWR2_PDN mod_tx_dis_lopwr2 pull down
 *     MOD_TX_DIS_LOPWR2_IND mod_tx_dis_lopwr2 ind
 *     MOD_TX_DIS_LOPWR2_SEL0 mod_tx_dis_lopwr2 sel0
 *     MOD_TX_DIS_LOPWR2_SEL1 mod_tx_dis_lopwr2 sel1
 *     MOD_TX_DIS_LOPWR2_SEL2 mod_tx_dis_lopwr2 sel2
 *     MOD_TX_DIS_LOPWR2_IBOF For input, this is deglitch bypassFor output, this is the output force enable
 *     MOD_TX_DIS_LOPWR2_INVERT_EN enable polarity invertion for pad input or output
 *     MOD_TX_DIS_LOPWR2_OUT_FRCVAL the forced output value
 *     MOD_TX_DIS_LOPWR2_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mod_tx_dis_lopwr2_ibof) is set to 0{mod_tx_dis_lopwr2_ibof, mod_tx_dis_lopwr2_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr (0x00018a5c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MOD_TX_DIS_LOPWR2_CTL.
 */
typedef union BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_s {
	uint32_t v[1];
	uint32_t mod_tx_dis_lopwr2_ctl[1];
	uint32_t _mod_tx_dis_lopwr2_ctl;
} BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_t;

#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_CLR(r) (r).mod_tx_dis_lopwr2_ctl[0] = 0
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_SET(r,d) (r).mod_tx_dis_lopwr2_ctl[0] = d
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_GET(r) (r).mod_tx_dis_lopwr2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_DGLH_CNTf_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_DGLH_CNTf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OUT_FRCVALf_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OUT_FRCVALf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INVERT_ENf_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INVERT_ENf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_IBOFf_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_IBOFf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL2f_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL2f_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL1f_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL1f_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL0f_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL0f_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INDf_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INDf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PDNf_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PDNf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PUPf_GET(r) ((((r).mod_tx_dis_lopwr2_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PUPf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OEBf_GET(r) (((r).mod_tx_dis_lopwr2_ctl[0]) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OEBf_SET(r,f) (r).mod_tx_dis_lopwr2_ctl[0]=(((r).mod_tx_dis_lopwr2_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_TX_DIS_LOPWR2_CTL.
 */
#define BCMI_MADURA_READ_MOD_TX_DIS_LOPWR2_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr,_r._mod_tx_dis_lopwr2_ctl)
#define BCMI_MADURA_WRITE_MOD_TX_DIS_LOPWR2_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr,_r._mod_tx_dis_lopwr2_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_TX_DIS_LOPWR2_CTLr BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr
#define MOD_TX_DIS_LOPWR2_CTLr_SIZE BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_SIZE
typedef BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_t MOD_TX_DIS_LOPWR2_CTLr_t;
#define MOD_TX_DIS_LOPWR2_CTLr_CLR BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_CLR
#define MOD_TX_DIS_LOPWR2_CTLr_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_SET
#define MOD_TX_DIS_LOPWR2_CTLr_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_DGLH_CNTf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_DGLH_CNTf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_DGLH_CNTf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_DGLH_CNTf_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OUT_FRCVALf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OUT_FRCVALf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OUT_FRCVALf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OUT_FRCVALf_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INVERT_ENf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INVERT_ENf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INVERT_ENf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INVERT_ENf_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_IBOFf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_IBOFf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_IBOFf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_IBOFf_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL2f_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL2f_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL2f_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL2f_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL1f_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL1f_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL1f_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL1f_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL0f_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL0f_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL0f_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_SEL0f_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INDf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INDf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INDf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_INDf_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PDNf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PDNf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PDNf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PDNf_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PUPf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PUPf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PUPf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_PUPf_SET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OEBf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OEBf_GET
#define MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OEBf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr_MOD_TX_DIS_LOPWR2_OEBf_SET
#define READ_MOD_TX_DIS_LOPWR2_CTLr BCMI_MADURA_READ_MOD_TX_DIS_LOPWR2_CTLr
#define WRITE_MOD_TX_DIS_LOPWR2_CTLr BCMI_MADURA_WRITE_MOD_TX_DIS_LOPWR2_CTLr
#define MODIFY_MOD_TX_DIS_LOPWR2_CTLr BCMI_MADURA_MODIFY_MOD_TX_DIS_LOPWR2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_TX_DIS_LOPWR2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_TX_DIS_LOPWR2_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a5d
 * DEVAD:    1
 * DESC:     PAD mod_tx_dis_lopwr2 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_TX_DIS_LOPWR2_DIN_LH pad input latch highstatus
 *     MOD_TX_DIS_LOPWR2_DIN_LL pad input latch low status
 *     MOD_TX_DIS_LOPWR2_DIN live pad input value
 */
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr (0x00018a5d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_SIZE 4

/*
 * This structure should be used to declare and program MOD_TX_DIS_LOPWR2_STS.
 */
typedef union BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_s {
	uint32_t v[1];
	uint32_t mod_tx_dis_lopwr2_sts[1];
	uint32_t _mod_tx_dis_lopwr2_sts;
} BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_t;

#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_CLR(r) (r).mod_tx_dis_lopwr2_sts[0] = 0
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_SET(r,d) (r).mod_tx_dis_lopwr2_sts[0] = d
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_GET(r) (r).mod_tx_dis_lopwr2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DINf_GET(r) ((((r).mod_tx_dis_lopwr2_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DINf_SET(r,f) (r).mod_tx_dis_lopwr2_sts[0]=(((r).mod_tx_dis_lopwr2_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LLf_GET(r) ((((r).mod_tx_dis_lopwr2_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LLf_SET(r,f) (r).mod_tx_dis_lopwr2_sts[0]=(((r).mod_tx_dis_lopwr2_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LHf_GET(r) (((r).mod_tx_dis_lopwr2_sts[0]) & 0x1)
#define BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LHf_SET(r,f) (r).mod_tx_dis_lopwr2_sts[0]=(((r).mod_tx_dis_lopwr2_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_TX_DIS_LOPWR2_STS.
 */
#define BCMI_MADURA_READ_MOD_TX_DIS_LOPWR2_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr,_r._mod_tx_dis_lopwr2_sts)
#define BCMI_MADURA_WRITE_MOD_TX_DIS_LOPWR2_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr,_r._mod_tx_dis_lopwr2_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_TX_DIS_LOPWR2_STSr BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr
#define MOD_TX_DIS_LOPWR2_STSr_SIZE BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_SIZE
typedef BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_t MOD_TX_DIS_LOPWR2_STSr_t;
#define MOD_TX_DIS_LOPWR2_STSr_CLR BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_CLR
#define MOD_TX_DIS_LOPWR2_STSr_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_SET
#define MOD_TX_DIS_LOPWR2_STSr_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_GET
#define MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DINf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DINf_GET
#define MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DINf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DINf_SET
#define MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LLf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LLf_GET
#define MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LLf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LLf_SET
#define MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LHf_GET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LHf_GET
#define MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LHf_SET BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr_MOD_TX_DIS_LOPWR2_DIN_LHf_SET
#define READ_MOD_TX_DIS_LOPWR2_STSr BCMI_MADURA_READ_MOD_TX_DIS_LOPWR2_STSr
#define WRITE_MOD_TX_DIS_LOPWR2_STSr BCMI_MADURA_WRITE_MOD_TX_DIS_LOPWR2_STSr
#define MODIFY_MOD_TX_DIS_LOPWR2_STSr BCMI_MADURA_MODIFY_MOD_TX_DIS_LOPWR2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_TX_DIS_LOPWR2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_RX_LOS_ABS2_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a5e
 * DEVAD:    1
 * DESC:     PAD mod_rx_los_abs2 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_RX_LOS_ABS2_PUP mod_rx_los_abs2 pull-up
 *     MOD_RX_LOS_ABS2_PDN mod_rx_los_abs2 pull down
 *     MOD_RX_LOS_ABS2_IND mod_rx_los_abs2 ind
 *     MOD_RX_LOS_ABS2_IBOF For input, this is deglitch bypassFor output, this is the output force enable
 *     MOD_RX_LOS_ABS2_INVERT_EN enable polarity invertion for pad input or output
 *     MOD_RX_LOS_ABS2_OUT_FRCVAL the forced output value
 *     MOD_RX_LOS_ABS2_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mod_rx_los_abs2_ibof) is set to 0{mod_rx_los_abs2_ibof, mod_rx_los_abs2_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr (0x00018a5e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MOD_RX_LOS_ABS2_CTL.
 */
typedef union BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_s {
	uint32_t v[1];
	uint32_t mod_rx_los_abs2_ctl[1];
	uint32_t _mod_rx_los_abs2_ctl;
} BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_t;

#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_CLR(r) (r).mod_rx_los_abs2_ctl[0] = 0
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_SET(r,d) (r).mod_rx_los_abs2_ctl[0] = d
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_GET(r) (r).mod_rx_los_abs2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_DGLH_CNTf_GET(r) ((((r).mod_rx_los_abs2_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_DGLH_CNTf_SET(r,f) (r).mod_rx_los_abs2_ctl[0]=(((r).mod_rx_los_abs2_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_OUT_FRCVALf_GET(r) ((((r).mod_rx_los_abs2_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_OUT_FRCVALf_SET(r,f) (r).mod_rx_los_abs2_ctl[0]=(((r).mod_rx_los_abs2_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INVERT_ENf_GET(r) ((((r).mod_rx_los_abs2_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INVERT_ENf_SET(r,f) (r).mod_rx_los_abs2_ctl[0]=(((r).mod_rx_los_abs2_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_IBOFf_GET(r) ((((r).mod_rx_los_abs2_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_IBOFf_SET(r,f) (r).mod_rx_los_abs2_ctl[0]=(((r).mod_rx_los_abs2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INDf_GET(r) ((((r).mod_rx_los_abs2_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INDf_SET(r,f) (r).mod_rx_los_abs2_ctl[0]=(((r).mod_rx_los_abs2_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PDNf_GET(r) ((((r).mod_rx_los_abs2_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PDNf_SET(r,f) (r).mod_rx_los_abs2_ctl[0]=(((r).mod_rx_los_abs2_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PUPf_GET(r) ((((r).mod_rx_los_abs2_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PUPf_SET(r,f) (r).mod_rx_los_abs2_ctl[0]=(((r).mod_rx_los_abs2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access MOD_RX_LOS_ABS2_CTL.
 */
#define BCMI_MADURA_READ_MOD_RX_LOS_ABS2_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr,_r._mod_rx_los_abs2_ctl)
#define BCMI_MADURA_WRITE_MOD_RX_LOS_ABS2_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr,_r._mod_rx_los_abs2_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_RX_LOS_ABS2_CTLr BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr
#define MOD_RX_LOS_ABS2_CTLr_SIZE BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_SIZE
typedef BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_t MOD_RX_LOS_ABS2_CTLr_t;
#define MOD_RX_LOS_ABS2_CTLr_CLR BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_CLR
#define MOD_RX_LOS_ABS2_CTLr_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_SET
#define MOD_RX_LOS_ABS2_CTLr_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_DGLH_CNTf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_DGLH_CNTf_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_DGLH_CNTf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_DGLH_CNTf_SET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_OUT_FRCVALf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_OUT_FRCVALf_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_OUT_FRCVALf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_OUT_FRCVALf_SET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INVERT_ENf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INVERT_ENf_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INVERT_ENf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INVERT_ENf_SET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_IBOFf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_IBOFf_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_IBOFf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_IBOFf_SET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INDf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INDf_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INDf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_INDf_SET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PDNf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PDNf_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PDNf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PDNf_SET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PUPf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PUPf_GET
#define MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PUPf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr_MOD_RX_LOS_ABS2_PUPf_SET
#define READ_MOD_RX_LOS_ABS2_CTLr BCMI_MADURA_READ_MOD_RX_LOS_ABS2_CTLr
#define WRITE_MOD_RX_LOS_ABS2_CTLr BCMI_MADURA_WRITE_MOD_RX_LOS_ABS2_CTLr
#define MODIFY_MOD_RX_LOS_ABS2_CTLr BCMI_MADURA_MODIFY_MOD_RX_LOS_ABS2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_RX_LOS_ABS2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MOD_RX_LOS_ABS2_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a5f
 * DEVAD:    1
 * DESC:     PAD mod_rx_los_abs2 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MOD_RX_LOS_ABS2_DIN_LH pad input latch highstatus
 *     MOD_RX_LOS_ABS2_DIN_LL pad input latch low status
 *     MOD_RX_LOS_ABS2_DIN live pad input value
 */
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr (0x00018a5f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_SIZE 4

/*
 * This structure should be used to declare and program MOD_RX_LOS_ABS2_STS.
 */
typedef union BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_s {
	uint32_t v[1];
	uint32_t mod_rx_los_abs2_sts[1];
	uint32_t _mod_rx_los_abs2_sts;
} BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_t;

#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_CLR(r) (r).mod_rx_los_abs2_sts[0] = 0
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_SET(r,d) (r).mod_rx_los_abs2_sts[0] = d
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_GET(r) (r).mod_rx_los_abs2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DINf_GET(r) ((((r).mod_rx_los_abs2_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DINf_SET(r,f) (r).mod_rx_los_abs2_sts[0]=(((r).mod_rx_los_abs2_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LLf_GET(r) ((((r).mod_rx_los_abs2_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LLf_SET(r,f) (r).mod_rx_los_abs2_sts[0]=(((r).mod_rx_los_abs2_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LHf_GET(r) (((r).mod_rx_los_abs2_sts[0]) & 0x1)
#define BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LHf_SET(r,f) (r).mod_rx_los_abs2_sts[0]=(((r).mod_rx_los_abs2_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MOD_RX_LOS_ABS2_STS.
 */
#define BCMI_MADURA_READ_MOD_RX_LOS_ABS2_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MOD_RX_LOS_ABS2_STSr,_r._mod_rx_los_abs2_sts)
#define BCMI_MADURA_WRITE_MOD_RX_LOS_ABS2_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MOD_RX_LOS_ABS2_STSr,_r._mod_rx_los_abs2_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MOD_RX_LOS_ABS2_STSr BCMI_MADURA_MOD_RX_LOS_ABS2_STSr
#define MOD_RX_LOS_ABS2_STSr_SIZE BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_SIZE
typedef BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_t MOD_RX_LOS_ABS2_STSr_t;
#define MOD_RX_LOS_ABS2_STSr_CLR BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_CLR
#define MOD_RX_LOS_ABS2_STSr_SET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_SET
#define MOD_RX_LOS_ABS2_STSr_GET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_GET
#define MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DINf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DINf_GET
#define MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DINf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DINf_SET
#define MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LLf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LLf_GET
#define MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LLf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LLf_SET
#define MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LHf_GET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LHf_GET
#define MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LHf_SET BCMI_MADURA_MOD_RX_LOS_ABS2_STSr_MOD_RX_LOS_ABS2_DIN_LHf_SET
#define READ_MOD_RX_LOS_ABS2_STSr BCMI_MADURA_READ_MOD_RX_LOS_ABS2_STSr
#define WRITE_MOD_RX_LOS_ABS2_STSr BCMI_MADURA_WRITE_MOD_RX_LOS_ABS2_STSr
#define MODIFY_MOD_RX_LOS_ABS2_STSr BCMI_MADURA_MODIFY_MOD_RX_LOS_ABS2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MOD_RX_LOS_ABS2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_0_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a60
 * DEVAD:    1
 * DESC:     PAD gpio_0 control register
 * RESETVAL: 0xe3 (227)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_0_OEB       gpio_0 output enable, active low
 *     GPIO_0_PUP       gpio_0 pull-up
 *     GPIO_0_PDN       gpio_0 pull down
 *     GPIO_0_IND       gpio_0 ind
 *     GPIO_0_SEL0      gpio_0 sel0
 *     GPIO_0_SEL1      gpio_0 sel1
 *     GPIO_0_SEL2      gpio_0 sel2
 *     GPIO_0_IBOF      For input, this is deglitch bypassFor output, this is the output force enable
 *     GPIO_0_INVERT_EN enable polarity invertion for pad input or output
 *     GPIO_0_OUT_FRCVAL the forced output value
 *     GPIO_0_DGLH_CNT  the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (gpio_0_ibof) is set to 0{gpio_0_ibof, gpio_0_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_GPIO_0_CTLr (0x00018a60 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_0_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_0_CTL.
 */
typedef union BCMI_MADURA_GPIO_0_CTLr_s {
	uint32_t v[1];
	uint32_t gpio_0_ctl[1];
	uint32_t _gpio_0_ctl;
} BCMI_MADURA_GPIO_0_CTLr_t;

#define BCMI_MADURA_GPIO_0_CTLr_CLR(r) (r).gpio_0_ctl[0] = 0
#define BCMI_MADURA_GPIO_0_CTLr_SET(r,d) (r).gpio_0_ctl[0] = d
#define BCMI_MADURA_GPIO_0_CTLr_GET(r) (r).gpio_0_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_DGLH_CNTf_GET(r) ((((r).gpio_0_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_DGLH_CNTf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OUT_FRCVALf_GET(r) ((((r).gpio_0_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OUT_FRCVALf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INVERT_ENf_GET(r) ((((r).gpio_0_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INVERT_ENf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_IBOFf_GET(r) ((((r).gpio_0_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_IBOFf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL2f_GET(r) ((((r).gpio_0_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL2f_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL1f_GET(r) ((((r).gpio_0_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL1f_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL0f_GET(r) ((((r).gpio_0_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL0f_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INDf_GET(r) ((((r).gpio_0_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INDf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PDNf_GET(r) ((((r).gpio_0_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PDNf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PUPf_GET(r) ((((r).gpio_0_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PUPf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OEBf_GET(r) (((r).gpio_0_ctl[0]) & 0x1)
#define BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OEBf_SET(r,f) (r).gpio_0_ctl[0]=(((r).gpio_0_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_0_CTL.
 */
#define BCMI_MADURA_READ_GPIO_0_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_0_CTLr,_r._gpio_0_ctl)
#define BCMI_MADURA_WRITE_GPIO_0_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_0_CTLr,_r._gpio_0_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_0_CTLr BCMI_MADURA_GPIO_0_CTLr
#define GPIO_0_CTLr_SIZE BCMI_MADURA_GPIO_0_CTLr_SIZE
typedef BCMI_MADURA_GPIO_0_CTLr_t GPIO_0_CTLr_t;
#define GPIO_0_CTLr_CLR BCMI_MADURA_GPIO_0_CTLr_CLR
#define GPIO_0_CTLr_SET BCMI_MADURA_GPIO_0_CTLr_SET
#define GPIO_0_CTLr_GET BCMI_MADURA_GPIO_0_CTLr_GET
#define GPIO_0_CTLr_GPIO_0_DGLH_CNTf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_DGLH_CNTf_GET
#define GPIO_0_CTLr_GPIO_0_DGLH_CNTf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_DGLH_CNTf_SET
#define GPIO_0_CTLr_GPIO_0_OUT_FRCVALf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OUT_FRCVALf_GET
#define GPIO_0_CTLr_GPIO_0_OUT_FRCVALf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OUT_FRCVALf_SET
#define GPIO_0_CTLr_GPIO_0_INVERT_ENf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INVERT_ENf_GET
#define GPIO_0_CTLr_GPIO_0_INVERT_ENf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INVERT_ENf_SET
#define GPIO_0_CTLr_GPIO_0_IBOFf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_IBOFf_GET
#define GPIO_0_CTLr_GPIO_0_IBOFf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_IBOFf_SET
#define GPIO_0_CTLr_GPIO_0_SEL2f_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL2f_GET
#define GPIO_0_CTLr_GPIO_0_SEL2f_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL2f_SET
#define GPIO_0_CTLr_GPIO_0_SEL1f_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL1f_GET
#define GPIO_0_CTLr_GPIO_0_SEL1f_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL1f_SET
#define GPIO_0_CTLr_GPIO_0_SEL0f_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL0f_GET
#define GPIO_0_CTLr_GPIO_0_SEL0f_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_SEL0f_SET
#define GPIO_0_CTLr_GPIO_0_INDf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INDf_GET
#define GPIO_0_CTLr_GPIO_0_INDf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_INDf_SET
#define GPIO_0_CTLr_GPIO_0_PDNf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PDNf_GET
#define GPIO_0_CTLr_GPIO_0_PDNf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PDNf_SET
#define GPIO_0_CTLr_GPIO_0_PUPf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PUPf_GET
#define GPIO_0_CTLr_GPIO_0_PUPf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_PUPf_SET
#define GPIO_0_CTLr_GPIO_0_OEBf_GET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OEBf_GET
#define GPIO_0_CTLr_GPIO_0_OEBf_SET BCMI_MADURA_GPIO_0_CTLr_GPIO_0_OEBf_SET
#define READ_GPIO_0_CTLr BCMI_MADURA_READ_GPIO_0_CTLr
#define WRITE_GPIO_0_CTLr BCMI_MADURA_WRITE_GPIO_0_CTLr
#define MODIFY_GPIO_0_CTLr BCMI_MADURA_MODIFY_GPIO_0_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_0_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_0_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a61
 * DEVAD:    1
 * DESC:     PAD gpio_0 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_0_DIN_LH    pad input latch highstatus
 *     GPIO_0_DIN_LL    pad input latch low status
 *     GPIO_0_DIN       live pad input value
 */
#define BCMI_MADURA_GPIO_0_STSr (0x00018a61 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_0_STSr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_0_STS.
 */
typedef union BCMI_MADURA_GPIO_0_STSr_s {
	uint32_t v[1];
	uint32_t gpio_0_sts[1];
	uint32_t _gpio_0_sts;
} BCMI_MADURA_GPIO_0_STSr_t;

#define BCMI_MADURA_GPIO_0_STSr_CLR(r) (r).gpio_0_sts[0] = 0
#define BCMI_MADURA_GPIO_0_STSr_SET(r,d) (r).gpio_0_sts[0] = d
#define BCMI_MADURA_GPIO_0_STSr_GET(r) (r).gpio_0_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_0_STSr_GPIO_0_DINf_GET(r) ((((r).gpio_0_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_0_STSr_GPIO_0_DINf_SET(r,f) (r).gpio_0_sts[0]=(((r).gpio_0_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LLf_GET(r) ((((r).gpio_0_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LLf_SET(r,f) (r).gpio_0_sts[0]=(((r).gpio_0_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LHf_GET(r) (((r).gpio_0_sts[0]) & 0x1)
#define BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LHf_SET(r,f) (r).gpio_0_sts[0]=(((r).gpio_0_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_0_STS.
 */
#define BCMI_MADURA_READ_GPIO_0_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_0_STSr,_r._gpio_0_sts)
#define BCMI_MADURA_WRITE_GPIO_0_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_0_STSr,_r._gpio_0_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_0_STSr BCMI_MADURA_GPIO_0_STSr
#define GPIO_0_STSr_SIZE BCMI_MADURA_GPIO_0_STSr_SIZE
typedef BCMI_MADURA_GPIO_0_STSr_t GPIO_0_STSr_t;
#define GPIO_0_STSr_CLR BCMI_MADURA_GPIO_0_STSr_CLR
#define GPIO_0_STSr_SET BCMI_MADURA_GPIO_0_STSr_SET
#define GPIO_0_STSr_GET BCMI_MADURA_GPIO_0_STSr_GET
#define GPIO_0_STSr_GPIO_0_DINf_GET BCMI_MADURA_GPIO_0_STSr_GPIO_0_DINf_GET
#define GPIO_0_STSr_GPIO_0_DINf_SET BCMI_MADURA_GPIO_0_STSr_GPIO_0_DINf_SET
#define GPIO_0_STSr_GPIO_0_DIN_LLf_GET BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LLf_GET
#define GPIO_0_STSr_GPIO_0_DIN_LLf_SET BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LLf_SET
#define GPIO_0_STSr_GPIO_0_DIN_LHf_GET BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LHf_GET
#define GPIO_0_STSr_GPIO_0_DIN_LHf_SET BCMI_MADURA_GPIO_0_STSr_GPIO_0_DIN_LHf_SET
#define READ_GPIO_0_STSr BCMI_MADURA_READ_GPIO_0_STSr
#define WRITE_GPIO_0_STSr BCMI_MADURA_WRITE_GPIO_0_STSr
#define MODIFY_GPIO_0_STSr BCMI_MADURA_MODIFY_GPIO_0_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_0_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_1_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a62
 * DEVAD:    1
 * DESC:     PAD gpio_1 control register
 * RESETVAL: 0xe3 (227)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_1_OEB       gpio_1 output enable, active low
 *     GPIO_1_PUP       gpio_1 pull-up
 *     GPIO_1_PDN       gpio_1 pull down
 *     GPIO_1_IND       gpio_1 ind
 *     GPIO_1_SEL0      gpio_1 sel0
 *     GPIO_1_SEL1      gpio_1 sel1
 *     GPIO_1_SEL2      gpio_1 sel2
 *     GPIO_1_IBOF      For input, this is deglitch bypassFor output, this is the output force enable
 *     GPIO_1_INVERT_EN enable polarity invertion for pad input or output
 *     GPIO_1_OUT_FRCVAL the forced output value
 *     GPIO_1_DGLH_CNT  the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (gpio_1_ibof) is set to 0{gpio_1_ibof, gpio_1_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_GPIO_1_CTLr (0x00018a62 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_1_CTL.
 */
typedef union BCMI_MADURA_GPIO_1_CTLr_s {
	uint32_t v[1];
	uint32_t gpio_1_ctl[1];
	uint32_t _gpio_1_ctl;
} BCMI_MADURA_GPIO_1_CTLr_t;

#define BCMI_MADURA_GPIO_1_CTLr_CLR(r) (r).gpio_1_ctl[0] = 0
#define BCMI_MADURA_GPIO_1_CTLr_SET(r,d) (r).gpio_1_ctl[0] = d
#define BCMI_MADURA_GPIO_1_CTLr_GET(r) (r).gpio_1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_DGLH_CNTf_GET(r) ((((r).gpio_1_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_DGLH_CNTf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OUT_FRCVALf_GET(r) ((((r).gpio_1_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OUT_FRCVALf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INVERT_ENf_GET(r) ((((r).gpio_1_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INVERT_ENf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_IBOFf_GET(r) ((((r).gpio_1_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_IBOFf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL2f_GET(r) ((((r).gpio_1_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL2f_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL1f_GET(r) ((((r).gpio_1_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL1f_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL0f_GET(r) ((((r).gpio_1_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL0f_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INDf_GET(r) ((((r).gpio_1_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INDf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PDNf_GET(r) ((((r).gpio_1_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PDNf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PUPf_GET(r) ((((r).gpio_1_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PUPf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OEBf_GET(r) (((r).gpio_1_ctl[0]) & 0x1)
#define BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OEBf_SET(r,f) (r).gpio_1_ctl[0]=(((r).gpio_1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_1_CTL.
 */
#define BCMI_MADURA_READ_GPIO_1_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_1_CTLr,_r._gpio_1_ctl)
#define BCMI_MADURA_WRITE_GPIO_1_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_1_CTLr,_r._gpio_1_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_1_CTLr BCMI_MADURA_GPIO_1_CTLr
#define GPIO_1_CTLr_SIZE BCMI_MADURA_GPIO_1_CTLr_SIZE
typedef BCMI_MADURA_GPIO_1_CTLr_t GPIO_1_CTLr_t;
#define GPIO_1_CTLr_CLR BCMI_MADURA_GPIO_1_CTLr_CLR
#define GPIO_1_CTLr_SET BCMI_MADURA_GPIO_1_CTLr_SET
#define GPIO_1_CTLr_GET BCMI_MADURA_GPIO_1_CTLr_GET
#define GPIO_1_CTLr_GPIO_1_DGLH_CNTf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_DGLH_CNTf_GET
#define GPIO_1_CTLr_GPIO_1_DGLH_CNTf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_DGLH_CNTf_SET
#define GPIO_1_CTLr_GPIO_1_OUT_FRCVALf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OUT_FRCVALf_GET
#define GPIO_1_CTLr_GPIO_1_OUT_FRCVALf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OUT_FRCVALf_SET
#define GPIO_1_CTLr_GPIO_1_INVERT_ENf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INVERT_ENf_GET
#define GPIO_1_CTLr_GPIO_1_INVERT_ENf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INVERT_ENf_SET
#define GPIO_1_CTLr_GPIO_1_IBOFf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_IBOFf_GET
#define GPIO_1_CTLr_GPIO_1_IBOFf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_IBOFf_SET
#define GPIO_1_CTLr_GPIO_1_SEL2f_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL2f_GET
#define GPIO_1_CTLr_GPIO_1_SEL2f_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL2f_SET
#define GPIO_1_CTLr_GPIO_1_SEL1f_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL1f_GET
#define GPIO_1_CTLr_GPIO_1_SEL1f_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL1f_SET
#define GPIO_1_CTLr_GPIO_1_SEL0f_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL0f_GET
#define GPIO_1_CTLr_GPIO_1_SEL0f_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_SEL0f_SET
#define GPIO_1_CTLr_GPIO_1_INDf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INDf_GET
#define GPIO_1_CTLr_GPIO_1_INDf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_INDf_SET
#define GPIO_1_CTLr_GPIO_1_PDNf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PDNf_GET
#define GPIO_1_CTLr_GPIO_1_PDNf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PDNf_SET
#define GPIO_1_CTLr_GPIO_1_PUPf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PUPf_GET
#define GPIO_1_CTLr_GPIO_1_PUPf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_PUPf_SET
#define GPIO_1_CTLr_GPIO_1_OEBf_GET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OEBf_GET
#define GPIO_1_CTLr_GPIO_1_OEBf_SET BCMI_MADURA_GPIO_1_CTLr_GPIO_1_OEBf_SET
#define READ_GPIO_1_CTLr BCMI_MADURA_READ_GPIO_1_CTLr
#define WRITE_GPIO_1_CTLr BCMI_MADURA_WRITE_GPIO_1_CTLr
#define MODIFY_GPIO_1_CTLr BCMI_MADURA_MODIFY_GPIO_1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_1_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a63
 * DEVAD:    1
 * DESC:     PAD gpio_1 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_1_DIN_LH    pad input latch highstatus
 *     GPIO_1_DIN_LL    pad input latch low status
 *     GPIO_1_DIN       live pad input value
 */
#define BCMI_MADURA_GPIO_1_STSr (0x00018a63 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_1_STSr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_1_STS.
 */
typedef union BCMI_MADURA_GPIO_1_STSr_s {
	uint32_t v[1];
	uint32_t gpio_1_sts[1];
	uint32_t _gpio_1_sts;
} BCMI_MADURA_GPIO_1_STSr_t;

#define BCMI_MADURA_GPIO_1_STSr_CLR(r) (r).gpio_1_sts[0] = 0
#define BCMI_MADURA_GPIO_1_STSr_SET(r,d) (r).gpio_1_sts[0] = d
#define BCMI_MADURA_GPIO_1_STSr_GET(r) (r).gpio_1_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_1_STSr_GPIO_1_DINf_GET(r) ((((r).gpio_1_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_1_STSr_GPIO_1_DINf_SET(r,f) (r).gpio_1_sts[0]=(((r).gpio_1_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LLf_GET(r) ((((r).gpio_1_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LLf_SET(r,f) (r).gpio_1_sts[0]=(((r).gpio_1_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LHf_GET(r) (((r).gpio_1_sts[0]) & 0x1)
#define BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LHf_SET(r,f) (r).gpio_1_sts[0]=(((r).gpio_1_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_1_STS.
 */
#define BCMI_MADURA_READ_GPIO_1_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_1_STSr,_r._gpio_1_sts)
#define BCMI_MADURA_WRITE_GPIO_1_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_1_STSr,_r._gpio_1_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_1_STSr BCMI_MADURA_GPIO_1_STSr
#define GPIO_1_STSr_SIZE BCMI_MADURA_GPIO_1_STSr_SIZE
typedef BCMI_MADURA_GPIO_1_STSr_t GPIO_1_STSr_t;
#define GPIO_1_STSr_CLR BCMI_MADURA_GPIO_1_STSr_CLR
#define GPIO_1_STSr_SET BCMI_MADURA_GPIO_1_STSr_SET
#define GPIO_1_STSr_GET BCMI_MADURA_GPIO_1_STSr_GET
#define GPIO_1_STSr_GPIO_1_DINf_GET BCMI_MADURA_GPIO_1_STSr_GPIO_1_DINf_GET
#define GPIO_1_STSr_GPIO_1_DINf_SET BCMI_MADURA_GPIO_1_STSr_GPIO_1_DINf_SET
#define GPIO_1_STSr_GPIO_1_DIN_LLf_GET BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LLf_GET
#define GPIO_1_STSr_GPIO_1_DIN_LLf_SET BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LLf_SET
#define GPIO_1_STSr_GPIO_1_DIN_LHf_GET BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LHf_GET
#define GPIO_1_STSr_GPIO_1_DIN_LHf_SET BCMI_MADURA_GPIO_1_STSr_GPIO_1_DIN_LHf_SET
#define READ_GPIO_1_STSr BCMI_MADURA_READ_GPIO_1_STSr
#define WRITE_GPIO_1_STSr BCMI_MADURA_WRITE_GPIO_1_STSr
#define MODIFY_GPIO_1_STSr BCMI_MADURA_MODIFY_GPIO_1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_1_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_2_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a64
 * DEVAD:    1
 * DESC:     PAD gpio_2 control register
 * RESETVAL: 0xe3 (227)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_2_OEB       gpio_2 output enable, active low
 *     GPIO_2_PUP       gpio_2 pull-up
 *     GPIO_2_PDN       gpio_2 pull down
 *     GPIO_2_IND       gpio_2 ind
 *     GPIO_2_SEL0      gpio_2 sel0
 *     GPIO_2_SEL1      gpio_2 sel1
 *     GPIO_2_SEL2      gpio_2 sel2
 *     GPIO_2_IBOF      For input, this is deglitch bypassFor output, this is the output force enable
 *     GPIO_2_INVERT_EN enable polarity invertion for pad input or output
 *     GPIO_2_OUT_FRCVAL the forced output value
 *     GPIO_2_DGLH_CNT  the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (gpio_2_ibof) is set to 0{gpio_2_ibof, gpio_2_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_GPIO_2_CTLr (0x00018a64 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_2_CTL.
 */
typedef union BCMI_MADURA_GPIO_2_CTLr_s {
	uint32_t v[1];
	uint32_t gpio_2_ctl[1];
	uint32_t _gpio_2_ctl;
} BCMI_MADURA_GPIO_2_CTLr_t;

#define BCMI_MADURA_GPIO_2_CTLr_CLR(r) (r).gpio_2_ctl[0] = 0
#define BCMI_MADURA_GPIO_2_CTLr_SET(r,d) (r).gpio_2_ctl[0] = d
#define BCMI_MADURA_GPIO_2_CTLr_GET(r) (r).gpio_2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_DGLH_CNTf_GET(r) ((((r).gpio_2_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_DGLH_CNTf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OUT_FRCVALf_GET(r) ((((r).gpio_2_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OUT_FRCVALf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INVERT_ENf_GET(r) ((((r).gpio_2_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INVERT_ENf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_IBOFf_GET(r) ((((r).gpio_2_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_IBOFf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL2f_GET(r) ((((r).gpio_2_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL2f_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL1f_GET(r) ((((r).gpio_2_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL1f_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL0f_GET(r) ((((r).gpio_2_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL0f_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INDf_GET(r) ((((r).gpio_2_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INDf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PDNf_GET(r) ((((r).gpio_2_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PDNf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PUPf_GET(r) ((((r).gpio_2_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PUPf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OEBf_GET(r) (((r).gpio_2_ctl[0]) & 0x1)
#define BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OEBf_SET(r,f) (r).gpio_2_ctl[0]=(((r).gpio_2_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_2_CTL.
 */
#define BCMI_MADURA_READ_GPIO_2_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_2_CTLr,_r._gpio_2_ctl)
#define BCMI_MADURA_WRITE_GPIO_2_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_2_CTLr,_r._gpio_2_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_2_CTLr BCMI_MADURA_GPIO_2_CTLr
#define GPIO_2_CTLr_SIZE BCMI_MADURA_GPIO_2_CTLr_SIZE
typedef BCMI_MADURA_GPIO_2_CTLr_t GPIO_2_CTLr_t;
#define GPIO_2_CTLr_CLR BCMI_MADURA_GPIO_2_CTLr_CLR
#define GPIO_2_CTLr_SET BCMI_MADURA_GPIO_2_CTLr_SET
#define GPIO_2_CTLr_GET BCMI_MADURA_GPIO_2_CTLr_GET
#define GPIO_2_CTLr_GPIO_2_DGLH_CNTf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_DGLH_CNTf_GET
#define GPIO_2_CTLr_GPIO_2_DGLH_CNTf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_DGLH_CNTf_SET
#define GPIO_2_CTLr_GPIO_2_OUT_FRCVALf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OUT_FRCVALf_GET
#define GPIO_2_CTLr_GPIO_2_OUT_FRCVALf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OUT_FRCVALf_SET
#define GPIO_2_CTLr_GPIO_2_INVERT_ENf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INVERT_ENf_GET
#define GPIO_2_CTLr_GPIO_2_INVERT_ENf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INVERT_ENf_SET
#define GPIO_2_CTLr_GPIO_2_IBOFf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_IBOFf_GET
#define GPIO_2_CTLr_GPIO_2_IBOFf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_IBOFf_SET
#define GPIO_2_CTLr_GPIO_2_SEL2f_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL2f_GET
#define GPIO_2_CTLr_GPIO_2_SEL2f_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL2f_SET
#define GPIO_2_CTLr_GPIO_2_SEL1f_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL1f_GET
#define GPIO_2_CTLr_GPIO_2_SEL1f_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL1f_SET
#define GPIO_2_CTLr_GPIO_2_SEL0f_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL0f_GET
#define GPIO_2_CTLr_GPIO_2_SEL0f_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_SEL0f_SET
#define GPIO_2_CTLr_GPIO_2_INDf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INDf_GET
#define GPIO_2_CTLr_GPIO_2_INDf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_INDf_SET
#define GPIO_2_CTLr_GPIO_2_PDNf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PDNf_GET
#define GPIO_2_CTLr_GPIO_2_PDNf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PDNf_SET
#define GPIO_2_CTLr_GPIO_2_PUPf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PUPf_GET
#define GPIO_2_CTLr_GPIO_2_PUPf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_PUPf_SET
#define GPIO_2_CTLr_GPIO_2_OEBf_GET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OEBf_GET
#define GPIO_2_CTLr_GPIO_2_OEBf_SET BCMI_MADURA_GPIO_2_CTLr_GPIO_2_OEBf_SET
#define READ_GPIO_2_CTLr BCMI_MADURA_READ_GPIO_2_CTLr
#define WRITE_GPIO_2_CTLr BCMI_MADURA_WRITE_GPIO_2_CTLr
#define MODIFY_GPIO_2_CTLr BCMI_MADURA_MODIFY_GPIO_2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_2_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a65
 * DEVAD:    1
 * DESC:     PAD gpio_2 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_2_DIN_LH    pad input latch highstatus
 *     GPIO_2_DIN_LL    pad input latch low status
 *     GPIO_2_DIN       live pad input value
 */
#define BCMI_MADURA_GPIO_2_STSr (0x00018a65 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_2_STSr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_2_STS.
 */
typedef union BCMI_MADURA_GPIO_2_STSr_s {
	uint32_t v[1];
	uint32_t gpio_2_sts[1];
	uint32_t _gpio_2_sts;
} BCMI_MADURA_GPIO_2_STSr_t;

#define BCMI_MADURA_GPIO_2_STSr_CLR(r) (r).gpio_2_sts[0] = 0
#define BCMI_MADURA_GPIO_2_STSr_SET(r,d) (r).gpio_2_sts[0] = d
#define BCMI_MADURA_GPIO_2_STSr_GET(r) (r).gpio_2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_2_STSr_GPIO_2_DINf_GET(r) ((((r).gpio_2_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_2_STSr_GPIO_2_DINf_SET(r,f) (r).gpio_2_sts[0]=(((r).gpio_2_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LLf_GET(r) ((((r).gpio_2_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LLf_SET(r,f) (r).gpio_2_sts[0]=(((r).gpio_2_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LHf_GET(r) (((r).gpio_2_sts[0]) & 0x1)
#define BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LHf_SET(r,f) (r).gpio_2_sts[0]=(((r).gpio_2_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_2_STS.
 */
#define BCMI_MADURA_READ_GPIO_2_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_2_STSr,_r._gpio_2_sts)
#define BCMI_MADURA_WRITE_GPIO_2_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_2_STSr,_r._gpio_2_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_2_STSr BCMI_MADURA_GPIO_2_STSr
#define GPIO_2_STSr_SIZE BCMI_MADURA_GPIO_2_STSr_SIZE
typedef BCMI_MADURA_GPIO_2_STSr_t GPIO_2_STSr_t;
#define GPIO_2_STSr_CLR BCMI_MADURA_GPIO_2_STSr_CLR
#define GPIO_2_STSr_SET BCMI_MADURA_GPIO_2_STSr_SET
#define GPIO_2_STSr_GET BCMI_MADURA_GPIO_2_STSr_GET
#define GPIO_2_STSr_GPIO_2_DINf_GET BCMI_MADURA_GPIO_2_STSr_GPIO_2_DINf_GET
#define GPIO_2_STSr_GPIO_2_DINf_SET BCMI_MADURA_GPIO_2_STSr_GPIO_2_DINf_SET
#define GPIO_2_STSr_GPIO_2_DIN_LLf_GET BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LLf_GET
#define GPIO_2_STSr_GPIO_2_DIN_LLf_SET BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LLf_SET
#define GPIO_2_STSr_GPIO_2_DIN_LHf_GET BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LHf_GET
#define GPIO_2_STSr_GPIO_2_DIN_LHf_SET BCMI_MADURA_GPIO_2_STSr_GPIO_2_DIN_LHf_SET
#define READ_GPIO_2_STSr BCMI_MADURA_READ_GPIO_2_STSr
#define WRITE_GPIO_2_STSr BCMI_MADURA_WRITE_GPIO_2_STSr
#define MODIFY_GPIO_2_STSr BCMI_MADURA_MODIFY_GPIO_2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_3_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a66
 * DEVAD:    1
 * DESC:     PAD gpio_3 control register
 * RESETVAL: 0xe3 (227)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_3_OEB       gpio_3 output enable, active low
 *     GPIO_3_PUP       gpio_3 pull-up
 *     GPIO_3_PDN       gpio_3 pull down
 *     GPIO_3_IND       gpio_3 ind
 *     GPIO_3_SEL0      gpio_3 sel0
 *     GPIO_3_SEL1      gpio_3 sel1
 *     GPIO_3_SEL2      gpio_3 sel2
 *     GPIO_3_IBOF      For input, this is deglitch bypassFor output, this is the output force enable
 *     GPIO_3_INVERT_EN enable polarity invertion for pad input or output
 *     GPIO_3_OUT_FRCVAL the forced output value
 *     GPIO_3_DGLH_CNT  the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (gpio_3_ibof) is set to 0{gpio_3_ibof, gpio_3_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_GPIO_3_CTLr (0x00018a66 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_3_CTL.
 */
typedef union BCMI_MADURA_GPIO_3_CTLr_s {
	uint32_t v[1];
	uint32_t gpio_3_ctl[1];
	uint32_t _gpio_3_ctl;
} BCMI_MADURA_GPIO_3_CTLr_t;

#define BCMI_MADURA_GPIO_3_CTLr_CLR(r) (r).gpio_3_ctl[0] = 0
#define BCMI_MADURA_GPIO_3_CTLr_SET(r,d) (r).gpio_3_ctl[0] = d
#define BCMI_MADURA_GPIO_3_CTLr_GET(r) (r).gpio_3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_DGLH_CNTf_GET(r) ((((r).gpio_3_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_DGLH_CNTf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OUT_FRCVALf_GET(r) ((((r).gpio_3_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OUT_FRCVALf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INVERT_ENf_GET(r) ((((r).gpio_3_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INVERT_ENf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_IBOFf_GET(r) ((((r).gpio_3_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_IBOFf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL2f_GET(r) ((((r).gpio_3_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL2f_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL1f_GET(r) ((((r).gpio_3_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL1f_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL0f_GET(r) ((((r).gpio_3_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL0f_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INDf_GET(r) ((((r).gpio_3_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INDf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PDNf_GET(r) ((((r).gpio_3_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PDNf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PUPf_GET(r) ((((r).gpio_3_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PUPf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OEBf_GET(r) (((r).gpio_3_ctl[0]) & 0x1)
#define BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OEBf_SET(r,f) (r).gpio_3_ctl[0]=(((r).gpio_3_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_3_CTL.
 */
#define BCMI_MADURA_READ_GPIO_3_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_3_CTLr,_r._gpio_3_ctl)
#define BCMI_MADURA_WRITE_GPIO_3_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_3_CTLr,_r._gpio_3_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_3_CTLr BCMI_MADURA_GPIO_3_CTLr
#define GPIO_3_CTLr_SIZE BCMI_MADURA_GPIO_3_CTLr_SIZE
typedef BCMI_MADURA_GPIO_3_CTLr_t GPIO_3_CTLr_t;
#define GPIO_3_CTLr_CLR BCMI_MADURA_GPIO_3_CTLr_CLR
#define GPIO_3_CTLr_SET BCMI_MADURA_GPIO_3_CTLr_SET
#define GPIO_3_CTLr_GET BCMI_MADURA_GPIO_3_CTLr_GET
#define GPIO_3_CTLr_GPIO_3_DGLH_CNTf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_DGLH_CNTf_GET
#define GPIO_3_CTLr_GPIO_3_DGLH_CNTf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_DGLH_CNTf_SET
#define GPIO_3_CTLr_GPIO_3_OUT_FRCVALf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OUT_FRCVALf_GET
#define GPIO_3_CTLr_GPIO_3_OUT_FRCVALf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OUT_FRCVALf_SET
#define GPIO_3_CTLr_GPIO_3_INVERT_ENf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INVERT_ENf_GET
#define GPIO_3_CTLr_GPIO_3_INVERT_ENf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INVERT_ENf_SET
#define GPIO_3_CTLr_GPIO_3_IBOFf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_IBOFf_GET
#define GPIO_3_CTLr_GPIO_3_IBOFf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_IBOFf_SET
#define GPIO_3_CTLr_GPIO_3_SEL2f_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL2f_GET
#define GPIO_3_CTLr_GPIO_3_SEL2f_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL2f_SET
#define GPIO_3_CTLr_GPIO_3_SEL1f_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL1f_GET
#define GPIO_3_CTLr_GPIO_3_SEL1f_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL1f_SET
#define GPIO_3_CTLr_GPIO_3_SEL0f_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL0f_GET
#define GPIO_3_CTLr_GPIO_3_SEL0f_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_SEL0f_SET
#define GPIO_3_CTLr_GPIO_3_INDf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INDf_GET
#define GPIO_3_CTLr_GPIO_3_INDf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_INDf_SET
#define GPIO_3_CTLr_GPIO_3_PDNf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PDNf_GET
#define GPIO_3_CTLr_GPIO_3_PDNf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PDNf_SET
#define GPIO_3_CTLr_GPIO_3_PUPf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PUPf_GET
#define GPIO_3_CTLr_GPIO_3_PUPf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_PUPf_SET
#define GPIO_3_CTLr_GPIO_3_OEBf_GET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OEBf_GET
#define GPIO_3_CTLr_GPIO_3_OEBf_SET BCMI_MADURA_GPIO_3_CTLr_GPIO_3_OEBf_SET
#define READ_GPIO_3_CTLr BCMI_MADURA_READ_GPIO_3_CTLr
#define WRITE_GPIO_3_CTLr BCMI_MADURA_WRITE_GPIO_3_CTLr
#define MODIFY_GPIO_3_CTLr BCMI_MADURA_MODIFY_GPIO_3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_3_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a67
 * DEVAD:    1
 * DESC:     PAD gpio_3 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_3_DIN_LH    pad input latch highstatus
 *     GPIO_3_DIN_LL    pad input latch low status
 *     GPIO_3_DIN       live pad input value
 */
#define BCMI_MADURA_GPIO_3_STSr (0x00018a67 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_3_STSr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_3_STS.
 */
typedef union BCMI_MADURA_GPIO_3_STSr_s {
	uint32_t v[1];
	uint32_t gpio_3_sts[1];
	uint32_t _gpio_3_sts;
} BCMI_MADURA_GPIO_3_STSr_t;

#define BCMI_MADURA_GPIO_3_STSr_CLR(r) (r).gpio_3_sts[0] = 0
#define BCMI_MADURA_GPIO_3_STSr_SET(r,d) (r).gpio_3_sts[0] = d
#define BCMI_MADURA_GPIO_3_STSr_GET(r) (r).gpio_3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_3_STSr_GPIO_3_DINf_GET(r) ((((r).gpio_3_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_3_STSr_GPIO_3_DINf_SET(r,f) (r).gpio_3_sts[0]=(((r).gpio_3_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LLf_GET(r) ((((r).gpio_3_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LLf_SET(r,f) (r).gpio_3_sts[0]=(((r).gpio_3_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LHf_GET(r) (((r).gpio_3_sts[0]) & 0x1)
#define BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LHf_SET(r,f) (r).gpio_3_sts[0]=(((r).gpio_3_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_3_STS.
 */
#define BCMI_MADURA_READ_GPIO_3_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_3_STSr,_r._gpio_3_sts)
#define BCMI_MADURA_WRITE_GPIO_3_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_3_STSr,_r._gpio_3_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_3_STSr BCMI_MADURA_GPIO_3_STSr
#define GPIO_3_STSr_SIZE BCMI_MADURA_GPIO_3_STSr_SIZE
typedef BCMI_MADURA_GPIO_3_STSr_t GPIO_3_STSr_t;
#define GPIO_3_STSr_CLR BCMI_MADURA_GPIO_3_STSr_CLR
#define GPIO_3_STSr_SET BCMI_MADURA_GPIO_3_STSr_SET
#define GPIO_3_STSr_GET BCMI_MADURA_GPIO_3_STSr_GET
#define GPIO_3_STSr_GPIO_3_DINf_GET BCMI_MADURA_GPIO_3_STSr_GPIO_3_DINf_GET
#define GPIO_3_STSr_GPIO_3_DINf_SET BCMI_MADURA_GPIO_3_STSr_GPIO_3_DINf_SET
#define GPIO_3_STSr_GPIO_3_DIN_LLf_GET BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LLf_GET
#define GPIO_3_STSr_GPIO_3_DIN_LLf_SET BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LLf_SET
#define GPIO_3_STSr_GPIO_3_DIN_LHf_GET BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LHf_GET
#define GPIO_3_STSr_GPIO_3_DIN_LHf_SET BCMI_MADURA_GPIO_3_STSr_GPIO_3_DIN_LHf_SET
#define READ_GPIO_3_STSr BCMI_MADURA_READ_GPIO_3_STSr
#define WRITE_GPIO_3_STSr BCMI_MADURA_WRITE_GPIO_3_STSr
#define MODIFY_GPIO_3_STSr BCMI_MADURA_MODIFY_GPIO_3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_4_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a68
 * DEVAD:    1
 * DESC:     PAD gpio_4 control register
 * RESETVAL: 0xe3 (227)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_4_OEB       gpio_4 output enable, active low
 *     GPIO_4_PUP       gpio_4 pull-up
 *     GPIO_4_PDN       gpio_4 pull down
 *     GPIO_4_IND       gpio_4 ind
 *     GPIO_4_SEL0      gpio_4 sel0
 *     GPIO_4_SEL1      gpio_4 sel1
 *     GPIO_4_SEL2      gpio_4 sel2
 *     GPIO_4_IBOF      For input, this is deglitch bypassFor output, this is the output force enable
 *     GPIO_4_INVERT_EN enable polarity invertion for pad input or output
 *     GPIO_4_OUT_FRCVAL the forced output value
 *     GPIO_4_DGLH_CNT  the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (gpio_4_ibof) is set to 0{gpio_4_ibof, gpio_4_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_GPIO_4_CTLr (0x00018a68 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_4_CTL.
 */
typedef union BCMI_MADURA_GPIO_4_CTLr_s {
	uint32_t v[1];
	uint32_t gpio_4_ctl[1];
	uint32_t _gpio_4_ctl;
} BCMI_MADURA_GPIO_4_CTLr_t;

#define BCMI_MADURA_GPIO_4_CTLr_CLR(r) (r).gpio_4_ctl[0] = 0
#define BCMI_MADURA_GPIO_4_CTLr_SET(r,d) (r).gpio_4_ctl[0] = d
#define BCMI_MADURA_GPIO_4_CTLr_GET(r) (r).gpio_4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_DGLH_CNTf_GET(r) ((((r).gpio_4_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_DGLH_CNTf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OUT_FRCVALf_GET(r) ((((r).gpio_4_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OUT_FRCVALf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INVERT_ENf_GET(r) ((((r).gpio_4_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INVERT_ENf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_IBOFf_GET(r) ((((r).gpio_4_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_IBOFf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL2f_GET(r) ((((r).gpio_4_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL2f_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL1f_GET(r) ((((r).gpio_4_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL1f_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL0f_GET(r) ((((r).gpio_4_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL0f_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INDf_GET(r) ((((r).gpio_4_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INDf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PDNf_GET(r) ((((r).gpio_4_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PDNf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PUPf_GET(r) ((((r).gpio_4_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PUPf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OEBf_GET(r) (((r).gpio_4_ctl[0]) & 0x1)
#define BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OEBf_SET(r,f) (r).gpio_4_ctl[0]=(((r).gpio_4_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_4_CTL.
 */
#define BCMI_MADURA_READ_GPIO_4_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_4_CTLr,_r._gpio_4_ctl)
#define BCMI_MADURA_WRITE_GPIO_4_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_4_CTLr,_r._gpio_4_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_4_CTLr BCMI_MADURA_GPIO_4_CTLr
#define GPIO_4_CTLr_SIZE BCMI_MADURA_GPIO_4_CTLr_SIZE
typedef BCMI_MADURA_GPIO_4_CTLr_t GPIO_4_CTLr_t;
#define GPIO_4_CTLr_CLR BCMI_MADURA_GPIO_4_CTLr_CLR
#define GPIO_4_CTLr_SET BCMI_MADURA_GPIO_4_CTLr_SET
#define GPIO_4_CTLr_GET BCMI_MADURA_GPIO_4_CTLr_GET
#define GPIO_4_CTLr_GPIO_4_DGLH_CNTf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_DGLH_CNTf_GET
#define GPIO_4_CTLr_GPIO_4_DGLH_CNTf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_DGLH_CNTf_SET
#define GPIO_4_CTLr_GPIO_4_OUT_FRCVALf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OUT_FRCVALf_GET
#define GPIO_4_CTLr_GPIO_4_OUT_FRCVALf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OUT_FRCVALf_SET
#define GPIO_4_CTLr_GPIO_4_INVERT_ENf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INVERT_ENf_GET
#define GPIO_4_CTLr_GPIO_4_INVERT_ENf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INVERT_ENf_SET
#define GPIO_4_CTLr_GPIO_4_IBOFf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_IBOFf_GET
#define GPIO_4_CTLr_GPIO_4_IBOFf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_IBOFf_SET
#define GPIO_4_CTLr_GPIO_4_SEL2f_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL2f_GET
#define GPIO_4_CTLr_GPIO_4_SEL2f_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL2f_SET
#define GPIO_4_CTLr_GPIO_4_SEL1f_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL1f_GET
#define GPIO_4_CTLr_GPIO_4_SEL1f_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL1f_SET
#define GPIO_4_CTLr_GPIO_4_SEL0f_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL0f_GET
#define GPIO_4_CTLr_GPIO_4_SEL0f_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_SEL0f_SET
#define GPIO_4_CTLr_GPIO_4_INDf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INDf_GET
#define GPIO_4_CTLr_GPIO_4_INDf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_INDf_SET
#define GPIO_4_CTLr_GPIO_4_PDNf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PDNf_GET
#define GPIO_4_CTLr_GPIO_4_PDNf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PDNf_SET
#define GPIO_4_CTLr_GPIO_4_PUPf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PUPf_GET
#define GPIO_4_CTLr_GPIO_4_PUPf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_PUPf_SET
#define GPIO_4_CTLr_GPIO_4_OEBf_GET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OEBf_GET
#define GPIO_4_CTLr_GPIO_4_OEBf_SET BCMI_MADURA_GPIO_4_CTLr_GPIO_4_OEBf_SET
#define READ_GPIO_4_CTLr BCMI_MADURA_READ_GPIO_4_CTLr
#define WRITE_GPIO_4_CTLr BCMI_MADURA_WRITE_GPIO_4_CTLr
#define MODIFY_GPIO_4_CTLr BCMI_MADURA_MODIFY_GPIO_4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GPIO_4_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a69
 * DEVAD:    1
 * DESC:     PAD gpio_4 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_4_DIN_LH    pad input latch highstatus
 *     GPIO_4_DIN_LL    pad input latch low status
 *     GPIO_4_DIN       live pad input value
 */
#define BCMI_MADURA_GPIO_4_STSr (0x00018a69 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GPIO_4_STSr_SIZE 4

/*
 * This structure should be used to declare and program GPIO_4_STS.
 */
typedef union BCMI_MADURA_GPIO_4_STSr_s {
	uint32_t v[1];
	uint32_t gpio_4_sts[1];
	uint32_t _gpio_4_sts;
} BCMI_MADURA_GPIO_4_STSr_t;

#define BCMI_MADURA_GPIO_4_STSr_CLR(r) (r).gpio_4_sts[0] = 0
#define BCMI_MADURA_GPIO_4_STSr_SET(r,d) (r).gpio_4_sts[0] = d
#define BCMI_MADURA_GPIO_4_STSr_GET(r) (r).gpio_4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GPIO_4_STSr_GPIO_4_DINf_GET(r) ((((r).gpio_4_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_GPIO_4_STSr_GPIO_4_DINf_SET(r,f) (r).gpio_4_sts[0]=(((r).gpio_4_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LLf_GET(r) ((((r).gpio_4_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LLf_SET(r,f) (r).gpio_4_sts[0]=(((r).gpio_4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LHf_GET(r) (((r).gpio_4_sts[0]) & 0x1)
#define BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LHf_SET(r,f) (r).gpio_4_sts[0]=(((r).gpio_4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GPIO_4_STS.
 */
#define BCMI_MADURA_READ_GPIO_4_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GPIO_4_STSr,_r._gpio_4_sts)
#define BCMI_MADURA_WRITE_GPIO_4_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GPIO_4_STSr,_r._gpio_4_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GPIO_4_STSr BCMI_MADURA_GPIO_4_STSr
#define GPIO_4_STSr_SIZE BCMI_MADURA_GPIO_4_STSr_SIZE
typedef BCMI_MADURA_GPIO_4_STSr_t GPIO_4_STSr_t;
#define GPIO_4_STSr_CLR BCMI_MADURA_GPIO_4_STSr_CLR
#define GPIO_4_STSr_SET BCMI_MADURA_GPIO_4_STSr_SET
#define GPIO_4_STSr_GET BCMI_MADURA_GPIO_4_STSr_GET
#define GPIO_4_STSr_GPIO_4_DINf_GET BCMI_MADURA_GPIO_4_STSr_GPIO_4_DINf_GET
#define GPIO_4_STSr_GPIO_4_DINf_SET BCMI_MADURA_GPIO_4_STSr_GPIO_4_DINf_SET
#define GPIO_4_STSr_GPIO_4_DIN_LLf_GET BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LLf_GET
#define GPIO_4_STSr_GPIO_4_DIN_LLf_SET BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LLf_SET
#define GPIO_4_STSr_GPIO_4_DIN_LHf_GET BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LHf_GET
#define GPIO_4_STSr_GPIO_4_DIN_LHf_SET BCMI_MADURA_GPIO_4_STSr_GPIO_4_DIN_LHf_SET
#define READ_GPIO_4_STSr BCMI_MADURA_READ_GPIO_4_STSr
#define WRITE_GPIO_4_STSr BCMI_MADURA_WRITE_GPIO_4_STSr
#define MODIFY_GPIO_4_STSr BCMI_MADURA_MODIFY_GPIO_4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GPIO_4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EXT_INTRB_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a6a
 * DEVAD:    1
 * DESC:     PAD ext_intrb control register
 * RESETVAL: 0xe1 (225)
 * ACCESS:   R/W
 * FIELDS:
 *     EXT_INTRB_OEB    external interrupt open drain control1: open drain; 0: output always enabled
 *     EXT_INTRB_SEL0   ext_intrb sel0
 *     EXT_INTRB_SEL1   ext_intrb sel1
 *     EXT_INTRB_SEL2   ext_intrb sel2
 *     EXT_INTRB_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     EXT_INTRB_INVERT_EN enable polarity invertion for pad input or output
 *     EXT_INTRB_OUT_FRCVAL the forced output value
 *     EXT_INTRB_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (ext_intrb_ibof) is set to 0{ext_intrb_ibof, ext_intrb_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_EXT_INTRB_CTLr (0x00018a6a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EXT_INTRB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program EXT_INTRB_CTL.
 */
typedef union BCMI_MADURA_EXT_INTRB_CTLr_s {
	uint32_t v[1];
	uint32_t ext_intrb_ctl[1];
	uint32_t _ext_intrb_ctl;
} BCMI_MADURA_EXT_INTRB_CTLr_t;

#define BCMI_MADURA_EXT_INTRB_CTLr_CLR(r) (r).ext_intrb_ctl[0] = 0
#define BCMI_MADURA_EXT_INTRB_CTLr_SET(r,d) (r).ext_intrb_ctl[0] = d
#define BCMI_MADURA_EXT_INTRB_CTLr_GET(r) (r).ext_intrb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_DGLH_CNTf_GET(r) ((((r).ext_intrb_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_DGLH_CNTf_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OUT_FRCVALf_GET(r) ((((r).ext_intrb_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OUT_FRCVALf_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_INVERT_ENf_GET(r) ((((r).ext_intrb_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_INVERT_ENf_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_IBOFf_GET(r) ((((r).ext_intrb_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_IBOFf_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL2f_GET(r) ((((r).ext_intrb_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL2f_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL1f_GET(r) ((((r).ext_intrb_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL1f_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL0f_GET(r) ((((r).ext_intrb_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL0f_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OEBf_GET(r) (((r).ext_intrb_ctl[0]) & 0x1)
#define BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OEBf_SET(r,f) (r).ext_intrb_ctl[0]=(((r).ext_intrb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EXT_INTRB_CTL.
 */
#define BCMI_MADURA_READ_EXT_INTRB_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EXT_INTRB_CTLr,_r._ext_intrb_ctl)
#define BCMI_MADURA_WRITE_EXT_INTRB_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EXT_INTRB_CTLr,_r._ext_intrb_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EXT_INTRB_CTLr BCMI_MADURA_EXT_INTRB_CTLr
#define EXT_INTRB_CTLr_SIZE BCMI_MADURA_EXT_INTRB_CTLr_SIZE
typedef BCMI_MADURA_EXT_INTRB_CTLr_t EXT_INTRB_CTLr_t;
#define EXT_INTRB_CTLr_CLR BCMI_MADURA_EXT_INTRB_CTLr_CLR
#define EXT_INTRB_CTLr_SET BCMI_MADURA_EXT_INTRB_CTLr_SET
#define EXT_INTRB_CTLr_GET BCMI_MADURA_EXT_INTRB_CTLr_GET
#define EXT_INTRB_CTLr_EXT_INTRB_DGLH_CNTf_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_DGLH_CNTf_GET
#define EXT_INTRB_CTLr_EXT_INTRB_DGLH_CNTf_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_DGLH_CNTf_SET
#define EXT_INTRB_CTLr_EXT_INTRB_OUT_FRCVALf_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OUT_FRCVALf_GET
#define EXT_INTRB_CTLr_EXT_INTRB_OUT_FRCVALf_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OUT_FRCVALf_SET
#define EXT_INTRB_CTLr_EXT_INTRB_INVERT_ENf_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_INVERT_ENf_GET
#define EXT_INTRB_CTLr_EXT_INTRB_INVERT_ENf_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_INVERT_ENf_SET
#define EXT_INTRB_CTLr_EXT_INTRB_IBOFf_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_IBOFf_GET
#define EXT_INTRB_CTLr_EXT_INTRB_IBOFf_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_IBOFf_SET
#define EXT_INTRB_CTLr_EXT_INTRB_SEL2f_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL2f_GET
#define EXT_INTRB_CTLr_EXT_INTRB_SEL2f_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL2f_SET
#define EXT_INTRB_CTLr_EXT_INTRB_SEL1f_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL1f_GET
#define EXT_INTRB_CTLr_EXT_INTRB_SEL1f_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL1f_SET
#define EXT_INTRB_CTLr_EXT_INTRB_SEL0f_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL0f_GET
#define EXT_INTRB_CTLr_EXT_INTRB_SEL0f_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_SEL0f_SET
#define EXT_INTRB_CTLr_EXT_INTRB_OEBf_GET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OEBf_GET
#define EXT_INTRB_CTLr_EXT_INTRB_OEBf_SET BCMI_MADURA_EXT_INTRB_CTLr_EXT_INTRB_OEBf_SET
#define READ_EXT_INTRB_CTLr BCMI_MADURA_READ_EXT_INTRB_CTLr
#define WRITE_EXT_INTRB_CTLr BCMI_MADURA_WRITE_EXT_INTRB_CTLr
#define MODIFY_EXT_INTRB_CTLr BCMI_MADURA_MODIFY_EXT_INTRB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EXT_INTRB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EXT_INTRB_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a6b
 * DEVAD:    1
 * DESC:     PAD ext_intrb status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EXT_INTRB_DIN_LH pad input latch highstatus
 *     EXT_INTRB_DIN_LL pad input latch low status
 *     EXT_INTRB_DIN    live pad input value
 */
#define BCMI_MADURA_EXT_INTRB_STSr (0x00018a6b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EXT_INTRB_STSr_SIZE 4

/*
 * This structure should be used to declare and program EXT_INTRB_STS.
 */
typedef union BCMI_MADURA_EXT_INTRB_STSr_s {
	uint32_t v[1];
	uint32_t ext_intrb_sts[1];
	uint32_t _ext_intrb_sts;
} BCMI_MADURA_EXT_INTRB_STSr_t;

#define BCMI_MADURA_EXT_INTRB_STSr_CLR(r) (r).ext_intrb_sts[0] = 0
#define BCMI_MADURA_EXT_INTRB_STSr_SET(r,d) (r).ext_intrb_sts[0] = d
#define BCMI_MADURA_EXT_INTRB_STSr_GET(r) (r).ext_intrb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DINf_GET(r) ((((r).ext_intrb_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DINf_SET(r,f) (r).ext_intrb_sts[0]=(((r).ext_intrb_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LLf_GET(r) ((((r).ext_intrb_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LLf_SET(r,f) (r).ext_intrb_sts[0]=(((r).ext_intrb_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LHf_GET(r) (((r).ext_intrb_sts[0]) & 0x1)
#define BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LHf_SET(r,f) (r).ext_intrb_sts[0]=(((r).ext_intrb_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EXT_INTRB_STS.
 */
#define BCMI_MADURA_READ_EXT_INTRB_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EXT_INTRB_STSr,_r._ext_intrb_sts)
#define BCMI_MADURA_WRITE_EXT_INTRB_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EXT_INTRB_STSr,_r._ext_intrb_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EXT_INTRB_STSr BCMI_MADURA_EXT_INTRB_STSr
#define EXT_INTRB_STSr_SIZE BCMI_MADURA_EXT_INTRB_STSr_SIZE
typedef BCMI_MADURA_EXT_INTRB_STSr_t EXT_INTRB_STSr_t;
#define EXT_INTRB_STSr_CLR BCMI_MADURA_EXT_INTRB_STSr_CLR
#define EXT_INTRB_STSr_SET BCMI_MADURA_EXT_INTRB_STSr_SET
#define EXT_INTRB_STSr_GET BCMI_MADURA_EXT_INTRB_STSr_GET
#define EXT_INTRB_STSr_EXT_INTRB_DINf_GET BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DINf_GET
#define EXT_INTRB_STSr_EXT_INTRB_DINf_SET BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DINf_SET
#define EXT_INTRB_STSr_EXT_INTRB_DIN_LLf_GET BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LLf_GET
#define EXT_INTRB_STSr_EXT_INTRB_DIN_LLf_SET BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LLf_SET
#define EXT_INTRB_STSr_EXT_INTRB_DIN_LHf_GET BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LHf_GET
#define EXT_INTRB_STSr_EXT_INTRB_DIN_LHf_SET BCMI_MADURA_EXT_INTRB_STSr_EXT_INTRB_DIN_LHf_SET
#define READ_EXT_INTRB_STSr BCMI_MADURA_READ_EXT_INTRB_STSr
#define WRITE_EXT_INTRB_STSr BCMI_MADURA_WRITE_EXT_INTRB_STSr
#define MODIFY_EXT_INTRB_STSr BCMI_MADURA_MODIFY_EXT_INTRB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EXT_INTRB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EN_REF1_DIV2_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a6c
 * DEVAD:    1
 * DESC:     PAD en_ref1_div2 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EN_REF1_DIV2_PUP en_ref1_div2 pull-up
 *     EN_REF1_DIV2_PDN en_ref1_div2 pull down
 *     EN_REF1_DIV2_IND en_ref1_div2 ind
 *     EN_REF1_DIV2_IBOF For input, this is deglitch bypassFor output, this is the output force enable
 *     EN_REF1_DIV2_INVERT_EN enable polarity invertion for pad input or output
 *     EN_REF1_DIV2_OUT_FRCVAL the forced output value
 *     EN_REF1_DIV2_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (en_ref1_div2_ibof) is set to 0{en_ref1_div2_ibof, en_ref1_div2_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_EN_REF1_DIV2_CTLr (0x00018a6c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EN_REF1_DIV2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program EN_REF1_DIV2_CTL.
 */
typedef union BCMI_MADURA_EN_REF1_DIV2_CTLr_s {
	uint32_t v[1];
	uint32_t en_ref1_div2_ctl[1];
	uint32_t _en_ref1_div2_ctl;
} BCMI_MADURA_EN_REF1_DIV2_CTLr_t;

#define BCMI_MADURA_EN_REF1_DIV2_CTLr_CLR(r) (r).en_ref1_div2_ctl[0] = 0
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_SET(r,d) (r).en_ref1_div2_ctl[0] = d
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_GET(r) (r).en_ref1_div2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_DGLH_CNTf_GET(r) ((((r).en_ref1_div2_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_DGLH_CNTf_SET(r,f) (r).en_ref1_div2_ctl[0]=(((r).en_ref1_div2_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_OUT_FRCVALf_GET(r) ((((r).en_ref1_div2_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_OUT_FRCVALf_SET(r,f) (r).en_ref1_div2_ctl[0]=(((r).en_ref1_div2_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INVERT_ENf_GET(r) ((((r).en_ref1_div2_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INVERT_ENf_SET(r,f) (r).en_ref1_div2_ctl[0]=(((r).en_ref1_div2_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_IBOFf_GET(r) ((((r).en_ref1_div2_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_IBOFf_SET(r,f) (r).en_ref1_div2_ctl[0]=(((r).en_ref1_div2_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INDf_GET(r) ((((r).en_ref1_div2_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INDf_SET(r,f) (r).en_ref1_div2_ctl[0]=(((r).en_ref1_div2_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PDNf_GET(r) ((((r).en_ref1_div2_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PDNf_SET(r,f) (r).en_ref1_div2_ctl[0]=(((r).en_ref1_div2_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PUPf_GET(r) ((((r).en_ref1_div2_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PUPf_SET(r,f) (r).en_ref1_div2_ctl[0]=(((r).en_ref1_div2_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access EN_REF1_DIV2_CTL.
 */
#define BCMI_MADURA_READ_EN_REF1_DIV2_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EN_REF1_DIV2_CTLr,_r._en_ref1_div2_ctl)
#define BCMI_MADURA_WRITE_EN_REF1_DIV2_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EN_REF1_DIV2_CTLr,_r._en_ref1_div2_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EN_REF1_DIV2_CTLr BCMI_MADURA_EN_REF1_DIV2_CTLr
#define EN_REF1_DIV2_CTLr_SIZE BCMI_MADURA_EN_REF1_DIV2_CTLr_SIZE
typedef BCMI_MADURA_EN_REF1_DIV2_CTLr_t EN_REF1_DIV2_CTLr_t;
#define EN_REF1_DIV2_CTLr_CLR BCMI_MADURA_EN_REF1_DIV2_CTLr_CLR
#define EN_REF1_DIV2_CTLr_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_SET
#define EN_REF1_DIV2_CTLr_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_DGLH_CNTf_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_DGLH_CNTf_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_DGLH_CNTf_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_DGLH_CNTf_SET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_OUT_FRCVALf_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_OUT_FRCVALf_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_OUT_FRCVALf_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_OUT_FRCVALf_SET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INVERT_ENf_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INVERT_ENf_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INVERT_ENf_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INVERT_ENf_SET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_IBOFf_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_IBOFf_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_IBOFf_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_IBOFf_SET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INDf_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INDf_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INDf_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_INDf_SET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PDNf_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PDNf_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PDNf_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PDNf_SET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PUPf_GET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PUPf_GET
#define EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PUPf_SET BCMI_MADURA_EN_REF1_DIV2_CTLr_EN_REF1_DIV2_PUPf_SET
#define READ_EN_REF1_DIV2_CTLr BCMI_MADURA_READ_EN_REF1_DIV2_CTLr
#define WRITE_EN_REF1_DIV2_CTLr BCMI_MADURA_WRITE_EN_REF1_DIV2_CTLr
#define MODIFY_EN_REF1_DIV2_CTLr BCMI_MADURA_MODIFY_EN_REF1_DIV2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EN_REF1_DIV2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EN_REF1_DIV2_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a6d
 * DEVAD:    1
 * DESC:     PAD en_ref1_div2 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EN_REF1_DIV2_DIN_LH pad input latch highstatus
 *     EN_REF1_DIV2_DIN_LL pad input latch low status
 *     EN_REF1_DIV2_DIN live pad input value
 */
#define BCMI_MADURA_EN_REF1_DIV2_STSr (0x00018a6d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EN_REF1_DIV2_STSr_SIZE 4

/*
 * This structure should be used to declare and program EN_REF1_DIV2_STS.
 */
typedef union BCMI_MADURA_EN_REF1_DIV2_STSr_s {
	uint32_t v[1];
	uint32_t en_ref1_div2_sts[1];
	uint32_t _en_ref1_div2_sts;
} BCMI_MADURA_EN_REF1_DIV2_STSr_t;

#define BCMI_MADURA_EN_REF1_DIV2_STSr_CLR(r) (r).en_ref1_div2_sts[0] = 0
#define BCMI_MADURA_EN_REF1_DIV2_STSr_SET(r,d) (r).en_ref1_div2_sts[0] = d
#define BCMI_MADURA_EN_REF1_DIV2_STSr_GET(r) (r).en_ref1_div2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DINf_GET(r) ((((r).en_ref1_div2_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DINf_SET(r,f) (r).en_ref1_div2_sts[0]=(((r).en_ref1_div2_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LLf_GET(r) ((((r).en_ref1_div2_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LLf_SET(r,f) (r).en_ref1_div2_sts[0]=(((r).en_ref1_div2_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LHf_GET(r) (((r).en_ref1_div2_sts[0]) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LHf_SET(r,f) (r).en_ref1_div2_sts[0]=(((r).en_ref1_div2_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EN_REF1_DIV2_STS.
 */
#define BCMI_MADURA_READ_EN_REF1_DIV2_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EN_REF1_DIV2_STSr,_r._en_ref1_div2_sts)
#define BCMI_MADURA_WRITE_EN_REF1_DIV2_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EN_REF1_DIV2_STSr,_r._en_ref1_div2_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EN_REF1_DIV2_STSr BCMI_MADURA_EN_REF1_DIV2_STSr
#define EN_REF1_DIV2_STSr_SIZE BCMI_MADURA_EN_REF1_DIV2_STSr_SIZE
typedef BCMI_MADURA_EN_REF1_DIV2_STSr_t EN_REF1_DIV2_STSr_t;
#define EN_REF1_DIV2_STSr_CLR BCMI_MADURA_EN_REF1_DIV2_STSr_CLR
#define EN_REF1_DIV2_STSr_SET BCMI_MADURA_EN_REF1_DIV2_STSr_SET
#define EN_REF1_DIV2_STSr_GET BCMI_MADURA_EN_REF1_DIV2_STSr_GET
#define EN_REF1_DIV2_STSr_EN_REF1_DIV2_DINf_GET BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DINf_GET
#define EN_REF1_DIV2_STSr_EN_REF1_DIV2_DINf_SET BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DINf_SET
#define EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LLf_GET BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LLf_GET
#define EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LLf_SET BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LLf_SET
#define EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LHf_GET BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LHf_GET
#define EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LHf_SET BCMI_MADURA_EN_REF1_DIV2_STSr_EN_REF1_DIV2_DIN_LHf_SET
#define READ_EN_REF1_DIV2_STSr BCMI_MADURA_READ_EN_REF1_DIV2_STSr
#define WRITE_EN_REF1_DIV2_STSr BCMI_MADURA_WRITE_EN_REF1_DIV2_STSr
#define MODIFY_EN_REF1_DIV2_STSr BCMI_MADURA_MODIFY_EN_REF1_DIV2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EN_REF1_DIV2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EN_REF1_DIV4_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a6e
 * DEVAD:    1
 * DESC:     PAD en_ref1_div4 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EN_REF1_DIV4_PUP en_ref1_div4 pull-up
 *     EN_REF1_DIV4_PDN en_ref1_div4 pull down
 *     EN_REF1_DIV4_IND en_ref1_div4 ind
 *     EN_REF1_DIV4_IBOF For input, this is deglitch bypassFor output, this is the output force enable
 *     EN_REF1_DIV4_INVERT_EN enable polarity invertion for pad input or output
 *     EN_REF1_DIV4_OUT_FRCVAL the forced output value
 *     EN_REF1_DIV4_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (en_ref1_div4_ibof) is set to 0{en_ref1_div4_ibof, en_ref1_div4_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_EN_REF1_DIV4_CTLr (0x00018a6e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EN_REF1_DIV4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program EN_REF1_DIV4_CTL.
 */
typedef union BCMI_MADURA_EN_REF1_DIV4_CTLr_s {
	uint32_t v[1];
	uint32_t en_ref1_div4_ctl[1];
	uint32_t _en_ref1_div4_ctl;
} BCMI_MADURA_EN_REF1_DIV4_CTLr_t;

#define BCMI_MADURA_EN_REF1_DIV4_CTLr_CLR(r) (r).en_ref1_div4_ctl[0] = 0
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_SET(r,d) (r).en_ref1_div4_ctl[0] = d
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_GET(r) (r).en_ref1_div4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_DGLH_CNTf_GET(r) ((((r).en_ref1_div4_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_DGLH_CNTf_SET(r,f) (r).en_ref1_div4_ctl[0]=(((r).en_ref1_div4_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_OUT_FRCVALf_GET(r) ((((r).en_ref1_div4_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_OUT_FRCVALf_SET(r,f) (r).en_ref1_div4_ctl[0]=(((r).en_ref1_div4_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INVERT_ENf_GET(r) ((((r).en_ref1_div4_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INVERT_ENf_SET(r,f) (r).en_ref1_div4_ctl[0]=(((r).en_ref1_div4_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_IBOFf_GET(r) ((((r).en_ref1_div4_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_IBOFf_SET(r,f) (r).en_ref1_div4_ctl[0]=(((r).en_ref1_div4_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INDf_GET(r) ((((r).en_ref1_div4_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INDf_SET(r,f) (r).en_ref1_div4_ctl[0]=(((r).en_ref1_div4_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PDNf_GET(r) ((((r).en_ref1_div4_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PDNf_SET(r,f) (r).en_ref1_div4_ctl[0]=(((r).en_ref1_div4_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PUPf_GET(r) ((((r).en_ref1_div4_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PUPf_SET(r,f) (r).en_ref1_div4_ctl[0]=(((r).en_ref1_div4_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access EN_REF1_DIV4_CTL.
 */
#define BCMI_MADURA_READ_EN_REF1_DIV4_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EN_REF1_DIV4_CTLr,_r._en_ref1_div4_ctl)
#define BCMI_MADURA_WRITE_EN_REF1_DIV4_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EN_REF1_DIV4_CTLr,_r._en_ref1_div4_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EN_REF1_DIV4_CTLr BCMI_MADURA_EN_REF1_DIV4_CTLr
#define EN_REF1_DIV4_CTLr_SIZE BCMI_MADURA_EN_REF1_DIV4_CTLr_SIZE
typedef BCMI_MADURA_EN_REF1_DIV4_CTLr_t EN_REF1_DIV4_CTLr_t;
#define EN_REF1_DIV4_CTLr_CLR BCMI_MADURA_EN_REF1_DIV4_CTLr_CLR
#define EN_REF1_DIV4_CTLr_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_SET
#define EN_REF1_DIV4_CTLr_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_DGLH_CNTf_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_DGLH_CNTf_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_DGLH_CNTf_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_DGLH_CNTf_SET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_OUT_FRCVALf_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_OUT_FRCVALf_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_OUT_FRCVALf_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_OUT_FRCVALf_SET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INVERT_ENf_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INVERT_ENf_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INVERT_ENf_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INVERT_ENf_SET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_IBOFf_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_IBOFf_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_IBOFf_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_IBOFf_SET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INDf_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INDf_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INDf_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_INDf_SET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PDNf_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PDNf_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PDNf_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PDNf_SET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PUPf_GET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PUPf_GET
#define EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PUPf_SET BCMI_MADURA_EN_REF1_DIV4_CTLr_EN_REF1_DIV4_PUPf_SET
#define READ_EN_REF1_DIV4_CTLr BCMI_MADURA_READ_EN_REF1_DIV4_CTLr
#define WRITE_EN_REF1_DIV4_CTLr BCMI_MADURA_WRITE_EN_REF1_DIV4_CTLr
#define MODIFY_EN_REF1_DIV4_CTLr BCMI_MADURA_MODIFY_EN_REF1_DIV4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EN_REF1_DIV4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EN_REF1_DIV4_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a6f
 * DEVAD:    1
 * DESC:     PAD en_ref1_div4 status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EN_REF1_DIV4_DIN_LH pad input latch highstatus
 *     EN_REF1_DIV4_DIN_LL pad input latch low status
 *     EN_REF1_DIV4_DIN live pad input value
 */
#define BCMI_MADURA_EN_REF1_DIV4_STSr (0x00018a6f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EN_REF1_DIV4_STSr_SIZE 4

/*
 * This structure should be used to declare and program EN_REF1_DIV4_STS.
 */
typedef union BCMI_MADURA_EN_REF1_DIV4_STSr_s {
	uint32_t v[1];
	uint32_t en_ref1_div4_sts[1];
	uint32_t _en_ref1_div4_sts;
} BCMI_MADURA_EN_REF1_DIV4_STSr_t;

#define BCMI_MADURA_EN_REF1_DIV4_STSr_CLR(r) (r).en_ref1_div4_sts[0] = 0
#define BCMI_MADURA_EN_REF1_DIV4_STSr_SET(r,d) (r).en_ref1_div4_sts[0] = d
#define BCMI_MADURA_EN_REF1_DIV4_STSr_GET(r) (r).en_ref1_div4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DINf_GET(r) ((((r).en_ref1_div4_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DINf_SET(r,f) (r).en_ref1_div4_sts[0]=(((r).en_ref1_div4_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LLf_GET(r) ((((r).en_ref1_div4_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LLf_SET(r,f) (r).en_ref1_div4_sts[0]=(((r).en_ref1_div4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LHf_GET(r) (((r).en_ref1_div4_sts[0]) & 0x1)
#define BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LHf_SET(r,f) (r).en_ref1_div4_sts[0]=(((r).en_ref1_div4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access EN_REF1_DIV4_STS.
 */
#define BCMI_MADURA_READ_EN_REF1_DIV4_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EN_REF1_DIV4_STSr,_r._en_ref1_div4_sts)
#define BCMI_MADURA_WRITE_EN_REF1_DIV4_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EN_REF1_DIV4_STSr,_r._en_ref1_div4_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EN_REF1_DIV4_STSr BCMI_MADURA_EN_REF1_DIV4_STSr
#define EN_REF1_DIV4_STSr_SIZE BCMI_MADURA_EN_REF1_DIV4_STSr_SIZE
typedef BCMI_MADURA_EN_REF1_DIV4_STSr_t EN_REF1_DIV4_STSr_t;
#define EN_REF1_DIV4_STSr_CLR BCMI_MADURA_EN_REF1_DIV4_STSr_CLR
#define EN_REF1_DIV4_STSr_SET BCMI_MADURA_EN_REF1_DIV4_STSr_SET
#define EN_REF1_DIV4_STSr_GET BCMI_MADURA_EN_REF1_DIV4_STSr_GET
#define EN_REF1_DIV4_STSr_EN_REF1_DIV4_DINf_GET BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DINf_GET
#define EN_REF1_DIV4_STSr_EN_REF1_DIV4_DINf_SET BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DINf_SET
#define EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LLf_GET BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LLf_GET
#define EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LLf_SET BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LLf_SET
#define EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LHf_GET BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LHf_GET
#define EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LHf_SET BCMI_MADURA_EN_REF1_DIV4_STSr_EN_REF1_DIV4_DIN_LHf_SET
#define READ_EN_REF1_DIV4_STSr BCMI_MADURA_READ_EN_REF1_DIV4_STSr
#define WRITE_EN_REF1_DIV4_STSr BCMI_MADURA_WRITE_EN_REF1_DIV4_STSr
#define MODIFY_EN_REF1_DIV4_STSr BCMI_MADURA_MODIFY_EN_REF1_DIV4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EN_REF1_DIV4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_SELB_CTL
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a70
 * DEVAD:    1
 * DESC:     PAD mdio_selb control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_SELB_PUP    mdio_selb pull-up
 *     MDIO_SELB_PDN    mdio_selb pull down
 *     MDIO_SELB_IND    mdio_selb ind
 *     MDIO_SELB_IBOF   For input, this is deglitch bypassFor output, this is the output force enable
 *     MDIO_SELB_INVERT_EN enable polarity invertion for pad input or output
 *     MDIO_SELB_OUT_FRCVAL the forced output value
 *     MDIO_SELB_DGLH_CNT the number of consecutive common cycle for din deglitchvalid only deglitch_bypass (mdio_selb_ibof) is set to 0{mdio_selb_ibof, mdio_selb_dglh_cnt}: number of stable common_ck cycle needed to deglitch{1'b1, 4'hx}        1 (no deglitch){1'b0, 4'h0}        2{1'b0, 4'h1}        3{1'b0, 4'h2}        4...{1'b0, 4'hF}        17
 */
#define BCMI_MADURA_MDIO_SELB_CTLr (0x00018a70 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_SELB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_SELB_CTL.
 */
typedef union BCMI_MADURA_MDIO_SELB_CTLr_s {
	uint32_t v[1];
	uint32_t mdio_selb_ctl[1];
	uint32_t _mdio_selb_ctl;
} BCMI_MADURA_MDIO_SELB_CTLr_t;

#define BCMI_MADURA_MDIO_SELB_CTLr_CLR(r) (r).mdio_selb_ctl[0] = 0
#define BCMI_MADURA_MDIO_SELB_CTLr_SET(r,d) (r).mdio_selb_ctl[0] = d
#define BCMI_MADURA_MDIO_SELB_CTLr_GET(r) (r).mdio_selb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_DGLH_CNTf_GET(r) ((((r).mdio_selb_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_DGLH_CNTf_SET(r,f) (r).mdio_selb_ctl[0]=(((r).mdio_selb_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_OUT_FRCVALf_GET(r) ((((r).mdio_selb_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_OUT_FRCVALf_SET(r,f) (r).mdio_selb_ctl[0]=(((r).mdio_selb_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INVERT_ENf_GET(r) ((((r).mdio_selb_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INVERT_ENf_SET(r,f) (r).mdio_selb_ctl[0]=(((r).mdio_selb_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_IBOFf_GET(r) ((((r).mdio_selb_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_IBOFf_SET(r,f) (r).mdio_selb_ctl[0]=(((r).mdio_selb_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INDf_GET(r) ((((r).mdio_selb_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INDf_SET(r,f) (r).mdio_selb_ctl[0]=(((r).mdio_selb_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PDNf_GET(r) ((((r).mdio_selb_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PDNf_SET(r,f) (r).mdio_selb_ctl[0]=(((r).mdio_selb_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PUPf_GET(r) ((((r).mdio_selb_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PUPf_SET(r,f) (r).mdio_selb_ctl[0]=(((r).mdio_selb_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access MDIO_SELB_CTL.
 */
#define BCMI_MADURA_READ_MDIO_SELB_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_SELB_CTLr,_r._mdio_selb_ctl)
#define BCMI_MADURA_WRITE_MDIO_SELB_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_SELB_CTLr,_r._mdio_selb_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_SELB_CTLr BCMI_MADURA_MDIO_SELB_CTLr
#define MDIO_SELB_CTLr_SIZE BCMI_MADURA_MDIO_SELB_CTLr_SIZE
typedef BCMI_MADURA_MDIO_SELB_CTLr_t MDIO_SELB_CTLr_t;
#define MDIO_SELB_CTLr_CLR BCMI_MADURA_MDIO_SELB_CTLr_CLR
#define MDIO_SELB_CTLr_SET BCMI_MADURA_MDIO_SELB_CTLr_SET
#define MDIO_SELB_CTLr_GET BCMI_MADURA_MDIO_SELB_CTLr_GET
#define MDIO_SELB_CTLr_MDIO_SELB_DGLH_CNTf_GET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_DGLH_CNTf_GET
#define MDIO_SELB_CTLr_MDIO_SELB_DGLH_CNTf_SET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_DGLH_CNTf_SET
#define MDIO_SELB_CTLr_MDIO_SELB_OUT_FRCVALf_GET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_OUT_FRCVALf_GET
#define MDIO_SELB_CTLr_MDIO_SELB_OUT_FRCVALf_SET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_OUT_FRCVALf_SET
#define MDIO_SELB_CTLr_MDIO_SELB_INVERT_ENf_GET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INVERT_ENf_GET
#define MDIO_SELB_CTLr_MDIO_SELB_INVERT_ENf_SET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INVERT_ENf_SET
#define MDIO_SELB_CTLr_MDIO_SELB_IBOFf_GET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_IBOFf_GET
#define MDIO_SELB_CTLr_MDIO_SELB_IBOFf_SET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_IBOFf_SET
#define MDIO_SELB_CTLr_MDIO_SELB_INDf_GET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INDf_GET
#define MDIO_SELB_CTLr_MDIO_SELB_INDf_SET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_INDf_SET
#define MDIO_SELB_CTLr_MDIO_SELB_PDNf_GET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PDNf_GET
#define MDIO_SELB_CTLr_MDIO_SELB_PDNf_SET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PDNf_SET
#define MDIO_SELB_CTLr_MDIO_SELB_PUPf_GET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PUPf_GET
#define MDIO_SELB_CTLr_MDIO_SELB_PUPf_SET BCMI_MADURA_MDIO_SELB_CTLr_MDIO_SELB_PUPf_SET
#define READ_MDIO_SELB_CTLr BCMI_MADURA_READ_MDIO_SELB_CTLr
#define WRITE_MDIO_SELB_CTLr BCMI_MADURA_WRITE_MDIO_SELB_CTLr
#define MODIFY_MDIO_SELB_CTLr BCMI_MADURA_MODIFY_MDIO_SELB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_SELB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_SELB_STS
 * BLOCKS:   PAD_CTRL
 * REGADDR:  0x8a71
 * DEVAD:    1
 * DESC:     PAD mdio_selb status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_SELB_DIN_LH pad input latch highstatus
 *     MDIO_SELB_DIN_LL pad input latch low status
 *     MDIO_SELB_DIN    live pad input value
 */
#define BCMI_MADURA_MDIO_SELB_STSr (0x00018a71 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_SELB_STSr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_SELB_STS.
 */
typedef union BCMI_MADURA_MDIO_SELB_STSr_s {
	uint32_t v[1];
	uint32_t mdio_selb_sts[1];
	uint32_t _mdio_selb_sts;
} BCMI_MADURA_MDIO_SELB_STSr_t;

#define BCMI_MADURA_MDIO_SELB_STSr_CLR(r) (r).mdio_selb_sts[0] = 0
#define BCMI_MADURA_MDIO_SELB_STSr_SET(r,d) (r).mdio_selb_sts[0] = d
#define BCMI_MADURA_MDIO_SELB_STSr_GET(r) (r).mdio_selb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DINf_GET(r) ((((r).mdio_selb_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DINf_SET(r,f) (r).mdio_selb_sts[0]=(((r).mdio_selb_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LLf_GET(r) ((((r).mdio_selb_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LLf_SET(r,f) (r).mdio_selb_sts[0]=(((r).mdio_selb_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LHf_GET(r) (((r).mdio_selb_sts[0]) & 0x1)
#define BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LHf_SET(r,f) (r).mdio_selb_sts[0]=(((r).mdio_selb_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_SELB_STS.
 */
#define BCMI_MADURA_READ_MDIO_SELB_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_SELB_STSr,_r._mdio_selb_sts)
#define BCMI_MADURA_WRITE_MDIO_SELB_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_SELB_STSr,_r._mdio_selb_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_SELB_STSr BCMI_MADURA_MDIO_SELB_STSr
#define MDIO_SELB_STSr_SIZE BCMI_MADURA_MDIO_SELB_STSr_SIZE
typedef BCMI_MADURA_MDIO_SELB_STSr_t MDIO_SELB_STSr_t;
#define MDIO_SELB_STSr_CLR BCMI_MADURA_MDIO_SELB_STSr_CLR
#define MDIO_SELB_STSr_SET BCMI_MADURA_MDIO_SELB_STSr_SET
#define MDIO_SELB_STSr_GET BCMI_MADURA_MDIO_SELB_STSr_GET
#define MDIO_SELB_STSr_MDIO_SELB_DINf_GET BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DINf_GET
#define MDIO_SELB_STSr_MDIO_SELB_DINf_SET BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DINf_SET
#define MDIO_SELB_STSr_MDIO_SELB_DIN_LLf_GET BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LLf_GET
#define MDIO_SELB_STSr_MDIO_SELB_DIN_LLf_SET BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LLf_SET
#define MDIO_SELB_STSr_MDIO_SELB_DIN_LHf_GET BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LHf_GET
#define MDIO_SELB_STSr_MDIO_SELB_DIN_LHf_SET BCMI_MADURA_MDIO_SELB_STSr_MDIO_SELB_DIN_LHf_SET
#define READ_MDIO_SELB_STSr BCMI_MADURA_READ_MDIO_SELB_STSr
#define WRITE_MDIO_SELB_STSr BCMI_MADURA_WRITE_MDIO_SELB_STSr
#define MODIFY_MDIO_SELB_STSr BCMI_MADURA_MODIFY_MDIO_SELB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_SELB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CHIP_ID
 * BLOCKS:   CTRL
 * REGADDR:  0x8b00
 * DEVAD:    1
 * DESC:     Chip ID Register (Lower 16-bits)
 * RESETVAL: 0x2388 (9096)
 * ACCESS:   R/W
 * FIELDS:
 *     CHIP_ID_15_0     Chip ID[15:0]
 */
#define BCMI_MADURA_CHIP_IDr (0x00018b00 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CHIP_IDr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_ID.
 */
typedef union BCMI_MADURA_CHIP_IDr_s {
	uint32_t v[1];
	uint32_t chip_id[1];
	uint32_t _chip_id;
} BCMI_MADURA_CHIP_IDr_t;

#define BCMI_MADURA_CHIP_IDr_CLR(r) (r).chip_id[0] = 0
#define BCMI_MADURA_CHIP_IDr_SET(r,d) (r).chip_id[0] = d
#define BCMI_MADURA_CHIP_IDr_GET(r) (r).chip_id[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CHIP_IDr_CHIP_ID_15_0f_GET(r) (((r).chip_id[0]) & 0xffff)
#define BCMI_MADURA_CHIP_IDr_CHIP_ID_15_0f_SET(r,f) (r).chip_id[0]=(((r).chip_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CHIP_ID.
 */
#define BCMI_MADURA_READ_CHIP_IDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CHIP_IDr,_r._chip_id)
#define BCMI_MADURA_WRITE_CHIP_IDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CHIP_IDr,_r._chip_id)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CHIP_IDr BCMI_MADURA_CHIP_IDr
#define CHIP_IDr_SIZE BCMI_MADURA_CHIP_IDr_SIZE
typedef BCMI_MADURA_CHIP_IDr_t CHIP_IDr_t;
#define CHIP_IDr_CLR BCMI_MADURA_CHIP_IDr_CLR
#define CHIP_IDr_SET BCMI_MADURA_CHIP_IDr_SET
#define CHIP_IDr_GET BCMI_MADURA_CHIP_IDr_GET
#define CHIP_IDr_CHIP_ID_15_0f_GET BCMI_MADURA_CHIP_IDr_CHIP_ID_15_0f_GET
#define CHIP_IDr_CHIP_ID_15_0f_SET BCMI_MADURA_CHIP_IDr_CHIP_ID_15_0f_SET
#define READ_CHIP_IDr BCMI_MADURA_READ_CHIP_IDr
#define WRITE_CHIP_IDr BCMI_MADURA_WRITE_CHIP_IDr
#define MODIFY_CHIP_IDr BCMI_MADURA_MODIFY_CHIP_IDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CHIP_IDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CHIP_REVISION
 * BLOCKS:   CTRL
 * REGADDR:  0x8b01
 * DEVAD:    1
 * DESC:     Chip REV Register
 * RESETVAL: 0x80a0 (32928)
 * ACCESS:   R/W
 * FIELDS:
 *     CHIP_REV         Rev ID
 *     CHIP_ID_19_16    Chip ID[19:16]
 */
#define BCMI_MADURA_CHIP_REVISIONr (0x00018b01 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CHIP_REVISIONr_SIZE 4

/*
 * This structure should be used to declare and program CHIP_REVISION.
 */
typedef union BCMI_MADURA_CHIP_REVISIONr_s {
	uint32_t v[1];
	uint32_t chip_revision[1];
	uint32_t _chip_revision;
} BCMI_MADURA_CHIP_REVISIONr_t;

#define BCMI_MADURA_CHIP_REVISIONr_CLR(r) (r).chip_revision[0] = 0
#define BCMI_MADURA_CHIP_REVISIONr_SET(r,d) (r).chip_revision[0] = d
#define BCMI_MADURA_CHIP_REVISIONr_GET(r) (r).chip_revision[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CHIP_REVISIONr_CHIP_ID_19_16f_GET(r) ((((r).chip_revision[0]) >> 12) & 0xf)
#define BCMI_MADURA_CHIP_REVISIONr_CHIP_ID_19_16f_SET(r,f) (r).chip_revision[0]=(((r).chip_revision[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_CHIP_REVISIONr_CHIP_REVf_GET(r) (((r).chip_revision[0]) & 0xff)
#define BCMI_MADURA_CHIP_REVISIONr_CHIP_REVf_SET(r,f) (r).chip_revision[0]=(((r).chip_revision[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access CHIP_REVISION.
 */
#define BCMI_MADURA_READ_CHIP_REVISIONr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CHIP_REVISIONr,_r._chip_revision)
#define BCMI_MADURA_WRITE_CHIP_REVISIONr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CHIP_REVISIONr,_r._chip_revision)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CHIP_REVISIONr BCMI_MADURA_CHIP_REVISIONr
#define CHIP_REVISIONr_SIZE BCMI_MADURA_CHIP_REVISIONr_SIZE
typedef BCMI_MADURA_CHIP_REVISIONr_t CHIP_REVISIONr_t;
#define CHIP_REVISIONr_CLR BCMI_MADURA_CHIP_REVISIONr_CLR
#define CHIP_REVISIONr_SET BCMI_MADURA_CHIP_REVISIONr_SET
#define CHIP_REVISIONr_GET BCMI_MADURA_CHIP_REVISIONr_GET
#define CHIP_REVISIONr_CHIP_ID_19_16f_GET BCMI_MADURA_CHIP_REVISIONr_CHIP_ID_19_16f_GET
#define CHIP_REVISIONr_CHIP_ID_19_16f_SET BCMI_MADURA_CHIP_REVISIONr_CHIP_ID_19_16f_SET
#define CHIP_REVISIONr_CHIP_REVf_GET BCMI_MADURA_CHIP_REVISIONr_CHIP_REVf_GET
#define CHIP_REVISIONr_CHIP_REVf_SET BCMI_MADURA_CHIP_REVISIONr_CHIP_REVf_SET
#define READ_CHIP_REVISIONr BCMI_MADURA_READ_CHIP_REVISIONr
#define WRITE_CHIP_REVISIONr BCMI_MADURA_WRITE_CHIP_REVISIONr
#define MODIFY_CHIP_REVISIONr BCMI_MADURA_MODIFY_CHIP_REVISIONr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CHIP_REVISIONr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_EISR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b10
 * DEVAD:    1
 * DESC:     M0 Micro Master and Slave 1 External Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_SYSRESETREQ  Master M0 sys reset req rising edge interrupt statusM0 core needs to be reset in response to sysresetreq
 *     MST_LOCKUP       Master M0 lockup rising edge interrupt statusM0 core needs to be reset to come out of lockup
 *     MST_MISC_INTR    Master M0 puts a Message out in the mst_misc_msgout_val register and generates this rising edge interrupt for the external device
 *     MST_MSGOUT_INTR  Master M0 puts a Message out in the mst_msgout_val register and generates this rising edge interrupt for the external device
 *     MST_DED          Master Code RAM ECC 2-bit error detected rising edge interrupt status
 *     MST_SEC          Master Code RAM ECC 1-bit error corrected rising edge interrupt status
 */
#define BCMI_MADURA_MST_EISRr (0x00018b10 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_EISRr_SIZE 4

/*
 * This structure should be used to declare and program MST_EISR.
 */
typedef union BCMI_MADURA_MST_EISRr_s {
	uint32_t v[1];
	uint32_t mst_eisr[1];
	uint32_t _mst_eisr;
} BCMI_MADURA_MST_EISRr_t;

#define BCMI_MADURA_MST_EISRr_CLR(r) (r).mst_eisr[0] = 0
#define BCMI_MADURA_MST_EISRr_SET(r,d) (r).mst_eisr[0] = d
#define BCMI_MADURA_MST_EISRr_GET(r) (r).mst_eisr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_EISRr_MST_SECf_GET(r) ((((r).mst_eisr[0]) >> 5) & 0x1)
#define BCMI_MADURA_MST_EISRr_MST_SECf_SET(r,f) (r).mst_eisr[0]=(((r).mst_eisr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MST_EISRr_MST_DEDf_GET(r) ((((r).mst_eisr[0]) >> 4) & 0x1)
#define BCMI_MADURA_MST_EISRr_MST_DEDf_SET(r,f) (r).mst_eisr[0]=(((r).mst_eisr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MST_EISRr_MST_MSGOUT_INTRf_GET(r) ((((r).mst_eisr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MST_EISRr_MST_MSGOUT_INTRf_SET(r,f) (r).mst_eisr[0]=(((r).mst_eisr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MST_EISRr_MST_MISC_INTRf_GET(r) ((((r).mst_eisr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MST_EISRr_MST_MISC_INTRf_SET(r,f) (r).mst_eisr[0]=(((r).mst_eisr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MST_EISRr_MST_LOCKUPf_GET(r) ((((r).mst_eisr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MST_EISRr_MST_LOCKUPf_SET(r,f) (r).mst_eisr[0]=(((r).mst_eisr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MST_EISRr_MST_SYSRESETREQf_GET(r) (((r).mst_eisr[0]) & 0x1)
#define BCMI_MADURA_MST_EISRr_MST_SYSRESETREQf_SET(r,f) (r).mst_eisr[0]=(((r).mst_eisr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MST_EISR.
 */
#define BCMI_MADURA_READ_MST_EISRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_EISRr,_r._mst_eisr)
#define BCMI_MADURA_WRITE_MST_EISRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_EISRr,_r._mst_eisr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_EISRr BCMI_MADURA_MST_EISRr
#define MST_EISRr_SIZE BCMI_MADURA_MST_EISRr_SIZE
typedef BCMI_MADURA_MST_EISRr_t MST_EISRr_t;
#define MST_EISRr_CLR BCMI_MADURA_MST_EISRr_CLR
#define MST_EISRr_SET BCMI_MADURA_MST_EISRr_SET
#define MST_EISRr_GET BCMI_MADURA_MST_EISRr_GET
#define MST_EISRr_MST_SECf_GET BCMI_MADURA_MST_EISRr_MST_SECf_GET
#define MST_EISRr_MST_SECf_SET BCMI_MADURA_MST_EISRr_MST_SECf_SET
#define MST_EISRr_MST_DEDf_GET BCMI_MADURA_MST_EISRr_MST_DEDf_GET
#define MST_EISRr_MST_DEDf_SET BCMI_MADURA_MST_EISRr_MST_DEDf_SET
#define MST_EISRr_MST_MSGOUT_INTRf_GET BCMI_MADURA_MST_EISRr_MST_MSGOUT_INTRf_GET
#define MST_EISRr_MST_MSGOUT_INTRf_SET BCMI_MADURA_MST_EISRr_MST_MSGOUT_INTRf_SET
#define MST_EISRr_MST_MISC_INTRf_GET BCMI_MADURA_MST_EISRr_MST_MISC_INTRf_GET
#define MST_EISRr_MST_MISC_INTRf_SET BCMI_MADURA_MST_EISRr_MST_MISC_INTRf_SET
#define MST_EISRr_MST_LOCKUPf_GET BCMI_MADURA_MST_EISRr_MST_LOCKUPf_GET
#define MST_EISRr_MST_LOCKUPf_SET BCMI_MADURA_MST_EISRr_MST_LOCKUPf_SET
#define MST_EISRr_MST_SYSRESETREQf_GET BCMI_MADURA_MST_EISRr_MST_SYSRESETREQf_GET
#define MST_EISRr_MST_SYSRESETREQf_SET BCMI_MADURA_MST_EISRr_MST_SYSRESETREQf_SET
#define READ_MST_EISRr BCMI_MADURA_READ_MST_EISRr
#define WRITE_MST_EISRr BCMI_MADURA_WRITE_MST_EISRr
#define MODIFY_MST_EISRr BCMI_MADURA_MODIFY_MST_EISRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_EISRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_EIPR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b11
 * DEVAD:    1
 * DESC:     M0 Micro Master and Slave 1 External Interrupt Pending
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P_MST_SYSRESETREQ 1 = Pending Interrupt
 *     P_MST_LOCKUP     1 = Pending Interrupt
 *     P_MST_MISC_INTR  1 = Pending Interrupt
 *     P_MST_MSGOUT_INTR 1 = Pending Interrupt
 *     P_MST_DED        1 = Pending Interrupt
 *     P_MST_SEC        1 = Pending Interrupt
 */
#define BCMI_MADURA_MST_EIPRr (0x00018b11 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_EIPRr_SIZE 4

/*
 * This structure should be used to declare and program MST_EIPR.
 */
typedef union BCMI_MADURA_MST_EIPRr_s {
	uint32_t v[1];
	uint32_t mst_eipr[1];
	uint32_t _mst_eipr;
} BCMI_MADURA_MST_EIPRr_t;

#define BCMI_MADURA_MST_EIPRr_CLR(r) (r).mst_eipr[0] = 0
#define BCMI_MADURA_MST_EIPRr_SET(r,d) (r).mst_eipr[0] = d
#define BCMI_MADURA_MST_EIPRr_GET(r) (r).mst_eipr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_EIPRr_P_MST_SECf_GET(r) ((((r).mst_eipr[0]) >> 5) & 0x1)
#define BCMI_MADURA_MST_EIPRr_P_MST_SECf_SET(r,f) (r).mst_eipr[0]=(((r).mst_eipr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MST_EIPRr_P_MST_DEDf_GET(r) ((((r).mst_eipr[0]) >> 4) & 0x1)
#define BCMI_MADURA_MST_EIPRr_P_MST_DEDf_SET(r,f) (r).mst_eipr[0]=(((r).mst_eipr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MST_EIPRr_P_MST_MSGOUT_INTRf_GET(r) ((((r).mst_eipr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MST_EIPRr_P_MST_MSGOUT_INTRf_SET(r,f) (r).mst_eipr[0]=(((r).mst_eipr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MST_EIPRr_P_MST_MISC_INTRf_GET(r) ((((r).mst_eipr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MST_EIPRr_P_MST_MISC_INTRf_SET(r,f) (r).mst_eipr[0]=(((r).mst_eipr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MST_EIPRr_P_MST_LOCKUPf_GET(r) ((((r).mst_eipr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MST_EIPRr_P_MST_LOCKUPf_SET(r,f) (r).mst_eipr[0]=(((r).mst_eipr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MST_EIPRr_P_MST_SYSRESETREQf_GET(r) (((r).mst_eipr[0]) & 0x1)
#define BCMI_MADURA_MST_EIPRr_P_MST_SYSRESETREQf_SET(r,f) (r).mst_eipr[0]=(((r).mst_eipr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MST_EIPR.
 */
#define BCMI_MADURA_READ_MST_EIPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_EIPRr,_r._mst_eipr)
#define BCMI_MADURA_WRITE_MST_EIPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_EIPRr,_r._mst_eipr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_EIPRr BCMI_MADURA_MST_EIPRr
#define MST_EIPRr_SIZE BCMI_MADURA_MST_EIPRr_SIZE
typedef BCMI_MADURA_MST_EIPRr_t MST_EIPRr_t;
#define MST_EIPRr_CLR BCMI_MADURA_MST_EIPRr_CLR
#define MST_EIPRr_SET BCMI_MADURA_MST_EIPRr_SET
#define MST_EIPRr_GET BCMI_MADURA_MST_EIPRr_GET
#define MST_EIPRr_P_MST_SECf_GET BCMI_MADURA_MST_EIPRr_P_MST_SECf_GET
#define MST_EIPRr_P_MST_SECf_SET BCMI_MADURA_MST_EIPRr_P_MST_SECf_SET
#define MST_EIPRr_P_MST_DEDf_GET BCMI_MADURA_MST_EIPRr_P_MST_DEDf_GET
#define MST_EIPRr_P_MST_DEDf_SET BCMI_MADURA_MST_EIPRr_P_MST_DEDf_SET
#define MST_EIPRr_P_MST_MSGOUT_INTRf_GET BCMI_MADURA_MST_EIPRr_P_MST_MSGOUT_INTRf_GET
#define MST_EIPRr_P_MST_MSGOUT_INTRf_SET BCMI_MADURA_MST_EIPRr_P_MST_MSGOUT_INTRf_SET
#define MST_EIPRr_P_MST_MISC_INTRf_GET BCMI_MADURA_MST_EIPRr_P_MST_MISC_INTRf_GET
#define MST_EIPRr_P_MST_MISC_INTRf_SET BCMI_MADURA_MST_EIPRr_P_MST_MISC_INTRf_SET
#define MST_EIPRr_P_MST_LOCKUPf_GET BCMI_MADURA_MST_EIPRr_P_MST_LOCKUPf_GET
#define MST_EIPRr_P_MST_LOCKUPf_SET BCMI_MADURA_MST_EIPRr_P_MST_LOCKUPf_SET
#define MST_EIPRr_P_MST_SYSRESETREQf_GET BCMI_MADURA_MST_EIPRr_P_MST_SYSRESETREQf_GET
#define MST_EIPRr_P_MST_SYSRESETREQf_SET BCMI_MADURA_MST_EIPRr_P_MST_SYSRESETREQf_SET
#define READ_MST_EIPRr BCMI_MADURA_READ_MST_EIPRr
#define WRITE_MST_EIPRr BCMI_MADURA_WRITE_MST_EIPRr
#define MODIFY_MST_EIPRr BCMI_MADURA_MODIFY_MST_EIPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_EIPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_EIER
 * BLOCKS:   CTRL
 * REGADDR:  0x8b12
 * DEVAD:    1
 * DESC:     M0 Micro Master and Slave 1 External Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_MST_SYSRESETREQ 
 *     ENABLE_MST_LOCKUP 
 *     ENABLE_MST_MISC_INTR 
 *     ENABLE_MST_MSGOUT_INTR 
 *     ENABLE_MST_DED   
 *     ENABLE_MST_SEC   
 */
#define BCMI_MADURA_MST_EIERr (0x00018b12 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_EIERr_SIZE 4

/*
 * This structure should be used to declare and program MST_EIER.
 */
typedef union BCMI_MADURA_MST_EIERr_s {
	uint32_t v[1];
	uint32_t mst_eier[1];
	uint32_t _mst_eier;
} BCMI_MADURA_MST_EIERr_t;

#define BCMI_MADURA_MST_EIERr_CLR(r) (r).mst_eier[0] = 0
#define BCMI_MADURA_MST_EIERr_SET(r,d) (r).mst_eier[0] = d
#define BCMI_MADURA_MST_EIERr_GET(r) (r).mst_eier[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_SECf_GET(r) ((((r).mst_eier[0]) >> 5) & 0x1)
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_SECf_SET(r,f) (r).mst_eier[0]=(((r).mst_eier[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_DEDf_GET(r) ((((r).mst_eier[0]) >> 4) & 0x1)
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_DEDf_SET(r,f) (r).mst_eier[0]=(((r).mst_eier[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_MSGOUT_INTRf_GET(r) ((((r).mst_eier[0]) >> 3) & 0x1)
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_MSGOUT_INTRf_SET(r,f) (r).mst_eier[0]=(((r).mst_eier[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_MISC_INTRf_GET(r) ((((r).mst_eier[0]) >> 2) & 0x1)
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_MISC_INTRf_SET(r,f) (r).mst_eier[0]=(((r).mst_eier[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_LOCKUPf_GET(r) ((((r).mst_eier[0]) >> 1) & 0x1)
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_LOCKUPf_SET(r,f) (r).mst_eier[0]=(((r).mst_eier[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_SYSRESETREQf_GET(r) (((r).mst_eier[0]) & 0x1)
#define BCMI_MADURA_MST_EIERr_ENABLE_MST_SYSRESETREQf_SET(r,f) (r).mst_eier[0]=(((r).mst_eier[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MST_EIER.
 */
#define BCMI_MADURA_READ_MST_EIERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_EIERr,_r._mst_eier)
#define BCMI_MADURA_WRITE_MST_EIERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_EIERr,_r._mst_eier)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_EIERr BCMI_MADURA_MST_EIERr
#define MST_EIERr_SIZE BCMI_MADURA_MST_EIERr_SIZE
typedef BCMI_MADURA_MST_EIERr_t MST_EIERr_t;
#define MST_EIERr_CLR BCMI_MADURA_MST_EIERr_CLR
#define MST_EIERr_SET BCMI_MADURA_MST_EIERr_SET
#define MST_EIERr_GET BCMI_MADURA_MST_EIERr_GET
#define MST_EIERr_ENABLE_MST_SECf_GET BCMI_MADURA_MST_EIERr_ENABLE_MST_SECf_GET
#define MST_EIERr_ENABLE_MST_SECf_SET BCMI_MADURA_MST_EIERr_ENABLE_MST_SECf_SET
#define MST_EIERr_ENABLE_MST_DEDf_GET BCMI_MADURA_MST_EIERr_ENABLE_MST_DEDf_GET
#define MST_EIERr_ENABLE_MST_DEDf_SET BCMI_MADURA_MST_EIERr_ENABLE_MST_DEDf_SET
#define MST_EIERr_ENABLE_MST_MSGOUT_INTRf_GET BCMI_MADURA_MST_EIERr_ENABLE_MST_MSGOUT_INTRf_GET
#define MST_EIERr_ENABLE_MST_MSGOUT_INTRf_SET BCMI_MADURA_MST_EIERr_ENABLE_MST_MSGOUT_INTRf_SET
#define MST_EIERr_ENABLE_MST_MISC_INTRf_GET BCMI_MADURA_MST_EIERr_ENABLE_MST_MISC_INTRf_GET
#define MST_EIERr_ENABLE_MST_MISC_INTRf_SET BCMI_MADURA_MST_EIERr_ENABLE_MST_MISC_INTRf_SET
#define MST_EIERr_ENABLE_MST_LOCKUPf_GET BCMI_MADURA_MST_EIERr_ENABLE_MST_LOCKUPf_GET
#define MST_EIERr_ENABLE_MST_LOCKUPf_SET BCMI_MADURA_MST_EIERr_ENABLE_MST_LOCKUPf_SET
#define MST_EIERr_ENABLE_MST_SYSRESETREQf_GET BCMI_MADURA_MST_EIERr_ENABLE_MST_SYSRESETREQf_GET
#define MST_EIERr_ENABLE_MST_SYSRESETREQf_SET BCMI_MADURA_MST_EIERr_ENABLE_MST_SYSRESETREQf_SET
#define READ_MST_EIERr BCMI_MADURA_READ_MST_EIERr
#define WRITE_MST_EIERr BCMI_MADURA_WRITE_MST_EIERr
#define MODIFY_MST_EIERr BCMI_MADURA_MODIFY_MST_EIERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_EIERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_EISR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b13
 * DEVAD:    1
 * DESC:     PLL Lock External Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_FAL_1_PLL1_LOCK_LOST Line Falcon 1 PLL 1 Lock Lost Falling Edge Interrupt Status
 *     LIN_FAL_1_PLL1_LOCK_FOUND Line Falcon 1 PLL 1 Lock Found Rising Edge Interrupt Status
 *     LIN_FAL_1_PLL0_LOCK_LOST Line Falcon 1 PLL 0 Lock Lost Falling Edge Interrupt Status
 *     LIN_FAL_1_PLL0_LOCK_FOUND Line Falcon 1 PLL 0 Lock Found Rising Edge Interrupt Status
 *     LIN_FAL_0_PLL1_LOCK_LOST Line Falcon 0 PLL 1 Lock Lost Falling Edge Interrupt Status
 *     LIN_FAL_0_PLL1_LOCK_FOUND Line Falcon 0 PLL 1 Lock Found Rising Edge Interrupt Status
 *     LIN_FAL_0_PLL0_LOCK_LOST Line Falcon 0 PLL 0 Lock Lost Falling Edge Interrupt Status
 *     LIN_FAL_0_PLL0_LOCK_FOUND Line Falcon 0 PLL 0 Lock Found Rising Edge Interrupt Status
 *     SYS_FAL_1_PLL1_LOCK_LOST System Falcon 1 PLL 1 Lock Lost Falling Edge Interrupt Status
 *     SYS_FAL_1_PLL1_LOCK_FOUND System Falcon 1 PLL 1 Lock Found Rising Edge Interrupt Status
 *     SYS_FAL_1_PLL0_LOCK_LOST System Falcon 1 PLL 0 Lock Lost Falling Edge Interrupt Status
 *     SYS_FAL_1_PLL0_LOCK_FOUND System Falcon 1 PLL 0 Lock Found Rising Edge Interrupt Status
 *     SYS_FAL_0_PLL1_LOCK_LOST System Falcon 0 PLL 1 Lock Lost Falling Edge Interrupt Status
 *     SYS_FAL_0_PLL1_LOCK_FOUND System Falcon 0 PLL 1 Lock Found Rising Edge Interrupt Status
 *     SYS_FAL_0_PLL0_LOCK_LOST System Falcon 0 PLL 0 Lock Lost Falling Edge Interrupt Status
 *     SYS_FAL_0_PLL0_LOCK_FOUND System Falcon 0 PLL 0 Lock Found Rising Edge Interrupt Status
 */
#define BCMI_MADURA_PLL_EISRr (0x00018b13 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_EISRr_SIZE 4

/*
 * This structure should be used to declare and program PLL_EISR.
 */
typedef union BCMI_MADURA_PLL_EISRr_s {
	uint32_t v[1];
	uint32_t pll_eisr[1];
	uint32_t _pll_eisr;
} BCMI_MADURA_PLL_EISRr_t;

#define BCMI_MADURA_PLL_EISRr_CLR(r) (r).pll_eisr[0] = 0
#define BCMI_MADURA_PLL_EISRr_SET(r,d) (r).pll_eisr[0] = d
#define BCMI_MADURA_PLL_EISRr_GET(r) (r).pll_eisr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 15) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eisr[0]) >> 14) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 13) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eisr[0]) >> 12) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 11) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eisr[0]) >> 10) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 9) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eisr[0]) >> 8) & 0x1)
#define BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 7) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eisr[0]) >> 6) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 5) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eisr[0]) >> 4) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 3) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eisr[0]) >> 2) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eisr[0]) >> 1) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_LOSTf_GET(r) (((r).pll_eisr[0]) & 0x1)
#define BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eisr[0]=(((r).pll_eisr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_EISR.
 */
#define BCMI_MADURA_READ_PLL_EISRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_EISRr,_r._pll_eisr)
#define BCMI_MADURA_WRITE_PLL_EISRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_EISRr,_r._pll_eisr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_EISRr BCMI_MADURA_PLL_EISRr
#define PLL_EISRr_SIZE BCMI_MADURA_PLL_EISRr_SIZE
typedef BCMI_MADURA_PLL_EISRr_t PLL_EISRr_t;
#define PLL_EISRr_CLR BCMI_MADURA_PLL_EISRr_CLR
#define PLL_EISRr_SET BCMI_MADURA_PLL_EISRr_SET
#define PLL_EISRr_GET BCMI_MADURA_PLL_EISRr_GET
#define PLL_EISRr_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET
#define PLL_EISRr_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET
#define PLL_EISRr_SYS_FAL_0_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_LOSTf_GET
#define PLL_EISRr_SYS_FAL_0_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL0_LOCK_LOSTf_SET
#define PLL_EISRr_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET
#define PLL_EISRr_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET
#define PLL_EISRr_SYS_FAL_0_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_LOSTf_GET
#define PLL_EISRr_SYS_FAL_0_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_0_PLL1_LOCK_LOSTf_SET
#define PLL_EISRr_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET
#define PLL_EISRr_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET
#define PLL_EISRr_SYS_FAL_1_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_LOSTf_GET
#define PLL_EISRr_SYS_FAL_1_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL0_LOCK_LOSTf_SET
#define PLL_EISRr_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET
#define PLL_EISRr_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET
#define PLL_EISRr_SYS_FAL_1_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_LOSTf_GET
#define PLL_EISRr_SYS_FAL_1_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_SYS_FAL_1_PLL1_LOCK_LOSTf_SET
#define PLL_EISRr_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET
#define PLL_EISRr_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET
#define PLL_EISRr_LIN_FAL_0_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_LOSTf_GET
#define PLL_EISRr_LIN_FAL_0_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL0_LOCK_LOSTf_SET
#define PLL_EISRr_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET
#define PLL_EISRr_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET
#define PLL_EISRr_LIN_FAL_0_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_LOSTf_GET
#define PLL_EISRr_LIN_FAL_0_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_0_PLL1_LOCK_LOSTf_SET
#define PLL_EISRr_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET
#define PLL_EISRr_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET
#define PLL_EISRr_LIN_FAL_1_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_LOSTf_GET
#define PLL_EISRr_LIN_FAL_1_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL0_LOCK_LOSTf_SET
#define PLL_EISRr_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET
#define PLL_EISRr_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET
#define PLL_EISRr_LIN_FAL_1_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_LOSTf_GET
#define PLL_EISRr_LIN_FAL_1_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EISRr_LIN_FAL_1_PLL1_LOCK_LOSTf_SET
#define READ_PLL_EISRr BCMI_MADURA_READ_PLL_EISRr
#define WRITE_PLL_EISRr BCMI_MADURA_WRITE_PLL_EISRr
#define MODIFY_PLL_EISRr BCMI_MADURA_MODIFY_PLL_EISRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_EISRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_EIPR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b14
 * DEVAD:    1
 * DESC:     PLL Lock External Interrupt Pending
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P_LIN_FAL_1_PLL1_LOCK_LOST 1 = Pending Interrupt - Line Falcon 1 PLL 1 Lock Lost Pending Status
 *     P_LIN_FAL_1_PLL1_LOCK_FOUND 1 = Pending Interrupt - Line Falcon 1 PLL 1 Lock Found Pending Status
 *     P_LIN_FAL_1_PLL0_LOCK_LOST 1 = Pending Interrupt - Line Falcon 1 PLL 0 Lock Lost Pending Status
 *     P_LIN_FAL_1_PLL0_LOCK_FOUND 1 = Pending Interrupt - Line Falcon 1 PLL 0 Lock Found Pending Status
 *     P_LIN_FAL_0_PLL1_LOCK_LOST 1 = Pending Interrupt - Line Falcon 0 PLL 1 Lock Lost Pending Status
 *     P_LIN_FAL_0_PLL1_LOCK_FOUND 1 = Pending Interrupt - Line Falcon 0 PLL 1 Lock Found Pending Status
 *     P_LIN_FAL_0_PLL0_LOCK_LOST 1 = Pending Interrupt - Line Falcon 0 PLL 0 Lock Lost Pending Status
 *     P_LIN_FAL_0_PLL0_LOCK_FOUND 1 = Pending Interrupt - Line Falcon 0 PLL 0 Lock Found Pending Status
 *     P_SYS_FAL_1_PLL1_LOCK_LOST 1 = Pending Interrupt - System Falcon 1 PLL 1 Lock Lost Pending Status
 *     P_SYS_FAL_1_PLL1_LOCK_FOUND 1 = Pending Interrupt - System Falcon 1 PLL 1 Lock Found Pending Status
 *     P_SYS_FAL_1_PLL0_LOCK_LOST 1 = Pending Interrupt - System Falcon 1 PLL 0 Lock Lost Pending Status
 *     P_SYS_FAL_1_PLL0_LOCK_FOUND 1 = Pending Interrupt - System Falcon 1 PLL 0 Lock Found Pending Status
 *     P_SYS_FAL_0_PLL1_LOCK_LOST 1 = Pending Interrupt - System Falcon 0 PLL 1 Lock Lost Pending Status
 *     P_SYS_FAL_0_PLL1_LOCK_FOUND 1 = Pending Interrupt - System Falcon 0 PLL 1 Lock Found Pending Status
 *     P_SYS_FAL_0_PLL0_LOCK_LOST 1 = Pending Interrupt - System Falcon 0 PLL 0 Lock Lost Pending Status
 *     P_SYS_FAL_0_PLL0_LOCK_FOUND 1 = Pending Interrupt - System Falcon 0 PLL 0 Lock Found Pending Status
 */
#define BCMI_MADURA_PLL_EIPRr (0x00018b14 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_EIPRr_SIZE 4

/*
 * This structure should be used to declare and program PLL_EIPR.
 */
typedef union BCMI_MADURA_PLL_EIPRr_s {
	uint32_t v[1];
	uint32_t pll_eipr[1];
	uint32_t _pll_eipr;
} BCMI_MADURA_PLL_EIPRr_t;

#define BCMI_MADURA_PLL_EIPRr_CLR(r) (r).pll_eipr[0] = 0
#define BCMI_MADURA_PLL_EIPRr_SET(r,d) (r).pll_eipr[0] = d
#define BCMI_MADURA_PLL_EIPRr_GET(r) (r).pll_eipr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 15) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eipr[0]) >> 14) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 13) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eipr[0]) >> 12) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 11) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eipr[0]) >> 10) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 9) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eipr[0]) >> 8) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 7) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eipr[0]) >> 6) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 5) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eipr[0]) >> 4) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 3) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eipr[0]) >> 2) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eipr[0]) >> 1) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_LOSTf_GET(r) (((r).pll_eipr[0]) & 0x1)
#define BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eipr[0]=(((r).pll_eipr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_EIPR.
 */
#define BCMI_MADURA_READ_PLL_EIPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_EIPRr,_r._pll_eipr)
#define BCMI_MADURA_WRITE_PLL_EIPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_EIPRr,_r._pll_eipr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_EIPRr BCMI_MADURA_PLL_EIPRr
#define PLL_EIPRr_SIZE BCMI_MADURA_PLL_EIPRr_SIZE
typedef BCMI_MADURA_PLL_EIPRr_t PLL_EIPRr_t;
#define PLL_EIPRr_CLR BCMI_MADURA_PLL_EIPRr_CLR
#define PLL_EIPRr_SET BCMI_MADURA_PLL_EIPRr_SET
#define PLL_EIPRr_GET BCMI_MADURA_PLL_EIPRr_GET
#define PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_LOSTf_GET
#define PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL0_LOCK_LOSTf_SET
#define PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_LOSTf_GET
#define PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_0_PLL1_LOCK_LOSTf_SET
#define PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_LOSTf_GET
#define PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL0_LOCK_LOSTf_SET
#define PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_LOSTf_GET
#define PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_SYS_FAL_1_PLL1_LOCK_LOSTf_SET
#define PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_LOSTf_GET
#define PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL0_LOCK_LOSTf_SET
#define PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_LOSTf_GET
#define PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_0_PLL1_LOCK_LOSTf_SET
#define PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_LOSTf_GET
#define PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL0_LOCK_LOSTf_SET
#define PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET
#define PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET
#define PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_LOSTf_GET
#define PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIPRr_P_LIN_FAL_1_PLL1_LOCK_LOSTf_SET
#define READ_PLL_EIPRr BCMI_MADURA_READ_PLL_EIPRr
#define WRITE_PLL_EIPRr BCMI_MADURA_WRITE_PLL_EIPRr
#define MODIFY_PLL_EIPRr BCMI_MADURA_MODIFY_PLL_EIPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_EIPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_EIER
 * BLOCKS:   CTRL
 * REGADDR:  0x8b15
 * DEVAD:    1
 * DESC:     PLL Lock External Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_LIN_FAL_1_PLL1_LOCK_LOST Line Falcon 1 PLL 1 Lock Lost Enable
 *     ENABLE_LIN_FAL_1_PLL1_LOCK_FOUND Line Falcon 1 PLL 1 Lock Found Enable
 *     ENABLE_LIN_FAL_1_PLL0_LOCK_LOST Line Falcon 1 PLL 0 Lock Lost Enable
 *     ENABLE_LIN_FAL_1_PLL0_LOCK_FOUND Line Falcon 1 PLL 0 Lock Found Enable
 *     ENABLE_LIN_FAL_0_PLL1_LOCK_LOST Line Falcon 0 PLL 1 Lock Lost Enable
 *     ENABLE_LIN_FAL_0_PLL1_LOCK_FOUND Line Falcon 0 PLL 1 Lock Found Enable
 *     ENABLE_LIN_FAL_0_PLL0_LOCK_LOST Line Falcon 0 PLL 0 Lock Lost Enable
 *     ENABLE_LIN_FAL_0_PLL0_LOCK_FOUND Line Falcon 0 PLL 0 Lock Found Enable
 *     ENABLE_SYS_FAL_1_PLL1_LOCK_LOST System Falcon 1 PLL 1 Lock Lost Enable
 *     ENABLE_SYS_FAL_1_PLL1_LOCK_FOUND System Falcon 1 PLL 1 Lock Found Enable
 *     ENABLE_SYS_FAL_1_PLL0_LOCK_LOST System Falcon 1 PLL 0 Lock Lost Enable
 *     ENABLE_SYS_FAL_1_PLL0_LOCK_FOUND System Falcon 1 PLL 0 Lock Found Enable
 *     ENABLE_SYS_FAL_0_PLL1_LOCK_LOST System Falcon 0 PLL 1 Lock Lost Enable
 *     ENABLE_SYS_FAL_0_PLL1_LOCK_FOUND System Falcon 0 PLL 1 Lock Found Enable
 *     ENABLE_SYS_FAL_0_PLL0_LOCK_LOST System Falcon 0 PLL 0 Lock Lost Enable
 *     ENABLE_SYS_FAL_0_PLL0_LOCK_FOUND System Falcon 0 PLL 0 Lock Found Enable
 */
#define BCMI_MADURA_PLL_EIERr (0x00018b15 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_EIERr_SIZE 4

/*
 * This structure should be used to declare and program PLL_EIER.
 */
typedef union BCMI_MADURA_PLL_EIERr_s {
	uint32_t v[1];
	uint32_t pll_eier[1];
	uint32_t _pll_eier;
} BCMI_MADURA_PLL_EIERr_t;

#define BCMI_MADURA_PLL_EIERr_CLR(r) (r).pll_eier[0] = 0
#define BCMI_MADURA_PLL_EIERr_SET(r,d) (r).pll_eier[0] = d
#define BCMI_MADURA_PLL_EIERr_GET(r) (r).pll_eier[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 15) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eier[0]) >> 14) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 13) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eier[0]) >> 12) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 11) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eier[0]) >> 10) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 9) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eier[0]) >> 8) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 7) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eier[0]) >> 6) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 5) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_LOSTf_GET(r) ((((r).pll_eier[0]) >> 4) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 3) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_LOSTf_GET(r) ((((r).pll_eier[0]) >> 2) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET(r) ((((r).pll_eier[0]) >> 1) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_LOSTf_GET(r) (((r).pll_eier[0]) & 0x1)
#define BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_LOSTf_SET(r,f) (r).pll_eier[0]=(((r).pll_eier[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_EIER.
 */
#define BCMI_MADURA_READ_PLL_EIERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_EIERr,_r._pll_eier)
#define BCMI_MADURA_WRITE_PLL_EIERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_EIERr,_r._pll_eier)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_EIERr BCMI_MADURA_PLL_EIERr
#define PLL_EIERr_SIZE BCMI_MADURA_PLL_EIERr_SIZE
typedef BCMI_MADURA_PLL_EIERr_t PLL_EIERr_t;
#define PLL_EIERr_CLR BCMI_MADURA_PLL_EIERr_CLR
#define PLL_EIERr_SET BCMI_MADURA_PLL_EIERr_SET
#define PLL_EIERr_GET BCMI_MADURA_PLL_EIERr_GET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL0_LOCK_LOSTf_SET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_0_PLL1_LOCK_LOSTf_SET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL0_LOCK_LOSTf_SET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_SYS_FAL_1_PLL1_LOCK_LOSTf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL0_LOCK_LOSTf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_0_PLL1_LOCK_LOSTf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL0_LOCK_LOSTf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_FOUNDf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_FOUNDf_SET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_LOSTf_GET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_LOSTf_GET
#define PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_LOSTf_SET BCMI_MADURA_PLL_EIERr_ENABLE_LIN_FAL_1_PLL1_LOCK_LOSTf_SET
#define READ_PLL_EIERr BCMI_MADURA_READ_PLL_EIERr
#define WRITE_PLL_EIERr BCMI_MADURA_WRITE_PLL_EIERr
#define MODIFY_PLL_EIERr BCMI_MADURA_MODIFY_PLL_EIERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_EIERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_EISR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b16
 * DEVAD:    1
 * DESC:     Clause 73 External Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_CL73_AN_RESTARTED_P2 Line Side cl73 auto neg restarted p2 Rising Edge Interrupt Status
 *     LIN_CL73_AN_COMPLETE_P2 Line Side cl73 auto neg complete p2 Rising Edge Interrupt Status
 *     LIN_CL73_AN_RESTARTED_P1 Line Side cl73 auto neg restarted p1 Rising Edge Interrupt Status
 *     LIN_CL73_AN_COMPLETE_P1 Line Side cl73 auto neg complete p1 Rising Edge Interrupt Status
 *     LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1 Line Side cl73 Link Fail Inhibit Timer done 1 Rising Edge Interrupt Status
 *     LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0 Line Side cl73 Link Fail Inhibit Timer done 0 Rising Edge Interrupt Status
 *     LIN_CL73_INCOMPATIBLE_LINK_1 Line Side cl73 Incompatible Link 1 Rising Edge Interrupt Status
 *     LIN_CL73_INCOMPATIBLE_LINK_0 Line Side cl73 Incompatible Link 0 Rising Edge Interrupt Status
 *     SYS_CL73_AN_RESTARTED_P2 System Side cl73 auto neg restarted p2 Rising Edge Interrupt Status
 *     SYS_CL73_AN_COMPLETE_P2 System Side cl73 auto neg complete p2 Rising Edge Interrupt Status
 *     SYS_CL73_AN_RESTARTED_P1 System Side cl73 auto neg restarted p1 Rising Edge Interrupt Status
 *     SYS_CL73_AN_COMPLETE_P1 System Side cl73 auto neg complete p1 Rising Edge Interrupt Status
 *     SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1 System Side cl73 Link Fail Inhibit Timer done 1 Rising Edge Interrupt Status
 *     SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0 System Side cl73 Link Fail Inhibit Timer done 0 Rising Edge Interrupt Status
 *     SYS_CL73_INCOMPATIBLE_LINK_1 System Side cl73 Incompatible Link 1 Rising Edge Interrupt Status
 *     SYS_CL73_INCOMPATIBLE_LINK_0 System Side cl73 Incompatible Link 0 Rising Edge Interrupt Status
 */
#define BCMI_MADURA_CL73_EISRr (0x00018b16 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_EISRr_SIZE 4

/*
 * This structure should be used to declare and program CL73_EISR.
 */
typedef union BCMI_MADURA_CL73_EISRr_s {
	uint32_t v[1];
	uint32_t cl73_eisr[1];
	uint32_t _cl73_eisr;
} BCMI_MADURA_CL73_EISRr_t;

#define BCMI_MADURA_CL73_EISRr_CLR(r) (r).cl73_eisr[0] = 0
#define BCMI_MADURA_CL73_EISRr_SET(r,d) (r).cl73_eisr[0] = d
#define BCMI_MADURA_CL73_EISRr_GET(r) (r).cl73_eisr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_0f_GET(r) ((((r).cl73_eisr[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_0f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_1f_GET(r) ((((r).cl73_eisr[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET(r) ((((r).cl73_eisr[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET(r) ((((r).cl73_eisr[0]) >> 12) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P1f_GET(r) ((((r).cl73_eisr[0]) >> 11) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P1f_GET(r) ((((r).cl73_eisr[0]) >> 10) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P2f_GET(r) ((((r).cl73_eisr[0]) >> 9) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P2f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P2f_GET(r) ((((r).cl73_eisr[0]) >> 8) & 0x1)
#define BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P2f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_0f_GET(r) ((((r).cl73_eisr[0]) >> 7) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_0f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_1f_GET(r) ((((r).cl73_eisr[0]) >> 6) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET(r) ((((r).cl73_eisr[0]) >> 5) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET(r) ((((r).cl73_eisr[0]) >> 4) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P1f_GET(r) ((((r).cl73_eisr[0]) >> 3) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P1f_GET(r) ((((r).cl73_eisr[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P1f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P2f_GET(r) ((((r).cl73_eisr[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P2f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P2f_GET(r) (((r).cl73_eisr[0]) & 0x1)
#define BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P2f_SET(r,f) (r).cl73_eisr[0]=(((r).cl73_eisr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL73_EISR.
 */
#define BCMI_MADURA_READ_CL73_EISRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_EISRr,_r._cl73_eisr)
#define BCMI_MADURA_WRITE_CL73_EISRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_EISRr,_r._cl73_eisr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_EISRr BCMI_MADURA_CL73_EISRr
#define CL73_EISRr_SIZE BCMI_MADURA_CL73_EISRr_SIZE
typedef BCMI_MADURA_CL73_EISRr_t CL73_EISRr_t;
#define CL73_EISRr_CLR BCMI_MADURA_CL73_EISRr_CLR
#define CL73_EISRr_SET BCMI_MADURA_CL73_EISRr_SET
#define CL73_EISRr_GET BCMI_MADURA_CL73_EISRr_GET
#define CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_0f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_0f_GET
#define CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_0f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_0f_SET
#define CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_1f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_1f_GET
#define CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_1f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_INCOMPATIBLE_LINK_1f_SET
#define CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET
#define CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET
#define CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET
#define CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET
#define CL73_EISRr_SYS_CL73_AN_COMPLETE_P1f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P1f_GET
#define CL73_EISRr_SYS_CL73_AN_COMPLETE_P1f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P1f_SET
#define CL73_EISRr_SYS_CL73_AN_RESTARTED_P1f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P1f_GET
#define CL73_EISRr_SYS_CL73_AN_RESTARTED_P1f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P1f_SET
#define CL73_EISRr_SYS_CL73_AN_COMPLETE_P2f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P2f_GET
#define CL73_EISRr_SYS_CL73_AN_COMPLETE_P2f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_COMPLETE_P2f_SET
#define CL73_EISRr_SYS_CL73_AN_RESTARTED_P2f_GET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P2f_GET
#define CL73_EISRr_SYS_CL73_AN_RESTARTED_P2f_SET BCMI_MADURA_CL73_EISRr_SYS_CL73_AN_RESTARTED_P2f_SET
#define CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_0f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_0f_GET
#define CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_0f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_0f_SET
#define CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_1f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_1f_GET
#define CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_1f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_INCOMPATIBLE_LINK_1f_SET
#define CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET
#define CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET
#define CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET
#define CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET
#define CL73_EISRr_LIN_CL73_AN_COMPLETE_P1f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P1f_GET
#define CL73_EISRr_LIN_CL73_AN_COMPLETE_P1f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P1f_SET
#define CL73_EISRr_LIN_CL73_AN_RESTARTED_P1f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P1f_GET
#define CL73_EISRr_LIN_CL73_AN_RESTARTED_P1f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P1f_SET
#define CL73_EISRr_LIN_CL73_AN_COMPLETE_P2f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P2f_GET
#define CL73_EISRr_LIN_CL73_AN_COMPLETE_P2f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_COMPLETE_P2f_SET
#define CL73_EISRr_LIN_CL73_AN_RESTARTED_P2f_GET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P2f_GET
#define CL73_EISRr_LIN_CL73_AN_RESTARTED_P2f_SET BCMI_MADURA_CL73_EISRr_LIN_CL73_AN_RESTARTED_P2f_SET
#define READ_CL73_EISRr BCMI_MADURA_READ_CL73_EISRr
#define WRITE_CL73_EISRr BCMI_MADURA_WRITE_CL73_EISRr
#define MODIFY_CL73_EISRr BCMI_MADURA_MODIFY_CL73_EISRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_EISRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_EIPR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b17
 * DEVAD:    1
 * DESC:     Clause 73 External Interrupt Pending
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P_LIN_CL73_AN_RESTARTED_P2 1 = Pending Interrupt - Line Side cl73 auto neg restarted p2 Pending Status
 *     P_LIN_CL73_AN_COMPLETE_P2 1 = Pending Interrupt - Line Side cl73 auto neg complete p2 Pending Status
 *     P_LIN_CL73_AN_RESTARTED_P1 1 = Pending Interrupt - Line Side cl73 auto neg restarted p1 Pending Status
 *     P_LIN_CL73_AN_COMPLETE_P1 1 = Pending Interrupt - Line Side cl73 auto neg complete p1 Pending Status
 *     P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1 1 = Pending Interrupt - Line Side cl73 Link Fail Inhibit Timer done 1 Pending Status
 *     P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0 1 = Pending Interrupt - Line Side cl73 Link Fail Inhibit Timer done 0 Pending Status
 *     P_LIN_CL73_INCOMPATIBLE_LINK_1 1 = Pending Interrupt - Line Side cl73 Incompatible Link 1 Pending Status
 *     P_LIN_CL73_INCOMPATIBLE_LINK_0 1 = Pending Interrupt - Line Side cl73 Incompatible Link 0 Pending Status
 *     P_SYS_CL73_AN_RESTARTED_P2 1 = Pending Interrupt - System Side cl73 auto neg restarted p2 Pending Status
 *     P_SYS_CL73_AN_COMPLETE_P2 1 = Pending Interrupt - System Side cl73 auto neg complete p2 Pending Status
 *     P_SYS_CL73_AN_RESTARTED_P1 1 = Pending Interrupt - System Side cl73 auto neg restarted p1 Pending Status
 *     P_SYS_CL73_AN_COMPLETE_P1 1 = Pending Interrupt - System Side cl73 auto neg complete p1 Pending Status
 *     P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1 1 = Pending Interrupt - System Side cl73 Link Fail Inhibit Timer done 1 Pending Status
 *     P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0 1 = Pending Interrupt - System Side cl73 Link Fail Inhibit Timer done 0 Pending Status
 *     P_SYS_CL73_INCOMPATIBLE_LINK_1 1 = Pending Interrupt - System Side cl73 Incompatible Link 1 Pending Status
 *     P_SYS_CL73_INCOMPATIBLE_LINK_0 1 = Pending Interrupt - System Side cl73 Incompatible Link 0 Pending Status
 */
#define BCMI_MADURA_CL73_EIPRr (0x00018b17 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_EIPRr_SIZE 4

/*
 * This structure should be used to declare and program CL73_EIPR.
 */
typedef union BCMI_MADURA_CL73_EIPRr_s {
	uint32_t v[1];
	uint32_t cl73_eipr[1];
	uint32_t _cl73_eipr;
} BCMI_MADURA_CL73_EIPRr_t;

#define BCMI_MADURA_CL73_EIPRr_CLR(r) (r).cl73_eipr[0] = 0
#define BCMI_MADURA_CL73_EIPRr_SET(r,d) (r).cl73_eipr[0] = d
#define BCMI_MADURA_CL73_EIPRr_GET(r) (r).cl73_eipr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_0f_GET(r) ((((r).cl73_eipr[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_0f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_1f_GET(r) ((((r).cl73_eipr[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET(r) ((((r).cl73_eipr[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET(r) ((((r).cl73_eipr[0]) >> 12) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P1f_GET(r) ((((r).cl73_eipr[0]) >> 11) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P1f_GET(r) ((((r).cl73_eipr[0]) >> 10) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P2f_GET(r) ((((r).cl73_eipr[0]) >> 9) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P2f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P2f_GET(r) ((((r).cl73_eipr[0]) >> 8) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P2f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_0f_GET(r) ((((r).cl73_eipr[0]) >> 7) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_0f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_1f_GET(r) ((((r).cl73_eipr[0]) >> 6) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET(r) ((((r).cl73_eipr[0]) >> 5) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET(r) ((((r).cl73_eipr[0]) >> 4) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P1f_GET(r) ((((r).cl73_eipr[0]) >> 3) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P1f_GET(r) ((((r).cl73_eipr[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P1f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P2f_GET(r) ((((r).cl73_eipr[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P2f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P2f_GET(r) (((r).cl73_eipr[0]) & 0x1)
#define BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P2f_SET(r,f) (r).cl73_eipr[0]=(((r).cl73_eipr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL73_EIPR.
 */
#define BCMI_MADURA_READ_CL73_EIPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_EIPRr,_r._cl73_eipr)
#define BCMI_MADURA_WRITE_CL73_EIPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_EIPRr,_r._cl73_eipr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_EIPRr BCMI_MADURA_CL73_EIPRr
#define CL73_EIPRr_SIZE BCMI_MADURA_CL73_EIPRr_SIZE
typedef BCMI_MADURA_CL73_EIPRr_t CL73_EIPRr_t;
#define CL73_EIPRr_CLR BCMI_MADURA_CL73_EIPRr_CLR
#define CL73_EIPRr_SET BCMI_MADURA_CL73_EIPRr_SET
#define CL73_EIPRr_GET BCMI_MADURA_CL73_EIPRr_GET
#define CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_0f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_0f_GET
#define CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_0f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_0f_SET
#define CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_1f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_1f_GET
#define CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_1f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_INCOMPATIBLE_LINK_1f_SET
#define CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET
#define CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET
#define CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET
#define CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET
#define CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P1f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P1f_GET
#define CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P1f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P1f_SET
#define CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P1f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P1f_GET
#define CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P1f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P1f_SET
#define CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P2f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P2f_GET
#define CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P2f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_COMPLETE_P2f_SET
#define CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P2f_GET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P2f_GET
#define CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P2f_SET BCMI_MADURA_CL73_EIPRr_P_SYS_CL73_AN_RESTARTED_P2f_SET
#define CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_0f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_0f_GET
#define CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_0f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_0f_SET
#define CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_1f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_1f_GET
#define CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_1f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_INCOMPATIBLE_LINK_1f_SET
#define CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET
#define CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET
#define CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET
#define CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET
#define CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P1f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P1f_GET
#define CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P1f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P1f_SET
#define CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P1f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P1f_GET
#define CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P1f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P1f_SET
#define CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P2f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P2f_GET
#define CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P2f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_COMPLETE_P2f_SET
#define CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P2f_GET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P2f_GET
#define CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P2f_SET BCMI_MADURA_CL73_EIPRr_P_LIN_CL73_AN_RESTARTED_P2f_SET
#define READ_CL73_EIPRr BCMI_MADURA_READ_CL73_EIPRr
#define WRITE_CL73_EIPRr BCMI_MADURA_WRITE_CL73_EIPRr
#define MODIFY_CL73_EIPRr BCMI_MADURA_MODIFY_CL73_EIPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_EIPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_EIER
 * BLOCKS:   CTRL
 * REGADDR:  0x8b18
 * DEVAD:    1
 * DESC:     Clause 73 External Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_LIN_CL73_AN_RESTARTED_P2 Line Side cl73 auto neg restarted p2 Enable
 *     ENABLE_LIN_CL73_AN_COMPLETE_P2 Line Side cl73 auto neg complete p2 Enable
 *     ENABLE_LIN_CL73_AN_RESTARTED_P1 Line Side cl73 auto neg restarted p1 Enable
 *     ENABLE_LIN_CL73_AN_COMPLETE_P1 Line Side cl73 auto neg complete p1 Enable
 *     ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1 Line Side cl73 Link Fail Inhibit Timer done 1 Enable
 *     ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0 Line Side cl73 Link Fail Inhibit Timer done 0 Enable
 *     ENABLE_LIN_CL73_INCOMPATIBLE_LINK_1 Line Side cl73 Incompatible Link 1 Enable
 *     ENABLE_LIN_CL73_INCOMPATIBLE_LINK_0 Line Side cl73 Incompatible Link 0 Enable
 *     ENABLE_SYS_CL73_AN_RESTARTED_P2 System Side cl73 auto neg restarted p2 Enable
 *     ENABLE_SYS_CL73_AN_COMPLETE_P2 System Side cl73 auto neg complete p2 Enable
 *     ENABLE_SYS_CL73_AN_RESTARTED_P1 System Side cl73 auto neg restarted p1 Enable
 *     ENABLE_SYS_CL73_AN_COMPLETE_P1 System Side cl73 auto neg complete p1 Enable
 *     ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1 System Side cl73 Link Fail Inhibit Timer done 1 Enable
 *     ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0 System Side cl73 Link Fail Inhibit Timer done 0 Enable
 *     ENABLE_SYS_CL73_INCOMPATIBLE_LINK_1 System Side cl73 Incompatible Link 1 Enable
 *     ENABLE_SYS_CL73_INCOMPATIBLE_LINK_0 System Side cl73 Incompatible Link 0 Enable
 */
#define BCMI_MADURA_CL73_EIERr (0x00018b18 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_EIERr_SIZE 4

/*
 * This structure should be used to declare and program CL73_EIER.
 */
typedef union BCMI_MADURA_CL73_EIERr_s {
	uint32_t v[1];
	uint32_t cl73_eier[1];
	uint32_t _cl73_eier;
} BCMI_MADURA_CL73_EIERr_t;

#define BCMI_MADURA_CL73_EIERr_CLR(r) (r).cl73_eier[0] = 0
#define BCMI_MADURA_CL73_EIERr_SET(r,d) (r).cl73_eier[0] = d
#define BCMI_MADURA_CL73_EIERr_GET(r) (r).cl73_eier[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_0f_GET(r) ((((r).cl73_eier[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_0f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_1f_GET(r) ((((r).cl73_eier[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET(r) ((((r).cl73_eier[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET(r) ((((r).cl73_eier[0]) >> 12) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P1f_GET(r) ((((r).cl73_eier[0]) >> 11) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P1f_GET(r) ((((r).cl73_eier[0]) >> 10) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P2f_GET(r) ((((r).cl73_eier[0]) >> 9) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P2f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P2f_GET(r) ((((r).cl73_eier[0]) >> 8) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P2f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_0f_GET(r) ((((r).cl73_eier[0]) >> 7) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_0f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_1f_GET(r) ((((r).cl73_eier[0]) >> 6) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET(r) ((((r).cl73_eier[0]) >> 5) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET(r) ((((r).cl73_eier[0]) >> 4) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P1f_GET(r) ((((r).cl73_eier[0]) >> 3) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P1f_GET(r) ((((r).cl73_eier[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P1f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P2f_GET(r) ((((r).cl73_eier[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P2f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P2f_GET(r) (((r).cl73_eier[0]) & 0x1)
#define BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P2f_SET(r,f) (r).cl73_eier[0]=(((r).cl73_eier[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL73_EIER.
 */
#define BCMI_MADURA_READ_CL73_EIERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_EIERr,_r._cl73_eier)
#define BCMI_MADURA_WRITE_CL73_EIERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_EIERr,_r._cl73_eier)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_EIERr BCMI_MADURA_CL73_EIERr
#define CL73_EIERr_SIZE BCMI_MADURA_CL73_EIERr_SIZE
typedef BCMI_MADURA_CL73_EIERr_t CL73_EIERr_t;
#define CL73_EIERr_CLR BCMI_MADURA_CL73_EIERr_CLR
#define CL73_EIERr_SET BCMI_MADURA_CL73_EIERr_SET
#define CL73_EIERr_GET BCMI_MADURA_CL73_EIERr_GET
#define CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_0f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_0f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_0f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_0f_SET
#define CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_1f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_INCOMPATIBLE_LINK_1f_SET
#define CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET
#define CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P1f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P1f_SET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P1f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P1f_SET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P2f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P2f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P2f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_COMPLETE_P2f_SET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P2f_GET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P2f_GET
#define CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P2f_SET BCMI_MADURA_CL73_EIERr_ENABLE_SYS_CL73_AN_RESTARTED_P2f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_0f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_0f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_0f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_0f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_1f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_INCOMPATIBLE_LINK_1f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_0f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_LINK_FAIL_INHIBIT_TIMER_DONE_1f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P1f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P1f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P1f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P1f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P1f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P1f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P2f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P2f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P2f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_COMPLETE_P2f_SET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P2f_GET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P2f_GET
#define CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P2f_SET BCMI_MADURA_CL73_EIERr_ENABLE_LIN_CL73_AN_RESTARTED_P2f_SET
#define READ_CL73_EIERr BCMI_MADURA_READ_CL73_EIERr
#define WRITE_CL73_EIERr BCMI_MADURA_WRITE_CL73_EIERr
#define MODIFY_CL73_EIERr BCMI_MADURA_MODIFY_CL73_EIERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_EIERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISC0_EISR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b19
 * DEVAD:    1
 * DESC:     Miscellaneous 0 External Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_FAL_1_PMI_ARB_WDOG_EXP Not used - TIE_LOW - Line Side Falcon 1 PMI-ARB Watchdog Expired On No Ack Rising Edge Interrupt Status
 *     LIN_FAL_0_PMI_ARB_WDOG_EXP Not used - TIE_LOW - Line Side Falcon 0 PMI-ARB Watchdog Expired On No Ack Rising Edge Interrupt Status
 *     LIN_PMD_LOCK_LOST Line Side PMD Lock Lost Falling Edge Interrupt Status
 *     LIN_PMD_LOCK_FOUND Line Side PMD Lock Found Rising Edge Interrupt Status
 *     LIN_SIGDET_LOST  Line Side Signal Detect Lost Falling Edge Interrupt Status
 *     LIN_SIGDET_FOUND Line Side Signal Detect Found Rising Edge Interrupt Status
 *     SYS_FAL_1_PMI_ARB_WDOG_EXP Not used - TIE_LOW - System Side Falcon 1 PMI-ARB Watchdog Expired On No Ack Rising Edge Interrupt Status
 *     SYS_FAL_0_PMI_ARB_WDOG_EXP Replaced by fal_pmi_lp_en_squelch - System Side Falcon 0 PMI-ARB Watchdog Expired On Rising Edge Interrupt No Ack Status
 *     SYS_PMD_LOCK_LOST System Side PMD Lock Lost Falling Edge Interrupt Status
 *     SYS_PMD_LOCK_FOUND System Side PMD Lock Found Rising Edge Interrupt Status
 *     SYS_SIGDET_LOST  System Side Signal Detect Lost Falling Edge Interrupt Status
 *     SYS_SIGDET_FOUND System Side Signal Detect Found Rising Edge Interrupt Status
 */
#define BCMI_MADURA_MISC0_EISRr (0x00018b19 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISC0_EISRr_SIZE 4

/*
 * This structure should be used to declare and program MISC0_EISR.
 */
typedef union BCMI_MADURA_MISC0_EISRr_s {
	uint32_t v[1];
	uint32_t misc0_eisr[1];
	uint32_t _misc0_eisr;
} BCMI_MADURA_MISC0_EISRr_t;

#define BCMI_MADURA_MISC0_EISRr_CLR(r) (r).misc0_eisr[0] = 0
#define BCMI_MADURA_MISC0_EISRr_SET(r,d) (r).misc0_eisr[0] = d
#define BCMI_MADURA_MISC0_EISRr_GET(r) (r).misc0_eisr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_FOUNDf_GET(r) ((((r).misc0_eisr[0]) >> 11) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_FOUNDf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_LOSTf_GET(r) ((((r).misc0_eisr[0]) >> 10) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_LOSTf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_FOUNDf_GET(r) ((((r).misc0_eisr[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_FOUNDf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_LOSTf_GET(r) ((((r).misc0_eisr[0]) >> 8) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_LOSTf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MISC0_EISRr_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eisr[0]) >> 7) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MISC0_EISRr_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eisr[0]) >> 6) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_FOUNDf_GET(r) ((((r).misc0_eisr[0]) >> 5) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_FOUNDf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_LOSTf_GET(r) ((((r).misc0_eisr[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_LOSTf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_FOUNDf_GET(r) ((((r).misc0_eisr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_FOUNDf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_LOSTf_GET(r) ((((r).misc0_eisr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_LOSTf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISC0_EISRr_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eisr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISC0_EISRr_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET(r) (((r).misc0_eisr[0]) & 0x1)
#define BCMI_MADURA_MISC0_EISRr_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eisr[0]=(((r).misc0_eisr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC0_EISR.
 */
#define BCMI_MADURA_READ_MISC0_EISRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISC0_EISRr,_r._misc0_eisr)
#define BCMI_MADURA_WRITE_MISC0_EISRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISC0_EISRr,_r._misc0_eisr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC0_EISRr BCMI_MADURA_MISC0_EISRr
#define MISC0_EISRr_SIZE BCMI_MADURA_MISC0_EISRr_SIZE
typedef BCMI_MADURA_MISC0_EISRr_t MISC0_EISRr_t;
#define MISC0_EISRr_CLR BCMI_MADURA_MISC0_EISRr_CLR
#define MISC0_EISRr_SET BCMI_MADURA_MISC0_EISRr_SET
#define MISC0_EISRr_GET BCMI_MADURA_MISC0_EISRr_GET
#define MISC0_EISRr_SYS_SIGDET_FOUNDf_GET BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_FOUNDf_GET
#define MISC0_EISRr_SYS_SIGDET_FOUNDf_SET BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_FOUNDf_SET
#define MISC0_EISRr_SYS_SIGDET_LOSTf_GET BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_LOSTf_GET
#define MISC0_EISRr_SYS_SIGDET_LOSTf_SET BCMI_MADURA_MISC0_EISRr_SYS_SIGDET_LOSTf_SET
#define MISC0_EISRr_SYS_PMD_LOCK_FOUNDf_GET BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_FOUNDf_GET
#define MISC0_EISRr_SYS_PMD_LOCK_FOUNDf_SET BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_FOUNDf_SET
#define MISC0_EISRr_SYS_PMD_LOCK_LOSTf_GET BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_LOSTf_GET
#define MISC0_EISRr_SYS_PMD_LOCK_LOSTf_SET BCMI_MADURA_MISC0_EISRr_SYS_PMD_LOCK_LOSTf_SET
#define MISC0_EISRr_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EISRr_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EISRr_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EISRr_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EISRr_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EISRr_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EISRr_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EISRr_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EISRr_LIN_SIGDET_FOUNDf_GET BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_FOUNDf_GET
#define MISC0_EISRr_LIN_SIGDET_FOUNDf_SET BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_FOUNDf_SET
#define MISC0_EISRr_LIN_SIGDET_LOSTf_GET BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_LOSTf_GET
#define MISC0_EISRr_LIN_SIGDET_LOSTf_SET BCMI_MADURA_MISC0_EISRr_LIN_SIGDET_LOSTf_SET
#define MISC0_EISRr_LIN_PMD_LOCK_FOUNDf_GET BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_FOUNDf_GET
#define MISC0_EISRr_LIN_PMD_LOCK_FOUNDf_SET BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_FOUNDf_SET
#define MISC0_EISRr_LIN_PMD_LOCK_LOSTf_GET BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_LOSTf_GET
#define MISC0_EISRr_LIN_PMD_LOCK_LOSTf_SET BCMI_MADURA_MISC0_EISRr_LIN_PMD_LOCK_LOSTf_SET
#define MISC0_EISRr_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EISRr_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EISRr_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EISRr_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EISRr_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EISRr_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EISRr_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EISRr_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET
#define READ_MISC0_EISRr BCMI_MADURA_READ_MISC0_EISRr
#define WRITE_MISC0_EISRr BCMI_MADURA_WRITE_MISC0_EISRr
#define MODIFY_MISC0_EISRr BCMI_MADURA_MODIFY_MISC0_EISRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISC0_EISRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISC0_EIPR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b1a
 * DEVAD:    1
 * DESC:     Miscellaneous 0 External Interrupt Pending
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P_LIN_FAL_1_PMI_ARB_WDOG_EXP 1 = Pending Interrupt - Line Side Falcon 1 PMI-ARB Watchdog Expired On No Ack Pending Status
 *     P_LIN_FAL_0_PMI_ARB_WDOG_EXP 1 = Pending Interrupt - Line Side Falcon 0 PMI-ARB Watchdog Expired On No Ack Pending Status
 *     P_LIN_PMD_LOCK_LOST 1 = Pending Interrupt - Line Side PMD Lock Lost Pending Status
 *     P_LIN_PMD_LOCK_FOUND 1 = Pending Interrupt - Line Side PMD Lock Found Pending Status
 *     P_LIN_SIGDET_LOST 1 = Pending Interrupt - Line Side Signal Detect Lost Pending Status
 *     P_LIN_SIGDET_FOUND 1 = Pending Interrupt - Line Side Signal Detect Found Pending Status
 *     P_SYS_FAL_1_PMI_ARB_WDOG_EXP 1 = Pending Interrupt - System Side Falcon 1 PMI-ARB Watchdog Expired On No Ack Pending Status
 *     P_SYS_FAL_0_PMI_ARB_WDOG_EXP 1 = Pending Interrupt - System Side Falcon 0 PMI-ARB Watchdog Expired On No Ack Pending Status
 *     P_SYS_PMD_LOCK_LOST 1 = Pending Interrupt - System Side PMD Lock Lost Pending Status
 *     P_SYS_PMD_LOCK_FOUND 1 = Pending Interrupt - System Side PMD Lock Found Pending Status
 *     P_SYS_SIGDET_LOST 1 = Pending Interrupt - System Side Signal Detect Lost Pending Status
 *     P_SYS_SIGDET_FOUND 1 = Pending Interrupt - System Side Signal Detect Found Pending Status
 */
#define BCMI_MADURA_MISC0_EIPRr (0x00018b1a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISC0_EIPRr_SIZE 4

/*
 * This structure should be used to declare and program MISC0_EIPR.
 */
typedef union BCMI_MADURA_MISC0_EIPRr_s {
	uint32_t v[1];
	uint32_t misc0_eipr[1];
	uint32_t _misc0_eipr;
} BCMI_MADURA_MISC0_EIPRr_t;

#define BCMI_MADURA_MISC0_EIPRr_CLR(r) (r).misc0_eipr[0] = 0
#define BCMI_MADURA_MISC0_EIPRr_SET(r,d) (r).misc0_eipr[0] = d
#define BCMI_MADURA_MISC0_EIPRr_GET(r) (r).misc0_eipr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_FOUNDf_GET(r) ((((r).misc0_eipr[0]) >> 11) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_FOUNDf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_LOSTf_GET(r) ((((r).misc0_eipr[0]) >> 10) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_LOSTf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_FOUNDf_GET(r) ((((r).misc0_eipr[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_FOUNDf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_LOSTf_GET(r) ((((r).misc0_eipr[0]) >> 8) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_LOSTf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eipr[0]) >> 7) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eipr[0]) >> 6) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_FOUNDf_GET(r) ((((r).misc0_eipr[0]) >> 5) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_FOUNDf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_LOSTf_GET(r) ((((r).misc0_eipr[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_LOSTf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_FOUNDf_GET(r) ((((r).misc0_eipr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_FOUNDf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_LOSTf_GET(r) ((((r).misc0_eipr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_LOSTf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eipr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET(r) (((r).misc0_eipr[0]) & 0x1)
#define BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eipr[0]=(((r).misc0_eipr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC0_EIPR.
 */
#define BCMI_MADURA_READ_MISC0_EIPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISC0_EIPRr,_r._misc0_eipr)
#define BCMI_MADURA_WRITE_MISC0_EIPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISC0_EIPRr,_r._misc0_eipr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC0_EIPRr BCMI_MADURA_MISC0_EIPRr
#define MISC0_EIPRr_SIZE BCMI_MADURA_MISC0_EIPRr_SIZE
typedef BCMI_MADURA_MISC0_EIPRr_t MISC0_EIPRr_t;
#define MISC0_EIPRr_CLR BCMI_MADURA_MISC0_EIPRr_CLR
#define MISC0_EIPRr_SET BCMI_MADURA_MISC0_EIPRr_SET
#define MISC0_EIPRr_GET BCMI_MADURA_MISC0_EIPRr_GET
#define MISC0_EIPRr_P_SYS_SIGDET_FOUNDf_GET BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_FOUNDf_GET
#define MISC0_EIPRr_P_SYS_SIGDET_FOUNDf_SET BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_FOUNDf_SET
#define MISC0_EIPRr_P_SYS_SIGDET_LOSTf_GET BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_LOSTf_GET
#define MISC0_EIPRr_P_SYS_SIGDET_LOSTf_SET BCMI_MADURA_MISC0_EIPRr_P_SYS_SIGDET_LOSTf_SET
#define MISC0_EIPRr_P_SYS_PMD_LOCK_FOUNDf_GET BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_FOUNDf_GET
#define MISC0_EIPRr_P_SYS_PMD_LOCK_FOUNDf_SET BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_FOUNDf_SET
#define MISC0_EIPRr_P_SYS_PMD_LOCK_LOSTf_GET BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_LOSTf_GET
#define MISC0_EIPRr_P_SYS_PMD_LOCK_LOSTf_SET BCMI_MADURA_MISC0_EIPRr_P_SYS_PMD_LOCK_LOSTf_SET
#define MISC0_EIPRr_P_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIPRr_P_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EIPRr_P_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIPRr_P_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIPRr_P_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EIPRr_P_LIN_SIGDET_FOUNDf_GET BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_FOUNDf_GET
#define MISC0_EIPRr_P_LIN_SIGDET_FOUNDf_SET BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_FOUNDf_SET
#define MISC0_EIPRr_P_LIN_SIGDET_LOSTf_GET BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_LOSTf_GET
#define MISC0_EIPRr_P_LIN_SIGDET_LOSTf_SET BCMI_MADURA_MISC0_EIPRr_P_LIN_SIGDET_LOSTf_SET
#define MISC0_EIPRr_P_LIN_PMD_LOCK_FOUNDf_GET BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_FOUNDf_GET
#define MISC0_EIPRr_P_LIN_PMD_LOCK_FOUNDf_SET BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_FOUNDf_SET
#define MISC0_EIPRr_P_LIN_PMD_LOCK_LOSTf_GET BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_LOSTf_GET
#define MISC0_EIPRr_P_LIN_PMD_LOCK_LOSTf_SET BCMI_MADURA_MISC0_EIPRr_P_LIN_PMD_LOCK_LOSTf_SET
#define MISC0_EIPRr_P_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIPRr_P_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EIPRr_P_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIPRr_P_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIPRr_P_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET
#define READ_MISC0_EIPRr BCMI_MADURA_READ_MISC0_EIPRr
#define WRITE_MISC0_EIPRr BCMI_MADURA_WRITE_MISC0_EIPRr
#define MODIFY_MISC0_EIPRr BCMI_MADURA_MODIFY_MISC0_EIPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISC0_EIPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISC0_EIER
 * BLOCKS:   CTRL
 * REGADDR:  0x8b1b
 * DEVAD:    1
 * DESC:     Miscellaneous 0 External Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_LIN_FAL_1_PMI_ARB_WDOG_EXP Line Side Falcon 1 PMI-ARB Watchdog Expired On No Ack Enable
 *     ENABLE_LIN_FAL_0_PMI_ARB_WDOG_EXP Line Side Falcon 0 PMI-ARB Watchdog Expired On No Ack Enable
 *     ENABLE_LIN_PMD_LOCK_LOST Line Side PMD Lock Lost Enable
 *     ENABLE_LIN_PMD_LOCK_FOUND Line Side PMD Lock Found Enable
 *     ENABLE_LIN_SIGDET_LOST Line Side Signal Detect Lost Enable
 *     ENABLE_LIN_SIGDET_FOUND Line Side Signal Detect Found Enable
 *     ENABLE_SYS_FAL_1_PMI_ARB_WDOG_EXP System Side Falcon 1 PMI-ARB Watchdog Expired On No Ack Enable
 *     ENABLE_SYS_FAL_0_PMI_ARB_WDOG_EXP System Side Falcon 0 PMI-ARB Watchdog Expired On No Ack Enable
 *     ENABLE_SYS_PMD_LOCK_LOST System Side PMD Lock Lost Enable
 *     ENABLE_SYS_PMD_LOCK_FOUND System Side PMD Lock Found Enable
 *     ENABLE_SYS_SIGDET_LOST System Side Signal Detect Lost Enable
 *     ENABLE_SYS_SIGDET_FOUND System Side Signal Detect Found Enable
 */
#define BCMI_MADURA_MISC0_EIERr (0x00018b1b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISC0_EIERr_SIZE 4

/*
 * This structure should be used to declare and program MISC0_EIER.
 */
typedef union BCMI_MADURA_MISC0_EIERr_s {
	uint32_t v[1];
	uint32_t misc0_eier[1];
	uint32_t _misc0_eier;
} BCMI_MADURA_MISC0_EIERr_t;

#define BCMI_MADURA_MISC0_EIERr_CLR(r) (r).misc0_eier[0] = 0
#define BCMI_MADURA_MISC0_EIERr_SET(r,d) (r).misc0_eier[0] = d
#define BCMI_MADURA_MISC0_EIERr_GET(r) (r).misc0_eier[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_FOUNDf_GET(r) ((((r).misc0_eier[0]) >> 11) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_FOUNDf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_LOSTf_GET(r) ((((r).misc0_eier[0]) >> 10) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_LOSTf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_FOUNDf_GET(r) ((((r).misc0_eier[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_FOUNDf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_LOSTf_GET(r) ((((r).misc0_eier[0]) >> 8) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_LOSTf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eier[0]) >> 7) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eier[0]) >> 6) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_FOUNDf_GET(r) ((((r).misc0_eier[0]) >> 5) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_FOUNDf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_LOSTf_GET(r) ((((r).misc0_eier[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_LOSTf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_FOUNDf_GET(r) ((((r).misc0_eier[0]) >> 3) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_FOUNDf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_LOSTf_GET(r) ((((r).misc0_eier[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_LOSTf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET(r) ((((r).misc0_eier[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET(r) (((r).misc0_eier[0]) & 0x1)
#define BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET(r,f) (r).misc0_eier[0]=(((r).misc0_eier[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC0_EIER.
 */
#define BCMI_MADURA_READ_MISC0_EIERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISC0_EIERr,_r._misc0_eier)
#define BCMI_MADURA_WRITE_MISC0_EIERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISC0_EIERr,_r._misc0_eier)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC0_EIERr BCMI_MADURA_MISC0_EIERr
#define MISC0_EIERr_SIZE BCMI_MADURA_MISC0_EIERr_SIZE
typedef BCMI_MADURA_MISC0_EIERr_t MISC0_EIERr_t;
#define MISC0_EIERr_CLR BCMI_MADURA_MISC0_EIERr_CLR
#define MISC0_EIERr_SET BCMI_MADURA_MISC0_EIERr_SET
#define MISC0_EIERr_GET BCMI_MADURA_MISC0_EIERr_GET
#define MISC0_EIERr_ENABLE_SYS_SIGDET_FOUNDf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_FOUNDf_GET
#define MISC0_EIERr_ENABLE_SYS_SIGDET_FOUNDf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_FOUNDf_SET
#define MISC0_EIERr_ENABLE_SYS_SIGDET_LOSTf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_LOSTf_GET
#define MISC0_EIERr_ENABLE_SYS_SIGDET_LOSTf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_SIGDET_LOSTf_SET
#define MISC0_EIERr_ENABLE_SYS_PMD_LOCK_FOUNDf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_FOUNDf_GET
#define MISC0_EIERr_ENABLE_SYS_PMD_LOCK_FOUNDf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_FOUNDf_SET
#define MISC0_EIERr_ENABLE_SYS_PMD_LOCK_LOSTf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_LOSTf_GET
#define MISC0_EIERr_ENABLE_SYS_PMD_LOCK_LOSTf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_PMD_LOCK_LOSTf_SET
#define MISC0_EIERr_ENABLE_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_0_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIERr_ENABLE_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_0_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EIERr_ENABLE_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_1_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIERr_ENABLE_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_SYS_FAL_1_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EIERr_ENABLE_LIN_SIGDET_FOUNDf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_FOUNDf_GET
#define MISC0_EIERr_ENABLE_LIN_SIGDET_FOUNDf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_FOUNDf_SET
#define MISC0_EIERr_ENABLE_LIN_SIGDET_LOSTf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_LOSTf_GET
#define MISC0_EIERr_ENABLE_LIN_SIGDET_LOSTf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_SIGDET_LOSTf_SET
#define MISC0_EIERr_ENABLE_LIN_PMD_LOCK_FOUNDf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_FOUNDf_GET
#define MISC0_EIERr_ENABLE_LIN_PMD_LOCK_FOUNDf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_FOUNDf_SET
#define MISC0_EIERr_ENABLE_LIN_PMD_LOCK_LOSTf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_LOSTf_GET
#define MISC0_EIERr_ENABLE_LIN_PMD_LOCK_LOSTf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_PMD_LOCK_LOSTf_SET
#define MISC0_EIERr_ENABLE_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_0_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIERr_ENABLE_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_0_PMI_ARB_WDOG_EXPf_SET
#define MISC0_EIERr_ENABLE_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_1_PMI_ARB_WDOG_EXPf_GET
#define MISC0_EIERr_ENABLE_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET BCMI_MADURA_MISC0_EIERr_ENABLE_LIN_FAL_1_PMI_ARB_WDOG_EXPf_SET
#define READ_MISC0_EIERr BCMI_MADURA_READ_MISC0_EIERr
#define WRITE_MISC0_EIERr BCMI_MADURA_WRITE_MISC0_EIERr
#define MODIFY_MISC0_EIERr BCMI_MADURA_MODIFY_MISC0_EIERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISC0_EIERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISC1_EISR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b1c
 * DEVAD:    1
 * DESC:     Miscellaneous 1 External Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_FIFOERR      Line Side FIFO Error Rising Edge Interrupt Status
 *     SYS_FIFOERR      System Side FIFO Error Rising Edge Interrupt Status
 *     CL91_1_TX_PCS_ALIGN_LOST CL91 1 TX PCS Alignment Lost Falling Edge Interrupt Status
 *     CL91_1_TX_PCS_ALIGN_FOUND CL91 1 TX PCS Alignment Found Rising Edge Interrupt Status
 *     CL91_0_TX_PCS_ALIGN_LOST CL91 0 TX PCS Alignment Lost Falling Edge Interrupt Status
 *     CL91_0_TX_PCS_ALIGN_FOUND CL91 0 TX PCS Alignment Found Rising Edge Interrupt Status
 *     CL91_1_RX_FEC_ALIGN_LOST CL91 1 RX FEC Alignment Lost Falling Edge Interrupt Status
 *     CL91_1_RX_FEC_ALIGN_FOUND CL91 1 RX FEC Alignment Found Rising Edge Interrupt Status
 *     CL91_0_RX_FEC_ALIGN_LOST CL91 0 RX FEC Alignment Lost Falling Edge Interrupt Status
 *     CL91_0_RX_FEC_ALIGN_FOUND CL91 0 RX FEC Alignment Found Rising Edge Interrupt Status
 *     LIN_PCS_MON_LOCK_LOST Line Side PCS Monitor Lock Lost Falling Edge Interrupt Status
 *     LIN_PCS_MON_LOCK_FOUND Line Side PCS Monitor Lock Found Rising Edge Interrupt Status
 *     SYS_PCS_MON_LOCK_LOST System Side PCS Monitor Lock Lost Falling Edge Interrupt Status
 *     SYS_PCS_MON_LOCK_FOUND System Side PCS Monitor Lock Found Rising Edge Interrupt Status
 *     ONEG_INBAND_MSG_LOCK_LOST Oneg Inband Message Lock Lost Falling Edge Interrupt Status
 *     ONEG_INBAND_MSG_LOCK_FOUND Oneg Inband Message Lock Found Rising Edge Interrupt Status
 */
#define BCMI_MADURA_MISC1_EISRr (0x00018b1c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISC1_EISRr_SIZE 4

/*
 * This structure should be used to declare and program MISC1_EISR.
 */
typedef union BCMI_MADURA_MISC1_EISRr_s {
	uint32_t v[1];
	uint32_t misc1_eisr[1];
	uint32_t _misc1_eisr;
} BCMI_MADURA_MISC1_EISRr_t;

#define BCMI_MADURA_MISC1_EISRr_CLR(r) (r).misc1_eisr[0] = 0
#define BCMI_MADURA_MISC1_EISRr_SET(r,d) (r).misc1_eisr[0] = d
#define BCMI_MADURA_MISC1_EISRr_GET(r) (r).misc1_eisr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_FOUNDf_GET(r) ((((r).misc1_eisr[0]) >> 15) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_FOUNDf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_LOSTf_GET(r) ((((r).misc1_eisr[0]) >> 14) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_LOSTf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_FOUNDf_GET(r) ((((r).misc1_eisr[0]) >> 13) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_FOUNDf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_LOSTf_GET(r) ((((r).misc1_eisr[0]) >> 12) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_LOSTf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_FOUNDf_GET(r) ((((r).misc1_eisr[0]) >> 11) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_FOUNDf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_LOSTf_GET(r) ((((r).misc1_eisr[0]) >> 10) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_LOSTf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_FOUNDf_GET(r) ((((r).misc1_eisr[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_FOUNDf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_LOSTf_GET(r) ((((r).misc1_eisr[0]) >> 8) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_LOSTf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_FOUNDf_GET(r) ((((r).misc1_eisr[0]) >> 7) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_FOUNDf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_LOSTf_GET(r) ((((r).misc1_eisr[0]) >> 6) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_LOSTf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_FOUNDf_GET(r) ((((r).misc1_eisr[0]) >> 5) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_FOUNDf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_LOSTf_GET(r) ((((r).misc1_eisr[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_LOSTf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_FOUNDf_GET(r) ((((r).misc1_eisr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_FOUNDf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_LOSTf_GET(r) ((((r).misc1_eisr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_LOSTf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISC1_EISRr_SYS_FIFOERRf_GET(r) ((((r).misc1_eisr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_SYS_FIFOERRf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISC1_EISRr_LIN_FIFOERRf_GET(r) (((r).misc1_eisr[0]) & 0x1)
#define BCMI_MADURA_MISC1_EISRr_LIN_FIFOERRf_SET(r,f) (r).misc1_eisr[0]=(((r).misc1_eisr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC1_EISR.
 */
#define BCMI_MADURA_READ_MISC1_EISRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISC1_EISRr,_r._misc1_eisr)
#define BCMI_MADURA_WRITE_MISC1_EISRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISC1_EISRr,_r._misc1_eisr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC1_EISRr BCMI_MADURA_MISC1_EISRr
#define MISC1_EISRr_SIZE BCMI_MADURA_MISC1_EISRr_SIZE
typedef BCMI_MADURA_MISC1_EISRr_t MISC1_EISRr_t;
#define MISC1_EISRr_CLR BCMI_MADURA_MISC1_EISRr_CLR
#define MISC1_EISRr_SET BCMI_MADURA_MISC1_EISRr_SET
#define MISC1_EISRr_GET BCMI_MADURA_MISC1_EISRr_GET
#define MISC1_EISRr_ONEG_INBAND_MSG_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_FOUNDf_GET
#define MISC1_EISRr_ONEG_INBAND_MSG_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_FOUNDf_SET
#define MISC1_EISRr_ONEG_INBAND_MSG_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_LOSTf_GET
#define MISC1_EISRr_ONEG_INBAND_MSG_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EISRr_ONEG_INBAND_MSG_LOCK_LOSTf_SET
#define MISC1_EISRr_SYS_PCS_MON_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_FOUNDf_GET
#define MISC1_EISRr_SYS_PCS_MON_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_FOUNDf_SET
#define MISC1_EISRr_SYS_PCS_MON_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_LOSTf_GET
#define MISC1_EISRr_SYS_PCS_MON_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EISRr_SYS_PCS_MON_LOCK_LOSTf_SET
#define MISC1_EISRr_LIN_PCS_MON_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_FOUNDf_GET
#define MISC1_EISRr_LIN_PCS_MON_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_FOUNDf_SET
#define MISC1_EISRr_LIN_PCS_MON_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_LOSTf_GET
#define MISC1_EISRr_LIN_PCS_MON_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EISRr_LIN_PCS_MON_LOCK_LOSTf_SET
#define MISC1_EISRr_CL91_0_RX_FEC_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_FOUNDf_GET
#define MISC1_EISRr_CL91_0_RX_FEC_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_FOUNDf_SET
#define MISC1_EISRr_CL91_0_RX_FEC_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_LOSTf_GET
#define MISC1_EISRr_CL91_0_RX_FEC_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EISRr_CL91_0_RX_FEC_ALIGN_LOSTf_SET
#define MISC1_EISRr_CL91_1_RX_FEC_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_FOUNDf_GET
#define MISC1_EISRr_CL91_1_RX_FEC_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_FOUNDf_SET
#define MISC1_EISRr_CL91_1_RX_FEC_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_LOSTf_GET
#define MISC1_EISRr_CL91_1_RX_FEC_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EISRr_CL91_1_RX_FEC_ALIGN_LOSTf_SET
#define MISC1_EISRr_CL91_0_TX_PCS_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_FOUNDf_GET
#define MISC1_EISRr_CL91_0_TX_PCS_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_FOUNDf_SET
#define MISC1_EISRr_CL91_0_TX_PCS_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_LOSTf_GET
#define MISC1_EISRr_CL91_0_TX_PCS_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EISRr_CL91_0_TX_PCS_ALIGN_LOSTf_SET
#define MISC1_EISRr_CL91_1_TX_PCS_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_FOUNDf_GET
#define MISC1_EISRr_CL91_1_TX_PCS_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_FOUNDf_SET
#define MISC1_EISRr_CL91_1_TX_PCS_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_LOSTf_GET
#define MISC1_EISRr_CL91_1_TX_PCS_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EISRr_CL91_1_TX_PCS_ALIGN_LOSTf_SET
#define MISC1_EISRr_SYS_FIFOERRf_GET BCMI_MADURA_MISC1_EISRr_SYS_FIFOERRf_GET
#define MISC1_EISRr_SYS_FIFOERRf_SET BCMI_MADURA_MISC1_EISRr_SYS_FIFOERRf_SET
#define MISC1_EISRr_LIN_FIFOERRf_GET BCMI_MADURA_MISC1_EISRr_LIN_FIFOERRf_GET
#define MISC1_EISRr_LIN_FIFOERRf_SET BCMI_MADURA_MISC1_EISRr_LIN_FIFOERRf_SET
#define READ_MISC1_EISRr BCMI_MADURA_READ_MISC1_EISRr
#define WRITE_MISC1_EISRr BCMI_MADURA_WRITE_MISC1_EISRr
#define MODIFY_MISC1_EISRr BCMI_MADURA_MODIFY_MISC1_EISRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISC1_EISRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISC1_EIPR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b1d
 * DEVAD:    1
 * DESC:     Miscellaneous 1 External Interrupt Pending
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P_LIN_FIFOERR    1 = Pending Interrupt - Line Side FIFO Error Pending Status
 *     P_SYS_FIFOERR    1 = Pending Interrupt - System Side FIFO Error Pending Status
 *     P_CL91_1_TX_PCS_ALIGN_LOST 1 = Pending Interrupt - CL91 1 TX PCS Alignment Lost Pending Status
 *     P_CL91_1_TX_PCS_ALIGN_FOUND 1 = Pending Interrupt - CL91 1 TX PCS Alignment Found Pending Status
 *     P_CL91_0_TX_PCS_ALIGN_LOST 1 = Pending Interrupt - CL91 0 TX PCS Alignment Lost Pending Status
 *     P_CL91_0_TX_PCS_ALIGN_FOUND 1 = Pending Interrupt - CL91 0 TX PCS Alignment Found Pending Status
 *     P_CL91_1_RX_FEC_ALIGN_LOST 1 = Pending Interrupt - CL91 1 RX FEC Alignment Lost Pending Status
 *     P_CL91_1_RX_FEC_ALIGN_FOUND 1 = Pending Interrupt - CL91 1 RX FEC Alignment Found Pending Status
 *     P_CL91_0_RX_FEC_ALIGN_LOST 1 = Pending Interrupt - CL91 0 RX FEC Alignment Lost Pending Status
 *     P_CL91_0_RX_FEC_ALIGN_FOUND 1 = Pending Interrupt - CL91 0 RX FEC Alignment Found Pending Status
 *     P_LIN_PCS_MON_LOCK_LOST 1 = Pending Interrupt - Line Side PCS Monitor Lock Lost Pending Status
 *     P_LIN_PCS_MON_LOCK_FOUND 1 = Pending Interrupt - Line Side PCS Monitor Lock Found Pending Status
 *     P_SYS_PCS_MON_LOCK_LOST 1 = Pending Interrupt - System Side PCS Monitor Lock Lost Pending Status
 *     P_SYS_PCS_MON_LOCK_FOUND 1 = Pending Interrupt - System Side PCS Monitor Lock Found Pending Status
 *     P_ONEG_INBAND_MSG_LOCK_LOST 1 = Pending Interrupt - Oneg Inband Message Lock Lost Pending Status
 *     P_ONEG_INBAND_MSG_LOCK_FOUND 1 = Pending Interrupt - Oneg Inband Message Lock Found Pending Status
 */
#define BCMI_MADURA_MISC1_EIPRr (0x00018b1d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISC1_EIPRr_SIZE 4

/*
 * This structure should be used to declare and program MISC1_EIPR.
 */
typedef union BCMI_MADURA_MISC1_EIPRr_s {
	uint32_t v[1];
	uint32_t misc1_eipr[1];
	uint32_t _misc1_eipr;
} BCMI_MADURA_MISC1_EIPRr_t;

#define BCMI_MADURA_MISC1_EIPRr_CLR(r) (r).misc1_eipr[0] = 0
#define BCMI_MADURA_MISC1_EIPRr_SET(r,d) (r).misc1_eipr[0] = d
#define BCMI_MADURA_MISC1_EIPRr_GET(r) (r).misc1_eipr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_FOUNDf_GET(r) ((((r).misc1_eipr[0]) >> 15) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_FOUNDf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_LOSTf_GET(r) ((((r).misc1_eipr[0]) >> 14) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_LOSTf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_FOUNDf_GET(r) ((((r).misc1_eipr[0]) >> 13) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_FOUNDf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_LOSTf_GET(r) ((((r).misc1_eipr[0]) >> 12) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_LOSTf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_FOUNDf_GET(r) ((((r).misc1_eipr[0]) >> 11) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_FOUNDf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_LOSTf_GET(r) ((((r).misc1_eipr[0]) >> 10) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_LOSTf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_FOUNDf_GET(r) ((((r).misc1_eipr[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_FOUNDf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_LOSTf_GET(r) ((((r).misc1_eipr[0]) >> 8) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_LOSTf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_FOUNDf_GET(r) ((((r).misc1_eipr[0]) >> 7) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_FOUNDf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_LOSTf_GET(r) ((((r).misc1_eipr[0]) >> 6) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_LOSTf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_FOUNDf_GET(r) ((((r).misc1_eipr[0]) >> 5) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_FOUNDf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_LOSTf_GET(r) ((((r).misc1_eipr[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_LOSTf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_FOUNDf_GET(r) ((((r).misc1_eipr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_FOUNDf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_LOSTf_GET(r) ((((r).misc1_eipr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_LOSTf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISC1_EIPRr_P_SYS_FIFOERRf_GET(r) ((((r).misc1_eipr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_SYS_FIFOERRf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISC1_EIPRr_P_LIN_FIFOERRf_GET(r) (((r).misc1_eipr[0]) & 0x1)
#define BCMI_MADURA_MISC1_EIPRr_P_LIN_FIFOERRf_SET(r,f) (r).misc1_eipr[0]=(((r).misc1_eipr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC1_EIPR.
 */
#define BCMI_MADURA_READ_MISC1_EIPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISC1_EIPRr,_r._misc1_eipr)
#define BCMI_MADURA_WRITE_MISC1_EIPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISC1_EIPRr,_r._misc1_eipr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC1_EIPRr BCMI_MADURA_MISC1_EIPRr
#define MISC1_EIPRr_SIZE BCMI_MADURA_MISC1_EIPRr_SIZE
typedef BCMI_MADURA_MISC1_EIPRr_t MISC1_EIPRr_t;
#define MISC1_EIPRr_CLR BCMI_MADURA_MISC1_EIPRr_CLR
#define MISC1_EIPRr_SET BCMI_MADURA_MISC1_EIPRr_SET
#define MISC1_EIPRr_GET BCMI_MADURA_MISC1_EIPRr_GET
#define MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_FOUNDf_GET
#define MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_FOUNDf_SET
#define MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_LOSTf_GET
#define MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EIPRr_P_ONEG_INBAND_MSG_LOCK_LOSTf_SET
#define MISC1_EIPRr_P_SYS_PCS_MON_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_FOUNDf_GET
#define MISC1_EIPRr_P_SYS_PCS_MON_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_FOUNDf_SET
#define MISC1_EIPRr_P_SYS_PCS_MON_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_LOSTf_GET
#define MISC1_EIPRr_P_SYS_PCS_MON_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EIPRr_P_SYS_PCS_MON_LOCK_LOSTf_SET
#define MISC1_EIPRr_P_LIN_PCS_MON_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_FOUNDf_GET
#define MISC1_EIPRr_P_LIN_PCS_MON_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_FOUNDf_SET
#define MISC1_EIPRr_P_LIN_PCS_MON_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_LOSTf_GET
#define MISC1_EIPRr_P_LIN_PCS_MON_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EIPRr_P_LIN_PCS_MON_LOCK_LOSTf_SET
#define MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_FOUNDf_GET
#define MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_FOUNDf_SET
#define MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_LOSTf_GET
#define MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_RX_FEC_ALIGN_LOSTf_SET
#define MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_FOUNDf_GET
#define MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_FOUNDf_SET
#define MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_LOSTf_GET
#define MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_RX_FEC_ALIGN_LOSTf_SET
#define MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_FOUNDf_GET
#define MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_FOUNDf_SET
#define MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_LOSTf_GET
#define MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_0_TX_PCS_ALIGN_LOSTf_SET
#define MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_FOUNDf_GET
#define MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_FOUNDf_SET
#define MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_LOSTf_GET
#define MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIPRr_P_CL91_1_TX_PCS_ALIGN_LOSTf_SET
#define MISC1_EIPRr_P_SYS_FIFOERRf_GET BCMI_MADURA_MISC1_EIPRr_P_SYS_FIFOERRf_GET
#define MISC1_EIPRr_P_SYS_FIFOERRf_SET BCMI_MADURA_MISC1_EIPRr_P_SYS_FIFOERRf_SET
#define MISC1_EIPRr_P_LIN_FIFOERRf_GET BCMI_MADURA_MISC1_EIPRr_P_LIN_FIFOERRf_GET
#define MISC1_EIPRr_P_LIN_FIFOERRf_SET BCMI_MADURA_MISC1_EIPRr_P_LIN_FIFOERRf_SET
#define READ_MISC1_EIPRr BCMI_MADURA_READ_MISC1_EIPRr
#define WRITE_MISC1_EIPRr BCMI_MADURA_WRITE_MISC1_EIPRr
#define MODIFY_MISC1_EIPRr BCMI_MADURA_MODIFY_MISC1_EIPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISC1_EIPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISC1_EIER
 * BLOCKS:   CTRL
 * REGADDR:  0x8b1e
 * DEVAD:    1
 * DESC:     Miscellaneous 1 External Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_LIN_FIFOERR Line Side FIFO Error Enable
 *     ENABLE_SYS_FIFOERR System Side FIFO Error Enable
 *     ENABLE_CL91_1_TX_PCS_ALIGN_LOST CL91 1 TX PCS Alignment Lost Enable
 *     ENABLE_CL91_1_TX_PCS_ALIGN_FOUND CL91 1 TX PCS Alignment Found Enable
 *     ENABLE_CL91_0_TX_PCS_ALIGN_LOST CL91 0 TX PCS Alignment Lost Enable
 *     ENABLE_CL91_0_TX_PCS_ALIGN_FOUND CL91 0 TX PCS Alignment Found Enable
 *     ENABLE_CL91_1_RX_FEC_ALIGN_LOST CL91 1 RX FEC Alignment Lost Enable
 *     ENABLE_CL91_1_RX_FEC_ALIGN_FOUND CL91 1 RX FEC Alignment Found Enable
 *     ENABLE_CL91_0_RX_FEC_ALIGN_LOST CL91 0 RX FEC Alignment Lost Enable
 *     ENABLE_CL91_0_RX_FEC_ALIGN_FOUND CL91 0 RX FEC Alignment Found Enable
 *     ENABLE_LIN_PCS_MON_LOCK_LOST Line Side PCS Monitor Lock Lost Enable
 *     ENABLE_LIN_PCS_MON_LOCK_FOUND Line Side PCS Monitor Lock Found Enable
 *     ENABLE_SYS_PCS_MON_LOCK_LOST System Side PCS Monitor Lock Lost Enable
 *     ENABLE_SYS_PCS_MON_LOCK_FOUND System Side PCS Monitor Lock Found Enable
 *     ENABLE_ONEG_INBAND_MSG_LOCK_LOST Oneg Inband Message Lock Lost Enable
 *     ENABLE_ONEG_INBAND_MSG_LOCK_FOUND Oneg Inband Message Lock Found Enable
 */
#define BCMI_MADURA_MISC1_EIERr (0x00018b1e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISC1_EIERr_SIZE 4

/*
 * This structure should be used to declare and program MISC1_EIER.
 */
typedef union BCMI_MADURA_MISC1_EIERr_s {
	uint32_t v[1];
	uint32_t misc1_eier[1];
	uint32_t _misc1_eier;
} BCMI_MADURA_MISC1_EIERr_t;

#define BCMI_MADURA_MISC1_EIERr_CLR(r) (r).misc1_eier[0] = 0
#define BCMI_MADURA_MISC1_EIERr_SET(r,d) (r).misc1_eier[0] = d
#define BCMI_MADURA_MISC1_EIERr_GET(r) (r).misc1_eier[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_FOUNDf_GET(r) ((((r).misc1_eier[0]) >> 15) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_FOUNDf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_LOSTf_GET(r) ((((r).misc1_eier[0]) >> 14) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_LOSTf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_FOUNDf_GET(r) ((((r).misc1_eier[0]) >> 13) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_FOUNDf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_LOSTf_GET(r) ((((r).misc1_eier[0]) >> 12) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_LOSTf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_FOUNDf_GET(r) ((((r).misc1_eier[0]) >> 11) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_FOUNDf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_LOSTf_GET(r) ((((r).misc1_eier[0]) >> 10) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_LOSTf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_FOUNDf_GET(r) ((((r).misc1_eier[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_FOUNDf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_LOSTf_GET(r) ((((r).misc1_eier[0]) >> 8) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_LOSTf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_FOUNDf_GET(r) ((((r).misc1_eier[0]) >> 7) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_FOUNDf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_LOSTf_GET(r) ((((r).misc1_eier[0]) >> 6) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_LOSTf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_FOUNDf_GET(r) ((((r).misc1_eier[0]) >> 5) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_FOUNDf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_LOSTf_GET(r) ((((r).misc1_eier[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_LOSTf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_FOUNDf_GET(r) ((((r).misc1_eier[0]) >> 3) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_FOUNDf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_LOSTf_GET(r) ((((r).misc1_eier[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_LOSTf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_FIFOERRf_GET(r) ((((r).misc1_eier[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_FIFOERRf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_FIFOERRf_GET(r) (((r).misc1_eier[0]) & 0x1)
#define BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_FIFOERRf_SET(r,f) (r).misc1_eier[0]=(((r).misc1_eier[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISC1_EIER.
 */
#define BCMI_MADURA_READ_MISC1_EIERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISC1_EIERr,_r._misc1_eier)
#define BCMI_MADURA_WRITE_MISC1_EIERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISC1_EIERr,_r._misc1_eier)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISC1_EIERr BCMI_MADURA_MISC1_EIERr
#define MISC1_EIERr_SIZE BCMI_MADURA_MISC1_EIERr_SIZE
typedef BCMI_MADURA_MISC1_EIERr_t MISC1_EIERr_t;
#define MISC1_EIERr_CLR BCMI_MADURA_MISC1_EIERr_CLR
#define MISC1_EIERr_SET BCMI_MADURA_MISC1_EIERr_SET
#define MISC1_EIERr_GET BCMI_MADURA_MISC1_EIERr_GET
#define MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_FOUNDf_GET
#define MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_FOUNDf_SET
#define MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_LOSTf_GET
#define MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_ONEG_INBAND_MSG_LOCK_LOSTf_SET
#define MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_FOUNDf_GET
#define MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_FOUNDf_SET
#define MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_LOSTf_GET
#define MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_PCS_MON_LOCK_LOSTf_SET
#define MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_FOUNDf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_FOUNDf_GET
#define MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_FOUNDf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_FOUNDf_SET
#define MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_LOSTf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_LOSTf_GET
#define MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_LOSTf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_PCS_MON_LOCK_LOSTf_SET
#define MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_FOUNDf_GET
#define MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_FOUNDf_SET
#define MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_LOSTf_GET
#define MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_RX_FEC_ALIGN_LOSTf_SET
#define MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_FOUNDf_GET
#define MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_FOUNDf_SET
#define MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_LOSTf_GET
#define MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_RX_FEC_ALIGN_LOSTf_SET
#define MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_FOUNDf_GET
#define MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_FOUNDf_SET
#define MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_LOSTf_GET
#define MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_0_TX_PCS_ALIGN_LOSTf_SET
#define MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_FOUNDf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_FOUNDf_GET
#define MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_FOUNDf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_FOUNDf_SET
#define MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_LOSTf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_LOSTf_GET
#define MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_LOSTf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_CL91_1_TX_PCS_ALIGN_LOSTf_SET
#define MISC1_EIERr_ENABLE_SYS_FIFOERRf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_FIFOERRf_GET
#define MISC1_EIERr_ENABLE_SYS_FIFOERRf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_SYS_FIFOERRf_SET
#define MISC1_EIERr_ENABLE_LIN_FIFOERRf_GET BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_FIFOERRf_GET
#define MISC1_EIERr_ENABLE_LIN_FIFOERRf_SET BCMI_MADURA_MISC1_EIERr_ENABLE_LIN_FIFOERRf_SET
#define READ_MISC1_EIERr BCMI_MADURA_READ_MISC1_EIERr
#define WRITE_MISC1_EIERr BCMI_MADURA_WRITE_MISC1_EIERr
#define MODIFY_MISC1_EIERr BCMI_MADURA_MODIFY_MISC1_EIERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISC1_EIERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MCTL_EISR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b1f
 * DEVAD:    1
 * DESC:     Module Controller External Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MODULE2_INTRB_LOW Module 2 Intrb Low Level Interrupt Status
 *     MODULE2_INTRB_HIGH Module 2 Intrb High Level Interrupt Status
 *     MODULE1_INTRB_LOW Module 1 Intrb Low Level Interrupt Status
 *     MODULE1_INTRB_HIGH Module 1 Intrb High Level Interrupt Status
 */
#define BCMI_MADURA_MCTL_EISRr (0x00018b1f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MCTL_EISRr_SIZE 4

/*
 * This structure should be used to declare and program MCTL_EISR.
 */
typedef union BCMI_MADURA_MCTL_EISRr_s {
	uint32_t v[1];
	uint32_t mctl_eisr[1];
	uint32_t _mctl_eisr;
} BCMI_MADURA_MCTL_EISRr_t;

#define BCMI_MADURA_MCTL_EISRr_CLR(r) (r).mctl_eisr[0] = 0
#define BCMI_MADURA_MCTL_EISRr_SET(r,d) (r).mctl_eisr[0] = d
#define BCMI_MADURA_MCTL_EISRr_GET(r) (r).mctl_eisr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_HIGHf_GET(r) ((((r).mctl_eisr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_HIGHf_SET(r,f) (r).mctl_eisr[0]=(((r).mctl_eisr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_LOWf_GET(r) ((((r).mctl_eisr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_LOWf_SET(r,f) (r).mctl_eisr[0]=(((r).mctl_eisr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_HIGHf_GET(r) ((((r).mctl_eisr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_HIGHf_SET(r,f) (r).mctl_eisr[0]=(((r).mctl_eisr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_LOWf_GET(r) (((r).mctl_eisr[0]) & 0x1)
#define BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_LOWf_SET(r,f) (r).mctl_eisr[0]=(((r).mctl_eisr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MCTL_EISR.
 */
#define BCMI_MADURA_READ_MCTL_EISRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MCTL_EISRr,_r._mctl_eisr)
#define BCMI_MADURA_WRITE_MCTL_EISRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MCTL_EISRr,_r._mctl_eisr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MCTL_EISRr BCMI_MADURA_MCTL_EISRr
#define MCTL_EISRr_SIZE BCMI_MADURA_MCTL_EISRr_SIZE
typedef BCMI_MADURA_MCTL_EISRr_t MCTL_EISRr_t;
#define MCTL_EISRr_CLR BCMI_MADURA_MCTL_EISRr_CLR
#define MCTL_EISRr_SET BCMI_MADURA_MCTL_EISRr_SET
#define MCTL_EISRr_GET BCMI_MADURA_MCTL_EISRr_GET
#define MCTL_EISRr_MODULE1_INTRB_HIGHf_GET BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_HIGHf_GET
#define MCTL_EISRr_MODULE1_INTRB_HIGHf_SET BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_HIGHf_SET
#define MCTL_EISRr_MODULE1_INTRB_LOWf_GET BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_LOWf_GET
#define MCTL_EISRr_MODULE1_INTRB_LOWf_SET BCMI_MADURA_MCTL_EISRr_MODULE1_INTRB_LOWf_SET
#define MCTL_EISRr_MODULE2_INTRB_HIGHf_GET BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_HIGHf_GET
#define MCTL_EISRr_MODULE2_INTRB_HIGHf_SET BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_HIGHf_SET
#define MCTL_EISRr_MODULE2_INTRB_LOWf_GET BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_LOWf_GET
#define MCTL_EISRr_MODULE2_INTRB_LOWf_SET BCMI_MADURA_MCTL_EISRr_MODULE2_INTRB_LOWf_SET
#define READ_MCTL_EISRr BCMI_MADURA_READ_MCTL_EISRr
#define WRITE_MCTL_EISRr BCMI_MADURA_WRITE_MCTL_EISRr
#define MODIFY_MCTL_EISRr BCMI_MADURA_MODIFY_MCTL_EISRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MCTL_EISRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MCTL_EIPR
 * BLOCKS:   CTRL
 * REGADDR:  0x8b20
 * DEVAD:    1
 * DESC:     Module Controller External Interrupt Pending
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P_MODULE2_INTRB_LOW 1 = Pending Interrupt
 *     P_MODULE2_INTRB_HIGH 1 = Pending Interrupt
 *     P_MODULE1_INTRB_LOW 1 = Pending Interrupt
 *     P_MODULE1_INTRB_HIGH 1 = Pending Interrupt
 */
#define BCMI_MADURA_MCTL_EIPRr (0x00018b20 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MCTL_EIPRr_SIZE 4

/*
 * This structure should be used to declare and program MCTL_EIPR.
 */
typedef union BCMI_MADURA_MCTL_EIPRr_s {
	uint32_t v[1];
	uint32_t mctl_eipr[1];
	uint32_t _mctl_eipr;
} BCMI_MADURA_MCTL_EIPRr_t;

#define BCMI_MADURA_MCTL_EIPRr_CLR(r) (r).mctl_eipr[0] = 0
#define BCMI_MADURA_MCTL_EIPRr_SET(r,d) (r).mctl_eipr[0] = d
#define BCMI_MADURA_MCTL_EIPRr_GET(r) (r).mctl_eipr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_HIGHf_GET(r) ((((r).mctl_eipr[0]) >> 3) & 0x1)
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_HIGHf_SET(r,f) (r).mctl_eipr[0]=(((r).mctl_eipr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_LOWf_GET(r) ((((r).mctl_eipr[0]) >> 2) & 0x1)
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_LOWf_SET(r,f) (r).mctl_eipr[0]=(((r).mctl_eipr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_HIGHf_GET(r) ((((r).mctl_eipr[0]) >> 1) & 0x1)
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_HIGHf_SET(r,f) (r).mctl_eipr[0]=(((r).mctl_eipr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_LOWf_GET(r) (((r).mctl_eipr[0]) & 0x1)
#define BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_LOWf_SET(r,f) (r).mctl_eipr[0]=(((r).mctl_eipr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MCTL_EIPR.
 */
#define BCMI_MADURA_READ_MCTL_EIPRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MCTL_EIPRr,_r._mctl_eipr)
#define BCMI_MADURA_WRITE_MCTL_EIPRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MCTL_EIPRr,_r._mctl_eipr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MCTL_EIPRr BCMI_MADURA_MCTL_EIPRr
#define MCTL_EIPRr_SIZE BCMI_MADURA_MCTL_EIPRr_SIZE
typedef BCMI_MADURA_MCTL_EIPRr_t MCTL_EIPRr_t;
#define MCTL_EIPRr_CLR BCMI_MADURA_MCTL_EIPRr_CLR
#define MCTL_EIPRr_SET BCMI_MADURA_MCTL_EIPRr_SET
#define MCTL_EIPRr_GET BCMI_MADURA_MCTL_EIPRr_GET
#define MCTL_EIPRr_P_MODULE1_INTRB_HIGHf_GET BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_HIGHf_GET
#define MCTL_EIPRr_P_MODULE1_INTRB_HIGHf_SET BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_HIGHf_SET
#define MCTL_EIPRr_P_MODULE1_INTRB_LOWf_GET BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_LOWf_GET
#define MCTL_EIPRr_P_MODULE1_INTRB_LOWf_SET BCMI_MADURA_MCTL_EIPRr_P_MODULE1_INTRB_LOWf_SET
#define MCTL_EIPRr_P_MODULE2_INTRB_HIGHf_GET BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_HIGHf_GET
#define MCTL_EIPRr_P_MODULE2_INTRB_HIGHf_SET BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_HIGHf_SET
#define MCTL_EIPRr_P_MODULE2_INTRB_LOWf_GET BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_LOWf_GET
#define MCTL_EIPRr_P_MODULE2_INTRB_LOWf_SET BCMI_MADURA_MCTL_EIPRr_P_MODULE2_INTRB_LOWf_SET
#define READ_MCTL_EIPRr BCMI_MADURA_READ_MCTL_EIPRr
#define WRITE_MCTL_EIPRr BCMI_MADURA_WRITE_MCTL_EIPRr
#define MODIFY_MCTL_EIPRr BCMI_MADURA_MODIFY_MCTL_EIPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MCTL_EIPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MCTL_EIER
 * BLOCKS:   CTRL
 * REGADDR:  0x8b21
 * DEVAD:    1
 * DESC:     Module Controller External Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_MODULE2_INTRB_LOW 
 *     ENABLE_MODULE2_INTRB_HIGH 
 *     ENABLE_MODULE1_INTRB_LOW 
 *     ENABLE_MODULE1_INTRB_HIGH 
 */
#define BCMI_MADURA_MCTL_EIERr (0x00018b21 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MCTL_EIERr_SIZE 4

/*
 * This structure should be used to declare and program MCTL_EIER.
 */
typedef union BCMI_MADURA_MCTL_EIERr_s {
	uint32_t v[1];
	uint32_t mctl_eier[1];
	uint32_t _mctl_eier;
} BCMI_MADURA_MCTL_EIERr_t;

#define BCMI_MADURA_MCTL_EIERr_CLR(r) (r).mctl_eier[0] = 0
#define BCMI_MADURA_MCTL_EIERr_SET(r,d) (r).mctl_eier[0] = d
#define BCMI_MADURA_MCTL_EIERr_GET(r) (r).mctl_eier[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_HIGHf_GET(r) ((((r).mctl_eier[0]) >> 3) & 0x1)
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_HIGHf_SET(r,f) (r).mctl_eier[0]=(((r).mctl_eier[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_LOWf_GET(r) ((((r).mctl_eier[0]) >> 2) & 0x1)
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_LOWf_SET(r,f) (r).mctl_eier[0]=(((r).mctl_eier[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_HIGHf_GET(r) ((((r).mctl_eier[0]) >> 1) & 0x1)
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_HIGHf_SET(r,f) (r).mctl_eier[0]=(((r).mctl_eier[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_LOWf_GET(r) (((r).mctl_eier[0]) & 0x1)
#define BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_LOWf_SET(r,f) (r).mctl_eier[0]=(((r).mctl_eier[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MCTL_EIER.
 */
#define BCMI_MADURA_READ_MCTL_EIERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MCTL_EIERr,_r._mctl_eier)
#define BCMI_MADURA_WRITE_MCTL_EIERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MCTL_EIERr,_r._mctl_eier)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MCTL_EIERr BCMI_MADURA_MCTL_EIERr
#define MCTL_EIERr_SIZE BCMI_MADURA_MCTL_EIERr_SIZE
typedef BCMI_MADURA_MCTL_EIERr_t MCTL_EIERr_t;
#define MCTL_EIERr_CLR BCMI_MADURA_MCTL_EIERr_CLR
#define MCTL_EIERr_SET BCMI_MADURA_MCTL_EIERr_SET
#define MCTL_EIERr_GET BCMI_MADURA_MCTL_EIERr_GET
#define MCTL_EIERr_ENABLE_MODULE1_INTRB_HIGHf_GET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_HIGHf_GET
#define MCTL_EIERr_ENABLE_MODULE1_INTRB_HIGHf_SET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_HIGHf_SET
#define MCTL_EIERr_ENABLE_MODULE1_INTRB_LOWf_GET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_LOWf_GET
#define MCTL_EIERr_ENABLE_MODULE1_INTRB_LOWf_SET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE1_INTRB_LOWf_SET
#define MCTL_EIERr_ENABLE_MODULE2_INTRB_HIGHf_GET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_HIGHf_GET
#define MCTL_EIERr_ENABLE_MODULE2_INTRB_HIGHf_SET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_HIGHf_SET
#define MCTL_EIERr_ENABLE_MODULE2_INTRB_LOWf_GET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_LOWf_GET
#define MCTL_EIERr_ENABLE_MODULE2_INTRB_LOWf_SET BCMI_MADURA_MCTL_EIERr_ENABLE_MODULE2_INTRB_LOWf_SET
#define READ_MCTL_EIERr BCMI_MADURA_READ_MCTL_EIERr
#define WRITE_MCTL_EIERr BCMI_MADURA_WRITE_MCTL_EIERr
#define MODIFY_MCTL_EIERr BCMI_MADURA_MODIFY_MCTL_EIERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MCTL_EIERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GENERAL_PURPOSE_IO_CTL0
 * BLOCKS:   CTRL
 * REGADDR:  0x8b80
 * DEVAD:    1
 * DESC:     general purpose IO status select for GPIO 0 through 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_0_OUT_SEL   GPIO 0 output mux
 *     GPIO_1_OUT_SEL   GPIO 1 output mux
 *     GPIO_2_OUT_SEL   GPIO 2 output mux
 *     GPIO_0_VAL       GPIO 0 output val
 *     GPIO_1_VAL       GPIO 1 output val
 *     GPIO_2_VAL       GPIO 2 output val
 */
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r (0x00018b80 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program GENERAL_PURPOSE_IO_CTL0.
 */
typedef union BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_s {
	uint32_t v[1];
	uint32_t general_purpose_io_ctl0[1];
	uint32_t _general_purpose_io_ctl0;
} BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_t;

#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_CLR(r) (r).general_purpose_io_ctl0[0] = 0
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_SET(r,d) (r).general_purpose_io_ctl0[0] = d
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GET(r) (r).general_purpose_io_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_VALf_GET(r) ((((r).general_purpose_io_ctl0[0]) >> 14) & 0x1)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_VALf_SET(r,f) (r).general_purpose_io_ctl0[0]=(((r).general_purpose_io_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_VALf_GET(r) ((((r).general_purpose_io_ctl0[0]) >> 13) & 0x1)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_VALf_SET(r,f) (r).general_purpose_io_ctl0[0]=(((r).general_purpose_io_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_VALf_GET(r) ((((r).general_purpose_io_ctl0[0]) >> 12) & 0x1)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_VALf_SET(r,f) (r).general_purpose_io_ctl0[0]=(((r).general_purpose_io_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_OUT_SELf_GET(r) ((((r).general_purpose_io_ctl0[0]) >> 8) & 0xf)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_OUT_SELf_SET(r,f) (r).general_purpose_io_ctl0[0]=(((r).general_purpose_io_ctl0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_OUT_SELf_GET(r) ((((r).general_purpose_io_ctl0[0]) >> 4) & 0xf)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_OUT_SELf_SET(r,f) (r).general_purpose_io_ctl0[0]=(((r).general_purpose_io_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_OUT_SELf_GET(r) (((r).general_purpose_io_ctl0[0]) & 0xf)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_OUT_SELf_SET(r,f) (r).general_purpose_io_ctl0[0]=(((r).general_purpose_io_ctl0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access GENERAL_PURPOSE_IO_CTL0.
 */
#define BCMI_MADURA_READ_GENERAL_PURPOSE_IO_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r,_r._general_purpose_io_ctl0)
#define BCMI_MADURA_WRITE_GENERAL_PURPOSE_IO_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r,_r._general_purpose_io_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GENERAL_PURPOSE_IO_CTL0r BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r
#define GENERAL_PURPOSE_IO_CTL0r_SIZE BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_SIZE
typedef BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_t GENERAL_PURPOSE_IO_CTL0r_t;
#define GENERAL_PURPOSE_IO_CTL0r_CLR BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_CLR
#define GENERAL_PURPOSE_IO_CTL0r_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_SET
#define GENERAL_PURPOSE_IO_CTL0r_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_2_VALf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_VALf_GET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_2_VALf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_VALf_SET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_1_VALf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_VALf_GET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_1_VALf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_VALf_SET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_0_VALf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_VALf_GET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_0_VALf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_VALf_SET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_2_OUT_SELf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_OUT_SELf_GET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_2_OUT_SELf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_2_OUT_SELf_SET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_1_OUT_SELf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_OUT_SELf_GET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_1_OUT_SELf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_1_OUT_SELf_SET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_0_OUT_SELf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_OUT_SELf_GET
#define GENERAL_PURPOSE_IO_CTL0r_GPIO_0_OUT_SELf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r_GPIO_0_OUT_SELf_SET
#define READ_GENERAL_PURPOSE_IO_CTL0r BCMI_MADURA_READ_GENERAL_PURPOSE_IO_CTL0r
#define WRITE_GENERAL_PURPOSE_IO_CTL0r BCMI_MADURA_WRITE_GENERAL_PURPOSE_IO_CTL0r
#define MODIFY_GENERAL_PURPOSE_IO_CTL0r BCMI_MADURA_MODIFY_GENERAL_PURPOSE_IO_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GENERAL_PURPOSE_IO_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GENERAL_PURPOSE_IO_CTL1
 * BLOCKS:   CTRL
 * REGADDR:  0x8b81
 * DEVAD:    1
 * DESC:     general purpose IO status select for GPIO 3 through 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GPIO_3_OUT_SEL   GPIO 3 output mux
 *     GPIO_4_OUT_SEL   GPIO 4 output mux
 *     GPIO_3_VAL       GPIO 3 output val
 *     GPIO_4_VAL       GPIO 4 output val
 */
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r (0x00018b81 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program GENERAL_PURPOSE_IO_CTL1.
 */
typedef union BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_s {
	uint32_t v[1];
	uint32_t general_purpose_io_ctl1[1];
	uint32_t _general_purpose_io_ctl1;
} BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_t;

#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_CLR(r) (r).general_purpose_io_ctl1[0] = 0
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_SET(r,d) (r).general_purpose_io_ctl1[0] = d
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GET(r) (r).general_purpose_io_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_VALf_GET(r) ((((r).general_purpose_io_ctl1[0]) >> 13) & 0x1)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_VALf_SET(r,f) (r).general_purpose_io_ctl1[0]=(((r).general_purpose_io_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_VALf_GET(r) ((((r).general_purpose_io_ctl1[0]) >> 12) & 0x1)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_VALf_SET(r,f) (r).general_purpose_io_ctl1[0]=(((r).general_purpose_io_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_OUT_SELf_GET(r) ((((r).general_purpose_io_ctl1[0]) >> 4) & 0xf)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_OUT_SELf_SET(r,f) (r).general_purpose_io_ctl1[0]=(((r).general_purpose_io_ctl1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_OUT_SELf_GET(r) (((r).general_purpose_io_ctl1[0]) & 0xf)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_OUT_SELf_SET(r,f) (r).general_purpose_io_ctl1[0]=(((r).general_purpose_io_ctl1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access GENERAL_PURPOSE_IO_CTL1.
 */
#define BCMI_MADURA_READ_GENERAL_PURPOSE_IO_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r,_r._general_purpose_io_ctl1)
#define BCMI_MADURA_WRITE_GENERAL_PURPOSE_IO_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r,_r._general_purpose_io_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GENERAL_PURPOSE_IO_CTL1r BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r
#define GENERAL_PURPOSE_IO_CTL1r_SIZE BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_SIZE
typedef BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_t GENERAL_PURPOSE_IO_CTL1r_t;
#define GENERAL_PURPOSE_IO_CTL1r_CLR BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_CLR
#define GENERAL_PURPOSE_IO_CTL1r_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_SET
#define GENERAL_PURPOSE_IO_CTL1r_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_4_VALf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_VALf_GET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_4_VALf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_VALf_SET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_3_VALf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_VALf_GET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_3_VALf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_VALf_SET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_4_OUT_SELf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_OUT_SELf_GET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_4_OUT_SELf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_4_OUT_SELf_SET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_3_OUT_SELf_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_OUT_SELf_GET
#define GENERAL_PURPOSE_IO_CTL1r_GPIO_3_OUT_SELf_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r_GPIO_3_OUT_SELf_SET
#define READ_GENERAL_PURPOSE_IO_CTL1r BCMI_MADURA_READ_GENERAL_PURPOSE_IO_CTL1r
#define WRITE_GENERAL_PURPOSE_IO_CTL1r BCMI_MADURA_WRITE_GENERAL_PURPOSE_IO_CTL1r
#define MODIFY_GENERAL_PURPOSE_IO_CTL1r BCMI_MADURA_MODIFY_GENERAL_PURPOSE_IO_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GENERAL_PURPOSE_IO_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GENERAL_PURPOSE_IO_CTL2
 * BLOCKS:   CTRL
 * REGADDR:  0x8b82
 * DEVAD:    1
 * DESC:     general purpose IO status QSFP select
 * RESETVAL: 0x77 (119)
 * ACCESS:   R/W
 * FIELDS:
 *     QSFP_GPIO_SEL0   GPIO pin number selected to send out external module enable 0, valid range is 0 to 4
 *     EN_MOD_INTRN_GPIO_0 enable GPIO 0 as mod_intrn input
 *     QSFP_GPIO_SEL1   GPIO pin number selected to send out external module enable 1, valid range is 0 to 4
 *     EN_EXT_PCS_LINK_GPIO_1 enable GPIO 1 as ext_pcs_link input
 */
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r (0x00018b82 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program GENERAL_PURPOSE_IO_CTL2.
 */
typedef union BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_s {
	uint32_t v[1];
	uint32_t general_purpose_io_ctl2[1];
	uint32_t _general_purpose_io_ctl2;
} BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_t;

#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_CLR(r) (r).general_purpose_io_ctl2[0] = 0
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_SET(r,d) (r).general_purpose_io_ctl2[0] = d
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_GET(r) (r).general_purpose_io_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_EXT_PCS_LINK_GPIO_1f_GET(r) ((((r).general_purpose_io_ctl2[0]) >> 7) & 0x1)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_EXT_PCS_LINK_GPIO_1f_SET(r,f) (r).general_purpose_io_ctl2[0]=(((r).general_purpose_io_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL1f_GET(r) ((((r).general_purpose_io_ctl2[0]) >> 4) & 0x7)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL1f_SET(r,f) (r).general_purpose_io_ctl2[0]=(((r).general_purpose_io_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_MOD_INTRN_GPIO_0f_GET(r) ((((r).general_purpose_io_ctl2[0]) >> 3) & 0x1)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_MOD_INTRN_GPIO_0f_SET(r,f) (r).general_purpose_io_ctl2[0]=(((r).general_purpose_io_ctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL0f_GET(r) (((r).general_purpose_io_ctl2[0]) & 0x7)
#define BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL0f_SET(r,f) (r).general_purpose_io_ctl2[0]=(((r).general_purpose_io_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access GENERAL_PURPOSE_IO_CTL2.
 */
#define BCMI_MADURA_READ_GENERAL_PURPOSE_IO_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r,_r._general_purpose_io_ctl2)
#define BCMI_MADURA_WRITE_GENERAL_PURPOSE_IO_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r,_r._general_purpose_io_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GENERAL_PURPOSE_IO_CTL2r BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r
#define GENERAL_PURPOSE_IO_CTL2r_SIZE BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_SIZE
typedef BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_t GENERAL_PURPOSE_IO_CTL2r_t;
#define GENERAL_PURPOSE_IO_CTL2r_CLR BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_CLR
#define GENERAL_PURPOSE_IO_CTL2r_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_SET
#define GENERAL_PURPOSE_IO_CTL2r_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_GET
#define GENERAL_PURPOSE_IO_CTL2r_EN_EXT_PCS_LINK_GPIO_1f_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_EXT_PCS_LINK_GPIO_1f_GET
#define GENERAL_PURPOSE_IO_CTL2r_EN_EXT_PCS_LINK_GPIO_1f_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_EXT_PCS_LINK_GPIO_1f_SET
#define GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL1f_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL1f_GET
#define GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL1f_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL1f_SET
#define GENERAL_PURPOSE_IO_CTL2r_EN_MOD_INTRN_GPIO_0f_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_MOD_INTRN_GPIO_0f_GET
#define GENERAL_PURPOSE_IO_CTL2r_EN_MOD_INTRN_GPIO_0f_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_EN_MOD_INTRN_GPIO_0f_SET
#define GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL0f_GET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL0f_GET
#define GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL0f_SET BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r_QSFP_GPIO_SEL0f_SET
#define READ_GENERAL_PURPOSE_IO_CTL2r BCMI_MADURA_READ_GENERAL_PURPOSE_IO_CTL2r
#define WRITE_GENERAL_PURPOSE_IO_CTL2r BCMI_MADURA_WRITE_GENERAL_PURPOSE_IO_CTL2r
#define MODIFY_GENERAL_PURPOSE_IO_CTL2r BCMI_MADURA_MODIFY_GENERAL_PURPOSE_IO_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GENERAL_PURPOSE_IO_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TEST_PAD_CTL
 * BLOCKS:   CTRL
 * REGADDR:  0x8b83
 * DEVAD:    1
 * DESC:     GPIO open drain and test pad IO control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ROSC_TESTPAD_EN  When set 1 & UPI/PVTMON are not selected from JTAG, send LIB_ROSC output to TestPad pin
 *     TESTPAD2GPIO3    send testpad out through GPIO3 in case Testpad is not bonded out
 *     GPIO_OPEN_DRAIN_EN 1'b1: Enable GPIO open drain1'b1: oeb is controlled by pad_ctrlbit 6:2 corresponds to GPIO 4 to 0
 */
#define BCMI_MADURA_TEST_PAD_CTLr (0x00018b83 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TEST_PAD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TEST_PAD_CTL.
 */
typedef union BCMI_MADURA_TEST_PAD_CTLr_s {
	uint32_t v[1];
	uint32_t test_pad_ctl[1];
	uint32_t _test_pad_ctl;
} BCMI_MADURA_TEST_PAD_CTLr_t;

#define BCMI_MADURA_TEST_PAD_CTLr_CLR(r) (r).test_pad_ctl[0] = 0
#define BCMI_MADURA_TEST_PAD_CTLr_SET(r,d) (r).test_pad_ctl[0] = d
#define BCMI_MADURA_TEST_PAD_CTLr_GET(r) (r).test_pad_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TEST_PAD_CTLr_GPIO_OPEN_DRAIN_ENf_GET(r) ((((r).test_pad_ctl[0]) >> 2) & 0x1f)
#define BCMI_MADURA_TEST_PAD_CTLr_GPIO_OPEN_DRAIN_ENf_SET(r,f) (r).test_pad_ctl[0]=(((r).test_pad_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2)) | (31 << (16 + 2))
#define BCMI_MADURA_TEST_PAD_CTLr_TESTPAD2GPIO3f_GET(r) ((((r).test_pad_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_TEST_PAD_CTLr_TESTPAD2GPIO3f_SET(r,f) (r).test_pad_ctl[0]=(((r).test_pad_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TEST_PAD_CTLr_ROSC_TESTPAD_ENf_GET(r) (((r).test_pad_ctl[0]) & 0x1)
#define BCMI_MADURA_TEST_PAD_CTLr_ROSC_TESTPAD_ENf_SET(r,f) (r).test_pad_ctl[0]=(((r).test_pad_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TEST_PAD_CTL.
 */
#define BCMI_MADURA_READ_TEST_PAD_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TEST_PAD_CTLr,_r._test_pad_ctl)
#define BCMI_MADURA_WRITE_TEST_PAD_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TEST_PAD_CTLr,_r._test_pad_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TEST_PAD_CTLr BCMI_MADURA_TEST_PAD_CTLr
#define TEST_PAD_CTLr_SIZE BCMI_MADURA_TEST_PAD_CTLr_SIZE
typedef BCMI_MADURA_TEST_PAD_CTLr_t TEST_PAD_CTLr_t;
#define TEST_PAD_CTLr_CLR BCMI_MADURA_TEST_PAD_CTLr_CLR
#define TEST_PAD_CTLr_SET BCMI_MADURA_TEST_PAD_CTLr_SET
#define TEST_PAD_CTLr_GET BCMI_MADURA_TEST_PAD_CTLr_GET
#define TEST_PAD_CTLr_GPIO_OPEN_DRAIN_ENf_GET BCMI_MADURA_TEST_PAD_CTLr_GPIO_OPEN_DRAIN_ENf_GET
#define TEST_PAD_CTLr_GPIO_OPEN_DRAIN_ENf_SET BCMI_MADURA_TEST_PAD_CTLr_GPIO_OPEN_DRAIN_ENf_SET
#define TEST_PAD_CTLr_TESTPAD2GPIO3f_GET BCMI_MADURA_TEST_PAD_CTLr_TESTPAD2GPIO3f_GET
#define TEST_PAD_CTLr_TESTPAD2GPIO3f_SET BCMI_MADURA_TEST_PAD_CTLr_TESTPAD2GPIO3f_SET
#define TEST_PAD_CTLr_ROSC_TESTPAD_ENf_GET BCMI_MADURA_TEST_PAD_CTLr_ROSC_TESTPAD_ENf_GET
#define TEST_PAD_CTLr_ROSC_TESTPAD_ENf_SET BCMI_MADURA_TEST_PAD_CTLr_ROSC_TESTPAD_ENf_SET
#define READ_TEST_PAD_CTLr BCMI_MADURA_READ_TEST_PAD_CTLr
#define WRITE_TEST_PAD_CTLr BCMI_MADURA_WRITE_TEST_PAD_CTLr
#define MODIFY_TEST_PAD_CTLr BCMI_MADURA_MODIFY_TEST_PAD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TEST_PAD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_0_DATARAM_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf1
 * DEVAD:    1
 * DESC:     CL91 0 data RAM tm configuration 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TM_128X40_0_0    CL91 0 data RAM tm[4:0] input 0
 *     TM_128X40_1_0    CL91 0 data RAM tm[4:0] input 1
 *     TM_128X40_2_0    CL91 0 data RAM tm[4:0] input 2
 */
#define BCMI_MADURA_CL91_0_DATARAM_TMr (0x00018bf1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_0_DATARAM_TMr_SIZE 4

/*
 * This structure should be used to declare and program CL91_0_DATARAM_TM.
 */
typedef union BCMI_MADURA_CL91_0_DATARAM_TMr_s {
	uint32_t v[1];
	uint32_t cl91_0_dataram_tm[1];
	uint32_t _cl91_0_dataram_tm;
} BCMI_MADURA_CL91_0_DATARAM_TMr_t;

#define BCMI_MADURA_CL91_0_DATARAM_TMr_CLR(r) (r).cl91_0_dataram_tm[0] = 0
#define BCMI_MADURA_CL91_0_DATARAM_TMr_SET(r,d) (r).cl91_0_dataram_tm[0] = d
#define BCMI_MADURA_CL91_0_DATARAM_TMr_GET(r) (r).cl91_0_dataram_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_2_0f_GET(r) ((((r).cl91_0_dataram_tm[0]) >> 10) & 0x1f)
#define BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_2_0f_SET(r,f) (r).cl91_0_dataram_tm[0]=(((r).cl91_0_dataram_tm[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_1_0f_GET(r) ((((r).cl91_0_dataram_tm[0]) >> 5) & 0x1f)
#define BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_1_0f_SET(r,f) (r).cl91_0_dataram_tm[0]=(((r).cl91_0_dataram_tm[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_0_0f_GET(r) (((r).cl91_0_dataram_tm[0]) & 0x1f)
#define BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_0_0f_SET(r,f) (r).cl91_0_dataram_tm[0]=(((r).cl91_0_dataram_tm[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access CL91_0_DATARAM_TM.
 */
#define BCMI_MADURA_READ_CL91_0_DATARAM_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_0_DATARAM_TMr,_r._cl91_0_dataram_tm)
#define BCMI_MADURA_WRITE_CL91_0_DATARAM_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_0_DATARAM_TMr,_r._cl91_0_dataram_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_0_DATARAM_TMr BCMI_MADURA_CL91_0_DATARAM_TMr
#define CL91_0_DATARAM_TMr_SIZE BCMI_MADURA_CL91_0_DATARAM_TMr_SIZE
typedef BCMI_MADURA_CL91_0_DATARAM_TMr_t CL91_0_DATARAM_TMr_t;
#define CL91_0_DATARAM_TMr_CLR BCMI_MADURA_CL91_0_DATARAM_TMr_CLR
#define CL91_0_DATARAM_TMr_SET BCMI_MADURA_CL91_0_DATARAM_TMr_SET
#define CL91_0_DATARAM_TMr_GET BCMI_MADURA_CL91_0_DATARAM_TMr_GET
#define CL91_0_DATARAM_TMr_TM_128X40_2_0f_GET BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_2_0f_GET
#define CL91_0_DATARAM_TMr_TM_128X40_2_0f_SET BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_2_0f_SET
#define CL91_0_DATARAM_TMr_TM_128X40_1_0f_GET BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_1_0f_GET
#define CL91_0_DATARAM_TMr_TM_128X40_1_0f_SET BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_1_0f_SET
#define CL91_0_DATARAM_TMr_TM_128X40_0_0f_GET BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_0_0f_GET
#define CL91_0_DATARAM_TMr_TM_128X40_0_0f_SET BCMI_MADURA_CL91_0_DATARAM_TMr_TM_128X40_0_0f_SET
#define READ_CL91_0_DATARAM_TMr BCMI_MADURA_READ_CL91_0_DATARAM_TMr
#define WRITE_CL91_0_DATARAM_TMr BCMI_MADURA_WRITE_CL91_0_DATARAM_TMr
#define MODIFY_CL91_0_DATARAM_TMr BCMI_MADURA_MODIFY_CL91_0_DATARAM_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_0_DATARAM_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_0_DATARAM_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf2
 * DEVAD:    1
 * DESC:     FEC 0 data RAM tm configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TM_128X40_3_0    CL91 0 data RAM tm[4:0] input 3
 *     TM_NFD_50X82_LSB_I_0 FEC 0 LSB data RAM tm[4:0] input
 *     TM_NFD_50X82_MSB_I_0 FEC 0 MSB data RAM tm[4:0] input
 */
#define BCMI_MADURA_FEC_0_DATARAM_TMr (0x00018bf2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_0_DATARAM_TMr_SIZE 4

/*
 * This structure should be used to declare and program FEC_0_DATARAM_TM.
 */
typedef union BCMI_MADURA_FEC_0_DATARAM_TMr_s {
	uint32_t v[1];
	uint32_t fec_0_dataram_tm[1];
	uint32_t _fec_0_dataram_tm;
} BCMI_MADURA_FEC_0_DATARAM_TMr_t;

#define BCMI_MADURA_FEC_0_DATARAM_TMr_CLR(r) (r).fec_0_dataram_tm[0] = 0
#define BCMI_MADURA_FEC_0_DATARAM_TMr_SET(r,d) (r).fec_0_dataram_tm[0] = d
#define BCMI_MADURA_FEC_0_DATARAM_TMr_GET(r) (r).fec_0_dataram_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_MSB_I_0f_GET(r) ((((r).fec_0_dataram_tm[0]) >> 10) & 0x1f)
#define BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_MSB_I_0f_SET(r,f) (r).fec_0_dataram_tm[0]=(((r).fec_0_dataram_tm[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_LSB_I_0f_GET(r) ((((r).fec_0_dataram_tm[0]) >> 5) & 0x1f)
#define BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_LSB_I_0f_SET(r,f) (r).fec_0_dataram_tm[0]=(((r).fec_0_dataram_tm[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_FEC_0_DATARAM_TMr_TM_128X40_3_0f_GET(r) (((r).fec_0_dataram_tm[0]) & 0x1f)
#define BCMI_MADURA_FEC_0_DATARAM_TMr_TM_128X40_3_0f_SET(r,f) (r).fec_0_dataram_tm[0]=(((r).fec_0_dataram_tm[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access FEC_0_DATARAM_TM.
 */
#define BCMI_MADURA_READ_FEC_0_DATARAM_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_0_DATARAM_TMr,_r._fec_0_dataram_tm)
#define BCMI_MADURA_WRITE_FEC_0_DATARAM_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_0_DATARAM_TMr,_r._fec_0_dataram_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_0_DATARAM_TMr BCMI_MADURA_FEC_0_DATARAM_TMr
#define FEC_0_DATARAM_TMr_SIZE BCMI_MADURA_FEC_0_DATARAM_TMr_SIZE
typedef BCMI_MADURA_FEC_0_DATARAM_TMr_t FEC_0_DATARAM_TMr_t;
#define FEC_0_DATARAM_TMr_CLR BCMI_MADURA_FEC_0_DATARAM_TMr_CLR
#define FEC_0_DATARAM_TMr_SET BCMI_MADURA_FEC_0_DATARAM_TMr_SET
#define FEC_0_DATARAM_TMr_GET BCMI_MADURA_FEC_0_DATARAM_TMr_GET
#define FEC_0_DATARAM_TMr_TM_NFD_50X82_MSB_I_0f_GET BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_MSB_I_0f_GET
#define FEC_0_DATARAM_TMr_TM_NFD_50X82_MSB_I_0f_SET BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_MSB_I_0f_SET
#define FEC_0_DATARAM_TMr_TM_NFD_50X82_LSB_I_0f_GET BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_LSB_I_0f_GET
#define FEC_0_DATARAM_TMr_TM_NFD_50X82_LSB_I_0f_SET BCMI_MADURA_FEC_0_DATARAM_TMr_TM_NFD_50X82_LSB_I_0f_SET
#define FEC_0_DATARAM_TMr_TM_128X40_3_0f_GET BCMI_MADURA_FEC_0_DATARAM_TMr_TM_128X40_3_0f_GET
#define FEC_0_DATARAM_TMr_TM_128X40_3_0f_SET BCMI_MADURA_FEC_0_DATARAM_TMr_TM_128X40_3_0f_SET
#define READ_FEC_0_DATARAM_TMr BCMI_MADURA_READ_FEC_0_DATARAM_TMr
#define WRITE_FEC_0_DATARAM_TMr BCMI_MADURA_WRITE_FEC_0_DATARAM_TMr
#define MODIFY_FEC_0_DATARAM_TMr BCMI_MADURA_MODIFY_FEC_0_DATARAM_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_0_DATARAM_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_1_DATARAM_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf3
 * DEVAD:    1
 * DESC:     CL91 1 data RAM tm configuration 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TM_128X40_0_1    CL91 1 data RAM tm[4:0] input 0
 *     TM_128X40_1_1    CL91 1 data RAM tm[4:0] input 1
 *     TM_128X40_2_1    CL91 1 data RAM tm[4:0] input 2
 */
#define BCMI_MADURA_CL91_1_DATARAM_TMr (0x00018bf3 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_1_DATARAM_TMr_SIZE 4

/*
 * This structure should be used to declare and program CL91_1_DATARAM_TM.
 */
typedef union BCMI_MADURA_CL91_1_DATARAM_TMr_s {
	uint32_t v[1];
	uint32_t cl91_1_dataram_tm[1];
	uint32_t _cl91_1_dataram_tm;
} BCMI_MADURA_CL91_1_DATARAM_TMr_t;

#define BCMI_MADURA_CL91_1_DATARAM_TMr_CLR(r) (r).cl91_1_dataram_tm[0] = 0
#define BCMI_MADURA_CL91_1_DATARAM_TMr_SET(r,d) (r).cl91_1_dataram_tm[0] = d
#define BCMI_MADURA_CL91_1_DATARAM_TMr_GET(r) (r).cl91_1_dataram_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_2_1f_GET(r) ((((r).cl91_1_dataram_tm[0]) >> 10) & 0x1f)
#define BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_2_1f_SET(r,f) (r).cl91_1_dataram_tm[0]=(((r).cl91_1_dataram_tm[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_1_1f_GET(r) ((((r).cl91_1_dataram_tm[0]) >> 5) & 0x1f)
#define BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_1_1f_SET(r,f) (r).cl91_1_dataram_tm[0]=(((r).cl91_1_dataram_tm[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_0_1f_GET(r) (((r).cl91_1_dataram_tm[0]) & 0x1f)
#define BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_0_1f_SET(r,f) (r).cl91_1_dataram_tm[0]=(((r).cl91_1_dataram_tm[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access CL91_1_DATARAM_TM.
 */
#define BCMI_MADURA_READ_CL91_1_DATARAM_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_1_DATARAM_TMr,_r._cl91_1_dataram_tm)
#define BCMI_MADURA_WRITE_CL91_1_DATARAM_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_1_DATARAM_TMr,_r._cl91_1_dataram_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_1_DATARAM_TMr BCMI_MADURA_CL91_1_DATARAM_TMr
#define CL91_1_DATARAM_TMr_SIZE BCMI_MADURA_CL91_1_DATARAM_TMr_SIZE
typedef BCMI_MADURA_CL91_1_DATARAM_TMr_t CL91_1_DATARAM_TMr_t;
#define CL91_1_DATARAM_TMr_CLR BCMI_MADURA_CL91_1_DATARAM_TMr_CLR
#define CL91_1_DATARAM_TMr_SET BCMI_MADURA_CL91_1_DATARAM_TMr_SET
#define CL91_1_DATARAM_TMr_GET BCMI_MADURA_CL91_1_DATARAM_TMr_GET
#define CL91_1_DATARAM_TMr_TM_128X40_2_1f_GET BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_2_1f_GET
#define CL91_1_DATARAM_TMr_TM_128X40_2_1f_SET BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_2_1f_SET
#define CL91_1_DATARAM_TMr_TM_128X40_1_1f_GET BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_1_1f_GET
#define CL91_1_DATARAM_TMr_TM_128X40_1_1f_SET BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_1_1f_SET
#define CL91_1_DATARAM_TMr_TM_128X40_0_1f_GET BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_0_1f_GET
#define CL91_1_DATARAM_TMr_TM_128X40_0_1f_SET BCMI_MADURA_CL91_1_DATARAM_TMr_TM_128X40_0_1f_SET
#define READ_CL91_1_DATARAM_TMr BCMI_MADURA_READ_CL91_1_DATARAM_TMr
#define WRITE_CL91_1_DATARAM_TMr BCMI_MADURA_WRITE_CL91_1_DATARAM_TMr
#define MODIFY_CL91_1_DATARAM_TMr BCMI_MADURA_MODIFY_CL91_1_DATARAM_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_1_DATARAM_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_1_DATARAM_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf4
 * DEVAD:    1
 * DESC:     FEC 1 data RAM tm configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TM_128X40_3_1    CL91 1 data RAM tm[4:0] input 3
 *     TM_NFD_50X82_LSB_I_1 FEC 1 LSB data RAM tm[4:0] input
 *     TM_NFD_50X82_MSB_I_1 FEC 1 MSB data RAM tm[4:0] input
 */
#define BCMI_MADURA_FEC_1_DATARAM_TMr (0x00018bf4 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_1_DATARAM_TMr_SIZE 4

/*
 * This structure should be used to declare and program FEC_1_DATARAM_TM.
 */
typedef union BCMI_MADURA_FEC_1_DATARAM_TMr_s {
	uint32_t v[1];
	uint32_t fec_1_dataram_tm[1];
	uint32_t _fec_1_dataram_tm;
} BCMI_MADURA_FEC_1_DATARAM_TMr_t;

#define BCMI_MADURA_FEC_1_DATARAM_TMr_CLR(r) (r).fec_1_dataram_tm[0] = 0
#define BCMI_MADURA_FEC_1_DATARAM_TMr_SET(r,d) (r).fec_1_dataram_tm[0] = d
#define BCMI_MADURA_FEC_1_DATARAM_TMr_GET(r) (r).fec_1_dataram_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_MSB_I_1f_GET(r) ((((r).fec_1_dataram_tm[0]) >> 10) & 0x1f)
#define BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_MSB_I_1f_SET(r,f) (r).fec_1_dataram_tm[0]=(((r).fec_1_dataram_tm[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_LSB_I_1f_GET(r) ((((r).fec_1_dataram_tm[0]) >> 5) & 0x1f)
#define BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_LSB_I_1f_SET(r,f) (r).fec_1_dataram_tm[0]=(((r).fec_1_dataram_tm[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_FEC_1_DATARAM_TMr_TM_128X40_3_1f_GET(r) (((r).fec_1_dataram_tm[0]) & 0x1f)
#define BCMI_MADURA_FEC_1_DATARAM_TMr_TM_128X40_3_1f_SET(r,f) (r).fec_1_dataram_tm[0]=(((r).fec_1_dataram_tm[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access FEC_1_DATARAM_TM.
 */
#define BCMI_MADURA_READ_FEC_1_DATARAM_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_1_DATARAM_TMr,_r._fec_1_dataram_tm)
#define BCMI_MADURA_WRITE_FEC_1_DATARAM_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_1_DATARAM_TMr,_r._fec_1_dataram_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_1_DATARAM_TMr BCMI_MADURA_FEC_1_DATARAM_TMr
#define FEC_1_DATARAM_TMr_SIZE BCMI_MADURA_FEC_1_DATARAM_TMr_SIZE
typedef BCMI_MADURA_FEC_1_DATARAM_TMr_t FEC_1_DATARAM_TMr_t;
#define FEC_1_DATARAM_TMr_CLR BCMI_MADURA_FEC_1_DATARAM_TMr_CLR
#define FEC_1_DATARAM_TMr_SET BCMI_MADURA_FEC_1_DATARAM_TMr_SET
#define FEC_1_DATARAM_TMr_GET BCMI_MADURA_FEC_1_DATARAM_TMr_GET
#define FEC_1_DATARAM_TMr_TM_NFD_50X82_MSB_I_1f_GET BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_MSB_I_1f_GET
#define FEC_1_DATARAM_TMr_TM_NFD_50X82_MSB_I_1f_SET BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_MSB_I_1f_SET
#define FEC_1_DATARAM_TMr_TM_NFD_50X82_LSB_I_1f_GET BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_LSB_I_1f_GET
#define FEC_1_DATARAM_TMr_TM_NFD_50X82_LSB_I_1f_SET BCMI_MADURA_FEC_1_DATARAM_TMr_TM_NFD_50X82_LSB_I_1f_SET
#define FEC_1_DATARAM_TMr_TM_128X40_3_1f_GET BCMI_MADURA_FEC_1_DATARAM_TMr_TM_128X40_3_1f_GET
#define FEC_1_DATARAM_TMr_TM_128X40_3_1f_SET BCMI_MADURA_FEC_1_DATARAM_TMr_TM_128X40_3_1f_SET
#define READ_FEC_1_DATARAM_TMr BCMI_MADURA_READ_FEC_1_DATARAM_TMr
#define WRITE_FEC_1_DATARAM_TMr BCMI_MADURA_WRITE_FEC_1_DATARAM_TMr
#define MODIFY_FEC_1_DATARAM_TMr BCMI_MADURA_MODIFY_FEC_1_DATARAM_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_1_DATARAM_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FIFO_BOOT_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf5
 * DEVAD:    1
 * DESC:     M0 TX and RX FIFO RAM and boot ROM tm configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TM_BOOT_ROM      M0 boot ROM tm[5:0] input
 *     TM_TXFIFO        M0 tx FIFO tm[2:0] input
 *     TM_RXFIFO        M0 rx FIFO tm[2:0] input
 */
#define BCMI_MADURA_FIFO_BOOT_TMr (0x00018bf5 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FIFO_BOOT_TMr_SIZE 4

/*
 * This structure should be used to declare and program FIFO_BOOT_TM.
 */
typedef union BCMI_MADURA_FIFO_BOOT_TMr_s {
	uint32_t v[1];
	uint32_t fifo_boot_tm[1];
	uint32_t _fifo_boot_tm;
} BCMI_MADURA_FIFO_BOOT_TMr_t;

#define BCMI_MADURA_FIFO_BOOT_TMr_CLR(r) (r).fifo_boot_tm[0] = 0
#define BCMI_MADURA_FIFO_BOOT_TMr_SET(r,d) (r).fifo_boot_tm[0] = d
#define BCMI_MADURA_FIFO_BOOT_TMr_GET(r) (r).fifo_boot_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FIFO_BOOT_TMr_TM_RXFIFOf_GET(r) ((((r).fifo_boot_tm[0]) >> 12) & 0x7)
#define BCMI_MADURA_FIFO_BOOT_TMr_TM_RXFIFOf_SET(r,f) (r).fifo_boot_tm[0]=(((r).fifo_boot_tm[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_MADURA_FIFO_BOOT_TMr_TM_TXFIFOf_GET(r) ((((r).fifo_boot_tm[0]) >> 8) & 0x7)
#define BCMI_MADURA_FIFO_BOOT_TMr_TM_TXFIFOf_SET(r,f) (r).fifo_boot_tm[0]=(((r).fifo_boot_tm[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_MADURA_FIFO_BOOT_TMr_TM_BOOT_ROMf_GET(r) (((r).fifo_boot_tm[0]) & 0x3f)
#define BCMI_MADURA_FIFO_BOOT_TMr_TM_BOOT_ROMf_SET(r,f) (r).fifo_boot_tm[0]=(((r).fifo_boot_tm[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access FIFO_BOOT_TM.
 */
#define BCMI_MADURA_READ_FIFO_BOOT_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FIFO_BOOT_TMr,_r._fifo_boot_tm)
#define BCMI_MADURA_WRITE_FIFO_BOOT_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FIFO_BOOT_TMr,_r._fifo_boot_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FIFO_BOOT_TMr BCMI_MADURA_FIFO_BOOT_TMr
#define FIFO_BOOT_TMr_SIZE BCMI_MADURA_FIFO_BOOT_TMr_SIZE
typedef BCMI_MADURA_FIFO_BOOT_TMr_t FIFO_BOOT_TMr_t;
#define FIFO_BOOT_TMr_CLR BCMI_MADURA_FIFO_BOOT_TMr_CLR
#define FIFO_BOOT_TMr_SET BCMI_MADURA_FIFO_BOOT_TMr_SET
#define FIFO_BOOT_TMr_GET BCMI_MADURA_FIFO_BOOT_TMr_GET
#define FIFO_BOOT_TMr_TM_RXFIFOf_GET BCMI_MADURA_FIFO_BOOT_TMr_TM_RXFIFOf_GET
#define FIFO_BOOT_TMr_TM_RXFIFOf_SET BCMI_MADURA_FIFO_BOOT_TMr_TM_RXFIFOf_SET
#define FIFO_BOOT_TMr_TM_TXFIFOf_GET BCMI_MADURA_FIFO_BOOT_TMr_TM_TXFIFOf_GET
#define FIFO_BOOT_TMr_TM_TXFIFOf_SET BCMI_MADURA_FIFO_BOOT_TMr_TM_TXFIFOf_SET
#define FIFO_BOOT_TMr_TM_BOOT_ROMf_GET BCMI_MADURA_FIFO_BOOT_TMr_TM_BOOT_ROMf_GET
#define FIFO_BOOT_TMr_TM_BOOT_ROMf_SET BCMI_MADURA_FIFO_BOOT_TMr_TM_BOOT_ROMf_SET
#define READ_FIFO_BOOT_TMr BCMI_MADURA_READ_FIFO_BOOT_TMr
#define WRITE_FIFO_BOOT_TMr BCMI_MADURA_WRITE_FIFO_BOOT_TMr
#define MODIFY_FIFO_BOOT_TMr BCMI_MADURA_MODIFY_FIFO_BOOT_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FIFO_BOOT_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MST_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf6
 * DEVAD:    1
 * DESC:     M0 m code and data RAM tm configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MST_TM_DATA_RAM  M0 mst data RAM tm[6:0] input
 *     MST_TM_CODE_RAM  M0 mst code RAM tm[6:0] input
 */
#define BCMI_MADURA_MST_TMr (0x00018bf6 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MST_TMr_SIZE 4

/*
 * This structure should be used to declare and program MST_TM.
 */
typedef union BCMI_MADURA_MST_TMr_s {
	uint32_t v[1];
	uint32_t mst_tm[1];
	uint32_t _mst_tm;
} BCMI_MADURA_MST_TMr_t;

#define BCMI_MADURA_MST_TMr_CLR(r) (r).mst_tm[0] = 0
#define BCMI_MADURA_MST_TMr_SET(r,d) (r).mst_tm[0] = d
#define BCMI_MADURA_MST_TMr_GET(r) (r).mst_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MST_TMr_MST_TM_CODE_RAMf_GET(r) ((((r).mst_tm[0]) >> 8) & 0x7f)
#define BCMI_MADURA_MST_TMr_MST_TM_CODE_RAMf_SET(r,f) (r).mst_tm[0]=(((r).mst_tm[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_MST_TMr_MST_TM_DATA_RAMf_GET(r) (((r).mst_tm[0]) & 0x7f)
#define BCMI_MADURA_MST_TMr_MST_TM_DATA_RAMf_SET(r,f) (r).mst_tm[0]=(((r).mst_tm[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access MST_TM.
 */
#define BCMI_MADURA_READ_MST_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MST_TMr,_r._mst_tm)
#define BCMI_MADURA_WRITE_MST_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MST_TMr,_r._mst_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MST_TMr BCMI_MADURA_MST_TMr
#define MST_TMr_SIZE BCMI_MADURA_MST_TMr_SIZE
typedef BCMI_MADURA_MST_TMr_t MST_TMr_t;
#define MST_TMr_CLR BCMI_MADURA_MST_TMr_CLR
#define MST_TMr_SET BCMI_MADURA_MST_TMr_SET
#define MST_TMr_GET BCMI_MADURA_MST_TMr_GET
#define MST_TMr_MST_TM_CODE_RAMf_GET BCMI_MADURA_MST_TMr_MST_TM_CODE_RAMf_GET
#define MST_TMr_MST_TM_CODE_RAMf_SET BCMI_MADURA_MST_TMr_MST_TM_CODE_RAMf_SET
#define MST_TMr_MST_TM_DATA_RAMf_GET BCMI_MADURA_MST_TMr_MST_TM_DATA_RAMf_GET
#define MST_TMr_MST_TM_DATA_RAMf_SET BCMI_MADURA_MST_TMr_MST_TM_DATA_RAMf_SET
#define READ_MST_TMr BCMI_MADURA_READ_MST_TMr
#define WRITE_MST_TMr BCMI_MADURA_WRITE_MST_TMr
#define MODIFY_MST_TMr BCMI_MADURA_MODIFY_MST_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MST_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MCTL_DATARAM0_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf7
 * DEVAD:    1
 * DESC:     module controller data RAM 0 tm configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DATARAM0_TM      Module controller data RAM 0 tm[6:0] input
 */
#define BCMI_MADURA_MCTL_DATARAM0_TMr (0x00018bf7 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MCTL_DATARAM0_TMr_SIZE 4

/*
 * This structure should be used to declare and program MCTL_DATARAM0_TM.
 */
typedef union BCMI_MADURA_MCTL_DATARAM0_TMr_s {
	uint32_t v[1];
	uint32_t mctl_dataram0_tm[1];
	uint32_t _mctl_dataram0_tm;
} BCMI_MADURA_MCTL_DATARAM0_TMr_t;

#define BCMI_MADURA_MCTL_DATARAM0_TMr_CLR(r) (r).mctl_dataram0_tm[0] = 0
#define BCMI_MADURA_MCTL_DATARAM0_TMr_SET(r,d) (r).mctl_dataram0_tm[0] = d
#define BCMI_MADURA_MCTL_DATARAM0_TMr_GET(r) (r).mctl_dataram0_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MCTL_DATARAM0_TMr_DATARAM0_TMf_GET(r) (((r).mctl_dataram0_tm[0]) & 0x7f)
#define BCMI_MADURA_MCTL_DATARAM0_TMr_DATARAM0_TMf_SET(r,f) (r).mctl_dataram0_tm[0]=(((r).mctl_dataram0_tm[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access MCTL_DATARAM0_TM.
 */
#define BCMI_MADURA_READ_MCTL_DATARAM0_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MCTL_DATARAM0_TMr,_r._mctl_dataram0_tm)
#define BCMI_MADURA_WRITE_MCTL_DATARAM0_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MCTL_DATARAM0_TMr,_r._mctl_dataram0_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MCTL_DATARAM0_TMr BCMI_MADURA_MCTL_DATARAM0_TMr
#define MCTL_DATARAM0_TMr_SIZE BCMI_MADURA_MCTL_DATARAM0_TMr_SIZE
typedef BCMI_MADURA_MCTL_DATARAM0_TMr_t MCTL_DATARAM0_TMr_t;
#define MCTL_DATARAM0_TMr_CLR BCMI_MADURA_MCTL_DATARAM0_TMr_CLR
#define MCTL_DATARAM0_TMr_SET BCMI_MADURA_MCTL_DATARAM0_TMr_SET
#define MCTL_DATARAM0_TMr_GET BCMI_MADURA_MCTL_DATARAM0_TMr_GET
#define MCTL_DATARAM0_TMr_DATARAM0_TMf_GET BCMI_MADURA_MCTL_DATARAM0_TMr_DATARAM0_TMf_GET
#define MCTL_DATARAM0_TMr_DATARAM0_TMf_SET BCMI_MADURA_MCTL_DATARAM0_TMr_DATARAM0_TMf_SET
#define READ_MCTL_DATARAM0_TMr BCMI_MADURA_READ_MCTL_DATARAM0_TMr
#define WRITE_MCTL_DATARAM0_TMr BCMI_MADURA_WRITE_MCTL_DATARAM0_TMr
#define MODIFY_MCTL_DATARAM0_TMr BCMI_MADURA_MODIFY_MCTL_DATARAM0_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MCTL_DATARAM0_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MCTL_DATARAM1_TM
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf8
 * DEVAD:    1
 * DESC:     module controller data RAM 1 tm configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DATARAM1_TM      Module controller data RAM 1 tm[6:0] input
 */
#define BCMI_MADURA_MCTL_DATARAM1_TMr (0x00018bf8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MCTL_DATARAM1_TMr_SIZE 4

/*
 * This structure should be used to declare and program MCTL_DATARAM1_TM.
 */
typedef union BCMI_MADURA_MCTL_DATARAM1_TMr_s {
	uint32_t v[1];
	uint32_t mctl_dataram1_tm[1];
	uint32_t _mctl_dataram1_tm;
} BCMI_MADURA_MCTL_DATARAM1_TMr_t;

#define BCMI_MADURA_MCTL_DATARAM1_TMr_CLR(r) (r).mctl_dataram1_tm[0] = 0
#define BCMI_MADURA_MCTL_DATARAM1_TMr_SET(r,d) (r).mctl_dataram1_tm[0] = d
#define BCMI_MADURA_MCTL_DATARAM1_TMr_GET(r) (r).mctl_dataram1_tm[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MCTL_DATARAM1_TMr_DATARAM1_TMf_GET(r) (((r).mctl_dataram1_tm[0]) & 0x7f)
#define BCMI_MADURA_MCTL_DATARAM1_TMr_DATARAM1_TMf_SET(r,f) (r).mctl_dataram1_tm[0]=(((r).mctl_dataram1_tm[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access MCTL_DATARAM1_TM.
 */
#define BCMI_MADURA_READ_MCTL_DATARAM1_TMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MCTL_DATARAM1_TMr,_r._mctl_dataram1_tm)
#define BCMI_MADURA_WRITE_MCTL_DATARAM1_TMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MCTL_DATARAM1_TMr,_r._mctl_dataram1_tm)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MCTL_DATARAM1_TMr BCMI_MADURA_MCTL_DATARAM1_TMr
#define MCTL_DATARAM1_TMr_SIZE BCMI_MADURA_MCTL_DATARAM1_TMr_SIZE
typedef BCMI_MADURA_MCTL_DATARAM1_TMr_t MCTL_DATARAM1_TMr_t;
#define MCTL_DATARAM1_TMr_CLR BCMI_MADURA_MCTL_DATARAM1_TMr_CLR
#define MCTL_DATARAM1_TMr_SET BCMI_MADURA_MCTL_DATARAM1_TMr_SET
#define MCTL_DATARAM1_TMr_GET BCMI_MADURA_MCTL_DATARAM1_TMr_GET
#define MCTL_DATARAM1_TMr_DATARAM1_TMf_GET BCMI_MADURA_MCTL_DATARAM1_TMr_DATARAM1_TMf_GET
#define MCTL_DATARAM1_TMr_DATARAM1_TMf_SET BCMI_MADURA_MCTL_DATARAM1_TMr_DATARAM1_TMf_SET
#define READ_MCTL_DATARAM1_TMr BCMI_MADURA_READ_MCTL_DATARAM1_TMr
#define WRITE_MCTL_DATARAM1_TMr BCMI_MADURA_WRITE_MCTL_DATARAM1_TMr
#define MODIFY_MCTL_DATARAM1_TMr BCMI_MADURA_MODIFY_MCTL_DATARAM1_TMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MCTL_DATARAM1_TMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UPI_CTL
 * BLOCKS:   CTRL
 * REGADDR:  0x8bf9
 * DEVAD:    1
 * DESC:     UPI software enable control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UPI_SW_EN        UPI software enable
 */
#define BCMI_MADURA_UPI_CTLr (0x00018bf9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UPI_CTLr_SIZE 4

/*
 * This structure should be used to declare and program UPI_CTL.
 */
typedef union BCMI_MADURA_UPI_CTLr_s {
	uint32_t v[1];
	uint32_t upi_ctl[1];
	uint32_t _upi_ctl;
} BCMI_MADURA_UPI_CTLr_t;

#define BCMI_MADURA_UPI_CTLr_CLR(r) (r).upi_ctl[0] = 0
#define BCMI_MADURA_UPI_CTLr_SET(r,d) (r).upi_ctl[0] = d
#define BCMI_MADURA_UPI_CTLr_GET(r) (r).upi_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UPI_CTLr_UPI_SW_ENf_GET(r) (((r).upi_ctl[0]) & 0x1)
#define BCMI_MADURA_UPI_CTLr_UPI_SW_ENf_SET(r,f) (r).upi_ctl[0]=(((r).upi_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UPI_CTL.
 */
#define BCMI_MADURA_READ_UPI_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UPI_CTLr,_r._upi_ctl)
#define BCMI_MADURA_WRITE_UPI_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UPI_CTLr,_r._upi_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UPI_CTLr BCMI_MADURA_UPI_CTLr
#define UPI_CTLr_SIZE BCMI_MADURA_UPI_CTLr_SIZE
typedef BCMI_MADURA_UPI_CTLr_t UPI_CTLr_t;
#define UPI_CTLr_CLR BCMI_MADURA_UPI_CTLr_CLR
#define UPI_CTLr_SET BCMI_MADURA_UPI_CTLr_SET
#define UPI_CTLr_GET BCMI_MADURA_UPI_CTLr_GET
#define UPI_CTLr_UPI_SW_ENf_GET BCMI_MADURA_UPI_CTLr_UPI_SW_ENf_GET
#define UPI_CTLr_UPI_SW_ENf_SET BCMI_MADURA_UPI_CTLr_UPI_SW_ENf_SET
#define READ_UPI_CTLr BCMI_MADURA_READ_UPI_CTLr
#define WRITE_UPI_CTLr BCMI_MADURA_WRITE_UPI_CTLr
#define MODIFY_UPI_CTLr BCMI_MADURA_MODIFY_UPI_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UPI_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FAL_ACK_TMR
 * BLOCKS:   CTRL
 * REGADDR:  0x8bfa
 * DEVAD:    1
 * DESC:     Falcon time to create artificial falcon ack
 * RESETVAL: 0x70 (112)
 * ACCESS:   R/W
 * FIELDS:
 *     COM_CK_RATIO     Chip com_ck to Falcon com_ck ratioSet to 2'h0, when the Chip com_ck to Falcon com_ck ratio is 1:1 - chip com_ck is the same frequency as falcon com_ckSet to 2'h1, when the Chip com_ck to Falcon com_ck ratio is 1:2 - chip com_ck is half as fast as falcon com_ckSet to 2'h2, when the Chip com_ck to Falcon com_ck ratio is 2:1 - chip com_ck is twice as fast as falcon com_ck
 *     FAL_REG_ACK_TIMER_DIS Falcon ack timer disableWhen set to 1, the falcon ack timer does not startwhen a falcon write enable is detected.Consequently, there will not be an artificial falcon ack generated.
 *     FAL_REG_ACK_TIMER_VALUE Falcon ack timer valueIf falcon ack timer is enabled, the counter startswhen any of the falcon block enables is asserted.When the counter reaches the falcon_ack_timer_value,an artificial falcon ack is created in lieu of the real falcon ack.If a real falcon ack is detected prior to the counter reachingthe falcon_ack_timer_value, the counter is reset to 0 and stops counting.
 */
#define BCMI_MADURA_FAL_ACK_TMRr (0x00018bfa | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FAL_ACK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program FAL_ACK_TMR.
 */
typedef union BCMI_MADURA_FAL_ACK_TMRr_s {
	uint32_t v[1];
	uint32_t fal_ack_tmr[1];
	uint32_t _fal_ack_tmr;
} BCMI_MADURA_FAL_ACK_TMRr_t;

#define BCMI_MADURA_FAL_ACK_TMRr_CLR(r) (r).fal_ack_tmr[0] = 0
#define BCMI_MADURA_FAL_ACK_TMRr_SET(r,d) (r).fal_ack_tmr[0] = d
#define BCMI_MADURA_FAL_ACK_TMRr_GET(r) (r).fal_ack_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_VALUEf_GET(r) ((((r).fal_ack_tmr[0]) >> 4) & 0xff)
#define BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_VALUEf_SET(r,f) (r).fal_ack_tmr[0]=(((r).fal_ack_tmr[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_DISf_GET(r) ((((r).fal_ack_tmr[0]) >> 2) & 0x1)
#define BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_DISf_SET(r,f) (r).fal_ack_tmr[0]=(((r).fal_ack_tmr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FAL_ACK_TMRr_COM_CK_RATIOf_GET(r) (((r).fal_ack_tmr[0]) & 0x3)
#define BCMI_MADURA_FAL_ACK_TMRr_COM_CK_RATIOf_SET(r,f) (r).fal_ack_tmr[0]=(((r).fal_ack_tmr[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access FAL_ACK_TMR.
 */
#define BCMI_MADURA_READ_FAL_ACK_TMRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FAL_ACK_TMRr,_r._fal_ack_tmr)
#define BCMI_MADURA_WRITE_FAL_ACK_TMRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FAL_ACK_TMRr,_r._fal_ack_tmr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FAL_ACK_TMRr BCMI_MADURA_FAL_ACK_TMRr
#define FAL_ACK_TMRr_SIZE BCMI_MADURA_FAL_ACK_TMRr_SIZE
typedef BCMI_MADURA_FAL_ACK_TMRr_t FAL_ACK_TMRr_t;
#define FAL_ACK_TMRr_CLR BCMI_MADURA_FAL_ACK_TMRr_CLR
#define FAL_ACK_TMRr_SET BCMI_MADURA_FAL_ACK_TMRr_SET
#define FAL_ACK_TMRr_GET BCMI_MADURA_FAL_ACK_TMRr_GET
#define FAL_ACK_TMRr_FAL_REG_ACK_TIMER_VALUEf_GET BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_VALUEf_GET
#define FAL_ACK_TMRr_FAL_REG_ACK_TIMER_VALUEf_SET BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_VALUEf_SET
#define FAL_ACK_TMRr_FAL_REG_ACK_TIMER_DISf_GET BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_DISf_GET
#define FAL_ACK_TMRr_FAL_REG_ACK_TIMER_DISf_SET BCMI_MADURA_FAL_ACK_TMRr_FAL_REG_ACK_TIMER_DISf_SET
#define FAL_ACK_TMRr_COM_CK_RATIOf_GET BCMI_MADURA_FAL_ACK_TMRr_COM_CK_RATIOf_GET
#define FAL_ACK_TMRr_COM_CK_RATIOf_SET BCMI_MADURA_FAL_ACK_TMRr_COM_CK_RATIOf_SET
#define READ_FAL_ACK_TMRr BCMI_MADURA_READ_FAL_ACK_TMRr
#define WRITE_FAL_ACK_TMRr BCMI_MADURA_WRITE_FAL_ACK_TMRr
#define MODIFY_FAL_ACK_TMRr BCMI_MADURA_MODIFY_FAL_ACK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FAL_ACK_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_CLK_RST_CNT
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9100
 * DEVAD:    1
 * DESC:     RS decoder controls: clock, reset and error counters
 * RESETVAL: 0x34 (52)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFD_IEEE_ERR_CNT_PRESET 1: preset all the IEEE-defined counters to their maximum valueless 5 for testing counter-saturation purpose.
 *     RG_NFD_ERR_CNT_PRESET 1: preset all the user-defined counters to their maximum valueless 5 for testing counter-saturation purpose.
 *     RG_NFD_ERR_CNT_SOFT_RSTB An active-low soft reset signal to all the user-defined errorcounters in the decoder.0=soft reset all the user-defined error counters.
 *     RG_NFD_DIS_POT_DEC_MALFUNC_DET 0: The decoder uses both potential-decoder malfunction logicand the normal way to generate the decoder failure signal.1: The decoder ony uses the normal way to generate thedecoder failure signal.
 *     RG_NFD_SOFT_RSTB An active-low reset the RS decoder0=soft reset the RS decoder.If the decoder inputs are valid, after de-asserting therg_nfd_soft_rstb_i, the decoder takes at most 3-codewordtime to flush out the internal garbage data.
 *     RG_NFD_CLK_EN    An active-high clock enable for the RS decoder1 = enable the clock.0 = disable the clock.If the decoder inputs are valid, after re-enabling therg_nfd_clk_en_i, the decoder takes at most 3-codewordtime to flush out the internal garbage data.
 *     RG_NFD_ERR_CNT_LOA_CLR_MODE 0 = hold all counters when fec_align_status_rx_i = 01 = clear all counters to 0's when fec_align_status_rx_i = 0
 */
#define BCMI_MADURA_CTL_CLK_RST_CNTr (0x00019100 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_CLK_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program CTL_CLK_RST_CNT.
 */
typedef union BCMI_MADURA_CTL_CLK_RST_CNTr_s {
	uint32_t v[1];
	uint32_t ctl_clk_rst_cnt[1];
	uint32_t _ctl_clk_rst_cnt;
} BCMI_MADURA_CTL_CLK_RST_CNTr_t;

#define BCMI_MADURA_CTL_CLK_RST_CNTr_CLR(r) (r).ctl_clk_rst_cnt[0] = 0
#define BCMI_MADURA_CTL_CLK_RST_CNTr_SET(r,d) (r).ctl_clk_rst_cnt[0] = d
#define BCMI_MADURA_CTL_CLK_RST_CNTr_GET(r) (r).ctl_clk_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_LOA_CLR_MODEf_GET(r) ((((r).ctl_clk_rst_cnt[0]) >> 6) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_LOA_CLR_MODEf_SET(r,f) (r).ctl_clk_rst_cnt[0]=(((r).ctl_clk_rst_cnt[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_CLK_ENf_GET(r) ((((r).ctl_clk_rst_cnt[0]) >> 5) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_CLK_ENf_SET(r,f) (r).ctl_clk_rst_cnt[0]=(((r).ctl_clk_rst_cnt[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_SOFT_RSTBf_GET(r) ((((r).ctl_clk_rst_cnt[0]) >> 4) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_SOFT_RSTBf_SET(r,f) (r).ctl_clk_rst_cnt[0]=(((r).ctl_clk_rst_cnt[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_DIS_POT_DEC_MALFUNC_DETf_GET(r) ((((r).ctl_clk_rst_cnt[0]) >> 3) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_DIS_POT_DEC_MALFUNC_DETf_SET(r,f) (r).ctl_clk_rst_cnt[0]=(((r).ctl_clk_rst_cnt[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_SOFT_RSTBf_GET(r) ((((r).ctl_clk_rst_cnt[0]) >> 2) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_SOFT_RSTBf_SET(r,f) (r).ctl_clk_rst_cnt[0]=(((r).ctl_clk_rst_cnt[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_PRESETf_GET(r) ((((r).ctl_clk_rst_cnt[0]) >> 1) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_PRESETf_SET(r,f) (r).ctl_clk_rst_cnt[0]=(((r).ctl_clk_rst_cnt[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_IEEE_ERR_CNT_PRESETf_GET(r) (((r).ctl_clk_rst_cnt[0]) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_IEEE_ERR_CNT_PRESETf_SET(r,f) (r).ctl_clk_rst_cnt[0]=(((r).ctl_clk_rst_cnt[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CTL_CLK_RST_CNT.
 */
#define BCMI_MADURA_READ_CTL_CLK_RST_CNTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_CLK_RST_CNTr,_r._ctl_clk_rst_cnt)
#define BCMI_MADURA_WRITE_CTL_CLK_RST_CNTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_CLK_RST_CNTr,_r._ctl_clk_rst_cnt)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_CLK_RST_CNTr BCMI_MADURA_CTL_CLK_RST_CNTr
#define CTL_CLK_RST_CNTr_SIZE BCMI_MADURA_CTL_CLK_RST_CNTr_SIZE
typedef BCMI_MADURA_CTL_CLK_RST_CNTr_t CTL_CLK_RST_CNTr_t;
#define CTL_CLK_RST_CNTr_CLR BCMI_MADURA_CTL_CLK_RST_CNTr_CLR
#define CTL_CLK_RST_CNTr_SET BCMI_MADURA_CTL_CLK_RST_CNTr_SET
#define CTL_CLK_RST_CNTr_GET BCMI_MADURA_CTL_CLK_RST_CNTr_GET
#define CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_LOA_CLR_MODEf_GET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_LOA_CLR_MODEf_GET
#define CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_LOA_CLR_MODEf_SET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_LOA_CLR_MODEf_SET
#define CTL_CLK_RST_CNTr_RG_NFD_CLK_ENf_GET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_CLK_ENf_GET
#define CTL_CLK_RST_CNTr_RG_NFD_CLK_ENf_SET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_CLK_ENf_SET
#define CTL_CLK_RST_CNTr_RG_NFD_SOFT_RSTBf_GET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_SOFT_RSTBf_GET
#define CTL_CLK_RST_CNTr_RG_NFD_SOFT_RSTBf_SET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_SOFT_RSTBf_SET
#define CTL_CLK_RST_CNTr_RG_NFD_DIS_POT_DEC_MALFUNC_DETf_GET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_DIS_POT_DEC_MALFUNC_DETf_GET
#define CTL_CLK_RST_CNTr_RG_NFD_DIS_POT_DEC_MALFUNC_DETf_SET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_DIS_POT_DEC_MALFUNC_DETf_SET
#define CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_SOFT_RSTBf_GET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_SOFT_RSTBf_GET
#define CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_SOFT_RSTBf_SET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_SOFT_RSTBf_SET
#define CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_PRESETf_GET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_PRESETf_GET
#define CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_PRESETf_SET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_ERR_CNT_PRESETf_SET
#define CTL_CLK_RST_CNTr_RG_NFD_IEEE_ERR_CNT_PRESETf_GET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_IEEE_ERR_CNT_PRESETf_GET
#define CTL_CLK_RST_CNTr_RG_NFD_IEEE_ERR_CNT_PRESETf_SET BCMI_MADURA_CTL_CLK_RST_CNTr_RG_NFD_IEEE_ERR_CNT_PRESETf_SET
#define READ_CTL_CLK_RST_CNTr BCMI_MADURA_READ_CTL_CLK_RST_CNTr
#define WRITE_CTL_CLK_RST_CNTr BCMI_MADURA_WRITE_CTL_CLK_RST_CNTr
#define MODIFY_CTL_CLK_RST_CNTr BCMI_MADURA_MODIFY_CTL_CLK_RST_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_CLK_RST_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9101
 * DEVAD:    1
 * DESC:     RS decoder status: codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_CW_CNT_0  Bits [15:0] of the 48-bit counter of the received words.Reading this will refresh all of the RS decoder'suser-defined counters.
 */
#define BCMI_MADURA_STAT_CW_CNT0r (0x00019101 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_cw_cnt0[1];
	uint32_t _stat_cw_cnt0;
} BCMI_MADURA_STAT_CW_CNT0r_t;

#define BCMI_MADURA_STAT_CW_CNT0r_CLR(r) (r).stat_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_CW_CNT0r_SET(r,d) (r).stat_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_CW_CNT0r_GET(r) (r).stat_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_CW_CNT0r_NFD_RG_CW_CNT_0f_GET(r) (((r).stat_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_CW_CNT0r_NFD_RG_CW_CNT_0f_SET(r,f) (r).stat_cw_cnt0[0]=(((r).stat_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_CW_CNT0r,_r._stat_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_CW_CNT0r,_r._stat_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_CW_CNT0r BCMI_MADURA_STAT_CW_CNT0r
#define STAT_CW_CNT0r_SIZE BCMI_MADURA_STAT_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_CW_CNT0r_t STAT_CW_CNT0r_t;
#define STAT_CW_CNT0r_CLR BCMI_MADURA_STAT_CW_CNT0r_CLR
#define STAT_CW_CNT0r_SET BCMI_MADURA_STAT_CW_CNT0r_SET
#define STAT_CW_CNT0r_GET BCMI_MADURA_STAT_CW_CNT0r_GET
#define STAT_CW_CNT0r_NFD_RG_CW_CNT_0f_GET BCMI_MADURA_STAT_CW_CNT0r_NFD_RG_CW_CNT_0f_GET
#define STAT_CW_CNT0r_NFD_RG_CW_CNT_0f_SET BCMI_MADURA_STAT_CW_CNT0r_NFD_RG_CW_CNT_0f_SET
#define READ_STAT_CW_CNT0r BCMI_MADURA_READ_STAT_CW_CNT0r
#define WRITE_STAT_CW_CNT0r BCMI_MADURA_WRITE_STAT_CW_CNT0r
#define MODIFY_STAT_CW_CNT0r BCMI_MADURA_MODIFY_STAT_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9102
 * DEVAD:    1
 * DESC:     RS decoder status: codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_CW_CNT_1  Bits [31:16] of the 48-bit counter of the received words.Reading codeword_count[15:0] will refresh this register.
 */
#define BCMI_MADURA_STAT_CW_CNT1r (0x00019102 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_cw_cnt1[1];
	uint32_t _stat_cw_cnt1;
} BCMI_MADURA_STAT_CW_CNT1r_t;

#define BCMI_MADURA_STAT_CW_CNT1r_CLR(r) (r).stat_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_CW_CNT1r_SET(r,d) (r).stat_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_CW_CNT1r_GET(r) (r).stat_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_CW_CNT1r_NFD_RG_CW_CNT_1f_GET(r) (((r).stat_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_CW_CNT1r_NFD_RG_CW_CNT_1f_SET(r,f) (r).stat_cw_cnt1[0]=(((r).stat_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_CW_CNT1r,_r._stat_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_CW_CNT1r,_r._stat_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_CW_CNT1r BCMI_MADURA_STAT_CW_CNT1r
#define STAT_CW_CNT1r_SIZE BCMI_MADURA_STAT_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_CW_CNT1r_t STAT_CW_CNT1r_t;
#define STAT_CW_CNT1r_CLR BCMI_MADURA_STAT_CW_CNT1r_CLR
#define STAT_CW_CNT1r_SET BCMI_MADURA_STAT_CW_CNT1r_SET
#define STAT_CW_CNT1r_GET BCMI_MADURA_STAT_CW_CNT1r_GET
#define STAT_CW_CNT1r_NFD_RG_CW_CNT_1f_GET BCMI_MADURA_STAT_CW_CNT1r_NFD_RG_CW_CNT_1f_GET
#define STAT_CW_CNT1r_NFD_RG_CW_CNT_1f_SET BCMI_MADURA_STAT_CW_CNT1r_NFD_RG_CW_CNT_1f_SET
#define READ_STAT_CW_CNT1r BCMI_MADURA_READ_STAT_CW_CNT1r
#define WRITE_STAT_CW_CNT1r BCMI_MADURA_WRITE_STAT_CW_CNT1r
#define MODIFY_STAT_CW_CNT1r BCMI_MADURA_MODIFY_STAT_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9103
 * DEVAD:    1
 * DESC:     RS decoder status: codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_CW_CNT_2  Bits [47:32] of the 48-bit counter of the received words.Reading codeword_count[15:0] will refresh this register.
 */
#define BCMI_MADURA_STAT_CW_CNT2r (0x00019103 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_cw_cnt2[1];
	uint32_t _stat_cw_cnt2;
} BCMI_MADURA_STAT_CW_CNT2r_t;

#define BCMI_MADURA_STAT_CW_CNT2r_CLR(r) (r).stat_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_CW_CNT2r_SET(r,d) (r).stat_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_CW_CNT2r_GET(r) (r).stat_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_CW_CNT2r_NFD_RG_CW_CNT_2f_GET(r) (((r).stat_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_CW_CNT2r_NFD_RG_CW_CNT_2f_SET(r,f) (r).stat_cw_cnt2[0]=(((r).stat_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_CW_CNT2r,_r._stat_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_CW_CNT2r,_r._stat_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_CW_CNT2r BCMI_MADURA_STAT_CW_CNT2r
#define STAT_CW_CNT2r_SIZE BCMI_MADURA_STAT_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_CW_CNT2r_t STAT_CW_CNT2r_t;
#define STAT_CW_CNT2r_CLR BCMI_MADURA_STAT_CW_CNT2r_CLR
#define STAT_CW_CNT2r_SET BCMI_MADURA_STAT_CW_CNT2r_SET
#define STAT_CW_CNT2r_GET BCMI_MADURA_STAT_CW_CNT2r_GET
#define STAT_CW_CNT2r_NFD_RG_CW_CNT_2f_GET BCMI_MADURA_STAT_CW_CNT2r_NFD_RG_CW_CNT_2f_GET
#define STAT_CW_CNT2r_NFD_RG_CW_CNT_2f_SET BCMI_MADURA_STAT_CW_CNT2r_NFD_RG_CW_CNT_2f_SET
#define READ_STAT_CW_CNT2r BCMI_MADURA_READ_STAT_CW_CNT2r
#define WRITE_STAT_CW_CNT2r BCMI_MADURA_WRITE_STAT_CW_CNT2r
#define MODIFY_STAT_CW_CNT2r BCMI_MADURA_MODIFY_STAT_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_UCORR_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9104
 * DEVAD:    1
 * DESC:     RS decoder status: uncorr_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_UNCORR_CW_CNT_0 Bits [15:0] of the 32-bit counter of the words which are uncorrectablein the error-correction mode and with non-zero errors in theerror-detection-only mode.Reading codeword_count[15:0] will refresh this register.
 */
#define BCMI_MADURA_STAT_UCORR_CW_CNT0r (0x00019104 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_UCORR_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_UCORR_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_UCORR_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_ucorr_cw_cnt0[1];
	uint32_t _stat_ucorr_cw_cnt0;
} BCMI_MADURA_STAT_UCORR_CW_CNT0r_t;

#define BCMI_MADURA_STAT_UCORR_CW_CNT0r_CLR(r) (r).stat_ucorr_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_UCORR_CW_CNT0r_SET(r,d) (r).stat_ucorr_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_UCORR_CW_CNT0r_GET(r) (r).stat_ucorr_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_UCORR_CW_CNT0r_NFD_RG_UNCORR_CW_CNT_0f_GET(r) (((r).stat_ucorr_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_UCORR_CW_CNT0r_NFD_RG_UNCORR_CW_CNT_0f_SET(r,f) (r).stat_ucorr_cw_cnt0[0]=(((r).stat_ucorr_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_UCORR_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_UCORR_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_UCORR_CW_CNT0r,_r._stat_ucorr_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_UCORR_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_UCORR_CW_CNT0r,_r._stat_ucorr_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_UCORR_CW_CNT0r BCMI_MADURA_STAT_UCORR_CW_CNT0r
#define STAT_UCORR_CW_CNT0r_SIZE BCMI_MADURA_STAT_UCORR_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_UCORR_CW_CNT0r_t STAT_UCORR_CW_CNT0r_t;
#define STAT_UCORR_CW_CNT0r_CLR BCMI_MADURA_STAT_UCORR_CW_CNT0r_CLR
#define STAT_UCORR_CW_CNT0r_SET BCMI_MADURA_STAT_UCORR_CW_CNT0r_SET
#define STAT_UCORR_CW_CNT0r_GET BCMI_MADURA_STAT_UCORR_CW_CNT0r_GET
#define STAT_UCORR_CW_CNT0r_NFD_RG_UNCORR_CW_CNT_0f_GET BCMI_MADURA_STAT_UCORR_CW_CNT0r_NFD_RG_UNCORR_CW_CNT_0f_GET
#define STAT_UCORR_CW_CNT0r_NFD_RG_UNCORR_CW_CNT_0f_SET BCMI_MADURA_STAT_UCORR_CW_CNT0r_NFD_RG_UNCORR_CW_CNT_0f_SET
#define READ_STAT_UCORR_CW_CNT0r BCMI_MADURA_READ_STAT_UCORR_CW_CNT0r
#define WRITE_STAT_UCORR_CW_CNT0r BCMI_MADURA_WRITE_STAT_UCORR_CW_CNT0r
#define MODIFY_STAT_UCORR_CW_CNT0r BCMI_MADURA_MODIFY_STAT_UCORR_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_UCORR_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_UCORR_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9105
 * DEVAD:    1
 * DESC:     RS decoder status: uncorr_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_UNCORR_CW_CNT_1 Bits [31:16] of the 32-bit counter of the words which are uncorrectablein the error-correction mode and with non-zero errors in theerror-detection-only mode.Reading codeword_count[15:0] will refresh this register.
 */
#define BCMI_MADURA_STAT_UCORR_CW_CNT1r (0x00019105 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_UCORR_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_UCORR_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_UCORR_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_ucorr_cw_cnt1[1];
	uint32_t _stat_ucorr_cw_cnt1;
} BCMI_MADURA_STAT_UCORR_CW_CNT1r_t;

#define BCMI_MADURA_STAT_UCORR_CW_CNT1r_CLR(r) (r).stat_ucorr_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_UCORR_CW_CNT1r_SET(r,d) (r).stat_ucorr_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_UCORR_CW_CNT1r_GET(r) (r).stat_ucorr_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_UCORR_CW_CNT1r_NFD_RG_UNCORR_CW_CNT_1f_GET(r) (((r).stat_ucorr_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_UCORR_CW_CNT1r_NFD_RG_UNCORR_CW_CNT_1f_SET(r,f) (r).stat_ucorr_cw_cnt1[0]=(((r).stat_ucorr_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_UCORR_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_UCORR_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_UCORR_CW_CNT1r,_r._stat_ucorr_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_UCORR_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_UCORR_CW_CNT1r,_r._stat_ucorr_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_UCORR_CW_CNT1r BCMI_MADURA_STAT_UCORR_CW_CNT1r
#define STAT_UCORR_CW_CNT1r_SIZE BCMI_MADURA_STAT_UCORR_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_UCORR_CW_CNT1r_t STAT_UCORR_CW_CNT1r_t;
#define STAT_UCORR_CW_CNT1r_CLR BCMI_MADURA_STAT_UCORR_CW_CNT1r_CLR
#define STAT_UCORR_CW_CNT1r_SET BCMI_MADURA_STAT_UCORR_CW_CNT1r_SET
#define STAT_UCORR_CW_CNT1r_GET BCMI_MADURA_STAT_UCORR_CW_CNT1r_GET
#define STAT_UCORR_CW_CNT1r_NFD_RG_UNCORR_CW_CNT_1f_GET BCMI_MADURA_STAT_UCORR_CW_CNT1r_NFD_RG_UNCORR_CW_CNT_1f_GET
#define STAT_UCORR_CW_CNT1r_NFD_RG_UNCORR_CW_CNT_1f_SET BCMI_MADURA_STAT_UCORR_CW_CNT1r_NFD_RG_UNCORR_CW_CNT_1f_SET
#define READ_STAT_UCORR_CW_CNT1r BCMI_MADURA_READ_STAT_UCORR_CW_CNT1r
#define WRITE_STAT_UCORR_CW_CNT1r BCMI_MADURA_WRITE_STAT_UCORR_CW_CNT1r
#define MODIFY_STAT_UCORR_CW_CNT1r BCMI_MADURA_MODIFY_STAT_UCORR_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_UCORR_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_FAIL_MALFUNC_CW_CNT
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9106
 * DEVAD:    1
 * DESC:     RS decoder status: fail_malfunc_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_DEC_FAILURE_MALFUNC_CW_CNT The counter of the received words that has caused the decoder tofail but is only caught by the potential-decoder-malfunctionlogic.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr (0x00019106 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_SIZE 4

/*
 * This structure should be used to declare and program STAT_FAIL_MALFUNC_CW_CNT.
 */
typedef union BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_s {
	uint32_t v[1];
	uint32_t stat_fail_malfunc_cw_cnt[1];
	uint32_t _stat_fail_malfunc_cw_cnt;
} BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_t;

#define BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_CLR(r) (r).stat_fail_malfunc_cw_cnt[0] = 0
#define BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_SET(r,d) (r).stat_fail_malfunc_cw_cnt[0] = d
#define BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_GET(r) (r).stat_fail_malfunc_cw_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_NFD_RG_DEC_FAILURE_MALFUNC_CW_CNTf_GET(r) (((r).stat_fail_malfunc_cw_cnt[0]) & 0xffff)
#define BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_NFD_RG_DEC_FAILURE_MALFUNC_CW_CNTf_SET(r,f) (r).stat_fail_malfunc_cw_cnt[0]=(((r).stat_fail_malfunc_cw_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_FAIL_MALFUNC_CW_CNT.
 */
#define BCMI_MADURA_READ_STAT_FAIL_MALFUNC_CW_CNTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr,_r._stat_fail_malfunc_cw_cnt)
#define BCMI_MADURA_WRITE_STAT_FAIL_MALFUNC_CW_CNTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr,_r._stat_fail_malfunc_cw_cnt)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_FAIL_MALFUNC_CW_CNTr BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr
#define STAT_FAIL_MALFUNC_CW_CNTr_SIZE BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_SIZE
typedef BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_t STAT_FAIL_MALFUNC_CW_CNTr_t;
#define STAT_FAIL_MALFUNC_CW_CNTr_CLR BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_CLR
#define STAT_FAIL_MALFUNC_CW_CNTr_SET BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_SET
#define STAT_FAIL_MALFUNC_CW_CNTr_GET BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_GET
#define STAT_FAIL_MALFUNC_CW_CNTr_NFD_RG_DEC_FAILURE_MALFUNC_CW_CNTf_GET BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_NFD_RG_DEC_FAILURE_MALFUNC_CW_CNTf_GET
#define STAT_FAIL_MALFUNC_CW_CNTr_NFD_RG_DEC_FAILURE_MALFUNC_CW_CNTf_SET BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr_NFD_RG_DEC_FAILURE_MALFUNC_CW_CNTf_SET
#define READ_STAT_FAIL_MALFUNC_CW_CNTr BCMI_MADURA_READ_STAT_FAIL_MALFUNC_CW_CNTr
#define WRITE_STAT_FAIL_MALFUNC_CW_CNTr BCMI_MADURA_WRITE_STAT_FAIL_MALFUNC_CW_CNTr
#define MODIFY_STAT_FAIL_MALFUNC_CW_CNTr BCMI_MADURA_MODIFY_STAT_FAIL_MALFUNC_CW_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_FAIL_MALFUNC_CW_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ1_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9107
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq1_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ1_CW_CNT_0 Bits [15:0] of the 48-bit counter of the received words that contain1 symbol error.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r (0x00019107 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ1_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq1_cw_cnt0[1];
	uint32_t _stat_sym_err_eq1_cw_cnt0;
} BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_CLR(r) (r).stat_sym_err_eq1_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_SET(r,d) (r).stat_sym_err_eq1_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_GET(r) (r).stat_sym_err_eq1_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_0f_GET(r) (((r).stat_sym_err_eq1_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_0f_SET(r,f) (r).stat_sym_err_eq1_cw_cnt0[0]=(((r).stat_sym_err_eq1_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ1_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ1_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r,_r._stat_sym_err_eq1_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ1_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r,_r._stat_sym_err_eq1_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ1_CW_CNT0r BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r
#define STAT_SYM_ERR_EQ1_CW_CNT0r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_t STAT_SYM_ERR_EQ1_CW_CNT0r_t;
#define STAT_SYM_ERR_EQ1_CW_CNT0r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_CLR
#define STAT_SYM_ERR_EQ1_CW_CNT0r_SET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_SET
#define STAT_SYM_ERR_EQ1_CW_CNT0r_GET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_GET
#define STAT_SYM_ERR_EQ1_CW_CNT0r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_0f_GET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_0f_GET
#define STAT_SYM_ERR_EQ1_CW_CNT0r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_0f_SET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_0f_SET
#define READ_STAT_SYM_ERR_EQ1_CW_CNT0r BCMI_MADURA_READ_STAT_SYM_ERR_EQ1_CW_CNT0r
#define WRITE_STAT_SYM_ERR_EQ1_CW_CNT0r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ1_CW_CNT0r
#define MODIFY_STAT_SYM_ERR_EQ1_CW_CNT0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ1_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ1_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9108
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq1_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ1_CW_CNT_1 Bits [31:16] of the 48-bit counter of the received words thatcontain 1 symbol error.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r (0x00019108 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ1_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq1_cw_cnt1[1];
	uint32_t _stat_sym_err_eq1_cw_cnt1;
} BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_CLR(r) (r).stat_sym_err_eq1_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_SET(r,d) (r).stat_sym_err_eq1_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_GET(r) (r).stat_sym_err_eq1_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_1f_GET(r) (((r).stat_sym_err_eq1_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_1f_SET(r,f) (r).stat_sym_err_eq1_cw_cnt1[0]=(((r).stat_sym_err_eq1_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ1_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ1_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r,_r._stat_sym_err_eq1_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ1_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r,_r._stat_sym_err_eq1_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ1_CW_CNT1r BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r
#define STAT_SYM_ERR_EQ1_CW_CNT1r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_t STAT_SYM_ERR_EQ1_CW_CNT1r_t;
#define STAT_SYM_ERR_EQ1_CW_CNT1r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_CLR
#define STAT_SYM_ERR_EQ1_CW_CNT1r_SET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_SET
#define STAT_SYM_ERR_EQ1_CW_CNT1r_GET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_GET
#define STAT_SYM_ERR_EQ1_CW_CNT1r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_1f_GET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_1f_GET
#define STAT_SYM_ERR_EQ1_CW_CNT1r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_1f_SET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_1f_SET
#define READ_STAT_SYM_ERR_EQ1_CW_CNT1r BCMI_MADURA_READ_STAT_SYM_ERR_EQ1_CW_CNT1r
#define WRITE_STAT_SYM_ERR_EQ1_CW_CNT1r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ1_CW_CNT1r
#define MODIFY_STAT_SYM_ERR_EQ1_CW_CNT1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ1_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ1_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9109
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq1_codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ1_CW_CNT_2 Bits [47:32] of the 48-bit counter of the received words thatcontain 1 symbol error.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r (0x00019109 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ1_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq1_cw_cnt2[1];
	uint32_t _stat_sym_err_eq1_cw_cnt2;
} BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_CLR(r) (r).stat_sym_err_eq1_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_SET(r,d) (r).stat_sym_err_eq1_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_GET(r) (r).stat_sym_err_eq1_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_2f_GET(r) (((r).stat_sym_err_eq1_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_2f_SET(r,f) (r).stat_sym_err_eq1_cw_cnt2[0]=(((r).stat_sym_err_eq1_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ1_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ1_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r,_r._stat_sym_err_eq1_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ1_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r,_r._stat_sym_err_eq1_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ1_CW_CNT2r BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r
#define STAT_SYM_ERR_EQ1_CW_CNT2r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_t STAT_SYM_ERR_EQ1_CW_CNT2r_t;
#define STAT_SYM_ERR_EQ1_CW_CNT2r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_CLR
#define STAT_SYM_ERR_EQ1_CW_CNT2r_SET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_SET
#define STAT_SYM_ERR_EQ1_CW_CNT2r_GET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_GET
#define STAT_SYM_ERR_EQ1_CW_CNT2r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_2f_GET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_2f_GET
#define STAT_SYM_ERR_EQ1_CW_CNT2r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_2f_SET BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r_NFD_RG_SYMB_ERR_EQ1_CW_CNT_2f_SET
#define READ_STAT_SYM_ERR_EQ1_CW_CNT2r BCMI_MADURA_READ_STAT_SYM_ERR_EQ1_CW_CNT2r
#define WRITE_STAT_SYM_ERR_EQ1_CW_CNT2r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ1_CW_CNT2r
#define MODIFY_STAT_SYM_ERR_EQ1_CW_CNT2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ1_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ1_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ2_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x910a
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq2_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ2_CW_CNT_0 Bits [15:0] of the 48-bit counter of the received words that contain2 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r (0x0001910a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ2_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq2_cw_cnt0[1];
	uint32_t _stat_sym_err_eq2_cw_cnt0;
} BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_CLR(r) (r).stat_sym_err_eq2_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_SET(r,d) (r).stat_sym_err_eq2_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_GET(r) (r).stat_sym_err_eq2_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_0f_GET(r) (((r).stat_sym_err_eq2_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_0f_SET(r,f) (r).stat_sym_err_eq2_cw_cnt0[0]=(((r).stat_sym_err_eq2_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ2_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ2_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r,_r._stat_sym_err_eq2_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ2_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r,_r._stat_sym_err_eq2_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ2_CW_CNT0r BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r
#define STAT_SYM_ERR_EQ2_CW_CNT0r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_t STAT_SYM_ERR_EQ2_CW_CNT0r_t;
#define STAT_SYM_ERR_EQ2_CW_CNT0r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_CLR
#define STAT_SYM_ERR_EQ2_CW_CNT0r_SET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_SET
#define STAT_SYM_ERR_EQ2_CW_CNT0r_GET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_GET
#define STAT_SYM_ERR_EQ2_CW_CNT0r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_0f_GET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_0f_GET
#define STAT_SYM_ERR_EQ2_CW_CNT0r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_0f_SET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_0f_SET
#define READ_STAT_SYM_ERR_EQ2_CW_CNT0r BCMI_MADURA_READ_STAT_SYM_ERR_EQ2_CW_CNT0r
#define WRITE_STAT_SYM_ERR_EQ2_CW_CNT0r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ2_CW_CNT0r
#define MODIFY_STAT_SYM_ERR_EQ2_CW_CNT0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ2_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ2_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x910b
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq2_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ2_CW_CNT_1 Bits [31:16] of the 48-bit counter of the received words thatcontain 2 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r (0x0001910b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ2_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq2_cw_cnt1[1];
	uint32_t _stat_sym_err_eq2_cw_cnt1;
} BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_CLR(r) (r).stat_sym_err_eq2_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_SET(r,d) (r).stat_sym_err_eq2_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_GET(r) (r).stat_sym_err_eq2_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_1f_GET(r) (((r).stat_sym_err_eq2_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_1f_SET(r,f) (r).stat_sym_err_eq2_cw_cnt1[0]=(((r).stat_sym_err_eq2_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ2_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ2_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r,_r._stat_sym_err_eq2_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ2_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r,_r._stat_sym_err_eq2_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ2_CW_CNT1r BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r
#define STAT_SYM_ERR_EQ2_CW_CNT1r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_t STAT_SYM_ERR_EQ2_CW_CNT1r_t;
#define STAT_SYM_ERR_EQ2_CW_CNT1r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_CLR
#define STAT_SYM_ERR_EQ2_CW_CNT1r_SET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_SET
#define STAT_SYM_ERR_EQ2_CW_CNT1r_GET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_GET
#define STAT_SYM_ERR_EQ2_CW_CNT1r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_1f_GET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_1f_GET
#define STAT_SYM_ERR_EQ2_CW_CNT1r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_1f_SET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_1f_SET
#define READ_STAT_SYM_ERR_EQ2_CW_CNT1r BCMI_MADURA_READ_STAT_SYM_ERR_EQ2_CW_CNT1r
#define WRITE_STAT_SYM_ERR_EQ2_CW_CNT1r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ2_CW_CNT1r
#define MODIFY_STAT_SYM_ERR_EQ2_CW_CNT1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ2_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ2_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x910c
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq2_codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ2_CW_CNT_2 Bits [47:32] of the 48-bit counter of the received words thatcontain 2 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r (0x0001910c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ2_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq2_cw_cnt2[1];
	uint32_t _stat_sym_err_eq2_cw_cnt2;
} BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_CLR(r) (r).stat_sym_err_eq2_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_SET(r,d) (r).stat_sym_err_eq2_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_GET(r) (r).stat_sym_err_eq2_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_2f_GET(r) (((r).stat_sym_err_eq2_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_2f_SET(r,f) (r).stat_sym_err_eq2_cw_cnt2[0]=(((r).stat_sym_err_eq2_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ2_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ2_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r,_r._stat_sym_err_eq2_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ2_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r,_r._stat_sym_err_eq2_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ2_CW_CNT2r BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r
#define STAT_SYM_ERR_EQ2_CW_CNT2r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_t STAT_SYM_ERR_EQ2_CW_CNT2r_t;
#define STAT_SYM_ERR_EQ2_CW_CNT2r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_CLR
#define STAT_SYM_ERR_EQ2_CW_CNT2r_SET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_SET
#define STAT_SYM_ERR_EQ2_CW_CNT2r_GET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_GET
#define STAT_SYM_ERR_EQ2_CW_CNT2r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_2f_GET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_2f_GET
#define STAT_SYM_ERR_EQ2_CW_CNT2r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_2f_SET BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r_NFD_RG_SYMB_ERR_EQ2_CW_CNT_2f_SET
#define READ_STAT_SYM_ERR_EQ2_CW_CNT2r BCMI_MADURA_READ_STAT_SYM_ERR_EQ2_CW_CNT2r
#define WRITE_STAT_SYM_ERR_EQ2_CW_CNT2r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ2_CW_CNT2r
#define MODIFY_STAT_SYM_ERR_EQ2_CW_CNT2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ2_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ2_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ3_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x910d
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq3_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ3_CW_CNT_0 Bits [15:0] of the 48-bit counter of the received words that contain3 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r (0x0001910d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ3_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq3_cw_cnt0[1];
	uint32_t _stat_sym_err_eq3_cw_cnt0;
} BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_CLR(r) (r).stat_sym_err_eq3_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_SET(r,d) (r).stat_sym_err_eq3_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_GET(r) (r).stat_sym_err_eq3_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_0f_GET(r) (((r).stat_sym_err_eq3_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_0f_SET(r,f) (r).stat_sym_err_eq3_cw_cnt0[0]=(((r).stat_sym_err_eq3_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ3_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ3_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r,_r._stat_sym_err_eq3_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ3_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r,_r._stat_sym_err_eq3_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ3_CW_CNT0r BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r
#define STAT_SYM_ERR_EQ3_CW_CNT0r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_t STAT_SYM_ERR_EQ3_CW_CNT0r_t;
#define STAT_SYM_ERR_EQ3_CW_CNT0r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_CLR
#define STAT_SYM_ERR_EQ3_CW_CNT0r_SET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_SET
#define STAT_SYM_ERR_EQ3_CW_CNT0r_GET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_GET
#define STAT_SYM_ERR_EQ3_CW_CNT0r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_0f_GET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_0f_GET
#define STAT_SYM_ERR_EQ3_CW_CNT0r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_0f_SET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_0f_SET
#define READ_STAT_SYM_ERR_EQ3_CW_CNT0r BCMI_MADURA_READ_STAT_SYM_ERR_EQ3_CW_CNT0r
#define WRITE_STAT_SYM_ERR_EQ3_CW_CNT0r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ3_CW_CNT0r
#define MODIFY_STAT_SYM_ERR_EQ3_CW_CNT0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ3_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ3_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x910e
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq3_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ3_CW_CNT_1 Bits [31:16] of the 48-bit counter of the received words thatcontain 3 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r (0x0001910e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ3_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq3_cw_cnt1[1];
	uint32_t _stat_sym_err_eq3_cw_cnt1;
} BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_CLR(r) (r).stat_sym_err_eq3_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_SET(r,d) (r).stat_sym_err_eq3_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_GET(r) (r).stat_sym_err_eq3_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_1f_GET(r) (((r).stat_sym_err_eq3_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_1f_SET(r,f) (r).stat_sym_err_eq3_cw_cnt1[0]=(((r).stat_sym_err_eq3_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ3_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ3_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r,_r._stat_sym_err_eq3_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ3_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r,_r._stat_sym_err_eq3_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ3_CW_CNT1r BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r
#define STAT_SYM_ERR_EQ3_CW_CNT1r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_t STAT_SYM_ERR_EQ3_CW_CNT1r_t;
#define STAT_SYM_ERR_EQ3_CW_CNT1r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_CLR
#define STAT_SYM_ERR_EQ3_CW_CNT1r_SET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_SET
#define STAT_SYM_ERR_EQ3_CW_CNT1r_GET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_GET
#define STAT_SYM_ERR_EQ3_CW_CNT1r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_1f_GET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_1f_GET
#define STAT_SYM_ERR_EQ3_CW_CNT1r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_1f_SET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_1f_SET
#define READ_STAT_SYM_ERR_EQ3_CW_CNT1r BCMI_MADURA_READ_STAT_SYM_ERR_EQ3_CW_CNT1r
#define WRITE_STAT_SYM_ERR_EQ3_CW_CNT1r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ3_CW_CNT1r
#define MODIFY_STAT_SYM_ERR_EQ3_CW_CNT1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ3_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ3_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x910f
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq3_codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ3_CW_CNT_2 Bits [47:32] of the 48-bit counter of the received words thatcontain 3 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r (0x0001910f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ3_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq3_cw_cnt2[1];
	uint32_t _stat_sym_err_eq3_cw_cnt2;
} BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_CLR(r) (r).stat_sym_err_eq3_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_SET(r,d) (r).stat_sym_err_eq3_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_GET(r) (r).stat_sym_err_eq3_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_2f_GET(r) (((r).stat_sym_err_eq3_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_2f_SET(r,f) (r).stat_sym_err_eq3_cw_cnt2[0]=(((r).stat_sym_err_eq3_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ3_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ3_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r,_r._stat_sym_err_eq3_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ3_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r,_r._stat_sym_err_eq3_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ3_CW_CNT2r BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r
#define STAT_SYM_ERR_EQ3_CW_CNT2r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_t STAT_SYM_ERR_EQ3_CW_CNT2r_t;
#define STAT_SYM_ERR_EQ3_CW_CNT2r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_CLR
#define STAT_SYM_ERR_EQ3_CW_CNT2r_SET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_SET
#define STAT_SYM_ERR_EQ3_CW_CNT2r_GET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_GET
#define STAT_SYM_ERR_EQ3_CW_CNT2r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_2f_GET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_2f_GET
#define STAT_SYM_ERR_EQ3_CW_CNT2r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_2f_SET BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r_NFD_RG_SYMB_ERR_EQ3_CW_CNT_2f_SET
#define READ_STAT_SYM_ERR_EQ3_CW_CNT2r BCMI_MADURA_READ_STAT_SYM_ERR_EQ3_CW_CNT2r
#define WRITE_STAT_SYM_ERR_EQ3_CW_CNT2r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ3_CW_CNT2r
#define MODIFY_STAT_SYM_ERR_EQ3_CW_CNT2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ3_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ3_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ4_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9110
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq4_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ4_CW_CNT_0 Bits [15:0] of the 48-bit counter of the received words that contain4 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r (0x00019110 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ4_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq4_cw_cnt0[1];
	uint32_t _stat_sym_err_eq4_cw_cnt0;
} BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_CLR(r) (r).stat_sym_err_eq4_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_SET(r,d) (r).stat_sym_err_eq4_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_GET(r) (r).stat_sym_err_eq4_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_0f_GET(r) (((r).stat_sym_err_eq4_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_0f_SET(r,f) (r).stat_sym_err_eq4_cw_cnt0[0]=(((r).stat_sym_err_eq4_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ4_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ4_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r,_r._stat_sym_err_eq4_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ4_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r,_r._stat_sym_err_eq4_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ4_CW_CNT0r BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r
#define STAT_SYM_ERR_EQ4_CW_CNT0r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_t STAT_SYM_ERR_EQ4_CW_CNT0r_t;
#define STAT_SYM_ERR_EQ4_CW_CNT0r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_CLR
#define STAT_SYM_ERR_EQ4_CW_CNT0r_SET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_SET
#define STAT_SYM_ERR_EQ4_CW_CNT0r_GET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_GET
#define STAT_SYM_ERR_EQ4_CW_CNT0r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_0f_GET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_0f_GET
#define STAT_SYM_ERR_EQ4_CW_CNT0r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_0f_SET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_0f_SET
#define READ_STAT_SYM_ERR_EQ4_CW_CNT0r BCMI_MADURA_READ_STAT_SYM_ERR_EQ4_CW_CNT0r
#define WRITE_STAT_SYM_ERR_EQ4_CW_CNT0r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ4_CW_CNT0r
#define MODIFY_STAT_SYM_ERR_EQ4_CW_CNT0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ4_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ4_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9111
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq4_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ4_CW_CNT_1 Bits [31:16] of the 48-bit counter of the received words thatcontain 4 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r (0x00019111 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ4_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq4_cw_cnt1[1];
	uint32_t _stat_sym_err_eq4_cw_cnt1;
} BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_CLR(r) (r).stat_sym_err_eq4_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_SET(r,d) (r).stat_sym_err_eq4_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_GET(r) (r).stat_sym_err_eq4_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_1f_GET(r) (((r).stat_sym_err_eq4_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_1f_SET(r,f) (r).stat_sym_err_eq4_cw_cnt1[0]=(((r).stat_sym_err_eq4_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ4_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ4_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r,_r._stat_sym_err_eq4_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ4_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r,_r._stat_sym_err_eq4_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ4_CW_CNT1r BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r
#define STAT_SYM_ERR_EQ4_CW_CNT1r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_t STAT_SYM_ERR_EQ4_CW_CNT1r_t;
#define STAT_SYM_ERR_EQ4_CW_CNT1r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_CLR
#define STAT_SYM_ERR_EQ4_CW_CNT1r_SET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_SET
#define STAT_SYM_ERR_EQ4_CW_CNT1r_GET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_GET
#define STAT_SYM_ERR_EQ4_CW_CNT1r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_1f_GET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_1f_GET
#define STAT_SYM_ERR_EQ4_CW_CNT1r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_1f_SET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_1f_SET
#define READ_STAT_SYM_ERR_EQ4_CW_CNT1r BCMI_MADURA_READ_STAT_SYM_ERR_EQ4_CW_CNT1r
#define WRITE_STAT_SYM_ERR_EQ4_CW_CNT1r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ4_CW_CNT1r
#define MODIFY_STAT_SYM_ERR_EQ4_CW_CNT1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ4_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ4_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9112
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq4_codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ4_CW_CNT_2 Bits [47:32] of the 48-bit counter of the received words thatcontain 4 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r (0x00019112 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ4_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq4_cw_cnt2[1];
	uint32_t _stat_sym_err_eq4_cw_cnt2;
} BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_CLR(r) (r).stat_sym_err_eq4_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_SET(r,d) (r).stat_sym_err_eq4_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_GET(r) (r).stat_sym_err_eq4_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_2f_GET(r) (((r).stat_sym_err_eq4_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_2f_SET(r,f) (r).stat_sym_err_eq4_cw_cnt2[0]=(((r).stat_sym_err_eq4_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ4_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ4_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r,_r._stat_sym_err_eq4_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ4_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r,_r._stat_sym_err_eq4_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ4_CW_CNT2r BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r
#define STAT_SYM_ERR_EQ4_CW_CNT2r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_t STAT_SYM_ERR_EQ4_CW_CNT2r_t;
#define STAT_SYM_ERR_EQ4_CW_CNT2r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_CLR
#define STAT_SYM_ERR_EQ4_CW_CNT2r_SET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_SET
#define STAT_SYM_ERR_EQ4_CW_CNT2r_GET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_GET
#define STAT_SYM_ERR_EQ4_CW_CNT2r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_2f_GET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_2f_GET
#define STAT_SYM_ERR_EQ4_CW_CNT2r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_2f_SET BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r_NFD_RG_SYMB_ERR_EQ4_CW_CNT_2f_SET
#define READ_STAT_SYM_ERR_EQ4_CW_CNT2r BCMI_MADURA_READ_STAT_SYM_ERR_EQ4_CW_CNT2r
#define WRITE_STAT_SYM_ERR_EQ4_CW_CNT2r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ4_CW_CNT2r
#define MODIFY_STAT_SYM_ERR_EQ4_CW_CNT2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ4_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ4_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ5_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9113
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq5_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ5_CW_CNT_0 Bits [15:0] of the 48-bit counter of the received words that contain5 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r (0x00019113 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ5_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq5_cw_cnt0[1];
	uint32_t _stat_sym_err_eq5_cw_cnt0;
} BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_CLR(r) (r).stat_sym_err_eq5_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_SET(r,d) (r).stat_sym_err_eq5_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_GET(r) (r).stat_sym_err_eq5_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_0f_GET(r) (((r).stat_sym_err_eq5_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_0f_SET(r,f) (r).stat_sym_err_eq5_cw_cnt0[0]=(((r).stat_sym_err_eq5_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ5_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ5_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r,_r._stat_sym_err_eq5_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ5_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r,_r._stat_sym_err_eq5_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ5_CW_CNT0r BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r
#define STAT_SYM_ERR_EQ5_CW_CNT0r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_t STAT_SYM_ERR_EQ5_CW_CNT0r_t;
#define STAT_SYM_ERR_EQ5_CW_CNT0r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_CLR
#define STAT_SYM_ERR_EQ5_CW_CNT0r_SET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_SET
#define STAT_SYM_ERR_EQ5_CW_CNT0r_GET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_GET
#define STAT_SYM_ERR_EQ5_CW_CNT0r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_0f_GET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_0f_GET
#define STAT_SYM_ERR_EQ5_CW_CNT0r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_0f_SET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_0f_SET
#define READ_STAT_SYM_ERR_EQ5_CW_CNT0r BCMI_MADURA_READ_STAT_SYM_ERR_EQ5_CW_CNT0r
#define WRITE_STAT_SYM_ERR_EQ5_CW_CNT0r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ5_CW_CNT0r
#define MODIFY_STAT_SYM_ERR_EQ5_CW_CNT0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ5_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ5_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9114
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq5_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ5_CW_CNT_1 Bits [31:16] of the 48-bit counter of the received words thatcontain 5 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r (0x00019114 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ5_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq5_cw_cnt1[1];
	uint32_t _stat_sym_err_eq5_cw_cnt1;
} BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_CLR(r) (r).stat_sym_err_eq5_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_SET(r,d) (r).stat_sym_err_eq5_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_GET(r) (r).stat_sym_err_eq5_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_1f_GET(r) (((r).stat_sym_err_eq5_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_1f_SET(r,f) (r).stat_sym_err_eq5_cw_cnt1[0]=(((r).stat_sym_err_eq5_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ5_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ5_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r,_r._stat_sym_err_eq5_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ5_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r,_r._stat_sym_err_eq5_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ5_CW_CNT1r BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r
#define STAT_SYM_ERR_EQ5_CW_CNT1r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_t STAT_SYM_ERR_EQ5_CW_CNT1r_t;
#define STAT_SYM_ERR_EQ5_CW_CNT1r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_CLR
#define STAT_SYM_ERR_EQ5_CW_CNT1r_SET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_SET
#define STAT_SYM_ERR_EQ5_CW_CNT1r_GET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_GET
#define STAT_SYM_ERR_EQ5_CW_CNT1r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_1f_GET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_1f_GET
#define STAT_SYM_ERR_EQ5_CW_CNT1r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_1f_SET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_1f_SET
#define READ_STAT_SYM_ERR_EQ5_CW_CNT1r BCMI_MADURA_READ_STAT_SYM_ERR_EQ5_CW_CNT1r
#define WRITE_STAT_SYM_ERR_EQ5_CW_CNT1r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ5_CW_CNT1r
#define MODIFY_STAT_SYM_ERR_EQ5_CW_CNT1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ5_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ5_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9115
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq5_codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ5_CW_CNT_2 Bits [47:32] of the 48-bit counter of the received words thatcontain 5 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r (0x00019115 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ5_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq5_cw_cnt2[1];
	uint32_t _stat_sym_err_eq5_cw_cnt2;
} BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_CLR(r) (r).stat_sym_err_eq5_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_SET(r,d) (r).stat_sym_err_eq5_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_GET(r) (r).stat_sym_err_eq5_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_2f_GET(r) (((r).stat_sym_err_eq5_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_2f_SET(r,f) (r).stat_sym_err_eq5_cw_cnt2[0]=(((r).stat_sym_err_eq5_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ5_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ5_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r,_r._stat_sym_err_eq5_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ5_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r,_r._stat_sym_err_eq5_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ5_CW_CNT2r BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r
#define STAT_SYM_ERR_EQ5_CW_CNT2r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_t STAT_SYM_ERR_EQ5_CW_CNT2r_t;
#define STAT_SYM_ERR_EQ5_CW_CNT2r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_CLR
#define STAT_SYM_ERR_EQ5_CW_CNT2r_SET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_SET
#define STAT_SYM_ERR_EQ5_CW_CNT2r_GET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_GET
#define STAT_SYM_ERR_EQ5_CW_CNT2r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_2f_GET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_2f_GET
#define STAT_SYM_ERR_EQ5_CW_CNT2r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_2f_SET BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r_NFD_RG_SYMB_ERR_EQ5_CW_CNT_2f_SET
#define READ_STAT_SYM_ERR_EQ5_CW_CNT2r BCMI_MADURA_READ_STAT_SYM_ERR_EQ5_CW_CNT2r
#define WRITE_STAT_SYM_ERR_EQ5_CW_CNT2r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ5_CW_CNT2r
#define MODIFY_STAT_SYM_ERR_EQ5_CW_CNT2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ5_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ5_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ6_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9116
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq6_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ6_CW_CNT_0 Bits [15:0] of the 48-bit counter of the received words that contain6 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r (0x00019116 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ6_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq6_cw_cnt0[1];
	uint32_t _stat_sym_err_eq6_cw_cnt0;
} BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_CLR(r) (r).stat_sym_err_eq6_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_SET(r,d) (r).stat_sym_err_eq6_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_GET(r) (r).stat_sym_err_eq6_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_0f_GET(r) (((r).stat_sym_err_eq6_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_0f_SET(r,f) (r).stat_sym_err_eq6_cw_cnt0[0]=(((r).stat_sym_err_eq6_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ6_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ6_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r,_r._stat_sym_err_eq6_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ6_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r,_r._stat_sym_err_eq6_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ6_CW_CNT0r BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r
#define STAT_SYM_ERR_EQ6_CW_CNT0r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_t STAT_SYM_ERR_EQ6_CW_CNT0r_t;
#define STAT_SYM_ERR_EQ6_CW_CNT0r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_CLR
#define STAT_SYM_ERR_EQ6_CW_CNT0r_SET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_SET
#define STAT_SYM_ERR_EQ6_CW_CNT0r_GET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_GET
#define STAT_SYM_ERR_EQ6_CW_CNT0r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_0f_GET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_0f_GET
#define STAT_SYM_ERR_EQ6_CW_CNT0r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_0f_SET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_0f_SET
#define READ_STAT_SYM_ERR_EQ6_CW_CNT0r BCMI_MADURA_READ_STAT_SYM_ERR_EQ6_CW_CNT0r
#define WRITE_STAT_SYM_ERR_EQ6_CW_CNT0r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ6_CW_CNT0r
#define MODIFY_STAT_SYM_ERR_EQ6_CW_CNT0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ6_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ6_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9117
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq6_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ6_CW_CNT_1 Bits [31:16] of the 48-bit counter of the received words thatcontain 6 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r (0x00019117 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ6_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq6_cw_cnt1[1];
	uint32_t _stat_sym_err_eq6_cw_cnt1;
} BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_CLR(r) (r).stat_sym_err_eq6_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_SET(r,d) (r).stat_sym_err_eq6_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_GET(r) (r).stat_sym_err_eq6_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_1f_GET(r) (((r).stat_sym_err_eq6_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_1f_SET(r,f) (r).stat_sym_err_eq6_cw_cnt1[0]=(((r).stat_sym_err_eq6_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ6_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ6_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r,_r._stat_sym_err_eq6_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ6_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r,_r._stat_sym_err_eq6_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ6_CW_CNT1r BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r
#define STAT_SYM_ERR_EQ6_CW_CNT1r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_t STAT_SYM_ERR_EQ6_CW_CNT1r_t;
#define STAT_SYM_ERR_EQ6_CW_CNT1r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_CLR
#define STAT_SYM_ERR_EQ6_CW_CNT1r_SET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_SET
#define STAT_SYM_ERR_EQ6_CW_CNT1r_GET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_GET
#define STAT_SYM_ERR_EQ6_CW_CNT1r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_1f_GET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_1f_GET
#define STAT_SYM_ERR_EQ6_CW_CNT1r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_1f_SET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_1f_SET
#define READ_STAT_SYM_ERR_EQ6_CW_CNT1r BCMI_MADURA_READ_STAT_SYM_ERR_EQ6_CW_CNT1r
#define WRITE_STAT_SYM_ERR_EQ6_CW_CNT1r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ6_CW_CNT1r
#define MODIFY_STAT_SYM_ERR_EQ6_CW_CNT1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ6_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ6_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9118
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq6_codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ6_CW_CNT_2 Bits [47:32] of the 48-bit counter of the received words thatcontain 6 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r (0x00019118 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ6_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq6_cw_cnt2[1];
	uint32_t _stat_sym_err_eq6_cw_cnt2;
} BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_CLR(r) (r).stat_sym_err_eq6_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_SET(r,d) (r).stat_sym_err_eq6_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_GET(r) (r).stat_sym_err_eq6_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_2f_GET(r) (((r).stat_sym_err_eq6_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_2f_SET(r,f) (r).stat_sym_err_eq6_cw_cnt2[0]=(((r).stat_sym_err_eq6_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ6_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ6_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r,_r._stat_sym_err_eq6_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ6_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r,_r._stat_sym_err_eq6_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ6_CW_CNT2r BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r
#define STAT_SYM_ERR_EQ6_CW_CNT2r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_t STAT_SYM_ERR_EQ6_CW_CNT2r_t;
#define STAT_SYM_ERR_EQ6_CW_CNT2r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_CLR
#define STAT_SYM_ERR_EQ6_CW_CNT2r_SET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_SET
#define STAT_SYM_ERR_EQ6_CW_CNT2r_GET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_GET
#define STAT_SYM_ERR_EQ6_CW_CNT2r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_2f_GET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_2f_GET
#define STAT_SYM_ERR_EQ6_CW_CNT2r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_2f_SET BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r_NFD_RG_SYMB_ERR_EQ6_CW_CNT_2f_SET
#define READ_STAT_SYM_ERR_EQ6_CW_CNT2r BCMI_MADURA_READ_STAT_SYM_ERR_EQ6_CW_CNT2r
#define WRITE_STAT_SYM_ERR_EQ6_CW_CNT2r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ6_CW_CNT2r
#define MODIFY_STAT_SYM_ERR_EQ6_CW_CNT2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ6_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ6_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ7_CW_CNT0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9119
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq7_codeword_count[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ7_CW_CNT_0 Bits [15:0] of the 48-bit counter of the received words that contain7 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r (0x00019119 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ7_CW_CNT0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq7_cw_cnt0[1];
	uint32_t _stat_sym_err_eq7_cw_cnt0;
} BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_CLR(r) (r).stat_sym_err_eq7_cw_cnt0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_SET(r,d) (r).stat_sym_err_eq7_cw_cnt0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_GET(r) (r).stat_sym_err_eq7_cw_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_0f_GET(r) (((r).stat_sym_err_eq7_cw_cnt0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_0f_SET(r,f) (r).stat_sym_err_eq7_cw_cnt0[0]=(((r).stat_sym_err_eq7_cw_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ7_CW_CNT0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ7_CW_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r,_r._stat_sym_err_eq7_cw_cnt0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ7_CW_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r,_r._stat_sym_err_eq7_cw_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ7_CW_CNT0r BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r
#define STAT_SYM_ERR_EQ7_CW_CNT0r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_t STAT_SYM_ERR_EQ7_CW_CNT0r_t;
#define STAT_SYM_ERR_EQ7_CW_CNT0r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_CLR
#define STAT_SYM_ERR_EQ7_CW_CNT0r_SET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_SET
#define STAT_SYM_ERR_EQ7_CW_CNT0r_GET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_GET
#define STAT_SYM_ERR_EQ7_CW_CNT0r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_0f_GET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_0f_GET
#define STAT_SYM_ERR_EQ7_CW_CNT0r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_0f_SET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_0f_SET
#define READ_STAT_SYM_ERR_EQ7_CW_CNT0r BCMI_MADURA_READ_STAT_SYM_ERR_EQ7_CW_CNT0r
#define WRITE_STAT_SYM_ERR_EQ7_CW_CNT0r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ7_CW_CNT0r
#define MODIFY_STAT_SYM_ERR_EQ7_CW_CNT0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ7_CW_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ7_CW_CNT1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x911a
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq7_codeword_count[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ7_CW_CNT_1 Bits [31:16] of the 48-bit counter of the received words thatcontain 7 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r (0x0001911a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ7_CW_CNT1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq7_cw_cnt1[1];
	uint32_t _stat_sym_err_eq7_cw_cnt1;
} BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_CLR(r) (r).stat_sym_err_eq7_cw_cnt1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_SET(r,d) (r).stat_sym_err_eq7_cw_cnt1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_GET(r) (r).stat_sym_err_eq7_cw_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_1f_GET(r) (((r).stat_sym_err_eq7_cw_cnt1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_1f_SET(r,f) (r).stat_sym_err_eq7_cw_cnt1[0]=(((r).stat_sym_err_eq7_cw_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ7_CW_CNT1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ7_CW_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r,_r._stat_sym_err_eq7_cw_cnt1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ7_CW_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r,_r._stat_sym_err_eq7_cw_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ7_CW_CNT1r BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r
#define STAT_SYM_ERR_EQ7_CW_CNT1r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_t STAT_SYM_ERR_EQ7_CW_CNT1r_t;
#define STAT_SYM_ERR_EQ7_CW_CNT1r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_CLR
#define STAT_SYM_ERR_EQ7_CW_CNT1r_SET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_SET
#define STAT_SYM_ERR_EQ7_CW_CNT1r_GET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_GET
#define STAT_SYM_ERR_EQ7_CW_CNT1r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_1f_GET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_1f_GET
#define STAT_SYM_ERR_EQ7_CW_CNT1r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_1f_SET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_1f_SET
#define READ_STAT_SYM_ERR_EQ7_CW_CNT1r BCMI_MADURA_READ_STAT_SYM_ERR_EQ7_CW_CNT1r
#define WRITE_STAT_SYM_ERR_EQ7_CW_CNT1r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ7_CW_CNT1r
#define MODIFY_STAT_SYM_ERR_EQ7_CW_CNT1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ7_CW_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_EQ7_CW_CNT2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x911b
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_eq7_codeword_count[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_EQ7_CW_CNT_2 Bits [47:32] of the 48-bit counter of the received words thatcontain 7 symbol errors.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r (0x0001911b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_EQ7_CW_CNT2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_eq7_cw_cnt2[1];
	uint32_t _stat_sym_err_eq7_cw_cnt2;
} BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_CLR(r) (r).stat_sym_err_eq7_cw_cnt2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_SET(r,d) (r).stat_sym_err_eq7_cw_cnt2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_GET(r) (r).stat_sym_err_eq7_cw_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_2f_GET(r) (((r).stat_sym_err_eq7_cw_cnt2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_2f_SET(r,f) (r).stat_sym_err_eq7_cw_cnt2[0]=(((r).stat_sym_err_eq7_cw_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_EQ7_CW_CNT2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_EQ7_CW_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r,_r._stat_sym_err_eq7_cw_cnt2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ7_CW_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r,_r._stat_sym_err_eq7_cw_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_EQ7_CW_CNT2r BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r
#define STAT_SYM_ERR_EQ7_CW_CNT2r_SIZE BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_t STAT_SYM_ERR_EQ7_CW_CNT2r_t;
#define STAT_SYM_ERR_EQ7_CW_CNT2r_CLR BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_CLR
#define STAT_SYM_ERR_EQ7_CW_CNT2r_SET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_SET
#define STAT_SYM_ERR_EQ7_CW_CNT2r_GET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_GET
#define STAT_SYM_ERR_EQ7_CW_CNT2r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_2f_GET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_2f_GET
#define STAT_SYM_ERR_EQ7_CW_CNT2r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_2f_SET BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r_NFD_RG_SYMB_ERR_EQ7_CW_CNT_2f_SET
#define READ_STAT_SYM_ERR_EQ7_CW_CNT2r BCMI_MADURA_READ_STAT_SYM_ERR_EQ7_CW_CNT2r
#define WRITE_STAT_SYM_ERR_EQ7_CW_CNT2r BCMI_MADURA_WRITE_STAT_SYM_ERR_EQ7_CW_CNT2r
#define MODIFY_STAT_SYM_ERR_EQ7_CW_CNT2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_EQ7_CW_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_EQ7_CW_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN0_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x911c
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane0[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN0_0 Bits [15:0] of the 48-bit counter of symbol errors in the lane0.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r (0x0001911c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN0_0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln0_0[1];
	uint32_t _stat_sym_err_cnt_ln0_0;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_CLR(r) (r).stat_sym_err_cnt_ln0_0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_SET(r,d) (r).stat_sym_err_cnt_ln0_0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_GET(r) (r).stat_sym_err_cnt_ln0_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_NFD_RG_SYMB_ERR_CNT_LN0_0f_GET(r) (((r).stat_sym_err_cnt_ln0_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_NFD_RG_SYMB_ERR_CNT_LN0_0f_SET(r,f) (r).stat_sym_err_cnt_ln0_0[0]=(((r).stat_sym_err_cnt_ln0_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN0_0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN0_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r,_r._stat_sym_err_cnt_ln0_0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN0_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r,_r._stat_sym_err_cnt_ln0_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN0_0r BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r
#define STAT_SYM_ERR_CNT_LN0_0r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_t STAT_SYM_ERR_CNT_LN0_0r_t;
#define STAT_SYM_ERR_CNT_LN0_0r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_CLR
#define STAT_SYM_ERR_CNT_LN0_0r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_SET
#define STAT_SYM_ERR_CNT_LN0_0r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_GET
#define STAT_SYM_ERR_CNT_LN0_0r_NFD_RG_SYMB_ERR_CNT_LN0_0f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_NFD_RG_SYMB_ERR_CNT_LN0_0f_GET
#define STAT_SYM_ERR_CNT_LN0_0r_NFD_RG_SYMB_ERR_CNT_LN0_0f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r_NFD_RG_SYMB_ERR_CNT_LN0_0f_SET
#define READ_STAT_SYM_ERR_CNT_LN0_0r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN0_0r
#define WRITE_STAT_SYM_ERR_CNT_LN0_0r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN0_0r
#define MODIFY_STAT_SYM_ERR_CNT_LN0_0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN0_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN0_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x911d
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane0[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN0_1 Bits [31:16] of the 48-bit counter of symbol errors in the lane0.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r (0x0001911d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN0_1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln0_1[1];
	uint32_t _stat_sym_err_cnt_ln0_1;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_CLR(r) (r).stat_sym_err_cnt_ln0_1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_SET(r,d) (r).stat_sym_err_cnt_ln0_1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_GET(r) (r).stat_sym_err_cnt_ln0_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_NFD_RG_SYMB_ERR_CNT_LN0_1f_GET(r) (((r).stat_sym_err_cnt_ln0_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_NFD_RG_SYMB_ERR_CNT_LN0_1f_SET(r,f) (r).stat_sym_err_cnt_ln0_1[0]=(((r).stat_sym_err_cnt_ln0_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN0_1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN0_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r,_r._stat_sym_err_cnt_ln0_1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN0_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r,_r._stat_sym_err_cnt_ln0_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN0_1r BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r
#define STAT_SYM_ERR_CNT_LN0_1r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_t STAT_SYM_ERR_CNT_LN0_1r_t;
#define STAT_SYM_ERR_CNT_LN0_1r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_CLR
#define STAT_SYM_ERR_CNT_LN0_1r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_SET
#define STAT_SYM_ERR_CNT_LN0_1r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_GET
#define STAT_SYM_ERR_CNT_LN0_1r_NFD_RG_SYMB_ERR_CNT_LN0_1f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_NFD_RG_SYMB_ERR_CNT_LN0_1f_GET
#define STAT_SYM_ERR_CNT_LN0_1r_NFD_RG_SYMB_ERR_CNT_LN0_1f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r_NFD_RG_SYMB_ERR_CNT_LN0_1f_SET
#define READ_STAT_SYM_ERR_CNT_LN0_1r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN0_1r
#define WRITE_STAT_SYM_ERR_CNT_LN0_1r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN0_1r
#define MODIFY_STAT_SYM_ERR_CNT_LN0_1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN0_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x911e
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane0[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN0_2 Bits [47:32] of the 48-bit counter of symbol errors in the lane0.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r (0x0001911e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN0_2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln0_2[1];
	uint32_t _stat_sym_err_cnt_ln0_2;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_CLR(r) (r).stat_sym_err_cnt_ln0_2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_SET(r,d) (r).stat_sym_err_cnt_ln0_2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_GET(r) (r).stat_sym_err_cnt_ln0_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_NFD_RG_SYMB_ERR_CNT_LN0_2f_GET(r) (((r).stat_sym_err_cnt_ln0_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_NFD_RG_SYMB_ERR_CNT_LN0_2f_SET(r,f) (r).stat_sym_err_cnt_ln0_2[0]=(((r).stat_sym_err_cnt_ln0_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN0_2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN0_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r,_r._stat_sym_err_cnt_ln0_2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN0_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r,_r._stat_sym_err_cnt_ln0_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN0_2r BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r
#define STAT_SYM_ERR_CNT_LN0_2r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_t STAT_SYM_ERR_CNT_LN0_2r_t;
#define STAT_SYM_ERR_CNT_LN0_2r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_CLR
#define STAT_SYM_ERR_CNT_LN0_2r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_SET
#define STAT_SYM_ERR_CNT_LN0_2r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_GET
#define STAT_SYM_ERR_CNT_LN0_2r_NFD_RG_SYMB_ERR_CNT_LN0_2f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_NFD_RG_SYMB_ERR_CNT_LN0_2f_GET
#define STAT_SYM_ERR_CNT_LN0_2r_NFD_RG_SYMB_ERR_CNT_LN0_2f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r_NFD_RG_SYMB_ERR_CNT_LN0_2f_SET
#define READ_STAT_SYM_ERR_CNT_LN0_2r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN0_2r
#define WRITE_STAT_SYM_ERR_CNT_LN0_2r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN0_2r
#define MODIFY_STAT_SYM_ERR_CNT_LN0_2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN0_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN0_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN1_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x911f
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane1[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN1_0 Bits [15:0] of the 48-bit counter of symbol errors in the lane1.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r (0x0001911f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN1_0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln1_0[1];
	uint32_t _stat_sym_err_cnt_ln1_0;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_CLR(r) (r).stat_sym_err_cnt_ln1_0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_SET(r,d) (r).stat_sym_err_cnt_ln1_0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_GET(r) (r).stat_sym_err_cnt_ln1_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_NFD_RG_SYMB_ERR_CNT_LN1_0f_GET(r) (((r).stat_sym_err_cnt_ln1_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_NFD_RG_SYMB_ERR_CNT_LN1_0f_SET(r,f) (r).stat_sym_err_cnt_ln1_0[0]=(((r).stat_sym_err_cnt_ln1_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN1_0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN1_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r,_r._stat_sym_err_cnt_ln1_0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN1_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r,_r._stat_sym_err_cnt_ln1_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN1_0r BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r
#define STAT_SYM_ERR_CNT_LN1_0r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_t STAT_SYM_ERR_CNT_LN1_0r_t;
#define STAT_SYM_ERR_CNT_LN1_0r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_CLR
#define STAT_SYM_ERR_CNT_LN1_0r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_SET
#define STAT_SYM_ERR_CNT_LN1_0r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_GET
#define STAT_SYM_ERR_CNT_LN1_0r_NFD_RG_SYMB_ERR_CNT_LN1_0f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_NFD_RG_SYMB_ERR_CNT_LN1_0f_GET
#define STAT_SYM_ERR_CNT_LN1_0r_NFD_RG_SYMB_ERR_CNT_LN1_0f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r_NFD_RG_SYMB_ERR_CNT_LN1_0f_SET
#define READ_STAT_SYM_ERR_CNT_LN1_0r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN1_0r
#define WRITE_STAT_SYM_ERR_CNT_LN1_0r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN1_0r
#define MODIFY_STAT_SYM_ERR_CNT_LN1_0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN1_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN1_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9120
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane1[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN1_1 Bits [31:16] of the 48-bit counter of symbol errors in the lane1.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r (0x00019120 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN1_1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln1_1[1];
	uint32_t _stat_sym_err_cnt_ln1_1;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_CLR(r) (r).stat_sym_err_cnt_ln1_1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_SET(r,d) (r).stat_sym_err_cnt_ln1_1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_GET(r) (r).stat_sym_err_cnt_ln1_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_NFD_RG_SYMB_ERR_CNT_LN1_1f_GET(r) (((r).stat_sym_err_cnt_ln1_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_NFD_RG_SYMB_ERR_CNT_LN1_1f_SET(r,f) (r).stat_sym_err_cnt_ln1_1[0]=(((r).stat_sym_err_cnt_ln1_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN1_1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN1_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r,_r._stat_sym_err_cnt_ln1_1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN1_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r,_r._stat_sym_err_cnt_ln1_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN1_1r BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r
#define STAT_SYM_ERR_CNT_LN1_1r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_t STAT_SYM_ERR_CNT_LN1_1r_t;
#define STAT_SYM_ERR_CNT_LN1_1r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_CLR
#define STAT_SYM_ERR_CNT_LN1_1r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_SET
#define STAT_SYM_ERR_CNT_LN1_1r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_GET
#define STAT_SYM_ERR_CNT_LN1_1r_NFD_RG_SYMB_ERR_CNT_LN1_1f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_NFD_RG_SYMB_ERR_CNT_LN1_1f_GET
#define STAT_SYM_ERR_CNT_LN1_1r_NFD_RG_SYMB_ERR_CNT_LN1_1f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r_NFD_RG_SYMB_ERR_CNT_LN1_1f_SET
#define READ_STAT_SYM_ERR_CNT_LN1_1r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN1_1r
#define WRITE_STAT_SYM_ERR_CNT_LN1_1r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN1_1r
#define MODIFY_STAT_SYM_ERR_CNT_LN1_1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN1_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN1_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9121
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane1[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN1_2 Bits [47:32] of the 48-bit counter of symbol errors in the lane1.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r (0x00019121 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN1_2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln1_2[1];
	uint32_t _stat_sym_err_cnt_ln1_2;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_CLR(r) (r).stat_sym_err_cnt_ln1_2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_SET(r,d) (r).stat_sym_err_cnt_ln1_2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_GET(r) (r).stat_sym_err_cnt_ln1_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_NFD_RG_SYMB_ERR_CNT_LN1_2f_GET(r) (((r).stat_sym_err_cnt_ln1_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_NFD_RG_SYMB_ERR_CNT_LN1_2f_SET(r,f) (r).stat_sym_err_cnt_ln1_2[0]=(((r).stat_sym_err_cnt_ln1_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN1_2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN1_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r,_r._stat_sym_err_cnt_ln1_2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN1_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r,_r._stat_sym_err_cnt_ln1_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN1_2r BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r
#define STAT_SYM_ERR_CNT_LN1_2r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_t STAT_SYM_ERR_CNT_LN1_2r_t;
#define STAT_SYM_ERR_CNT_LN1_2r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_CLR
#define STAT_SYM_ERR_CNT_LN1_2r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_SET
#define STAT_SYM_ERR_CNT_LN1_2r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_GET
#define STAT_SYM_ERR_CNT_LN1_2r_NFD_RG_SYMB_ERR_CNT_LN1_2f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_NFD_RG_SYMB_ERR_CNT_LN1_2f_GET
#define STAT_SYM_ERR_CNT_LN1_2r_NFD_RG_SYMB_ERR_CNT_LN1_2f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r_NFD_RG_SYMB_ERR_CNT_LN1_2f_SET
#define READ_STAT_SYM_ERR_CNT_LN1_2r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN1_2r
#define WRITE_STAT_SYM_ERR_CNT_LN1_2r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN1_2r
#define MODIFY_STAT_SYM_ERR_CNT_LN1_2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN1_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN1_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN2_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9122
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane2[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN2_0 Bits [15:0] of the 48-bit counter of symbol errors in the lane2.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r (0x00019122 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN2_0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln2_0[1];
	uint32_t _stat_sym_err_cnt_ln2_0;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_CLR(r) (r).stat_sym_err_cnt_ln2_0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_SET(r,d) (r).stat_sym_err_cnt_ln2_0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_GET(r) (r).stat_sym_err_cnt_ln2_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_NFD_RG_SYMB_ERR_CNT_LN2_0f_GET(r) (((r).stat_sym_err_cnt_ln2_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_NFD_RG_SYMB_ERR_CNT_LN2_0f_SET(r,f) (r).stat_sym_err_cnt_ln2_0[0]=(((r).stat_sym_err_cnt_ln2_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN2_0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN2_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r,_r._stat_sym_err_cnt_ln2_0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN2_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r,_r._stat_sym_err_cnt_ln2_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN2_0r BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r
#define STAT_SYM_ERR_CNT_LN2_0r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_t STAT_SYM_ERR_CNT_LN2_0r_t;
#define STAT_SYM_ERR_CNT_LN2_0r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_CLR
#define STAT_SYM_ERR_CNT_LN2_0r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_SET
#define STAT_SYM_ERR_CNT_LN2_0r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_GET
#define STAT_SYM_ERR_CNT_LN2_0r_NFD_RG_SYMB_ERR_CNT_LN2_0f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_NFD_RG_SYMB_ERR_CNT_LN2_0f_GET
#define STAT_SYM_ERR_CNT_LN2_0r_NFD_RG_SYMB_ERR_CNT_LN2_0f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r_NFD_RG_SYMB_ERR_CNT_LN2_0f_SET
#define READ_STAT_SYM_ERR_CNT_LN2_0r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN2_0r
#define WRITE_STAT_SYM_ERR_CNT_LN2_0r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN2_0r
#define MODIFY_STAT_SYM_ERR_CNT_LN2_0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN2_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN2_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9123
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane2[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN2_1 Bits [31:16] of the 48-bit counter of symbol errors in the lane2.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r (0x00019123 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN2_1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln2_1[1];
	uint32_t _stat_sym_err_cnt_ln2_1;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_CLR(r) (r).stat_sym_err_cnt_ln2_1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_SET(r,d) (r).stat_sym_err_cnt_ln2_1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_GET(r) (r).stat_sym_err_cnt_ln2_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_NFD_RG_SYMB_ERR_CNT_LN2_1f_GET(r) (((r).stat_sym_err_cnt_ln2_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_NFD_RG_SYMB_ERR_CNT_LN2_1f_SET(r,f) (r).stat_sym_err_cnt_ln2_1[0]=(((r).stat_sym_err_cnt_ln2_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN2_1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN2_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r,_r._stat_sym_err_cnt_ln2_1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN2_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r,_r._stat_sym_err_cnt_ln2_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN2_1r BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r
#define STAT_SYM_ERR_CNT_LN2_1r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_t STAT_SYM_ERR_CNT_LN2_1r_t;
#define STAT_SYM_ERR_CNT_LN2_1r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_CLR
#define STAT_SYM_ERR_CNT_LN2_1r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_SET
#define STAT_SYM_ERR_CNT_LN2_1r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_GET
#define STAT_SYM_ERR_CNT_LN2_1r_NFD_RG_SYMB_ERR_CNT_LN2_1f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_NFD_RG_SYMB_ERR_CNT_LN2_1f_GET
#define STAT_SYM_ERR_CNT_LN2_1r_NFD_RG_SYMB_ERR_CNT_LN2_1f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r_NFD_RG_SYMB_ERR_CNT_LN2_1f_SET
#define READ_STAT_SYM_ERR_CNT_LN2_1r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN2_1r
#define WRITE_STAT_SYM_ERR_CNT_LN2_1r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN2_1r
#define MODIFY_STAT_SYM_ERR_CNT_LN2_1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN2_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN2_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9124
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane2[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN2_2 Bits [47:32] of the 48-bit counter of symbol errors in the lane2.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r (0x00019124 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN2_2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln2_2[1];
	uint32_t _stat_sym_err_cnt_ln2_2;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_CLR(r) (r).stat_sym_err_cnt_ln2_2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_SET(r,d) (r).stat_sym_err_cnt_ln2_2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_GET(r) (r).stat_sym_err_cnt_ln2_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_NFD_RG_SYMB_ERR_CNT_LN2_2f_GET(r) (((r).stat_sym_err_cnt_ln2_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_NFD_RG_SYMB_ERR_CNT_LN2_2f_SET(r,f) (r).stat_sym_err_cnt_ln2_2[0]=(((r).stat_sym_err_cnt_ln2_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN2_2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN2_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r,_r._stat_sym_err_cnt_ln2_2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN2_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r,_r._stat_sym_err_cnt_ln2_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN2_2r BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r
#define STAT_SYM_ERR_CNT_LN2_2r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_t STAT_SYM_ERR_CNT_LN2_2r_t;
#define STAT_SYM_ERR_CNT_LN2_2r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_CLR
#define STAT_SYM_ERR_CNT_LN2_2r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_SET
#define STAT_SYM_ERR_CNT_LN2_2r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_GET
#define STAT_SYM_ERR_CNT_LN2_2r_NFD_RG_SYMB_ERR_CNT_LN2_2f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_NFD_RG_SYMB_ERR_CNT_LN2_2f_GET
#define STAT_SYM_ERR_CNT_LN2_2r_NFD_RG_SYMB_ERR_CNT_LN2_2f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r_NFD_RG_SYMB_ERR_CNT_LN2_2f_SET
#define READ_STAT_SYM_ERR_CNT_LN2_2r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN2_2r
#define WRITE_STAT_SYM_ERR_CNT_LN2_2r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN2_2r
#define MODIFY_STAT_SYM_ERR_CNT_LN2_2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN2_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN2_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN3_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9125
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane3[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN3_0 Bits [15:0] of the 48-bit counter of symbol errors in the lane3.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r (0x00019125 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN3_0.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln3_0[1];
	uint32_t _stat_sym_err_cnt_ln3_0;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_CLR(r) (r).stat_sym_err_cnt_ln3_0[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_SET(r,d) (r).stat_sym_err_cnt_ln3_0[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_GET(r) (r).stat_sym_err_cnt_ln3_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_NFD_RG_SYMB_ERR_CNT_LN3_0f_GET(r) (((r).stat_sym_err_cnt_ln3_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_NFD_RG_SYMB_ERR_CNT_LN3_0f_SET(r,f) (r).stat_sym_err_cnt_ln3_0[0]=(((r).stat_sym_err_cnt_ln3_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN3_0.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN3_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r,_r._stat_sym_err_cnt_ln3_0)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN3_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r,_r._stat_sym_err_cnt_ln3_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN3_0r BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r
#define STAT_SYM_ERR_CNT_LN3_0r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_t STAT_SYM_ERR_CNT_LN3_0r_t;
#define STAT_SYM_ERR_CNT_LN3_0r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_CLR
#define STAT_SYM_ERR_CNT_LN3_0r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_SET
#define STAT_SYM_ERR_CNT_LN3_0r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_GET
#define STAT_SYM_ERR_CNT_LN3_0r_NFD_RG_SYMB_ERR_CNT_LN3_0f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_NFD_RG_SYMB_ERR_CNT_LN3_0f_GET
#define STAT_SYM_ERR_CNT_LN3_0r_NFD_RG_SYMB_ERR_CNT_LN3_0f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r_NFD_RG_SYMB_ERR_CNT_LN3_0f_SET
#define READ_STAT_SYM_ERR_CNT_LN3_0r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN3_0r
#define WRITE_STAT_SYM_ERR_CNT_LN3_0r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN3_0r
#define MODIFY_STAT_SYM_ERR_CNT_LN3_0r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN3_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN3_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9126
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane3[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN3_1 Bits [31:16] of the 48-bit counter of symbol errors in the lane3.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r (0x00019126 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN3_1.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln3_1[1];
	uint32_t _stat_sym_err_cnt_ln3_1;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_CLR(r) (r).stat_sym_err_cnt_ln3_1[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_SET(r,d) (r).stat_sym_err_cnt_ln3_1[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_GET(r) (r).stat_sym_err_cnt_ln3_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_NFD_RG_SYMB_ERR_CNT_LN3_1f_GET(r) (((r).stat_sym_err_cnt_ln3_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_NFD_RG_SYMB_ERR_CNT_LN3_1f_SET(r,f) (r).stat_sym_err_cnt_ln3_1[0]=(((r).stat_sym_err_cnt_ln3_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN3_1.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN3_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r,_r._stat_sym_err_cnt_ln3_1)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN3_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r,_r._stat_sym_err_cnt_ln3_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN3_1r BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r
#define STAT_SYM_ERR_CNT_LN3_1r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_t STAT_SYM_ERR_CNT_LN3_1r_t;
#define STAT_SYM_ERR_CNT_LN3_1r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_CLR
#define STAT_SYM_ERR_CNT_LN3_1r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_SET
#define STAT_SYM_ERR_CNT_LN3_1r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_GET
#define STAT_SYM_ERR_CNT_LN3_1r_NFD_RG_SYMB_ERR_CNT_LN3_1f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_NFD_RG_SYMB_ERR_CNT_LN3_1f_GET
#define STAT_SYM_ERR_CNT_LN3_1r_NFD_RG_SYMB_ERR_CNT_LN3_1f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r_NFD_RG_SYMB_ERR_CNT_LN3_1f_SET
#define READ_STAT_SYM_ERR_CNT_LN3_1r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN3_1r
#define WRITE_STAT_SYM_ERR_CNT_LN3_1r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN3_1r
#define MODIFY_STAT_SYM_ERR_CNT_LN3_1r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN3_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_SYM_ERR_CNT_LN3_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9127
 * DEVAD:    1
 * DESC:     RS decoder status: symb_err_count_lane3[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_SYMB_ERR_CNT_LN3_2 Bits [47:32] of the 48-bit counter of symbol errors in the lane3.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r (0x00019127 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_SYM_ERR_CNT_LN3_2.
 */
typedef union BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_s {
	uint32_t v[1];
	uint32_t stat_sym_err_cnt_ln3_2[1];
	uint32_t _stat_sym_err_cnt_ln3_2;
} BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_t;

#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_CLR(r) (r).stat_sym_err_cnt_ln3_2[0] = 0
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_SET(r,d) (r).stat_sym_err_cnt_ln3_2[0] = d
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_GET(r) (r).stat_sym_err_cnt_ln3_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_NFD_RG_SYMB_ERR_CNT_LN3_2f_GET(r) (((r).stat_sym_err_cnt_ln3_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_NFD_RG_SYMB_ERR_CNT_LN3_2f_SET(r,f) (r).stat_sym_err_cnt_ln3_2[0]=(((r).stat_sym_err_cnt_ln3_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_SYM_ERR_CNT_LN3_2.
 */
#define BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN3_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r,_r._stat_sym_err_cnt_ln3_2)
#define BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN3_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r,_r._stat_sym_err_cnt_ln3_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_SYM_ERR_CNT_LN3_2r BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r
#define STAT_SYM_ERR_CNT_LN3_2r_SIZE BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_SIZE
typedef BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_t STAT_SYM_ERR_CNT_LN3_2r_t;
#define STAT_SYM_ERR_CNT_LN3_2r_CLR BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_CLR
#define STAT_SYM_ERR_CNT_LN3_2r_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_SET
#define STAT_SYM_ERR_CNT_LN3_2r_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_GET
#define STAT_SYM_ERR_CNT_LN3_2r_NFD_RG_SYMB_ERR_CNT_LN3_2f_GET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_NFD_RG_SYMB_ERR_CNT_LN3_2f_GET
#define STAT_SYM_ERR_CNT_LN3_2r_NFD_RG_SYMB_ERR_CNT_LN3_2f_SET BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r_NFD_RG_SYMB_ERR_CNT_LN3_2f_SET
#define READ_STAT_SYM_ERR_CNT_LN3_2r BCMI_MADURA_READ_STAT_SYM_ERR_CNT_LN3_2r
#define WRITE_STAT_SYM_ERR_CNT_LN3_2r BCMI_MADURA_WRITE_STAT_SYM_ERR_CNT_LN3_2r
#define MODIFY_STAT_SYM_ERR_CNT_LN3_2r BCMI_MADURA_MODIFY_STAT_SYM_ERR_CNT_LN3_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_SYM_ERR_CNT_LN3_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN0_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9128
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane0[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN0_0 Bits [15:0] of the 48-bit counter of bit errors in the lane0.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r (0x00019128 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN0_0.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln0_0[1];
	uint32_t _stat_bit_err_cnt_ln0_0;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_CLR(r) (r).stat_bit_err_cnt_ln0_0[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_SET(r,d) (r).stat_bit_err_cnt_ln0_0[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_GET(r) (r).stat_bit_err_cnt_ln0_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_NFD_RG_BIT_ERR_CNT_LN0_0f_GET(r) (((r).stat_bit_err_cnt_ln0_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_NFD_RG_BIT_ERR_CNT_LN0_0f_SET(r,f) (r).stat_bit_err_cnt_ln0_0[0]=(((r).stat_bit_err_cnt_ln0_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN0_0.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN0_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r,_r._stat_bit_err_cnt_ln0_0)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN0_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r,_r._stat_bit_err_cnt_ln0_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN0_0r BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r
#define STAT_BIT_ERR_CNT_LN0_0r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_t STAT_BIT_ERR_CNT_LN0_0r_t;
#define STAT_BIT_ERR_CNT_LN0_0r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_CLR
#define STAT_BIT_ERR_CNT_LN0_0r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_SET
#define STAT_BIT_ERR_CNT_LN0_0r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_GET
#define STAT_BIT_ERR_CNT_LN0_0r_NFD_RG_BIT_ERR_CNT_LN0_0f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_NFD_RG_BIT_ERR_CNT_LN0_0f_GET
#define STAT_BIT_ERR_CNT_LN0_0r_NFD_RG_BIT_ERR_CNT_LN0_0f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r_NFD_RG_BIT_ERR_CNT_LN0_0f_SET
#define READ_STAT_BIT_ERR_CNT_LN0_0r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN0_0r
#define WRITE_STAT_BIT_ERR_CNT_LN0_0r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN0_0r
#define MODIFY_STAT_BIT_ERR_CNT_LN0_0r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN0_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN0_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9129
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane0[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN0_1 Bits [31:16] of the 48-bit counter of bit errors in the lane0.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r (0x00019129 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN0_1.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln0_1[1];
	uint32_t _stat_bit_err_cnt_ln0_1;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_CLR(r) (r).stat_bit_err_cnt_ln0_1[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_SET(r,d) (r).stat_bit_err_cnt_ln0_1[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_GET(r) (r).stat_bit_err_cnt_ln0_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_NFD_RG_BIT_ERR_CNT_LN0_1f_GET(r) (((r).stat_bit_err_cnt_ln0_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_NFD_RG_BIT_ERR_CNT_LN0_1f_SET(r,f) (r).stat_bit_err_cnt_ln0_1[0]=(((r).stat_bit_err_cnt_ln0_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN0_1.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN0_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r,_r._stat_bit_err_cnt_ln0_1)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN0_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r,_r._stat_bit_err_cnt_ln0_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN0_1r BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r
#define STAT_BIT_ERR_CNT_LN0_1r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_t STAT_BIT_ERR_CNT_LN0_1r_t;
#define STAT_BIT_ERR_CNT_LN0_1r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_CLR
#define STAT_BIT_ERR_CNT_LN0_1r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_SET
#define STAT_BIT_ERR_CNT_LN0_1r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_GET
#define STAT_BIT_ERR_CNT_LN0_1r_NFD_RG_BIT_ERR_CNT_LN0_1f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_NFD_RG_BIT_ERR_CNT_LN0_1f_GET
#define STAT_BIT_ERR_CNT_LN0_1r_NFD_RG_BIT_ERR_CNT_LN0_1f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r_NFD_RG_BIT_ERR_CNT_LN0_1f_SET
#define READ_STAT_BIT_ERR_CNT_LN0_1r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN0_1r
#define WRITE_STAT_BIT_ERR_CNT_LN0_1r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN0_1r
#define MODIFY_STAT_BIT_ERR_CNT_LN0_1r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN0_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x912a
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane0[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN0_2 Bits [47:32] of the 48-bit counter of bit errors in the lane0.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r (0x0001912a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN0_2.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln0_2[1];
	uint32_t _stat_bit_err_cnt_ln0_2;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_CLR(r) (r).stat_bit_err_cnt_ln0_2[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_SET(r,d) (r).stat_bit_err_cnt_ln0_2[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_GET(r) (r).stat_bit_err_cnt_ln0_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_NFD_RG_BIT_ERR_CNT_LN0_2f_GET(r) (((r).stat_bit_err_cnt_ln0_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_NFD_RG_BIT_ERR_CNT_LN0_2f_SET(r,f) (r).stat_bit_err_cnt_ln0_2[0]=(((r).stat_bit_err_cnt_ln0_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN0_2.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN0_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r,_r._stat_bit_err_cnt_ln0_2)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN0_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r,_r._stat_bit_err_cnt_ln0_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN0_2r BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r
#define STAT_BIT_ERR_CNT_LN0_2r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_t STAT_BIT_ERR_CNT_LN0_2r_t;
#define STAT_BIT_ERR_CNT_LN0_2r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_CLR
#define STAT_BIT_ERR_CNT_LN0_2r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_SET
#define STAT_BIT_ERR_CNT_LN0_2r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_GET
#define STAT_BIT_ERR_CNT_LN0_2r_NFD_RG_BIT_ERR_CNT_LN0_2f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_NFD_RG_BIT_ERR_CNT_LN0_2f_GET
#define STAT_BIT_ERR_CNT_LN0_2r_NFD_RG_BIT_ERR_CNT_LN0_2f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r_NFD_RG_BIT_ERR_CNT_LN0_2f_SET
#define READ_STAT_BIT_ERR_CNT_LN0_2r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN0_2r
#define WRITE_STAT_BIT_ERR_CNT_LN0_2r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN0_2r
#define MODIFY_STAT_BIT_ERR_CNT_LN0_2r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN0_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN0_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN1_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x912b
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane1[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN1_0 Bits [15:0] of the 48-bit counter of bit errors in the lane1.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r (0x0001912b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN1_0.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln1_0[1];
	uint32_t _stat_bit_err_cnt_ln1_0;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_CLR(r) (r).stat_bit_err_cnt_ln1_0[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_SET(r,d) (r).stat_bit_err_cnt_ln1_0[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_GET(r) (r).stat_bit_err_cnt_ln1_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_NFD_RG_BIT_ERR_CNT_LN1_0f_GET(r) (((r).stat_bit_err_cnt_ln1_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_NFD_RG_BIT_ERR_CNT_LN1_0f_SET(r,f) (r).stat_bit_err_cnt_ln1_0[0]=(((r).stat_bit_err_cnt_ln1_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN1_0.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN1_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r,_r._stat_bit_err_cnt_ln1_0)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN1_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r,_r._stat_bit_err_cnt_ln1_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN1_0r BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r
#define STAT_BIT_ERR_CNT_LN1_0r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_t STAT_BIT_ERR_CNT_LN1_0r_t;
#define STAT_BIT_ERR_CNT_LN1_0r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_CLR
#define STAT_BIT_ERR_CNT_LN1_0r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_SET
#define STAT_BIT_ERR_CNT_LN1_0r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_GET
#define STAT_BIT_ERR_CNT_LN1_0r_NFD_RG_BIT_ERR_CNT_LN1_0f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_NFD_RG_BIT_ERR_CNT_LN1_0f_GET
#define STAT_BIT_ERR_CNT_LN1_0r_NFD_RG_BIT_ERR_CNT_LN1_0f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r_NFD_RG_BIT_ERR_CNT_LN1_0f_SET
#define READ_STAT_BIT_ERR_CNT_LN1_0r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN1_0r
#define WRITE_STAT_BIT_ERR_CNT_LN1_0r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN1_0r
#define MODIFY_STAT_BIT_ERR_CNT_LN1_0r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN1_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN1_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x912c
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane1[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN1_1 Bits [31:16] of the 48-bit counter of bit errors in the lane1.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r (0x0001912c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN1_1.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln1_1[1];
	uint32_t _stat_bit_err_cnt_ln1_1;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_CLR(r) (r).stat_bit_err_cnt_ln1_1[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_SET(r,d) (r).stat_bit_err_cnt_ln1_1[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_GET(r) (r).stat_bit_err_cnt_ln1_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_NFD_RG_BIT_ERR_CNT_LN1_1f_GET(r) (((r).stat_bit_err_cnt_ln1_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_NFD_RG_BIT_ERR_CNT_LN1_1f_SET(r,f) (r).stat_bit_err_cnt_ln1_1[0]=(((r).stat_bit_err_cnt_ln1_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN1_1.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN1_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r,_r._stat_bit_err_cnt_ln1_1)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN1_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r,_r._stat_bit_err_cnt_ln1_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN1_1r BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r
#define STAT_BIT_ERR_CNT_LN1_1r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_t STAT_BIT_ERR_CNT_LN1_1r_t;
#define STAT_BIT_ERR_CNT_LN1_1r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_CLR
#define STAT_BIT_ERR_CNT_LN1_1r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_SET
#define STAT_BIT_ERR_CNT_LN1_1r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_GET
#define STAT_BIT_ERR_CNT_LN1_1r_NFD_RG_BIT_ERR_CNT_LN1_1f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_NFD_RG_BIT_ERR_CNT_LN1_1f_GET
#define STAT_BIT_ERR_CNT_LN1_1r_NFD_RG_BIT_ERR_CNT_LN1_1f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r_NFD_RG_BIT_ERR_CNT_LN1_1f_SET
#define READ_STAT_BIT_ERR_CNT_LN1_1r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN1_1r
#define WRITE_STAT_BIT_ERR_CNT_LN1_1r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN1_1r
#define MODIFY_STAT_BIT_ERR_CNT_LN1_1r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN1_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN1_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x912d
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane1[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN1_2 Bits [47:32] of the 48-bit counter of bit errors in the lane1.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r (0x0001912d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN1_2.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln1_2[1];
	uint32_t _stat_bit_err_cnt_ln1_2;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_CLR(r) (r).stat_bit_err_cnt_ln1_2[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_SET(r,d) (r).stat_bit_err_cnt_ln1_2[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_GET(r) (r).stat_bit_err_cnt_ln1_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_NFD_RG_BIT_ERR_CNT_LN1_2f_GET(r) (((r).stat_bit_err_cnt_ln1_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_NFD_RG_BIT_ERR_CNT_LN1_2f_SET(r,f) (r).stat_bit_err_cnt_ln1_2[0]=(((r).stat_bit_err_cnt_ln1_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN1_2.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN1_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r,_r._stat_bit_err_cnt_ln1_2)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN1_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r,_r._stat_bit_err_cnt_ln1_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN1_2r BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r
#define STAT_BIT_ERR_CNT_LN1_2r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_t STAT_BIT_ERR_CNT_LN1_2r_t;
#define STAT_BIT_ERR_CNT_LN1_2r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_CLR
#define STAT_BIT_ERR_CNT_LN1_2r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_SET
#define STAT_BIT_ERR_CNT_LN1_2r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_GET
#define STAT_BIT_ERR_CNT_LN1_2r_NFD_RG_BIT_ERR_CNT_LN1_2f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_NFD_RG_BIT_ERR_CNT_LN1_2f_GET
#define STAT_BIT_ERR_CNT_LN1_2r_NFD_RG_BIT_ERR_CNT_LN1_2f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r_NFD_RG_BIT_ERR_CNT_LN1_2f_SET
#define READ_STAT_BIT_ERR_CNT_LN1_2r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN1_2r
#define WRITE_STAT_BIT_ERR_CNT_LN1_2r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN1_2r
#define MODIFY_STAT_BIT_ERR_CNT_LN1_2r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN1_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN1_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN2_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x912e
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane2[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN2_0 Bits [15:0] of the 48-bit counter of bit errors in the lane2.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r (0x0001912e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN2_0.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln2_0[1];
	uint32_t _stat_bit_err_cnt_ln2_0;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_CLR(r) (r).stat_bit_err_cnt_ln2_0[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_SET(r,d) (r).stat_bit_err_cnt_ln2_0[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_GET(r) (r).stat_bit_err_cnt_ln2_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_NFD_RG_BIT_ERR_CNT_LN2_0f_GET(r) (((r).stat_bit_err_cnt_ln2_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_NFD_RG_BIT_ERR_CNT_LN2_0f_SET(r,f) (r).stat_bit_err_cnt_ln2_0[0]=(((r).stat_bit_err_cnt_ln2_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN2_0.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN2_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r,_r._stat_bit_err_cnt_ln2_0)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN2_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r,_r._stat_bit_err_cnt_ln2_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN2_0r BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r
#define STAT_BIT_ERR_CNT_LN2_0r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_t STAT_BIT_ERR_CNT_LN2_0r_t;
#define STAT_BIT_ERR_CNT_LN2_0r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_CLR
#define STAT_BIT_ERR_CNT_LN2_0r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_SET
#define STAT_BIT_ERR_CNT_LN2_0r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_GET
#define STAT_BIT_ERR_CNT_LN2_0r_NFD_RG_BIT_ERR_CNT_LN2_0f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_NFD_RG_BIT_ERR_CNT_LN2_0f_GET
#define STAT_BIT_ERR_CNT_LN2_0r_NFD_RG_BIT_ERR_CNT_LN2_0f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r_NFD_RG_BIT_ERR_CNT_LN2_0f_SET
#define READ_STAT_BIT_ERR_CNT_LN2_0r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN2_0r
#define WRITE_STAT_BIT_ERR_CNT_LN2_0r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN2_0r
#define MODIFY_STAT_BIT_ERR_CNT_LN2_0r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN2_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN2_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x912f
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane2[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN2_1 Bits [31:16] of the 48-bit counter of bit errors in the lane2.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r (0x0001912f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN2_1.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln2_1[1];
	uint32_t _stat_bit_err_cnt_ln2_1;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_CLR(r) (r).stat_bit_err_cnt_ln2_1[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_SET(r,d) (r).stat_bit_err_cnt_ln2_1[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_GET(r) (r).stat_bit_err_cnt_ln2_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_NFD_RG_BIT_ERR_CNT_LN2_1f_GET(r) (((r).stat_bit_err_cnt_ln2_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_NFD_RG_BIT_ERR_CNT_LN2_1f_SET(r,f) (r).stat_bit_err_cnt_ln2_1[0]=(((r).stat_bit_err_cnt_ln2_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN2_1.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN2_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r,_r._stat_bit_err_cnt_ln2_1)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN2_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r,_r._stat_bit_err_cnt_ln2_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN2_1r BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r
#define STAT_BIT_ERR_CNT_LN2_1r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_t STAT_BIT_ERR_CNT_LN2_1r_t;
#define STAT_BIT_ERR_CNT_LN2_1r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_CLR
#define STAT_BIT_ERR_CNT_LN2_1r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_SET
#define STAT_BIT_ERR_CNT_LN2_1r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_GET
#define STAT_BIT_ERR_CNT_LN2_1r_NFD_RG_BIT_ERR_CNT_LN2_1f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_NFD_RG_BIT_ERR_CNT_LN2_1f_GET
#define STAT_BIT_ERR_CNT_LN2_1r_NFD_RG_BIT_ERR_CNT_LN2_1f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r_NFD_RG_BIT_ERR_CNT_LN2_1f_SET
#define READ_STAT_BIT_ERR_CNT_LN2_1r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN2_1r
#define WRITE_STAT_BIT_ERR_CNT_LN2_1r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN2_1r
#define MODIFY_STAT_BIT_ERR_CNT_LN2_1r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN2_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN2_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9130
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane2[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN2_2 Bits [47:32] of the 48-bit counter of bit errors in the lane2.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r (0x00019130 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN2_2.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln2_2[1];
	uint32_t _stat_bit_err_cnt_ln2_2;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_CLR(r) (r).stat_bit_err_cnt_ln2_2[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_SET(r,d) (r).stat_bit_err_cnt_ln2_2[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_GET(r) (r).stat_bit_err_cnt_ln2_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_NFD_RG_BIT_ERR_CNT_LN2_2f_GET(r) (((r).stat_bit_err_cnt_ln2_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_NFD_RG_BIT_ERR_CNT_LN2_2f_SET(r,f) (r).stat_bit_err_cnt_ln2_2[0]=(((r).stat_bit_err_cnt_ln2_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN2_2.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN2_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r,_r._stat_bit_err_cnt_ln2_2)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN2_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r,_r._stat_bit_err_cnt_ln2_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN2_2r BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r
#define STAT_BIT_ERR_CNT_LN2_2r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_t STAT_BIT_ERR_CNT_LN2_2r_t;
#define STAT_BIT_ERR_CNT_LN2_2r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_CLR
#define STAT_BIT_ERR_CNT_LN2_2r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_SET
#define STAT_BIT_ERR_CNT_LN2_2r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_GET
#define STAT_BIT_ERR_CNT_LN2_2r_NFD_RG_BIT_ERR_CNT_LN2_2f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_NFD_RG_BIT_ERR_CNT_LN2_2f_GET
#define STAT_BIT_ERR_CNT_LN2_2r_NFD_RG_BIT_ERR_CNT_LN2_2f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r_NFD_RG_BIT_ERR_CNT_LN2_2f_SET
#define READ_STAT_BIT_ERR_CNT_LN2_2r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN2_2r
#define WRITE_STAT_BIT_ERR_CNT_LN2_2r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN2_2r
#define MODIFY_STAT_BIT_ERR_CNT_LN2_2r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN2_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN2_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN3_0
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9131
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane3[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN3_0 Bits [15:0] of the 48-bit counter of bit errors in the lane3.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r (0x00019131 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN3_0.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln3_0[1];
	uint32_t _stat_bit_err_cnt_ln3_0;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_CLR(r) (r).stat_bit_err_cnt_ln3_0[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_SET(r,d) (r).stat_bit_err_cnt_ln3_0[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_GET(r) (r).stat_bit_err_cnt_ln3_0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_NFD_RG_BIT_ERR_CNT_LN3_0f_GET(r) (((r).stat_bit_err_cnt_ln3_0[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_NFD_RG_BIT_ERR_CNT_LN3_0f_SET(r,f) (r).stat_bit_err_cnt_ln3_0[0]=(((r).stat_bit_err_cnt_ln3_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN3_0.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN3_0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r,_r._stat_bit_err_cnt_ln3_0)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN3_0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r,_r._stat_bit_err_cnt_ln3_0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN3_0r BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r
#define STAT_BIT_ERR_CNT_LN3_0r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_t STAT_BIT_ERR_CNT_LN3_0r_t;
#define STAT_BIT_ERR_CNT_LN3_0r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_CLR
#define STAT_BIT_ERR_CNT_LN3_0r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_SET
#define STAT_BIT_ERR_CNT_LN3_0r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_GET
#define STAT_BIT_ERR_CNT_LN3_0r_NFD_RG_BIT_ERR_CNT_LN3_0f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_NFD_RG_BIT_ERR_CNT_LN3_0f_GET
#define STAT_BIT_ERR_CNT_LN3_0r_NFD_RG_BIT_ERR_CNT_LN3_0f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r_NFD_RG_BIT_ERR_CNT_LN3_0f_SET
#define READ_STAT_BIT_ERR_CNT_LN3_0r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN3_0r
#define WRITE_STAT_BIT_ERR_CNT_LN3_0r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN3_0r
#define MODIFY_STAT_BIT_ERR_CNT_LN3_0r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN3_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN3_1
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9132
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane3[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN3_1 Bits [31:16] of the 48-bit counter of bit errors in the lane3.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r (0x00019132 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN3_1.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln3_1[1];
	uint32_t _stat_bit_err_cnt_ln3_1;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_CLR(r) (r).stat_bit_err_cnt_ln3_1[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_SET(r,d) (r).stat_bit_err_cnt_ln3_1[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_GET(r) (r).stat_bit_err_cnt_ln3_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_NFD_RG_BIT_ERR_CNT_LN3_1f_GET(r) (((r).stat_bit_err_cnt_ln3_1[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_NFD_RG_BIT_ERR_CNT_LN3_1f_SET(r,f) (r).stat_bit_err_cnt_ln3_1[0]=(((r).stat_bit_err_cnt_ln3_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN3_1.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN3_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r,_r._stat_bit_err_cnt_ln3_1)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN3_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r,_r._stat_bit_err_cnt_ln3_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN3_1r BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r
#define STAT_BIT_ERR_CNT_LN3_1r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_t STAT_BIT_ERR_CNT_LN3_1r_t;
#define STAT_BIT_ERR_CNT_LN3_1r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_CLR
#define STAT_BIT_ERR_CNT_LN3_1r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_SET
#define STAT_BIT_ERR_CNT_LN3_1r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_GET
#define STAT_BIT_ERR_CNT_LN3_1r_NFD_RG_BIT_ERR_CNT_LN3_1f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_NFD_RG_BIT_ERR_CNT_LN3_1f_GET
#define STAT_BIT_ERR_CNT_LN3_1r_NFD_RG_BIT_ERR_CNT_LN3_1f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r_NFD_RG_BIT_ERR_CNT_LN3_1f_SET
#define READ_STAT_BIT_ERR_CNT_LN3_1r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN3_1r
#define WRITE_STAT_BIT_ERR_CNT_LN3_1r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN3_1r
#define MODIFY_STAT_BIT_ERR_CNT_LN3_1r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN3_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_BIT_ERR_CNT_LN3_2
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9133
 * DEVAD:    1
 * DESC:     RS decoder status: bit_err_count_lane3[47:32]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_BIT_ERR_CNT_LN3_2 Bits [47:32] of the 48-bit counter of bit errors in the lane3.Reading codeword_count[15:0] will refresh this register.Always read as 0's in the error-detection-only mode.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r (0x00019133 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_SIZE 4

/*
 * This structure should be used to declare and program STAT_BIT_ERR_CNT_LN3_2.
 */
typedef union BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_s {
	uint32_t v[1];
	uint32_t stat_bit_err_cnt_ln3_2[1];
	uint32_t _stat_bit_err_cnt_ln3_2;
} BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_t;

#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_CLR(r) (r).stat_bit_err_cnt_ln3_2[0] = 0
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_SET(r,d) (r).stat_bit_err_cnt_ln3_2[0] = d
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_GET(r) (r).stat_bit_err_cnt_ln3_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_NFD_RG_BIT_ERR_CNT_LN3_2f_GET(r) (((r).stat_bit_err_cnt_ln3_2[0]) & 0xffff)
#define BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_NFD_RG_BIT_ERR_CNT_LN3_2f_SET(r,f) (r).stat_bit_err_cnt_ln3_2[0]=(((r).stat_bit_err_cnt_ln3_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access STAT_BIT_ERR_CNT_LN3_2.
 */
#define BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN3_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r,_r._stat_bit_err_cnt_ln3_2)
#define BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN3_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r,_r._stat_bit_err_cnt_ln3_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_BIT_ERR_CNT_LN3_2r BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r
#define STAT_BIT_ERR_CNT_LN3_2r_SIZE BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_SIZE
typedef BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_t STAT_BIT_ERR_CNT_LN3_2r_t;
#define STAT_BIT_ERR_CNT_LN3_2r_CLR BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_CLR
#define STAT_BIT_ERR_CNT_LN3_2r_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_SET
#define STAT_BIT_ERR_CNT_LN3_2r_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_GET
#define STAT_BIT_ERR_CNT_LN3_2r_NFD_RG_BIT_ERR_CNT_LN3_2f_GET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_NFD_RG_BIT_ERR_CNT_LN3_2f_GET
#define STAT_BIT_ERR_CNT_LN3_2r_NFD_RG_BIT_ERR_CNT_LN3_2f_SET BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r_NFD_RG_BIT_ERR_CNT_LN3_2f_SET
#define READ_STAT_BIT_ERR_CNT_LN3_2r BCMI_MADURA_READ_STAT_BIT_ERR_CNT_LN3_2r
#define WRITE_STAT_BIT_ERR_CNT_LN3_2r BCMI_MADURA_WRITE_STAT_BIT_ERR_CNT_LN3_2r
#define MODIFY_STAT_BIT_ERR_CNT_LN3_2r BCMI_MADURA_MODIFY_STAT_BIT_ERR_CNT_LN3_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_BIT_ERR_CNT_LN3_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STATFILE_PARITY_ERR_LH
 * BLOCKS:   CL91_USER_DEC
 * REGADDR:  0x9134
 * DEVAD:    1
 * DESC:     RS decoder status: regfile_parity_error_latch_high
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFD_RG_LSB_PARITY_ERR_LH 1 = a parity error is detected on the LSB regfileThis bit is self-cleared after read.
 *     NFD_RG_MSB_PARITY_ERR_LH 1 = a parity error is detected on the MSB regfileThis bit is self-cleared after read.
 */
#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr (0x00019134 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_SIZE 4

/*
 * This structure should be used to declare and program STATFILE_PARITY_ERR_LH.
 */
typedef union BCMI_MADURA_STATFILE_PARITY_ERR_LHr_s {
	uint32_t v[1];
	uint32_t statfile_parity_err_lh[1];
	uint32_t _statfile_parity_err_lh;
} BCMI_MADURA_STATFILE_PARITY_ERR_LHr_t;

#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_CLR(r) (r).statfile_parity_err_lh[0] = 0
#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_SET(r,d) (r).statfile_parity_err_lh[0] = d
#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_GET(r) (r).statfile_parity_err_lh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_MSB_PARITY_ERR_LHf_GET(r) ((((r).statfile_parity_err_lh[0]) >> 1) & 0x1)
#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_MSB_PARITY_ERR_LHf_SET(r,f) (r).statfile_parity_err_lh[0]=(((r).statfile_parity_err_lh[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_LSB_PARITY_ERR_LHf_GET(r) (((r).statfile_parity_err_lh[0]) & 0x1)
#define BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_LSB_PARITY_ERR_LHf_SET(r,f) (r).statfile_parity_err_lh[0]=(((r).statfile_parity_err_lh[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access STATFILE_PARITY_ERR_LH.
 */
#define BCMI_MADURA_READ_STATFILE_PARITY_ERR_LHr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STATFILE_PARITY_ERR_LHr,_r._statfile_parity_err_lh)
#define BCMI_MADURA_WRITE_STATFILE_PARITY_ERR_LHr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STATFILE_PARITY_ERR_LHr,_r._statfile_parity_err_lh)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STATFILE_PARITY_ERR_LHr BCMI_MADURA_STATFILE_PARITY_ERR_LHr
#define STATFILE_PARITY_ERR_LHr_SIZE BCMI_MADURA_STATFILE_PARITY_ERR_LHr_SIZE
typedef BCMI_MADURA_STATFILE_PARITY_ERR_LHr_t STATFILE_PARITY_ERR_LHr_t;
#define STATFILE_PARITY_ERR_LHr_CLR BCMI_MADURA_STATFILE_PARITY_ERR_LHr_CLR
#define STATFILE_PARITY_ERR_LHr_SET BCMI_MADURA_STATFILE_PARITY_ERR_LHr_SET
#define STATFILE_PARITY_ERR_LHr_GET BCMI_MADURA_STATFILE_PARITY_ERR_LHr_GET
#define STATFILE_PARITY_ERR_LHr_NFD_RG_MSB_PARITY_ERR_LHf_GET BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_MSB_PARITY_ERR_LHf_GET
#define STATFILE_PARITY_ERR_LHr_NFD_RG_MSB_PARITY_ERR_LHf_SET BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_MSB_PARITY_ERR_LHf_SET
#define STATFILE_PARITY_ERR_LHr_NFD_RG_LSB_PARITY_ERR_LHf_GET BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_LSB_PARITY_ERR_LHf_GET
#define STATFILE_PARITY_ERR_LHr_NFD_RG_LSB_PARITY_ERR_LHf_SET BCMI_MADURA_STATFILE_PARITY_ERR_LHr_NFD_RG_LSB_PARITY_ERR_LHf_SET
#define READ_STATFILE_PARITY_ERR_LHr BCMI_MADURA_READ_STATFILE_PARITY_ERR_LHr
#define WRITE_STATFILE_PARITY_ERR_LHr BCMI_MADURA_WRITE_STATFILE_PARITY_ERR_LHr
#define MODIFY_STATFILE_PARITY_ERR_LHr BCMI_MADURA_MODIFY_STATFILE_PARITY_ERR_LHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STATFILE_PARITY_ERR_LHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_USER_RX_STS
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9400
 * DEVAD:    1
 * DESC:     USER CL91 RX STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMP_LOCK_LN      1 = AM lock state is true for the lane0 = AM lock state is false for the laneBits 0-3 correspond to FEC lanes 0-3 respectively
 *     ALIGN_STATUS     1 = All FEC lanes are locked and aligned
 */
#define BCMI_MADURA_CL91_USER_RX_STSr (0x00019400 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_USER_RX_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL91_USER_RX_STS.
 */
typedef union BCMI_MADURA_CL91_USER_RX_STSr_s {
	uint32_t v[1];
	uint32_t cl91_user_rx_sts[1];
	uint32_t _cl91_user_rx_sts;
} BCMI_MADURA_CL91_USER_RX_STSr_t;

#define BCMI_MADURA_CL91_USER_RX_STSr_CLR(r) (r).cl91_user_rx_sts[0] = 0
#define BCMI_MADURA_CL91_USER_RX_STSr_SET(r,d) (r).cl91_user_rx_sts[0] = d
#define BCMI_MADURA_CL91_USER_RX_STSr_GET(r) (r).cl91_user_rx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_USER_RX_STSr_ALIGN_STATUSf_GET(r) ((((r).cl91_user_rx_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_CL91_USER_RX_STSr_ALIGN_STATUSf_SET(r,f) (r).cl91_user_rx_sts[0]=(((r).cl91_user_rx_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CL91_USER_RX_STSr_AMP_LOCK_LNf_GET(r) (((r).cl91_user_rx_sts[0]) & 0xf)
#define BCMI_MADURA_CL91_USER_RX_STSr_AMP_LOCK_LNf_SET(r,f) (r).cl91_user_rx_sts[0]=(((r).cl91_user_rx_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CL91_USER_RX_STS.
 */
#define BCMI_MADURA_READ_CL91_USER_RX_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_USER_RX_STSr,_r._cl91_user_rx_sts)
#define BCMI_MADURA_WRITE_CL91_USER_RX_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_USER_RX_STSr,_r._cl91_user_rx_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_USER_RX_STSr BCMI_MADURA_CL91_USER_RX_STSr
#define CL91_USER_RX_STSr_SIZE BCMI_MADURA_CL91_USER_RX_STSr_SIZE
typedef BCMI_MADURA_CL91_USER_RX_STSr_t CL91_USER_RX_STSr_t;
#define CL91_USER_RX_STSr_CLR BCMI_MADURA_CL91_USER_RX_STSr_CLR
#define CL91_USER_RX_STSr_SET BCMI_MADURA_CL91_USER_RX_STSr_SET
#define CL91_USER_RX_STSr_GET BCMI_MADURA_CL91_USER_RX_STSr_GET
#define CL91_USER_RX_STSr_ALIGN_STATUSf_GET BCMI_MADURA_CL91_USER_RX_STSr_ALIGN_STATUSf_GET
#define CL91_USER_RX_STSr_ALIGN_STATUSf_SET BCMI_MADURA_CL91_USER_RX_STSr_ALIGN_STATUSf_SET
#define CL91_USER_RX_STSr_AMP_LOCK_LNf_GET BCMI_MADURA_CL91_USER_RX_STSr_AMP_LOCK_LNf_GET
#define CL91_USER_RX_STSr_AMP_LOCK_LNf_SET BCMI_MADURA_CL91_USER_RX_STSr_AMP_LOCK_LNf_SET
#define READ_CL91_USER_RX_STSr BCMI_MADURA_READ_CL91_USER_RX_STSr
#define WRITE_CL91_USER_RX_STSr BCMI_MADURA_WRITE_CL91_USER_RX_STSr
#define MODIFY_CL91_USER_RX_STSr BCMI_MADURA_MODIFY_CL91_USER_RX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_USER_RX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LATCH_STS
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9401
 * DEVAD:    1
 * DESC:     USER CL91 RX LATCHED STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMP_LOCK_LN0_LH  Latching high version of amp_lock_ln[0] status
 *     AMP_LOCK_LN0_LL  Latching low version of amp_lock_ln[0] status
 *     AMP_LOCK_LN1_LH  Latching high version of amp_lock_ln[1] status
 *     AMP_LOCK_LN1_LL  Latching low version of amp_lock_ln[1] status
 *     AMP_LOCK_LN2_LH  Latching high version of amp_lock_ln[2] status
 *     AMP_LOCK_LN2_LL  Latching low version of amp_lock_ln[2] status
 *     AMP_LOCK_LN3_LH  Latching high version of amp_lock_ln[3] status
 *     AMP_LOCK_LN3_LL  Latching low version of amp_lock_ln[3] status
 *     ALIGN_STATUS_LH  Latching high version of align_status
 *     ALIGN_STATUS_LL  Latching low version of align_status
 */
#define BCMI_MADURA_LATCH_STSr (0x00019401 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program LATCH_STS.
 */
typedef union BCMI_MADURA_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t latch_sts[1];
	uint32_t _latch_sts;
} BCMI_MADURA_LATCH_STSr_t;

#define BCMI_MADURA_LATCH_STSr_CLR(r) (r).latch_sts[0] = 0
#define BCMI_MADURA_LATCH_STSr_SET(r,d) (r).latch_sts[0] = d
#define BCMI_MADURA_LATCH_STSr_GET(r) (r).latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LLf_GET(r) ((((r).latch_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LLf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LHf_GET(r) ((((r).latch_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LHf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LLf_GET(r) ((((r).latch_sts[0]) >> 7) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LLf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LHf_GET(r) ((((r).latch_sts[0]) >> 6) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LHf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LLf_GET(r) ((((r).latch_sts[0]) >> 5) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LLf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LHf_GET(r) ((((r).latch_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LHf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LLf_GET(r) ((((r).latch_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LLf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LHf_GET(r) ((((r).latch_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LHf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LLf_GET(r) ((((r).latch_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LLf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LHf_GET(r) (((r).latch_sts[0]) & 0x1)
#define BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LHf_SET(r,f) (r).latch_sts[0]=(((r).latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LATCH_STS.
 */
#define BCMI_MADURA_READ_LATCH_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LATCH_STSr,_r._latch_sts)
#define BCMI_MADURA_WRITE_LATCH_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LATCH_STSr,_r._latch_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LATCH_STSr BCMI_MADURA_LATCH_STSr
#define LATCH_STSr_SIZE BCMI_MADURA_LATCH_STSr_SIZE
typedef BCMI_MADURA_LATCH_STSr_t LATCH_STSr_t;
#define LATCH_STSr_CLR BCMI_MADURA_LATCH_STSr_CLR
#define LATCH_STSr_SET BCMI_MADURA_LATCH_STSr_SET
#define LATCH_STSr_GET BCMI_MADURA_LATCH_STSr_GET
#define LATCH_STSr_ALIGN_STATUS_LLf_GET BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LLf_GET
#define LATCH_STSr_ALIGN_STATUS_LLf_SET BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LLf_SET
#define LATCH_STSr_ALIGN_STATUS_LHf_GET BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LHf_GET
#define LATCH_STSr_ALIGN_STATUS_LHf_SET BCMI_MADURA_LATCH_STSr_ALIGN_STATUS_LHf_SET
#define LATCH_STSr_AMP_LOCK_LN3_LLf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LLf_GET
#define LATCH_STSr_AMP_LOCK_LN3_LLf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LLf_SET
#define LATCH_STSr_AMP_LOCK_LN3_LHf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LHf_GET
#define LATCH_STSr_AMP_LOCK_LN3_LHf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN3_LHf_SET
#define LATCH_STSr_AMP_LOCK_LN2_LLf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LLf_GET
#define LATCH_STSr_AMP_LOCK_LN2_LLf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LLf_SET
#define LATCH_STSr_AMP_LOCK_LN2_LHf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LHf_GET
#define LATCH_STSr_AMP_LOCK_LN2_LHf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN2_LHf_SET
#define LATCH_STSr_AMP_LOCK_LN1_LLf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LLf_GET
#define LATCH_STSr_AMP_LOCK_LN1_LLf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LLf_SET
#define LATCH_STSr_AMP_LOCK_LN1_LHf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LHf_GET
#define LATCH_STSr_AMP_LOCK_LN1_LHf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN1_LHf_SET
#define LATCH_STSr_AMP_LOCK_LN0_LLf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LLf_GET
#define LATCH_STSr_AMP_LOCK_LN0_LLf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LLf_SET
#define LATCH_STSr_AMP_LOCK_LN0_LHf_GET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LHf_GET
#define LATCH_STSr_AMP_LOCK_LN0_LHf_SET BCMI_MADURA_LATCH_STSr_AMP_LOCK_LN0_LHf_SET
#define READ_LATCH_STSr BCMI_MADURA_READ_LATCH_STSr
#define WRITE_LATCH_STSr BCMI_MADURA_WRITE_LATCH_STSr
#define MODIFY_LATCH_STSr BCMI_MADURA_MODIFY_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SKEW_LN0
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9402
 * DEVAD:    1
 * DESC:     USER CL91 RX SKEW STATUS LN0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SKEW_LN0     Skew for lane 0Skew reported for each lane relative to a common virtual reference in units of 40UI.Valid only when align_status is 1.This along with bit_offset_ln gives the complete skew b/w any two lanes:For example skew between lane 0 and lane 1:Skew = (fec_skew_ln1-fec_skew_ln0) * 40 -(bit_offset_ln1-bit_offset_ln0)If the above number is >0, lane1 is early w.r.t. lane0 by that amount.If the above number is <0, lane1 is late w.r.t. lane0 by that amount.
 *     BIT_OFFSET_LN0   bit offset for lane 0See description below
 */
#define BCMI_MADURA_SKEW_LN0r (0x00019402 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SKEW_LN0r_SIZE 4

/*
 * This structure should be used to declare and program SKEW_LN0.
 */
typedef union BCMI_MADURA_SKEW_LN0r_s {
	uint32_t v[1];
	uint32_t skew_ln0[1];
	uint32_t _skew_ln0;
} BCMI_MADURA_SKEW_LN0r_t;

#define BCMI_MADURA_SKEW_LN0r_CLR(r) (r).skew_ln0[0] = 0
#define BCMI_MADURA_SKEW_LN0r_SET(r,d) (r).skew_ln0[0] = d
#define BCMI_MADURA_SKEW_LN0r_GET(r) (r).skew_ln0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SKEW_LN0r_BIT_OFFSET_LN0f_GET(r) ((((r).skew_ln0[0]) >> 8) & 0x3f)
#define BCMI_MADURA_SKEW_LN0r_BIT_OFFSET_LN0f_SET(r,f) (r).skew_ln0[0]=(((r).skew_ln0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_SKEW_LN0r_FEC_SKEW_LN0f_GET(r) (((r).skew_ln0[0]) & 0x7f)
#define BCMI_MADURA_SKEW_LN0r_FEC_SKEW_LN0f_SET(r,f) (r).skew_ln0[0]=(((r).skew_ln0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access SKEW_LN0.
 */
#define BCMI_MADURA_READ_SKEW_LN0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SKEW_LN0r,_r._skew_ln0)
#define BCMI_MADURA_WRITE_SKEW_LN0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SKEW_LN0r,_r._skew_ln0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SKEW_LN0r BCMI_MADURA_SKEW_LN0r
#define SKEW_LN0r_SIZE BCMI_MADURA_SKEW_LN0r_SIZE
typedef BCMI_MADURA_SKEW_LN0r_t SKEW_LN0r_t;
#define SKEW_LN0r_CLR BCMI_MADURA_SKEW_LN0r_CLR
#define SKEW_LN0r_SET BCMI_MADURA_SKEW_LN0r_SET
#define SKEW_LN0r_GET BCMI_MADURA_SKEW_LN0r_GET
#define SKEW_LN0r_BIT_OFFSET_LN0f_GET BCMI_MADURA_SKEW_LN0r_BIT_OFFSET_LN0f_GET
#define SKEW_LN0r_BIT_OFFSET_LN0f_SET BCMI_MADURA_SKEW_LN0r_BIT_OFFSET_LN0f_SET
#define SKEW_LN0r_FEC_SKEW_LN0f_GET BCMI_MADURA_SKEW_LN0r_FEC_SKEW_LN0f_GET
#define SKEW_LN0r_FEC_SKEW_LN0f_SET BCMI_MADURA_SKEW_LN0r_FEC_SKEW_LN0f_SET
#define READ_SKEW_LN0r BCMI_MADURA_READ_SKEW_LN0r
#define WRITE_SKEW_LN0r BCMI_MADURA_WRITE_SKEW_LN0r
#define MODIFY_SKEW_LN0r BCMI_MADURA_MODIFY_SKEW_LN0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SKEW_LN0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SKEW_LN1
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9403
 * DEVAD:    1
 * DESC:     USER CL91 RX SKEW STATUS LN1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SKEW_LN1     See description for lane 0
 *     BIT_OFFSET_LN1   See description for lane 0
 */
#define BCMI_MADURA_SKEW_LN1r (0x00019403 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SKEW_LN1r_SIZE 4

/*
 * This structure should be used to declare and program SKEW_LN1.
 */
typedef union BCMI_MADURA_SKEW_LN1r_s {
	uint32_t v[1];
	uint32_t skew_ln1[1];
	uint32_t _skew_ln1;
} BCMI_MADURA_SKEW_LN1r_t;

#define BCMI_MADURA_SKEW_LN1r_CLR(r) (r).skew_ln1[0] = 0
#define BCMI_MADURA_SKEW_LN1r_SET(r,d) (r).skew_ln1[0] = d
#define BCMI_MADURA_SKEW_LN1r_GET(r) (r).skew_ln1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SKEW_LN1r_BIT_OFFSET_LN1f_GET(r) ((((r).skew_ln1[0]) >> 8) & 0x3f)
#define BCMI_MADURA_SKEW_LN1r_BIT_OFFSET_LN1f_SET(r,f) (r).skew_ln1[0]=(((r).skew_ln1[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_SKEW_LN1r_FEC_SKEW_LN1f_GET(r) (((r).skew_ln1[0]) & 0x7f)
#define BCMI_MADURA_SKEW_LN1r_FEC_SKEW_LN1f_SET(r,f) (r).skew_ln1[0]=(((r).skew_ln1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access SKEW_LN1.
 */
#define BCMI_MADURA_READ_SKEW_LN1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SKEW_LN1r,_r._skew_ln1)
#define BCMI_MADURA_WRITE_SKEW_LN1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SKEW_LN1r,_r._skew_ln1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SKEW_LN1r BCMI_MADURA_SKEW_LN1r
#define SKEW_LN1r_SIZE BCMI_MADURA_SKEW_LN1r_SIZE
typedef BCMI_MADURA_SKEW_LN1r_t SKEW_LN1r_t;
#define SKEW_LN1r_CLR BCMI_MADURA_SKEW_LN1r_CLR
#define SKEW_LN1r_SET BCMI_MADURA_SKEW_LN1r_SET
#define SKEW_LN1r_GET BCMI_MADURA_SKEW_LN1r_GET
#define SKEW_LN1r_BIT_OFFSET_LN1f_GET BCMI_MADURA_SKEW_LN1r_BIT_OFFSET_LN1f_GET
#define SKEW_LN1r_BIT_OFFSET_LN1f_SET BCMI_MADURA_SKEW_LN1r_BIT_OFFSET_LN1f_SET
#define SKEW_LN1r_FEC_SKEW_LN1f_GET BCMI_MADURA_SKEW_LN1r_FEC_SKEW_LN1f_GET
#define SKEW_LN1r_FEC_SKEW_LN1f_SET BCMI_MADURA_SKEW_LN1r_FEC_SKEW_LN1f_SET
#define READ_SKEW_LN1r BCMI_MADURA_READ_SKEW_LN1r
#define WRITE_SKEW_LN1r BCMI_MADURA_WRITE_SKEW_LN1r
#define MODIFY_SKEW_LN1r BCMI_MADURA_MODIFY_SKEW_LN1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SKEW_LN1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SKEW_LN2
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9404
 * DEVAD:    1
 * DESC:     USER CL91 RX SKEW STATUS LN2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SKEW_LN2     See description for lane 0
 *     BIT_OFFSET_LN2   See description for lane 0
 */
#define BCMI_MADURA_SKEW_LN2r (0x00019404 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SKEW_LN2r_SIZE 4

/*
 * This structure should be used to declare and program SKEW_LN2.
 */
typedef union BCMI_MADURA_SKEW_LN2r_s {
	uint32_t v[1];
	uint32_t skew_ln2[1];
	uint32_t _skew_ln2;
} BCMI_MADURA_SKEW_LN2r_t;

#define BCMI_MADURA_SKEW_LN2r_CLR(r) (r).skew_ln2[0] = 0
#define BCMI_MADURA_SKEW_LN2r_SET(r,d) (r).skew_ln2[0] = d
#define BCMI_MADURA_SKEW_LN2r_GET(r) (r).skew_ln2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SKEW_LN2r_BIT_OFFSET_LN2f_GET(r) ((((r).skew_ln2[0]) >> 8) & 0x3f)
#define BCMI_MADURA_SKEW_LN2r_BIT_OFFSET_LN2f_SET(r,f) (r).skew_ln2[0]=(((r).skew_ln2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_SKEW_LN2r_FEC_SKEW_LN2f_GET(r) (((r).skew_ln2[0]) & 0x7f)
#define BCMI_MADURA_SKEW_LN2r_FEC_SKEW_LN2f_SET(r,f) (r).skew_ln2[0]=(((r).skew_ln2[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access SKEW_LN2.
 */
#define BCMI_MADURA_READ_SKEW_LN2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SKEW_LN2r,_r._skew_ln2)
#define BCMI_MADURA_WRITE_SKEW_LN2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SKEW_LN2r,_r._skew_ln2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SKEW_LN2r BCMI_MADURA_SKEW_LN2r
#define SKEW_LN2r_SIZE BCMI_MADURA_SKEW_LN2r_SIZE
typedef BCMI_MADURA_SKEW_LN2r_t SKEW_LN2r_t;
#define SKEW_LN2r_CLR BCMI_MADURA_SKEW_LN2r_CLR
#define SKEW_LN2r_SET BCMI_MADURA_SKEW_LN2r_SET
#define SKEW_LN2r_GET BCMI_MADURA_SKEW_LN2r_GET
#define SKEW_LN2r_BIT_OFFSET_LN2f_GET BCMI_MADURA_SKEW_LN2r_BIT_OFFSET_LN2f_GET
#define SKEW_LN2r_BIT_OFFSET_LN2f_SET BCMI_MADURA_SKEW_LN2r_BIT_OFFSET_LN2f_SET
#define SKEW_LN2r_FEC_SKEW_LN2f_GET BCMI_MADURA_SKEW_LN2r_FEC_SKEW_LN2f_GET
#define SKEW_LN2r_FEC_SKEW_LN2f_SET BCMI_MADURA_SKEW_LN2r_FEC_SKEW_LN2f_SET
#define READ_SKEW_LN2r BCMI_MADURA_READ_SKEW_LN2r
#define WRITE_SKEW_LN2r BCMI_MADURA_WRITE_SKEW_LN2r
#define MODIFY_SKEW_LN2r BCMI_MADURA_MODIFY_SKEW_LN2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SKEW_LN2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SKEW_LN3
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9405
 * DEVAD:    1
 * DESC:     USER CL91 RX SKEW STATUS LN3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SKEW_LN3     See description for lane 0
 *     BIT_OFFSET_LN3   See description for lane 0
 */
#define BCMI_MADURA_SKEW_LN3r (0x00019405 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SKEW_LN3r_SIZE 4

/*
 * This structure should be used to declare and program SKEW_LN3.
 */
typedef union BCMI_MADURA_SKEW_LN3r_s {
	uint32_t v[1];
	uint32_t skew_ln3[1];
	uint32_t _skew_ln3;
} BCMI_MADURA_SKEW_LN3r_t;

#define BCMI_MADURA_SKEW_LN3r_CLR(r) (r).skew_ln3[0] = 0
#define BCMI_MADURA_SKEW_LN3r_SET(r,d) (r).skew_ln3[0] = d
#define BCMI_MADURA_SKEW_LN3r_GET(r) (r).skew_ln3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SKEW_LN3r_BIT_OFFSET_LN3f_GET(r) ((((r).skew_ln3[0]) >> 8) & 0x3f)
#define BCMI_MADURA_SKEW_LN3r_BIT_OFFSET_LN3f_SET(r,f) (r).skew_ln3[0]=(((r).skew_ln3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_SKEW_LN3r_FEC_SKEW_LN3f_GET(r) (((r).skew_ln3[0]) & 0x7f)
#define BCMI_MADURA_SKEW_LN3r_FEC_SKEW_LN3f_SET(r,f) (r).skew_ln3[0]=(((r).skew_ln3[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access SKEW_LN3.
 */
#define BCMI_MADURA_READ_SKEW_LN3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SKEW_LN3r,_r._skew_ln3)
#define BCMI_MADURA_WRITE_SKEW_LN3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SKEW_LN3r,_r._skew_ln3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SKEW_LN3r BCMI_MADURA_SKEW_LN3r
#define SKEW_LN3r_SIZE BCMI_MADURA_SKEW_LN3r_SIZE
typedef BCMI_MADURA_SKEW_LN3r_t SKEW_LN3r_t;
#define SKEW_LN3r_CLR BCMI_MADURA_SKEW_LN3r_CLR
#define SKEW_LN3r_SET BCMI_MADURA_SKEW_LN3r_SET
#define SKEW_LN3r_GET BCMI_MADURA_SKEW_LN3r_GET
#define SKEW_LN3r_BIT_OFFSET_LN3f_GET BCMI_MADURA_SKEW_LN3r_BIT_OFFSET_LN3f_GET
#define SKEW_LN3r_BIT_OFFSET_LN3f_SET BCMI_MADURA_SKEW_LN3r_BIT_OFFSET_LN3f_SET
#define SKEW_LN3r_FEC_SKEW_LN3f_GET BCMI_MADURA_SKEW_LN3r_FEC_SKEW_LN3f_GET
#define SKEW_LN3r_FEC_SKEW_LN3f_SET BCMI_MADURA_SKEW_LN3r_FEC_SKEW_LN3f_SET
#define READ_SKEW_LN3r BCMI_MADURA_READ_SKEW_LN3r
#define WRITE_SKEW_LN3r BCMI_MADURA_WRITE_SKEW_LN3r
#define MODIFY_SKEW_LN3r BCMI_MADURA_MODIFY_SKEW_LN3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SKEW_LN3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN0_MAP_CTL1
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9406
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE0 MAPPING CTRL1
 * RESETVAL: 0x100 (256)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN0_LOG_LN0  These bits configure the first PCS lane (0-20) to be sent on physical lane 0.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN0_LOG_LN1  These bits configure the second PCS lane (0-20) to be sent on physical lane 0.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN0_MAP_CTL1r (0x00019406 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN0_MAP_CTL1.
 */
typedef union BCMI_MADURA_PHY_LN0_MAP_CTL1r_s {
	uint32_t v[1];
	uint32_t phy_ln0_map_ctl1[1];
	uint32_t _phy_ln0_map_ctl1;
} BCMI_MADURA_PHY_LN0_MAP_CTL1r_t;

#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_CLR(r) (r).phy_ln0_map_ctl1[0] = 0
#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_SET(r,d) (r).phy_ln0_map_ctl1[0] = d
#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_GET(r) (r).phy_ln0_map_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN1f_GET(r) ((((r).phy_ln0_map_ctl1[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN1f_SET(r,f) (r).phy_ln0_map_ctl1[0]=(((r).phy_ln0_map_ctl1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN0f_GET(r) (((r).phy_ln0_map_ctl1[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN0f_SET(r,f) (r).phy_ln0_map_ctl1[0]=(((r).phy_ln0_map_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN0_MAP_CTL1.
 */
#define BCMI_MADURA_READ_PHY_LN0_MAP_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN0_MAP_CTL1r,_r._phy_ln0_map_ctl1)
#define BCMI_MADURA_WRITE_PHY_LN0_MAP_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN0_MAP_CTL1r,_r._phy_ln0_map_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN0_MAP_CTL1r BCMI_MADURA_PHY_LN0_MAP_CTL1r
#define PHY_LN0_MAP_CTL1r_SIZE BCMI_MADURA_PHY_LN0_MAP_CTL1r_SIZE
typedef BCMI_MADURA_PHY_LN0_MAP_CTL1r_t PHY_LN0_MAP_CTL1r_t;
#define PHY_LN0_MAP_CTL1r_CLR BCMI_MADURA_PHY_LN0_MAP_CTL1r_CLR
#define PHY_LN0_MAP_CTL1r_SET BCMI_MADURA_PHY_LN0_MAP_CTL1r_SET
#define PHY_LN0_MAP_CTL1r_GET BCMI_MADURA_PHY_LN0_MAP_CTL1r_GET
#define PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN1f_GET BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN1f_GET
#define PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN1f_SET BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN1f_SET
#define PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN0f_GET BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN0f_GET
#define PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN0f_SET BCMI_MADURA_PHY_LN0_MAP_CTL1r_PHY_LN0_LOG_LN0f_SET
#define READ_PHY_LN0_MAP_CTL1r BCMI_MADURA_READ_PHY_LN0_MAP_CTL1r
#define WRITE_PHY_LN0_MAP_CTL1r BCMI_MADURA_WRITE_PHY_LN0_MAP_CTL1r
#define MODIFY_PHY_LN0_MAP_CTL1r BCMI_MADURA_MODIFY_PHY_LN0_MAP_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN0_MAP_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN0_MAP_CTL2
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9407
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE0 MAPPING CTRL2
 * RESETVAL: 0x302 (770)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN0_LOG_LN2  These bits configure the third PCS lane (0-20) to be sent on physical lane 0.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN0_LOG_LN3  These bits configure the fourth PCS lane (0-20) to be sent on physical lane 0.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN0_MAP_CTL2r (0x00019407 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN0_MAP_CTL2.
 */
typedef union BCMI_MADURA_PHY_LN0_MAP_CTL2r_s {
	uint32_t v[1];
	uint32_t phy_ln0_map_ctl2[1];
	uint32_t _phy_ln0_map_ctl2;
} BCMI_MADURA_PHY_LN0_MAP_CTL2r_t;

#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_CLR(r) (r).phy_ln0_map_ctl2[0] = 0
#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_SET(r,d) (r).phy_ln0_map_ctl2[0] = d
#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_GET(r) (r).phy_ln0_map_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN3f_GET(r) ((((r).phy_ln0_map_ctl2[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN3f_SET(r,f) (r).phy_ln0_map_ctl2[0]=(((r).phy_ln0_map_ctl2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN2f_GET(r) (((r).phy_ln0_map_ctl2[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN2f_SET(r,f) (r).phy_ln0_map_ctl2[0]=(((r).phy_ln0_map_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN0_MAP_CTL2.
 */
#define BCMI_MADURA_READ_PHY_LN0_MAP_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN0_MAP_CTL2r,_r._phy_ln0_map_ctl2)
#define BCMI_MADURA_WRITE_PHY_LN0_MAP_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN0_MAP_CTL2r,_r._phy_ln0_map_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN0_MAP_CTL2r BCMI_MADURA_PHY_LN0_MAP_CTL2r
#define PHY_LN0_MAP_CTL2r_SIZE BCMI_MADURA_PHY_LN0_MAP_CTL2r_SIZE
typedef BCMI_MADURA_PHY_LN0_MAP_CTL2r_t PHY_LN0_MAP_CTL2r_t;
#define PHY_LN0_MAP_CTL2r_CLR BCMI_MADURA_PHY_LN0_MAP_CTL2r_CLR
#define PHY_LN0_MAP_CTL2r_SET BCMI_MADURA_PHY_LN0_MAP_CTL2r_SET
#define PHY_LN0_MAP_CTL2r_GET BCMI_MADURA_PHY_LN0_MAP_CTL2r_GET
#define PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN3f_GET BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN3f_GET
#define PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN3f_SET BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN3f_SET
#define PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN2f_GET BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN2f_GET
#define PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN2f_SET BCMI_MADURA_PHY_LN0_MAP_CTL2r_PHY_LN0_LOG_LN2f_SET
#define READ_PHY_LN0_MAP_CTL2r BCMI_MADURA_READ_PHY_LN0_MAP_CTL2r
#define WRITE_PHY_LN0_MAP_CTL2r BCMI_MADURA_WRITE_PHY_LN0_MAP_CTL2r
#define MODIFY_PHY_LN0_MAP_CTL2r BCMI_MADURA_MODIFY_PHY_LN0_MAP_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN0_MAP_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN0_MAP_CTL3
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9408
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE0 MAPPING CTRL3
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN0_LOG_LN4  These bits configure the fifth PCS lane (0-20) to be sent on physical lane 0.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN0_MAP_CTL3r (0x00019408 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN0_MAP_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN0_MAP_CTL3.
 */
typedef union BCMI_MADURA_PHY_LN0_MAP_CTL3r_s {
	uint32_t v[1];
	uint32_t phy_ln0_map_ctl3[1];
	uint32_t _phy_ln0_map_ctl3;
} BCMI_MADURA_PHY_LN0_MAP_CTL3r_t;

#define BCMI_MADURA_PHY_LN0_MAP_CTL3r_CLR(r) (r).phy_ln0_map_ctl3[0] = 0
#define BCMI_MADURA_PHY_LN0_MAP_CTL3r_SET(r,d) (r).phy_ln0_map_ctl3[0] = d
#define BCMI_MADURA_PHY_LN0_MAP_CTL3r_GET(r) (r).phy_ln0_map_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN0_MAP_CTL3r_PHY_LN0_LOG_LN4f_GET(r) (((r).phy_ln0_map_ctl3[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN0_MAP_CTL3r_PHY_LN0_LOG_LN4f_SET(r,f) (r).phy_ln0_map_ctl3[0]=(((r).phy_ln0_map_ctl3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN0_MAP_CTL3.
 */
#define BCMI_MADURA_READ_PHY_LN0_MAP_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN0_MAP_CTL3r,_r._phy_ln0_map_ctl3)
#define BCMI_MADURA_WRITE_PHY_LN0_MAP_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN0_MAP_CTL3r,_r._phy_ln0_map_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN0_MAP_CTL3r BCMI_MADURA_PHY_LN0_MAP_CTL3r
#define PHY_LN0_MAP_CTL3r_SIZE BCMI_MADURA_PHY_LN0_MAP_CTL3r_SIZE
typedef BCMI_MADURA_PHY_LN0_MAP_CTL3r_t PHY_LN0_MAP_CTL3r_t;
#define PHY_LN0_MAP_CTL3r_CLR BCMI_MADURA_PHY_LN0_MAP_CTL3r_CLR
#define PHY_LN0_MAP_CTL3r_SET BCMI_MADURA_PHY_LN0_MAP_CTL3r_SET
#define PHY_LN0_MAP_CTL3r_GET BCMI_MADURA_PHY_LN0_MAP_CTL3r_GET
#define PHY_LN0_MAP_CTL3r_PHY_LN0_LOG_LN4f_GET BCMI_MADURA_PHY_LN0_MAP_CTL3r_PHY_LN0_LOG_LN4f_GET
#define PHY_LN0_MAP_CTL3r_PHY_LN0_LOG_LN4f_SET BCMI_MADURA_PHY_LN0_MAP_CTL3r_PHY_LN0_LOG_LN4f_SET
#define READ_PHY_LN0_MAP_CTL3r BCMI_MADURA_READ_PHY_LN0_MAP_CTL3r
#define WRITE_PHY_LN0_MAP_CTL3r BCMI_MADURA_WRITE_PHY_LN0_MAP_CTL3r
#define MODIFY_PHY_LN0_MAP_CTL3r BCMI_MADURA_MODIFY_PHY_LN0_MAP_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN0_MAP_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN1_MAP_CTL1
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9409
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE1 MAPPING CTRL1
 * RESETVAL: 0x605 (1541)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN1_LOG_LN0  These bits configure the first PCS lane (0-20) to be sent on physical lane 1.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN1_LOG_LN1  These bits configure the second PCS lane (0-20) to be sent on physical lane 1.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN1_MAP_CTL1r (0x00019409 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN1_MAP_CTL1.
 */
typedef union BCMI_MADURA_PHY_LN1_MAP_CTL1r_s {
	uint32_t v[1];
	uint32_t phy_ln1_map_ctl1[1];
	uint32_t _phy_ln1_map_ctl1;
} BCMI_MADURA_PHY_LN1_MAP_CTL1r_t;

#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_CLR(r) (r).phy_ln1_map_ctl1[0] = 0
#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_SET(r,d) (r).phy_ln1_map_ctl1[0] = d
#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_GET(r) (r).phy_ln1_map_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN1f_GET(r) ((((r).phy_ln1_map_ctl1[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN1f_SET(r,f) (r).phy_ln1_map_ctl1[0]=(((r).phy_ln1_map_ctl1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN0f_GET(r) (((r).phy_ln1_map_ctl1[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN0f_SET(r,f) (r).phy_ln1_map_ctl1[0]=(((r).phy_ln1_map_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN1_MAP_CTL1.
 */
#define BCMI_MADURA_READ_PHY_LN1_MAP_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN1_MAP_CTL1r,_r._phy_ln1_map_ctl1)
#define BCMI_MADURA_WRITE_PHY_LN1_MAP_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN1_MAP_CTL1r,_r._phy_ln1_map_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN1_MAP_CTL1r BCMI_MADURA_PHY_LN1_MAP_CTL1r
#define PHY_LN1_MAP_CTL1r_SIZE BCMI_MADURA_PHY_LN1_MAP_CTL1r_SIZE
typedef BCMI_MADURA_PHY_LN1_MAP_CTL1r_t PHY_LN1_MAP_CTL1r_t;
#define PHY_LN1_MAP_CTL1r_CLR BCMI_MADURA_PHY_LN1_MAP_CTL1r_CLR
#define PHY_LN1_MAP_CTL1r_SET BCMI_MADURA_PHY_LN1_MAP_CTL1r_SET
#define PHY_LN1_MAP_CTL1r_GET BCMI_MADURA_PHY_LN1_MAP_CTL1r_GET
#define PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN1f_GET BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN1f_GET
#define PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN1f_SET BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN1f_SET
#define PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN0f_GET BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN0f_GET
#define PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN0f_SET BCMI_MADURA_PHY_LN1_MAP_CTL1r_PHY_LN1_LOG_LN0f_SET
#define READ_PHY_LN1_MAP_CTL1r BCMI_MADURA_READ_PHY_LN1_MAP_CTL1r
#define WRITE_PHY_LN1_MAP_CTL1r BCMI_MADURA_WRITE_PHY_LN1_MAP_CTL1r
#define MODIFY_PHY_LN1_MAP_CTL1r BCMI_MADURA_MODIFY_PHY_LN1_MAP_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN1_MAP_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN1_MAP_CTL2
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x940a
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE1 MAPPING CTRL2
 * RESETVAL: 0x807 (2055)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN1_LOG_LN2  These bits configure the third PCS lane (0-20) to be sent on physical lane 1.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN1_LOG_LN3  These bits configure the fourth PCS lane (0-20) to be sent on physical lane 1.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN1_MAP_CTL2r (0x0001940a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN1_MAP_CTL2.
 */
typedef union BCMI_MADURA_PHY_LN1_MAP_CTL2r_s {
	uint32_t v[1];
	uint32_t phy_ln1_map_ctl2[1];
	uint32_t _phy_ln1_map_ctl2;
} BCMI_MADURA_PHY_LN1_MAP_CTL2r_t;

#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_CLR(r) (r).phy_ln1_map_ctl2[0] = 0
#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_SET(r,d) (r).phy_ln1_map_ctl2[0] = d
#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_GET(r) (r).phy_ln1_map_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN3f_GET(r) ((((r).phy_ln1_map_ctl2[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN3f_SET(r,f) (r).phy_ln1_map_ctl2[0]=(((r).phy_ln1_map_ctl2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN2f_GET(r) (((r).phy_ln1_map_ctl2[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN2f_SET(r,f) (r).phy_ln1_map_ctl2[0]=(((r).phy_ln1_map_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN1_MAP_CTL2.
 */
#define BCMI_MADURA_READ_PHY_LN1_MAP_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN1_MAP_CTL2r,_r._phy_ln1_map_ctl2)
#define BCMI_MADURA_WRITE_PHY_LN1_MAP_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN1_MAP_CTL2r,_r._phy_ln1_map_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN1_MAP_CTL2r BCMI_MADURA_PHY_LN1_MAP_CTL2r
#define PHY_LN1_MAP_CTL2r_SIZE BCMI_MADURA_PHY_LN1_MAP_CTL2r_SIZE
typedef BCMI_MADURA_PHY_LN1_MAP_CTL2r_t PHY_LN1_MAP_CTL2r_t;
#define PHY_LN1_MAP_CTL2r_CLR BCMI_MADURA_PHY_LN1_MAP_CTL2r_CLR
#define PHY_LN1_MAP_CTL2r_SET BCMI_MADURA_PHY_LN1_MAP_CTL2r_SET
#define PHY_LN1_MAP_CTL2r_GET BCMI_MADURA_PHY_LN1_MAP_CTL2r_GET
#define PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN3f_GET BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN3f_GET
#define PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN3f_SET BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN3f_SET
#define PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN2f_GET BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN2f_GET
#define PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN2f_SET BCMI_MADURA_PHY_LN1_MAP_CTL2r_PHY_LN1_LOG_LN2f_SET
#define READ_PHY_LN1_MAP_CTL2r BCMI_MADURA_READ_PHY_LN1_MAP_CTL2r
#define WRITE_PHY_LN1_MAP_CTL2r BCMI_MADURA_WRITE_PHY_LN1_MAP_CTL2r
#define MODIFY_PHY_LN1_MAP_CTL2r BCMI_MADURA_MODIFY_PHY_LN1_MAP_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN1_MAP_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN1_MAP_CTL3
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x940b
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE1 MAPPING CTRL3
 * RESETVAL: 0x9 (9)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN1_LOG_LN4  These bits configure the fifth PCS lane (0-20) to be sent on physical lane 1.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN1_MAP_CTL3r (0x0001940b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN1_MAP_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN1_MAP_CTL3.
 */
typedef union BCMI_MADURA_PHY_LN1_MAP_CTL3r_s {
	uint32_t v[1];
	uint32_t phy_ln1_map_ctl3[1];
	uint32_t _phy_ln1_map_ctl3;
} BCMI_MADURA_PHY_LN1_MAP_CTL3r_t;

#define BCMI_MADURA_PHY_LN1_MAP_CTL3r_CLR(r) (r).phy_ln1_map_ctl3[0] = 0
#define BCMI_MADURA_PHY_LN1_MAP_CTL3r_SET(r,d) (r).phy_ln1_map_ctl3[0] = d
#define BCMI_MADURA_PHY_LN1_MAP_CTL3r_GET(r) (r).phy_ln1_map_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN1_MAP_CTL3r_PHY_LN1_LOG_LN4f_GET(r) (((r).phy_ln1_map_ctl3[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN1_MAP_CTL3r_PHY_LN1_LOG_LN4f_SET(r,f) (r).phy_ln1_map_ctl3[0]=(((r).phy_ln1_map_ctl3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN1_MAP_CTL3.
 */
#define BCMI_MADURA_READ_PHY_LN1_MAP_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN1_MAP_CTL3r,_r._phy_ln1_map_ctl3)
#define BCMI_MADURA_WRITE_PHY_LN1_MAP_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN1_MAP_CTL3r,_r._phy_ln1_map_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN1_MAP_CTL3r BCMI_MADURA_PHY_LN1_MAP_CTL3r
#define PHY_LN1_MAP_CTL3r_SIZE BCMI_MADURA_PHY_LN1_MAP_CTL3r_SIZE
typedef BCMI_MADURA_PHY_LN1_MAP_CTL3r_t PHY_LN1_MAP_CTL3r_t;
#define PHY_LN1_MAP_CTL3r_CLR BCMI_MADURA_PHY_LN1_MAP_CTL3r_CLR
#define PHY_LN1_MAP_CTL3r_SET BCMI_MADURA_PHY_LN1_MAP_CTL3r_SET
#define PHY_LN1_MAP_CTL3r_GET BCMI_MADURA_PHY_LN1_MAP_CTL3r_GET
#define PHY_LN1_MAP_CTL3r_PHY_LN1_LOG_LN4f_GET BCMI_MADURA_PHY_LN1_MAP_CTL3r_PHY_LN1_LOG_LN4f_GET
#define PHY_LN1_MAP_CTL3r_PHY_LN1_LOG_LN4f_SET BCMI_MADURA_PHY_LN1_MAP_CTL3r_PHY_LN1_LOG_LN4f_SET
#define READ_PHY_LN1_MAP_CTL3r BCMI_MADURA_READ_PHY_LN1_MAP_CTL3r
#define WRITE_PHY_LN1_MAP_CTL3r BCMI_MADURA_WRITE_PHY_LN1_MAP_CTL3r
#define MODIFY_PHY_LN1_MAP_CTL3r BCMI_MADURA_MODIFY_PHY_LN1_MAP_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN1_MAP_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN2_MAP_CTL1
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x940c
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE2 MAPPING CTRL1
 * RESETVAL: 0xb0a (2826)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN2_LOG_LN0  These bits configure the first PCS lane (0-20) to be sent on physical lane 2.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN2_LOG_LN1  These bits configure the second PCS lane (0-20) to be sent on physical lane 2.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN2_MAP_CTL1r (0x0001940c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN2_MAP_CTL1.
 */
typedef union BCMI_MADURA_PHY_LN2_MAP_CTL1r_s {
	uint32_t v[1];
	uint32_t phy_ln2_map_ctl1[1];
	uint32_t _phy_ln2_map_ctl1;
} BCMI_MADURA_PHY_LN2_MAP_CTL1r_t;

#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_CLR(r) (r).phy_ln2_map_ctl1[0] = 0
#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_SET(r,d) (r).phy_ln2_map_ctl1[0] = d
#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_GET(r) (r).phy_ln2_map_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN1f_GET(r) ((((r).phy_ln2_map_ctl1[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN1f_SET(r,f) (r).phy_ln2_map_ctl1[0]=(((r).phy_ln2_map_ctl1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN0f_GET(r) (((r).phy_ln2_map_ctl1[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN0f_SET(r,f) (r).phy_ln2_map_ctl1[0]=(((r).phy_ln2_map_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN2_MAP_CTL1.
 */
#define BCMI_MADURA_READ_PHY_LN2_MAP_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN2_MAP_CTL1r,_r._phy_ln2_map_ctl1)
#define BCMI_MADURA_WRITE_PHY_LN2_MAP_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN2_MAP_CTL1r,_r._phy_ln2_map_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN2_MAP_CTL1r BCMI_MADURA_PHY_LN2_MAP_CTL1r
#define PHY_LN2_MAP_CTL1r_SIZE BCMI_MADURA_PHY_LN2_MAP_CTL1r_SIZE
typedef BCMI_MADURA_PHY_LN2_MAP_CTL1r_t PHY_LN2_MAP_CTL1r_t;
#define PHY_LN2_MAP_CTL1r_CLR BCMI_MADURA_PHY_LN2_MAP_CTL1r_CLR
#define PHY_LN2_MAP_CTL1r_SET BCMI_MADURA_PHY_LN2_MAP_CTL1r_SET
#define PHY_LN2_MAP_CTL1r_GET BCMI_MADURA_PHY_LN2_MAP_CTL1r_GET
#define PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN1f_GET BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN1f_GET
#define PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN1f_SET BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN1f_SET
#define PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN0f_GET BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN0f_GET
#define PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN0f_SET BCMI_MADURA_PHY_LN2_MAP_CTL1r_PHY_LN2_LOG_LN0f_SET
#define READ_PHY_LN2_MAP_CTL1r BCMI_MADURA_READ_PHY_LN2_MAP_CTL1r
#define WRITE_PHY_LN2_MAP_CTL1r BCMI_MADURA_WRITE_PHY_LN2_MAP_CTL1r
#define MODIFY_PHY_LN2_MAP_CTL1r BCMI_MADURA_MODIFY_PHY_LN2_MAP_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN2_MAP_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN2_MAP_CTL2
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x940d
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE2 MAPPING CTRL2
 * RESETVAL: 0xd0c (3340)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN2_LOG_LN2  These bits configure the third PCS lane (0-20) to be sent on physical lane 2.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN2_LOG_LN3  These bits configure the fourth PCS lane (0-20) to be sent on physical lane 2.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN2_MAP_CTL2r (0x0001940d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN2_MAP_CTL2.
 */
typedef union BCMI_MADURA_PHY_LN2_MAP_CTL2r_s {
	uint32_t v[1];
	uint32_t phy_ln2_map_ctl2[1];
	uint32_t _phy_ln2_map_ctl2;
} BCMI_MADURA_PHY_LN2_MAP_CTL2r_t;

#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_CLR(r) (r).phy_ln2_map_ctl2[0] = 0
#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_SET(r,d) (r).phy_ln2_map_ctl2[0] = d
#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_GET(r) (r).phy_ln2_map_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN3f_GET(r) ((((r).phy_ln2_map_ctl2[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN3f_SET(r,f) (r).phy_ln2_map_ctl2[0]=(((r).phy_ln2_map_ctl2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN2f_GET(r) (((r).phy_ln2_map_ctl2[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN2f_SET(r,f) (r).phy_ln2_map_ctl2[0]=(((r).phy_ln2_map_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN2_MAP_CTL2.
 */
#define BCMI_MADURA_READ_PHY_LN2_MAP_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN2_MAP_CTL2r,_r._phy_ln2_map_ctl2)
#define BCMI_MADURA_WRITE_PHY_LN2_MAP_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN2_MAP_CTL2r,_r._phy_ln2_map_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN2_MAP_CTL2r BCMI_MADURA_PHY_LN2_MAP_CTL2r
#define PHY_LN2_MAP_CTL2r_SIZE BCMI_MADURA_PHY_LN2_MAP_CTL2r_SIZE
typedef BCMI_MADURA_PHY_LN2_MAP_CTL2r_t PHY_LN2_MAP_CTL2r_t;
#define PHY_LN2_MAP_CTL2r_CLR BCMI_MADURA_PHY_LN2_MAP_CTL2r_CLR
#define PHY_LN2_MAP_CTL2r_SET BCMI_MADURA_PHY_LN2_MAP_CTL2r_SET
#define PHY_LN2_MAP_CTL2r_GET BCMI_MADURA_PHY_LN2_MAP_CTL2r_GET
#define PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN3f_GET BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN3f_GET
#define PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN3f_SET BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN3f_SET
#define PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN2f_GET BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN2f_GET
#define PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN2f_SET BCMI_MADURA_PHY_LN2_MAP_CTL2r_PHY_LN2_LOG_LN2f_SET
#define READ_PHY_LN2_MAP_CTL2r BCMI_MADURA_READ_PHY_LN2_MAP_CTL2r
#define WRITE_PHY_LN2_MAP_CTL2r BCMI_MADURA_WRITE_PHY_LN2_MAP_CTL2r
#define MODIFY_PHY_LN2_MAP_CTL2r BCMI_MADURA_MODIFY_PHY_LN2_MAP_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN2_MAP_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN2_MAP_CTL3
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x940e
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE2 MAPPING CTRL3
 * RESETVAL: 0xe (14)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN2_LOG_LN4  These bits configure the fifth PCS lane (0-20) to be sent on physical lane 2.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN2_MAP_CTL3r (0x0001940e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN2_MAP_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN2_MAP_CTL3.
 */
typedef union BCMI_MADURA_PHY_LN2_MAP_CTL3r_s {
	uint32_t v[1];
	uint32_t phy_ln2_map_ctl3[1];
	uint32_t _phy_ln2_map_ctl3;
} BCMI_MADURA_PHY_LN2_MAP_CTL3r_t;

#define BCMI_MADURA_PHY_LN2_MAP_CTL3r_CLR(r) (r).phy_ln2_map_ctl3[0] = 0
#define BCMI_MADURA_PHY_LN2_MAP_CTL3r_SET(r,d) (r).phy_ln2_map_ctl3[0] = d
#define BCMI_MADURA_PHY_LN2_MAP_CTL3r_GET(r) (r).phy_ln2_map_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN2_MAP_CTL3r_PHY_LN2_LOG_LN4f_GET(r) (((r).phy_ln2_map_ctl3[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN2_MAP_CTL3r_PHY_LN2_LOG_LN4f_SET(r,f) (r).phy_ln2_map_ctl3[0]=(((r).phy_ln2_map_ctl3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN2_MAP_CTL3.
 */
#define BCMI_MADURA_READ_PHY_LN2_MAP_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN2_MAP_CTL3r,_r._phy_ln2_map_ctl3)
#define BCMI_MADURA_WRITE_PHY_LN2_MAP_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN2_MAP_CTL3r,_r._phy_ln2_map_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN2_MAP_CTL3r BCMI_MADURA_PHY_LN2_MAP_CTL3r
#define PHY_LN2_MAP_CTL3r_SIZE BCMI_MADURA_PHY_LN2_MAP_CTL3r_SIZE
typedef BCMI_MADURA_PHY_LN2_MAP_CTL3r_t PHY_LN2_MAP_CTL3r_t;
#define PHY_LN2_MAP_CTL3r_CLR BCMI_MADURA_PHY_LN2_MAP_CTL3r_CLR
#define PHY_LN2_MAP_CTL3r_SET BCMI_MADURA_PHY_LN2_MAP_CTL3r_SET
#define PHY_LN2_MAP_CTL3r_GET BCMI_MADURA_PHY_LN2_MAP_CTL3r_GET
#define PHY_LN2_MAP_CTL3r_PHY_LN2_LOG_LN4f_GET BCMI_MADURA_PHY_LN2_MAP_CTL3r_PHY_LN2_LOG_LN4f_GET
#define PHY_LN2_MAP_CTL3r_PHY_LN2_LOG_LN4f_SET BCMI_MADURA_PHY_LN2_MAP_CTL3r_PHY_LN2_LOG_LN4f_SET
#define READ_PHY_LN2_MAP_CTL3r BCMI_MADURA_READ_PHY_LN2_MAP_CTL3r
#define WRITE_PHY_LN2_MAP_CTL3r BCMI_MADURA_WRITE_PHY_LN2_MAP_CTL3r
#define MODIFY_PHY_LN2_MAP_CTL3r BCMI_MADURA_MODIFY_PHY_LN2_MAP_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN2_MAP_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN3_MAP_CTL1
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x940f
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE3 MAPPING CTRL1
 * RESETVAL: 0x100f (4111)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN3_LOG_LN0  These bits configure the first PCS lane (0-20) to be sent on physical lane 3.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN3_LOG_LN1  These bits configure the second PCS lane (0-20) to be sent on physical lane 3.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN3_MAP_CTL1r (0x0001940f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN3_MAP_CTL1.
 */
typedef union BCMI_MADURA_PHY_LN3_MAP_CTL1r_s {
	uint32_t v[1];
	uint32_t phy_ln3_map_ctl1[1];
	uint32_t _phy_ln3_map_ctl1;
} BCMI_MADURA_PHY_LN3_MAP_CTL1r_t;

#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_CLR(r) (r).phy_ln3_map_ctl1[0] = 0
#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_SET(r,d) (r).phy_ln3_map_ctl1[0] = d
#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_GET(r) (r).phy_ln3_map_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN1f_GET(r) ((((r).phy_ln3_map_ctl1[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN1f_SET(r,f) (r).phy_ln3_map_ctl1[0]=(((r).phy_ln3_map_ctl1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN0f_GET(r) (((r).phy_ln3_map_ctl1[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN0f_SET(r,f) (r).phy_ln3_map_ctl1[0]=(((r).phy_ln3_map_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN3_MAP_CTL1.
 */
#define BCMI_MADURA_READ_PHY_LN3_MAP_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN3_MAP_CTL1r,_r._phy_ln3_map_ctl1)
#define BCMI_MADURA_WRITE_PHY_LN3_MAP_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN3_MAP_CTL1r,_r._phy_ln3_map_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN3_MAP_CTL1r BCMI_MADURA_PHY_LN3_MAP_CTL1r
#define PHY_LN3_MAP_CTL1r_SIZE BCMI_MADURA_PHY_LN3_MAP_CTL1r_SIZE
typedef BCMI_MADURA_PHY_LN3_MAP_CTL1r_t PHY_LN3_MAP_CTL1r_t;
#define PHY_LN3_MAP_CTL1r_CLR BCMI_MADURA_PHY_LN3_MAP_CTL1r_CLR
#define PHY_LN3_MAP_CTL1r_SET BCMI_MADURA_PHY_LN3_MAP_CTL1r_SET
#define PHY_LN3_MAP_CTL1r_GET BCMI_MADURA_PHY_LN3_MAP_CTL1r_GET
#define PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN1f_GET BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN1f_GET
#define PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN1f_SET BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN1f_SET
#define PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN0f_GET BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN0f_GET
#define PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN0f_SET BCMI_MADURA_PHY_LN3_MAP_CTL1r_PHY_LN3_LOG_LN0f_SET
#define READ_PHY_LN3_MAP_CTL1r BCMI_MADURA_READ_PHY_LN3_MAP_CTL1r
#define WRITE_PHY_LN3_MAP_CTL1r BCMI_MADURA_WRITE_PHY_LN3_MAP_CTL1r
#define MODIFY_PHY_LN3_MAP_CTL1r BCMI_MADURA_MODIFY_PHY_LN3_MAP_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN3_MAP_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN3_MAP_CTL2
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9410
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE3 MAPPING CTRL2
 * RESETVAL: 0x1211 (4625)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN3_LOG_LN2  These bits configure the third PCS lane (0-20) to be sent on physical lane 3.Each physical lane carries 5 PCS lanes in bit round-robin
 *     PHY_LN3_LOG_LN3  These bits configure the fourth PCS lane (0-20) to be sent on physical lane 3.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN3_MAP_CTL2r (0x00019410 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN3_MAP_CTL2.
 */
typedef union BCMI_MADURA_PHY_LN3_MAP_CTL2r_s {
	uint32_t v[1];
	uint32_t phy_ln3_map_ctl2[1];
	uint32_t _phy_ln3_map_ctl2;
} BCMI_MADURA_PHY_LN3_MAP_CTL2r_t;

#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_CLR(r) (r).phy_ln3_map_ctl2[0] = 0
#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_SET(r,d) (r).phy_ln3_map_ctl2[0] = d
#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_GET(r) (r).phy_ln3_map_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN3f_GET(r) ((((r).phy_ln3_map_ctl2[0]) >> 8) & 0x1f)
#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN3f_SET(r,f) (r).phy_ln3_map_ctl2[0]=(((r).phy_ln3_map_ctl2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN2f_GET(r) (((r).phy_ln3_map_ctl2[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN2f_SET(r,f) (r).phy_ln3_map_ctl2[0]=(((r).phy_ln3_map_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN3_MAP_CTL2.
 */
#define BCMI_MADURA_READ_PHY_LN3_MAP_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN3_MAP_CTL2r,_r._phy_ln3_map_ctl2)
#define BCMI_MADURA_WRITE_PHY_LN3_MAP_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN3_MAP_CTL2r,_r._phy_ln3_map_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN3_MAP_CTL2r BCMI_MADURA_PHY_LN3_MAP_CTL2r
#define PHY_LN3_MAP_CTL2r_SIZE BCMI_MADURA_PHY_LN3_MAP_CTL2r_SIZE
typedef BCMI_MADURA_PHY_LN3_MAP_CTL2r_t PHY_LN3_MAP_CTL2r_t;
#define PHY_LN3_MAP_CTL2r_CLR BCMI_MADURA_PHY_LN3_MAP_CTL2r_CLR
#define PHY_LN3_MAP_CTL2r_SET BCMI_MADURA_PHY_LN3_MAP_CTL2r_SET
#define PHY_LN3_MAP_CTL2r_GET BCMI_MADURA_PHY_LN3_MAP_CTL2r_GET
#define PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN3f_GET BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN3f_GET
#define PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN3f_SET BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN3f_SET
#define PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN2f_GET BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN2f_GET
#define PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN2f_SET BCMI_MADURA_PHY_LN3_MAP_CTL2r_PHY_LN3_LOG_LN2f_SET
#define READ_PHY_LN3_MAP_CTL2r BCMI_MADURA_READ_PHY_LN3_MAP_CTL2r
#define WRITE_PHY_LN3_MAP_CTL2r BCMI_MADURA_WRITE_PHY_LN3_MAP_CTL2r
#define MODIFY_PHY_LN3_MAP_CTL2r BCMI_MADURA_MODIFY_PHY_LN3_MAP_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN3_MAP_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PHY_LN3_MAP_CTL3
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9411
 * DEVAD:    1
 * DESC:     USER CL91 RX PHYSICAL LANE3 MAPPING CTRL3
 * RESETVAL: 0x13 (19)
 * ACCESS:   R/W
 * FIELDS:
 *     PHY_LN3_LOG_LN4  These bits configure the fifth PCS lane (0-20) to be sent on physical lane 3.Each physical lane carries 5 PCS lanes in bit round-robin
 */
#define BCMI_MADURA_PHY_LN3_MAP_CTL3r (0x00019411 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PHY_LN3_MAP_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PHY_LN3_MAP_CTL3.
 */
typedef union BCMI_MADURA_PHY_LN3_MAP_CTL3r_s {
	uint32_t v[1];
	uint32_t phy_ln3_map_ctl3[1];
	uint32_t _phy_ln3_map_ctl3;
} BCMI_MADURA_PHY_LN3_MAP_CTL3r_t;

#define BCMI_MADURA_PHY_LN3_MAP_CTL3r_CLR(r) (r).phy_ln3_map_ctl3[0] = 0
#define BCMI_MADURA_PHY_LN3_MAP_CTL3r_SET(r,d) (r).phy_ln3_map_ctl3[0] = d
#define BCMI_MADURA_PHY_LN3_MAP_CTL3r_GET(r) (r).phy_ln3_map_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PHY_LN3_MAP_CTL3r_PHY_LN3_LOG_LN4f_GET(r) (((r).phy_ln3_map_ctl3[0]) & 0x1f)
#define BCMI_MADURA_PHY_LN3_MAP_CTL3r_PHY_LN3_LOG_LN4f_SET(r,f) (r).phy_ln3_map_ctl3[0]=(((r).phy_ln3_map_ctl3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PHY_LN3_MAP_CTL3.
 */
#define BCMI_MADURA_READ_PHY_LN3_MAP_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PHY_LN3_MAP_CTL3r,_r._phy_ln3_map_ctl3)
#define BCMI_MADURA_WRITE_PHY_LN3_MAP_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PHY_LN3_MAP_CTL3r,_r._phy_ln3_map_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHY_LN3_MAP_CTL3r BCMI_MADURA_PHY_LN3_MAP_CTL3r
#define PHY_LN3_MAP_CTL3r_SIZE BCMI_MADURA_PHY_LN3_MAP_CTL3r_SIZE
typedef BCMI_MADURA_PHY_LN3_MAP_CTL3r_t PHY_LN3_MAP_CTL3r_t;
#define PHY_LN3_MAP_CTL3r_CLR BCMI_MADURA_PHY_LN3_MAP_CTL3r_CLR
#define PHY_LN3_MAP_CTL3r_SET BCMI_MADURA_PHY_LN3_MAP_CTL3r_SET
#define PHY_LN3_MAP_CTL3r_GET BCMI_MADURA_PHY_LN3_MAP_CTL3r_GET
#define PHY_LN3_MAP_CTL3r_PHY_LN3_LOG_LN4f_GET BCMI_MADURA_PHY_LN3_MAP_CTL3r_PHY_LN3_LOG_LN4f_GET
#define PHY_LN3_MAP_CTL3r_PHY_LN3_LOG_LN4f_SET BCMI_MADURA_PHY_LN3_MAP_CTL3r_PHY_LN3_LOG_LN4f_SET
#define READ_PHY_LN3_MAP_CTL3r BCMI_MADURA_READ_PHY_LN3_MAP_CTL3r
#define WRITE_PHY_LN3_MAP_CTL3r BCMI_MADURA_WRITE_PHY_LN3_MAP_CTL3r
#define MODIFY_PHY_LN3_MAP_CTL3r BCMI_MADURA_MODIFY_PHY_LN3_MAP_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PHY_LN3_MAP_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DBG_CTL
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9420
 * DEVAD:    1
 * DESC:     USER CL91 RX DEBUG CTRL
 * RESETVAL: 0x8018 (32792)
 * ACCESS:   R/W
 * FIELDS:
 *     RST_DSC_FIFO     A 0 to 1 transition of this bit issues a reset to the deskew fifo pointers.Affects all instances
 *     FRC_RE_ALIGN     A 0 to 1 transition of this bit causes the FEC Alignment state machine to restart the alignment process
 *     FRC_AM_RELOCK    A 0 to 1 transition of this bit causes the AM sync state machine to restart the AM sync process. Affects all instances
 *     CRPT_XCW_ON_LOA  1 = Transcoder corrupts all PCS headers when Rx FEC Alignment is not found
 *     BYP_DEC_OOA      1 = Data bypasses Decoder when there is no FEC alignment
 *     DEBUG_OUT_CTRL   Controls which System side Rx lane data is sent out through the debug port.
 *     FRC_RX_DP_RSTB   1 = The bit rx_dp_rstb is effective0 = The bit rx_dp_rstb has no effect
 *     RX_DP_RSTB       0 = Reset Rx datapath. Will have no effect on config registers.1 = not in resetNote: This bit is effective only when frc_rx_dp_rstb = 1.This is not a self clearing bit
 */
#define BCMI_MADURA_DBG_CTLr (0x00019420 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DBG_CTL.
 */
typedef union BCMI_MADURA_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t dbg_ctl[1];
	uint32_t _dbg_ctl;
} BCMI_MADURA_DBG_CTLr_t;

#define BCMI_MADURA_DBG_CTLr_CLR(r) (r).dbg_ctl[0] = 0
#define BCMI_MADURA_DBG_CTLr_SET(r,d) (r).dbg_ctl[0] = d
#define BCMI_MADURA_DBG_CTLr_GET(r) (r).dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DBG_CTLr_RX_DP_RSTBf_GET(r) ((((r).dbg_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_DBG_CTLr_RX_DP_RSTBf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DBG_CTLr_FRC_RX_DP_RSTBf_GET(r) ((((r).dbg_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_DBG_CTLr_FRC_RX_DP_RSTBf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_DBG_CTLr_DEBUG_OUT_CTRLf_GET(r) ((((r).dbg_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_DBG_CTLr_DEBUG_OUT_CTRLf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_DBG_CTLr_BYP_DEC_OOAf_GET(r) ((((r).dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_DBG_CTLr_BYP_DEC_OOAf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DBG_CTLr_CRPT_XCW_ON_LOAf_GET(r) ((((r).dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_DBG_CTLr_CRPT_XCW_ON_LOAf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DBG_CTLr_FRC_AM_RELOCKf_GET(r) ((((r).dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_DBG_CTLr_FRC_AM_RELOCKf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DBG_CTLr_FRC_RE_ALIGNf_GET(r) ((((r).dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_DBG_CTLr_FRC_RE_ALIGNf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DBG_CTLr_RST_DSC_FIFOf_GET(r) (((r).dbg_ctl[0]) & 0x1)
#define BCMI_MADURA_DBG_CTLr_RST_DSC_FIFOf_SET(r,f) (r).dbg_ctl[0]=(((r).dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DBG_CTL.
 */
#define BCMI_MADURA_READ_DBG_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DBG_CTLr,_r._dbg_ctl)
#define BCMI_MADURA_WRITE_DBG_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DBG_CTLr,_r._dbg_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DBG_CTLr BCMI_MADURA_DBG_CTLr
#define DBG_CTLr_SIZE BCMI_MADURA_DBG_CTLr_SIZE
typedef BCMI_MADURA_DBG_CTLr_t DBG_CTLr_t;
#define DBG_CTLr_CLR BCMI_MADURA_DBG_CTLr_CLR
#define DBG_CTLr_SET BCMI_MADURA_DBG_CTLr_SET
#define DBG_CTLr_GET BCMI_MADURA_DBG_CTLr_GET
#define DBG_CTLr_RX_DP_RSTBf_GET BCMI_MADURA_DBG_CTLr_RX_DP_RSTBf_GET
#define DBG_CTLr_RX_DP_RSTBf_SET BCMI_MADURA_DBG_CTLr_RX_DP_RSTBf_SET
#define DBG_CTLr_FRC_RX_DP_RSTBf_GET BCMI_MADURA_DBG_CTLr_FRC_RX_DP_RSTBf_GET
#define DBG_CTLr_FRC_RX_DP_RSTBf_SET BCMI_MADURA_DBG_CTLr_FRC_RX_DP_RSTBf_SET
#define DBG_CTLr_DEBUG_OUT_CTRLf_GET BCMI_MADURA_DBG_CTLr_DEBUG_OUT_CTRLf_GET
#define DBG_CTLr_DEBUG_OUT_CTRLf_SET BCMI_MADURA_DBG_CTLr_DEBUG_OUT_CTRLf_SET
#define DBG_CTLr_BYP_DEC_OOAf_GET BCMI_MADURA_DBG_CTLr_BYP_DEC_OOAf_GET
#define DBG_CTLr_BYP_DEC_OOAf_SET BCMI_MADURA_DBG_CTLr_BYP_DEC_OOAf_SET
#define DBG_CTLr_CRPT_XCW_ON_LOAf_GET BCMI_MADURA_DBG_CTLr_CRPT_XCW_ON_LOAf_GET
#define DBG_CTLr_CRPT_XCW_ON_LOAf_SET BCMI_MADURA_DBG_CTLr_CRPT_XCW_ON_LOAf_SET
#define DBG_CTLr_FRC_AM_RELOCKf_GET BCMI_MADURA_DBG_CTLr_FRC_AM_RELOCKf_GET
#define DBG_CTLr_FRC_AM_RELOCKf_SET BCMI_MADURA_DBG_CTLr_FRC_AM_RELOCKf_SET
#define DBG_CTLr_FRC_RE_ALIGNf_GET BCMI_MADURA_DBG_CTLr_FRC_RE_ALIGNf_GET
#define DBG_CTLr_FRC_RE_ALIGNf_SET BCMI_MADURA_DBG_CTLr_FRC_RE_ALIGNf_SET
#define DBG_CTLr_RST_DSC_FIFOf_GET BCMI_MADURA_DBG_CTLr_RST_DSC_FIFOf_GET
#define DBG_CTLr_RST_DSC_FIFOf_SET BCMI_MADURA_DBG_CTLr_RST_DSC_FIFOf_SET
#define READ_DBG_CTLr BCMI_MADURA_READ_DBG_CTLr
#define WRITE_DBG_CTLr BCMI_MADURA_WRITE_DBG_CTLr
#define MODIFY_DBG_CTLr BCMI_MADURA_MODIFY_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DBG_STS1
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9421
 * DEVAD:    1
 * DESC:     USER CL91 RX DEBUG STATUS1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_XC_BLK_ERR_LH Latched high status to indicate Rx Transcoder has detected an invalid block typeImplemented with a latching high cell
 *     RX_XC_SH_ERR_LH  Latched high status to indicate Rx Transcoder has detected an invalid synch headerImplemented with a latching high cell
 *     DSC_ERR_LH       Latched high status to indicate a deskewing error.All lanes are aligned but the AM are not seen at the same timePoints to a logical or a memory issueImplemented with a latching high cell
 *     DSC_FIFO_COLSN_LN0_LH Latched high status to indicate a fifo collision was observed for lane 0Implemented with a latching high cell
 *     DSC_FIFO_COLSN_LN1_LH Latched high status to indicate a fifo collision was observed for lane 1Implemented with a latching high cell
 *     DSC_FIFO_COLSN_LN2_LH Latched high status to indicate a fifo collision was observed for lane 2Implemented with a latching high cell
 *     DSC_FIFO_COLSN_LN3_LH Latched high status to indicate a fifo collision was observed for lane 3Implemented with a latching high cell
 *     BAD_CW_LH        Latched high status to indicate the decoder signaled a bad cw Implemented with a latching high cell
 *     NON_UNIQUE_AM_LH Latched high status to indicate all lanes achieved AM lock, but the PCS lanes found were not uniqueImplemented with a latching high cell
 *     THREE_BAD_CW_LH  Latched high status to indicate FEC Alignment s/m entered BAD_CW stateImplemented with a latching high cell
 *     DESKEW_FAIL_LH   Latched high status to indicate FEC Alignment s/m entered DESKEW_FAIL stateImplemented with a latching high cell
 */
#define BCMI_MADURA_DBG_STS1r (0x00019421 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DBG_STS1r_SIZE 4

/*
 * This structure should be used to declare and program DBG_STS1.
 */
typedef union BCMI_MADURA_DBG_STS1r_s {
	uint32_t v[1];
	uint32_t dbg_sts1[1];
	uint32_t _dbg_sts1;
} BCMI_MADURA_DBG_STS1r_t;

#define BCMI_MADURA_DBG_STS1r_CLR(r) (r).dbg_sts1[0] = 0
#define BCMI_MADURA_DBG_STS1r_SET(r,d) (r).dbg_sts1[0] = d
#define BCMI_MADURA_DBG_STS1r_GET(r) (r).dbg_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DBG_STS1r_DESKEW_FAIL_LHf_GET(r) ((((r).dbg_sts1[0]) >> 10) & 0x1)
#define BCMI_MADURA_DBG_STS1r_DESKEW_FAIL_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_DBG_STS1r_THREE_BAD_CW_LHf_GET(r) ((((r).dbg_sts1[0]) >> 9) & 0x1)
#define BCMI_MADURA_DBG_STS1r_THREE_BAD_CW_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_DBG_STS1r_NON_UNIQUE_AM_LHf_GET(r) ((((r).dbg_sts1[0]) >> 8) & 0x1)
#define BCMI_MADURA_DBG_STS1r_NON_UNIQUE_AM_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_DBG_STS1r_BAD_CW_LHf_GET(r) ((((r).dbg_sts1[0]) >> 7) & 0x1)
#define BCMI_MADURA_DBG_STS1r_BAD_CW_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN3_LHf_GET(r) ((((r).dbg_sts1[0]) >> 6) & 0x1)
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN3_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN2_LHf_GET(r) ((((r).dbg_sts1[0]) >> 5) & 0x1)
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN2_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN1_LHf_GET(r) ((((r).dbg_sts1[0]) >> 4) & 0x1)
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN1_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN0_LHf_GET(r) ((((r).dbg_sts1[0]) >> 3) & 0x1)
#define BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN0_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DBG_STS1r_DSC_ERR_LHf_GET(r) ((((r).dbg_sts1[0]) >> 2) & 0x1)
#define BCMI_MADURA_DBG_STS1r_DSC_ERR_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DBG_STS1r_RX_XC_SH_ERR_LHf_GET(r) ((((r).dbg_sts1[0]) >> 1) & 0x1)
#define BCMI_MADURA_DBG_STS1r_RX_XC_SH_ERR_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DBG_STS1r_RX_XC_BLK_ERR_LHf_GET(r) (((r).dbg_sts1[0]) & 0x1)
#define BCMI_MADURA_DBG_STS1r_RX_XC_BLK_ERR_LHf_SET(r,f) (r).dbg_sts1[0]=(((r).dbg_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DBG_STS1.
 */
#define BCMI_MADURA_READ_DBG_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DBG_STS1r,_r._dbg_sts1)
#define BCMI_MADURA_WRITE_DBG_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DBG_STS1r,_r._dbg_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DBG_STS1r BCMI_MADURA_DBG_STS1r
#define DBG_STS1r_SIZE BCMI_MADURA_DBG_STS1r_SIZE
typedef BCMI_MADURA_DBG_STS1r_t DBG_STS1r_t;
#define DBG_STS1r_CLR BCMI_MADURA_DBG_STS1r_CLR
#define DBG_STS1r_SET BCMI_MADURA_DBG_STS1r_SET
#define DBG_STS1r_GET BCMI_MADURA_DBG_STS1r_GET
#define DBG_STS1r_DESKEW_FAIL_LHf_GET BCMI_MADURA_DBG_STS1r_DESKEW_FAIL_LHf_GET
#define DBG_STS1r_DESKEW_FAIL_LHf_SET BCMI_MADURA_DBG_STS1r_DESKEW_FAIL_LHf_SET
#define DBG_STS1r_THREE_BAD_CW_LHf_GET BCMI_MADURA_DBG_STS1r_THREE_BAD_CW_LHf_GET
#define DBG_STS1r_THREE_BAD_CW_LHf_SET BCMI_MADURA_DBG_STS1r_THREE_BAD_CW_LHf_SET
#define DBG_STS1r_NON_UNIQUE_AM_LHf_GET BCMI_MADURA_DBG_STS1r_NON_UNIQUE_AM_LHf_GET
#define DBG_STS1r_NON_UNIQUE_AM_LHf_SET BCMI_MADURA_DBG_STS1r_NON_UNIQUE_AM_LHf_SET
#define DBG_STS1r_BAD_CW_LHf_GET BCMI_MADURA_DBG_STS1r_BAD_CW_LHf_GET
#define DBG_STS1r_BAD_CW_LHf_SET BCMI_MADURA_DBG_STS1r_BAD_CW_LHf_SET
#define DBG_STS1r_DSC_FIFO_COLSN_LN3_LHf_GET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN3_LHf_GET
#define DBG_STS1r_DSC_FIFO_COLSN_LN3_LHf_SET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN3_LHf_SET
#define DBG_STS1r_DSC_FIFO_COLSN_LN2_LHf_GET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN2_LHf_GET
#define DBG_STS1r_DSC_FIFO_COLSN_LN2_LHf_SET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN2_LHf_SET
#define DBG_STS1r_DSC_FIFO_COLSN_LN1_LHf_GET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN1_LHf_GET
#define DBG_STS1r_DSC_FIFO_COLSN_LN1_LHf_SET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN1_LHf_SET
#define DBG_STS1r_DSC_FIFO_COLSN_LN0_LHf_GET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN0_LHf_GET
#define DBG_STS1r_DSC_FIFO_COLSN_LN0_LHf_SET BCMI_MADURA_DBG_STS1r_DSC_FIFO_COLSN_LN0_LHf_SET
#define DBG_STS1r_DSC_ERR_LHf_GET BCMI_MADURA_DBG_STS1r_DSC_ERR_LHf_GET
#define DBG_STS1r_DSC_ERR_LHf_SET BCMI_MADURA_DBG_STS1r_DSC_ERR_LHf_SET
#define DBG_STS1r_RX_XC_SH_ERR_LHf_GET BCMI_MADURA_DBG_STS1r_RX_XC_SH_ERR_LHf_GET
#define DBG_STS1r_RX_XC_SH_ERR_LHf_SET BCMI_MADURA_DBG_STS1r_RX_XC_SH_ERR_LHf_SET
#define DBG_STS1r_RX_XC_BLK_ERR_LHf_GET BCMI_MADURA_DBG_STS1r_RX_XC_BLK_ERR_LHf_GET
#define DBG_STS1r_RX_XC_BLK_ERR_LHf_SET BCMI_MADURA_DBG_STS1r_RX_XC_BLK_ERR_LHf_SET
#define READ_DBG_STS1r BCMI_MADURA_READ_DBG_STS1r
#define WRITE_DBG_STS1r BCMI_MADURA_WRITE_DBG_STS1r
#define MODIFY_DBG_STS1r BCMI_MADURA_MODIFY_DBG_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DBG_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DBG_STS2
 * BLOCKS:   CL91_USER_RX
 * REGADDR:  0x9422
 * DEVAD:    1
 * DESC:     USER CL91 RX DEBUG STATUS2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LK_SM_STATE_LN3 AM Sync s/m state for Lane 3
 *     AM_LK_SM_STATE_LN2 AM Sync s/m state for Lane 2
 *     AM_LK_SM_STATE_LN1 AM Sync s/m state for Lane 1
 *     AM_LK_SM_STATE_LN0 AM Sync s/m state for Lane 0
 *     FEC_ALGN_SM_STATE FEC Alignment state machine current state
 */
#define BCMI_MADURA_DBG_STS2r (0x00019422 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DBG_STS2r_SIZE 4

/*
 * This structure should be used to declare and program DBG_STS2.
 */
typedef union BCMI_MADURA_DBG_STS2r_s {
	uint32_t v[1];
	uint32_t dbg_sts2[1];
	uint32_t _dbg_sts2;
} BCMI_MADURA_DBG_STS2r_t;

#define BCMI_MADURA_DBG_STS2r_CLR(r) (r).dbg_sts2[0] = 0
#define BCMI_MADURA_DBG_STS2r_SET(r,d) (r).dbg_sts2[0] = d
#define BCMI_MADURA_DBG_STS2r_GET(r) (r).dbg_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DBG_STS2r_FEC_ALGN_SM_STATEf_GET(r) ((((r).dbg_sts2[0]) >> 8) & 0x7)
#define BCMI_MADURA_DBG_STS2r_FEC_ALGN_SM_STATEf_SET(r,f) (r).dbg_sts2[0]=(((r).dbg_sts2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN0f_GET(r) ((((r).dbg_sts2[0]) >> 6) & 0x3)
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN0f_SET(r,f) (r).dbg_sts2[0]=(((r).dbg_sts2[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN1f_GET(r) ((((r).dbg_sts2[0]) >> 4) & 0x3)
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN1f_SET(r,f) (r).dbg_sts2[0]=(((r).dbg_sts2[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN2f_GET(r) ((((r).dbg_sts2[0]) >> 2) & 0x3)
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN2f_SET(r,f) (r).dbg_sts2[0]=(((r).dbg_sts2[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN3f_GET(r) (((r).dbg_sts2[0]) & 0x3)
#define BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN3f_SET(r,f) (r).dbg_sts2[0]=(((r).dbg_sts2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DBG_STS2.
 */
#define BCMI_MADURA_READ_DBG_STS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DBG_STS2r,_r._dbg_sts2)
#define BCMI_MADURA_WRITE_DBG_STS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DBG_STS2r,_r._dbg_sts2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DBG_STS2r BCMI_MADURA_DBG_STS2r
#define DBG_STS2r_SIZE BCMI_MADURA_DBG_STS2r_SIZE
typedef BCMI_MADURA_DBG_STS2r_t DBG_STS2r_t;
#define DBG_STS2r_CLR BCMI_MADURA_DBG_STS2r_CLR
#define DBG_STS2r_SET BCMI_MADURA_DBG_STS2r_SET
#define DBG_STS2r_GET BCMI_MADURA_DBG_STS2r_GET
#define DBG_STS2r_FEC_ALGN_SM_STATEf_GET BCMI_MADURA_DBG_STS2r_FEC_ALGN_SM_STATEf_GET
#define DBG_STS2r_FEC_ALGN_SM_STATEf_SET BCMI_MADURA_DBG_STS2r_FEC_ALGN_SM_STATEf_SET
#define DBG_STS2r_AM_LK_SM_STATE_LN0f_GET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN0f_GET
#define DBG_STS2r_AM_LK_SM_STATE_LN0f_SET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN0f_SET
#define DBG_STS2r_AM_LK_SM_STATE_LN1f_GET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN1f_GET
#define DBG_STS2r_AM_LK_SM_STATE_LN1f_SET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN1f_SET
#define DBG_STS2r_AM_LK_SM_STATE_LN2f_GET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN2f_GET
#define DBG_STS2r_AM_LK_SM_STATE_LN2f_SET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN2f_SET
#define DBG_STS2r_AM_LK_SM_STATE_LN3f_GET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN3f_GET
#define DBG_STS2r_AM_LK_SM_STATE_LN3f_SET BCMI_MADURA_DBG_STS2r_AM_LK_SM_STATE_LN3f_SET
#define READ_DBG_STS2r BCMI_MADURA_READ_DBG_STS2r
#define WRITE_DBG_STS2r BCMI_MADURA_WRITE_DBG_STS2r
#define MODIFY_DBG_STS2r BCMI_MADURA_MODIFY_DBG_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DBG_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_CLK_RST_START_ERR_GEN
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9900
 * DEVAD:    1
 * DESC:     RS encoder controls: clock, reset, and start error generation
 * RESETVAL: 0x6 (6)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_START Toggling this control bit from 0 to 1 starts the error-generationprocess.The user can only re-toggle this bit after detecting the latch-higherror-generation-done status goes high via polling and after settingthe error-generation controls on the pattern, location and consecutiveword number.Note the error-generation controls should remain stable after thestart pulse is toggled and can only be changed again after thelatch-high error-generation-done status goes high.
 *     RG_NFE_SOFT_RSTB An active-low reset the RS encoder0=soft reset the RS encoder.If the encoder inputs are valid, after de-asserting therg_nfe_soft_rstb_i, the encoder takes at most 2-codewordtime to flush out the internal garbage data.
 *     RG_NFE_CLK_EN    An active-high clock enable for the RS encoder1 = enable the clock.0 = disable the clock.If the encoder inputs are valid, after re-enabling therg_nfe_clk_en_i, the encoder takes at most 2-codewordtime to flush out the internal garbage data.
 */
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr (0x00019900 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_SIZE 4

/*
 * This structure should be used to declare and program CTL_CLK_RST_START_ERR_GEN.
 */
typedef union BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_s {
	uint32_t v[1];
	uint32_t ctl_clk_rst_start_err_gen[1];
	uint32_t _ctl_clk_rst_start_err_gen;
} BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_t;

#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_CLR(r) (r).ctl_clk_rst_start_err_gen[0] = 0
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_SET(r,d) (r).ctl_clk_rst_start_err_gen[0] = d
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_GET(r) (r).ctl_clk_rst_start_err_gen[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_CLK_ENf_GET(r) ((((r).ctl_clk_rst_start_err_gen[0]) >> 2) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_CLK_ENf_SET(r,f) (r).ctl_clk_rst_start_err_gen[0]=(((r).ctl_clk_rst_start_err_gen[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_SOFT_RSTBf_GET(r) ((((r).ctl_clk_rst_start_err_gen[0]) >> 1) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_SOFT_RSTBf_SET(r,f) (r).ctl_clk_rst_start_err_gen[0]=(((r).ctl_clk_rst_start_err_gen[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_ERR_GEN_STARTf_GET(r) (((r).ctl_clk_rst_start_err_gen[0]) & 0x1)
#define BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_ERR_GEN_STARTf_SET(r,f) (r).ctl_clk_rst_start_err_gen[0]=(((r).ctl_clk_rst_start_err_gen[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CTL_CLK_RST_START_ERR_GEN.
 */
#define BCMI_MADURA_READ_CTL_CLK_RST_START_ERR_GENr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr,_r._ctl_clk_rst_start_err_gen)
#define BCMI_MADURA_WRITE_CTL_CLK_RST_START_ERR_GENr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr,_r._ctl_clk_rst_start_err_gen)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_CLK_RST_START_ERR_GENr BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr
#define CTL_CLK_RST_START_ERR_GENr_SIZE BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_SIZE
typedef BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_t CTL_CLK_RST_START_ERR_GENr_t;
#define CTL_CLK_RST_START_ERR_GENr_CLR BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_CLR
#define CTL_CLK_RST_START_ERR_GENr_SET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_SET
#define CTL_CLK_RST_START_ERR_GENr_GET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_GET
#define CTL_CLK_RST_START_ERR_GENr_RG_NFE_CLK_ENf_GET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_CLK_ENf_GET
#define CTL_CLK_RST_START_ERR_GENr_RG_NFE_CLK_ENf_SET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_CLK_ENf_SET
#define CTL_CLK_RST_START_ERR_GENr_RG_NFE_SOFT_RSTBf_GET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_SOFT_RSTBf_GET
#define CTL_CLK_RST_START_ERR_GENr_RG_NFE_SOFT_RSTBf_SET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_SOFT_RSTBf_SET
#define CTL_CLK_RST_START_ERR_GENr_RG_NFE_ERR_GEN_STARTf_GET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_ERR_GEN_STARTf_GET
#define CTL_CLK_RST_START_ERR_GENr_RG_NFE_ERR_GEN_STARTf_SET BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr_RG_NFE_ERR_GEN_STARTf_SET
#define READ_CTL_CLK_RST_START_ERR_GENr BCMI_MADURA_READ_CTL_CLK_RST_START_ERR_GENr
#define WRITE_CTL_CLK_RST_START_ERR_GENr BCMI_MADURA_WRITE_CTL_CLK_RST_START_ERR_GENr
#define MODIFY_CTL_CLK_RST_START_ERR_GENr BCMI_MADURA_MODIFY_CTL_CLK_RST_START_ERR_GENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_CLK_RST_START_ERR_GENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT0
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9901
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_0 Bits [15:0] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT0r (0x00019901 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT0r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT0.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT0r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt0[1];
	uint32_t _ctl_err_gen_patt0;
} BCMI_MADURA_CTL_ERR_GEN_PATT0r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT0r_CLR(r) (r).ctl_err_gen_patt0[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT0r_SET(r,d) (r).ctl_err_gen_patt0[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT0r_GET(r) (r).ctl_err_gen_patt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT0r_RG_NFE_ERR_GEN_PATT_0f_GET(r) (((r).ctl_err_gen_patt0[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT0r_RG_NFE_ERR_GEN_PATT_0f_SET(r,f) (r).ctl_err_gen_patt0[0]=(((r).ctl_err_gen_patt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT0.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT0r,_r._ctl_err_gen_patt0)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT0r,_r._ctl_err_gen_patt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT0r BCMI_MADURA_CTL_ERR_GEN_PATT0r
#define CTL_ERR_GEN_PATT0r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT0r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT0r_t CTL_ERR_GEN_PATT0r_t;
#define CTL_ERR_GEN_PATT0r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT0r_CLR
#define CTL_ERR_GEN_PATT0r_SET BCMI_MADURA_CTL_ERR_GEN_PATT0r_SET
#define CTL_ERR_GEN_PATT0r_GET BCMI_MADURA_CTL_ERR_GEN_PATT0r_GET
#define CTL_ERR_GEN_PATT0r_RG_NFE_ERR_GEN_PATT_0f_GET BCMI_MADURA_CTL_ERR_GEN_PATT0r_RG_NFE_ERR_GEN_PATT_0f_GET
#define CTL_ERR_GEN_PATT0r_RG_NFE_ERR_GEN_PATT_0f_SET BCMI_MADURA_CTL_ERR_GEN_PATT0r_RG_NFE_ERR_GEN_PATT_0f_SET
#define READ_CTL_ERR_GEN_PATT0r BCMI_MADURA_READ_CTL_ERR_GEN_PATT0r
#define WRITE_CTL_ERR_GEN_PATT0r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT0r
#define MODIFY_CTL_ERR_GEN_PATT0r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT1
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9902
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_1 Bits [31:16] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT1r (0x00019902 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT1r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT1.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT1r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt1[1];
	uint32_t _ctl_err_gen_patt1;
} BCMI_MADURA_CTL_ERR_GEN_PATT1r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT1r_CLR(r) (r).ctl_err_gen_patt1[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT1r_SET(r,d) (r).ctl_err_gen_patt1[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT1r_GET(r) (r).ctl_err_gen_patt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT1r_RG_NFE_ERR_GEN_PATT_1f_GET(r) (((r).ctl_err_gen_patt1[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT1r_RG_NFE_ERR_GEN_PATT_1f_SET(r,f) (r).ctl_err_gen_patt1[0]=(((r).ctl_err_gen_patt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT1.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT1r,_r._ctl_err_gen_patt1)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT1r,_r._ctl_err_gen_patt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT1r BCMI_MADURA_CTL_ERR_GEN_PATT1r
#define CTL_ERR_GEN_PATT1r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT1r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT1r_t CTL_ERR_GEN_PATT1r_t;
#define CTL_ERR_GEN_PATT1r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT1r_CLR
#define CTL_ERR_GEN_PATT1r_SET BCMI_MADURA_CTL_ERR_GEN_PATT1r_SET
#define CTL_ERR_GEN_PATT1r_GET BCMI_MADURA_CTL_ERR_GEN_PATT1r_GET
#define CTL_ERR_GEN_PATT1r_RG_NFE_ERR_GEN_PATT_1f_GET BCMI_MADURA_CTL_ERR_GEN_PATT1r_RG_NFE_ERR_GEN_PATT_1f_GET
#define CTL_ERR_GEN_PATT1r_RG_NFE_ERR_GEN_PATT_1f_SET BCMI_MADURA_CTL_ERR_GEN_PATT1r_RG_NFE_ERR_GEN_PATT_1f_SET
#define READ_CTL_ERR_GEN_PATT1r BCMI_MADURA_READ_CTL_ERR_GEN_PATT1r
#define WRITE_CTL_ERR_GEN_PATT1r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT1r
#define MODIFY_CTL_ERR_GEN_PATT1r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT2
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9903
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_2 Bits [47:32] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT2r (0x00019903 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT2r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT2.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT2r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt2[1];
	uint32_t _ctl_err_gen_patt2;
} BCMI_MADURA_CTL_ERR_GEN_PATT2r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT2r_CLR(r) (r).ctl_err_gen_patt2[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT2r_SET(r,d) (r).ctl_err_gen_patt2[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT2r_GET(r) (r).ctl_err_gen_patt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT2r_RG_NFE_ERR_GEN_PATT_2f_GET(r) (((r).ctl_err_gen_patt2[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT2r_RG_NFE_ERR_GEN_PATT_2f_SET(r,f) (r).ctl_err_gen_patt2[0]=(((r).ctl_err_gen_patt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT2.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT2r,_r._ctl_err_gen_patt2)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT2r,_r._ctl_err_gen_patt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT2r BCMI_MADURA_CTL_ERR_GEN_PATT2r
#define CTL_ERR_GEN_PATT2r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT2r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT2r_t CTL_ERR_GEN_PATT2r_t;
#define CTL_ERR_GEN_PATT2r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT2r_CLR
#define CTL_ERR_GEN_PATT2r_SET BCMI_MADURA_CTL_ERR_GEN_PATT2r_SET
#define CTL_ERR_GEN_PATT2r_GET BCMI_MADURA_CTL_ERR_GEN_PATT2r_GET
#define CTL_ERR_GEN_PATT2r_RG_NFE_ERR_GEN_PATT_2f_GET BCMI_MADURA_CTL_ERR_GEN_PATT2r_RG_NFE_ERR_GEN_PATT_2f_GET
#define CTL_ERR_GEN_PATT2r_RG_NFE_ERR_GEN_PATT_2f_SET BCMI_MADURA_CTL_ERR_GEN_PATT2r_RG_NFE_ERR_GEN_PATT_2f_SET
#define READ_CTL_ERR_GEN_PATT2r BCMI_MADURA_READ_CTL_ERR_GEN_PATT2r
#define WRITE_CTL_ERR_GEN_PATT2r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT2r
#define MODIFY_CTL_ERR_GEN_PATT2r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT3
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9904
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_3 Bits [63:48] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT3r (0x00019904 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT3r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT3.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT3r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt3[1];
	uint32_t _ctl_err_gen_patt3;
} BCMI_MADURA_CTL_ERR_GEN_PATT3r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT3r_CLR(r) (r).ctl_err_gen_patt3[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT3r_SET(r,d) (r).ctl_err_gen_patt3[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT3r_GET(r) (r).ctl_err_gen_patt3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT3r_RG_NFE_ERR_GEN_PATT_3f_GET(r) (((r).ctl_err_gen_patt3[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT3r_RG_NFE_ERR_GEN_PATT_3f_SET(r,f) (r).ctl_err_gen_patt3[0]=(((r).ctl_err_gen_patt3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT3.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT3r,_r._ctl_err_gen_patt3)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT3r,_r._ctl_err_gen_patt3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT3r BCMI_MADURA_CTL_ERR_GEN_PATT3r
#define CTL_ERR_GEN_PATT3r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT3r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT3r_t CTL_ERR_GEN_PATT3r_t;
#define CTL_ERR_GEN_PATT3r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT3r_CLR
#define CTL_ERR_GEN_PATT3r_SET BCMI_MADURA_CTL_ERR_GEN_PATT3r_SET
#define CTL_ERR_GEN_PATT3r_GET BCMI_MADURA_CTL_ERR_GEN_PATT3r_GET
#define CTL_ERR_GEN_PATT3r_RG_NFE_ERR_GEN_PATT_3f_GET BCMI_MADURA_CTL_ERR_GEN_PATT3r_RG_NFE_ERR_GEN_PATT_3f_GET
#define CTL_ERR_GEN_PATT3r_RG_NFE_ERR_GEN_PATT_3f_SET BCMI_MADURA_CTL_ERR_GEN_PATT3r_RG_NFE_ERR_GEN_PATT_3f_SET
#define READ_CTL_ERR_GEN_PATT3r BCMI_MADURA_READ_CTL_ERR_GEN_PATT3r
#define WRITE_CTL_ERR_GEN_PATT3r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT3r
#define MODIFY_CTL_ERR_GEN_PATT3r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT4
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9905
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_4 Bits [79:64] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT4r (0x00019905 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT4r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT4.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT4r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt4[1];
	uint32_t _ctl_err_gen_patt4;
} BCMI_MADURA_CTL_ERR_GEN_PATT4r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT4r_CLR(r) (r).ctl_err_gen_patt4[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT4r_SET(r,d) (r).ctl_err_gen_patt4[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT4r_GET(r) (r).ctl_err_gen_patt4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT4r_RG_NFE_ERR_GEN_PATT_4f_GET(r) (((r).ctl_err_gen_patt4[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT4r_RG_NFE_ERR_GEN_PATT_4f_SET(r,f) (r).ctl_err_gen_patt4[0]=(((r).ctl_err_gen_patt4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT4.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT4r,_r._ctl_err_gen_patt4)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT4r,_r._ctl_err_gen_patt4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT4r BCMI_MADURA_CTL_ERR_GEN_PATT4r
#define CTL_ERR_GEN_PATT4r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT4r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT4r_t CTL_ERR_GEN_PATT4r_t;
#define CTL_ERR_GEN_PATT4r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT4r_CLR
#define CTL_ERR_GEN_PATT4r_SET BCMI_MADURA_CTL_ERR_GEN_PATT4r_SET
#define CTL_ERR_GEN_PATT4r_GET BCMI_MADURA_CTL_ERR_GEN_PATT4r_GET
#define CTL_ERR_GEN_PATT4r_RG_NFE_ERR_GEN_PATT_4f_GET BCMI_MADURA_CTL_ERR_GEN_PATT4r_RG_NFE_ERR_GEN_PATT_4f_GET
#define CTL_ERR_GEN_PATT4r_RG_NFE_ERR_GEN_PATT_4f_SET BCMI_MADURA_CTL_ERR_GEN_PATT4r_RG_NFE_ERR_GEN_PATT_4f_SET
#define READ_CTL_ERR_GEN_PATT4r BCMI_MADURA_READ_CTL_ERR_GEN_PATT4r
#define WRITE_CTL_ERR_GEN_PATT4r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT4r
#define MODIFY_CTL_ERR_GEN_PATT4r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT5
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9906
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_5 Bits [95:80] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT5r (0x00019906 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT5r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT5.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT5r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt5[1];
	uint32_t _ctl_err_gen_patt5;
} BCMI_MADURA_CTL_ERR_GEN_PATT5r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT5r_CLR(r) (r).ctl_err_gen_patt5[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT5r_SET(r,d) (r).ctl_err_gen_patt5[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT5r_GET(r) (r).ctl_err_gen_patt5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT5r_RG_NFE_ERR_GEN_PATT_5f_GET(r) (((r).ctl_err_gen_patt5[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT5r_RG_NFE_ERR_GEN_PATT_5f_SET(r,f) (r).ctl_err_gen_patt5[0]=(((r).ctl_err_gen_patt5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT5.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT5r,_r._ctl_err_gen_patt5)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT5r,_r._ctl_err_gen_patt5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT5r BCMI_MADURA_CTL_ERR_GEN_PATT5r
#define CTL_ERR_GEN_PATT5r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT5r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT5r_t CTL_ERR_GEN_PATT5r_t;
#define CTL_ERR_GEN_PATT5r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT5r_CLR
#define CTL_ERR_GEN_PATT5r_SET BCMI_MADURA_CTL_ERR_GEN_PATT5r_SET
#define CTL_ERR_GEN_PATT5r_GET BCMI_MADURA_CTL_ERR_GEN_PATT5r_GET
#define CTL_ERR_GEN_PATT5r_RG_NFE_ERR_GEN_PATT_5f_GET BCMI_MADURA_CTL_ERR_GEN_PATT5r_RG_NFE_ERR_GEN_PATT_5f_GET
#define CTL_ERR_GEN_PATT5r_RG_NFE_ERR_GEN_PATT_5f_SET BCMI_MADURA_CTL_ERR_GEN_PATT5r_RG_NFE_ERR_GEN_PATT_5f_SET
#define READ_CTL_ERR_GEN_PATT5r BCMI_MADURA_READ_CTL_ERR_GEN_PATT5r
#define WRITE_CTL_ERR_GEN_PATT5r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT5r
#define MODIFY_CTL_ERR_GEN_PATT5r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT6
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9907
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_6 Bits [111:96] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT6r (0x00019907 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT6r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT6.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT6r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt6[1];
	uint32_t _ctl_err_gen_patt6;
} BCMI_MADURA_CTL_ERR_GEN_PATT6r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT6r_CLR(r) (r).ctl_err_gen_patt6[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT6r_SET(r,d) (r).ctl_err_gen_patt6[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT6r_GET(r) (r).ctl_err_gen_patt6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT6r_RG_NFE_ERR_GEN_PATT_6f_GET(r) (((r).ctl_err_gen_patt6[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT6r_RG_NFE_ERR_GEN_PATT_6f_SET(r,f) (r).ctl_err_gen_patt6[0]=(((r).ctl_err_gen_patt6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT6.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT6r,_r._ctl_err_gen_patt6)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT6r,_r._ctl_err_gen_patt6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT6r BCMI_MADURA_CTL_ERR_GEN_PATT6r
#define CTL_ERR_GEN_PATT6r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT6r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT6r_t CTL_ERR_GEN_PATT6r_t;
#define CTL_ERR_GEN_PATT6r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT6r_CLR
#define CTL_ERR_GEN_PATT6r_SET BCMI_MADURA_CTL_ERR_GEN_PATT6r_SET
#define CTL_ERR_GEN_PATT6r_GET BCMI_MADURA_CTL_ERR_GEN_PATT6r_GET
#define CTL_ERR_GEN_PATT6r_RG_NFE_ERR_GEN_PATT_6f_GET BCMI_MADURA_CTL_ERR_GEN_PATT6r_RG_NFE_ERR_GEN_PATT_6f_GET
#define CTL_ERR_GEN_PATT6r_RG_NFE_ERR_GEN_PATT_6f_SET BCMI_MADURA_CTL_ERR_GEN_PATT6r_RG_NFE_ERR_GEN_PATT_6f_SET
#define READ_CTL_ERR_GEN_PATT6r BCMI_MADURA_READ_CTL_ERR_GEN_PATT6r
#define WRITE_CTL_ERR_GEN_PATT6r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT6r
#define MODIFY_CTL_ERR_GEN_PATT6r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT7
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9908
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_7 Bits [127:112] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT7r (0x00019908 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT7r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT7.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT7r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt7[1];
	uint32_t _ctl_err_gen_patt7;
} BCMI_MADURA_CTL_ERR_GEN_PATT7r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT7r_CLR(r) (r).ctl_err_gen_patt7[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT7r_SET(r,d) (r).ctl_err_gen_patt7[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT7r_GET(r) (r).ctl_err_gen_patt7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT7r_RG_NFE_ERR_GEN_PATT_7f_GET(r) (((r).ctl_err_gen_patt7[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT7r_RG_NFE_ERR_GEN_PATT_7f_SET(r,f) (r).ctl_err_gen_patt7[0]=(((r).ctl_err_gen_patt7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT7.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT7r,_r._ctl_err_gen_patt7)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT7r,_r._ctl_err_gen_patt7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT7r BCMI_MADURA_CTL_ERR_GEN_PATT7r
#define CTL_ERR_GEN_PATT7r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT7r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT7r_t CTL_ERR_GEN_PATT7r_t;
#define CTL_ERR_GEN_PATT7r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT7r_CLR
#define CTL_ERR_GEN_PATT7r_SET BCMI_MADURA_CTL_ERR_GEN_PATT7r_SET
#define CTL_ERR_GEN_PATT7r_GET BCMI_MADURA_CTL_ERR_GEN_PATT7r_GET
#define CTL_ERR_GEN_PATT7r_RG_NFE_ERR_GEN_PATT_7f_GET BCMI_MADURA_CTL_ERR_GEN_PATT7r_RG_NFE_ERR_GEN_PATT_7f_GET
#define CTL_ERR_GEN_PATT7r_RG_NFE_ERR_GEN_PATT_7f_SET BCMI_MADURA_CTL_ERR_GEN_PATT7r_RG_NFE_ERR_GEN_PATT_7f_SET
#define READ_CTL_ERR_GEN_PATT7r BCMI_MADURA_READ_CTL_ERR_GEN_PATT7r
#define WRITE_CTL_ERR_GEN_PATT7r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT7r
#define MODIFY_CTL_ERR_GEN_PATT7r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT8
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x9909
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_8 Bits [143:128] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT8r (0x00019909 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT8r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT8.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT8r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt8[1];
	uint32_t _ctl_err_gen_patt8;
} BCMI_MADURA_CTL_ERR_GEN_PATT8r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT8r_CLR(r) (r).ctl_err_gen_patt8[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT8r_SET(r,d) (r).ctl_err_gen_patt8[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT8r_GET(r) (r).ctl_err_gen_patt8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT8r_RG_NFE_ERR_GEN_PATT_8f_GET(r) (((r).ctl_err_gen_patt8[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT8r_RG_NFE_ERR_GEN_PATT_8f_SET(r,f) (r).ctl_err_gen_patt8[0]=(((r).ctl_err_gen_patt8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT8.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT8r,_r._ctl_err_gen_patt8)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT8r,_r._ctl_err_gen_patt8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT8r BCMI_MADURA_CTL_ERR_GEN_PATT8r
#define CTL_ERR_GEN_PATT8r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT8r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT8r_t CTL_ERR_GEN_PATT8r_t;
#define CTL_ERR_GEN_PATT8r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT8r_CLR
#define CTL_ERR_GEN_PATT8r_SET BCMI_MADURA_CTL_ERR_GEN_PATT8r_SET
#define CTL_ERR_GEN_PATT8r_GET BCMI_MADURA_CTL_ERR_GEN_PATT8r_GET
#define CTL_ERR_GEN_PATT8r_RG_NFE_ERR_GEN_PATT_8f_GET BCMI_MADURA_CTL_ERR_GEN_PATT8r_RG_NFE_ERR_GEN_PATT_8f_GET
#define CTL_ERR_GEN_PATT8r_RG_NFE_ERR_GEN_PATT_8f_SET BCMI_MADURA_CTL_ERR_GEN_PATT8r_RG_NFE_ERR_GEN_PATT_8f_SET
#define READ_CTL_ERR_GEN_PATT8r BCMI_MADURA_READ_CTL_ERR_GEN_PATT8r
#define WRITE_CTL_ERR_GEN_PATT8r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT8r
#define MODIFY_CTL_ERR_GEN_PATT8r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_PATT9
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x990a
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_pattern_9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_PATT_9 Bits [159:144] of the 160-bit error pattern to be XORed to the normalencoded codeword at the locations selected byrg_nfe_err_gen_loc_i [32:0] forrg_nfe_err_gen_consec_cw_num_i[2:0] consecutive codewords.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT9r (0x0001990a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_PATT9r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_PATT9.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_PATT9r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_patt9[1];
	uint32_t _ctl_err_gen_patt9;
} BCMI_MADURA_CTL_ERR_GEN_PATT9r_t;

#define BCMI_MADURA_CTL_ERR_GEN_PATT9r_CLR(r) (r).ctl_err_gen_patt9[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_PATT9r_SET(r,d) (r).ctl_err_gen_patt9[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_PATT9r_GET(r) (r).ctl_err_gen_patt9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_PATT9r_RG_NFE_ERR_GEN_PATT_9f_GET(r) (((r).ctl_err_gen_patt9[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_PATT9r_RG_NFE_ERR_GEN_PATT_9f_SET(r,f) (r).ctl_err_gen_patt9[0]=(((r).ctl_err_gen_patt9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_PATT9.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_PATT9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT9r,_r._ctl_err_gen_patt9)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_PATT9r,_r._ctl_err_gen_patt9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_PATT9r BCMI_MADURA_CTL_ERR_GEN_PATT9r
#define CTL_ERR_GEN_PATT9r_SIZE BCMI_MADURA_CTL_ERR_GEN_PATT9r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_PATT9r_t CTL_ERR_GEN_PATT9r_t;
#define CTL_ERR_GEN_PATT9r_CLR BCMI_MADURA_CTL_ERR_GEN_PATT9r_CLR
#define CTL_ERR_GEN_PATT9r_SET BCMI_MADURA_CTL_ERR_GEN_PATT9r_SET
#define CTL_ERR_GEN_PATT9r_GET BCMI_MADURA_CTL_ERR_GEN_PATT9r_GET
#define CTL_ERR_GEN_PATT9r_RG_NFE_ERR_GEN_PATT_9f_GET BCMI_MADURA_CTL_ERR_GEN_PATT9r_RG_NFE_ERR_GEN_PATT_9f_GET
#define CTL_ERR_GEN_PATT9r_RG_NFE_ERR_GEN_PATT_9f_SET BCMI_MADURA_CTL_ERR_GEN_PATT9r_RG_NFE_ERR_GEN_PATT_9f_SET
#define READ_CTL_ERR_GEN_PATT9r BCMI_MADURA_READ_CTL_ERR_GEN_PATT9r
#define WRITE_CTL_ERR_GEN_PATT9r BCMI_MADURA_WRITE_CTL_ERR_GEN_PATT9r
#define MODIFY_CTL_ERR_GEN_PATT9r BCMI_MADURA_MODIFY_CTL_ERR_GEN_PATT9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_PATT9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_LOC0
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x990b
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_location_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_LOC_0 Bits [15:0] of the 33-bit error location.Note a codeword constitutes 33 clock cycles. A Logic 1 on rg_nfe_err_gen_loc_i[N] corresponds to adding (XORing) rg_nfe_err_gen_patt_i[159:0] to the Nth 160-bit encoded data.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_LOC0r (0x0001990b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_LOC0r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_LOC0.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_LOC0r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_loc0[1];
	uint32_t _ctl_err_gen_loc0;
} BCMI_MADURA_CTL_ERR_GEN_LOC0r_t;

#define BCMI_MADURA_CTL_ERR_GEN_LOC0r_CLR(r) (r).ctl_err_gen_loc0[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_LOC0r_SET(r,d) (r).ctl_err_gen_loc0[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_LOC0r_GET(r) (r).ctl_err_gen_loc0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_LOC0r_RG_NFE_ERR_GEN_LOC_0f_GET(r) (((r).ctl_err_gen_loc0[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_LOC0r_RG_NFE_ERR_GEN_LOC_0f_SET(r,f) (r).ctl_err_gen_loc0[0]=(((r).ctl_err_gen_loc0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_LOC0.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_LOC0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_LOC0r,_r._ctl_err_gen_loc0)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_LOC0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_LOC0r,_r._ctl_err_gen_loc0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_LOC0r BCMI_MADURA_CTL_ERR_GEN_LOC0r
#define CTL_ERR_GEN_LOC0r_SIZE BCMI_MADURA_CTL_ERR_GEN_LOC0r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_LOC0r_t CTL_ERR_GEN_LOC0r_t;
#define CTL_ERR_GEN_LOC0r_CLR BCMI_MADURA_CTL_ERR_GEN_LOC0r_CLR
#define CTL_ERR_GEN_LOC0r_SET BCMI_MADURA_CTL_ERR_GEN_LOC0r_SET
#define CTL_ERR_GEN_LOC0r_GET BCMI_MADURA_CTL_ERR_GEN_LOC0r_GET
#define CTL_ERR_GEN_LOC0r_RG_NFE_ERR_GEN_LOC_0f_GET BCMI_MADURA_CTL_ERR_GEN_LOC0r_RG_NFE_ERR_GEN_LOC_0f_GET
#define CTL_ERR_GEN_LOC0r_RG_NFE_ERR_GEN_LOC_0f_SET BCMI_MADURA_CTL_ERR_GEN_LOC0r_RG_NFE_ERR_GEN_LOC_0f_SET
#define READ_CTL_ERR_GEN_LOC0r BCMI_MADURA_READ_CTL_ERR_GEN_LOC0r
#define WRITE_CTL_ERR_GEN_LOC0r BCMI_MADURA_WRITE_CTL_ERR_GEN_LOC0r
#define MODIFY_CTL_ERR_GEN_LOC0r BCMI_MADURA_MODIFY_CTL_ERR_GEN_LOC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_LOC0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_LOC1
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x990c
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_location_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_LOC_1 Bits [31:16] of the 33-bit error location.Note a codeword constitutes 33 clock cycles. A Logic 1 on rg_nfe_err_gen_loc_i[N] corresponds to adding (XORing) rg_nfe_err_gen_patt_i[159:0] to the Nth 160-bit encoded data.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_LOC1r (0x0001990c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_LOC1r_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_LOC1.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_LOC1r_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_loc1[1];
	uint32_t _ctl_err_gen_loc1;
} BCMI_MADURA_CTL_ERR_GEN_LOC1r_t;

#define BCMI_MADURA_CTL_ERR_GEN_LOC1r_CLR(r) (r).ctl_err_gen_loc1[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_LOC1r_SET(r,d) (r).ctl_err_gen_loc1[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_LOC1r_GET(r) (r).ctl_err_gen_loc1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_LOC1r_RG_NFE_ERR_GEN_LOC_1f_GET(r) (((r).ctl_err_gen_loc1[0]) & 0xffff)
#define BCMI_MADURA_CTL_ERR_GEN_LOC1r_RG_NFE_ERR_GEN_LOC_1f_SET(r,f) (r).ctl_err_gen_loc1[0]=(((r).ctl_err_gen_loc1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_LOC1.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_LOC1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_LOC1r,_r._ctl_err_gen_loc1)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_LOC1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_LOC1r,_r._ctl_err_gen_loc1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_LOC1r BCMI_MADURA_CTL_ERR_GEN_LOC1r
#define CTL_ERR_GEN_LOC1r_SIZE BCMI_MADURA_CTL_ERR_GEN_LOC1r_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_LOC1r_t CTL_ERR_GEN_LOC1r_t;
#define CTL_ERR_GEN_LOC1r_CLR BCMI_MADURA_CTL_ERR_GEN_LOC1r_CLR
#define CTL_ERR_GEN_LOC1r_SET BCMI_MADURA_CTL_ERR_GEN_LOC1r_SET
#define CTL_ERR_GEN_LOC1r_GET BCMI_MADURA_CTL_ERR_GEN_LOC1r_GET
#define CTL_ERR_GEN_LOC1r_RG_NFE_ERR_GEN_LOC_1f_GET BCMI_MADURA_CTL_ERR_GEN_LOC1r_RG_NFE_ERR_GEN_LOC_1f_GET
#define CTL_ERR_GEN_LOC1r_RG_NFE_ERR_GEN_LOC_1f_SET BCMI_MADURA_CTL_ERR_GEN_LOC1r_RG_NFE_ERR_GEN_LOC_1f_SET
#define READ_CTL_ERR_GEN_LOC1r BCMI_MADURA_READ_CTL_ERR_GEN_LOC1r
#define WRITE_CTL_ERR_GEN_LOC1r BCMI_MADURA_WRITE_CTL_ERR_GEN_LOC1r
#define MODIFY_CTL_ERR_GEN_LOC1r BCMI_MADURA_MODIFY_CTL_ERR_GEN_LOC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_LOC1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CTL_ERR_GEN_LOC_2_CW_NUM
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x990d
 * DEVAD:    1
 * DESC:     RS encoder error-generation controls: error_location_2 & word number
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RG_NFE_ERR_GEN_LOC_2 Bits [32] of the 33-bit error location.Note a codeword constitutes 33 clock cycles. A Logic 1 on rg_nfe_err_gen_loc_i[N] corresponds to adding (XORing) rg_nfe_err_gen_patt_i[159:0] to the Nth 160-bit encoded data.This register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 *     RG_NFE_ERR_GEN_CONSEC_CW_NUM The number of consecutive codewords having the error pattern andat the locations specified by the rg_nfe_err_gen_patt_i[159:0] andthe rg_nfe_err_gen_loc_i[32:0] respectively.0: no error added (XORed)1: error added (XORed) to 1 codeword2: error added (XORed) to 2 consecutive codewords......15: error added (XORed) to on 15 consecutive codewordsThis register should be changed before toggling the error-generationstart pulse. Once the start pulse is toggled, it must remain stable and it can be re-programmed after the latch-high error-generation-donestatus goes high via polling.
 */
#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr (0x0001990d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_SIZE 4

/*
 * This structure should be used to declare and program CTL_ERR_GEN_LOC_2_CW_NUM.
 */
typedef union BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_s {
	uint32_t v[1];
	uint32_t ctl_err_gen_loc_2_cw_num[1];
	uint32_t _ctl_err_gen_loc_2_cw_num;
} BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_t;

#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_CLR(r) (r).ctl_err_gen_loc_2_cw_num[0] = 0
#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_SET(r,d) (r).ctl_err_gen_loc_2_cw_num[0] = d
#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_GET(r) (r).ctl_err_gen_loc_2_cw_num[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_CONSEC_CW_NUMf_GET(r) ((((r).ctl_err_gen_loc_2_cw_num[0]) >> 1) & 0xf)
#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_CONSEC_CW_NUMf_SET(r,f) (r).ctl_err_gen_loc_2_cw_num[0]=(((r).ctl_err_gen_loc_2_cw_num[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))
#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_LOC_2f_GET(r) (((r).ctl_err_gen_loc_2_cw_num[0]) & 0x1)
#define BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_LOC_2f_SET(r,f) (r).ctl_err_gen_loc_2_cw_num[0]=(((r).ctl_err_gen_loc_2_cw_num[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CTL_ERR_GEN_LOC_2_CW_NUM.
 */
#define BCMI_MADURA_READ_CTL_ERR_GEN_LOC_2_CW_NUMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr,_r._ctl_err_gen_loc_2_cw_num)
#define BCMI_MADURA_WRITE_CTL_ERR_GEN_LOC_2_CW_NUMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr,_r._ctl_err_gen_loc_2_cw_num)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CTL_ERR_GEN_LOC_2_CW_NUMr BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr
#define CTL_ERR_GEN_LOC_2_CW_NUMr_SIZE BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_SIZE
typedef BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_t CTL_ERR_GEN_LOC_2_CW_NUMr_t;
#define CTL_ERR_GEN_LOC_2_CW_NUMr_CLR BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_CLR
#define CTL_ERR_GEN_LOC_2_CW_NUMr_SET BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_SET
#define CTL_ERR_GEN_LOC_2_CW_NUMr_GET BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_GET
#define CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_CONSEC_CW_NUMf_GET BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_CONSEC_CW_NUMf_GET
#define CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_CONSEC_CW_NUMf_SET BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_CONSEC_CW_NUMf_SET
#define CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_LOC_2f_GET BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_LOC_2f_GET
#define CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_LOC_2f_SET BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr_RG_NFE_ERR_GEN_LOC_2f_SET
#define READ_CTL_ERR_GEN_LOC_2_CW_NUMr BCMI_MADURA_READ_CTL_ERR_GEN_LOC_2_CW_NUMr
#define WRITE_CTL_ERR_GEN_LOC_2_CW_NUMr BCMI_MADURA_WRITE_CTL_ERR_GEN_LOC_2_CW_NUMr
#define MODIFY_CTL_ERR_GEN_LOC_2_CW_NUMr BCMI_MADURA_MODIFY_CTL_ERR_GEN_LOC_2_CW_NUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CTL_ERR_GEN_LOC_2_CW_NUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  STAT_ERR_GEN_DONE_LH
 * BLOCKS:   CL91_USER_ENC
 * REGADDR:  0x990e
 * DEVAD:    1
 * DESC:     RS encoder status: latch-high error-generation done
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NFE_RG_ERR_GEN_DONE_LH 1 = encoder error-generation is doneThis bit is self-cleared after read.
 */
#define BCMI_MADURA_STAT_ERR_GEN_DONE_LHr (0x0001990e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_SIZE 4

/*
 * This structure should be used to declare and program STAT_ERR_GEN_DONE_LH.
 */
typedef union BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_s {
	uint32_t v[1];
	uint32_t stat_err_gen_done_lh[1];
	uint32_t _stat_err_gen_done_lh;
} BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_t;

#define BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_CLR(r) (r).stat_err_gen_done_lh[0] = 0
#define BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_SET(r,d) (r).stat_err_gen_done_lh[0] = d
#define BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_GET(r) (r).stat_err_gen_done_lh[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_NFE_RG_ERR_GEN_DONE_LHf_GET(r) (((r).stat_err_gen_done_lh[0]) & 0x1)
#define BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_NFE_RG_ERR_GEN_DONE_LHf_SET(r,f) (r).stat_err_gen_done_lh[0]=(((r).stat_err_gen_done_lh[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access STAT_ERR_GEN_DONE_LH.
 */
#define BCMI_MADURA_READ_STAT_ERR_GEN_DONE_LHr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_STAT_ERR_GEN_DONE_LHr,_r._stat_err_gen_done_lh)
#define BCMI_MADURA_WRITE_STAT_ERR_GEN_DONE_LHr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_STAT_ERR_GEN_DONE_LHr,_r._stat_err_gen_done_lh)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define STAT_ERR_GEN_DONE_LHr BCMI_MADURA_STAT_ERR_GEN_DONE_LHr
#define STAT_ERR_GEN_DONE_LHr_SIZE BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_SIZE
typedef BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_t STAT_ERR_GEN_DONE_LHr_t;
#define STAT_ERR_GEN_DONE_LHr_CLR BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_CLR
#define STAT_ERR_GEN_DONE_LHr_SET BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_SET
#define STAT_ERR_GEN_DONE_LHr_GET BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_GET
#define STAT_ERR_GEN_DONE_LHr_NFE_RG_ERR_GEN_DONE_LHf_GET BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_NFE_RG_ERR_GEN_DONE_LHf_GET
#define STAT_ERR_GEN_DONE_LHr_NFE_RG_ERR_GEN_DONE_LHf_SET BCMI_MADURA_STAT_ERR_GEN_DONE_LHr_NFE_RG_ERR_GEN_DONE_LHf_SET
#define READ_STAT_ERR_GEN_DONE_LHr BCMI_MADURA_READ_STAT_ERR_GEN_DONE_LHr
#define WRITE_STAT_ERR_GEN_DONE_LHr BCMI_MADURA_WRITE_STAT_ERR_GEN_DONE_LHr
#define MODIFY_STAT_ERR_GEN_DONE_LHr BCMI_MADURA_MODIFY_STAT_ERR_GEN_DONE_LHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_STAT_ERR_GEN_DONE_LHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_USER_TX_CTL
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c00
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Common control 1
 * RESETVAL: 0x8001 (32769)
 * ACCESS:   R/W
 * FIELDS:
 *     CRPT_XCW_ON_LOA  1 = Generate transcoded words with invalid sync headers when Tx PCS AM  Lock is not found
 *     DIS_SOM_ON_LOA   1 = Disable start of message signal generation to the RS Encoder when Tx PCS AM  Lock is not found
 *     USE_MLG_40G_AM   1 = Use 4x25G MLG Alignment Markers corresponding to 2x40G + 2x10G trafficIf both use_mlg_10g_am and use_mlg_40g_am bits are 0, then Alignment Markers listed in CL91 of IEEE std are usedThere is no equivalent cfg bit in Rx regs, this is applicable for both Tx and Rx paths
 *     USE_MLG_10G_AM   1 = Use 4x25G MLG Alignment Markers corresponding to 10x10G trafficIf both use_mlg_10g_am and use_mlg_40g_am bits are 0, then Alignment Markers listed in CL91 of IEEE std are usedThere is no equivalent cfg bit in Rx regs, this is applicable for both Tx and Rx paths
 *     FRC_TX_DP_RSTB   1 = The bit tx_dp_rstb is effective0 = The bit tx_dp_rstb has no effect
 *     TX_DP_RSTB       0 = Reset Tx datapath. Will have no effect on config registers.1 = not in resetNote: This bit is effective only when frc_tx_dp_rstb = 1.This is not a self clearing bit
 */
#define BCMI_MADURA_CL91_USER_TX_CTLr (0x00019c00 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_USER_TX_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL91_USER_TX_CTL.
 */
typedef union BCMI_MADURA_CL91_USER_TX_CTLr_s {
	uint32_t v[1];
	uint32_t cl91_user_tx_ctl[1];
	uint32_t _cl91_user_tx_ctl;
} BCMI_MADURA_CL91_USER_TX_CTLr_t;

#define BCMI_MADURA_CL91_USER_TX_CTLr_CLR(r) (r).cl91_user_tx_ctl[0] = 0
#define BCMI_MADURA_CL91_USER_TX_CTLr_SET(r,d) (r).cl91_user_tx_ctl[0] = d
#define BCMI_MADURA_CL91_USER_TX_CTLr_GET(r) (r).cl91_user_tx_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_USER_TX_CTLr_TX_DP_RSTBf_GET(r) ((((r).cl91_user_tx_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_CTLr_TX_DP_RSTBf_SET(r,f) (r).cl91_user_tx_ctl[0]=(((r).cl91_user_tx_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL91_USER_TX_CTLr_FRC_TX_DP_RSTBf_GET(r) ((((r).cl91_user_tx_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_CTLr_FRC_TX_DP_RSTBf_SET(r,f) (r).cl91_user_tx_ctl[0]=(((r).cl91_user_tx_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_10G_AMf_GET(r) ((((r).cl91_user_tx_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_10G_AMf_SET(r,f) (r).cl91_user_tx_ctl[0]=(((r).cl91_user_tx_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_40G_AMf_GET(r) ((((r).cl91_user_tx_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_40G_AMf_SET(r,f) (r).cl91_user_tx_ctl[0]=(((r).cl91_user_tx_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL91_USER_TX_CTLr_DIS_SOM_ON_LOAf_GET(r) ((((r).cl91_user_tx_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_CTLr_DIS_SOM_ON_LOAf_SET(r,f) (r).cl91_user_tx_ctl[0]=(((r).cl91_user_tx_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL91_USER_TX_CTLr_CRPT_XCW_ON_LOAf_GET(r) (((r).cl91_user_tx_ctl[0]) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_CTLr_CRPT_XCW_ON_LOAf_SET(r,f) (r).cl91_user_tx_ctl[0]=(((r).cl91_user_tx_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL91_USER_TX_CTL.
 */
#define BCMI_MADURA_READ_CL91_USER_TX_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_USER_TX_CTLr,_r._cl91_user_tx_ctl)
#define BCMI_MADURA_WRITE_CL91_USER_TX_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_USER_TX_CTLr,_r._cl91_user_tx_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_USER_TX_CTLr BCMI_MADURA_CL91_USER_TX_CTLr
#define CL91_USER_TX_CTLr_SIZE BCMI_MADURA_CL91_USER_TX_CTLr_SIZE
typedef BCMI_MADURA_CL91_USER_TX_CTLr_t CL91_USER_TX_CTLr_t;
#define CL91_USER_TX_CTLr_CLR BCMI_MADURA_CL91_USER_TX_CTLr_CLR
#define CL91_USER_TX_CTLr_SET BCMI_MADURA_CL91_USER_TX_CTLr_SET
#define CL91_USER_TX_CTLr_GET BCMI_MADURA_CL91_USER_TX_CTLr_GET
#define CL91_USER_TX_CTLr_TX_DP_RSTBf_GET BCMI_MADURA_CL91_USER_TX_CTLr_TX_DP_RSTBf_GET
#define CL91_USER_TX_CTLr_TX_DP_RSTBf_SET BCMI_MADURA_CL91_USER_TX_CTLr_TX_DP_RSTBf_SET
#define CL91_USER_TX_CTLr_FRC_TX_DP_RSTBf_GET BCMI_MADURA_CL91_USER_TX_CTLr_FRC_TX_DP_RSTBf_GET
#define CL91_USER_TX_CTLr_FRC_TX_DP_RSTBf_SET BCMI_MADURA_CL91_USER_TX_CTLr_FRC_TX_DP_RSTBf_SET
#define CL91_USER_TX_CTLr_USE_MLG_10G_AMf_GET BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_10G_AMf_GET
#define CL91_USER_TX_CTLr_USE_MLG_10G_AMf_SET BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_10G_AMf_SET
#define CL91_USER_TX_CTLr_USE_MLG_40G_AMf_GET BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_40G_AMf_GET
#define CL91_USER_TX_CTLr_USE_MLG_40G_AMf_SET BCMI_MADURA_CL91_USER_TX_CTLr_USE_MLG_40G_AMf_SET
#define CL91_USER_TX_CTLr_DIS_SOM_ON_LOAf_GET BCMI_MADURA_CL91_USER_TX_CTLr_DIS_SOM_ON_LOAf_GET
#define CL91_USER_TX_CTLr_DIS_SOM_ON_LOAf_SET BCMI_MADURA_CL91_USER_TX_CTLr_DIS_SOM_ON_LOAf_SET
#define CL91_USER_TX_CTLr_CRPT_XCW_ON_LOAf_GET BCMI_MADURA_CL91_USER_TX_CTLr_CRPT_XCW_ON_LOAf_GET
#define CL91_USER_TX_CTLr_CRPT_XCW_ON_LOAf_SET BCMI_MADURA_CL91_USER_TX_CTLr_CRPT_XCW_ON_LOAf_SET
#define READ_CL91_USER_TX_CTLr BCMI_MADURA_READ_CL91_USER_TX_CTLr
#define WRITE_CL91_USER_TX_CTLr BCMI_MADURA_WRITE_CL91_USER_TX_CTLr
#define MODIFY_CL91_USER_TX_CTLr BCMI_MADURA_MODIFY_CL91_USER_TX_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_USER_TX_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_USER_TX_STS1
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c01
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Common status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NONUNIQ_PCSL_FOUND_LH Non unique PCSL lane number found.This bit indicates that there are alteast two Service Interface lanesare carrying traffic with the same PCSL lane numbers.During this condition, the all_aligned indication will be a zero.This bit needs to be evaluated only after all lanes have achieved am_lock.This bit will be high at the start and should be cleared once allam_lock is valid. If this bit still remains high after all am_lock is validthen there are atleast two lanes with the same lane numbers.Latched high status, implemented with a latching high cell
 *     ALL_ALIGNED      1 = All PCSL lanes are skew balanced and aligned.
 *     ALL_ALIGNED_LL   Latching low version of all_aligned status
 *     ALL_ALIGNED_LH   Latching high version of all_aligned status
 *     TX_XC_SH_ERR_LH  1 = A transcoded word with invalid sync headers was generated in response to an invalid sync header from the PCS.Latched high status, implemented with a latching high cell
 */
#define BCMI_MADURA_CL91_USER_TX_STS1r (0x00019c01 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_USER_TX_STS1r_SIZE 4

/*
 * This structure should be used to declare and program CL91_USER_TX_STS1.
 */
typedef union BCMI_MADURA_CL91_USER_TX_STS1r_s {
	uint32_t v[1];
	uint32_t cl91_user_tx_sts1[1];
	uint32_t _cl91_user_tx_sts1;
} BCMI_MADURA_CL91_USER_TX_STS1r_t;

#define BCMI_MADURA_CL91_USER_TX_STS1r_CLR(r) (r).cl91_user_tx_sts1[0] = 0
#define BCMI_MADURA_CL91_USER_TX_STS1r_SET(r,d) (r).cl91_user_tx_sts1[0] = d
#define BCMI_MADURA_CL91_USER_TX_STS1r_GET(r) (r).cl91_user_tx_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_USER_TX_STS1r_TX_XC_SH_ERR_LHf_GET(r) ((((r).cl91_user_tx_sts1[0]) >> 4) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_STS1r_TX_XC_SH_ERR_LHf_SET(r,f) (r).cl91_user_tx_sts1[0]=(((r).cl91_user_tx_sts1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LHf_GET(r) ((((r).cl91_user_tx_sts1[0]) >> 3) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LHf_SET(r,f) (r).cl91_user_tx_sts1[0]=(((r).cl91_user_tx_sts1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LLf_GET(r) ((((r).cl91_user_tx_sts1[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LLf_SET(r,f) (r).cl91_user_tx_sts1[0]=(((r).cl91_user_tx_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNEDf_GET(r) ((((r).cl91_user_tx_sts1[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNEDf_SET(r,f) (r).cl91_user_tx_sts1[0]=(((r).cl91_user_tx_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL91_USER_TX_STS1r_NONUNIQ_PCSL_FOUND_LHf_GET(r) (((r).cl91_user_tx_sts1[0]) & 0x1)
#define BCMI_MADURA_CL91_USER_TX_STS1r_NONUNIQ_PCSL_FOUND_LHf_SET(r,f) (r).cl91_user_tx_sts1[0]=(((r).cl91_user_tx_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL91_USER_TX_STS1.
 */
#define BCMI_MADURA_READ_CL91_USER_TX_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_USER_TX_STS1r,_r._cl91_user_tx_sts1)
#define BCMI_MADURA_WRITE_CL91_USER_TX_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_USER_TX_STS1r,_r._cl91_user_tx_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_USER_TX_STS1r BCMI_MADURA_CL91_USER_TX_STS1r
#define CL91_USER_TX_STS1r_SIZE BCMI_MADURA_CL91_USER_TX_STS1r_SIZE
typedef BCMI_MADURA_CL91_USER_TX_STS1r_t CL91_USER_TX_STS1r_t;
#define CL91_USER_TX_STS1r_CLR BCMI_MADURA_CL91_USER_TX_STS1r_CLR
#define CL91_USER_TX_STS1r_SET BCMI_MADURA_CL91_USER_TX_STS1r_SET
#define CL91_USER_TX_STS1r_GET BCMI_MADURA_CL91_USER_TX_STS1r_GET
#define CL91_USER_TX_STS1r_TX_XC_SH_ERR_LHf_GET BCMI_MADURA_CL91_USER_TX_STS1r_TX_XC_SH_ERR_LHf_GET
#define CL91_USER_TX_STS1r_TX_XC_SH_ERR_LHf_SET BCMI_MADURA_CL91_USER_TX_STS1r_TX_XC_SH_ERR_LHf_SET
#define CL91_USER_TX_STS1r_ALL_ALIGNED_LHf_GET BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LHf_GET
#define CL91_USER_TX_STS1r_ALL_ALIGNED_LHf_SET BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LHf_SET
#define CL91_USER_TX_STS1r_ALL_ALIGNED_LLf_GET BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LLf_GET
#define CL91_USER_TX_STS1r_ALL_ALIGNED_LLf_SET BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNED_LLf_SET
#define CL91_USER_TX_STS1r_ALL_ALIGNEDf_GET BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNEDf_GET
#define CL91_USER_TX_STS1r_ALL_ALIGNEDf_SET BCMI_MADURA_CL91_USER_TX_STS1r_ALL_ALIGNEDf_SET
#define CL91_USER_TX_STS1r_NONUNIQ_PCSL_FOUND_LHf_GET BCMI_MADURA_CL91_USER_TX_STS1r_NONUNIQ_PCSL_FOUND_LHf_GET
#define CL91_USER_TX_STS1r_NONUNIQ_PCSL_FOUND_LHf_SET BCMI_MADURA_CL91_USER_TX_STS1r_NONUNIQ_PCSL_FOUND_LHf_SET
#define READ_CL91_USER_TX_STS1r BCMI_MADURA_READ_CL91_USER_TX_STS1r
#define WRITE_CL91_USER_TX_STS1r BCMI_MADURA_WRITE_CL91_USER_TX_STS1r
#define MODIFY_CL91_USER_TX_STS1r BCMI_MADURA_MODIFY_CL91_USER_TX_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_USER_TX_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_USER_TX_STS2
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c02
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Common status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BLOCK_LOCK_9_0   Block lock status for service interface lanes 9 through 0.bit[0] - Lane 0.bit[1] - Lane 1.bit[2] - Lane 2.bit[3] - Lane 3.bit[4] - Lane 4.bit[5] - Lane 5.bit[6] - Lane 6.bit[7] - Lane 7.bit[8] - Lane 8.bit[9] - Lane 9.
 */
#define BCMI_MADURA_CL91_USER_TX_STS2r (0x00019c02 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_USER_TX_STS2r_SIZE 4

/*
 * This structure should be used to declare and program CL91_USER_TX_STS2.
 */
typedef union BCMI_MADURA_CL91_USER_TX_STS2r_s {
	uint32_t v[1];
	uint32_t cl91_user_tx_sts2[1];
	uint32_t _cl91_user_tx_sts2;
} BCMI_MADURA_CL91_USER_TX_STS2r_t;

#define BCMI_MADURA_CL91_USER_TX_STS2r_CLR(r) (r).cl91_user_tx_sts2[0] = 0
#define BCMI_MADURA_CL91_USER_TX_STS2r_SET(r,d) (r).cl91_user_tx_sts2[0] = d
#define BCMI_MADURA_CL91_USER_TX_STS2r_GET(r) (r).cl91_user_tx_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_USER_TX_STS2r_BLOCK_LOCK_9_0f_GET(r) (((r).cl91_user_tx_sts2[0]) & 0x3ff)
#define BCMI_MADURA_CL91_USER_TX_STS2r_BLOCK_LOCK_9_0f_SET(r,f) (r).cl91_user_tx_sts2[0]=(((r).cl91_user_tx_sts2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL91_USER_TX_STS2.
 */
#define BCMI_MADURA_READ_CL91_USER_TX_STS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_USER_TX_STS2r,_r._cl91_user_tx_sts2)
#define BCMI_MADURA_WRITE_CL91_USER_TX_STS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_USER_TX_STS2r,_r._cl91_user_tx_sts2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_USER_TX_STS2r BCMI_MADURA_CL91_USER_TX_STS2r
#define CL91_USER_TX_STS2r_SIZE BCMI_MADURA_CL91_USER_TX_STS2r_SIZE
typedef BCMI_MADURA_CL91_USER_TX_STS2r_t CL91_USER_TX_STS2r_t;
#define CL91_USER_TX_STS2r_CLR BCMI_MADURA_CL91_USER_TX_STS2r_CLR
#define CL91_USER_TX_STS2r_SET BCMI_MADURA_CL91_USER_TX_STS2r_SET
#define CL91_USER_TX_STS2r_GET BCMI_MADURA_CL91_USER_TX_STS2r_GET
#define CL91_USER_TX_STS2r_BLOCK_LOCK_9_0f_GET BCMI_MADURA_CL91_USER_TX_STS2r_BLOCK_LOCK_9_0f_GET
#define CL91_USER_TX_STS2r_BLOCK_LOCK_9_0f_SET BCMI_MADURA_CL91_USER_TX_STS2r_BLOCK_LOCK_9_0f_SET
#define READ_CL91_USER_TX_STS2r BCMI_MADURA_READ_CL91_USER_TX_STS2r
#define WRITE_CL91_USER_TX_STS2r BCMI_MADURA_WRITE_CL91_USER_TX_STS2r
#define MODIFY_CL91_USER_TX_STS2r BCMI_MADURA_MODIFY_CL91_USER_TX_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_USER_TX_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_USER_TX_STS3
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c03
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Common status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BLOCK_LOCK_19_10 Block lock status for service interface lanes 19 through 10.bit[0] - Lane 10.bit[1] - Lane 11.bit[2] - Lane 12.bit[3] - Lane 13.bit[4] - Lane 14.bit[5] - Lane 15.bit[6] - Lane 16.bit[7] - Lane 17.bit[8] - Lane 18.bit[9] - Lane 19.
 */
#define BCMI_MADURA_CL91_USER_TX_STS3r (0x00019c03 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_USER_TX_STS3r_SIZE 4

/*
 * This structure should be used to declare and program CL91_USER_TX_STS3.
 */
typedef union BCMI_MADURA_CL91_USER_TX_STS3r_s {
	uint32_t v[1];
	uint32_t cl91_user_tx_sts3[1];
	uint32_t _cl91_user_tx_sts3;
} BCMI_MADURA_CL91_USER_TX_STS3r_t;

#define BCMI_MADURA_CL91_USER_TX_STS3r_CLR(r) (r).cl91_user_tx_sts3[0] = 0
#define BCMI_MADURA_CL91_USER_TX_STS3r_SET(r,d) (r).cl91_user_tx_sts3[0] = d
#define BCMI_MADURA_CL91_USER_TX_STS3r_GET(r) (r).cl91_user_tx_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_USER_TX_STS3r_BLOCK_LOCK_19_10f_GET(r) (((r).cl91_user_tx_sts3[0]) & 0x3ff)
#define BCMI_MADURA_CL91_USER_TX_STS3r_BLOCK_LOCK_19_10f_SET(r,f) (r).cl91_user_tx_sts3[0]=(((r).cl91_user_tx_sts3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL91_USER_TX_STS3.
 */
#define BCMI_MADURA_READ_CL91_USER_TX_STS3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_USER_TX_STS3r,_r._cl91_user_tx_sts3)
#define BCMI_MADURA_WRITE_CL91_USER_TX_STS3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_USER_TX_STS3r,_r._cl91_user_tx_sts3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_USER_TX_STS3r BCMI_MADURA_CL91_USER_TX_STS3r
#define CL91_USER_TX_STS3r_SIZE BCMI_MADURA_CL91_USER_TX_STS3r_SIZE
typedef BCMI_MADURA_CL91_USER_TX_STS3r_t CL91_USER_TX_STS3r_t;
#define CL91_USER_TX_STS3r_CLR BCMI_MADURA_CL91_USER_TX_STS3r_CLR
#define CL91_USER_TX_STS3r_SET BCMI_MADURA_CL91_USER_TX_STS3r_SET
#define CL91_USER_TX_STS3r_GET BCMI_MADURA_CL91_USER_TX_STS3r_GET
#define CL91_USER_TX_STS3r_BLOCK_LOCK_19_10f_GET BCMI_MADURA_CL91_USER_TX_STS3r_BLOCK_LOCK_19_10f_GET
#define CL91_USER_TX_STS3r_BLOCK_LOCK_19_10f_SET BCMI_MADURA_CL91_USER_TX_STS3r_BLOCK_LOCK_19_10f_SET
#define READ_CL91_USER_TX_STS3r BCMI_MADURA_READ_CL91_USER_TX_STS3r
#define WRITE_CL91_USER_TX_STS3r BCMI_MADURA_WRITE_CL91_USER_TX_STS3r
#define MODIFY_CL91_USER_TX_STS3r BCMI_MADURA_MODIFY_CL91_USER_TX_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_USER_TX_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_USER_TX_STS4
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c04
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Common status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_9_0      AM lock status for service interface lanes 9 through 0.bit[0] - Lane 0.bit[1] - Lane 1.bit[2] - Lane 2.bit[3] - Lane 3.bit[4] - Lane 4.bit[5] - Lane 5.bit[6] - Lane 6.bit[7] - Lane 7.bit[8] - Lane 8.bit[9] - Lane 9.
 */
#define BCMI_MADURA_CL91_USER_TX_STS4r (0x00019c04 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_USER_TX_STS4r_SIZE 4

/*
 * This structure should be used to declare and program CL91_USER_TX_STS4.
 */
typedef union BCMI_MADURA_CL91_USER_TX_STS4r_s {
	uint32_t v[1];
	uint32_t cl91_user_tx_sts4[1];
	uint32_t _cl91_user_tx_sts4;
} BCMI_MADURA_CL91_USER_TX_STS4r_t;

#define BCMI_MADURA_CL91_USER_TX_STS4r_CLR(r) (r).cl91_user_tx_sts4[0] = 0
#define BCMI_MADURA_CL91_USER_TX_STS4r_SET(r,d) (r).cl91_user_tx_sts4[0] = d
#define BCMI_MADURA_CL91_USER_TX_STS4r_GET(r) (r).cl91_user_tx_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_USER_TX_STS4r_AM_LOCK_9_0f_GET(r) (((r).cl91_user_tx_sts4[0]) & 0x3ff)
#define BCMI_MADURA_CL91_USER_TX_STS4r_AM_LOCK_9_0f_SET(r,f) (r).cl91_user_tx_sts4[0]=(((r).cl91_user_tx_sts4[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL91_USER_TX_STS4.
 */
#define BCMI_MADURA_READ_CL91_USER_TX_STS4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_USER_TX_STS4r,_r._cl91_user_tx_sts4)
#define BCMI_MADURA_WRITE_CL91_USER_TX_STS4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_USER_TX_STS4r,_r._cl91_user_tx_sts4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_USER_TX_STS4r BCMI_MADURA_CL91_USER_TX_STS4r
#define CL91_USER_TX_STS4r_SIZE BCMI_MADURA_CL91_USER_TX_STS4r_SIZE
typedef BCMI_MADURA_CL91_USER_TX_STS4r_t CL91_USER_TX_STS4r_t;
#define CL91_USER_TX_STS4r_CLR BCMI_MADURA_CL91_USER_TX_STS4r_CLR
#define CL91_USER_TX_STS4r_SET BCMI_MADURA_CL91_USER_TX_STS4r_SET
#define CL91_USER_TX_STS4r_GET BCMI_MADURA_CL91_USER_TX_STS4r_GET
#define CL91_USER_TX_STS4r_AM_LOCK_9_0f_GET BCMI_MADURA_CL91_USER_TX_STS4r_AM_LOCK_9_0f_GET
#define CL91_USER_TX_STS4r_AM_LOCK_9_0f_SET BCMI_MADURA_CL91_USER_TX_STS4r_AM_LOCK_9_0f_SET
#define READ_CL91_USER_TX_STS4r BCMI_MADURA_READ_CL91_USER_TX_STS4r
#define WRITE_CL91_USER_TX_STS4r BCMI_MADURA_WRITE_CL91_USER_TX_STS4r
#define MODIFY_CL91_USER_TX_STS4r BCMI_MADURA_MODIFY_CL91_USER_TX_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_USER_TX_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL91_USER_TX_STS5
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c05
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Common status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_19_10    AM lock status for service interface lanes 19 through 10.bit[0] - Lane 10.bit[1] - Lane 11.bit[2] - Lane 12.bit[3] - Lane 13.bit[4] - Lane 14.bit[5] - Lane 15.bit[6] - Lane 16.bit[7] - Lane 17.bit[8] - Lane 18.bit[9] - Lane 19.
 */
#define BCMI_MADURA_CL91_USER_TX_STS5r (0x00019c05 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL91_USER_TX_STS5r_SIZE 4

/*
 * This structure should be used to declare and program CL91_USER_TX_STS5.
 */
typedef union BCMI_MADURA_CL91_USER_TX_STS5r_s {
	uint32_t v[1];
	uint32_t cl91_user_tx_sts5[1];
	uint32_t _cl91_user_tx_sts5;
} BCMI_MADURA_CL91_USER_TX_STS5r_t;

#define BCMI_MADURA_CL91_USER_TX_STS5r_CLR(r) (r).cl91_user_tx_sts5[0] = 0
#define BCMI_MADURA_CL91_USER_TX_STS5r_SET(r,d) (r).cl91_user_tx_sts5[0] = d
#define BCMI_MADURA_CL91_USER_TX_STS5r_GET(r) (r).cl91_user_tx_sts5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL91_USER_TX_STS5r_AM_LOCK_19_10f_GET(r) (((r).cl91_user_tx_sts5[0]) & 0x3ff)
#define BCMI_MADURA_CL91_USER_TX_STS5r_AM_LOCK_19_10f_SET(r,f) (r).cl91_user_tx_sts5[0]=(((r).cl91_user_tx_sts5[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL91_USER_TX_STS5.
 */
#define BCMI_MADURA_READ_CL91_USER_TX_STS5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL91_USER_TX_STS5r,_r._cl91_user_tx_sts5)
#define BCMI_MADURA_WRITE_CL91_USER_TX_STS5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL91_USER_TX_STS5r,_r._cl91_user_tx_sts5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL91_USER_TX_STS5r BCMI_MADURA_CL91_USER_TX_STS5r
#define CL91_USER_TX_STS5r_SIZE BCMI_MADURA_CL91_USER_TX_STS5r_SIZE
typedef BCMI_MADURA_CL91_USER_TX_STS5r_t CL91_USER_TX_STS5r_t;
#define CL91_USER_TX_STS5r_CLR BCMI_MADURA_CL91_USER_TX_STS5r_CLR
#define CL91_USER_TX_STS5r_SET BCMI_MADURA_CL91_USER_TX_STS5r_SET
#define CL91_USER_TX_STS5r_GET BCMI_MADURA_CL91_USER_TX_STS5r_GET
#define CL91_USER_TX_STS5r_AM_LOCK_19_10f_GET BCMI_MADURA_CL91_USER_TX_STS5r_AM_LOCK_19_10f_GET
#define CL91_USER_TX_STS5r_AM_LOCK_19_10f_SET BCMI_MADURA_CL91_USER_TX_STS5r_AM_LOCK_19_10f_SET
#define READ_CL91_USER_TX_STS5r BCMI_MADURA_READ_CL91_USER_TX_STS5r
#define WRITE_CL91_USER_TX_STS5r BCMI_MADURA_WRITE_CL91_USER_TX_STS5r
#define MODIFY_CL91_USER_TX_STS5r BCMI_MADURA_MODIFY_CL91_USER_TX_STS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL91_USER_TX_STS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN0_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c06
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_0 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN0_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN0_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN0_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN0_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN0_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN0_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN0_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN0_STSr (0x00019c06 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN0_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN0_STS.
 */
typedef union BCMI_MADURA_LN0_STSr_s {
	uint32_t v[1];
	uint32_t ln0_sts[1];
	uint32_t _ln0_sts;
} BCMI_MADURA_LN0_STSr_t;

#define BCMI_MADURA_LN0_STSr_CLR(r) (r).ln0_sts[0] = 0
#define BCMI_MADURA_LN0_STSr_SET(r,d) (r).ln0_sts[0] = d
#define BCMI_MADURA_LN0_STSr_GET(r) (r).ln0_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCKf_GET(r) ((((r).ln0_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCKf_SET(r,f) (r).ln0_sts[0]=(((r).ln0_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LHf_GET(r) ((((r).ln0_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LHf_SET(r,f) (r).ln0_sts[0]=(((r).ln0_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LLf_GET(r) ((((r).ln0_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LLf_SET(r,f) (r).ln0_sts[0]=(((r).ln0_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN0_STSr_LN0_AM_LOCKf_GET(r) ((((r).ln0_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN0_STSr_LN0_AM_LOCKf_SET(r,f) (r).ln0_sts[0]=(((r).ln0_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LHf_GET(r) ((((r).ln0_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LHf_SET(r,f) (r).ln0_sts[0]=(((r).ln0_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LLf_GET(r) ((((r).ln0_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LLf_SET(r,f) (r).ln0_sts[0]=(((r).ln0_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN0_STSr_LN0_PCSL_LANE_NUMBERf_GET(r) (((r).ln0_sts[0]) & 0x1f)
#define BCMI_MADURA_LN0_STSr_LN0_PCSL_LANE_NUMBERf_SET(r,f) (r).ln0_sts[0]=(((r).ln0_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN0_STS.
 */
#define BCMI_MADURA_READ_LN0_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN0_STSr,_r._ln0_sts)
#define BCMI_MADURA_WRITE_LN0_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN0_STSr,_r._ln0_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN0_STSr BCMI_MADURA_LN0_STSr
#define LN0_STSr_SIZE BCMI_MADURA_LN0_STSr_SIZE
typedef BCMI_MADURA_LN0_STSr_t LN0_STSr_t;
#define LN0_STSr_CLR BCMI_MADURA_LN0_STSr_CLR
#define LN0_STSr_SET BCMI_MADURA_LN0_STSr_SET
#define LN0_STSr_GET BCMI_MADURA_LN0_STSr_GET
#define LN0_STSr_LN0_BLOCK_LOCKf_GET BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCKf_GET
#define LN0_STSr_LN0_BLOCK_LOCKf_SET BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCKf_SET
#define LN0_STSr_LN0_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LHf_GET
#define LN0_STSr_LN0_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LHf_SET
#define LN0_STSr_LN0_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LLf_GET
#define LN0_STSr_LN0_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN0_STSr_LN0_BLOCK_LOCK_LLf_SET
#define LN0_STSr_LN0_AM_LOCKf_GET BCMI_MADURA_LN0_STSr_LN0_AM_LOCKf_GET
#define LN0_STSr_LN0_AM_LOCKf_SET BCMI_MADURA_LN0_STSr_LN0_AM_LOCKf_SET
#define LN0_STSr_LN0_AM_LOCK_LHf_GET BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LHf_GET
#define LN0_STSr_LN0_AM_LOCK_LHf_SET BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LHf_SET
#define LN0_STSr_LN0_AM_LOCK_LLf_GET BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LLf_GET
#define LN0_STSr_LN0_AM_LOCK_LLf_SET BCMI_MADURA_LN0_STSr_LN0_AM_LOCK_LLf_SET
#define LN0_STSr_LN0_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN0_STSr_LN0_PCSL_LANE_NUMBERf_GET
#define LN0_STSr_LN0_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN0_STSr_LN0_PCSL_LANE_NUMBERf_SET
#define READ_LN0_STSr BCMI_MADURA_READ_LN0_STSr
#define WRITE_LN0_STSr BCMI_MADURA_WRITE_LN0_STSr
#define MODIFY_LN0_STSr BCMI_MADURA_MODIFY_LN0_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN0_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN1_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c07
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_1 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN1_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN1_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN1_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN1_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN1_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN1_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN1_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN1_STSr (0x00019c07 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN1_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN1_STS.
 */
typedef union BCMI_MADURA_LN1_STSr_s {
	uint32_t v[1];
	uint32_t ln1_sts[1];
	uint32_t _ln1_sts;
} BCMI_MADURA_LN1_STSr_t;

#define BCMI_MADURA_LN1_STSr_CLR(r) (r).ln1_sts[0] = 0
#define BCMI_MADURA_LN1_STSr_SET(r,d) (r).ln1_sts[0] = d
#define BCMI_MADURA_LN1_STSr_GET(r) (r).ln1_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCKf_GET(r) ((((r).ln1_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCKf_SET(r,f) (r).ln1_sts[0]=(((r).ln1_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LHf_GET(r) ((((r).ln1_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LHf_SET(r,f) (r).ln1_sts[0]=(((r).ln1_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LLf_GET(r) ((((r).ln1_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LLf_SET(r,f) (r).ln1_sts[0]=(((r).ln1_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN1_STSr_LN1_AM_LOCKf_GET(r) ((((r).ln1_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN1_STSr_LN1_AM_LOCKf_SET(r,f) (r).ln1_sts[0]=(((r).ln1_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LHf_GET(r) ((((r).ln1_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LHf_SET(r,f) (r).ln1_sts[0]=(((r).ln1_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LLf_GET(r) ((((r).ln1_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LLf_SET(r,f) (r).ln1_sts[0]=(((r).ln1_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN1_STSr_LN1_PCSL_LANE_NUMBERf_GET(r) (((r).ln1_sts[0]) & 0x1f)
#define BCMI_MADURA_LN1_STSr_LN1_PCSL_LANE_NUMBERf_SET(r,f) (r).ln1_sts[0]=(((r).ln1_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN1_STS.
 */
#define BCMI_MADURA_READ_LN1_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN1_STSr,_r._ln1_sts)
#define BCMI_MADURA_WRITE_LN1_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN1_STSr,_r._ln1_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN1_STSr BCMI_MADURA_LN1_STSr
#define LN1_STSr_SIZE BCMI_MADURA_LN1_STSr_SIZE
typedef BCMI_MADURA_LN1_STSr_t LN1_STSr_t;
#define LN1_STSr_CLR BCMI_MADURA_LN1_STSr_CLR
#define LN1_STSr_SET BCMI_MADURA_LN1_STSr_SET
#define LN1_STSr_GET BCMI_MADURA_LN1_STSr_GET
#define LN1_STSr_LN1_BLOCK_LOCKf_GET BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCKf_GET
#define LN1_STSr_LN1_BLOCK_LOCKf_SET BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCKf_SET
#define LN1_STSr_LN1_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LHf_GET
#define LN1_STSr_LN1_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LHf_SET
#define LN1_STSr_LN1_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LLf_GET
#define LN1_STSr_LN1_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN1_STSr_LN1_BLOCK_LOCK_LLf_SET
#define LN1_STSr_LN1_AM_LOCKf_GET BCMI_MADURA_LN1_STSr_LN1_AM_LOCKf_GET
#define LN1_STSr_LN1_AM_LOCKf_SET BCMI_MADURA_LN1_STSr_LN1_AM_LOCKf_SET
#define LN1_STSr_LN1_AM_LOCK_LHf_GET BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LHf_GET
#define LN1_STSr_LN1_AM_LOCK_LHf_SET BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LHf_SET
#define LN1_STSr_LN1_AM_LOCK_LLf_GET BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LLf_GET
#define LN1_STSr_LN1_AM_LOCK_LLf_SET BCMI_MADURA_LN1_STSr_LN1_AM_LOCK_LLf_SET
#define LN1_STSr_LN1_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN1_STSr_LN1_PCSL_LANE_NUMBERf_GET
#define LN1_STSr_LN1_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN1_STSr_LN1_PCSL_LANE_NUMBERf_SET
#define READ_LN1_STSr BCMI_MADURA_READ_LN1_STSr
#define WRITE_LN1_STSr BCMI_MADURA_WRITE_LN1_STSr
#define MODIFY_LN1_STSr BCMI_MADURA_MODIFY_LN1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN1_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN2_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c08
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_2 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN2_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN2_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN2_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN2_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN2_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN2_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN2_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN2_STSr (0x00019c08 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN2_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN2_STS.
 */
typedef union BCMI_MADURA_LN2_STSr_s {
	uint32_t v[1];
	uint32_t ln2_sts[1];
	uint32_t _ln2_sts;
} BCMI_MADURA_LN2_STSr_t;

#define BCMI_MADURA_LN2_STSr_CLR(r) (r).ln2_sts[0] = 0
#define BCMI_MADURA_LN2_STSr_SET(r,d) (r).ln2_sts[0] = d
#define BCMI_MADURA_LN2_STSr_GET(r) (r).ln2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCKf_GET(r) ((((r).ln2_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCKf_SET(r,f) (r).ln2_sts[0]=(((r).ln2_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LHf_GET(r) ((((r).ln2_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LHf_SET(r,f) (r).ln2_sts[0]=(((r).ln2_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LLf_GET(r) ((((r).ln2_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LLf_SET(r,f) (r).ln2_sts[0]=(((r).ln2_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN2_STSr_LN2_AM_LOCKf_GET(r) ((((r).ln2_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN2_STSr_LN2_AM_LOCKf_SET(r,f) (r).ln2_sts[0]=(((r).ln2_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LHf_GET(r) ((((r).ln2_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LHf_SET(r,f) (r).ln2_sts[0]=(((r).ln2_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LLf_GET(r) ((((r).ln2_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LLf_SET(r,f) (r).ln2_sts[0]=(((r).ln2_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN2_STSr_LN2_PCSL_LANE_NUMBERf_GET(r) (((r).ln2_sts[0]) & 0x1f)
#define BCMI_MADURA_LN2_STSr_LN2_PCSL_LANE_NUMBERf_SET(r,f) (r).ln2_sts[0]=(((r).ln2_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN2_STS.
 */
#define BCMI_MADURA_READ_LN2_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN2_STSr,_r._ln2_sts)
#define BCMI_MADURA_WRITE_LN2_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN2_STSr,_r._ln2_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN2_STSr BCMI_MADURA_LN2_STSr
#define LN2_STSr_SIZE BCMI_MADURA_LN2_STSr_SIZE
typedef BCMI_MADURA_LN2_STSr_t LN2_STSr_t;
#define LN2_STSr_CLR BCMI_MADURA_LN2_STSr_CLR
#define LN2_STSr_SET BCMI_MADURA_LN2_STSr_SET
#define LN2_STSr_GET BCMI_MADURA_LN2_STSr_GET
#define LN2_STSr_LN2_BLOCK_LOCKf_GET BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCKf_GET
#define LN2_STSr_LN2_BLOCK_LOCKf_SET BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCKf_SET
#define LN2_STSr_LN2_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LHf_GET
#define LN2_STSr_LN2_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LHf_SET
#define LN2_STSr_LN2_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LLf_GET
#define LN2_STSr_LN2_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN2_STSr_LN2_BLOCK_LOCK_LLf_SET
#define LN2_STSr_LN2_AM_LOCKf_GET BCMI_MADURA_LN2_STSr_LN2_AM_LOCKf_GET
#define LN2_STSr_LN2_AM_LOCKf_SET BCMI_MADURA_LN2_STSr_LN2_AM_LOCKf_SET
#define LN2_STSr_LN2_AM_LOCK_LHf_GET BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LHf_GET
#define LN2_STSr_LN2_AM_LOCK_LHf_SET BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LHf_SET
#define LN2_STSr_LN2_AM_LOCK_LLf_GET BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LLf_GET
#define LN2_STSr_LN2_AM_LOCK_LLf_SET BCMI_MADURA_LN2_STSr_LN2_AM_LOCK_LLf_SET
#define LN2_STSr_LN2_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN2_STSr_LN2_PCSL_LANE_NUMBERf_GET
#define LN2_STSr_LN2_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN2_STSr_LN2_PCSL_LANE_NUMBERf_SET
#define READ_LN2_STSr BCMI_MADURA_READ_LN2_STSr
#define WRITE_LN2_STSr BCMI_MADURA_WRITE_LN2_STSr
#define MODIFY_LN2_STSr BCMI_MADURA_MODIFY_LN2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN3_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c09
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_3 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN3_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN3_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN3_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN3_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN3_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN3_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN3_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN3_STSr (0x00019c09 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN3_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN3_STS.
 */
typedef union BCMI_MADURA_LN3_STSr_s {
	uint32_t v[1];
	uint32_t ln3_sts[1];
	uint32_t _ln3_sts;
} BCMI_MADURA_LN3_STSr_t;

#define BCMI_MADURA_LN3_STSr_CLR(r) (r).ln3_sts[0] = 0
#define BCMI_MADURA_LN3_STSr_SET(r,d) (r).ln3_sts[0] = d
#define BCMI_MADURA_LN3_STSr_GET(r) (r).ln3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCKf_GET(r) ((((r).ln3_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCKf_SET(r,f) (r).ln3_sts[0]=(((r).ln3_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LHf_GET(r) ((((r).ln3_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LHf_SET(r,f) (r).ln3_sts[0]=(((r).ln3_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LLf_GET(r) ((((r).ln3_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LLf_SET(r,f) (r).ln3_sts[0]=(((r).ln3_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN3_STSr_LN3_AM_LOCKf_GET(r) ((((r).ln3_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN3_STSr_LN3_AM_LOCKf_SET(r,f) (r).ln3_sts[0]=(((r).ln3_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LHf_GET(r) ((((r).ln3_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LHf_SET(r,f) (r).ln3_sts[0]=(((r).ln3_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LLf_GET(r) ((((r).ln3_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LLf_SET(r,f) (r).ln3_sts[0]=(((r).ln3_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN3_STSr_LN3_PCSL_LANE_NUMBERf_GET(r) (((r).ln3_sts[0]) & 0x1f)
#define BCMI_MADURA_LN3_STSr_LN3_PCSL_LANE_NUMBERf_SET(r,f) (r).ln3_sts[0]=(((r).ln3_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN3_STS.
 */
#define BCMI_MADURA_READ_LN3_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN3_STSr,_r._ln3_sts)
#define BCMI_MADURA_WRITE_LN3_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN3_STSr,_r._ln3_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN3_STSr BCMI_MADURA_LN3_STSr
#define LN3_STSr_SIZE BCMI_MADURA_LN3_STSr_SIZE
typedef BCMI_MADURA_LN3_STSr_t LN3_STSr_t;
#define LN3_STSr_CLR BCMI_MADURA_LN3_STSr_CLR
#define LN3_STSr_SET BCMI_MADURA_LN3_STSr_SET
#define LN3_STSr_GET BCMI_MADURA_LN3_STSr_GET
#define LN3_STSr_LN3_BLOCK_LOCKf_GET BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCKf_GET
#define LN3_STSr_LN3_BLOCK_LOCKf_SET BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCKf_SET
#define LN3_STSr_LN3_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LHf_GET
#define LN3_STSr_LN3_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LHf_SET
#define LN3_STSr_LN3_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LLf_GET
#define LN3_STSr_LN3_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN3_STSr_LN3_BLOCK_LOCK_LLf_SET
#define LN3_STSr_LN3_AM_LOCKf_GET BCMI_MADURA_LN3_STSr_LN3_AM_LOCKf_GET
#define LN3_STSr_LN3_AM_LOCKf_SET BCMI_MADURA_LN3_STSr_LN3_AM_LOCKf_SET
#define LN3_STSr_LN3_AM_LOCK_LHf_GET BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LHf_GET
#define LN3_STSr_LN3_AM_LOCK_LHf_SET BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LHf_SET
#define LN3_STSr_LN3_AM_LOCK_LLf_GET BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LLf_GET
#define LN3_STSr_LN3_AM_LOCK_LLf_SET BCMI_MADURA_LN3_STSr_LN3_AM_LOCK_LLf_SET
#define LN3_STSr_LN3_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN3_STSr_LN3_PCSL_LANE_NUMBERf_GET
#define LN3_STSr_LN3_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN3_STSr_LN3_PCSL_LANE_NUMBERf_SET
#define READ_LN3_STSr BCMI_MADURA_READ_LN3_STSr
#define WRITE_LN3_STSr BCMI_MADURA_WRITE_LN3_STSr
#define MODIFY_LN3_STSr BCMI_MADURA_MODIFY_LN3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN4_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c0a
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_4 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN4_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN4_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN4_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN4_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN4_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN4_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN4_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN4_STSr (0x00019c0a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN4_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN4_STS.
 */
typedef union BCMI_MADURA_LN4_STSr_s {
	uint32_t v[1];
	uint32_t ln4_sts[1];
	uint32_t _ln4_sts;
} BCMI_MADURA_LN4_STSr_t;

#define BCMI_MADURA_LN4_STSr_CLR(r) (r).ln4_sts[0] = 0
#define BCMI_MADURA_LN4_STSr_SET(r,d) (r).ln4_sts[0] = d
#define BCMI_MADURA_LN4_STSr_GET(r) (r).ln4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCKf_GET(r) ((((r).ln4_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCKf_SET(r,f) (r).ln4_sts[0]=(((r).ln4_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LHf_GET(r) ((((r).ln4_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LHf_SET(r,f) (r).ln4_sts[0]=(((r).ln4_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LLf_GET(r) ((((r).ln4_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LLf_SET(r,f) (r).ln4_sts[0]=(((r).ln4_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN4_STSr_LN4_AM_LOCKf_GET(r) ((((r).ln4_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN4_STSr_LN4_AM_LOCKf_SET(r,f) (r).ln4_sts[0]=(((r).ln4_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LHf_GET(r) ((((r).ln4_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LHf_SET(r,f) (r).ln4_sts[0]=(((r).ln4_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LLf_GET(r) ((((r).ln4_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LLf_SET(r,f) (r).ln4_sts[0]=(((r).ln4_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN4_STSr_LN4_PCSL_LANE_NUMBERf_GET(r) (((r).ln4_sts[0]) & 0x1f)
#define BCMI_MADURA_LN4_STSr_LN4_PCSL_LANE_NUMBERf_SET(r,f) (r).ln4_sts[0]=(((r).ln4_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN4_STS.
 */
#define BCMI_MADURA_READ_LN4_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN4_STSr,_r._ln4_sts)
#define BCMI_MADURA_WRITE_LN4_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN4_STSr,_r._ln4_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN4_STSr BCMI_MADURA_LN4_STSr
#define LN4_STSr_SIZE BCMI_MADURA_LN4_STSr_SIZE
typedef BCMI_MADURA_LN4_STSr_t LN4_STSr_t;
#define LN4_STSr_CLR BCMI_MADURA_LN4_STSr_CLR
#define LN4_STSr_SET BCMI_MADURA_LN4_STSr_SET
#define LN4_STSr_GET BCMI_MADURA_LN4_STSr_GET
#define LN4_STSr_LN4_BLOCK_LOCKf_GET BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCKf_GET
#define LN4_STSr_LN4_BLOCK_LOCKf_SET BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCKf_SET
#define LN4_STSr_LN4_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LHf_GET
#define LN4_STSr_LN4_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LHf_SET
#define LN4_STSr_LN4_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LLf_GET
#define LN4_STSr_LN4_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN4_STSr_LN4_BLOCK_LOCK_LLf_SET
#define LN4_STSr_LN4_AM_LOCKf_GET BCMI_MADURA_LN4_STSr_LN4_AM_LOCKf_GET
#define LN4_STSr_LN4_AM_LOCKf_SET BCMI_MADURA_LN4_STSr_LN4_AM_LOCKf_SET
#define LN4_STSr_LN4_AM_LOCK_LHf_GET BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LHf_GET
#define LN4_STSr_LN4_AM_LOCK_LHf_SET BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LHf_SET
#define LN4_STSr_LN4_AM_LOCK_LLf_GET BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LLf_GET
#define LN4_STSr_LN4_AM_LOCK_LLf_SET BCMI_MADURA_LN4_STSr_LN4_AM_LOCK_LLf_SET
#define LN4_STSr_LN4_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN4_STSr_LN4_PCSL_LANE_NUMBERf_GET
#define LN4_STSr_LN4_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN4_STSr_LN4_PCSL_LANE_NUMBERf_SET
#define READ_LN4_STSr BCMI_MADURA_READ_LN4_STSr
#define WRITE_LN4_STSr BCMI_MADURA_WRITE_LN4_STSr
#define MODIFY_LN4_STSr BCMI_MADURA_MODIFY_LN4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN5_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c0b
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_5 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN5_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN5_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN5_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN5_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN5_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN5_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN5_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN5_STSr (0x00019c0b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN5_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN5_STS.
 */
typedef union BCMI_MADURA_LN5_STSr_s {
	uint32_t v[1];
	uint32_t ln5_sts[1];
	uint32_t _ln5_sts;
} BCMI_MADURA_LN5_STSr_t;

#define BCMI_MADURA_LN5_STSr_CLR(r) (r).ln5_sts[0] = 0
#define BCMI_MADURA_LN5_STSr_SET(r,d) (r).ln5_sts[0] = d
#define BCMI_MADURA_LN5_STSr_GET(r) (r).ln5_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCKf_GET(r) ((((r).ln5_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCKf_SET(r,f) (r).ln5_sts[0]=(((r).ln5_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LHf_GET(r) ((((r).ln5_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LHf_SET(r,f) (r).ln5_sts[0]=(((r).ln5_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LLf_GET(r) ((((r).ln5_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LLf_SET(r,f) (r).ln5_sts[0]=(((r).ln5_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN5_STSr_LN5_AM_LOCKf_GET(r) ((((r).ln5_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN5_STSr_LN5_AM_LOCKf_SET(r,f) (r).ln5_sts[0]=(((r).ln5_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LHf_GET(r) ((((r).ln5_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LHf_SET(r,f) (r).ln5_sts[0]=(((r).ln5_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LLf_GET(r) ((((r).ln5_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LLf_SET(r,f) (r).ln5_sts[0]=(((r).ln5_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN5_STSr_LN5_PCSL_LANE_NUMBERf_GET(r) (((r).ln5_sts[0]) & 0x1f)
#define BCMI_MADURA_LN5_STSr_LN5_PCSL_LANE_NUMBERf_SET(r,f) (r).ln5_sts[0]=(((r).ln5_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN5_STS.
 */
#define BCMI_MADURA_READ_LN5_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN5_STSr,_r._ln5_sts)
#define BCMI_MADURA_WRITE_LN5_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN5_STSr,_r._ln5_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN5_STSr BCMI_MADURA_LN5_STSr
#define LN5_STSr_SIZE BCMI_MADURA_LN5_STSr_SIZE
typedef BCMI_MADURA_LN5_STSr_t LN5_STSr_t;
#define LN5_STSr_CLR BCMI_MADURA_LN5_STSr_CLR
#define LN5_STSr_SET BCMI_MADURA_LN5_STSr_SET
#define LN5_STSr_GET BCMI_MADURA_LN5_STSr_GET
#define LN5_STSr_LN5_BLOCK_LOCKf_GET BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCKf_GET
#define LN5_STSr_LN5_BLOCK_LOCKf_SET BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCKf_SET
#define LN5_STSr_LN5_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LHf_GET
#define LN5_STSr_LN5_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LHf_SET
#define LN5_STSr_LN5_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LLf_GET
#define LN5_STSr_LN5_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN5_STSr_LN5_BLOCK_LOCK_LLf_SET
#define LN5_STSr_LN5_AM_LOCKf_GET BCMI_MADURA_LN5_STSr_LN5_AM_LOCKf_GET
#define LN5_STSr_LN5_AM_LOCKf_SET BCMI_MADURA_LN5_STSr_LN5_AM_LOCKf_SET
#define LN5_STSr_LN5_AM_LOCK_LHf_GET BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LHf_GET
#define LN5_STSr_LN5_AM_LOCK_LHf_SET BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LHf_SET
#define LN5_STSr_LN5_AM_LOCK_LLf_GET BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LLf_GET
#define LN5_STSr_LN5_AM_LOCK_LLf_SET BCMI_MADURA_LN5_STSr_LN5_AM_LOCK_LLf_SET
#define LN5_STSr_LN5_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN5_STSr_LN5_PCSL_LANE_NUMBERf_GET
#define LN5_STSr_LN5_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN5_STSr_LN5_PCSL_LANE_NUMBERf_SET
#define READ_LN5_STSr BCMI_MADURA_READ_LN5_STSr
#define WRITE_LN5_STSr BCMI_MADURA_WRITE_LN5_STSr
#define MODIFY_LN5_STSr BCMI_MADURA_MODIFY_LN5_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN5_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN6_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c0c
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_6 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN6_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN6_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN6_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN6_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN6_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN6_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN6_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN6_STSr (0x00019c0c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN6_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN6_STS.
 */
typedef union BCMI_MADURA_LN6_STSr_s {
	uint32_t v[1];
	uint32_t ln6_sts[1];
	uint32_t _ln6_sts;
} BCMI_MADURA_LN6_STSr_t;

#define BCMI_MADURA_LN6_STSr_CLR(r) (r).ln6_sts[0] = 0
#define BCMI_MADURA_LN6_STSr_SET(r,d) (r).ln6_sts[0] = d
#define BCMI_MADURA_LN6_STSr_GET(r) (r).ln6_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCKf_GET(r) ((((r).ln6_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCKf_SET(r,f) (r).ln6_sts[0]=(((r).ln6_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LHf_GET(r) ((((r).ln6_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LHf_SET(r,f) (r).ln6_sts[0]=(((r).ln6_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LLf_GET(r) ((((r).ln6_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LLf_SET(r,f) (r).ln6_sts[0]=(((r).ln6_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN6_STSr_LN6_AM_LOCKf_GET(r) ((((r).ln6_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN6_STSr_LN6_AM_LOCKf_SET(r,f) (r).ln6_sts[0]=(((r).ln6_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LHf_GET(r) ((((r).ln6_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LHf_SET(r,f) (r).ln6_sts[0]=(((r).ln6_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LLf_GET(r) ((((r).ln6_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LLf_SET(r,f) (r).ln6_sts[0]=(((r).ln6_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN6_STSr_LN6_PCSL_LANE_NUMBERf_GET(r) (((r).ln6_sts[0]) & 0x1f)
#define BCMI_MADURA_LN6_STSr_LN6_PCSL_LANE_NUMBERf_SET(r,f) (r).ln6_sts[0]=(((r).ln6_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN6_STS.
 */
#define BCMI_MADURA_READ_LN6_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN6_STSr,_r._ln6_sts)
#define BCMI_MADURA_WRITE_LN6_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN6_STSr,_r._ln6_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN6_STSr BCMI_MADURA_LN6_STSr
#define LN6_STSr_SIZE BCMI_MADURA_LN6_STSr_SIZE
typedef BCMI_MADURA_LN6_STSr_t LN6_STSr_t;
#define LN6_STSr_CLR BCMI_MADURA_LN6_STSr_CLR
#define LN6_STSr_SET BCMI_MADURA_LN6_STSr_SET
#define LN6_STSr_GET BCMI_MADURA_LN6_STSr_GET
#define LN6_STSr_LN6_BLOCK_LOCKf_GET BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCKf_GET
#define LN6_STSr_LN6_BLOCK_LOCKf_SET BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCKf_SET
#define LN6_STSr_LN6_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LHf_GET
#define LN6_STSr_LN6_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LHf_SET
#define LN6_STSr_LN6_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LLf_GET
#define LN6_STSr_LN6_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN6_STSr_LN6_BLOCK_LOCK_LLf_SET
#define LN6_STSr_LN6_AM_LOCKf_GET BCMI_MADURA_LN6_STSr_LN6_AM_LOCKf_GET
#define LN6_STSr_LN6_AM_LOCKf_SET BCMI_MADURA_LN6_STSr_LN6_AM_LOCKf_SET
#define LN6_STSr_LN6_AM_LOCK_LHf_GET BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LHf_GET
#define LN6_STSr_LN6_AM_LOCK_LHf_SET BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LHf_SET
#define LN6_STSr_LN6_AM_LOCK_LLf_GET BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LLf_GET
#define LN6_STSr_LN6_AM_LOCK_LLf_SET BCMI_MADURA_LN6_STSr_LN6_AM_LOCK_LLf_SET
#define LN6_STSr_LN6_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN6_STSr_LN6_PCSL_LANE_NUMBERf_GET
#define LN6_STSr_LN6_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN6_STSr_LN6_PCSL_LANE_NUMBERf_SET
#define READ_LN6_STSr BCMI_MADURA_READ_LN6_STSr
#define WRITE_LN6_STSr BCMI_MADURA_WRITE_LN6_STSr
#define MODIFY_LN6_STSr BCMI_MADURA_MODIFY_LN6_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN6_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN7_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c0d
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_7 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN7_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN7_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN7_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN7_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN7_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN7_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN7_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN7_STSr (0x00019c0d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN7_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN7_STS.
 */
typedef union BCMI_MADURA_LN7_STSr_s {
	uint32_t v[1];
	uint32_t ln7_sts[1];
	uint32_t _ln7_sts;
} BCMI_MADURA_LN7_STSr_t;

#define BCMI_MADURA_LN7_STSr_CLR(r) (r).ln7_sts[0] = 0
#define BCMI_MADURA_LN7_STSr_SET(r,d) (r).ln7_sts[0] = d
#define BCMI_MADURA_LN7_STSr_GET(r) (r).ln7_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCKf_GET(r) ((((r).ln7_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCKf_SET(r,f) (r).ln7_sts[0]=(((r).ln7_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LHf_GET(r) ((((r).ln7_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LHf_SET(r,f) (r).ln7_sts[0]=(((r).ln7_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LLf_GET(r) ((((r).ln7_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LLf_SET(r,f) (r).ln7_sts[0]=(((r).ln7_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN7_STSr_LN7_AM_LOCKf_GET(r) ((((r).ln7_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN7_STSr_LN7_AM_LOCKf_SET(r,f) (r).ln7_sts[0]=(((r).ln7_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LHf_GET(r) ((((r).ln7_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LHf_SET(r,f) (r).ln7_sts[0]=(((r).ln7_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LLf_GET(r) ((((r).ln7_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LLf_SET(r,f) (r).ln7_sts[0]=(((r).ln7_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN7_STSr_LN7_PCSL_LANE_NUMBERf_GET(r) (((r).ln7_sts[0]) & 0x1f)
#define BCMI_MADURA_LN7_STSr_LN7_PCSL_LANE_NUMBERf_SET(r,f) (r).ln7_sts[0]=(((r).ln7_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN7_STS.
 */
#define BCMI_MADURA_READ_LN7_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN7_STSr,_r._ln7_sts)
#define BCMI_MADURA_WRITE_LN7_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN7_STSr,_r._ln7_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN7_STSr BCMI_MADURA_LN7_STSr
#define LN7_STSr_SIZE BCMI_MADURA_LN7_STSr_SIZE
typedef BCMI_MADURA_LN7_STSr_t LN7_STSr_t;
#define LN7_STSr_CLR BCMI_MADURA_LN7_STSr_CLR
#define LN7_STSr_SET BCMI_MADURA_LN7_STSr_SET
#define LN7_STSr_GET BCMI_MADURA_LN7_STSr_GET
#define LN7_STSr_LN7_BLOCK_LOCKf_GET BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCKf_GET
#define LN7_STSr_LN7_BLOCK_LOCKf_SET BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCKf_SET
#define LN7_STSr_LN7_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LHf_GET
#define LN7_STSr_LN7_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LHf_SET
#define LN7_STSr_LN7_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LLf_GET
#define LN7_STSr_LN7_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN7_STSr_LN7_BLOCK_LOCK_LLf_SET
#define LN7_STSr_LN7_AM_LOCKf_GET BCMI_MADURA_LN7_STSr_LN7_AM_LOCKf_GET
#define LN7_STSr_LN7_AM_LOCKf_SET BCMI_MADURA_LN7_STSr_LN7_AM_LOCKf_SET
#define LN7_STSr_LN7_AM_LOCK_LHf_GET BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LHf_GET
#define LN7_STSr_LN7_AM_LOCK_LHf_SET BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LHf_SET
#define LN7_STSr_LN7_AM_LOCK_LLf_GET BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LLf_GET
#define LN7_STSr_LN7_AM_LOCK_LLf_SET BCMI_MADURA_LN7_STSr_LN7_AM_LOCK_LLf_SET
#define LN7_STSr_LN7_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN7_STSr_LN7_PCSL_LANE_NUMBERf_GET
#define LN7_STSr_LN7_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN7_STSr_LN7_PCSL_LANE_NUMBERf_SET
#define READ_LN7_STSr BCMI_MADURA_READ_LN7_STSr
#define WRITE_LN7_STSr BCMI_MADURA_WRITE_LN7_STSr
#define MODIFY_LN7_STSr BCMI_MADURA_MODIFY_LN7_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN7_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN8_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c0e
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_8 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN8_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN8_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN8_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN8_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN8_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN8_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN8_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN8_STSr (0x00019c0e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN8_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN8_STS.
 */
typedef union BCMI_MADURA_LN8_STSr_s {
	uint32_t v[1];
	uint32_t ln8_sts[1];
	uint32_t _ln8_sts;
} BCMI_MADURA_LN8_STSr_t;

#define BCMI_MADURA_LN8_STSr_CLR(r) (r).ln8_sts[0] = 0
#define BCMI_MADURA_LN8_STSr_SET(r,d) (r).ln8_sts[0] = d
#define BCMI_MADURA_LN8_STSr_GET(r) (r).ln8_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCKf_GET(r) ((((r).ln8_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCKf_SET(r,f) (r).ln8_sts[0]=(((r).ln8_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LHf_GET(r) ((((r).ln8_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LHf_SET(r,f) (r).ln8_sts[0]=(((r).ln8_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LLf_GET(r) ((((r).ln8_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LLf_SET(r,f) (r).ln8_sts[0]=(((r).ln8_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN8_STSr_LN8_AM_LOCKf_GET(r) ((((r).ln8_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN8_STSr_LN8_AM_LOCKf_SET(r,f) (r).ln8_sts[0]=(((r).ln8_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LHf_GET(r) ((((r).ln8_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LHf_SET(r,f) (r).ln8_sts[0]=(((r).ln8_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LLf_GET(r) ((((r).ln8_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LLf_SET(r,f) (r).ln8_sts[0]=(((r).ln8_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN8_STSr_LN8_PCSL_LANE_NUMBERf_GET(r) (((r).ln8_sts[0]) & 0x1f)
#define BCMI_MADURA_LN8_STSr_LN8_PCSL_LANE_NUMBERf_SET(r,f) (r).ln8_sts[0]=(((r).ln8_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN8_STS.
 */
#define BCMI_MADURA_READ_LN8_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN8_STSr,_r._ln8_sts)
#define BCMI_MADURA_WRITE_LN8_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN8_STSr,_r._ln8_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN8_STSr BCMI_MADURA_LN8_STSr
#define LN8_STSr_SIZE BCMI_MADURA_LN8_STSr_SIZE
typedef BCMI_MADURA_LN8_STSr_t LN8_STSr_t;
#define LN8_STSr_CLR BCMI_MADURA_LN8_STSr_CLR
#define LN8_STSr_SET BCMI_MADURA_LN8_STSr_SET
#define LN8_STSr_GET BCMI_MADURA_LN8_STSr_GET
#define LN8_STSr_LN8_BLOCK_LOCKf_GET BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCKf_GET
#define LN8_STSr_LN8_BLOCK_LOCKf_SET BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCKf_SET
#define LN8_STSr_LN8_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LHf_GET
#define LN8_STSr_LN8_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LHf_SET
#define LN8_STSr_LN8_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LLf_GET
#define LN8_STSr_LN8_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN8_STSr_LN8_BLOCK_LOCK_LLf_SET
#define LN8_STSr_LN8_AM_LOCKf_GET BCMI_MADURA_LN8_STSr_LN8_AM_LOCKf_GET
#define LN8_STSr_LN8_AM_LOCKf_SET BCMI_MADURA_LN8_STSr_LN8_AM_LOCKf_SET
#define LN8_STSr_LN8_AM_LOCK_LHf_GET BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LHf_GET
#define LN8_STSr_LN8_AM_LOCK_LHf_SET BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LHf_SET
#define LN8_STSr_LN8_AM_LOCK_LLf_GET BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LLf_GET
#define LN8_STSr_LN8_AM_LOCK_LLf_SET BCMI_MADURA_LN8_STSr_LN8_AM_LOCK_LLf_SET
#define LN8_STSr_LN8_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN8_STSr_LN8_PCSL_LANE_NUMBERf_GET
#define LN8_STSr_LN8_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN8_STSr_LN8_PCSL_LANE_NUMBERf_SET
#define READ_LN8_STSr BCMI_MADURA_READ_LN8_STSr
#define WRITE_LN8_STSr BCMI_MADURA_WRITE_LN8_STSr
#define MODIFY_LN8_STSr BCMI_MADURA_MODIFY_LN8_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN8_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN9_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c0f
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_9 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN9_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN9_AM_LOCK_LL   Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN9_AM_LOCK_LH   Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN9_AM_LOCK      Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN9_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN9_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN9_BLOCK_LOCK   Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN9_STSr (0x00019c0f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN9_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN9_STS.
 */
typedef union BCMI_MADURA_LN9_STSr_s {
	uint32_t v[1];
	uint32_t ln9_sts[1];
	uint32_t _ln9_sts;
} BCMI_MADURA_LN9_STSr_t;

#define BCMI_MADURA_LN9_STSr_CLR(r) (r).ln9_sts[0] = 0
#define BCMI_MADURA_LN9_STSr_SET(r,d) (r).ln9_sts[0] = d
#define BCMI_MADURA_LN9_STSr_GET(r) (r).ln9_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCKf_GET(r) ((((r).ln9_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCKf_SET(r,f) (r).ln9_sts[0]=(((r).ln9_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LHf_GET(r) ((((r).ln9_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LHf_SET(r,f) (r).ln9_sts[0]=(((r).ln9_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LLf_GET(r) ((((r).ln9_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LLf_SET(r,f) (r).ln9_sts[0]=(((r).ln9_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN9_STSr_LN9_AM_LOCKf_GET(r) ((((r).ln9_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN9_STSr_LN9_AM_LOCKf_SET(r,f) (r).ln9_sts[0]=(((r).ln9_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LHf_GET(r) ((((r).ln9_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LHf_SET(r,f) (r).ln9_sts[0]=(((r).ln9_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LLf_GET(r) ((((r).ln9_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LLf_SET(r,f) (r).ln9_sts[0]=(((r).ln9_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN9_STSr_LN9_PCSL_LANE_NUMBERf_GET(r) (((r).ln9_sts[0]) & 0x1f)
#define BCMI_MADURA_LN9_STSr_LN9_PCSL_LANE_NUMBERf_SET(r,f) (r).ln9_sts[0]=(((r).ln9_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN9_STS.
 */
#define BCMI_MADURA_READ_LN9_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN9_STSr,_r._ln9_sts)
#define BCMI_MADURA_WRITE_LN9_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN9_STSr,_r._ln9_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN9_STSr BCMI_MADURA_LN9_STSr
#define LN9_STSr_SIZE BCMI_MADURA_LN9_STSr_SIZE
typedef BCMI_MADURA_LN9_STSr_t LN9_STSr_t;
#define LN9_STSr_CLR BCMI_MADURA_LN9_STSr_CLR
#define LN9_STSr_SET BCMI_MADURA_LN9_STSr_SET
#define LN9_STSr_GET BCMI_MADURA_LN9_STSr_GET
#define LN9_STSr_LN9_BLOCK_LOCKf_GET BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCKf_GET
#define LN9_STSr_LN9_BLOCK_LOCKf_SET BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCKf_SET
#define LN9_STSr_LN9_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LHf_GET
#define LN9_STSr_LN9_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LHf_SET
#define LN9_STSr_LN9_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LLf_GET
#define LN9_STSr_LN9_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN9_STSr_LN9_BLOCK_LOCK_LLf_SET
#define LN9_STSr_LN9_AM_LOCKf_GET BCMI_MADURA_LN9_STSr_LN9_AM_LOCKf_GET
#define LN9_STSr_LN9_AM_LOCKf_SET BCMI_MADURA_LN9_STSr_LN9_AM_LOCKf_SET
#define LN9_STSr_LN9_AM_LOCK_LHf_GET BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LHf_GET
#define LN9_STSr_LN9_AM_LOCK_LHf_SET BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LHf_SET
#define LN9_STSr_LN9_AM_LOCK_LLf_GET BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LLf_GET
#define LN9_STSr_LN9_AM_LOCK_LLf_SET BCMI_MADURA_LN9_STSr_LN9_AM_LOCK_LLf_SET
#define LN9_STSr_LN9_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN9_STSr_LN9_PCSL_LANE_NUMBERf_GET
#define LN9_STSr_LN9_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN9_STSr_LN9_PCSL_LANE_NUMBERf_SET
#define READ_LN9_STSr BCMI_MADURA_READ_LN9_STSr
#define WRITE_LN9_STSr BCMI_MADURA_WRITE_LN9_STSr
#define MODIFY_LN9_STSr BCMI_MADURA_MODIFY_LN9_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN9_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN10_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c10
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_10 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN10_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN10_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN10_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN10_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN10_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN10_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN10_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN10_STSr (0x00019c10 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN10_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN10_STS.
 */
typedef union BCMI_MADURA_LN10_STSr_s {
	uint32_t v[1];
	uint32_t ln10_sts[1];
	uint32_t _ln10_sts;
} BCMI_MADURA_LN10_STSr_t;

#define BCMI_MADURA_LN10_STSr_CLR(r) (r).ln10_sts[0] = 0
#define BCMI_MADURA_LN10_STSr_SET(r,d) (r).ln10_sts[0] = d
#define BCMI_MADURA_LN10_STSr_GET(r) (r).ln10_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCKf_GET(r) ((((r).ln10_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCKf_SET(r,f) (r).ln10_sts[0]=(((r).ln10_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LHf_GET(r) ((((r).ln10_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LHf_SET(r,f) (r).ln10_sts[0]=(((r).ln10_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LLf_GET(r) ((((r).ln10_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LLf_SET(r,f) (r).ln10_sts[0]=(((r).ln10_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN10_STSr_LN10_AM_LOCKf_GET(r) ((((r).ln10_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN10_STSr_LN10_AM_LOCKf_SET(r,f) (r).ln10_sts[0]=(((r).ln10_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LHf_GET(r) ((((r).ln10_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LHf_SET(r,f) (r).ln10_sts[0]=(((r).ln10_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LLf_GET(r) ((((r).ln10_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LLf_SET(r,f) (r).ln10_sts[0]=(((r).ln10_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN10_STSr_LN10_PCSL_LANE_NUMBERf_GET(r) (((r).ln10_sts[0]) & 0x1f)
#define BCMI_MADURA_LN10_STSr_LN10_PCSL_LANE_NUMBERf_SET(r,f) (r).ln10_sts[0]=(((r).ln10_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN10_STS.
 */
#define BCMI_MADURA_READ_LN10_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN10_STSr,_r._ln10_sts)
#define BCMI_MADURA_WRITE_LN10_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN10_STSr,_r._ln10_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN10_STSr BCMI_MADURA_LN10_STSr
#define LN10_STSr_SIZE BCMI_MADURA_LN10_STSr_SIZE
typedef BCMI_MADURA_LN10_STSr_t LN10_STSr_t;
#define LN10_STSr_CLR BCMI_MADURA_LN10_STSr_CLR
#define LN10_STSr_SET BCMI_MADURA_LN10_STSr_SET
#define LN10_STSr_GET BCMI_MADURA_LN10_STSr_GET
#define LN10_STSr_LN10_BLOCK_LOCKf_GET BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCKf_GET
#define LN10_STSr_LN10_BLOCK_LOCKf_SET BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCKf_SET
#define LN10_STSr_LN10_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LHf_GET
#define LN10_STSr_LN10_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LHf_SET
#define LN10_STSr_LN10_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LLf_GET
#define LN10_STSr_LN10_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN10_STSr_LN10_BLOCK_LOCK_LLf_SET
#define LN10_STSr_LN10_AM_LOCKf_GET BCMI_MADURA_LN10_STSr_LN10_AM_LOCKf_GET
#define LN10_STSr_LN10_AM_LOCKf_SET BCMI_MADURA_LN10_STSr_LN10_AM_LOCKf_SET
#define LN10_STSr_LN10_AM_LOCK_LHf_GET BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LHf_GET
#define LN10_STSr_LN10_AM_LOCK_LHf_SET BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LHf_SET
#define LN10_STSr_LN10_AM_LOCK_LLf_GET BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LLf_GET
#define LN10_STSr_LN10_AM_LOCK_LLf_SET BCMI_MADURA_LN10_STSr_LN10_AM_LOCK_LLf_SET
#define LN10_STSr_LN10_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN10_STSr_LN10_PCSL_LANE_NUMBERf_GET
#define LN10_STSr_LN10_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN10_STSr_LN10_PCSL_LANE_NUMBERf_SET
#define READ_LN10_STSr BCMI_MADURA_READ_LN10_STSr
#define WRITE_LN10_STSr BCMI_MADURA_WRITE_LN10_STSr
#define MODIFY_LN10_STSr BCMI_MADURA_MODIFY_LN10_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN10_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN11_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c11
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_11 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN11_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN11_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN11_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN11_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN11_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN11_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN11_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN11_STSr (0x00019c11 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN11_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN11_STS.
 */
typedef union BCMI_MADURA_LN11_STSr_s {
	uint32_t v[1];
	uint32_t ln11_sts[1];
	uint32_t _ln11_sts;
} BCMI_MADURA_LN11_STSr_t;

#define BCMI_MADURA_LN11_STSr_CLR(r) (r).ln11_sts[0] = 0
#define BCMI_MADURA_LN11_STSr_SET(r,d) (r).ln11_sts[0] = d
#define BCMI_MADURA_LN11_STSr_GET(r) (r).ln11_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCKf_GET(r) ((((r).ln11_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCKf_SET(r,f) (r).ln11_sts[0]=(((r).ln11_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LHf_GET(r) ((((r).ln11_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LHf_SET(r,f) (r).ln11_sts[0]=(((r).ln11_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LLf_GET(r) ((((r).ln11_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LLf_SET(r,f) (r).ln11_sts[0]=(((r).ln11_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN11_STSr_LN11_AM_LOCKf_GET(r) ((((r).ln11_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN11_STSr_LN11_AM_LOCKf_SET(r,f) (r).ln11_sts[0]=(((r).ln11_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LHf_GET(r) ((((r).ln11_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LHf_SET(r,f) (r).ln11_sts[0]=(((r).ln11_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LLf_GET(r) ((((r).ln11_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LLf_SET(r,f) (r).ln11_sts[0]=(((r).ln11_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN11_STSr_LN11_PCSL_LANE_NUMBERf_GET(r) (((r).ln11_sts[0]) & 0x1f)
#define BCMI_MADURA_LN11_STSr_LN11_PCSL_LANE_NUMBERf_SET(r,f) (r).ln11_sts[0]=(((r).ln11_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN11_STS.
 */
#define BCMI_MADURA_READ_LN11_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN11_STSr,_r._ln11_sts)
#define BCMI_MADURA_WRITE_LN11_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN11_STSr,_r._ln11_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN11_STSr BCMI_MADURA_LN11_STSr
#define LN11_STSr_SIZE BCMI_MADURA_LN11_STSr_SIZE
typedef BCMI_MADURA_LN11_STSr_t LN11_STSr_t;
#define LN11_STSr_CLR BCMI_MADURA_LN11_STSr_CLR
#define LN11_STSr_SET BCMI_MADURA_LN11_STSr_SET
#define LN11_STSr_GET BCMI_MADURA_LN11_STSr_GET
#define LN11_STSr_LN11_BLOCK_LOCKf_GET BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCKf_GET
#define LN11_STSr_LN11_BLOCK_LOCKf_SET BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCKf_SET
#define LN11_STSr_LN11_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LHf_GET
#define LN11_STSr_LN11_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LHf_SET
#define LN11_STSr_LN11_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LLf_GET
#define LN11_STSr_LN11_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN11_STSr_LN11_BLOCK_LOCK_LLf_SET
#define LN11_STSr_LN11_AM_LOCKf_GET BCMI_MADURA_LN11_STSr_LN11_AM_LOCKf_GET
#define LN11_STSr_LN11_AM_LOCKf_SET BCMI_MADURA_LN11_STSr_LN11_AM_LOCKf_SET
#define LN11_STSr_LN11_AM_LOCK_LHf_GET BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LHf_GET
#define LN11_STSr_LN11_AM_LOCK_LHf_SET BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LHf_SET
#define LN11_STSr_LN11_AM_LOCK_LLf_GET BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LLf_GET
#define LN11_STSr_LN11_AM_LOCK_LLf_SET BCMI_MADURA_LN11_STSr_LN11_AM_LOCK_LLf_SET
#define LN11_STSr_LN11_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN11_STSr_LN11_PCSL_LANE_NUMBERf_GET
#define LN11_STSr_LN11_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN11_STSr_LN11_PCSL_LANE_NUMBERf_SET
#define READ_LN11_STSr BCMI_MADURA_READ_LN11_STSr
#define WRITE_LN11_STSr BCMI_MADURA_WRITE_LN11_STSr
#define MODIFY_LN11_STSr BCMI_MADURA_MODIFY_LN11_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN11_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN12_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c12
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_12 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN12_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN12_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN12_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN12_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN12_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN12_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN12_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN12_STSr (0x00019c12 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN12_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN12_STS.
 */
typedef union BCMI_MADURA_LN12_STSr_s {
	uint32_t v[1];
	uint32_t ln12_sts[1];
	uint32_t _ln12_sts;
} BCMI_MADURA_LN12_STSr_t;

#define BCMI_MADURA_LN12_STSr_CLR(r) (r).ln12_sts[0] = 0
#define BCMI_MADURA_LN12_STSr_SET(r,d) (r).ln12_sts[0] = d
#define BCMI_MADURA_LN12_STSr_GET(r) (r).ln12_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCKf_GET(r) ((((r).ln12_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCKf_SET(r,f) (r).ln12_sts[0]=(((r).ln12_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LHf_GET(r) ((((r).ln12_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LHf_SET(r,f) (r).ln12_sts[0]=(((r).ln12_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LLf_GET(r) ((((r).ln12_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LLf_SET(r,f) (r).ln12_sts[0]=(((r).ln12_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN12_STSr_LN12_AM_LOCKf_GET(r) ((((r).ln12_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN12_STSr_LN12_AM_LOCKf_SET(r,f) (r).ln12_sts[0]=(((r).ln12_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LHf_GET(r) ((((r).ln12_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LHf_SET(r,f) (r).ln12_sts[0]=(((r).ln12_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LLf_GET(r) ((((r).ln12_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LLf_SET(r,f) (r).ln12_sts[0]=(((r).ln12_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN12_STSr_LN12_PCSL_LANE_NUMBERf_GET(r) (((r).ln12_sts[0]) & 0x1f)
#define BCMI_MADURA_LN12_STSr_LN12_PCSL_LANE_NUMBERf_SET(r,f) (r).ln12_sts[0]=(((r).ln12_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN12_STS.
 */
#define BCMI_MADURA_READ_LN12_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN12_STSr,_r._ln12_sts)
#define BCMI_MADURA_WRITE_LN12_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN12_STSr,_r._ln12_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN12_STSr BCMI_MADURA_LN12_STSr
#define LN12_STSr_SIZE BCMI_MADURA_LN12_STSr_SIZE
typedef BCMI_MADURA_LN12_STSr_t LN12_STSr_t;
#define LN12_STSr_CLR BCMI_MADURA_LN12_STSr_CLR
#define LN12_STSr_SET BCMI_MADURA_LN12_STSr_SET
#define LN12_STSr_GET BCMI_MADURA_LN12_STSr_GET
#define LN12_STSr_LN12_BLOCK_LOCKf_GET BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCKf_GET
#define LN12_STSr_LN12_BLOCK_LOCKf_SET BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCKf_SET
#define LN12_STSr_LN12_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LHf_GET
#define LN12_STSr_LN12_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LHf_SET
#define LN12_STSr_LN12_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LLf_GET
#define LN12_STSr_LN12_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN12_STSr_LN12_BLOCK_LOCK_LLf_SET
#define LN12_STSr_LN12_AM_LOCKf_GET BCMI_MADURA_LN12_STSr_LN12_AM_LOCKf_GET
#define LN12_STSr_LN12_AM_LOCKf_SET BCMI_MADURA_LN12_STSr_LN12_AM_LOCKf_SET
#define LN12_STSr_LN12_AM_LOCK_LHf_GET BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LHf_GET
#define LN12_STSr_LN12_AM_LOCK_LHf_SET BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LHf_SET
#define LN12_STSr_LN12_AM_LOCK_LLf_GET BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LLf_GET
#define LN12_STSr_LN12_AM_LOCK_LLf_SET BCMI_MADURA_LN12_STSr_LN12_AM_LOCK_LLf_SET
#define LN12_STSr_LN12_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN12_STSr_LN12_PCSL_LANE_NUMBERf_GET
#define LN12_STSr_LN12_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN12_STSr_LN12_PCSL_LANE_NUMBERf_SET
#define READ_LN12_STSr BCMI_MADURA_READ_LN12_STSr
#define WRITE_LN12_STSr BCMI_MADURA_WRITE_LN12_STSr
#define MODIFY_LN12_STSr BCMI_MADURA_MODIFY_LN12_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN12_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN13_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c13
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_13 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN13_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN13_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN13_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN13_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN13_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN13_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN13_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN13_STSr (0x00019c13 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN13_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN13_STS.
 */
typedef union BCMI_MADURA_LN13_STSr_s {
	uint32_t v[1];
	uint32_t ln13_sts[1];
	uint32_t _ln13_sts;
} BCMI_MADURA_LN13_STSr_t;

#define BCMI_MADURA_LN13_STSr_CLR(r) (r).ln13_sts[0] = 0
#define BCMI_MADURA_LN13_STSr_SET(r,d) (r).ln13_sts[0] = d
#define BCMI_MADURA_LN13_STSr_GET(r) (r).ln13_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCKf_GET(r) ((((r).ln13_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCKf_SET(r,f) (r).ln13_sts[0]=(((r).ln13_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LHf_GET(r) ((((r).ln13_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LHf_SET(r,f) (r).ln13_sts[0]=(((r).ln13_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LLf_GET(r) ((((r).ln13_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LLf_SET(r,f) (r).ln13_sts[0]=(((r).ln13_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN13_STSr_LN13_AM_LOCKf_GET(r) ((((r).ln13_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN13_STSr_LN13_AM_LOCKf_SET(r,f) (r).ln13_sts[0]=(((r).ln13_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LHf_GET(r) ((((r).ln13_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LHf_SET(r,f) (r).ln13_sts[0]=(((r).ln13_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LLf_GET(r) ((((r).ln13_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LLf_SET(r,f) (r).ln13_sts[0]=(((r).ln13_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN13_STSr_LN13_PCSL_LANE_NUMBERf_GET(r) (((r).ln13_sts[0]) & 0x1f)
#define BCMI_MADURA_LN13_STSr_LN13_PCSL_LANE_NUMBERf_SET(r,f) (r).ln13_sts[0]=(((r).ln13_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN13_STS.
 */
#define BCMI_MADURA_READ_LN13_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN13_STSr,_r._ln13_sts)
#define BCMI_MADURA_WRITE_LN13_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN13_STSr,_r._ln13_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN13_STSr BCMI_MADURA_LN13_STSr
#define LN13_STSr_SIZE BCMI_MADURA_LN13_STSr_SIZE
typedef BCMI_MADURA_LN13_STSr_t LN13_STSr_t;
#define LN13_STSr_CLR BCMI_MADURA_LN13_STSr_CLR
#define LN13_STSr_SET BCMI_MADURA_LN13_STSr_SET
#define LN13_STSr_GET BCMI_MADURA_LN13_STSr_GET
#define LN13_STSr_LN13_BLOCK_LOCKf_GET BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCKf_GET
#define LN13_STSr_LN13_BLOCK_LOCKf_SET BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCKf_SET
#define LN13_STSr_LN13_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LHf_GET
#define LN13_STSr_LN13_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LHf_SET
#define LN13_STSr_LN13_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LLf_GET
#define LN13_STSr_LN13_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN13_STSr_LN13_BLOCK_LOCK_LLf_SET
#define LN13_STSr_LN13_AM_LOCKf_GET BCMI_MADURA_LN13_STSr_LN13_AM_LOCKf_GET
#define LN13_STSr_LN13_AM_LOCKf_SET BCMI_MADURA_LN13_STSr_LN13_AM_LOCKf_SET
#define LN13_STSr_LN13_AM_LOCK_LHf_GET BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LHf_GET
#define LN13_STSr_LN13_AM_LOCK_LHf_SET BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LHf_SET
#define LN13_STSr_LN13_AM_LOCK_LLf_GET BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LLf_GET
#define LN13_STSr_LN13_AM_LOCK_LLf_SET BCMI_MADURA_LN13_STSr_LN13_AM_LOCK_LLf_SET
#define LN13_STSr_LN13_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN13_STSr_LN13_PCSL_LANE_NUMBERf_GET
#define LN13_STSr_LN13_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN13_STSr_LN13_PCSL_LANE_NUMBERf_SET
#define READ_LN13_STSr BCMI_MADURA_READ_LN13_STSr
#define WRITE_LN13_STSr BCMI_MADURA_WRITE_LN13_STSr
#define MODIFY_LN13_STSr BCMI_MADURA_MODIFY_LN13_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN13_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN14_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c14
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_14 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN14_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN14_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN14_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN14_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN14_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN14_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN14_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN14_STSr (0x00019c14 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN14_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN14_STS.
 */
typedef union BCMI_MADURA_LN14_STSr_s {
	uint32_t v[1];
	uint32_t ln14_sts[1];
	uint32_t _ln14_sts;
} BCMI_MADURA_LN14_STSr_t;

#define BCMI_MADURA_LN14_STSr_CLR(r) (r).ln14_sts[0] = 0
#define BCMI_MADURA_LN14_STSr_SET(r,d) (r).ln14_sts[0] = d
#define BCMI_MADURA_LN14_STSr_GET(r) (r).ln14_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCKf_GET(r) ((((r).ln14_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCKf_SET(r,f) (r).ln14_sts[0]=(((r).ln14_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LHf_GET(r) ((((r).ln14_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LHf_SET(r,f) (r).ln14_sts[0]=(((r).ln14_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LLf_GET(r) ((((r).ln14_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LLf_SET(r,f) (r).ln14_sts[0]=(((r).ln14_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN14_STSr_LN14_AM_LOCKf_GET(r) ((((r).ln14_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN14_STSr_LN14_AM_LOCKf_SET(r,f) (r).ln14_sts[0]=(((r).ln14_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LHf_GET(r) ((((r).ln14_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LHf_SET(r,f) (r).ln14_sts[0]=(((r).ln14_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LLf_GET(r) ((((r).ln14_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LLf_SET(r,f) (r).ln14_sts[0]=(((r).ln14_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN14_STSr_LN14_PCSL_LANE_NUMBERf_GET(r) (((r).ln14_sts[0]) & 0x1f)
#define BCMI_MADURA_LN14_STSr_LN14_PCSL_LANE_NUMBERf_SET(r,f) (r).ln14_sts[0]=(((r).ln14_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN14_STS.
 */
#define BCMI_MADURA_READ_LN14_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN14_STSr,_r._ln14_sts)
#define BCMI_MADURA_WRITE_LN14_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN14_STSr,_r._ln14_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN14_STSr BCMI_MADURA_LN14_STSr
#define LN14_STSr_SIZE BCMI_MADURA_LN14_STSr_SIZE
typedef BCMI_MADURA_LN14_STSr_t LN14_STSr_t;
#define LN14_STSr_CLR BCMI_MADURA_LN14_STSr_CLR
#define LN14_STSr_SET BCMI_MADURA_LN14_STSr_SET
#define LN14_STSr_GET BCMI_MADURA_LN14_STSr_GET
#define LN14_STSr_LN14_BLOCK_LOCKf_GET BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCKf_GET
#define LN14_STSr_LN14_BLOCK_LOCKf_SET BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCKf_SET
#define LN14_STSr_LN14_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LHf_GET
#define LN14_STSr_LN14_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LHf_SET
#define LN14_STSr_LN14_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LLf_GET
#define LN14_STSr_LN14_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN14_STSr_LN14_BLOCK_LOCK_LLf_SET
#define LN14_STSr_LN14_AM_LOCKf_GET BCMI_MADURA_LN14_STSr_LN14_AM_LOCKf_GET
#define LN14_STSr_LN14_AM_LOCKf_SET BCMI_MADURA_LN14_STSr_LN14_AM_LOCKf_SET
#define LN14_STSr_LN14_AM_LOCK_LHf_GET BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LHf_GET
#define LN14_STSr_LN14_AM_LOCK_LHf_SET BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LHf_SET
#define LN14_STSr_LN14_AM_LOCK_LLf_GET BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LLf_GET
#define LN14_STSr_LN14_AM_LOCK_LLf_SET BCMI_MADURA_LN14_STSr_LN14_AM_LOCK_LLf_SET
#define LN14_STSr_LN14_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN14_STSr_LN14_PCSL_LANE_NUMBERf_GET
#define LN14_STSr_LN14_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN14_STSr_LN14_PCSL_LANE_NUMBERf_SET
#define READ_LN14_STSr BCMI_MADURA_READ_LN14_STSr
#define WRITE_LN14_STSr BCMI_MADURA_WRITE_LN14_STSr
#define MODIFY_LN14_STSr BCMI_MADURA_MODIFY_LN14_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN14_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN15_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c15
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_15 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN15_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN15_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN15_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN15_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN15_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN15_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN15_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN15_STSr (0x00019c15 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN15_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN15_STS.
 */
typedef union BCMI_MADURA_LN15_STSr_s {
	uint32_t v[1];
	uint32_t ln15_sts[1];
	uint32_t _ln15_sts;
} BCMI_MADURA_LN15_STSr_t;

#define BCMI_MADURA_LN15_STSr_CLR(r) (r).ln15_sts[0] = 0
#define BCMI_MADURA_LN15_STSr_SET(r,d) (r).ln15_sts[0] = d
#define BCMI_MADURA_LN15_STSr_GET(r) (r).ln15_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCKf_GET(r) ((((r).ln15_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCKf_SET(r,f) (r).ln15_sts[0]=(((r).ln15_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LHf_GET(r) ((((r).ln15_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LHf_SET(r,f) (r).ln15_sts[0]=(((r).ln15_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LLf_GET(r) ((((r).ln15_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LLf_SET(r,f) (r).ln15_sts[0]=(((r).ln15_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN15_STSr_LN15_AM_LOCKf_GET(r) ((((r).ln15_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN15_STSr_LN15_AM_LOCKf_SET(r,f) (r).ln15_sts[0]=(((r).ln15_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LHf_GET(r) ((((r).ln15_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LHf_SET(r,f) (r).ln15_sts[0]=(((r).ln15_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LLf_GET(r) ((((r).ln15_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LLf_SET(r,f) (r).ln15_sts[0]=(((r).ln15_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN15_STSr_LN15_PCSL_LANE_NUMBERf_GET(r) (((r).ln15_sts[0]) & 0x1f)
#define BCMI_MADURA_LN15_STSr_LN15_PCSL_LANE_NUMBERf_SET(r,f) (r).ln15_sts[0]=(((r).ln15_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN15_STS.
 */
#define BCMI_MADURA_READ_LN15_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN15_STSr,_r._ln15_sts)
#define BCMI_MADURA_WRITE_LN15_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN15_STSr,_r._ln15_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN15_STSr BCMI_MADURA_LN15_STSr
#define LN15_STSr_SIZE BCMI_MADURA_LN15_STSr_SIZE
typedef BCMI_MADURA_LN15_STSr_t LN15_STSr_t;
#define LN15_STSr_CLR BCMI_MADURA_LN15_STSr_CLR
#define LN15_STSr_SET BCMI_MADURA_LN15_STSr_SET
#define LN15_STSr_GET BCMI_MADURA_LN15_STSr_GET
#define LN15_STSr_LN15_BLOCK_LOCKf_GET BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCKf_GET
#define LN15_STSr_LN15_BLOCK_LOCKf_SET BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCKf_SET
#define LN15_STSr_LN15_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LHf_GET
#define LN15_STSr_LN15_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LHf_SET
#define LN15_STSr_LN15_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LLf_GET
#define LN15_STSr_LN15_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN15_STSr_LN15_BLOCK_LOCK_LLf_SET
#define LN15_STSr_LN15_AM_LOCKf_GET BCMI_MADURA_LN15_STSr_LN15_AM_LOCKf_GET
#define LN15_STSr_LN15_AM_LOCKf_SET BCMI_MADURA_LN15_STSr_LN15_AM_LOCKf_SET
#define LN15_STSr_LN15_AM_LOCK_LHf_GET BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LHf_GET
#define LN15_STSr_LN15_AM_LOCK_LHf_SET BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LHf_SET
#define LN15_STSr_LN15_AM_LOCK_LLf_GET BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LLf_GET
#define LN15_STSr_LN15_AM_LOCK_LLf_SET BCMI_MADURA_LN15_STSr_LN15_AM_LOCK_LLf_SET
#define LN15_STSr_LN15_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN15_STSr_LN15_PCSL_LANE_NUMBERf_GET
#define LN15_STSr_LN15_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN15_STSr_LN15_PCSL_LANE_NUMBERf_SET
#define READ_LN15_STSr BCMI_MADURA_READ_LN15_STSr
#define WRITE_LN15_STSr BCMI_MADURA_WRITE_LN15_STSr
#define MODIFY_LN15_STSr BCMI_MADURA_MODIFY_LN15_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN15_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN16_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c16
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_16 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN16_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN16_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN16_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN16_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN16_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN16_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN16_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN16_STSr (0x00019c16 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN16_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN16_STS.
 */
typedef union BCMI_MADURA_LN16_STSr_s {
	uint32_t v[1];
	uint32_t ln16_sts[1];
	uint32_t _ln16_sts;
} BCMI_MADURA_LN16_STSr_t;

#define BCMI_MADURA_LN16_STSr_CLR(r) (r).ln16_sts[0] = 0
#define BCMI_MADURA_LN16_STSr_SET(r,d) (r).ln16_sts[0] = d
#define BCMI_MADURA_LN16_STSr_GET(r) (r).ln16_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCKf_GET(r) ((((r).ln16_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCKf_SET(r,f) (r).ln16_sts[0]=(((r).ln16_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LHf_GET(r) ((((r).ln16_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LHf_SET(r,f) (r).ln16_sts[0]=(((r).ln16_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LLf_GET(r) ((((r).ln16_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LLf_SET(r,f) (r).ln16_sts[0]=(((r).ln16_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN16_STSr_LN16_AM_LOCKf_GET(r) ((((r).ln16_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN16_STSr_LN16_AM_LOCKf_SET(r,f) (r).ln16_sts[0]=(((r).ln16_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LHf_GET(r) ((((r).ln16_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LHf_SET(r,f) (r).ln16_sts[0]=(((r).ln16_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LLf_GET(r) ((((r).ln16_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LLf_SET(r,f) (r).ln16_sts[0]=(((r).ln16_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN16_STSr_LN16_PCSL_LANE_NUMBERf_GET(r) (((r).ln16_sts[0]) & 0x1f)
#define BCMI_MADURA_LN16_STSr_LN16_PCSL_LANE_NUMBERf_SET(r,f) (r).ln16_sts[0]=(((r).ln16_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN16_STS.
 */
#define BCMI_MADURA_READ_LN16_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN16_STSr,_r._ln16_sts)
#define BCMI_MADURA_WRITE_LN16_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN16_STSr,_r._ln16_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN16_STSr BCMI_MADURA_LN16_STSr
#define LN16_STSr_SIZE BCMI_MADURA_LN16_STSr_SIZE
typedef BCMI_MADURA_LN16_STSr_t LN16_STSr_t;
#define LN16_STSr_CLR BCMI_MADURA_LN16_STSr_CLR
#define LN16_STSr_SET BCMI_MADURA_LN16_STSr_SET
#define LN16_STSr_GET BCMI_MADURA_LN16_STSr_GET
#define LN16_STSr_LN16_BLOCK_LOCKf_GET BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCKf_GET
#define LN16_STSr_LN16_BLOCK_LOCKf_SET BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCKf_SET
#define LN16_STSr_LN16_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LHf_GET
#define LN16_STSr_LN16_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LHf_SET
#define LN16_STSr_LN16_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LLf_GET
#define LN16_STSr_LN16_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN16_STSr_LN16_BLOCK_LOCK_LLf_SET
#define LN16_STSr_LN16_AM_LOCKf_GET BCMI_MADURA_LN16_STSr_LN16_AM_LOCKf_GET
#define LN16_STSr_LN16_AM_LOCKf_SET BCMI_MADURA_LN16_STSr_LN16_AM_LOCKf_SET
#define LN16_STSr_LN16_AM_LOCK_LHf_GET BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LHf_GET
#define LN16_STSr_LN16_AM_LOCK_LHf_SET BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LHf_SET
#define LN16_STSr_LN16_AM_LOCK_LLf_GET BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LLf_GET
#define LN16_STSr_LN16_AM_LOCK_LLf_SET BCMI_MADURA_LN16_STSr_LN16_AM_LOCK_LLf_SET
#define LN16_STSr_LN16_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN16_STSr_LN16_PCSL_LANE_NUMBERf_GET
#define LN16_STSr_LN16_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN16_STSr_LN16_PCSL_LANE_NUMBERf_SET
#define READ_LN16_STSr BCMI_MADURA_READ_LN16_STSr
#define WRITE_LN16_STSr BCMI_MADURA_WRITE_LN16_STSr
#define MODIFY_LN16_STSr BCMI_MADURA_MODIFY_LN16_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN16_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN17_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c17
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_17 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN17_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN17_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN17_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN17_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN17_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN17_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN17_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN17_STSr (0x00019c17 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN17_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN17_STS.
 */
typedef union BCMI_MADURA_LN17_STSr_s {
	uint32_t v[1];
	uint32_t ln17_sts[1];
	uint32_t _ln17_sts;
} BCMI_MADURA_LN17_STSr_t;

#define BCMI_MADURA_LN17_STSr_CLR(r) (r).ln17_sts[0] = 0
#define BCMI_MADURA_LN17_STSr_SET(r,d) (r).ln17_sts[0] = d
#define BCMI_MADURA_LN17_STSr_GET(r) (r).ln17_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCKf_GET(r) ((((r).ln17_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCKf_SET(r,f) (r).ln17_sts[0]=(((r).ln17_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LHf_GET(r) ((((r).ln17_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LHf_SET(r,f) (r).ln17_sts[0]=(((r).ln17_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LLf_GET(r) ((((r).ln17_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LLf_SET(r,f) (r).ln17_sts[0]=(((r).ln17_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN17_STSr_LN17_AM_LOCKf_GET(r) ((((r).ln17_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN17_STSr_LN17_AM_LOCKf_SET(r,f) (r).ln17_sts[0]=(((r).ln17_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LHf_GET(r) ((((r).ln17_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LHf_SET(r,f) (r).ln17_sts[0]=(((r).ln17_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LLf_GET(r) ((((r).ln17_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LLf_SET(r,f) (r).ln17_sts[0]=(((r).ln17_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN17_STSr_LN17_PCSL_LANE_NUMBERf_GET(r) (((r).ln17_sts[0]) & 0x1f)
#define BCMI_MADURA_LN17_STSr_LN17_PCSL_LANE_NUMBERf_SET(r,f) (r).ln17_sts[0]=(((r).ln17_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN17_STS.
 */
#define BCMI_MADURA_READ_LN17_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN17_STSr,_r._ln17_sts)
#define BCMI_MADURA_WRITE_LN17_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN17_STSr,_r._ln17_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN17_STSr BCMI_MADURA_LN17_STSr
#define LN17_STSr_SIZE BCMI_MADURA_LN17_STSr_SIZE
typedef BCMI_MADURA_LN17_STSr_t LN17_STSr_t;
#define LN17_STSr_CLR BCMI_MADURA_LN17_STSr_CLR
#define LN17_STSr_SET BCMI_MADURA_LN17_STSr_SET
#define LN17_STSr_GET BCMI_MADURA_LN17_STSr_GET
#define LN17_STSr_LN17_BLOCK_LOCKf_GET BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCKf_GET
#define LN17_STSr_LN17_BLOCK_LOCKf_SET BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCKf_SET
#define LN17_STSr_LN17_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LHf_GET
#define LN17_STSr_LN17_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LHf_SET
#define LN17_STSr_LN17_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LLf_GET
#define LN17_STSr_LN17_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN17_STSr_LN17_BLOCK_LOCK_LLf_SET
#define LN17_STSr_LN17_AM_LOCKf_GET BCMI_MADURA_LN17_STSr_LN17_AM_LOCKf_GET
#define LN17_STSr_LN17_AM_LOCKf_SET BCMI_MADURA_LN17_STSr_LN17_AM_LOCKf_SET
#define LN17_STSr_LN17_AM_LOCK_LHf_GET BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LHf_GET
#define LN17_STSr_LN17_AM_LOCK_LHf_SET BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LHf_SET
#define LN17_STSr_LN17_AM_LOCK_LLf_GET BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LLf_GET
#define LN17_STSr_LN17_AM_LOCK_LLf_SET BCMI_MADURA_LN17_STSr_LN17_AM_LOCK_LLf_SET
#define LN17_STSr_LN17_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN17_STSr_LN17_PCSL_LANE_NUMBERf_GET
#define LN17_STSr_LN17_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN17_STSr_LN17_PCSL_LANE_NUMBERf_SET
#define READ_LN17_STSr BCMI_MADURA_READ_LN17_STSr
#define WRITE_LN17_STSr BCMI_MADURA_WRITE_LN17_STSr
#define MODIFY_LN17_STSr BCMI_MADURA_MODIFY_LN17_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN17_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN18_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c18
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_18 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN18_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN18_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN18_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN18_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN18_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN18_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN18_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN18_STSr (0x00019c18 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN18_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN18_STS.
 */
typedef union BCMI_MADURA_LN18_STSr_s {
	uint32_t v[1];
	uint32_t ln18_sts[1];
	uint32_t _ln18_sts;
} BCMI_MADURA_LN18_STSr_t;

#define BCMI_MADURA_LN18_STSr_CLR(r) (r).ln18_sts[0] = 0
#define BCMI_MADURA_LN18_STSr_SET(r,d) (r).ln18_sts[0] = d
#define BCMI_MADURA_LN18_STSr_GET(r) (r).ln18_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCKf_GET(r) ((((r).ln18_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCKf_SET(r,f) (r).ln18_sts[0]=(((r).ln18_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LHf_GET(r) ((((r).ln18_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LHf_SET(r,f) (r).ln18_sts[0]=(((r).ln18_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LLf_GET(r) ((((r).ln18_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LLf_SET(r,f) (r).ln18_sts[0]=(((r).ln18_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN18_STSr_LN18_AM_LOCKf_GET(r) ((((r).ln18_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN18_STSr_LN18_AM_LOCKf_SET(r,f) (r).ln18_sts[0]=(((r).ln18_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LHf_GET(r) ((((r).ln18_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LHf_SET(r,f) (r).ln18_sts[0]=(((r).ln18_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LLf_GET(r) ((((r).ln18_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LLf_SET(r,f) (r).ln18_sts[0]=(((r).ln18_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN18_STSr_LN18_PCSL_LANE_NUMBERf_GET(r) (((r).ln18_sts[0]) & 0x1f)
#define BCMI_MADURA_LN18_STSr_LN18_PCSL_LANE_NUMBERf_SET(r,f) (r).ln18_sts[0]=(((r).ln18_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN18_STS.
 */
#define BCMI_MADURA_READ_LN18_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN18_STSr,_r._ln18_sts)
#define BCMI_MADURA_WRITE_LN18_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN18_STSr,_r._ln18_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN18_STSr BCMI_MADURA_LN18_STSr
#define LN18_STSr_SIZE BCMI_MADURA_LN18_STSr_SIZE
typedef BCMI_MADURA_LN18_STSr_t LN18_STSr_t;
#define LN18_STSr_CLR BCMI_MADURA_LN18_STSr_CLR
#define LN18_STSr_SET BCMI_MADURA_LN18_STSr_SET
#define LN18_STSr_GET BCMI_MADURA_LN18_STSr_GET
#define LN18_STSr_LN18_BLOCK_LOCKf_GET BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCKf_GET
#define LN18_STSr_LN18_BLOCK_LOCKf_SET BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCKf_SET
#define LN18_STSr_LN18_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LHf_GET
#define LN18_STSr_LN18_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LHf_SET
#define LN18_STSr_LN18_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LLf_GET
#define LN18_STSr_LN18_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN18_STSr_LN18_BLOCK_LOCK_LLf_SET
#define LN18_STSr_LN18_AM_LOCKf_GET BCMI_MADURA_LN18_STSr_LN18_AM_LOCKf_GET
#define LN18_STSr_LN18_AM_LOCKf_SET BCMI_MADURA_LN18_STSr_LN18_AM_LOCKf_SET
#define LN18_STSr_LN18_AM_LOCK_LHf_GET BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LHf_GET
#define LN18_STSr_LN18_AM_LOCK_LHf_SET BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LHf_SET
#define LN18_STSr_LN18_AM_LOCK_LLf_GET BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LLf_GET
#define LN18_STSr_LN18_AM_LOCK_LLf_SET BCMI_MADURA_LN18_STSr_LN18_AM_LOCK_LLf_SET
#define LN18_STSr_LN18_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN18_STSr_LN18_PCSL_LANE_NUMBERf_GET
#define LN18_STSr_LN18_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN18_STSr_LN18_PCSL_LANE_NUMBERf_SET
#define READ_LN18_STSr BCMI_MADURA_READ_LN18_STSr
#define WRITE_LN18_STSr BCMI_MADURA_WRITE_LN18_STSr
#define MODIFY_LN18_STSr BCMI_MADURA_MODIFY_LN18_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN18_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN19_STS
 * BLOCKS:   CL91_USER_TX
 * REGADDR:  0x9c19
 * DEVAD:    1
 * DESC:     CL91 TX User Register: Lane_19 status.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN19_PCSL_LANE_NUMBER PCS lane number that is coming in on this service interface lane.
 *     LN19_AM_LOCK_LL  Alignment marker lock - Latch low.This bit indicates the latching low status of AM lock signal.
 *     LN19_AM_LOCK_LH  Alignment marker lock - Latch high.This bit indicates the latching high status of AM lock signal.
 *     LN19_AM_LOCK     Alignment marker lock - Live status.This bit indicates the live status of AM lock signal.The AM lock indication is derived from the Alignment marker lock statediagram specified in FIgure 82-11 of CL82.
 *     LN19_BLOCK_LOCK_LL block lock - Latch low.This bit indicates the latching low status of block lock signal.
 *     LN19_BLOCK_LOCK_LH block lock - Latch high.This bit indicates the latching high status of block lock signal.
 *     LN19_BLOCK_LOCK  Block lock - Live status.This bit indicates the live status of block lock signal.The block lock indication is derived from the Block lock statediagram specified in FIgure 82-10 of CL82.
 */
#define BCMI_MADURA_LN19_STSr (0x00019c19 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN19_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN19_STS.
 */
typedef union BCMI_MADURA_LN19_STSr_s {
	uint32_t v[1];
	uint32_t ln19_sts[1];
	uint32_t _ln19_sts;
} BCMI_MADURA_LN19_STSr_t;

#define BCMI_MADURA_LN19_STSr_CLR(r) (r).ln19_sts[0] = 0
#define BCMI_MADURA_LN19_STSr_SET(r,d) (r).ln19_sts[0] = d
#define BCMI_MADURA_LN19_STSr_GET(r) (r).ln19_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCKf_GET(r) ((((r).ln19_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCKf_SET(r,f) (r).ln19_sts[0]=(((r).ln19_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LHf_GET(r) ((((r).ln19_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LHf_SET(r,f) (r).ln19_sts[0]=(((r).ln19_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LLf_GET(r) ((((r).ln19_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LLf_SET(r,f) (r).ln19_sts[0]=(((r).ln19_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_LN19_STSr_LN19_AM_LOCKf_GET(r) ((((r).ln19_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_LN19_STSr_LN19_AM_LOCKf_SET(r,f) (r).ln19_sts[0]=(((r).ln19_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LHf_GET(r) ((((r).ln19_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LHf_SET(r,f) (r).ln19_sts[0]=(((r).ln19_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LLf_GET(r) ((((r).ln19_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LLf_SET(r,f) (r).ln19_sts[0]=(((r).ln19_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_LN19_STSr_LN19_PCSL_LANE_NUMBERf_GET(r) (((r).ln19_sts[0]) & 0x1f)
#define BCMI_MADURA_LN19_STSr_LN19_PCSL_LANE_NUMBERf_SET(r,f) (r).ln19_sts[0]=(((r).ln19_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN19_STS.
 */
#define BCMI_MADURA_READ_LN19_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN19_STSr,_r._ln19_sts)
#define BCMI_MADURA_WRITE_LN19_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN19_STSr,_r._ln19_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN19_STSr BCMI_MADURA_LN19_STSr
#define LN19_STSr_SIZE BCMI_MADURA_LN19_STSr_SIZE
typedef BCMI_MADURA_LN19_STSr_t LN19_STSr_t;
#define LN19_STSr_CLR BCMI_MADURA_LN19_STSr_CLR
#define LN19_STSr_SET BCMI_MADURA_LN19_STSr_SET
#define LN19_STSr_GET BCMI_MADURA_LN19_STSr_GET
#define LN19_STSr_LN19_BLOCK_LOCKf_GET BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCKf_GET
#define LN19_STSr_LN19_BLOCK_LOCKf_SET BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCKf_SET
#define LN19_STSr_LN19_BLOCK_LOCK_LHf_GET BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LHf_GET
#define LN19_STSr_LN19_BLOCK_LOCK_LHf_SET BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LHf_SET
#define LN19_STSr_LN19_BLOCK_LOCK_LLf_GET BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LLf_GET
#define LN19_STSr_LN19_BLOCK_LOCK_LLf_SET BCMI_MADURA_LN19_STSr_LN19_BLOCK_LOCK_LLf_SET
#define LN19_STSr_LN19_AM_LOCKf_GET BCMI_MADURA_LN19_STSr_LN19_AM_LOCKf_GET
#define LN19_STSr_LN19_AM_LOCKf_SET BCMI_MADURA_LN19_STSr_LN19_AM_LOCKf_SET
#define LN19_STSr_LN19_AM_LOCK_LHf_GET BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LHf_GET
#define LN19_STSr_LN19_AM_LOCK_LHf_SET BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LHf_SET
#define LN19_STSr_LN19_AM_LOCK_LLf_GET BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LLf_GET
#define LN19_STSr_LN19_AM_LOCK_LLf_SET BCMI_MADURA_LN19_STSr_LN19_AM_LOCK_LLf_SET
#define LN19_STSr_LN19_PCSL_LANE_NUMBERf_GET BCMI_MADURA_LN19_STSr_LN19_PCSL_LANE_NUMBERf_GET
#define LN19_STSr_LN19_PCSL_LANE_NUMBERf_SET BCMI_MADURA_LN19_STSr_LN19_PCSL_LANE_NUMBERf_SET
#define READ_LN19_STSr BCMI_MADURA_READ_LN19_STSr
#define WRITE_LN19_STSr BCMI_MADURA_WRITE_LN19_STSr
#define MODIFY_LN19_STSr BCMI_MADURA_MODIFY_LN19_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN19_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DP_CTL0
 * BLOCKS:   DP
 * REGADDR:  0xa300
 * DEVAD:    1
 * DESC:     DP Control 0
 * RESETVAL: 0xff03 (65283)
 * ACCESS:   R/W
 * FIELDS:
 *     DP_RSTB          Datapath reset (Active low).These are the main resets for the datapath.bit 0 corresponds to datapath slice 0bit 1 corresponds to datapath slice 12'b11 - default - does not reset anything2'b10 - resets only datapath slice 02'b01 - resets only datapath slice 12'b00 - resets the entire datapathWhen programmed to 2'b00 this will reset the entire datapath logic.This is not self clearing and needs to be programmed to a 2'b11 after reseting..
 *     CL91_EN_0        Enable CL91 (RX and TX) of slice 1
 *     CL91_EN_1        Enable CL91 (RX and TX) of slice 1
 *     AN_AUTO_CL91_0_DIS In autonegotiated ports of 100GKR4/CR4, FEC block is automatically enabled. By programming this bit to 1, this feature can be disabled for FEC engine corresponding to line lanes 4-7This is intended for debug
 *     AN_AUTO_CL91_1_DIS In autonegotiated ports of 100GKR4/CR4, FEC block is automatically enabled. By programming this bit to 1, this feature can be disabled for FEC engine corresponding to line lanes 0-3This is intended for debug
 *     LANE_DP_RSTB     Lane reset (Active low).These are the main resets for the datapath.8'hFE - resets slice 0 lane 08'hFD - resets slice 0 lane 18'hFB - resets slice 0 lane 28'hF7 - resets slice 0 lane 38'hEF - resets slice 1 lane 08'hDF - resets slice 1 lane 18'hBF - resets slice 1 lane 28'h7F - resets slice 1 lane 38'hFF - default - does not reset anything8'hF0 - resets lanes in slice 08'h0F - resets lanes in slice 18'h00 - resets all lanesWhen programmed to 8'h00 this will reset all lanes.This is not self clearing and needs to be programmed to a 8'hFF after reseting..
 */
#define BCMI_MADURA_DP_CTL0r (0x0001a300 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DP_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DP_CTL0.
 */
typedef union BCMI_MADURA_DP_CTL0r_s {
	uint32_t v[1];
	uint32_t dp_ctl0[1];
	uint32_t _dp_ctl0;
} BCMI_MADURA_DP_CTL0r_t;

#define BCMI_MADURA_DP_CTL0r_CLR(r) (r).dp_ctl0[0] = 0
#define BCMI_MADURA_DP_CTL0r_SET(r,d) (r).dp_ctl0[0] = d
#define BCMI_MADURA_DP_CTL0r_GET(r) (r).dp_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DP_CTL0r_LANE_DP_RSTBf_GET(r) ((((r).dp_ctl0[0]) >> 8) & 0xff)
#define BCMI_MADURA_DP_CTL0r_LANE_DP_RSTBf_SET(r,f) (r).dp_ctl0[0]=(((r).dp_ctl0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_1_DISf_GET(r) ((((r).dp_ctl0[0]) >> 7) & 0x1)
#define BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_1_DISf_SET(r,f) (r).dp_ctl0[0]=(((r).dp_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_0_DISf_GET(r) ((((r).dp_ctl0[0]) >> 6) & 0x1)
#define BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_0_DISf_SET(r,f) (r).dp_ctl0[0]=(((r).dp_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DP_CTL0r_CL91_EN_1f_GET(r) ((((r).dp_ctl0[0]) >> 5) & 0x1)
#define BCMI_MADURA_DP_CTL0r_CL91_EN_1f_SET(r,f) (r).dp_ctl0[0]=(((r).dp_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DP_CTL0r_CL91_EN_0f_GET(r) ((((r).dp_ctl0[0]) >> 4) & 0x1)
#define BCMI_MADURA_DP_CTL0r_CL91_EN_0f_SET(r,f) (r).dp_ctl0[0]=(((r).dp_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DP_CTL0r_DP_RSTBf_GET(r) (((r).dp_ctl0[0]) & 0x3)
#define BCMI_MADURA_DP_CTL0r_DP_RSTBf_SET(r,f) (r).dp_ctl0[0]=(((r).dp_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DP_CTL0.
 */
#define BCMI_MADURA_READ_DP_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DP_CTL0r,_r._dp_ctl0)
#define BCMI_MADURA_WRITE_DP_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DP_CTL0r,_r._dp_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DP_CTL0r BCMI_MADURA_DP_CTL0r
#define DP_CTL0r_SIZE BCMI_MADURA_DP_CTL0r_SIZE
typedef BCMI_MADURA_DP_CTL0r_t DP_CTL0r_t;
#define DP_CTL0r_CLR BCMI_MADURA_DP_CTL0r_CLR
#define DP_CTL0r_SET BCMI_MADURA_DP_CTL0r_SET
#define DP_CTL0r_GET BCMI_MADURA_DP_CTL0r_GET
#define DP_CTL0r_LANE_DP_RSTBf_GET BCMI_MADURA_DP_CTL0r_LANE_DP_RSTBf_GET
#define DP_CTL0r_LANE_DP_RSTBf_SET BCMI_MADURA_DP_CTL0r_LANE_DP_RSTBf_SET
#define DP_CTL0r_AN_AUTO_CL91_1_DISf_GET BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_1_DISf_GET
#define DP_CTL0r_AN_AUTO_CL91_1_DISf_SET BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_1_DISf_SET
#define DP_CTL0r_AN_AUTO_CL91_0_DISf_GET BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_0_DISf_GET
#define DP_CTL0r_AN_AUTO_CL91_0_DISf_SET BCMI_MADURA_DP_CTL0r_AN_AUTO_CL91_0_DISf_SET
#define DP_CTL0r_CL91_EN_1f_GET BCMI_MADURA_DP_CTL0r_CL91_EN_1f_GET
#define DP_CTL0r_CL91_EN_1f_SET BCMI_MADURA_DP_CTL0r_CL91_EN_1f_SET
#define DP_CTL0r_CL91_EN_0f_GET BCMI_MADURA_DP_CTL0r_CL91_EN_0f_GET
#define DP_CTL0r_CL91_EN_0f_SET BCMI_MADURA_DP_CTL0r_CL91_EN_0f_SET
#define DP_CTL0r_DP_RSTBf_GET BCMI_MADURA_DP_CTL0r_DP_RSTBf_GET
#define DP_CTL0r_DP_RSTBf_SET BCMI_MADURA_DP_CTL0r_DP_RSTBf_SET
#define READ_DP_CTL0r BCMI_MADURA_READ_DP_CTL0r
#define WRITE_DP_CTL0r BCMI_MADURA_WRITE_DP_CTL0r
#define MODIFY_DP_CTL0r BCMI_MADURA_MODIFY_DP_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DP_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P0_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa310
 * DEVAD:    1
 * DESC:     Port 0 mode configuration
 * RESETVAL: 0x8038 (32824)
 * ACCESS:   R/W
 * FIELDS:
 *     P0_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P0_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P0_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P0_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P0_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P0_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P0_MODE_CTLr (0x0001a310 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P0_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P0_MODE_CTL.
 */
typedef union BCMI_MADURA_P0_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p0_mode_ctl[1];
	uint32_t _p0_mode_ctl;
} BCMI_MADURA_P0_MODE_CTLr_t;

#define BCMI_MADURA_P0_MODE_CTLr_CLR(r) (r).p0_mode_ctl[0] = 0
#define BCMI_MADURA_P0_MODE_CTLr_SET(r,d) (r).p0_mode_ctl[0] = d
#define BCMI_MADURA_P0_MODE_CTLr_GET(r) (r).p0_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P0_MODE_CTLr_P0_PVALIDf_GET(r) ((((r).p0_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P0_MODE_CTLr_P0_PVALIDf_SET(r,f) (r).p0_mode_ctl[0]=(((r).p0_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P0_MODE_CTLr_P0_UDMSf_GET(r) ((((r).p0_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P0_MODE_CTLr_P0_UDMSf_SET(r,f) (r).p0_mode_ctl[0]=(((r).p0_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P0_MODE_CTLr_P0_SALf_GET(r) ((((r).p0_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P0_MODE_CTLr_P0_SALf_SET(r,f) (r).p0_mode_ctl[0]=(((r).p0_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P0_MODE_CTLr_P0_DPTf_GET(r) ((((r).p0_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P0_MODE_CTLr_P0_DPTf_SET(r,f) (r).p0_mode_ctl[0]=(((r).p0_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P0_MODE_CTLr_P0_LALf_GET(r) ((((r).p0_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P0_MODE_CTLr_P0_LALf_SET(r,f) (r).p0_mode_ctl[0]=(((r).p0_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P0_MODE_CTLr_P0_MINDEXf_GET(r) (((r).p0_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P0_MODE_CTLr_P0_MINDEXf_SET(r,f) (r).p0_mode_ctl[0]=(((r).p0_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P0_MODE_CTL.
 */
#define BCMI_MADURA_READ_P0_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P0_MODE_CTLr,_r._p0_mode_ctl)
#define BCMI_MADURA_WRITE_P0_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P0_MODE_CTLr,_r._p0_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P0_MODE_CTLr BCMI_MADURA_P0_MODE_CTLr
#define P0_MODE_CTLr_SIZE BCMI_MADURA_P0_MODE_CTLr_SIZE
typedef BCMI_MADURA_P0_MODE_CTLr_t P0_MODE_CTLr_t;
#define P0_MODE_CTLr_CLR BCMI_MADURA_P0_MODE_CTLr_CLR
#define P0_MODE_CTLr_SET BCMI_MADURA_P0_MODE_CTLr_SET
#define P0_MODE_CTLr_GET BCMI_MADURA_P0_MODE_CTLr_GET
#define P0_MODE_CTLr_P0_PVALIDf_GET BCMI_MADURA_P0_MODE_CTLr_P0_PVALIDf_GET
#define P0_MODE_CTLr_P0_PVALIDf_SET BCMI_MADURA_P0_MODE_CTLr_P0_PVALIDf_SET
#define P0_MODE_CTLr_P0_UDMSf_GET BCMI_MADURA_P0_MODE_CTLr_P0_UDMSf_GET
#define P0_MODE_CTLr_P0_UDMSf_SET BCMI_MADURA_P0_MODE_CTLr_P0_UDMSf_SET
#define P0_MODE_CTLr_P0_SALf_GET BCMI_MADURA_P0_MODE_CTLr_P0_SALf_GET
#define P0_MODE_CTLr_P0_SALf_SET BCMI_MADURA_P0_MODE_CTLr_P0_SALf_SET
#define P0_MODE_CTLr_P0_DPTf_GET BCMI_MADURA_P0_MODE_CTLr_P0_DPTf_GET
#define P0_MODE_CTLr_P0_DPTf_SET BCMI_MADURA_P0_MODE_CTLr_P0_DPTf_SET
#define P0_MODE_CTLr_P0_LALf_GET BCMI_MADURA_P0_MODE_CTLr_P0_LALf_GET
#define P0_MODE_CTLr_P0_LALf_SET BCMI_MADURA_P0_MODE_CTLr_P0_LALf_SET
#define P0_MODE_CTLr_P0_MINDEXf_GET BCMI_MADURA_P0_MODE_CTLr_P0_MINDEXf_GET
#define P0_MODE_CTLr_P0_MINDEXf_SET BCMI_MADURA_P0_MODE_CTLr_P0_MINDEXf_SET
#define READ_P0_MODE_CTLr BCMI_MADURA_READ_P0_MODE_CTLr
#define WRITE_P0_MODE_CTLr BCMI_MADURA_WRITE_P0_MODE_CTLr
#define MODIFY_P0_MODE_CTLr BCMI_MADURA_MODIFY_P0_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P0_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P1_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa311
 * DEVAD:    1
 * DESC:     Port 1 mode configuration
 * RESETVAL: 0x8039 (32825)
 * ACCESS:   R/W
 * FIELDS:
 *     P1_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P1_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P1_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P1_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P1_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P1_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P1_MODE_CTLr (0x0001a311 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P1_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P1_MODE_CTL.
 */
typedef union BCMI_MADURA_P1_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p1_mode_ctl[1];
	uint32_t _p1_mode_ctl;
} BCMI_MADURA_P1_MODE_CTLr_t;

#define BCMI_MADURA_P1_MODE_CTLr_CLR(r) (r).p1_mode_ctl[0] = 0
#define BCMI_MADURA_P1_MODE_CTLr_SET(r,d) (r).p1_mode_ctl[0] = d
#define BCMI_MADURA_P1_MODE_CTLr_GET(r) (r).p1_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P1_MODE_CTLr_P1_PVALIDf_GET(r) ((((r).p1_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P1_MODE_CTLr_P1_PVALIDf_SET(r,f) (r).p1_mode_ctl[0]=(((r).p1_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P1_MODE_CTLr_P1_UDMSf_GET(r) ((((r).p1_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P1_MODE_CTLr_P1_UDMSf_SET(r,f) (r).p1_mode_ctl[0]=(((r).p1_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P1_MODE_CTLr_P1_SALf_GET(r) ((((r).p1_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P1_MODE_CTLr_P1_SALf_SET(r,f) (r).p1_mode_ctl[0]=(((r).p1_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P1_MODE_CTLr_P1_DPTf_GET(r) ((((r).p1_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P1_MODE_CTLr_P1_DPTf_SET(r,f) (r).p1_mode_ctl[0]=(((r).p1_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P1_MODE_CTLr_P1_LALf_GET(r) ((((r).p1_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P1_MODE_CTLr_P1_LALf_SET(r,f) (r).p1_mode_ctl[0]=(((r).p1_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P1_MODE_CTLr_P1_MINDEXf_GET(r) (((r).p1_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P1_MODE_CTLr_P1_MINDEXf_SET(r,f) (r).p1_mode_ctl[0]=(((r).p1_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P1_MODE_CTL.
 */
#define BCMI_MADURA_READ_P1_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P1_MODE_CTLr,_r._p1_mode_ctl)
#define BCMI_MADURA_WRITE_P1_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P1_MODE_CTLr,_r._p1_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P1_MODE_CTLr BCMI_MADURA_P1_MODE_CTLr
#define P1_MODE_CTLr_SIZE BCMI_MADURA_P1_MODE_CTLr_SIZE
typedef BCMI_MADURA_P1_MODE_CTLr_t P1_MODE_CTLr_t;
#define P1_MODE_CTLr_CLR BCMI_MADURA_P1_MODE_CTLr_CLR
#define P1_MODE_CTLr_SET BCMI_MADURA_P1_MODE_CTLr_SET
#define P1_MODE_CTLr_GET BCMI_MADURA_P1_MODE_CTLr_GET
#define P1_MODE_CTLr_P1_PVALIDf_GET BCMI_MADURA_P1_MODE_CTLr_P1_PVALIDf_GET
#define P1_MODE_CTLr_P1_PVALIDf_SET BCMI_MADURA_P1_MODE_CTLr_P1_PVALIDf_SET
#define P1_MODE_CTLr_P1_UDMSf_GET BCMI_MADURA_P1_MODE_CTLr_P1_UDMSf_GET
#define P1_MODE_CTLr_P1_UDMSf_SET BCMI_MADURA_P1_MODE_CTLr_P1_UDMSf_SET
#define P1_MODE_CTLr_P1_SALf_GET BCMI_MADURA_P1_MODE_CTLr_P1_SALf_GET
#define P1_MODE_CTLr_P1_SALf_SET BCMI_MADURA_P1_MODE_CTLr_P1_SALf_SET
#define P1_MODE_CTLr_P1_DPTf_GET BCMI_MADURA_P1_MODE_CTLr_P1_DPTf_GET
#define P1_MODE_CTLr_P1_DPTf_SET BCMI_MADURA_P1_MODE_CTLr_P1_DPTf_SET
#define P1_MODE_CTLr_P1_LALf_GET BCMI_MADURA_P1_MODE_CTLr_P1_LALf_GET
#define P1_MODE_CTLr_P1_LALf_SET BCMI_MADURA_P1_MODE_CTLr_P1_LALf_SET
#define P1_MODE_CTLr_P1_MINDEXf_GET BCMI_MADURA_P1_MODE_CTLr_P1_MINDEXf_GET
#define P1_MODE_CTLr_P1_MINDEXf_SET BCMI_MADURA_P1_MODE_CTLr_P1_MINDEXf_SET
#define READ_P1_MODE_CTLr BCMI_MADURA_READ_P1_MODE_CTLr
#define WRITE_P1_MODE_CTLr BCMI_MADURA_WRITE_P1_MODE_CTLr
#define MODIFY_P1_MODE_CTLr BCMI_MADURA_MODIFY_P1_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P1_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P2_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa312
 * DEVAD:    1
 * DESC:     Port 2 mode configuration
 * RESETVAL: 0x1a (26)
 * ACCESS:   R/W
 * FIELDS:
 *     P2_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P2_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P2_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P2_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P2_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P2_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P2_MODE_CTLr (0x0001a312 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P2_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P2_MODE_CTL.
 */
typedef union BCMI_MADURA_P2_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p2_mode_ctl[1];
	uint32_t _p2_mode_ctl;
} BCMI_MADURA_P2_MODE_CTLr_t;

#define BCMI_MADURA_P2_MODE_CTLr_CLR(r) (r).p2_mode_ctl[0] = 0
#define BCMI_MADURA_P2_MODE_CTLr_SET(r,d) (r).p2_mode_ctl[0] = d
#define BCMI_MADURA_P2_MODE_CTLr_GET(r) (r).p2_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P2_MODE_CTLr_P2_PVALIDf_GET(r) ((((r).p2_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P2_MODE_CTLr_P2_PVALIDf_SET(r,f) (r).p2_mode_ctl[0]=(((r).p2_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P2_MODE_CTLr_P2_UDMSf_GET(r) ((((r).p2_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P2_MODE_CTLr_P2_UDMSf_SET(r,f) (r).p2_mode_ctl[0]=(((r).p2_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P2_MODE_CTLr_P2_SALf_GET(r) ((((r).p2_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P2_MODE_CTLr_P2_SALf_SET(r,f) (r).p2_mode_ctl[0]=(((r).p2_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P2_MODE_CTLr_P2_DPTf_GET(r) ((((r).p2_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P2_MODE_CTLr_P2_DPTf_SET(r,f) (r).p2_mode_ctl[0]=(((r).p2_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P2_MODE_CTLr_P2_LALf_GET(r) ((((r).p2_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P2_MODE_CTLr_P2_LALf_SET(r,f) (r).p2_mode_ctl[0]=(((r).p2_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P2_MODE_CTLr_P2_MINDEXf_GET(r) (((r).p2_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P2_MODE_CTLr_P2_MINDEXf_SET(r,f) (r).p2_mode_ctl[0]=(((r).p2_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P2_MODE_CTL.
 */
#define BCMI_MADURA_READ_P2_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P2_MODE_CTLr,_r._p2_mode_ctl)
#define BCMI_MADURA_WRITE_P2_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P2_MODE_CTLr,_r._p2_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P2_MODE_CTLr BCMI_MADURA_P2_MODE_CTLr
#define P2_MODE_CTLr_SIZE BCMI_MADURA_P2_MODE_CTLr_SIZE
typedef BCMI_MADURA_P2_MODE_CTLr_t P2_MODE_CTLr_t;
#define P2_MODE_CTLr_CLR BCMI_MADURA_P2_MODE_CTLr_CLR
#define P2_MODE_CTLr_SET BCMI_MADURA_P2_MODE_CTLr_SET
#define P2_MODE_CTLr_GET BCMI_MADURA_P2_MODE_CTLr_GET
#define P2_MODE_CTLr_P2_PVALIDf_GET BCMI_MADURA_P2_MODE_CTLr_P2_PVALIDf_GET
#define P2_MODE_CTLr_P2_PVALIDf_SET BCMI_MADURA_P2_MODE_CTLr_P2_PVALIDf_SET
#define P2_MODE_CTLr_P2_UDMSf_GET BCMI_MADURA_P2_MODE_CTLr_P2_UDMSf_GET
#define P2_MODE_CTLr_P2_UDMSf_SET BCMI_MADURA_P2_MODE_CTLr_P2_UDMSf_SET
#define P2_MODE_CTLr_P2_SALf_GET BCMI_MADURA_P2_MODE_CTLr_P2_SALf_GET
#define P2_MODE_CTLr_P2_SALf_SET BCMI_MADURA_P2_MODE_CTLr_P2_SALf_SET
#define P2_MODE_CTLr_P2_DPTf_GET BCMI_MADURA_P2_MODE_CTLr_P2_DPTf_GET
#define P2_MODE_CTLr_P2_DPTf_SET BCMI_MADURA_P2_MODE_CTLr_P2_DPTf_SET
#define P2_MODE_CTLr_P2_LALf_GET BCMI_MADURA_P2_MODE_CTLr_P2_LALf_GET
#define P2_MODE_CTLr_P2_LALf_SET BCMI_MADURA_P2_MODE_CTLr_P2_LALf_SET
#define P2_MODE_CTLr_P2_MINDEXf_GET BCMI_MADURA_P2_MODE_CTLr_P2_MINDEXf_GET
#define P2_MODE_CTLr_P2_MINDEXf_SET BCMI_MADURA_P2_MODE_CTLr_P2_MINDEXf_SET
#define READ_P2_MODE_CTLr BCMI_MADURA_READ_P2_MODE_CTLr
#define WRITE_P2_MODE_CTLr BCMI_MADURA_WRITE_P2_MODE_CTLr
#define MODIFY_P2_MODE_CTLr BCMI_MADURA_MODIFY_P2_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P2_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P3_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa313
 * DEVAD:    1
 * DESC:     Port 3 mode configuration
 * RESETVAL: 0x1a (26)
 * ACCESS:   R/W
 * FIELDS:
 *     P3_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P3_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P3_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P3_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P3_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P3_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P3_MODE_CTLr (0x0001a313 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P3_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P3_MODE_CTL.
 */
typedef union BCMI_MADURA_P3_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p3_mode_ctl[1];
	uint32_t _p3_mode_ctl;
} BCMI_MADURA_P3_MODE_CTLr_t;

#define BCMI_MADURA_P3_MODE_CTLr_CLR(r) (r).p3_mode_ctl[0] = 0
#define BCMI_MADURA_P3_MODE_CTLr_SET(r,d) (r).p3_mode_ctl[0] = d
#define BCMI_MADURA_P3_MODE_CTLr_GET(r) (r).p3_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P3_MODE_CTLr_P3_PVALIDf_GET(r) ((((r).p3_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P3_MODE_CTLr_P3_PVALIDf_SET(r,f) (r).p3_mode_ctl[0]=(((r).p3_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P3_MODE_CTLr_P3_UDMSf_GET(r) ((((r).p3_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P3_MODE_CTLr_P3_UDMSf_SET(r,f) (r).p3_mode_ctl[0]=(((r).p3_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P3_MODE_CTLr_P3_SALf_GET(r) ((((r).p3_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P3_MODE_CTLr_P3_SALf_SET(r,f) (r).p3_mode_ctl[0]=(((r).p3_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P3_MODE_CTLr_P3_DPTf_GET(r) ((((r).p3_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P3_MODE_CTLr_P3_DPTf_SET(r,f) (r).p3_mode_ctl[0]=(((r).p3_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P3_MODE_CTLr_P3_LALf_GET(r) ((((r).p3_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P3_MODE_CTLr_P3_LALf_SET(r,f) (r).p3_mode_ctl[0]=(((r).p3_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P3_MODE_CTLr_P3_MINDEXf_GET(r) (((r).p3_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P3_MODE_CTLr_P3_MINDEXf_SET(r,f) (r).p3_mode_ctl[0]=(((r).p3_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P3_MODE_CTL.
 */
#define BCMI_MADURA_READ_P3_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P3_MODE_CTLr,_r._p3_mode_ctl)
#define BCMI_MADURA_WRITE_P3_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P3_MODE_CTLr,_r._p3_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P3_MODE_CTLr BCMI_MADURA_P3_MODE_CTLr
#define P3_MODE_CTLr_SIZE BCMI_MADURA_P3_MODE_CTLr_SIZE
typedef BCMI_MADURA_P3_MODE_CTLr_t P3_MODE_CTLr_t;
#define P3_MODE_CTLr_CLR BCMI_MADURA_P3_MODE_CTLr_CLR
#define P3_MODE_CTLr_SET BCMI_MADURA_P3_MODE_CTLr_SET
#define P3_MODE_CTLr_GET BCMI_MADURA_P3_MODE_CTLr_GET
#define P3_MODE_CTLr_P3_PVALIDf_GET BCMI_MADURA_P3_MODE_CTLr_P3_PVALIDf_GET
#define P3_MODE_CTLr_P3_PVALIDf_SET BCMI_MADURA_P3_MODE_CTLr_P3_PVALIDf_SET
#define P3_MODE_CTLr_P3_UDMSf_GET BCMI_MADURA_P3_MODE_CTLr_P3_UDMSf_GET
#define P3_MODE_CTLr_P3_UDMSf_SET BCMI_MADURA_P3_MODE_CTLr_P3_UDMSf_SET
#define P3_MODE_CTLr_P3_SALf_GET BCMI_MADURA_P3_MODE_CTLr_P3_SALf_GET
#define P3_MODE_CTLr_P3_SALf_SET BCMI_MADURA_P3_MODE_CTLr_P3_SALf_SET
#define P3_MODE_CTLr_P3_DPTf_GET BCMI_MADURA_P3_MODE_CTLr_P3_DPTf_GET
#define P3_MODE_CTLr_P3_DPTf_SET BCMI_MADURA_P3_MODE_CTLr_P3_DPTf_SET
#define P3_MODE_CTLr_P3_LALf_GET BCMI_MADURA_P3_MODE_CTLr_P3_LALf_GET
#define P3_MODE_CTLr_P3_LALf_SET BCMI_MADURA_P3_MODE_CTLr_P3_LALf_SET
#define P3_MODE_CTLr_P3_MINDEXf_GET BCMI_MADURA_P3_MODE_CTLr_P3_MINDEXf_GET
#define P3_MODE_CTLr_P3_MINDEXf_SET BCMI_MADURA_P3_MODE_CTLr_P3_MINDEXf_SET
#define READ_P3_MODE_CTLr BCMI_MADURA_READ_P3_MODE_CTLr
#define WRITE_P3_MODE_CTLr BCMI_MADURA_WRITE_P3_MODE_CTLr
#define MODIFY_P3_MODE_CTLr BCMI_MADURA_MODIFY_P3_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P3_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P4_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa314
 * DEVAD:    1
 * DESC:     Port 4 mode configuration
 * RESETVAL: 0x1a (26)
 * ACCESS:   R/W
 * FIELDS:
 *     P4_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P4_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P4_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P4_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P4_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P4_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P4_MODE_CTLr (0x0001a314 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P4_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P4_MODE_CTL.
 */
typedef union BCMI_MADURA_P4_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p4_mode_ctl[1];
	uint32_t _p4_mode_ctl;
} BCMI_MADURA_P4_MODE_CTLr_t;

#define BCMI_MADURA_P4_MODE_CTLr_CLR(r) (r).p4_mode_ctl[0] = 0
#define BCMI_MADURA_P4_MODE_CTLr_SET(r,d) (r).p4_mode_ctl[0] = d
#define BCMI_MADURA_P4_MODE_CTLr_GET(r) (r).p4_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P4_MODE_CTLr_P4_PVALIDf_GET(r) ((((r).p4_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P4_MODE_CTLr_P4_PVALIDf_SET(r,f) (r).p4_mode_ctl[0]=(((r).p4_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P4_MODE_CTLr_P4_UDMSf_GET(r) ((((r).p4_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P4_MODE_CTLr_P4_UDMSf_SET(r,f) (r).p4_mode_ctl[0]=(((r).p4_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P4_MODE_CTLr_P4_SALf_GET(r) ((((r).p4_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P4_MODE_CTLr_P4_SALf_SET(r,f) (r).p4_mode_ctl[0]=(((r).p4_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P4_MODE_CTLr_P4_DPTf_GET(r) ((((r).p4_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P4_MODE_CTLr_P4_DPTf_SET(r,f) (r).p4_mode_ctl[0]=(((r).p4_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P4_MODE_CTLr_P4_LALf_GET(r) ((((r).p4_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P4_MODE_CTLr_P4_LALf_SET(r,f) (r).p4_mode_ctl[0]=(((r).p4_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P4_MODE_CTLr_P4_MINDEXf_GET(r) (((r).p4_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P4_MODE_CTLr_P4_MINDEXf_SET(r,f) (r).p4_mode_ctl[0]=(((r).p4_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P4_MODE_CTL.
 */
#define BCMI_MADURA_READ_P4_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P4_MODE_CTLr,_r._p4_mode_ctl)
#define BCMI_MADURA_WRITE_P4_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P4_MODE_CTLr,_r._p4_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P4_MODE_CTLr BCMI_MADURA_P4_MODE_CTLr
#define P4_MODE_CTLr_SIZE BCMI_MADURA_P4_MODE_CTLr_SIZE
typedef BCMI_MADURA_P4_MODE_CTLr_t P4_MODE_CTLr_t;
#define P4_MODE_CTLr_CLR BCMI_MADURA_P4_MODE_CTLr_CLR
#define P4_MODE_CTLr_SET BCMI_MADURA_P4_MODE_CTLr_SET
#define P4_MODE_CTLr_GET BCMI_MADURA_P4_MODE_CTLr_GET
#define P4_MODE_CTLr_P4_PVALIDf_GET BCMI_MADURA_P4_MODE_CTLr_P4_PVALIDf_GET
#define P4_MODE_CTLr_P4_PVALIDf_SET BCMI_MADURA_P4_MODE_CTLr_P4_PVALIDf_SET
#define P4_MODE_CTLr_P4_UDMSf_GET BCMI_MADURA_P4_MODE_CTLr_P4_UDMSf_GET
#define P4_MODE_CTLr_P4_UDMSf_SET BCMI_MADURA_P4_MODE_CTLr_P4_UDMSf_SET
#define P4_MODE_CTLr_P4_SALf_GET BCMI_MADURA_P4_MODE_CTLr_P4_SALf_GET
#define P4_MODE_CTLr_P4_SALf_SET BCMI_MADURA_P4_MODE_CTLr_P4_SALf_SET
#define P4_MODE_CTLr_P4_DPTf_GET BCMI_MADURA_P4_MODE_CTLr_P4_DPTf_GET
#define P4_MODE_CTLr_P4_DPTf_SET BCMI_MADURA_P4_MODE_CTLr_P4_DPTf_SET
#define P4_MODE_CTLr_P4_LALf_GET BCMI_MADURA_P4_MODE_CTLr_P4_LALf_GET
#define P4_MODE_CTLr_P4_LALf_SET BCMI_MADURA_P4_MODE_CTLr_P4_LALf_SET
#define P4_MODE_CTLr_P4_MINDEXf_GET BCMI_MADURA_P4_MODE_CTLr_P4_MINDEXf_GET
#define P4_MODE_CTLr_P4_MINDEXf_SET BCMI_MADURA_P4_MODE_CTLr_P4_MINDEXf_SET
#define READ_P4_MODE_CTLr BCMI_MADURA_READ_P4_MODE_CTLr
#define WRITE_P4_MODE_CTLr BCMI_MADURA_WRITE_P4_MODE_CTLr
#define MODIFY_P4_MODE_CTLr BCMI_MADURA_MODIFY_P4_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P4_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P5_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa315
 * DEVAD:    1
 * DESC:     Port 5 mode configuration
 * RESETVAL: 0x1a (26)
 * ACCESS:   R/W
 * FIELDS:
 *     P5_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P5_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P5_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P5_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P5_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P5_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P5_MODE_CTLr (0x0001a315 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P5_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P5_MODE_CTL.
 */
typedef union BCMI_MADURA_P5_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p5_mode_ctl[1];
	uint32_t _p5_mode_ctl;
} BCMI_MADURA_P5_MODE_CTLr_t;

#define BCMI_MADURA_P5_MODE_CTLr_CLR(r) (r).p5_mode_ctl[0] = 0
#define BCMI_MADURA_P5_MODE_CTLr_SET(r,d) (r).p5_mode_ctl[0] = d
#define BCMI_MADURA_P5_MODE_CTLr_GET(r) (r).p5_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P5_MODE_CTLr_P5_PVALIDf_GET(r) ((((r).p5_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P5_MODE_CTLr_P5_PVALIDf_SET(r,f) (r).p5_mode_ctl[0]=(((r).p5_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P5_MODE_CTLr_P5_UDMSf_GET(r) ((((r).p5_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P5_MODE_CTLr_P5_UDMSf_SET(r,f) (r).p5_mode_ctl[0]=(((r).p5_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P5_MODE_CTLr_P5_SALf_GET(r) ((((r).p5_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P5_MODE_CTLr_P5_SALf_SET(r,f) (r).p5_mode_ctl[0]=(((r).p5_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P5_MODE_CTLr_P5_DPTf_GET(r) ((((r).p5_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P5_MODE_CTLr_P5_DPTf_SET(r,f) (r).p5_mode_ctl[0]=(((r).p5_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P5_MODE_CTLr_P5_LALf_GET(r) ((((r).p5_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P5_MODE_CTLr_P5_LALf_SET(r,f) (r).p5_mode_ctl[0]=(((r).p5_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P5_MODE_CTLr_P5_MINDEXf_GET(r) (((r).p5_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P5_MODE_CTLr_P5_MINDEXf_SET(r,f) (r).p5_mode_ctl[0]=(((r).p5_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P5_MODE_CTL.
 */
#define BCMI_MADURA_READ_P5_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P5_MODE_CTLr,_r._p5_mode_ctl)
#define BCMI_MADURA_WRITE_P5_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P5_MODE_CTLr,_r._p5_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P5_MODE_CTLr BCMI_MADURA_P5_MODE_CTLr
#define P5_MODE_CTLr_SIZE BCMI_MADURA_P5_MODE_CTLr_SIZE
typedef BCMI_MADURA_P5_MODE_CTLr_t P5_MODE_CTLr_t;
#define P5_MODE_CTLr_CLR BCMI_MADURA_P5_MODE_CTLr_CLR
#define P5_MODE_CTLr_SET BCMI_MADURA_P5_MODE_CTLr_SET
#define P5_MODE_CTLr_GET BCMI_MADURA_P5_MODE_CTLr_GET
#define P5_MODE_CTLr_P5_PVALIDf_GET BCMI_MADURA_P5_MODE_CTLr_P5_PVALIDf_GET
#define P5_MODE_CTLr_P5_PVALIDf_SET BCMI_MADURA_P5_MODE_CTLr_P5_PVALIDf_SET
#define P5_MODE_CTLr_P5_UDMSf_GET BCMI_MADURA_P5_MODE_CTLr_P5_UDMSf_GET
#define P5_MODE_CTLr_P5_UDMSf_SET BCMI_MADURA_P5_MODE_CTLr_P5_UDMSf_SET
#define P5_MODE_CTLr_P5_SALf_GET BCMI_MADURA_P5_MODE_CTLr_P5_SALf_GET
#define P5_MODE_CTLr_P5_SALf_SET BCMI_MADURA_P5_MODE_CTLr_P5_SALf_SET
#define P5_MODE_CTLr_P5_DPTf_GET BCMI_MADURA_P5_MODE_CTLr_P5_DPTf_GET
#define P5_MODE_CTLr_P5_DPTf_SET BCMI_MADURA_P5_MODE_CTLr_P5_DPTf_SET
#define P5_MODE_CTLr_P5_LALf_GET BCMI_MADURA_P5_MODE_CTLr_P5_LALf_GET
#define P5_MODE_CTLr_P5_LALf_SET BCMI_MADURA_P5_MODE_CTLr_P5_LALf_SET
#define P5_MODE_CTLr_P5_MINDEXf_GET BCMI_MADURA_P5_MODE_CTLr_P5_MINDEXf_GET
#define P5_MODE_CTLr_P5_MINDEXf_SET BCMI_MADURA_P5_MODE_CTLr_P5_MINDEXf_SET
#define READ_P5_MODE_CTLr BCMI_MADURA_READ_P5_MODE_CTLr
#define WRITE_P5_MODE_CTLr BCMI_MADURA_WRITE_P5_MODE_CTLr
#define MODIFY_P5_MODE_CTLr BCMI_MADURA_MODIFY_P5_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P5_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P6_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa316
 * DEVAD:    1
 * DESC:     Port 6 mode configuration
 * RESETVAL: 0x1a (26)
 * ACCESS:   R/W
 * FIELDS:
 *     P6_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P6_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P6_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P6_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P6_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P6_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P6_MODE_CTLr (0x0001a316 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P6_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P6_MODE_CTL.
 */
typedef union BCMI_MADURA_P6_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p6_mode_ctl[1];
	uint32_t _p6_mode_ctl;
} BCMI_MADURA_P6_MODE_CTLr_t;

#define BCMI_MADURA_P6_MODE_CTLr_CLR(r) (r).p6_mode_ctl[0] = 0
#define BCMI_MADURA_P6_MODE_CTLr_SET(r,d) (r).p6_mode_ctl[0] = d
#define BCMI_MADURA_P6_MODE_CTLr_GET(r) (r).p6_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P6_MODE_CTLr_P6_PVALIDf_GET(r) ((((r).p6_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P6_MODE_CTLr_P6_PVALIDf_SET(r,f) (r).p6_mode_ctl[0]=(((r).p6_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P6_MODE_CTLr_P6_UDMSf_GET(r) ((((r).p6_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P6_MODE_CTLr_P6_UDMSf_SET(r,f) (r).p6_mode_ctl[0]=(((r).p6_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P6_MODE_CTLr_P6_SALf_GET(r) ((((r).p6_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P6_MODE_CTLr_P6_SALf_SET(r,f) (r).p6_mode_ctl[0]=(((r).p6_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P6_MODE_CTLr_P6_DPTf_GET(r) ((((r).p6_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P6_MODE_CTLr_P6_DPTf_SET(r,f) (r).p6_mode_ctl[0]=(((r).p6_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P6_MODE_CTLr_P6_LALf_GET(r) ((((r).p6_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P6_MODE_CTLr_P6_LALf_SET(r,f) (r).p6_mode_ctl[0]=(((r).p6_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P6_MODE_CTLr_P6_MINDEXf_GET(r) (((r).p6_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P6_MODE_CTLr_P6_MINDEXf_SET(r,f) (r).p6_mode_ctl[0]=(((r).p6_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P6_MODE_CTL.
 */
#define BCMI_MADURA_READ_P6_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P6_MODE_CTLr,_r._p6_mode_ctl)
#define BCMI_MADURA_WRITE_P6_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P6_MODE_CTLr,_r._p6_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P6_MODE_CTLr BCMI_MADURA_P6_MODE_CTLr
#define P6_MODE_CTLr_SIZE BCMI_MADURA_P6_MODE_CTLr_SIZE
typedef BCMI_MADURA_P6_MODE_CTLr_t P6_MODE_CTLr_t;
#define P6_MODE_CTLr_CLR BCMI_MADURA_P6_MODE_CTLr_CLR
#define P6_MODE_CTLr_SET BCMI_MADURA_P6_MODE_CTLr_SET
#define P6_MODE_CTLr_GET BCMI_MADURA_P6_MODE_CTLr_GET
#define P6_MODE_CTLr_P6_PVALIDf_GET BCMI_MADURA_P6_MODE_CTLr_P6_PVALIDf_GET
#define P6_MODE_CTLr_P6_PVALIDf_SET BCMI_MADURA_P6_MODE_CTLr_P6_PVALIDf_SET
#define P6_MODE_CTLr_P6_UDMSf_GET BCMI_MADURA_P6_MODE_CTLr_P6_UDMSf_GET
#define P6_MODE_CTLr_P6_UDMSf_SET BCMI_MADURA_P6_MODE_CTLr_P6_UDMSf_SET
#define P6_MODE_CTLr_P6_SALf_GET BCMI_MADURA_P6_MODE_CTLr_P6_SALf_GET
#define P6_MODE_CTLr_P6_SALf_SET BCMI_MADURA_P6_MODE_CTLr_P6_SALf_SET
#define P6_MODE_CTLr_P6_DPTf_GET BCMI_MADURA_P6_MODE_CTLr_P6_DPTf_GET
#define P6_MODE_CTLr_P6_DPTf_SET BCMI_MADURA_P6_MODE_CTLr_P6_DPTf_SET
#define P6_MODE_CTLr_P6_LALf_GET BCMI_MADURA_P6_MODE_CTLr_P6_LALf_GET
#define P6_MODE_CTLr_P6_LALf_SET BCMI_MADURA_P6_MODE_CTLr_P6_LALf_SET
#define P6_MODE_CTLr_P6_MINDEXf_GET BCMI_MADURA_P6_MODE_CTLr_P6_MINDEXf_GET
#define P6_MODE_CTLr_P6_MINDEXf_SET BCMI_MADURA_P6_MODE_CTLr_P6_MINDEXf_SET
#define READ_P6_MODE_CTLr BCMI_MADURA_READ_P6_MODE_CTLr
#define WRITE_P6_MODE_CTLr BCMI_MADURA_WRITE_P6_MODE_CTLr
#define MODIFY_P6_MODE_CTLr BCMI_MADURA_MODIFY_P6_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P6_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  P7_MODE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa317
 * DEVAD:    1
 * DESC:     Port 7 mode configuration
 * RESETVAL: 0x1a (26)
 * ACCESS:   R/W
 * FIELDS:
 *     P7_MINDEX        Mode indexThis field summarizes the type of traffic and the chip lanes used by a port.This field should be populated according mode_decode spreadsheet table.Every valid port should have a unique mode index.
 *     P7_LAL           If applicable, this denotes the lane number on the line side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.This is also used to specify the AN lane in DME-PT mode.
 *     P7_DPT           1: Enable DME Passthrough on this port. Applies only to modes whereDME-PT is supported.
 *     P7_SAL           If applicable, this denotes the lane number on the system side used by a port for performing AN.Note that an AN port can have either 4 lanes(0-3) or 1 lane(0) and this field represents that lane number. This does not denote the Madura lane numbers.In DME-PT mode, this is a status register that outputs the system lane on which DME traffic is expected. This denotes the port lane number and not Madura lane numbers.
 *     P7_UDMS          User Defined Mode Setting.If a port can derive its mode from AN or from this register, setting this bit to 1 will force the mode to be decoded from this register. If this register is the only means to configure the mode for this port, this bit will have no effect.
 *     P7_PVALID        If set to 1, this denotes that this port is valid - i.e. configured for use. The other fields of this register have effect only if this bit is set.
 */
#define BCMI_MADURA_P7_MODE_CTLr (0x0001a317 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_P7_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program P7_MODE_CTL.
 */
typedef union BCMI_MADURA_P7_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t p7_mode_ctl[1];
	uint32_t _p7_mode_ctl;
} BCMI_MADURA_P7_MODE_CTLr_t;

#define BCMI_MADURA_P7_MODE_CTLr_CLR(r) (r).p7_mode_ctl[0] = 0
#define BCMI_MADURA_P7_MODE_CTLr_SET(r,d) (r).p7_mode_ctl[0] = d
#define BCMI_MADURA_P7_MODE_CTLr_GET(r) (r).p7_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_P7_MODE_CTLr_P7_PVALIDf_GET(r) ((((r).p7_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_P7_MODE_CTLr_P7_PVALIDf_SET(r,f) (r).p7_mode_ctl[0]=(((r).p7_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_P7_MODE_CTLr_P7_UDMSf_GET(r) ((((r).p7_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_P7_MODE_CTLr_P7_UDMSf_SET(r,f) (r).p7_mode_ctl[0]=(((r).p7_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_P7_MODE_CTLr_P7_SALf_GET(r) ((((r).p7_mode_ctl[0]) >> 12) & 0x3)
#define BCMI_MADURA_P7_MODE_CTLr_P7_SALf_SET(r,f) (r).p7_mode_ctl[0]=(((r).p7_mode_ctl[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_P7_MODE_CTLr_P7_DPTf_GET(r) ((((r).p7_mode_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_P7_MODE_CTLr_P7_DPTf_SET(r,f) (r).p7_mode_ctl[0]=(((r).p7_mode_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_P7_MODE_CTLr_P7_LALf_GET(r) ((((r).p7_mode_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_P7_MODE_CTLr_P7_LALf_SET(r,f) (r).p7_mode_ctl[0]=(((r).p7_mode_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_P7_MODE_CTLr_P7_MINDEXf_GET(r) (((r).p7_mode_ctl[0]) & 0xff)
#define BCMI_MADURA_P7_MODE_CTLr_P7_MINDEXf_SET(r,f) (r).p7_mode_ctl[0]=(((r).p7_mode_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access P7_MODE_CTL.
 */
#define BCMI_MADURA_READ_P7_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_P7_MODE_CTLr,_r._p7_mode_ctl)
#define BCMI_MADURA_WRITE_P7_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_P7_MODE_CTLr,_r._p7_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define P7_MODE_CTLr BCMI_MADURA_P7_MODE_CTLr
#define P7_MODE_CTLr_SIZE BCMI_MADURA_P7_MODE_CTLr_SIZE
typedef BCMI_MADURA_P7_MODE_CTLr_t P7_MODE_CTLr_t;
#define P7_MODE_CTLr_CLR BCMI_MADURA_P7_MODE_CTLr_CLR
#define P7_MODE_CTLr_SET BCMI_MADURA_P7_MODE_CTLr_SET
#define P7_MODE_CTLr_GET BCMI_MADURA_P7_MODE_CTLr_GET
#define P7_MODE_CTLr_P7_PVALIDf_GET BCMI_MADURA_P7_MODE_CTLr_P7_PVALIDf_GET
#define P7_MODE_CTLr_P7_PVALIDf_SET BCMI_MADURA_P7_MODE_CTLr_P7_PVALIDf_SET
#define P7_MODE_CTLr_P7_UDMSf_GET BCMI_MADURA_P7_MODE_CTLr_P7_UDMSf_GET
#define P7_MODE_CTLr_P7_UDMSf_SET BCMI_MADURA_P7_MODE_CTLr_P7_UDMSf_SET
#define P7_MODE_CTLr_P7_SALf_GET BCMI_MADURA_P7_MODE_CTLr_P7_SALf_GET
#define P7_MODE_CTLr_P7_SALf_SET BCMI_MADURA_P7_MODE_CTLr_P7_SALf_SET
#define P7_MODE_CTLr_P7_DPTf_GET BCMI_MADURA_P7_MODE_CTLr_P7_DPTf_GET
#define P7_MODE_CTLr_P7_DPTf_SET BCMI_MADURA_P7_MODE_CTLr_P7_DPTf_SET
#define P7_MODE_CTLr_P7_LALf_GET BCMI_MADURA_P7_MODE_CTLr_P7_LALf_GET
#define P7_MODE_CTLr_P7_LALf_SET BCMI_MADURA_P7_MODE_CTLr_P7_LALf_SET
#define P7_MODE_CTLr_P7_MINDEXf_GET BCMI_MADURA_P7_MODE_CTLr_P7_MINDEXf_GET
#define P7_MODE_CTLr_P7_MINDEXf_SET BCMI_MADURA_P7_MODE_CTLr_P7_MINDEXf_SET
#define READ_P7_MODE_CTLr BCMI_MADURA_READ_P7_MODE_CTLr
#define WRITE_P7_MODE_CTLr BCMI_MADURA_WRITE_P7_MODE_CTLr
#define MODIFY_P7_MODE_CTLr BCMI_MADURA_MODIFY_P7_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_P7_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ETH_PHY_TYPE_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa320
 * DEVAD:    1
 * DESC:     Ethernet PHY type
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ETH_PHY_TYPE     Ethernet PHY typeThis register is valid only in ethernet application.00 - Optical Front Panel01 - Copper Front Panel10 - Back Plane11 - Reserved
 */
#define BCMI_MADURA_ETH_PHY_TYPE_CTLr (0x0001a320 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ETH_PHY_TYPE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ETH_PHY_TYPE_CTL.
 */
typedef union BCMI_MADURA_ETH_PHY_TYPE_CTLr_s {
	uint32_t v[1];
	uint32_t eth_phy_type_ctl[1];
	uint32_t _eth_phy_type_ctl;
} BCMI_MADURA_ETH_PHY_TYPE_CTLr_t;

#define BCMI_MADURA_ETH_PHY_TYPE_CTLr_CLR(r) (r).eth_phy_type_ctl[0] = 0
#define BCMI_MADURA_ETH_PHY_TYPE_CTLr_SET(r,d) (r).eth_phy_type_ctl[0] = d
#define BCMI_MADURA_ETH_PHY_TYPE_CTLr_GET(r) (r).eth_phy_type_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ETH_PHY_TYPE_CTLr_ETH_PHY_TYPEf_GET(r) (((r).eth_phy_type_ctl[0]) & 0x3)
#define BCMI_MADURA_ETH_PHY_TYPE_CTLr_ETH_PHY_TYPEf_SET(r,f) (r).eth_phy_type_ctl[0]=(((r).eth_phy_type_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access ETH_PHY_TYPE_CTL.
 */
#define BCMI_MADURA_READ_ETH_PHY_TYPE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ETH_PHY_TYPE_CTLr,_r._eth_phy_type_ctl)
#define BCMI_MADURA_WRITE_ETH_PHY_TYPE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ETH_PHY_TYPE_CTLr,_r._eth_phy_type_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ETH_PHY_TYPE_CTLr BCMI_MADURA_ETH_PHY_TYPE_CTLr
#define ETH_PHY_TYPE_CTLr_SIZE BCMI_MADURA_ETH_PHY_TYPE_CTLr_SIZE
typedef BCMI_MADURA_ETH_PHY_TYPE_CTLr_t ETH_PHY_TYPE_CTLr_t;
#define ETH_PHY_TYPE_CTLr_CLR BCMI_MADURA_ETH_PHY_TYPE_CTLr_CLR
#define ETH_PHY_TYPE_CTLr_SET BCMI_MADURA_ETH_PHY_TYPE_CTLr_SET
#define ETH_PHY_TYPE_CTLr_GET BCMI_MADURA_ETH_PHY_TYPE_CTLr_GET
#define ETH_PHY_TYPE_CTLr_ETH_PHY_TYPEf_GET BCMI_MADURA_ETH_PHY_TYPE_CTLr_ETH_PHY_TYPEf_GET
#define ETH_PHY_TYPE_CTLr_ETH_PHY_TYPEf_SET BCMI_MADURA_ETH_PHY_TYPE_CTLr_ETH_PHY_TYPEf_SET
#define READ_ETH_PHY_TYPE_CTLr BCMI_MADURA_READ_ETH_PHY_TYPE_CTLr
#define WRITE_ETH_PHY_TYPE_CTLr BCMI_MADURA_WRITE_ETH_PHY_TYPE_CTLr
#define MODIFY_ETH_PHY_TYPE_CTLr BCMI_MADURA_MODIFY_ETH_PHY_TYPE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ETH_PHY_TYPE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODE_SYS_RX_FIFO_RSTB_FRC_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa330
 * DEVAD:    1
 * DESC:     Override system side rx FIFO rstb
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_RX_FIFO_RSTB_FRCVAL Forced values for resetting system rx FIFOsApplicable only when force bits are set
 *     SYS_RX_FIFO_RSTB_FRC Force bits for resetting system rx FIFOs. Overrides the automatic value
 */
#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr (0x0001a330 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_SYS_RX_FIFO_RSTB_FRC_CTL.
 */
typedef union BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_s {
	uint32_t v[1];
	uint32_t mode_sys_rx_fifo_rstb_frc_ctl[1];
	uint32_t _mode_sys_rx_fifo_rstb_frc_ctl;
} BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_t;

#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_CLR(r) (r).mode_sys_rx_fifo_rstb_frc_ctl[0] = 0
#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SET(r,d) (r).mode_sys_rx_fifo_rstb_frc_ctl[0] = d
#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_GET(r) (r).mode_sys_rx_fifo_rstb_frc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCf_GET(r) ((((r).mode_sys_rx_fifo_rstb_frc_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCf_SET(r,f) (r).mode_sys_rx_fifo_rstb_frc_ctl[0]=(((r).mode_sys_rx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCVALf_GET(r) (((r).mode_sys_rx_fifo_rstb_frc_ctl[0]) & 0xff)
#define BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCVALf_SET(r,f) (r).mode_sys_rx_fifo_rstb_frc_ctl[0]=(((r).mode_sys_rx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MODE_SYS_RX_FIFO_RSTB_FRC_CTL.
 */
#define BCMI_MADURA_READ_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr,_r._mode_sys_rx_fifo_rstb_frc_ctl)
#define BCMI_MADURA_WRITE_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr,_r._mode_sys_rx_fifo_rstb_frc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SIZE BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SIZE
typedef BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_t MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_t;
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_CLR BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_CLR
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SET BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SET
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_GET BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_GET
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCf_GET BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCf_GET
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCf_SET BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCf_SET
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCVALf_GET BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCVALf_GET
#define MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCVALf_SET BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr_SYS_RX_FIFO_RSTB_FRCVALf_SET
#define READ_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_READ_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr
#define WRITE_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_WRITE_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr
#define MODIFY_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODIFY_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODE_SYS_RX_FIFO_RSTB_FRC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODE_SYS_TX_FIFO_RSTB_FRC_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa331
 * DEVAD:    1
 * DESC:     Override system side tx FIFO rstb
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_TX_FIFO_RSTB_FRCVAL Forced values for resetting system tx FIFOsApplicable only when force bits are set
 *     SYS_TX_FIFO_RSTB_FRC Force bits for resetting system tx FIFOs. Overrides the automatic value
 */
#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr (0x0001a331 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_SYS_TX_FIFO_RSTB_FRC_CTL.
 */
typedef union BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_s {
	uint32_t v[1];
	uint32_t mode_sys_tx_fifo_rstb_frc_ctl[1];
	uint32_t _mode_sys_tx_fifo_rstb_frc_ctl;
} BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_t;

#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_CLR(r) (r).mode_sys_tx_fifo_rstb_frc_ctl[0] = 0
#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SET(r,d) (r).mode_sys_tx_fifo_rstb_frc_ctl[0] = d
#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_GET(r) (r).mode_sys_tx_fifo_rstb_frc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCf_GET(r) ((((r).mode_sys_tx_fifo_rstb_frc_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCf_SET(r,f) (r).mode_sys_tx_fifo_rstb_frc_ctl[0]=(((r).mode_sys_tx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCVALf_GET(r) (((r).mode_sys_tx_fifo_rstb_frc_ctl[0]) & 0xff)
#define BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCVALf_SET(r,f) (r).mode_sys_tx_fifo_rstb_frc_ctl[0]=(((r).mode_sys_tx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MODE_SYS_TX_FIFO_RSTB_FRC_CTL.
 */
#define BCMI_MADURA_READ_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr,_r._mode_sys_tx_fifo_rstb_frc_ctl)
#define BCMI_MADURA_WRITE_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr,_r._mode_sys_tx_fifo_rstb_frc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SIZE BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SIZE
typedef BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_t MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_t;
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_CLR BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_CLR
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SET BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SET
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_GET BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_GET
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCf_GET BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCf_GET
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCf_SET BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCf_SET
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCVALf_GET BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCVALf_GET
#define MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCVALf_SET BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr_SYS_TX_FIFO_RSTB_FRCVALf_SET
#define READ_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_READ_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr
#define WRITE_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_WRITE_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr
#define MODIFY_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODIFY_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODE_SYS_TX_FIFO_RSTB_FRC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODE_LIN_RX_FIFO_RSTB_FRC_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa332
 * DEVAD:    1
 * DESC:     Override line side rx FIFO rstb
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_RX_FIFO_RSTB_FRCVAL Forced values for resetting line rx FIFOsApplicable only when force bits are set
 *     LIN_RX_FIFO_RSTB_FRC Force bits for resetting line rx FIFOs. Overrides the automatic value
 */
#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr (0x0001a332 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_LIN_RX_FIFO_RSTB_FRC_CTL.
 */
typedef union BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_s {
	uint32_t v[1];
	uint32_t mode_lin_rx_fifo_rstb_frc_ctl[1];
	uint32_t _mode_lin_rx_fifo_rstb_frc_ctl;
} BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_t;

#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_CLR(r) (r).mode_lin_rx_fifo_rstb_frc_ctl[0] = 0
#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_SET(r,d) (r).mode_lin_rx_fifo_rstb_frc_ctl[0] = d
#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_GET(r) (r).mode_lin_rx_fifo_rstb_frc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCf_GET(r) ((((r).mode_lin_rx_fifo_rstb_frc_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCf_SET(r,f) (r).mode_lin_rx_fifo_rstb_frc_ctl[0]=(((r).mode_lin_rx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCVALf_GET(r) (((r).mode_lin_rx_fifo_rstb_frc_ctl[0]) & 0xff)
#define BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCVALf_SET(r,f) (r).mode_lin_rx_fifo_rstb_frc_ctl[0]=(((r).mode_lin_rx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MODE_LIN_RX_FIFO_RSTB_FRC_CTL.
 */
#define BCMI_MADURA_READ_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr,_r._mode_lin_rx_fifo_rstb_frc_ctl)
#define BCMI_MADURA_WRITE_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr,_r._mode_lin_rx_fifo_rstb_frc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_SIZE BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_SIZE
typedef BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_t MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_t;
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_CLR BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_CLR
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_SET BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_SET
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_GET BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_GET
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCf_GET BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCf_GET
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCf_SET BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCf_SET
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCVALf_GET BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCVALf_GET
#define MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCVALf_SET BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr_LIN_RX_FIFO_RSTB_FRCVALf_SET
#define READ_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_READ_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr
#define WRITE_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_WRITE_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr
#define MODIFY_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODIFY_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODE_LIN_RX_FIFO_RSTB_FRC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODE_LIN_TX_FIFO_RSTB_FRC_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa333
 * DEVAD:    1
 * DESC:     Override line side tx FIFO rstb
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_TX_FIFO_RSTB_FRCVAL Forced values for resetting line tx FIFOsApplicable only when force bits are set
 *     LIN_TX_FIFO_RSTB_FRC Force bits for resetting line tx FIFOs. Overrides the automatic value
 */
#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr (0x0001a333 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_LIN_TX_FIFO_RSTB_FRC_CTL.
 */
typedef union BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_s {
	uint32_t v[1];
	uint32_t mode_lin_tx_fifo_rstb_frc_ctl[1];
	uint32_t _mode_lin_tx_fifo_rstb_frc_ctl;
} BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_t;

#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_CLR(r) (r).mode_lin_tx_fifo_rstb_frc_ctl[0] = 0
#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_SET(r,d) (r).mode_lin_tx_fifo_rstb_frc_ctl[0] = d
#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_GET(r) (r).mode_lin_tx_fifo_rstb_frc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCf_GET(r) ((((r).mode_lin_tx_fifo_rstb_frc_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCf_SET(r,f) (r).mode_lin_tx_fifo_rstb_frc_ctl[0]=(((r).mode_lin_tx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCVALf_GET(r) (((r).mode_lin_tx_fifo_rstb_frc_ctl[0]) & 0xff)
#define BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCVALf_SET(r,f) (r).mode_lin_tx_fifo_rstb_frc_ctl[0]=(((r).mode_lin_tx_fifo_rstb_frc_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MODE_LIN_TX_FIFO_RSTB_FRC_CTL.
 */
#define BCMI_MADURA_READ_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr,_r._mode_lin_tx_fifo_rstb_frc_ctl)
#define BCMI_MADURA_WRITE_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr,_r._mode_lin_tx_fifo_rstb_frc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_SIZE BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_SIZE
typedef BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_t MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_t;
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_CLR BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_CLR
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_SET BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_SET
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_GET BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_GET
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCf_GET BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCf_GET
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCf_SET BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCf_SET
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCVALf_GET BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCVALf_GET
#define MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCVALf_SET BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr_LIN_TX_FIFO_RSTB_FRCVALf_SET
#define READ_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_READ_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr
#define WRITE_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_WRITE_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr
#define MODIFY_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr BCMI_MADURA_MODIFY_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODE_LIN_TX_FIFO_RSTB_FRC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODE_SYS_LN_EN_FRC_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa334
 * DEVAD:    1
 * DESC:     Override mode based system lane enables
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     MODE_SYS_LANE_EN_FRCVAL Forced values for enabling system falcon lanesApplicable only when force bits are set
 *     MODE_SYS_LANE_EN_FRC Force bits for enabling system falcon lanes. Overrides the automatic value
 */
#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr (0x0001a334 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_SYS_LN_EN_FRC_CTL.
 */
typedef union BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_s {
	uint32_t v[1];
	uint32_t mode_sys_ln_en_frc_ctl[1];
	uint32_t _mode_sys_ln_en_frc_ctl;
} BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_t;

#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_CLR(r) (r).mode_sys_ln_en_frc_ctl[0] = 0
#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_SET(r,d) (r).mode_sys_ln_en_frc_ctl[0] = d
#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_GET(r) (r).mode_sys_ln_en_frc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCf_GET(r) ((((r).mode_sys_ln_en_frc_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCf_SET(r,f) (r).mode_sys_ln_en_frc_ctl[0]=(((r).mode_sys_ln_en_frc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCVALf_GET(r) (((r).mode_sys_ln_en_frc_ctl[0]) & 0xff)
#define BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCVALf_SET(r,f) (r).mode_sys_ln_en_frc_ctl[0]=(((r).mode_sys_ln_en_frc_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MODE_SYS_LN_EN_FRC_CTL.
 */
#define BCMI_MADURA_READ_MODE_SYS_LN_EN_FRC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr,_r._mode_sys_ln_en_frc_ctl)
#define BCMI_MADURA_WRITE_MODE_SYS_LN_EN_FRC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr,_r._mode_sys_ln_en_frc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODE_SYS_LN_EN_FRC_CTLr BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr
#define MODE_SYS_LN_EN_FRC_CTLr_SIZE BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_SIZE
typedef BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_t MODE_SYS_LN_EN_FRC_CTLr_t;
#define MODE_SYS_LN_EN_FRC_CTLr_CLR BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_CLR
#define MODE_SYS_LN_EN_FRC_CTLr_SET BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_SET
#define MODE_SYS_LN_EN_FRC_CTLr_GET BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_GET
#define MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCf_GET BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCf_GET
#define MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCf_SET BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCf_SET
#define MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCVALf_GET BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCVALf_GET
#define MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCVALf_SET BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr_MODE_SYS_LANE_EN_FRCVALf_SET
#define READ_MODE_SYS_LN_EN_FRC_CTLr BCMI_MADURA_READ_MODE_SYS_LN_EN_FRC_CTLr
#define WRITE_MODE_SYS_LN_EN_FRC_CTLr BCMI_MADURA_WRITE_MODE_SYS_LN_EN_FRC_CTLr
#define MODIFY_MODE_SYS_LN_EN_FRC_CTLr BCMI_MADURA_MODIFY_MODE_SYS_LN_EN_FRC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODE_SYS_LN_EN_FRC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MODE_LIN_LN_EN_FRC_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa335
 * DEVAD:    1
 * DESC:     Override mode based line lane enables
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     MODE_LIN_LANE_EN_FRCVAL Forced values for enabling line falcon lanesApplicable only when force bits are set
 *     MODE_LIN_LANE_EN_FRC Force bits for enabling line falcon lanes. Overrides the automatic value
 */
#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr (0x0001a335 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MODE_LIN_LN_EN_FRC_CTL.
 */
typedef union BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_s {
	uint32_t v[1];
	uint32_t mode_lin_ln_en_frc_ctl[1];
	uint32_t _mode_lin_ln_en_frc_ctl;
} BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_t;

#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_CLR(r) (r).mode_lin_ln_en_frc_ctl[0] = 0
#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_SET(r,d) (r).mode_lin_ln_en_frc_ctl[0] = d
#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_GET(r) (r).mode_lin_ln_en_frc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCf_GET(r) ((((r).mode_lin_ln_en_frc_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCf_SET(r,f) (r).mode_lin_ln_en_frc_ctl[0]=(((r).mode_lin_ln_en_frc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCVALf_GET(r) (((r).mode_lin_ln_en_frc_ctl[0]) & 0xff)
#define BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCVALf_SET(r,f) (r).mode_lin_ln_en_frc_ctl[0]=(((r).mode_lin_ln_en_frc_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MODE_LIN_LN_EN_FRC_CTL.
 */
#define BCMI_MADURA_READ_MODE_LIN_LN_EN_FRC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr,_r._mode_lin_ln_en_frc_ctl)
#define BCMI_MADURA_WRITE_MODE_LIN_LN_EN_FRC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr,_r._mode_lin_ln_en_frc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MODE_LIN_LN_EN_FRC_CTLr BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr
#define MODE_LIN_LN_EN_FRC_CTLr_SIZE BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_SIZE
typedef BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_t MODE_LIN_LN_EN_FRC_CTLr_t;
#define MODE_LIN_LN_EN_FRC_CTLr_CLR BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_CLR
#define MODE_LIN_LN_EN_FRC_CTLr_SET BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_SET
#define MODE_LIN_LN_EN_FRC_CTLr_GET BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_GET
#define MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCf_GET BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCf_GET
#define MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCf_SET BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCf_SET
#define MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCVALf_GET BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCVALf_GET
#define MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCVALf_SET BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr_MODE_LIN_LANE_EN_FRCVALf_SET
#define READ_MODE_LIN_LN_EN_FRC_CTLr BCMI_MADURA_READ_MODE_LIN_LN_EN_FRC_CTLr
#define WRITE_MODE_LIN_LN_EN_FRC_CTLr BCMI_MADURA_WRITE_MODE_LIN_LN_EN_FRC_CTLr
#define MODIFY_MODE_LIN_LN_EN_FRC_CTLr BCMI_MADURA_MODIFY_MODE_LIN_LN_EN_FRC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MODE_LIN_LN_EN_FRC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FAL_USE_SLOCK_4_TXDIS
 * BLOCKS:   DP
 * REGADDR:  0xa336
 * DEVAD:    1
 * DESC:     Falcon use sys lock for line side tx disable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FAL_USE_SYS_LOCK_4_TXDISABLE 1'b1 - use sys lock for line tx disable1'b0 - do NOT use sys lock for line tx disablebit 7:0 corresponding to Line TX lane 7:0
 */
#define BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr (0x0001a336 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_SIZE 4

/*
 * This structure should be used to declare and program FAL_USE_SLOCK_4_TXDIS.
 */
typedef union BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_s {
	uint32_t v[1];
	uint32_t fal_use_slock_4_txdis[1];
	uint32_t _fal_use_slock_4_txdis;
} BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_t;

#define BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_CLR(r) (r).fal_use_slock_4_txdis[0] = 0
#define BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_SET(r,d) (r).fal_use_slock_4_txdis[0] = d
#define BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_GET(r) (r).fal_use_slock_4_txdis[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_FAL_USE_SYS_LOCK_4_TXDISABLEf_GET(r) (((r).fal_use_slock_4_txdis[0]) & 0xff)
#define BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_FAL_USE_SYS_LOCK_4_TXDISABLEf_SET(r,f) (r).fal_use_slock_4_txdis[0]=(((r).fal_use_slock_4_txdis[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access FAL_USE_SLOCK_4_TXDIS.
 */
#define BCMI_MADURA_READ_FAL_USE_SLOCK_4_TXDISr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr,_r._fal_use_slock_4_txdis)
#define BCMI_MADURA_WRITE_FAL_USE_SLOCK_4_TXDISr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr,_r._fal_use_slock_4_txdis)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FAL_USE_SLOCK_4_TXDISr BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr
#define FAL_USE_SLOCK_4_TXDISr_SIZE BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_SIZE
typedef BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_t FAL_USE_SLOCK_4_TXDISr_t;
#define FAL_USE_SLOCK_4_TXDISr_CLR BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_CLR
#define FAL_USE_SLOCK_4_TXDISr_SET BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_SET
#define FAL_USE_SLOCK_4_TXDISr_GET BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_GET
#define FAL_USE_SLOCK_4_TXDISr_FAL_USE_SYS_LOCK_4_TXDISABLEf_GET BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_FAL_USE_SYS_LOCK_4_TXDISABLEf_GET
#define FAL_USE_SLOCK_4_TXDISr_FAL_USE_SYS_LOCK_4_TXDISABLEf_SET BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr_FAL_USE_SYS_LOCK_4_TXDISABLEf_SET
#define READ_FAL_USE_SLOCK_4_TXDISr BCMI_MADURA_READ_FAL_USE_SLOCK_4_TXDISr
#define WRITE_FAL_USE_SLOCK_4_TXDISr BCMI_MADURA_WRITE_FAL_USE_SLOCK_4_TXDISr
#define MODIFY_FAL_USE_SLOCK_4_TXDISr BCMI_MADURA_MODIFY_FAL_USE_SLOCK_4_TXDISr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FAL_USE_SLOCK_4_TXDISr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FAL_RST_CTL1
 * BLOCKS:   DP
 * REGADDR:  0xa337
 * DEVAD:    1
 * DESC:     Falcon reset control 1
 * RESETVAL: 0x3ff (1023)
 * ACCESS:   R/W
 * FIELDS:
 *     FAL_LN_H_RSTB    This field contributes to pmd_ln_h_rstb[7:0] of FalconThis is just one of the sources for the pmd_ln_h_rstb. Please refer to the DP_resets document
 *     MGT_DATAPATH_RSTB This contributes to pmd_core_dp_h_rstb of FalconThis is just one of the reset sources for pmd_core_dp_h_rstb
 */
#define BCMI_MADURA_FAL_RST_CTL1r (0x0001a337 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FAL_RST_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program FAL_RST_CTL1.
 */
typedef union BCMI_MADURA_FAL_RST_CTL1r_s {
	uint32_t v[1];
	uint32_t fal_rst_ctl1[1];
	uint32_t _fal_rst_ctl1;
} BCMI_MADURA_FAL_RST_CTL1r_t;

#define BCMI_MADURA_FAL_RST_CTL1r_CLR(r) (r).fal_rst_ctl1[0] = 0
#define BCMI_MADURA_FAL_RST_CTL1r_SET(r,d) (r).fal_rst_ctl1[0] = d
#define BCMI_MADURA_FAL_RST_CTL1r_GET(r) (r).fal_rst_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FAL_RST_CTL1r_MGT_DATAPATH_RSTBf_GET(r) ((((r).fal_rst_ctl1[0]) >> 8) & 0x3)
#define BCMI_MADURA_FAL_RST_CTL1r_MGT_DATAPATH_RSTBf_SET(r,f) (r).fal_rst_ctl1[0]=(((r).fal_rst_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_FAL_RST_CTL1r_FAL_LN_H_RSTBf_GET(r) (((r).fal_rst_ctl1[0]) & 0xff)
#define BCMI_MADURA_FAL_RST_CTL1r_FAL_LN_H_RSTBf_SET(r,f) (r).fal_rst_ctl1[0]=(((r).fal_rst_ctl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access FAL_RST_CTL1.
 */
#define BCMI_MADURA_READ_FAL_RST_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FAL_RST_CTL1r,_r._fal_rst_ctl1)
#define BCMI_MADURA_WRITE_FAL_RST_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FAL_RST_CTL1r,_r._fal_rst_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FAL_RST_CTL1r BCMI_MADURA_FAL_RST_CTL1r
#define FAL_RST_CTL1r_SIZE BCMI_MADURA_FAL_RST_CTL1r_SIZE
typedef BCMI_MADURA_FAL_RST_CTL1r_t FAL_RST_CTL1r_t;
#define FAL_RST_CTL1r_CLR BCMI_MADURA_FAL_RST_CTL1r_CLR
#define FAL_RST_CTL1r_SET BCMI_MADURA_FAL_RST_CTL1r_SET
#define FAL_RST_CTL1r_GET BCMI_MADURA_FAL_RST_CTL1r_GET
#define FAL_RST_CTL1r_MGT_DATAPATH_RSTBf_GET BCMI_MADURA_FAL_RST_CTL1r_MGT_DATAPATH_RSTBf_GET
#define FAL_RST_CTL1r_MGT_DATAPATH_RSTBf_SET BCMI_MADURA_FAL_RST_CTL1r_MGT_DATAPATH_RSTBf_SET
#define FAL_RST_CTL1r_FAL_LN_H_RSTBf_GET BCMI_MADURA_FAL_RST_CTL1r_FAL_LN_H_RSTBf_GET
#define FAL_RST_CTL1r_FAL_LN_H_RSTBf_SET BCMI_MADURA_FAL_RST_CTL1r_FAL_LN_H_RSTBf_SET
#define READ_FAL_RST_CTL1r BCMI_MADURA_READ_FAL_RST_CTL1r
#define WRITE_FAL_RST_CTL1r BCMI_MADURA_WRITE_FAL_RST_CTL1r
#define MODIFY_FAL_RST_CTL1r BCMI_MADURA_MODIFY_FAL_RST_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FAL_RST_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PI_XFR_RX_RSTB_FRC
 * BLOCKS:   DP
 * REGADDR:  0xa339
 * DEVAD:    1
 * DESC:     force bits for pi transfer resets
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PI_XFR_LRX_RSTB_FRC Force bits for resetting the line side pi_xfr. Overrides the automatic valuebit[7:4]  Line RX lane[7:4]bit[3:0]  Line RX lane[3:0]
 *     PI_XFR_SRX_RSTB_FRC Force bits for resetting the system side pi_xfr. Overrides the automatic valuebits[15:12]  System RX lane[7:4]bits[11:8]   System RX lane[3:0]
 */
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr (0x0001a339 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_SIZE 4

/*
 * This structure should be used to declare and program PI_XFR_RX_RSTB_FRC.
 */
typedef union BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_s {
	uint32_t v[1];
	uint32_t pi_xfr_rx_rstb_frc[1];
	uint32_t _pi_xfr_rx_rstb_frc;
} BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_t;

#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_CLR(r) (r).pi_xfr_rx_rstb_frc[0] = 0
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_SET(r,d) (r).pi_xfr_rx_rstb_frc[0] = d
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_GET(r) (r).pi_xfr_rx_rstb_frc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_SRX_RSTB_FRCf_GET(r) ((((r).pi_xfr_rx_rstb_frc[0]) >> 8) & 0xff)
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_SRX_RSTB_FRCf_SET(r,f) (r).pi_xfr_rx_rstb_frc[0]=(((r).pi_xfr_rx_rstb_frc[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_LRX_RSTB_FRCf_GET(r) (((r).pi_xfr_rx_rstb_frc[0]) & 0xff)
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_LRX_RSTB_FRCf_SET(r,f) (r).pi_xfr_rx_rstb_frc[0]=(((r).pi_xfr_rx_rstb_frc[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PI_XFR_RX_RSTB_FRC.
 */
#define BCMI_MADURA_READ_PI_XFR_RX_RSTB_FRCr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PI_XFR_RX_RSTB_FRCr,_r._pi_xfr_rx_rstb_frc)
#define BCMI_MADURA_WRITE_PI_XFR_RX_RSTB_FRCr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PI_XFR_RX_RSTB_FRCr,_r._pi_xfr_rx_rstb_frc)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PI_XFR_RX_RSTB_FRCr BCMI_MADURA_PI_XFR_RX_RSTB_FRCr
#define PI_XFR_RX_RSTB_FRCr_SIZE BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_SIZE
typedef BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_t PI_XFR_RX_RSTB_FRCr_t;
#define PI_XFR_RX_RSTB_FRCr_CLR BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_CLR
#define PI_XFR_RX_RSTB_FRCr_SET BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_SET
#define PI_XFR_RX_RSTB_FRCr_GET BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_GET
#define PI_XFR_RX_RSTB_FRCr_PI_XFR_SRX_RSTB_FRCf_GET BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_SRX_RSTB_FRCf_GET
#define PI_XFR_RX_RSTB_FRCr_PI_XFR_SRX_RSTB_FRCf_SET BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_SRX_RSTB_FRCf_SET
#define PI_XFR_RX_RSTB_FRCr_PI_XFR_LRX_RSTB_FRCf_GET BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_LRX_RSTB_FRCf_GET
#define PI_XFR_RX_RSTB_FRCr_PI_XFR_LRX_RSTB_FRCf_SET BCMI_MADURA_PI_XFR_RX_RSTB_FRCr_PI_XFR_LRX_RSTB_FRCf_SET
#define READ_PI_XFR_RX_RSTB_FRCr BCMI_MADURA_READ_PI_XFR_RX_RSTB_FRCr
#define WRITE_PI_XFR_RX_RSTB_FRCr BCMI_MADURA_WRITE_PI_XFR_RX_RSTB_FRCr
#define MODIFY_PI_XFR_RX_RSTB_FRCr BCMI_MADURA_MODIFY_PI_XFR_RX_RSTB_FRCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PI_XFR_RX_RSTB_FRCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PI_XFR_RX_RSTB_FRCVAL
 * BLOCKS:   DP
 * REGADDR:  0xa33a
 * DEVAD:    1
 * DESC:     force value bits for pi transfer resets
 * RESETVAL: 0xffff (65535)
 * ACCESS:   R/W
 * FIELDS:
 *     PI_XFR_LRX_RSTB_FRCVAL Forced values for resetting the line side pi_xfr. Overrides the automatic valuebit[7:4]  Line RX lane[7:4]bit[3:0]  Line RX lane[3:0]
 *     PI_XFR_SRX_RSTB_FRCVAL Forced values for resetting the system side pi_xfr. Overrides the automatic valuebits[15:12]  System RX lane[7:4]bits[11:8]   System RX lane[3:0]
 */
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr (0x0001a33a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_SIZE 4

/*
 * This structure should be used to declare and program PI_XFR_RX_RSTB_FRCVAL.
 */
typedef union BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_s {
	uint32_t v[1];
	uint32_t pi_xfr_rx_rstb_frcval[1];
	uint32_t _pi_xfr_rx_rstb_frcval;
} BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_t;

#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_CLR(r) (r).pi_xfr_rx_rstb_frcval[0] = 0
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_SET(r,d) (r).pi_xfr_rx_rstb_frcval[0] = d
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_GET(r) (r).pi_xfr_rx_rstb_frcval[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_SRX_RSTB_FRCVALf_GET(r) ((((r).pi_xfr_rx_rstb_frcval[0]) >> 8) & 0xff)
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_SRX_RSTB_FRCVALf_SET(r,f) (r).pi_xfr_rx_rstb_frcval[0]=(((r).pi_xfr_rx_rstb_frcval[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_LRX_RSTB_FRCVALf_GET(r) (((r).pi_xfr_rx_rstb_frcval[0]) & 0xff)
#define BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_LRX_RSTB_FRCVALf_SET(r,f) (r).pi_xfr_rx_rstb_frcval[0]=(((r).pi_xfr_rx_rstb_frcval[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PI_XFR_RX_RSTB_FRCVAL.
 */
#define BCMI_MADURA_READ_PI_XFR_RX_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr,_r._pi_xfr_rx_rstb_frcval)
#define BCMI_MADURA_WRITE_PI_XFR_RX_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr,_r._pi_xfr_rx_rstb_frcval)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PI_XFR_RX_RSTB_FRCVALr BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr
#define PI_XFR_RX_RSTB_FRCVALr_SIZE BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_SIZE
typedef BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_t PI_XFR_RX_RSTB_FRCVALr_t;
#define PI_XFR_RX_RSTB_FRCVALr_CLR BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_CLR
#define PI_XFR_RX_RSTB_FRCVALr_SET BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_SET
#define PI_XFR_RX_RSTB_FRCVALr_GET BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_GET
#define PI_XFR_RX_RSTB_FRCVALr_PI_XFR_SRX_RSTB_FRCVALf_GET BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_SRX_RSTB_FRCVALf_GET
#define PI_XFR_RX_RSTB_FRCVALr_PI_XFR_SRX_RSTB_FRCVALf_SET BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_SRX_RSTB_FRCVALf_SET
#define PI_XFR_RX_RSTB_FRCVALr_PI_XFR_LRX_RSTB_FRCVALf_GET BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_LRX_RSTB_FRCVALf_GET
#define PI_XFR_RX_RSTB_FRCVALr_PI_XFR_LRX_RSTB_FRCVALf_SET BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr_PI_XFR_LRX_RSTB_FRCVALf_SET
#define READ_PI_XFR_RX_RSTB_FRCVALr BCMI_MADURA_READ_PI_XFR_RX_RSTB_FRCVALr
#define WRITE_PI_XFR_RX_RSTB_FRCVALr BCMI_MADURA_WRITE_PI_XFR_RX_RSTB_FRCVALr
#define MODIFY_PI_XFR_RX_RSTB_FRCVALr BCMI_MADURA_MODIFY_PI_XFR_RX_RSTB_FRCVALr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PI_XFR_RX_RSTB_FRCVALr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PI_XFR_RX_RSTB_SEL
 * BLOCKS:   DP
 * REGADDR:  0xa33b
 * DEVAD:    1
 * DESC:     selects which reset to use if not using force for pi_xfr block
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PI_XFR_LRX_RSTB_SELECT selects which reset to use if not using force for line pi_xfr block2'b00 selects lin_fal_pmd_rx_clk_vld2'b01 selects lin_fal_pmd_rx_lock2'b10 selects lin_fal_pmd_rx_lock & lin_fal_pmd_rx_clk_vld2'b11 selects lin_fal_pmd_rx_clk_vld
 *     PI_XFR_SRX_RSTB_SELECT selects which reset to use if not using force for system pi_xfr block2'b00 selects sys_fal_pmd_rx_clk_vld2'b01 selects sys_fal_pmd_rx_lock2'b10 selects sys_fal_pmd_rx_lock & sys_fal_pmd_rx_clk_vld2'b11 selects sys_fal_pmd_rx_clk_vld
 */
#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr (0x0001a33b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_SIZE 4

/*
 * This structure should be used to declare and program PI_XFR_RX_RSTB_SEL.
 */
typedef union BCMI_MADURA_PI_XFR_RX_RSTB_SELr_s {
	uint32_t v[1];
	uint32_t pi_xfr_rx_rstb_sel[1];
	uint32_t _pi_xfr_rx_rstb_sel;
} BCMI_MADURA_PI_XFR_RX_RSTB_SELr_t;

#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_CLR(r) (r).pi_xfr_rx_rstb_sel[0] = 0
#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_SET(r,d) (r).pi_xfr_rx_rstb_sel[0] = d
#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_GET(r) (r).pi_xfr_rx_rstb_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_SRX_RSTB_SELECTf_GET(r) ((((r).pi_xfr_rx_rstb_sel[0]) >> 4) & 0x3)
#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_SRX_RSTB_SELECTf_SET(r,f) (r).pi_xfr_rx_rstb_sel[0]=(((r).pi_xfr_rx_rstb_sel[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_LRX_RSTB_SELECTf_GET(r) (((r).pi_xfr_rx_rstb_sel[0]) & 0x3)
#define BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_LRX_RSTB_SELECTf_SET(r,f) (r).pi_xfr_rx_rstb_sel[0]=(((r).pi_xfr_rx_rstb_sel[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PI_XFR_RX_RSTB_SEL.
 */
#define BCMI_MADURA_READ_PI_XFR_RX_RSTB_SELr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PI_XFR_RX_RSTB_SELr,_r._pi_xfr_rx_rstb_sel)
#define BCMI_MADURA_WRITE_PI_XFR_RX_RSTB_SELr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PI_XFR_RX_RSTB_SELr,_r._pi_xfr_rx_rstb_sel)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PI_XFR_RX_RSTB_SELr BCMI_MADURA_PI_XFR_RX_RSTB_SELr
#define PI_XFR_RX_RSTB_SELr_SIZE BCMI_MADURA_PI_XFR_RX_RSTB_SELr_SIZE
typedef BCMI_MADURA_PI_XFR_RX_RSTB_SELr_t PI_XFR_RX_RSTB_SELr_t;
#define PI_XFR_RX_RSTB_SELr_CLR BCMI_MADURA_PI_XFR_RX_RSTB_SELr_CLR
#define PI_XFR_RX_RSTB_SELr_SET BCMI_MADURA_PI_XFR_RX_RSTB_SELr_SET
#define PI_XFR_RX_RSTB_SELr_GET BCMI_MADURA_PI_XFR_RX_RSTB_SELr_GET
#define PI_XFR_RX_RSTB_SELr_PI_XFR_SRX_RSTB_SELECTf_GET BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_SRX_RSTB_SELECTf_GET
#define PI_XFR_RX_RSTB_SELr_PI_XFR_SRX_RSTB_SELECTf_SET BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_SRX_RSTB_SELECTf_SET
#define PI_XFR_RX_RSTB_SELr_PI_XFR_LRX_RSTB_SELECTf_GET BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_LRX_RSTB_SELECTf_GET
#define PI_XFR_RX_RSTB_SELr_PI_XFR_LRX_RSTB_SELECTf_SET BCMI_MADURA_PI_XFR_RX_RSTB_SELr_PI_XFR_LRX_RSTB_SELECTf_SET
#define READ_PI_XFR_RX_RSTB_SELr BCMI_MADURA_READ_PI_XFR_RX_RSTB_SELr
#define WRITE_PI_XFR_RX_RSTB_SELr BCMI_MADURA_WRITE_PI_XFR_RX_RSTB_SELr
#define MODIFY_PI_XFR_RX_RSTB_SELr BCMI_MADURA_MODIFY_PI_XFR_RX_RSTB_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PI_XFR_RX_RSTB_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_AN_PF_DP_RSTB_FRC
 * BLOCKS:   DP
 * REGADDR:  0xa33c
 * DEVAD:    1
 * DESC:     force bits for tx_an_pf_dp resets
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_FAL_0_TX_AN_PF_DP_RSTB_FRC 
 *     LIN_FAL_1_TX_AN_PF_DP_RSTB_FRC 
 *     SYS_FAL_0_TX_AN_PF_DP_RSTB_FRC 
 *     SYS_FAL_1_TX_AN_PF_DP_RSTB_FRC 
 */
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr (0x0001a33c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SIZE 4

/*
 * This structure should be used to declare and program TX_AN_PF_DP_RSTB_FRC.
 */
typedef union BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_s {
	uint32_t v[1];
	uint32_t tx_an_pf_dp_rstb_frc[1];
	uint32_t _tx_an_pf_dp_rstb_frc;
} BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_t;

#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_CLR(r) (r).tx_an_pf_dp_rstb_frc[0] = 0
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SET(r,d) (r).tx_an_pf_dp_rstb_frc[0] = d
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_GET(r) (r).tx_an_pf_dp_rstb_frc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCf_GET(r) ((((r).tx_an_pf_dp_rstb_frc[0]) >> 3) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCf_SET(r,f) (r).tx_an_pf_dp_rstb_frc[0]=(((r).tx_an_pf_dp_rstb_frc[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCf_GET(r) ((((r).tx_an_pf_dp_rstb_frc[0]) >> 2) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCf_SET(r,f) (r).tx_an_pf_dp_rstb_frc[0]=(((r).tx_an_pf_dp_rstb_frc[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCf_GET(r) ((((r).tx_an_pf_dp_rstb_frc[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCf_SET(r,f) (r).tx_an_pf_dp_rstb_frc[0]=(((r).tx_an_pf_dp_rstb_frc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCf_GET(r) (((r).tx_an_pf_dp_rstb_frc[0]) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCf_SET(r,f) (r).tx_an_pf_dp_rstb_frc[0]=(((r).tx_an_pf_dp_rstb_frc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_AN_PF_DP_RSTB_FRC.
 */
#define BCMI_MADURA_READ_TX_AN_PF_DP_RSTB_FRCr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr,_r._tx_an_pf_dp_rstb_frc)
#define BCMI_MADURA_WRITE_TX_AN_PF_DP_RSTB_FRCr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr,_r._tx_an_pf_dp_rstb_frc)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_AN_PF_DP_RSTB_FRCr BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr
#define TX_AN_PF_DP_RSTB_FRCr_SIZE BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SIZE
typedef BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_t TX_AN_PF_DP_RSTB_FRCr_t;
#define TX_AN_PF_DP_RSTB_FRCr_CLR BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_CLR
#define TX_AN_PF_DP_RSTB_FRCr_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SET
#define TX_AN_PF_DP_RSTB_FRCr_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_GET
#define TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCf_GET
#define TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCf_SET
#define TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCf_GET
#define TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCf_SET
#define TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCf_GET
#define TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCf_SET
#define TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCf_GET
#define TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCf_SET
#define READ_TX_AN_PF_DP_RSTB_FRCr BCMI_MADURA_READ_TX_AN_PF_DP_RSTB_FRCr
#define WRITE_TX_AN_PF_DP_RSTB_FRCr BCMI_MADURA_WRITE_TX_AN_PF_DP_RSTB_FRCr
#define MODIFY_TX_AN_PF_DP_RSTB_FRCr BCMI_MADURA_MODIFY_TX_AN_PF_DP_RSTB_FRCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_AN_PF_DP_RSTB_FRCVAL
 * BLOCKS:   DP
 * REGADDR:  0xa33d
 * DEVAD:    1
 * DESC:     force value bits for tx_an_pf_dp resets
 * RESETVAL: 0xf (15)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCVAL 
 *     LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCVAL 
 *     SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCVAL 
 *     SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCVAL 
 */
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr (0x0001a33d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SIZE 4

/*
 * This structure should be used to declare and program TX_AN_PF_DP_RSTB_FRCVAL.
 */
typedef union BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_s {
	uint32_t v[1];
	uint32_t tx_an_pf_dp_rstb_frcval[1];
	uint32_t _tx_an_pf_dp_rstb_frcval;
} BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_t;

#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_CLR(r) (r).tx_an_pf_dp_rstb_frcval[0] = 0
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SET(r,d) (r).tx_an_pf_dp_rstb_frcval[0] = d
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_GET(r) (r).tx_an_pf_dp_rstb_frcval[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_GET(r) ((((r).tx_an_pf_dp_rstb_frcval[0]) >> 3) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_SET(r,f) (r).tx_an_pf_dp_rstb_frcval[0]=(((r).tx_an_pf_dp_rstb_frcval[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_GET(r) ((((r).tx_an_pf_dp_rstb_frcval[0]) >> 2) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_SET(r,f) (r).tx_an_pf_dp_rstb_frcval[0]=(((r).tx_an_pf_dp_rstb_frcval[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_GET(r) ((((r).tx_an_pf_dp_rstb_frcval[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_SET(r,f) (r).tx_an_pf_dp_rstb_frcval[0]=(((r).tx_an_pf_dp_rstb_frcval[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_GET(r) (((r).tx_an_pf_dp_rstb_frcval[0]) & 0x1)
#define BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_SET(r,f) (r).tx_an_pf_dp_rstb_frcval[0]=(((r).tx_an_pf_dp_rstb_frcval[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_AN_PF_DP_RSTB_FRCVAL.
 */
#define BCMI_MADURA_READ_TX_AN_PF_DP_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr,_r._tx_an_pf_dp_rstb_frcval)
#define BCMI_MADURA_WRITE_TX_AN_PF_DP_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr,_r._tx_an_pf_dp_rstb_frcval)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_AN_PF_DP_RSTB_FRCVALr BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr
#define TX_AN_PF_DP_RSTB_FRCVALr_SIZE BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SIZE
typedef BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_t TX_AN_PF_DP_RSTB_FRCVALr_t;
#define TX_AN_PF_DP_RSTB_FRCVALr_CLR BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_CLR
#define TX_AN_PF_DP_RSTB_FRCVALr_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SET
#define TX_AN_PF_DP_RSTB_FRCVALr_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_GET
#define TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_GET
#define TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_SET
#define TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_GET
#define TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_SYS_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_SET
#define TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_GET
#define TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_1_TX_AN_PF_DP_RSTB_FRCVALf_SET
#define TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_GET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_GET
#define TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_SET BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr_LIN_FAL_0_TX_AN_PF_DP_RSTB_FRCVALf_SET
#define READ_TX_AN_PF_DP_RSTB_FRCVALr BCMI_MADURA_READ_TX_AN_PF_DP_RSTB_FRCVALr
#define WRITE_TX_AN_PF_DP_RSTB_FRCVALr BCMI_MADURA_WRITE_TX_AN_PF_DP_RSTB_FRCVALr
#define MODIFY_TX_AN_PF_DP_RSTB_FRCVALr BCMI_MADURA_MODIFY_TX_AN_PF_DP_RSTB_FRCVALr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_AN_PF_DP_RSTB_FRCVALr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_AN_PF_RD_RSTB_FRC
 * BLOCKS:   DP
 * REGADDR:  0xa33e
 * DEVAD:    1
 * DESC:     force bits for tx_an_pf_rd resets
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_TX_AN_PF_RD_RSTB_0_FRC 
 *     LIN_TX_AN_PF_RD_RSTB_1_FRC 
 *     SYS_TX_AN_PF_RD_RSTB_0_FRC 
 *     SYS_TX_AN_PF_RD_RSTB_1_FRC 
 */
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr (0x0001a33e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SIZE 4

/*
 * This structure should be used to declare and program TX_AN_PF_RD_RSTB_FRC.
 */
typedef union BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_s {
	uint32_t v[1];
	uint32_t tx_an_pf_rd_rstb_frc[1];
	uint32_t _tx_an_pf_rd_rstb_frc;
} BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_t;

#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_CLR(r) (r).tx_an_pf_rd_rstb_frc[0] = 0
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SET(r,d) (r).tx_an_pf_rd_rstb_frc[0] = d
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_GET(r) (r).tx_an_pf_rd_rstb_frc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_1_FRCf_GET(r) ((((r).tx_an_pf_rd_rstb_frc[0]) >> 12) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_1_FRCf_SET(r,f) (r).tx_an_pf_rd_rstb_frc[0]=(((r).tx_an_pf_rd_rstb_frc[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_0_FRCf_GET(r) ((((r).tx_an_pf_rd_rstb_frc[0]) >> 8) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_0_FRCf_SET(r,f) (r).tx_an_pf_rd_rstb_frc[0]=(((r).tx_an_pf_rd_rstb_frc[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_1_FRCf_GET(r) ((((r).tx_an_pf_rd_rstb_frc[0]) >> 4) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_1_FRCf_SET(r,f) (r).tx_an_pf_rd_rstb_frc[0]=(((r).tx_an_pf_rd_rstb_frc[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_0_FRCf_GET(r) (((r).tx_an_pf_rd_rstb_frc[0]) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_0_FRCf_SET(r,f) (r).tx_an_pf_rd_rstb_frc[0]=(((r).tx_an_pf_rd_rstb_frc[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_AN_PF_RD_RSTB_FRC.
 */
#define BCMI_MADURA_READ_TX_AN_PF_RD_RSTB_FRCr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr,_r._tx_an_pf_rd_rstb_frc)
#define BCMI_MADURA_WRITE_TX_AN_PF_RD_RSTB_FRCr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr,_r._tx_an_pf_rd_rstb_frc)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_AN_PF_RD_RSTB_FRCr BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr
#define TX_AN_PF_RD_RSTB_FRCr_SIZE BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SIZE
typedef BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_t TX_AN_PF_RD_RSTB_FRCr_t;
#define TX_AN_PF_RD_RSTB_FRCr_CLR BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_CLR
#define TX_AN_PF_RD_RSTB_FRCr_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SET
#define TX_AN_PF_RD_RSTB_FRCr_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_GET
#define TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_1_FRCf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_1_FRCf_GET
#define TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_1_FRCf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_1_FRCf_SET
#define TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_0_FRCf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_0_FRCf_GET
#define TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_0_FRCf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_SYS_TX_AN_PF_RD_RSTB_0_FRCf_SET
#define TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_1_FRCf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_1_FRCf_GET
#define TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_1_FRCf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_1_FRCf_SET
#define TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_0_FRCf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_0_FRCf_GET
#define TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_0_FRCf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr_LIN_TX_AN_PF_RD_RSTB_0_FRCf_SET
#define READ_TX_AN_PF_RD_RSTB_FRCr BCMI_MADURA_READ_TX_AN_PF_RD_RSTB_FRCr
#define WRITE_TX_AN_PF_RD_RSTB_FRCr BCMI_MADURA_WRITE_TX_AN_PF_RD_RSTB_FRCr
#define MODIFY_TX_AN_PF_RD_RSTB_FRCr BCMI_MADURA_MODIFY_TX_AN_PF_RD_RSTB_FRCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_AN_PF_RD_RSTB_FRCVAL
 * BLOCKS:   DP
 * REGADDR:  0xa33f
 * DEVAD:    1
 * DESC:     force value bits for tx_an_pf_rd resets
 * RESETVAL: 0xffff (65535)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_TX_AN_PF_RD_RSTB_0_FRCVAL 
 *     LIN_TX_AN_PF_RD_RSTB_1_FRCVAL 
 *     SYS_TX_AN_PF_RD_RSTB_0_FRCVAL 
 *     SYS_TX_AN_PF_RD_RSTB_1_FRCVAL 
 */
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr (0x0001a33f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SIZE 4

/*
 * This structure should be used to declare and program TX_AN_PF_RD_RSTB_FRCVAL.
 */
typedef union BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_s {
	uint32_t v[1];
	uint32_t tx_an_pf_rd_rstb_frcval[1];
	uint32_t _tx_an_pf_rd_rstb_frcval;
} BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_t;

#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_CLR(r) (r).tx_an_pf_rd_rstb_frcval[0] = 0
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SET(r,d) (r).tx_an_pf_rd_rstb_frcval[0] = d
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_GET(r) (r).tx_an_pf_rd_rstb_frcval[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_1_FRCVALf_GET(r) ((((r).tx_an_pf_rd_rstb_frcval[0]) >> 12) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_1_FRCVALf_SET(r,f) (r).tx_an_pf_rd_rstb_frcval[0]=(((r).tx_an_pf_rd_rstb_frcval[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_0_FRCVALf_GET(r) ((((r).tx_an_pf_rd_rstb_frcval[0]) >> 8) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_0_FRCVALf_SET(r,f) (r).tx_an_pf_rd_rstb_frcval[0]=(((r).tx_an_pf_rd_rstb_frcval[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_1_FRCVALf_GET(r) ((((r).tx_an_pf_rd_rstb_frcval[0]) >> 4) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_1_FRCVALf_SET(r,f) (r).tx_an_pf_rd_rstb_frcval[0]=(((r).tx_an_pf_rd_rstb_frcval[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_0_FRCVALf_GET(r) (((r).tx_an_pf_rd_rstb_frcval[0]) & 0xf)
#define BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_0_FRCVALf_SET(r,f) (r).tx_an_pf_rd_rstb_frcval[0]=(((r).tx_an_pf_rd_rstb_frcval[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_AN_PF_RD_RSTB_FRCVAL.
 */
#define BCMI_MADURA_READ_TX_AN_PF_RD_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr,_r._tx_an_pf_rd_rstb_frcval)
#define BCMI_MADURA_WRITE_TX_AN_PF_RD_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr,_r._tx_an_pf_rd_rstb_frcval)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_AN_PF_RD_RSTB_FRCVALr BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr
#define TX_AN_PF_RD_RSTB_FRCVALr_SIZE BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SIZE
typedef BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_t TX_AN_PF_RD_RSTB_FRCVALr_t;
#define TX_AN_PF_RD_RSTB_FRCVALr_CLR BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_CLR
#define TX_AN_PF_RD_RSTB_FRCVALr_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SET
#define TX_AN_PF_RD_RSTB_FRCVALr_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_GET
#define TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_1_FRCVALf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_1_FRCVALf_GET
#define TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_1_FRCVALf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_1_FRCVALf_SET
#define TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_0_FRCVALf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_0_FRCVALf_GET
#define TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_0_FRCVALf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_SYS_TX_AN_PF_RD_RSTB_0_FRCVALf_SET
#define TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_1_FRCVALf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_1_FRCVALf_GET
#define TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_1_FRCVALf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_1_FRCVALf_SET
#define TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_0_FRCVALf_GET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_0_FRCVALf_GET
#define TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_0_FRCVALf_SET BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr_LIN_TX_AN_PF_RD_RSTB_0_FRCVALf_SET
#define READ_TX_AN_PF_RD_RSTB_FRCVALr BCMI_MADURA_READ_TX_AN_PF_RD_RSTB_FRCVALr
#define WRITE_TX_AN_PF_RD_RSTB_FRCVALr BCMI_MADURA_WRITE_TX_AN_PF_RD_RSTB_FRCVALr
#define MODIFY_TX_AN_PF_RD_RSTB_FRCVALr BCMI_MADURA_MODIFY_TX_AN_PF_RD_RSTB_FRCVALr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_AN_PF_RD_RSTB_FRCVALr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_MON_RX_RSTB_FRC
 * BLOCKS:   DP
 * REGADDR:  0xa340
 * DEVAD:    1
 * DESC:     force bits for pcs mon resets
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_FAL_PCS_MON_RSTB_FRC Force bits for resetting the line side pcs_mon. Overrides the automatic valuebit[7:4]  Line lane[7:4]bit[3:0]  Line lane[3:0]
 *     SYS_FAL_PCS_MON_RSTB_FRC Force bits for resetting the system side pcs_mon. Overrides the automatic valuebits[15:12]  System lane[7:4]bits[11:8]   System lane[3:0]
 */
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr (0x0001a340 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SIZE 4

/*
 * This structure should be used to declare and program PCS_MON_RX_RSTB_FRC.
 */
typedef union BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_s {
	uint32_t v[1];
	uint32_t pcs_mon_rx_rstb_frc[1];
	uint32_t _pcs_mon_rx_rstb_frc;
} BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_t;

#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_CLR(r) (r).pcs_mon_rx_rstb_frc[0] = 0
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SET(r,d) (r).pcs_mon_rx_rstb_frc[0] = d
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_GET(r) (r).pcs_mon_rx_rstb_frc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SYS_FAL_PCS_MON_RSTB_FRCf_GET(r) ((((r).pcs_mon_rx_rstb_frc[0]) >> 8) & 0xff)
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SYS_FAL_PCS_MON_RSTB_FRCf_SET(r,f) (r).pcs_mon_rx_rstb_frc[0]=(((r).pcs_mon_rx_rstb_frc[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_LIN_FAL_PCS_MON_RSTB_FRCf_GET(r) (((r).pcs_mon_rx_rstb_frc[0]) & 0xff)
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_LIN_FAL_PCS_MON_RSTB_FRCf_SET(r,f) (r).pcs_mon_rx_rstb_frc[0]=(((r).pcs_mon_rx_rstb_frc[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PCS_MON_RX_RSTB_FRC.
 */
#define BCMI_MADURA_READ_PCS_MON_RX_RSTB_FRCr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_MON_RX_RSTB_FRCr,_r._pcs_mon_rx_rstb_frc)
#define BCMI_MADURA_WRITE_PCS_MON_RX_RSTB_FRCr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_MON_RX_RSTB_FRCr,_r._pcs_mon_rx_rstb_frc)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_MON_RX_RSTB_FRCr BCMI_MADURA_PCS_MON_RX_RSTB_FRCr
#define PCS_MON_RX_RSTB_FRCr_SIZE BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SIZE
typedef BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_t PCS_MON_RX_RSTB_FRCr_t;
#define PCS_MON_RX_RSTB_FRCr_CLR BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_CLR
#define PCS_MON_RX_RSTB_FRCr_SET BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SET
#define PCS_MON_RX_RSTB_FRCr_GET BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_GET
#define PCS_MON_RX_RSTB_FRCr_SYS_FAL_PCS_MON_RSTB_FRCf_GET BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SYS_FAL_PCS_MON_RSTB_FRCf_GET
#define PCS_MON_RX_RSTB_FRCr_SYS_FAL_PCS_MON_RSTB_FRCf_SET BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_SYS_FAL_PCS_MON_RSTB_FRCf_SET
#define PCS_MON_RX_RSTB_FRCr_LIN_FAL_PCS_MON_RSTB_FRCf_GET BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_LIN_FAL_PCS_MON_RSTB_FRCf_GET
#define PCS_MON_RX_RSTB_FRCr_LIN_FAL_PCS_MON_RSTB_FRCf_SET BCMI_MADURA_PCS_MON_RX_RSTB_FRCr_LIN_FAL_PCS_MON_RSTB_FRCf_SET
#define READ_PCS_MON_RX_RSTB_FRCr BCMI_MADURA_READ_PCS_MON_RX_RSTB_FRCr
#define WRITE_PCS_MON_RX_RSTB_FRCr BCMI_MADURA_WRITE_PCS_MON_RX_RSTB_FRCr
#define MODIFY_PCS_MON_RX_RSTB_FRCr BCMI_MADURA_MODIFY_PCS_MON_RX_RSTB_FRCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_MON_RX_RSTB_FRCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_MON_RX_RSTB_FRCVAL
 * BLOCKS:   DP
 * REGADDR:  0xa341
 * DEVAD:    1
 * DESC:     force value bits for pcs mon resets
 * RESETVAL: 0xffff (65535)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_FAL_PCS_MON_RSTB_FRCVAL Forced values for resetting the line side pcs_mon. Overrides the automatic valuebit[7:4]  Line lane[7:4]bit[3:0]  Line lane[3:0]
 *     SYS_FAL_PCS_MON_RSTB_FRCVAL Forced values for resetting the system side pcs_mon. Overrides the automatic valuebits[15:12]  System lane[7:4]bits[11:8]   System lane[3:0]
 */
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr (0x0001a341 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SIZE 4

/*
 * This structure should be used to declare and program PCS_MON_RX_RSTB_FRCVAL.
 */
typedef union BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_s {
	uint32_t v[1];
	uint32_t pcs_mon_rx_rstb_frcval[1];
	uint32_t _pcs_mon_rx_rstb_frcval;
} BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_t;

#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_CLR(r) (r).pcs_mon_rx_rstb_frcval[0] = 0
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SET(r,d) (r).pcs_mon_rx_rstb_frcval[0] = d
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_GET(r) (r).pcs_mon_rx_rstb_frcval[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SYS_FAL_PCS_MON_RSTB_FRCVALf_GET(r) ((((r).pcs_mon_rx_rstb_frcval[0]) >> 8) & 0xff)
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SYS_FAL_PCS_MON_RSTB_FRCVALf_SET(r,f) (r).pcs_mon_rx_rstb_frcval[0]=(((r).pcs_mon_rx_rstb_frcval[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_LIN_FAL_PCS_MON_RSTB_FRCVALf_GET(r) (((r).pcs_mon_rx_rstb_frcval[0]) & 0xff)
#define BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_LIN_FAL_PCS_MON_RSTB_FRCVALf_SET(r,f) (r).pcs_mon_rx_rstb_frcval[0]=(((r).pcs_mon_rx_rstb_frcval[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PCS_MON_RX_RSTB_FRCVAL.
 */
#define BCMI_MADURA_READ_PCS_MON_RX_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr,_r._pcs_mon_rx_rstb_frcval)
#define BCMI_MADURA_WRITE_PCS_MON_RX_RSTB_FRCVALr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr,_r._pcs_mon_rx_rstb_frcval)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_MON_RX_RSTB_FRCVALr BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr
#define PCS_MON_RX_RSTB_FRCVALr_SIZE BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SIZE
typedef BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_t PCS_MON_RX_RSTB_FRCVALr_t;
#define PCS_MON_RX_RSTB_FRCVALr_CLR BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_CLR
#define PCS_MON_RX_RSTB_FRCVALr_SET BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SET
#define PCS_MON_RX_RSTB_FRCVALr_GET BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_GET
#define PCS_MON_RX_RSTB_FRCVALr_SYS_FAL_PCS_MON_RSTB_FRCVALf_GET BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SYS_FAL_PCS_MON_RSTB_FRCVALf_GET
#define PCS_MON_RX_RSTB_FRCVALr_SYS_FAL_PCS_MON_RSTB_FRCVALf_SET BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_SYS_FAL_PCS_MON_RSTB_FRCVALf_SET
#define PCS_MON_RX_RSTB_FRCVALr_LIN_FAL_PCS_MON_RSTB_FRCVALf_GET BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_LIN_FAL_PCS_MON_RSTB_FRCVALf_GET
#define PCS_MON_RX_RSTB_FRCVALr_LIN_FAL_PCS_MON_RSTB_FRCVALf_SET BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr_LIN_FAL_PCS_MON_RSTB_FRCVALf_SET
#define READ_PCS_MON_RX_RSTB_FRCVALr BCMI_MADURA_READ_PCS_MON_RX_RSTB_FRCVALr
#define WRITE_PCS_MON_RX_RSTB_FRCVALr BCMI_MADURA_WRITE_PCS_MON_RX_RSTB_FRCVALr
#define MODIFY_PCS_MON_RX_RSTB_FRCVALr BCMI_MADURA_MODIFY_PCS_MON_RX_RSTB_FRCVALr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_MON_RX_RSTB_FRCVALr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FEC_FIFO_RSTB_FRC
 * BLOCKS:   DP
 * REGADDR:  0xa342
 * DEVAD:    1
 * DESC:     force and force value bits for fec FIFO resets
 * RESETVAL: 0xf0 (240)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_TX_FIFO_RSTB_0_FRC Forced bit for resetting the fec_tx_fifo_0. Overrides the automatic value
 *     FEC_TX_FIFO_RSTB_1_FRC Forced bit for resetting the fec_tx_fifo_1. Overrides the automatic value
 *     FEC_RX_FIFO_RSTB_0_FRC Forced bit for resetting the fec_rx_fifo_0. Overrides the automatic value
 *     FEC_RX_FIFO_RSTB_1_FRC Forced bit for resetting the fec_rx_fifo_1. Overrides the automatic value
 *     FEC_TX_FIFO_RSTB_0_FRCVAL Forced value for resetting the fec_tx_fifo_0. Overrides the automatic value
 *     FEC_TX_FIFO_RSTB_1_FRCVAL Forced value for resetting the fec_tx_fifo_1. Overrides the automatic value
 *     FEC_RX_FIFO_RSTB_0_FRCVAL Forced value for resetting the fec_rx_fifo_0. Overrides the automatic value
 *     FEC_RX_FIFO_RSTB_1_FRCVAL Forced value for resetting the fec_rx_fifo_1. Overrides the automatic value
 */
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr (0x0001a342 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_SIZE 4

/*
 * This structure should be used to declare and program FEC_FIFO_RSTB_FRC.
 */
typedef union BCMI_MADURA_FEC_FIFO_RSTB_FRCr_s {
	uint32_t v[1];
	uint32_t fec_fifo_rstb_frc[1];
	uint32_t _fec_fifo_rstb_frc;
} BCMI_MADURA_FEC_FIFO_RSTB_FRCr_t;

#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_CLR(r) (r).fec_fifo_rstb_frc[0] = 0
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_SET(r,d) (r).fec_fifo_rstb_frc[0] = d
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_GET(r) (r).fec_fifo_rstb_frc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCVALf_GET(r) ((((r).fec_fifo_rstb_frc[0]) >> 7) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCVALf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCVALf_GET(r) ((((r).fec_fifo_rstb_frc[0]) >> 6) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCVALf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCVALf_GET(r) ((((r).fec_fifo_rstb_frc[0]) >> 5) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCVALf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCVALf_GET(r) ((((r).fec_fifo_rstb_frc[0]) >> 4) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCVALf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCf_GET(r) ((((r).fec_fifo_rstb_frc[0]) >> 3) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCf_GET(r) ((((r).fec_fifo_rstb_frc[0]) >> 2) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCf_GET(r) ((((r).fec_fifo_rstb_frc[0]) >> 1) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCf_GET(r) (((r).fec_fifo_rstb_frc[0]) & 0x1)
#define BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCf_SET(r,f) (r).fec_fifo_rstb_frc[0]=(((r).fec_fifo_rstb_frc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FEC_FIFO_RSTB_FRC.
 */
#define BCMI_MADURA_READ_FEC_FIFO_RSTB_FRCr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FEC_FIFO_RSTB_FRCr,_r._fec_fifo_rstb_frc)
#define BCMI_MADURA_WRITE_FEC_FIFO_RSTB_FRCr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FEC_FIFO_RSTB_FRCr,_r._fec_fifo_rstb_frc)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FEC_FIFO_RSTB_FRCr BCMI_MADURA_FEC_FIFO_RSTB_FRCr
#define FEC_FIFO_RSTB_FRCr_SIZE BCMI_MADURA_FEC_FIFO_RSTB_FRCr_SIZE
typedef BCMI_MADURA_FEC_FIFO_RSTB_FRCr_t FEC_FIFO_RSTB_FRCr_t;
#define FEC_FIFO_RSTB_FRCr_CLR BCMI_MADURA_FEC_FIFO_RSTB_FRCr_CLR
#define FEC_FIFO_RSTB_FRCr_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_SET
#define FEC_FIFO_RSTB_FRCr_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_GET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCVALf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCVALf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCVALf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCVALf_SET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCVALf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCVALf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCVALf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCVALf_SET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCVALf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCVALf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCVALf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCVALf_SET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCVALf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCVALf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCVALf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCVALf_SET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_1_FRCf_SET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_RX_FIFO_RSTB_0_FRCf_SET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_1_FRCf_SET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCf_GET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCf_GET
#define FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCf_SET BCMI_MADURA_FEC_FIFO_RSTB_FRCr_FEC_TX_FIFO_RSTB_0_FRCf_SET
#define READ_FEC_FIFO_RSTB_FRCr BCMI_MADURA_READ_FEC_FIFO_RSTB_FRCr
#define WRITE_FEC_FIFO_RSTB_FRCr BCMI_MADURA_WRITE_FEC_FIFO_RSTB_FRCr
#define MODIFY_FEC_FIFO_RSTB_FRCr BCMI_MADURA_MODIFY_FEC_FIFO_RSTB_FRCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FEC_FIFO_RSTB_FRCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_FIFO_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa343
 * DEVAD:    1
 * DESC:     AN TX FIFO configuration
 * RESETVAL: 0x30 (48)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_FIFO_AUTO_RESET_DIS AN TX FIFO auto reset at collision disable control. If set, no reset when collision happensbit 3: auto reset at collision disable control for sys_an_tx_fifo_1bit 2: auto reset at collision disable control for sys_an_tx_fifo_0bit 1: auto reset at collision disable control for lin_an_tx_fifo_1bit 0: auto reset at collision disable control for lin_an_tx_fifo_0
 *     AN_FIFO_PTR_SYNC Write pointer value use to synchronize read pointer in AN TX FIFOs\This value determines to how many cycles the read pointer is behind the write pointer
 */
#define BCMI_MADURA_AN_FIFO_CTLr (0x0001a343 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_FIFO_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_FIFO_CTL.
 */
typedef union BCMI_MADURA_AN_FIFO_CTLr_s {
	uint32_t v[1];
	uint32_t an_fifo_ctl[1];
	uint32_t _an_fifo_ctl;
} BCMI_MADURA_AN_FIFO_CTLr_t;

#define BCMI_MADURA_AN_FIFO_CTLr_CLR(r) (r).an_fifo_ctl[0] = 0
#define BCMI_MADURA_AN_FIFO_CTLr_SET(r,d) (r).an_fifo_ctl[0] = d
#define BCMI_MADURA_AN_FIFO_CTLr_GET(r) (r).an_fifo_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_PTR_SYNCf_GET(r) ((((r).an_fifo_ctl[0]) >> 4) & 0xf)
#define BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_PTR_SYNCf_SET(r,f) (r).an_fifo_ctl[0]=(((r).an_fifo_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_AUTO_RESET_DISf_GET(r) (((r).an_fifo_ctl[0]) & 0xf)
#define BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_AUTO_RESET_DISf_SET(r,f) (r).an_fifo_ctl[0]=(((r).an_fifo_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AN_FIFO_CTL.
 */
#define BCMI_MADURA_READ_AN_FIFO_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_FIFO_CTLr,_r._an_fifo_ctl)
#define BCMI_MADURA_WRITE_AN_FIFO_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_FIFO_CTLr,_r._an_fifo_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_FIFO_CTLr BCMI_MADURA_AN_FIFO_CTLr
#define AN_FIFO_CTLr_SIZE BCMI_MADURA_AN_FIFO_CTLr_SIZE
typedef BCMI_MADURA_AN_FIFO_CTLr_t AN_FIFO_CTLr_t;
#define AN_FIFO_CTLr_CLR BCMI_MADURA_AN_FIFO_CTLr_CLR
#define AN_FIFO_CTLr_SET BCMI_MADURA_AN_FIFO_CTLr_SET
#define AN_FIFO_CTLr_GET BCMI_MADURA_AN_FIFO_CTLr_GET
#define AN_FIFO_CTLr_AN_FIFO_PTR_SYNCf_GET BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_PTR_SYNCf_GET
#define AN_FIFO_CTLr_AN_FIFO_PTR_SYNCf_SET BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_PTR_SYNCf_SET
#define AN_FIFO_CTLr_AN_FIFO_AUTO_RESET_DISf_GET BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_AUTO_RESET_DISf_GET
#define AN_FIFO_CTLr_AN_FIFO_AUTO_RESET_DISf_SET BCMI_MADURA_AN_FIFO_CTLr_AN_FIFO_AUTO_RESET_DISf_SET
#define READ_AN_FIFO_CTLr BCMI_MADURA_READ_AN_FIFO_CTLr
#define WRITE_AN_FIFO_CTLr BCMI_MADURA_WRITE_AN_FIFO_CTLr
#define MODIFY_AN_FIFO_CTLr BCMI_MADURA_MODIFY_AN_FIFO_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_FIFO_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_FIFO_LH_STAT
 * BLOCKS:   DP
 * REGADDR:  0xa344
 * DEVAD:    1
 * DESC:     AN TX FIFO collision latch high status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_FIFO_COLLIDE_LH AN TX FIFO collision latch high status, cleard on readbit 15:12 collision latch high status for sys_an_tx_fifo_1bit 11:8  collision latch high status for sys_an_tx_fifo_0bit 7:4   collision latch high status for lin_an_tx_fifo_1bit 3:0   collision latch high status for lin_an_tx_fifo_0
 */
#define BCMI_MADURA_AN_FIFO_LH_STATr (0x0001a344 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_FIFO_LH_STATr_SIZE 4

/*
 * This structure should be used to declare and program AN_FIFO_LH_STAT.
 */
typedef union BCMI_MADURA_AN_FIFO_LH_STATr_s {
	uint32_t v[1];
	uint32_t an_fifo_lh_stat[1];
	uint32_t _an_fifo_lh_stat;
} BCMI_MADURA_AN_FIFO_LH_STATr_t;

#define BCMI_MADURA_AN_FIFO_LH_STATr_CLR(r) (r).an_fifo_lh_stat[0] = 0
#define BCMI_MADURA_AN_FIFO_LH_STATr_SET(r,d) (r).an_fifo_lh_stat[0] = d
#define BCMI_MADURA_AN_FIFO_LH_STATr_GET(r) (r).an_fifo_lh_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_FIFO_LH_STATr_AN_FIFO_COLLIDE_LHf_GET(r) (((r).an_fifo_lh_stat[0]) & 0xffff)
#define BCMI_MADURA_AN_FIFO_LH_STATr_AN_FIFO_COLLIDE_LHf_SET(r,f) (r).an_fifo_lh_stat[0]=(((r).an_fifo_lh_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_FIFO_LH_STAT.
 */
#define BCMI_MADURA_READ_AN_FIFO_LH_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_FIFO_LH_STATr,_r._an_fifo_lh_stat)
#define BCMI_MADURA_WRITE_AN_FIFO_LH_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_FIFO_LH_STATr,_r._an_fifo_lh_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_FIFO_LH_STATr BCMI_MADURA_AN_FIFO_LH_STATr
#define AN_FIFO_LH_STATr_SIZE BCMI_MADURA_AN_FIFO_LH_STATr_SIZE
typedef BCMI_MADURA_AN_FIFO_LH_STATr_t AN_FIFO_LH_STATr_t;
#define AN_FIFO_LH_STATr_CLR BCMI_MADURA_AN_FIFO_LH_STATr_CLR
#define AN_FIFO_LH_STATr_SET BCMI_MADURA_AN_FIFO_LH_STATr_SET
#define AN_FIFO_LH_STATr_GET BCMI_MADURA_AN_FIFO_LH_STATr_GET
#define AN_FIFO_LH_STATr_AN_FIFO_COLLIDE_LHf_GET BCMI_MADURA_AN_FIFO_LH_STATr_AN_FIFO_COLLIDE_LHf_GET
#define AN_FIFO_LH_STATr_AN_FIFO_COLLIDE_LHf_SET BCMI_MADURA_AN_FIFO_LH_STATr_AN_FIFO_COLLIDE_LHf_SET
#define READ_AN_FIFO_LH_STATr BCMI_MADURA_READ_AN_FIFO_LH_STATr
#define WRITE_AN_FIFO_LH_STATr BCMI_MADURA_WRITE_AN_FIFO_LH_STATr
#define MODIFY_AN_FIFO_LH_STATr BCMI_MADURA_MODIFY_AN_FIFO_LH_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_FIFO_LH_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_FIFO_STAT
 * BLOCKS:   DP
 * REGADDR:  0xa345
 * DEVAD:    1
 * DESC:     AN TX FIFO clooision live status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_FIFO_COLLIDE  AN TX FIFO collision live status, cleard on readbit 15:12 collision live status for sys_an_tx_fifo_1bit 11:8  collision live status for sys_an_tx_fifo_0bit 7:4   collision live status for lin_an_tx_fifo_1bit 3:0   collision live status for lin_an_tx_fifo_0
 */
#define BCMI_MADURA_AN_FIFO_STATr (0x0001a345 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_FIFO_STATr_SIZE 4

/*
 * This structure should be used to declare and program AN_FIFO_STAT.
 */
typedef union BCMI_MADURA_AN_FIFO_STATr_s {
	uint32_t v[1];
	uint32_t an_fifo_stat[1];
	uint32_t _an_fifo_stat;
} BCMI_MADURA_AN_FIFO_STATr_t;

#define BCMI_MADURA_AN_FIFO_STATr_CLR(r) (r).an_fifo_stat[0] = 0
#define BCMI_MADURA_AN_FIFO_STATr_SET(r,d) (r).an_fifo_stat[0] = d
#define BCMI_MADURA_AN_FIFO_STATr_GET(r) (r).an_fifo_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_FIFO_STATr_AN_FIFO_COLLIDEf_GET(r) (((r).an_fifo_stat[0]) & 0xffff)
#define BCMI_MADURA_AN_FIFO_STATr_AN_FIFO_COLLIDEf_SET(r,f) (r).an_fifo_stat[0]=(((r).an_fifo_stat[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_FIFO_STAT.
 */
#define BCMI_MADURA_READ_AN_FIFO_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_FIFO_STATr,_r._an_fifo_stat)
#define BCMI_MADURA_WRITE_AN_FIFO_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_FIFO_STATr,_r._an_fifo_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_FIFO_STATr BCMI_MADURA_AN_FIFO_STATr
#define AN_FIFO_STATr_SIZE BCMI_MADURA_AN_FIFO_STATr_SIZE
typedef BCMI_MADURA_AN_FIFO_STATr_t AN_FIFO_STATr_t;
#define AN_FIFO_STATr_CLR BCMI_MADURA_AN_FIFO_STATr_CLR
#define AN_FIFO_STATr_SET BCMI_MADURA_AN_FIFO_STATr_SET
#define AN_FIFO_STATr_GET BCMI_MADURA_AN_FIFO_STATr_GET
#define AN_FIFO_STATr_AN_FIFO_COLLIDEf_GET BCMI_MADURA_AN_FIFO_STATr_AN_FIFO_COLLIDEf_GET
#define AN_FIFO_STATr_AN_FIFO_COLLIDEf_SET BCMI_MADURA_AN_FIFO_STATr_AN_FIFO_COLLIDEf_SET
#define READ_AN_FIFO_STATr BCMI_MADURA_READ_AN_FIFO_STATr
#define WRITE_AN_FIFO_STATr BCMI_MADURA_WRITE_AN_FIFO_STATr
#define MODIFY_AN_FIFO_STATr BCMI_MADURA_MODIFY_AN_FIFO_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_FIFO_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  GALLARDO_A0_DIS
 * BLOCKS:   DP
 * REGADDR:  0xa346
 * DEVAD:    1
 * DESC:     Set/reset creg_gallardoA0_dis
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CREG_GALLARDOA0_DIS A place holder to control creg_gallardoA0_dis input to legacy DP RTLUnder normal functional conditions, dont have to use this in Madura
 */
#define BCMI_MADURA_GALLARDO_A0_DISr (0x0001a346 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_GALLARDO_A0_DISr_SIZE 4

/*
 * This structure should be used to declare and program GALLARDO_A0_DIS.
 */
typedef union BCMI_MADURA_GALLARDO_A0_DISr_s {
	uint32_t v[1];
	uint32_t gallardo_a0_dis[1];
	uint32_t _gallardo_a0_dis;
} BCMI_MADURA_GALLARDO_A0_DISr_t;

#define BCMI_MADURA_GALLARDO_A0_DISr_CLR(r) (r).gallardo_a0_dis[0] = 0
#define BCMI_MADURA_GALLARDO_A0_DISr_SET(r,d) (r).gallardo_a0_dis[0] = d
#define BCMI_MADURA_GALLARDO_A0_DISr_GET(r) (r).gallardo_a0_dis[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_GALLARDO_A0_DISr_CREG_GALLARDOA0_DISf_GET(r) (((r).gallardo_a0_dis[0]) & 0x1)
#define BCMI_MADURA_GALLARDO_A0_DISr_CREG_GALLARDOA0_DISf_SET(r,f) (r).gallardo_a0_dis[0]=(((r).gallardo_a0_dis[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access GALLARDO_A0_DIS.
 */
#define BCMI_MADURA_READ_GALLARDO_A0_DISr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_GALLARDO_A0_DISr,_r._gallardo_a0_dis)
#define BCMI_MADURA_WRITE_GALLARDO_A0_DISr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_GALLARDO_A0_DISr,_r._gallardo_a0_dis)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define GALLARDO_A0_DISr BCMI_MADURA_GALLARDO_A0_DISr
#define GALLARDO_A0_DISr_SIZE BCMI_MADURA_GALLARDO_A0_DISr_SIZE
typedef BCMI_MADURA_GALLARDO_A0_DISr_t GALLARDO_A0_DISr_t;
#define GALLARDO_A0_DISr_CLR BCMI_MADURA_GALLARDO_A0_DISr_CLR
#define GALLARDO_A0_DISr_SET BCMI_MADURA_GALLARDO_A0_DISr_SET
#define GALLARDO_A0_DISr_GET BCMI_MADURA_GALLARDO_A0_DISr_GET
#define GALLARDO_A0_DISr_CREG_GALLARDOA0_DISf_GET BCMI_MADURA_GALLARDO_A0_DISr_CREG_GALLARDOA0_DISf_GET
#define GALLARDO_A0_DISr_CREG_GALLARDOA0_DISf_SET BCMI_MADURA_GALLARDO_A0_DISr_CREG_GALLARDOA0_DISf_SET
#define READ_GALLARDO_A0_DISr BCMI_MADURA_READ_GALLARDO_A0_DISr
#define WRITE_GALLARDO_A0_DISr BCMI_MADURA_WRITE_GALLARDO_A0_DISr
#define MODIFY_GALLARDO_A0_DISr BCMI_MADURA_MODIFY_GALLARDO_A0_DISr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_GALLARDO_A0_DISr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SYS_FAL_BIT_SWP
 * BLOCKS:   DP
 * REGADDR:  0xa347
 * DEVAD:    1
 * DESC:     system side data bus swap control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_TX_SWAP      1: enable{MSB:LSB] to [LSB:MSB] swap for falcon transmission data bus0: no swapbit 7:0 correspond to system side falcon transmission lanes 7 to 0
 *     SYS_RX_SWAP      1: enable{MSB:LSB] to [LSB:MSB] swap for falcon receiving data bus0: no swapbit 15:8 correspond to system side falcon receiving lanes 7 to 0
 */
#define BCMI_MADURA_SYS_FAL_BIT_SWPr (0x0001a347 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SYS_FAL_BIT_SWPr_SIZE 4

/*
 * This structure should be used to declare and program SYS_FAL_BIT_SWP.
 */
typedef union BCMI_MADURA_SYS_FAL_BIT_SWPr_s {
	uint32_t v[1];
	uint32_t sys_fal_bit_swp[1];
	uint32_t _sys_fal_bit_swp;
} BCMI_MADURA_SYS_FAL_BIT_SWPr_t;

#define BCMI_MADURA_SYS_FAL_BIT_SWPr_CLR(r) (r).sys_fal_bit_swp[0] = 0
#define BCMI_MADURA_SYS_FAL_BIT_SWPr_SET(r,d) (r).sys_fal_bit_swp[0] = d
#define BCMI_MADURA_SYS_FAL_BIT_SWPr_GET(r) (r).sys_fal_bit_swp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_RX_SWAPf_GET(r) ((((r).sys_fal_bit_swp[0]) >> 8) & 0xff)
#define BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_RX_SWAPf_SET(r,f) (r).sys_fal_bit_swp[0]=(((r).sys_fal_bit_swp[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_TX_SWAPf_GET(r) (((r).sys_fal_bit_swp[0]) & 0xff)
#define BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_TX_SWAPf_SET(r,f) (r).sys_fal_bit_swp[0]=(((r).sys_fal_bit_swp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SYS_FAL_BIT_SWP.
 */
#define BCMI_MADURA_READ_SYS_FAL_BIT_SWPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SYS_FAL_BIT_SWPr,_r._sys_fal_bit_swp)
#define BCMI_MADURA_WRITE_SYS_FAL_BIT_SWPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SYS_FAL_BIT_SWPr,_r._sys_fal_bit_swp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SYS_FAL_BIT_SWPr BCMI_MADURA_SYS_FAL_BIT_SWPr
#define SYS_FAL_BIT_SWPr_SIZE BCMI_MADURA_SYS_FAL_BIT_SWPr_SIZE
typedef BCMI_MADURA_SYS_FAL_BIT_SWPr_t SYS_FAL_BIT_SWPr_t;
#define SYS_FAL_BIT_SWPr_CLR BCMI_MADURA_SYS_FAL_BIT_SWPr_CLR
#define SYS_FAL_BIT_SWPr_SET BCMI_MADURA_SYS_FAL_BIT_SWPr_SET
#define SYS_FAL_BIT_SWPr_GET BCMI_MADURA_SYS_FAL_BIT_SWPr_GET
#define SYS_FAL_BIT_SWPr_SYS_RX_SWAPf_GET BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_RX_SWAPf_GET
#define SYS_FAL_BIT_SWPr_SYS_RX_SWAPf_SET BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_RX_SWAPf_SET
#define SYS_FAL_BIT_SWPr_SYS_TX_SWAPf_GET BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_TX_SWAPf_GET
#define SYS_FAL_BIT_SWPr_SYS_TX_SWAPf_SET BCMI_MADURA_SYS_FAL_BIT_SWPr_SYS_TX_SWAPf_SET
#define READ_SYS_FAL_BIT_SWPr BCMI_MADURA_READ_SYS_FAL_BIT_SWPr
#define WRITE_SYS_FAL_BIT_SWPr BCMI_MADURA_WRITE_SYS_FAL_BIT_SWPr
#define MODIFY_SYS_FAL_BIT_SWPr BCMI_MADURA_MODIFY_SYS_FAL_BIT_SWPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SYS_FAL_BIT_SWPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LIN_FAL_BIT_SWP
 * BLOCKS:   DP
 * REGADDR:  0xa348
 * DEVAD:    1
 * DESC:     line side data bus swap control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LIN_TX_SWAP      1: enable{MSB:LSB] to [LSB:MSB] swap for falcon transmission data bus0: no swapbit 7:0 correspond to line side falcon transmission lanes 7 to 0
 *     LIN_RX_SWAP      1: enable{MSB:LSB] to [LSB:MSB] swap for falcon receiving data bus0: no swapbit 15:8 correspond to line side falcon receiving lanes 7 to 0
 */
#define BCMI_MADURA_LIN_FAL_BIT_SWPr (0x0001a348 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LIN_FAL_BIT_SWPr_SIZE 4

/*
 * This structure should be used to declare and program LIN_FAL_BIT_SWP.
 */
typedef union BCMI_MADURA_LIN_FAL_BIT_SWPr_s {
	uint32_t v[1];
	uint32_t lin_fal_bit_swp[1];
	uint32_t _lin_fal_bit_swp;
} BCMI_MADURA_LIN_FAL_BIT_SWPr_t;

#define BCMI_MADURA_LIN_FAL_BIT_SWPr_CLR(r) (r).lin_fal_bit_swp[0] = 0
#define BCMI_MADURA_LIN_FAL_BIT_SWPr_SET(r,d) (r).lin_fal_bit_swp[0] = d
#define BCMI_MADURA_LIN_FAL_BIT_SWPr_GET(r) (r).lin_fal_bit_swp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_RX_SWAPf_GET(r) ((((r).lin_fal_bit_swp[0]) >> 8) & 0xff)
#define BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_RX_SWAPf_SET(r,f) (r).lin_fal_bit_swp[0]=(((r).lin_fal_bit_swp[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_TX_SWAPf_GET(r) (((r).lin_fal_bit_swp[0]) & 0xff)
#define BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_TX_SWAPf_SET(r,f) (r).lin_fal_bit_swp[0]=(((r).lin_fal_bit_swp[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access LIN_FAL_BIT_SWP.
 */
#define BCMI_MADURA_READ_LIN_FAL_BIT_SWPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LIN_FAL_BIT_SWPr,_r._lin_fal_bit_swp)
#define BCMI_MADURA_WRITE_LIN_FAL_BIT_SWPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LIN_FAL_BIT_SWPr,_r._lin_fal_bit_swp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LIN_FAL_BIT_SWPr BCMI_MADURA_LIN_FAL_BIT_SWPr
#define LIN_FAL_BIT_SWPr_SIZE BCMI_MADURA_LIN_FAL_BIT_SWPr_SIZE
typedef BCMI_MADURA_LIN_FAL_BIT_SWPr_t LIN_FAL_BIT_SWPr_t;
#define LIN_FAL_BIT_SWPr_CLR BCMI_MADURA_LIN_FAL_BIT_SWPr_CLR
#define LIN_FAL_BIT_SWPr_SET BCMI_MADURA_LIN_FAL_BIT_SWPr_SET
#define LIN_FAL_BIT_SWPr_GET BCMI_MADURA_LIN_FAL_BIT_SWPr_GET
#define LIN_FAL_BIT_SWPr_LIN_RX_SWAPf_GET BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_RX_SWAPf_GET
#define LIN_FAL_BIT_SWPr_LIN_RX_SWAPf_SET BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_RX_SWAPf_SET
#define LIN_FAL_BIT_SWPr_LIN_TX_SWAPf_GET BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_TX_SWAPf_GET
#define LIN_FAL_BIT_SWPr_LIN_TX_SWAPf_SET BCMI_MADURA_LIN_FAL_BIT_SWPr_LIN_TX_SWAPf_SET
#define READ_LIN_FAL_BIT_SWPr BCMI_MADURA_READ_LIN_FAL_BIT_SWPr
#define WRITE_LIN_FAL_BIT_SWPr BCMI_MADURA_WRITE_LIN_FAL_BIT_SWPr
#define MODIFY_LIN_FAL_BIT_SWPr BCMI_MADURA_MODIFY_LIN_FAL_BIT_SWPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LIN_FAL_BIT_SWPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_OVRR_4_MODE
 * BLOCKS:   DP
 * REGADDR:  0xa349
 * DEVAD:    1
 * DESC:     AN override for mode determination
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_EN_4_MODE_0_FRC 0: from AN engine1: from an_en_4_mode_0_frcval bit
 *     AN_EN_4_MODE_0_FRCVAL 0: AN disabled1: AN enabled
 *     AN_EN_4_MODE_1_FRC 0: from AN engine1: from an_en_4_mode_1_frcval bit
 *     AN_EN_4_MODE_1_FRCVAL 0: AN disabled1: AN enabled
 *     AN_100G_4_MODE_0_FRC 0: mode from AN1: mode from an_100g_4_mode_0_frcval bit
 *     AN_100G_4_MODE_0_FRCVAL 0: 40G mode1: 100G mode
 *     AN_100G_4_MODE_1_FRC 0: mode from AN1: mode from an_100g_4_mode_1_frcval bit
 *     AN_100G_4_MODE_1_FRCVAL 0: 40G mode1: 100G mode
 */
#define BCMI_MADURA_AN_OVRR_4_MODEr (0x0001a349 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_OVRR_4_MODEr_SIZE 4

/*
 * This structure should be used to declare and program AN_OVRR_4_MODE.
 */
typedef union BCMI_MADURA_AN_OVRR_4_MODEr_s {
	uint32_t v[1];
	uint32_t an_ovrr_4_mode[1];
	uint32_t _an_ovrr_4_mode;
} BCMI_MADURA_AN_OVRR_4_MODEr_t;

#define BCMI_MADURA_AN_OVRR_4_MODEr_CLR(r) (r).an_ovrr_4_mode[0] = 0
#define BCMI_MADURA_AN_OVRR_4_MODEr_SET(r,d) (r).an_ovrr_4_mode[0] = d
#define BCMI_MADURA_AN_OVRR_4_MODEr_GET(r) (r).an_ovrr_4_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCVALf_GET(r) ((((r).an_ovrr_4_mode[0]) >> 7) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCVALf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCf_GET(r) ((((r).an_ovrr_4_mode[0]) >> 6) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCVALf_GET(r) ((((r).an_ovrr_4_mode[0]) >> 5) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCVALf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCf_GET(r) ((((r).an_ovrr_4_mode[0]) >> 4) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCVALf_GET(r) ((((r).an_ovrr_4_mode[0]) >> 3) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCVALf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCf_GET(r) ((((r).an_ovrr_4_mode[0]) >> 2) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCVALf_GET(r) ((((r).an_ovrr_4_mode[0]) >> 1) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCVALf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCf_GET(r) (((r).an_ovrr_4_mode[0]) & 0x1)
#define BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCf_SET(r,f) (r).an_ovrr_4_mode[0]=(((r).an_ovrr_4_mode[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_OVRR_4_MODE.
 */
#define BCMI_MADURA_READ_AN_OVRR_4_MODEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_OVRR_4_MODEr,_r._an_ovrr_4_mode)
#define BCMI_MADURA_WRITE_AN_OVRR_4_MODEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_OVRR_4_MODEr,_r._an_ovrr_4_mode)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_OVRR_4_MODEr BCMI_MADURA_AN_OVRR_4_MODEr
#define AN_OVRR_4_MODEr_SIZE BCMI_MADURA_AN_OVRR_4_MODEr_SIZE
typedef BCMI_MADURA_AN_OVRR_4_MODEr_t AN_OVRR_4_MODEr_t;
#define AN_OVRR_4_MODEr_CLR BCMI_MADURA_AN_OVRR_4_MODEr_CLR
#define AN_OVRR_4_MODEr_SET BCMI_MADURA_AN_OVRR_4_MODEr_SET
#define AN_OVRR_4_MODEr_GET BCMI_MADURA_AN_OVRR_4_MODEr_GET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCVALf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCVALf_GET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCVALf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCVALf_SET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCf_GET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_1_FRCf_SET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCVALf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCVALf_GET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCVALf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCVALf_SET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCf_GET
#define AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_100G_4_MODE_0_FRCf_SET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCVALf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCVALf_GET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCVALf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCVALf_SET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCf_GET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_1_FRCf_SET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCVALf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCVALf_GET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCVALf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCVALf_SET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCf_GET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCf_GET
#define AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCf_SET BCMI_MADURA_AN_OVRR_4_MODEr_AN_EN_4_MODE_0_FRCf_SET
#define READ_AN_OVRR_4_MODEr BCMI_MADURA_READ_AN_OVRR_4_MODEr
#define WRITE_AN_OVRR_4_MODEr BCMI_MADURA_WRITE_AN_OVRR_4_MODEr
#define MODIFY_AN_OVRR_4_MODEr BCMI_MADURA_MODIFY_AN_OVRR_4_MODEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_OVRR_4_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PWR_UP_CTL
 * BLOCKS:   DP
 * REGADDR:  0xa350
 * DEVAD:    1
 * DESC:     power up FSM control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FRC_PWRUP_DONE   Set to force pwrup_done to 1, the power up/down sequence is not affected
 *     DIS_PWR_SEQ      Set to disable power up/down sequence, all enabled lanes will be powered up at the same time
 */
#define BCMI_MADURA_PWR_UP_CTLr (0x0001a350 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PWR_UP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PWR_UP_CTL.
 */
typedef union BCMI_MADURA_PWR_UP_CTLr_s {
	uint32_t v[1];
	uint32_t pwr_up_ctl[1];
	uint32_t _pwr_up_ctl;
} BCMI_MADURA_PWR_UP_CTLr_t;

#define BCMI_MADURA_PWR_UP_CTLr_CLR(r) (r).pwr_up_ctl[0] = 0
#define BCMI_MADURA_PWR_UP_CTLr_SET(r,d) (r).pwr_up_ctl[0] = d
#define BCMI_MADURA_PWR_UP_CTLr_GET(r) (r).pwr_up_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PWR_UP_CTLr_DIS_PWR_SEQf_GET(r) ((((r).pwr_up_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_PWR_UP_CTLr_DIS_PWR_SEQf_SET(r,f) (r).pwr_up_ctl[0]=(((r).pwr_up_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PWR_UP_CTLr_FRC_PWRUP_DONEf_GET(r) (((r).pwr_up_ctl[0]) & 0x1)
#define BCMI_MADURA_PWR_UP_CTLr_FRC_PWRUP_DONEf_SET(r,f) (r).pwr_up_ctl[0]=(((r).pwr_up_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PWR_UP_CTL.
 */
#define BCMI_MADURA_READ_PWR_UP_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PWR_UP_CTLr,_r._pwr_up_ctl)
#define BCMI_MADURA_WRITE_PWR_UP_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PWR_UP_CTLr,_r._pwr_up_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PWR_UP_CTLr BCMI_MADURA_PWR_UP_CTLr
#define PWR_UP_CTLr_SIZE BCMI_MADURA_PWR_UP_CTLr_SIZE
typedef BCMI_MADURA_PWR_UP_CTLr_t PWR_UP_CTLr_t;
#define PWR_UP_CTLr_CLR BCMI_MADURA_PWR_UP_CTLr_CLR
#define PWR_UP_CTLr_SET BCMI_MADURA_PWR_UP_CTLr_SET
#define PWR_UP_CTLr_GET BCMI_MADURA_PWR_UP_CTLr_GET
#define PWR_UP_CTLr_DIS_PWR_SEQf_GET BCMI_MADURA_PWR_UP_CTLr_DIS_PWR_SEQf_GET
#define PWR_UP_CTLr_DIS_PWR_SEQf_SET BCMI_MADURA_PWR_UP_CTLr_DIS_PWR_SEQf_SET
#define PWR_UP_CTLr_FRC_PWRUP_DONEf_GET BCMI_MADURA_PWR_UP_CTLr_FRC_PWRUP_DONEf_GET
#define PWR_UP_CTLr_FRC_PWRUP_DONEf_SET BCMI_MADURA_PWR_UP_CTLr_FRC_PWRUP_DONEf_SET
#define READ_PWR_UP_CTLr BCMI_MADURA_READ_PWR_UP_CTLr
#define WRITE_PWR_UP_CTLr BCMI_MADURA_WRITE_PWR_UP_CTLr
#define MODIFY_PWR_UP_CTLr BCMI_MADURA_MODIFY_PWR_UP_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PWR_UP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PWR_UP_STAT
 * BLOCKS:   DP
 * REGADDR:  0xa351
 * DEVAD:    1
 * DESC:     power up FSM status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PWRUP_DONE       Indicate Power up/down sequence FSM completed
 */
#define BCMI_MADURA_PWR_UP_STATr (0x0001a351 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PWR_UP_STATr_SIZE 4

/*
 * This structure should be used to declare and program PWR_UP_STAT.
 */
typedef union BCMI_MADURA_PWR_UP_STATr_s {
	uint32_t v[1];
	uint32_t pwr_up_stat[1];
	uint32_t _pwr_up_stat;
} BCMI_MADURA_PWR_UP_STATr_t;

#define BCMI_MADURA_PWR_UP_STATr_CLR(r) (r).pwr_up_stat[0] = 0
#define BCMI_MADURA_PWR_UP_STATr_SET(r,d) (r).pwr_up_stat[0] = d
#define BCMI_MADURA_PWR_UP_STATr_GET(r) (r).pwr_up_stat[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PWR_UP_STATr_PWRUP_DONEf_GET(r) (((r).pwr_up_stat[0]) & 0x1)
#define BCMI_MADURA_PWR_UP_STATr_PWRUP_DONEf_SET(r,f) (r).pwr_up_stat[0]=(((r).pwr_up_stat[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PWR_UP_STAT.
 */
#define BCMI_MADURA_READ_PWR_UP_STATr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PWR_UP_STATr,_r._pwr_up_stat)
#define BCMI_MADURA_WRITE_PWR_UP_STATr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PWR_UP_STATr,_r._pwr_up_stat)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PWR_UP_STATr BCMI_MADURA_PWR_UP_STATr
#define PWR_UP_STATr_SIZE BCMI_MADURA_PWR_UP_STATr_SIZE
typedef BCMI_MADURA_PWR_UP_STATr_t PWR_UP_STATr_t;
#define PWR_UP_STATr_CLR BCMI_MADURA_PWR_UP_STATr_CLR
#define PWR_UP_STATr_SET BCMI_MADURA_PWR_UP_STATr_SET
#define PWR_UP_STATr_GET BCMI_MADURA_PWR_UP_STATr_GET
#define PWR_UP_STATr_PWRUP_DONEf_GET BCMI_MADURA_PWR_UP_STATr_PWRUP_DONEf_GET
#define PWR_UP_STATr_PWRUP_DONEf_SET BCMI_MADURA_PWR_UP_STATr_PWRUP_DONEf_SET
#define READ_PWR_UP_STATr BCMI_MADURA_READ_PWR_UP_STATr
#define WRITE_PWR_UP_STATr BCMI_MADURA_WRITE_PWR_UP_STATr
#define MODIFY_PWR_UP_STATr BCMI_MADURA_MODIFY_PWR_UP_STATr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PWR_UP_STATr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT0
 * BLOCKS:   DP
 * REGADDR:  0xa352
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P0_SLANES        number of system side ports
 *     P0_LLANES        number of system side ports
 */
#define BCMI_MADURA_MD_PORT0r (0x0001a352 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT0r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT0.
 */
typedef union BCMI_MADURA_MD_PORT0r_s {
	uint32_t v[1];
	uint32_t md_port0[1];
	uint32_t _md_port0;
} BCMI_MADURA_MD_PORT0r_t;

#define BCMI_MADURA_MD_PORT0r_CLR(r) (r).md_port0[0] = 0
#define BCMI_MADURA_MD_PORT0r_SET(r,d) (r).md_port0[0] = d
#define BCMI_MADURA_MD_PORT0r_GET(r) (r).md_port0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT0r_P0_LLANESf_GET(r) ((((r).md_port0[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT0r_P0_LLANESf_SET(r,f) (r).md_port0[0]=(((r).md_port0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT0r_P0_SLANESf_GET(r) (((r).md_port0[0]) & 0xff)
#define BCMI_MADURA_MD_PORT0r_P0_SLANESf_SET(r,f) (r).md_port0[0]=(((r).md_port0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT0.
 */
#define BCMI_MADURA_READ_MD_PORT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT0r,_r._md_port0)
#define BCMI_MADURA_WRITE_MD_PORT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT0r,_r._md_port0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT0r BCMI_MADURA_MD_PORT0r
#define MD_PORT0r_SIZE BCMI_MADURA_MD_PORT0r_SIZE
typedef BCMI_MADURA_MD_PORT0r_t MD_PORT0r_t;
#define MD_PORT0r_CLR BCMI_MADURA_MD_PORT0r_CLR
#define MD_PORT0r_SET BCMI_MADURA_MD_PORT0r_SET
#define MD_PORT0r_GET BCMI_MADURA_MD_PORT0r_GET
#define MD_PORT0r_P0_LLANESf_GET BCMI_MADURA_MD_PORT0r_P0_LLANESf_GET
#define MD_PORT0r_P0_LLANESf_SET BCMI_MADURA_MD_PORT0r_P0_LLANESf_SET
#define MD_PORT0r_P0_SLANESf_GET BCMI_MADURA_MD_PORT0r_P0_SLANESf_GET
#define MD_PORT0r_P0_SLANESf_SET BCMI_MADURA_MD_PORT0r_P0_SLANESf_SET
#define READ_MD_PORT0r BCMI_MADURA_READ_MD_PORT0r
#define WRITE_MD_PORT0r BCMI_MADURA_WRITE_MD_PORT0r
#define MODIFY_MD_PORT0r BCMI_MADURA_MODIFY_MD_PORT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT1
 * BLOCKS:   DP
 * REGADDR:  0xa353
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P1_SLANES        number of system side ports
 *     P1_LLANES        number of line side ports
 */
#define BCMI_MADURA_MD_PORT1r (0x0001a353 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT1r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT1.
 */
typedef union BCMI_MADURA_MD_PORT1r_s {
	uint32_t v[1];
	uint32_t md_port1[1];
	uint32_t _md_port1;
} BCMI_MADURA_MD_PORT1r_t;

#define BCMI_MADURA_MD_PORT1r_CLR(r) (r).md_port1[0] = 0
#define BCMI_MADURA_MD_PORT1r_SET(r,d) (r).md_port1[0] = d
#define BCMI_MADURA_MD_PORT1r_GET(r) (r).md_port1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT1r_P1_LLANESf_GET(r) ((((r).md_port1[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT1r_P1_LLANESf_SET(r,f) (r).md_port1[0]=(((r).md_port1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT1r_P1_SLANESf_GET(r) (((r).md_port1[0]) & 0xff)
#define BCMI_MADURA_MD_PORT1r_P1_SLANESf_SET(r,f) (r).md_port1[0]=(((r).md_port1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT1.
 */
#define BCMI_MADURA_READ_MD_PORT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT1r,_r._md_port1)
#define BCMI_MADURA_WRITE_MD_PORT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT1r,_r._md_port1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT1r BCMI_MADURA_MD_PORT1r
#define MD_PORT1r_SIZE BCMI_MADURA_MD_PORT1r_SIZE
typedef BCMI_MADURA_MD_PORT1r_t MD_PORT1r_t;
#define MD_PORT1r_CLR BCMI_MADURA_MD_PORT1r_CLR
#define MD_PORT1r_SET BCMI_MADURA_MD_PORT1r_SET
#define MD_PORT1r_GET BCMI_MADURA_MD_PORT1r_GET
#define MD_PORT1r_P1_LLANESf_GET BCMI_MADURA_MD_PORT1r_P1_LLANESf_GET
#define MD_PORT1r_P1_LLANESf_SET BCMI_MADURA_MD_PORT1r_P1_LLANESf_SET
#define MD_PORT1r_P1_SLANESf_GET BCMI_MADURA_MD_PORT1r_P1_SLANESf_GET
#define MD_PORT1r_P1_SLANESf_SET BCMI_MADURA_MD_PORT1r_P1_SLANESf_SET
#define READ_MD_PORT1r BCMI_MADURA_READ_MD_PORT1r
#define WRITE_MD_PORT1r BCMI_MADURA_WRITE_MD_PORT1r
#define MODIFY_MD_PORT1r BCMI_MADURA_MODIFY_MD_PORT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT2
 * BLOCKS:   DP
 * REGADDR:  0xa354
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P2_SLANES        number of system side ports
 *     P2_LLANES        number of line side ports
 */
#define BCMI_MADURA_MD_PORT2r (0x0001a354 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT2r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT2.
 */
typedef union BCMI_MADURA_MD_PORT2r_s {
	uint32_t v[1];
	uint32_t md_port2[1];
	uint32_t _md_port2;
} BCMI_MADURA_MD_PORT2r_t;

#define BCMI_MADURA_MD_PORT2r_CLR(r) (r).md_port2[0] = 0
#define BCMI_MADURA_MD_PORT2r_SET(r,d) (r).md_port2[0] = d
#define BCMI_MADURA_MD_PORT2r_GET(r) (r).md_port2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT2r_P2_LLANESf_GET(r) ((((r).md_port2[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT2r_P2_LLANESf_SET(r,f) (r).md_port2[0]=(((r).md_port2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT2r_P2_SLANESf_GET(r) (((r).md_port2[0]) & 0xff)
#define BCMI_MADURA_MD_PORT2r_P2_SLANESf_SET(r,f) (r).md_port2[0]=(((r).md_port2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT2.
 */
#define BCMI_MADURA_READ_MD_PORT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT2r,_r._md_port2)
#define BCMI_MADURA_WRITE_MD_PORT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT2r,_r._md_port2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT2r BCMI_MADURA_MD_PORT2r
#define MD_PORT2r_SIZE BCMI_MADURA_MD_PORT2r_SIZE
typedef BCMI_MADURA_MD_PORT2r_t MD_PORT2r_t;
#define MD_PORT2r_CLR BCMI_MADURA_MD_PORT2r_CLR
#define MD_PORT2r_SET BCMI_MADURA_MD_PORT2r_SET
#define MD_PORT2r_GET BCMI_MADURA_MD_PORT2r_GET
#define MD_PORT2r_P2_LLANESf_GET BCMI_MADURA_MD_PORT2r_P2_LLANESf_GET
#define MD_PORT2r_P2_LLANESf_SET BCMI_MADURA_MD_PORT2r_P2_LLANESf_SET
#define MD_PORT2r_P2_SLANESf_GET BCMI_MADURA_MD_PORT2r_P2_SLANESf_GET
#define MD_PORT2r_P2_SLANESf_SET BCMI_MADURA_MD_PORT2r_P2_SLANESf_SET
#define READ_MD_PORT2r BCMI_MADURA_READ_MD_PORT2r
#define WRITE_MD_PORT2r BCMI_MADURA_WRITE_MD_PORT2r
#define MODIFY_MD_PORT2r BCMI_MADURA_MODIFY_MD_PORT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT3
 * BLOCKS:   DP
 * REGADDR:  0xa355
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P3_SLANES        number of system side ports
 *     P3_LLANES        number of line side ports
 */
#define BCMI_MADURA_MD_PORT3r (0x0001a355 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT3r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT3.
 */
typedef union BCMI_MADURA_MD_PORT3r_s {
	uint32_t v[1];
	uint32_t md_port3[1];
	uint32_t _md_port3;
} BCMI_MADURA_MD_PORT3r_t;

#define BCMI_MADURA_MD_PORT3r_CLR(r) (r).md_port3[0] = 0
#define BCMI_MADURA_MD_PORT3r_SET(r,d) (r).md_port3[0] = d
#define BCMI_MADURA_MD_PORT3r_GET(r) (r).md_port3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT3r_P3_LLANESf_GET(r) ((((r).md_port3[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT3r_P3_LLANESf_SET(r,f) (r).md_port3[0]=(((r).md_port3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT3r_P3_SLANESf_GET(r) (((r).md_port3[0]) & 0xff)
#define BCMI_MADURA_MD_PORT3r_P3_SLANESf_SET(r,f) (r).md_port3[0]=(((r).md_port3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT3.
 */
#define BCMI_MADURA_READ_MD_PORT3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT3r,_r._md_port3)
#define BCMI_MADURA_WRITE_MD_PORT3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT3r,_r._md_port3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT3r BCMI_MADURA_MD_PORT3r
#define MD_PORT3r_SIZE BCMI_MADURA_MD_PORT3r_SIZE
typedef BCMI_MADURA_MD_PORT3r_t MD_PORT3r_t;
#define MD_PORT3r_CLR BCMI_MADURA_MD_PORT3r_CLR
#define MD_PORT3r_SET BCMI_MADURA_MD_PORT3r_SET
#define MD_PORT3r_GET BCMI_MADURA_MD_PORT3r_GET
#define MD_PORT3r_P3_LLANESf_GET BCMI_MADURA_MD_PORT3r_P3_LLANESf_GET
#define MD_PORT3r_P3_LLANESf_SET BCMI_MADURA_MD_PORT3r_P3_LLANESf_SET
#define MD_PORT3r_P3_SLANESf_GET BCMI_MADURA_MD_PORT3r_P3_SLANESf_GET
#define MD_PORT3r_P3_SLANESf_SET BCMI_MADURA_MD_PORT3r_P3_SLANESf_SET
#define READ_MD_PORT3r BCMI_MADURA_READ_MD_PORT3r
#define WRITE_MD_PORT3r BCMI_MADURA_WRITE_MD_PORT3r
#define MODIFY_MD_PORT3r BCMI_MADURA_MODIFY_MD_PORT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT4
 * BLOCKS:   DP
 * REGADDR:  0xa356
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P4_SLANES        number of system side ports
 *     P4_LLANES        number of line side ports
 */
#define BCMI_MADURA_MD_PORT4r (0x0001a356 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT4r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT4.
 */
typedef union BCMI_MADURA_MD_PORT4r_s {
	uint32_t v[1];
	uint32_t md_port4[1];
	uint32_t _md_port4;
} BCMI_MADURA_MD_PORT4r_t;

#define BCMI_MADURA_MD_PORT4r_CLR(r) (r).md_port4[0] = 0
#define BCMI_MADURA_MD_PORT4r_SET(r,d) (r).md_port4[0] = d
#define BCMI_MADURA_MD_PORT4r_GET(r) (r).md_port4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT4r_P4_LLANESf_GET(r) ((((r).md_port4[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT4r_P4_LLANESf_SET(r,f) (r).md_port4[0]=(((r).md_port4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT4r_P4_SLANESf_GET(r) (((r).md_port4[0]) & 0xff)
#define BCMI_MADURA_MD_PORT4r_P4_SLANESf_SET(r,f) (r).md_port4[0]=(((r).md_port4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT4.
 */
#define BCMI_MADURA_READ_MD_PORT4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT4r,_r._md_port4)
#define BCMI_MADURA_WRITE_MD_PORT4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT4r,_r._md_port4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT4r BCMI_MADURA_MD_PORT4r
#define MD_PORT4r_SIZE BCMI_MADURA_MD_PORT4r_SIZE
typedef BCMI_MADURA_MD_PORT4r_t MD_PORT4r_t;
#define MD_PORT4r_CLR BCMI_MADURA_MD_PORT4r_CLR
#define MD_PORT4r_SET BCMI_MADURA_MD_PORT4r_SET
#define MD_PORT4r_GET BCMI_MADURA_MD_PORT4r_GET
#define MD_PORT4r_P4_LLANESf_GET BCMI_MADURA_MD_PORT4r_P4_LLANESf_GET
#define MD_PORT4r_P4_LLANESf_SET BCMI_MADURA_MD_PORT4r_P4_LLANESf_SET
#define MD_PORT4r_P4_SLANESf_GET BCMI_MADURA_MD_PORT4r_P4_SLANESf_GET
#define MD_PORT4r_P4_SLANESf_SET BCMI_MADURA_MD_PORT4r_P4_SLANESf_SET
#define READ_MD_PORT4r BCMI_MADURA_READ_MD_PORT4r
#define WRITE_MD_PORT4r BCMI_MADURA_WRITE_MD_PORT4r
#define MODIFY_MD_PORT4r BCMI_MADURA_MODIFY_MD_PORT4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT5
 * BLOCKS:   DP
 * REGADDR:  0xa357
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P5_SLANES        number of system side ports
 *     P5_LLANES        number of line side ports
 */
#define BCMI_MADURA_MD_PORT5r (0x0001a357 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT5r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT5.
 */
typedef union BCMI_MADURA_MD_PORT5r_s {
	uint32_t v[1];
	uint32_t md_port5[1];
	uint32_t _md_port5;
} BCMI_MADURA_MD_PORT5r_t;

#define BCMI_MADURA_MD_PORT5r_CLR(r) (r).md_port5[0] = 0
#define BCMI_MADURA_MD_PORT5r_SET(r,d) (r).md_port5[0] = d
#define BCMI_MADURA_MD_PORT5r_GET(r) (r).md_port5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT5r_P5_LLANESf_GET(r) ((((r).md_port5[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT5r_P5_LLANESf_SET(r,f) (r).md_port5[0]=(((r).md_port5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT5r_P5_SLANESf_GET(r) (((r).md_port5[0]) & 0xff)
#define BCMI_MADURA_MD_PORT5r_P5_SLANESf_SET(r,f) (r).md_port5[0]=(((r).md_port5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT5.
 */
#define BCMI_MADURA_READ_MD_PORT5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT5r,_r._md_port5)
#define BCMI_MADURA_WRITE_MD_PORT5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT5r,_r._md_port5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT5r BCMI_MADURA_MD_PORT5r
#define MD_PORT5r_SIZE BCMI_MADURA_MD_PORT5r_SIZE
typedef BCMI_MADURA_MD_PORT5r_t MD_PORT5r_t;
#define MD_PORT5r_CLR BCMI_MADURA_MD_PORT5r_CLR
#define MD_PORT5r_SET BCMI_MADURA_MD_PORT5r_SET
#define MD_PORT5r_GET BCMI_MADURA_MD_PORT5r_GET
#define MD_PORT5r_P5_LLANESf_GET BCMI_MADURA_MD_PORT5r_P5_LLANESf_GET
#define MD_PORT5r_P5_LLANESf_SET BCMI_MADURA_MD_PORT5r_P5_LLANESf_SET
#define MD_PORT5r_P5_SLANESf_GET BCMI_MADURA_MD_PORT5r_P5_SLANESf_GET
#define MD_PORT5r_P5_SLANESf_SET BCMI_MADURA_MD_PORT5r_P5_SLANESf_SET
#define READ_MD_PORT5r BCMI_MADURA_READ_MD_PORT5r
#define WRITE_MD_PORT5r BCMI_MADURA_WRITE_MD_PORT5r
#define MODIFY_MD_PORT5r BCMI_MADURA_MODIFY_MD_PORT5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT6
 * BLOCKS:   DP
 * REGADDR:  0xa358
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P6_SLANES        number of system side ports
 *     P6_LLANES        number of line side ports
 */
#define BCMI_MADURA_MD_PORT6r (0x0001a358 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT6r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT6.
 */
typedef union BCMI_MADURA_MD_PORT6r_s {
	uint32_t v[1];
	uint32_t md_port6[1];
	uint32_t _md_port6;
} BCMI_MADURA_MD_PORT6r_t;

#define BCMI_MADURA_MD_PORT6r_CLR(r) (r).md_port6[0] = 0
#define BCMI_MADURA_MD_PORT6r_SET(r,d) (r).md_port6[0] = d
#define BCMI_MADURA_MD_PORT6r_GET(r) (r).md_port6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT6r_P6_LLANESf_GET(r) ((((r).md_port6[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT6r_P6_LLANESf_SET(r,f) (r).md_port6[0]=(((r).md_port6[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT6r_P6_SLANESf_GET(r) (((r).md_port6[0]) & 0xff)
#define BCMI_MADURA_MD_PORT6r_P6_SLANESf_SET(r,f) (r).md_port6[0]=(((r).md_port6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT6.
 */
#define BCMI_MADURA_READ_MD_PORT6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT6r,_r._md_port6)
#define BCMI_MADURA_WRITE_MD_PORT6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT6r,_r._md_port6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT6r BCMI_MADURA_MD_PORT6r
#define MD_PORT6r_SIZE BCMI_MADURA_MD_PORT6r_SIZE
typedef BCMI_MADURA_MD_PORT6r_t MD_PORT6r_t;
#define MD_PORT6r_CLR BCMI_MADURA_MD_PORT6r_CLR
#define MD_PORT6r_SET BCMI_MADURA_MD_PORT6r_SET
#define MD_PORT6r_GET BCMI_MADURA_MD_PORT6r_GET
#define MD_PORT6r_P6_LLANESf_GET BCMI_MADURA_MD_PORT6r_P6_LLANESf_GET
#define MD_PORT6r_P6_LLANESf_SET BCMI_MADURA_MD_PORT6r_P6_LLANESf_SET
#define MD_PORT6r_P6_SLANESf_GET BCMI_MADURA_MD_PORT6r_P6_SLANESf_GET
#define MD_PORT6r_P6_SLANESf_SET BCMI_MADURA_MD_PORT6r_P6_SLANESf_SET
#define READ_MD_PORT6r BCMI_MADURA_READ_MD_PORT6r
#define WRITE_MD_PORT6r BCMI_MADURA_WRITE_MD_PORT6r
#define MODIFY_MD_PORT6r BCMI_MADURA_MODIFY_MD_PORT6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_PORT7
 * BLOCKS:   DP
 * REGADDR:  0xa359
 * DEVAD:    1
 * DESC:     port related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     P7_SLANES        number of system side ports
 *     P7_LLANES        number of line side ports
 */
#define BCMI_MADURA_MD_PORT7r (0x0001a359 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_PORT7r_SIZE 4

/*
 * This structure should be used to declare and program MD_PORT7.
 */
typedef union BCMI_MADURA_MD_PORT7r_s {
	uint32_t v[1];
	uint32_t md_port7[1];
	uint32_t _md_port7;
} BCMI_MADURA_MD_PORT7r_t;

#define BCMI_MADURA_MD_PORT7r_CLR(r) (r).md_port7[0] = 0
#define BCMI_MADURA_MD_PORT7r_SET(r,d) (r).md_port7[0] = d
#define BCMI_MADURA_MD_PORT7r_GET(r) (r).md_port7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_PORT7r_P7_LLANESf_GET(r) ((((r).md_port7[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_PORT7r_P7_LLANESf_SET(r,f) (r).md_port7[0]=(((r).md_port7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_PORT7r_P7_SLANESf_GET(r) (((r).md_port7[0]) & 0xff)
#define BCMI_MADURA_MD_PORT7r_P7_SLANESf_SET(r,f) (r).md_port7[0]=(((r).md_port7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_PORT7.
 */
#define BCMI_MADURA_READ_MD_PORT7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_PORT7r,_r._md_port7)
#define BCMI_MADURA_WRITE_MD_PORT7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_PORT7r,_r._md_port7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_PORT7r BCMI_MADURA_MD_PORT7r
#define MD_PORT7r_SIZE BCMI_MADURA_MD_PORT7r_SIZE
typedef BCMI_MADURA_MD_PORT7r_t MD_PORT7r_t;
#define MD_PORT7r_CLR BCMI_MADURA_MD_PORT7r_CLR
#define MD_PORT7r_SET BCMI_MADURA_MD_PORT7r_SET
#define MD_PORT7r_GET BCMI_MADURA_MD_PORT7r_GET
#define MD_PORT7r_P7_LLANESf_GET BCMI_MADURA_MD_PORT7r_P7_LLANESf_GET
#define MD_PORT7r_P7_LLANESf_SET BCMI_MADURA_MD_PORT7r_P7_LLANESf_SET
#define MD_PORT7r_P7_SLANESf_GET BCMI_MADURA_MD_PORT7r_P7_SLANESf_GET
#define MD_PORT7r_P7_SLANESf_SET BCMI_MADURA_MD_PORT7r_P7_SLANESf_SET
#define READ_MD_PORT7r BCMI_MADURA_READ_MD_PORT7r
#define WRITE_MD_PORT7r BCMI_MADURA_WRITE_MD_PORT7r
#define MODIFY_MD_PORT7r BCMI_MADURA_MODIFY_MD_PORT7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_PORT7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE0
 * BLOCKS:   DP
 * REGADDR:  0xa35a
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE0_S2L       mapping system side to line side mapping
 *     LLANE0_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE0r (0x0001a35a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE0r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE0.
 */
typedef union BCMI_MADURA_MD_LANE0r_s {
	uint32_t v[1];
	uint32_t md_lane0[1];
	uint32_t _md_lane0;
} BCMI_MADURA_MD_LANE0r_t;

#define BCMI_MADURA_MD_LANE0r_CLR(r) (r).md_lane0[0] = 0
#define BCMI_MADURA_MD_LANE0r_SET(r,d) (r).md_lane0[0] = d
#define BCMI_MADURA_MD_LANE0r_GET(r) (r).md_lane0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE0r_LLANE0_L2Sf_GET(r) ((((r).md_lane0[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE0r_LLANE0_L2Sf_SET(r,f) (r).md_lane0[0]=(((r).md_lane0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE0r_SLANE0_S2Lf_GET(r) (((r).md_lane0[0]) & 0xff)
#define BCMI_MADURA_MD_LANE0r_SLANE0_S2Lf_SET(r,f) (r).md_lane0[0]=(((r).md_lane0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE0.
 */
#define BCMI_MADURA_READ_MD_LANE0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE0r,_r._md_lane0)
#define BCMI_MADURA_WRITE_MD_LANE0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE0r,_r._md_lane0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE0r BCMI_MADURA_MD_LANE0r
#define MD_LANE0r_SIZE BCMI_MADURA_MD_LANE0r_SIZE
typedef BCMI_MADURA_MD_LANE0r_t MD_LANE0r_t;
#define MD_LANE0r_CLR BCMI_MADURA_MD_LANE0r_CLR
#define MD_LANE0r_SET BCMI_MADURA_MD_LANE0r_SET
#define MD_LANE0r_GET BCMI_MADURA_MD_LANE0r_GET
#define MD_LANE0r_LLANE0_L2Sf_GET BCMI_MADURA_MD_LANE0r_LLANE0_L2Sf_GET
#define MD_LANE0r_LLANE0_L2Sf_SET BCMI_MADURA_MD_LANE0r_LLANE0_L2Sf_SET
#define MD_LANE0r_SLANE0_S2Lf_GET BCMI_MADURA_MD_LANE0r_SLANE0_S2Lf_GET
#define MD_LANE0r_SLANE0_S2Lf_SET BCMI_MADURA_MD_LANE0r_SLANE0_S2Lf_SET
#define READ_MD_LANE0r BCMI_MADURA_READ_MD_LANE0r
#define WRITE_MD_LANE0r BCMI_MADURA_WRITE_MD_LANE0r
#define MODIFY_MD_LANE0r BCMI_MADURA_MODIFY_MD_LANE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE1
 * BLOCKS:   DP
 * REGADDR:  0xa35b
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE1_S2L       mapping system side to line side mapping
 *     LLANE1_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE1r (0x0001a35b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE1r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE1.
 */
typedef union BCMI_MADURA_MD_LANE1r_s {
	uint32_t v[1];
	uint32_t md_lane1[1];
	uint32_t _md_lane1;
} BCMI_MADURA_MD_LANE1r_t;

#define BCMI_MADURA_MD_LANE1r_CLR(r) (r).md_lane1[0] = 0
#define BCMI_MADURA_MD_LANE1r_SET(r,d) (r).md_lane1[0] = d
#define BCMI_MADURA_MD_LANE1r_GET(r) (r).md_lane1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE1r_LLANE1_L2Sf_GET(r) ((((r).md_lane1[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE1r_LLANE1_L2Sf_SET(r,f) (r).md_lane1[0]=(((r).md_lane1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE1r_SLANE1_S2Lf_GET(r) (((r).md_lane1[0]) & 0xff)
#define BCMI_MADURA_MD_LANE1r_SLANE1_S2Lf_SET(r,f) (r).md_lane1[0]=(((r).md_lane1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE1.
 */
#define BCMI_MADURA_READ_MD_LANE1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE1r,_r._md_lane1)
#define BCMI_MADURA_WRITE_MD_LANE1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE1r,_r._md_lane1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE1r BCMI_MADURA_MD_LANE1r
#define MD_LANE1r_SIZE BCMI_MADURA_MD_LANE1r_SIZE
typedef BCMI_MADURA_MD_LANE1r_t MD_LANE1r_t;
#define MD_LANE1r_CLR BCMI_MADURA_MD_LANE1r_CLR
#define MD_LANE1r_SET BCMI_MADURA_MD_LANE1r_SET
#define MD_LANE1r_GET BCMI_MADURA_MD_LANE1r_GET
#define MD_LANE1r_LLANE1_L2Sf_GET BCMI_MADURA_MD_LANE1r_LLANE1_L2Sf_GET
#define MD_LANE1r_LLANE1_L2Sf_SET BCMI_MADURA_MD_LANE1r_LLANE1_L2Sf_SET
#define MD_LANE1r_SLANE1_S2Lf_GET BCMI_MADURA_MD_LANE1r_SLANE1_S2Lf_GET
#define MD_LANE1r_SLANE1_S2Lf_SET BCMI_MADURA_MD_LANE1r_SLANE1_S2Lf_SET
#define READ_MD_LANE1r BCMI_MADURA_READ_MD_LANE1r
#define WRITE_MD_LANE1r BCMI_MADURA_WRITE_MD_LANE1r
#define MODIFY_MD_LANE1r BCMI_MADURA_MODIFY_MD_LANE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE2
 * BLOCKS:   DP
 * REGADDR:  0xa35c
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE2_S2L       mapping system side to line side mapping
 *     LLANE2_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE2r (0x0001a35c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE2r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE2.
 */
typedef union BCMI_MADURA_MD_LANE2r_s {
	uint32_t v[1];
	uint32_t md_lane2[1];
	uint32_t _md_lane2;
} BCMI_MADURA_MD_LANE2r_t;

#define BCMI_MADURA_MD_LANE2r_CLR(r) (r).md_lane2[0] = 0
#define BCMI_MADURA_MD_LANE2r_SET(r,d) (r).md_lane2[0] = d
#define BCMI_MADURA_MD_LANE2r_GET(r) (r).md_lane2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE2r_LLANE2_L2Sf_GET(r) ((((r).md_lane2[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE2r_LLANE2_L2Sf_SET(r,f) (r).md_lane2[0]=(((r).md_lane2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE2r_SLANE2_S2Lf_GET(r) (((r).md_lane2[0]) & 0xff)
#define BCMI_MADURA_MD_LANE2r_SLANE2_S2Lf_SET(r,f) (r).md_lane2[0]=(((r).md_lane2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE2.
 */
#define BCMI_MADURA_READ_MD_LANE2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE2r,_r._md_lane2)
#define BCMI_MADURA_WRITE_MD_LANE2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE2r,_r._md_lane2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE2r BCMI_MADURA_MD_LANE2r
#define MD_LANE2r_SIZE BCMI_MADURA_MD_LANE2r_SIZE
typedef BCMI_MADURA_MD_LANE2r_t MD_LANE2r_t;
#define MD_LANE2r_CLR BCMI_MADURA_MD_LANE2r_CLR
#define MD_LANE2r_SET BCMI_MADURA_MD_LANE2r_SET
#define MD_LANE2r_GET BCMI_MADURA_MD_LANE2r_GET
#define MD_LANE2r_LLANE2_L2Sf_GET BCMI_MADURA_MD_LANE2r_LLANE2_L2Sf_GET
#define MD_LANE2r_LLANE2_L2Sf_SET BCMI_MADURA_MD_LANE2r_LLANE2_L2Sf_SET
#define MD_LANE2r_SLANE2_S2Lf_GET BCMI_MADURA_MD_LANE2r_SLANE2_S2Lf_GET
#define MD_LANE2r_SLANE2_S2Lf_SET BCMI_MADURA_MD_LANE2r_SLANE2_S2Lf_SET
#define READ_MD_LANE2r BCMI_MADURA_READ_MD_LANE2r
#define WRITE_MD_LANE2r BCMI_MADURA_WRITE_MD_LANE2r
#define MODIFY_MD_LANE2r BCMI_MADURA_MODIFY_MD_LANE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE3
 * BLOCKS:   DP
 * REGADDR:  0xa35d
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE3_S2L       mapping system side to line side mapping
 *     LLANE3_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE3r (0x0001a35d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE3r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE3.
 */
typedef union BCMI_MADURA_MD_LANE3r_s {
	uint32_t v[1];
	uint32_t md_lane3[1];
	uint32_t _md_lane3;
} BCMI_MADURA_MD_LANE3r_t;

#define BCMI_MADURA_MD_LANE3r_CLR(r) (r).md_lane3[0] = 0
#define BCMI_MADURA_MD_LANE3r_SET(r,d) (r).md_lane3[0] = d
#define BCMI_MADURA_MD_LANE3r_GET(r) (r).md_lane3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE3r_LLANE3_L2Sf_GET(r) ((((r).md_lane3[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE3r_LLANE3_L2Sf_SET(r,f) (r).md_lane3[0]=(((r).md_lane3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE3r_SLANE3_S2Lf_GET(r) (((r).md_lane3[0]) & 0xff)
#define BCMI_MADURA_MD_LANE3r_SLANE3_S2Lf_SET(r,f) (r).md_lane3[0]=(((r).md_lane3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE3.
 */
#define BCMI_MADURA_READ_MD_LANE3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE3r,_r._md_lane3)
#define BCMI_MADURA_WRITE_MD_LANE3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE3r,_r._md_lane3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE3r BCMI_MADURA_MD_LANE3r
#define MD_LANE3r_SIZE BCMI_MADURA_MD_LANE3r_SIZE
typedef BCMI_MADURA_MD_LANE3r_t MD_LANE3r_t;
#define MD_LANE3r_CLR BCMI_MADURA_MD_LANE3r_CLR
#define MD_LANE3r_SET BCMI_MADURA_MD_LANE3r_SET
#define MD_LANE3r_GET BCMI_MADURA_MD_LANE3r_GET
#define MD_LANE3r_LLANE3_L2Sf_GET BCMI_MADURA_MD_LANE3r_LLANE3_L2Sf_GET
#define MD_LANE3r_LLANE3_L2Sf_SET BCMI_MADURA_MD_LANE3r_LLANE3_L2Sf_SET
#define MD_LANE3r_SLANE3_S2Lf_GET BCMI_MADURA_MD_LANE3r_SLANE3_S2Lf_GET
#define MD_LANE3r_SLANE3_S2Lf_SET BCMI_MADURA_MD_LANE3r_SLANE3_S2Lf_SET
#define READ_MD_LANE3r BCMI_MADURA_READ_MD_LANE3r
#define WRITE_MD_LANE3r BCMI_MADURA_WRITE_MD_LANE3r
#define MODIFY_MD_LANE3r BCMI_MADURA_MODIFY_MD_LANE3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE4
 * BLOCKS:   DP
 * REGADDR:  0xa35e
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE4_S2L       mapping system side to line side mapping
 *     LLANE4_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE4r (0x0001a35e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE4r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE4.
 */
typedef union BCMI_MADURA_MD_LANE4r_s {
	uint32_t v[1];
	uint32_t md_lane4[1];
	uint32_t _md_lane4;
} BCMI_MADURA_MD_LANE4r_t;

#define BCMI_MADURA_MD_LANE4r_CLR(r) (r).md_lane4[0] = 0
#define BCMI_MADURA_MD_LANE4r_SET(r,d) (r).md_lane4[0] = d
#define BCMI_MADURA_MD_LANE4r_GET(r) (r).md_lane4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE4r_LLANE4_L2Sf_GET(r) ((((r).md_lane4[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE4r_LLANE4_L2Sf_SET(r,f) (r).md_lane4[0]=(((r).md_lane4[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE4r_SLANE4_S2Lf_GET(r) (((r).md_lane4[0]) & 0xff)
#define BCMI_MADURA_MD_LANE4r_SLANE4_S2Lf_SET(r,f) (r).md_lane4[0]=(((r).md_lane4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE4.
 */
#define BCMI_MADURA_READ_MD_LANE4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE4r,_r._md_lane4)
#define BCMI_MADURA_WRITE_MD_LANE4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE4r,_r._md_lane4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE4r BCMI_MADURA_MD_LANE4r
#define MD_LANE4r_SIZE BCMI_MADURA_MD_LANE4r_SIZE
typedef BCMI_MADURA_MD_LANE4r_t MD_LANE4r_t;
#define MD_LANE4r_CLR BCMI_MADURA_MD_LANE4r_CLR
#define MD_LANE4r_SET BCMI_MADURA_MD_LANE4r_SET
#define MD_LANE4r_GET BCMI_MADURA_MD_LANE4r_GET
#define MD_LANE4r_LLANE4_L2Sf_GET BCMI_MADURA_MD_LANE4r_LLANE4_L2Sf_GET
#define MD_LANE4r_LLANE4_L2Sf_SET BCMI_MADURA_MD_LANE4r_LLANE4_L2Sf_SET
#define MD_LANE4r_SLANE4_S2Lf_GET BCMI_MADURA_MD_LANE4r_SLANE4_S2Lf_GET
#define MD_LANE4r_SLANE4_S2Lf_SET BCMI_MADURA_MD_LANE4r_SLANE4_S2Lf_SET
#define READ_MD_LANE4r BCMI_MADURA_READ_MD_LANE4r
#define WRITE_MD_LANE4r BCMI_MADURA_WRITE_MD_LANE4r
#define MODIFY_MD_LANE4r BCMI_MADURA_MODIFY_MD_LANE4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE5
 * BLOCKS:   DP
 * REGADDR:  0xa35f
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE5_S2L       mapping system side to line side mapping
 *     LLANE5_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE5r (0x0001a35f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE5r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE5.
 */
typedef union BCMI_MADURA_MD_LANE5r_s {
	uint32_t v[1];
	uint32_t md_lane5[1];
	uint32_t _md_lane5;
} BCMI_MADURA_MD_LANE5r_t;

#define BCMI_MADURA_MD_LANE5r_CLR(r) (r).md_lane5[0] = 0
#define BCMI_MADURA_MD_LANE5r_SET(r,d) (r).md_lane5[0] = d
#define BCMI_MADURA_MD_LANE5r_GET(r) (r).md_lane5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE5r_LLANE5_L2Sf_GET(r) ((((r).md_lane5[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE5r_LLANE5_L2Sf_SET(r,f) (r).md_lane5[0]=(((r).md_lane5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE5r_SLANE5_S2Lf_GET(r) (((r).md_lane5[0]) & 0xff)
#define BCMI_MADURA_MD_LANE5r_SLANE5_S2Lf_SET(r,f) (r).md_lane5[0]=(((r).md_lane5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE5.
 */
#define BCMI_MADURA_READ_MD_LANE5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE5r,_r._md_lane5)
#define BCMI_MADURA_WRITE_MD_LANE5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE5r,_r._md_lane5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE5r BCMI_MADURA_MD_LANE5r
#define MD_LANE5r_SIZE BCMI_MADURA_MD_LANE5r_SIZE
typedef BCMI_MADURA_MD_LANE5r_t MD_LANE5r_t;
#define MD_LANE5r_CLR BCMI_MADURA_MD_LANE5r_CLR
#define MD_LANE5r_SET BCMI_MADURA_MD_LANE5r_SET
#define MD_LANE5r_GET BCMI_MADURA_MD_LANE5r_GET
#define MD_LANE5r_LLANE5_L2Sf_GET BCMI_MADURA_MD_LANE5r_LLANE5_L2Sf_GET
#define MD_LANE5r_LLANE5_L2Sf_SET BCMI_MADURA_MD_LANE5r_LLANE5_L2Sf_SET
#define MD_LANE5r_SLANE5_S2Lf_GET BCMI_MADURA_MD_LANE5r_SLANE5_S2Lf_GET
#define MD_LANE5r_SLANE5_S2Lf_SET BCMI_MADURA_MD_LANE5r_SLANE5_S2Lf_SET
#define READ_MD_LANE5r BCMI_MADURA_READ_MD_LANE5r
#define WRITE_MD_LANE5r BCMI_MADURA_WRITE_MD_LANE5r
#define MODIFY_MD_LANE5r BCMI_MADURA_MODIFY_MD_LANE5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE6
 * BLOCKS:   DP
 * REGADDR:  0xa360
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE6_S2L       mapping system side to line side mapping
 *     LLANE6_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE6r (0x0001a360 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE6r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE6.
 */
typedef union BCMI_MADURA_MD_LANE6r_s {
	uint32_t v[1];
	uint32_t md_lane6[1];
	uint32_t _md_lane6;
} BCMI_MADURA_MD_LANE6r_t;

#define BCMI_MADURA_MD_LANE6r_CLR(r) (r).md_lane6[0] = 0
#define BCMI_MADURA_MD_LANE6r_SET(r,d) (r).md_lane6[0] = d
#define BCMI_MADURA_MD_LANE6r_GET(r) (r).md_lane6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE6r_LLANE6_L2Sf_GET(r) ((((r).md_lane6[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE6r_LLANE6_L2Sf_SET(r,f) (r).md_lane6[0]=(((r).md_lane6[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE6r_SLANE6_S2Lf_GET(r) (((r).md_lane6[0]) & 0xff)
#define BCMI_MADURA_MD_LANE6r_SLANE6_S2Lf_SET(r,f) (r).md_lane6[0]=(((r).md_lane6[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE6.
 */
#define BCMI_MADURA_READ_MD_LANE6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE6r,_r._md_lane6)
#define BCMI_MADURA_WRITE_MD_LANE6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE6r,_r._md_lane6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE6r BCMI_MADURA_MD_LANE6r
#define MD_LANE6r_SIZE BCMI_MADURA_MD_LANE6r_SIZE
typedef BCMI_MADURA_MD_LANE6r_t MD_LANE6r_t;
#define MD_LANE6r_CLR BCMI_MADURA_MD_LANE6r_CLR
#define MD_LANE6r_SET BCMI_MADURA_MD_LANE6r_SET
#define MD_LANE6r_GET BCMI_MADURA_MD_LANE6r_GET
#define MD_LANE6r_LLANE6_L2Sf_GET BCMI_MADURA_MD_LANE6r_LLANE6_L2Sf_GET
#define MD_LANE6r_LLANE6_L2Sf_SET BCMI_MADURA_MD_LANE6r_LLANE6_L2Sf_SET
#define MD_LANE6r_SLANE6_S2Lf_GET BCMI_MADURA_MD_LANE6r_SLANE6_S2Lf_GET
#define MD_LANE6r_SLANE6_S2Lf_SET BCMI_MADURA_MD_LANE6r_SLANE6_S2Lf_SET
#define READ_MD_LANE6r BCMI_MADURA_READ_MD_LANE6r
#define WRITE_MD_LANE6r BCMI_MADURA_WRITE_MD_LANE6r
#define MODIFY_MD_LANE6r BCMI_MADURA_MODIFY_MD_LANE6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MD_LANE7
 * BLOCKS:   DP
 * REGADDR:  0xa361
 * DEVAD:    1
 * DESC:     lane mapping related information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SLANE7_S2L       mapping system side to line side mapping
 *     LLANE7_L2S       mapping line side to system side mapping
 */
#define BCMI_MADURA_MD_LANE7r (0x0001a361 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MD_LANE7r_SIZE 4

/*
 * This structure should be used to declare and program MD_LANE7.
 */
typedef union BCMI_MADURA_MD_LANE7r_s {
	uint32_t v[1];
	uint32_t md_lane7[1];
	uint32_t _md_lane7;
} BCMI_MADURA_MD_LANE7r_t;

#define BCMI_MADURA_MD_LANE7r_CLR(r) (r).md_lane7[0] = 0
#define BCMI_MADURA_MD_LANE7r_SET(r,d) (r).md_lane7[0] = d
#define BCMI_MADURA_MD_LANE7r_GET(r) (r).md_lane7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MD_LANE7r_LLANE7_L2Sf_GET(r) ((((r).md_lane7[0]) >> 8) & 0xff)
#define BCMI_MADURA_MD_LANE7r_LLANE7_L2Sf_SET(r,f) (r).md_lane7[0]=(((r).md_lane7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_MD_LANE7r_SLANE7_S2Lf_GET(r) (((r).md_lane7[0]) & 0xff)
#define BCMI_MADURA_MD_LANE7r_SLANE7_S2Lf_SET(r,f) (r).md_lane7[0]=(((r).md_lane7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MD_LANE7.
 */
#define BCMI_MADURA_READ_MD_LANE7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MD_LANE7r,_r._md_lane7)
#define BCMI_MADURA_WRITE_MD_LANE7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MD_LANE7r,_r._md_lane7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MD_LANE7r BCMI_MADURA_MD_LANE7r
#define MD_LANE7r_SIZE BCMI_MADURA_MD_LANE7r_SIZE
typedef BCMI_MADURA_MD_LANE7r_t MD_LANE7r_t;
#define MD_LANE7r_CLR BCMI_MADURA_MD_LANE7r_CLR
#define MD_LANE7r_SET BCMI_MADURA_MD_LANE7r_SET
#define MD_LANE7r_GET BCMI_MADURA_MD_LANE7r_GET
#define MD_LANE7r_LLANE7_L2Sf_GET BCMI_MADURA_MD_LANE7r_LLANE7_L2Sf_GET
#define MD_LANE7r_LLANE7_L2Sf_SET BCMI_MADURA_MD_LANE7r_LLANE7_L2Sf_SET
#define MD_LANE7r_SLANE7_S2Lf_GET BCMI_MADURA_MD_LANE7r_SLANE7_S2Lf_GET
#define MD_LANE7r_SLANE7_S2Lf_SET BCMI_MADURA_MD_LANE7r_SLANE7_S2Lf_SET
#define READ_MD_LANE7r BCMI_MADURA_READ_MD_LANE7r
#define WRITE_MD_LANE7r BCMI_MADURA_WRITE_MD_LANE7r
#define MODIFY_MD_LANE7r BCMI_MADURA_MODIFY_MD_LANE7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MD_LANE7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL0
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa800
 * DEVAD:    1
 * DESC:     control register-0 for PI mux controls for transmit lane-0, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_0  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_0 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_0 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL0r (0x0001a800 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL0r_SIZE 4

/*
 * This structure should be used to declare and program LCTL0.
 */
typedef union BCMI_MADURA_LCTL0r_s {
	uint32_t v[1];
	uint32_t lctl0[1];
	uint32_t _lctl0;
} BCMI_MADURA_LCTL0r_t;

#define BCMI_MADURA_LCTL0r_CLR(r) (r).lctl0[0] = 0
#define BCMI_MADURA_LCTL0r_SET(r,d) (r).lctl0[0] = d
#define BCMI_MADURA_LCTL0r_GET(r) (r).lctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL0r_LINE_FRC_RATE_SEL_0f_GET(r) ((((r).lctl0[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL0r_LINE_FRC_RATE_SEL_0f_SET(r,f) (r).lctl0[0]=(((r).lctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL0r_LINE_FRC_CDR_PHASE_0f_GET(r) ((((r).lctl0[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL0r_LINE_FRC_CDR_PHASE_0f_SET(r,f) (r).lctl0[0]=(((r).lctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL0r_LINE_SEL_LANE_0f_GET(r) (((r).lctl0[0]) & 0x7)
#define BCMI_MADURA_LCTL0r_LINE_SEL_LANE_0f_SET(r,f) (r).lctl0[0]=(((r).lctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL0.
 */
#define BCMI_MADURA_READ_LCTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL0r,_r._lctl0)
#define BCMI_MADURA_WRITE_LCTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL0r,_r._lctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL0r BCMI_MADURA_LCTL0r
#define LCTL0r_SIZE BCMI_MADURA_LCTL0r_SIZE
typedef BCMI_MADURA_LCTL0r_t LCTL0r_t;
#define LCTL0r_CLR BCMI_MADURA_LCTL0r_CLR
#define LCTL0r_SET BCMI_MADURA_LCTL0r_SET
#define LCTL0r_GET BCMI_MADURA_LCTL0r_GET
#define LCTL0r_LINE_FRC_RATE_SEL_0f_GET BCMI_MADURA_LCTL0r_LINE_FRC_RATE_SEL_0f_GET
#define LCTL0r_LINE_FRC_RATE_SEL_0f_SET BCMI_MADURA_LCTL0r_LINE_FRC_RATE_SEL_0f_SET
#define LCTL0r_LINE_FRC_CDR_PHASE_0f_GET BCMI_MADURA_LCTL0r_LINE_FRC_CDR_PHASE_0f_GET
#define LCTL0r_LINE_FRC_CDR_PHASE_0f_SET BCMI_MADURA_LCTL0r_LINE_FRC_CDR_PHASE_0f_SET
#define LCTL0r_LINE_SEL_LANE_0f_GET BCMI_MADURA_LCTL0r_LINE_SEL_LANE_0f_GET
#define LCTL0r_LINE_SEL_LANE_0f_SET BCMI_MADURA_LCTL0r_LINE_SEL_LANE_0f_SET
#define READ_LCTL0r BCMI_MADURA_READ_LCTL0r
#define WRITE_LCTL0r BCMI_MADURA_WRITE_LCTL0r
#define MODIFY_LCTL0r BCMI_MADURA_MODIFY_LCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL1
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa801
 * DEVAD:    1
 * DESC:     control register-1 for PI mux controls for transmit lane-1, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_1  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_1 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_1 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL1r (0x0001a801 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL1r_SIZE 4

/*
 * This structure should be used to declare and program LCTL1.
 */
typedef union BCMI_MADURA_LCTL1r_s {
	uint32_t v[1];
	uint32_t lctl1[1];
	uint32_t _lctl1;
} BCMI_MADURA_LCTL1r_t;

#define BCMI_MADURA_LCTL1r_CLR(r) (r).lctl1[0] = 0
#define BCMI_MADURA_LCTL1r_SET(r,d) (r).lctl1[0] = d
#define BCMI_MADURA_LCTL1r_GET(r) (r).lctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL1r_LINE_FRC_RATE_SEL_1f_GET(r) ((((r).lctl1[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL1r_LINE_FRC_RATE_SEL_1f_SET(r,f) (r).lctl1[0]=(((r).lctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL1r_LINE_FRC_CDR_PHASE_1f_GET(r) ((((r).lctl1[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL1r_LINE_FRC_CDR_PHASE_1f_SET(r,f) (r).lctl1[0]=(((r).lctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL1r_LINE_SEL_LANE_1f_GET(r) (((r).lctl1[0]) & 0x7)
#define BCMI_MADURA_LCTL1r_LINE_SEL_LANE_1f_SET(r,f) (r).lctl1[0]=(((r).lctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL1.
 */
#define BCMI_MADURA_READ_LCTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL1r,_r._lctl1)
#define BCMI_MADURA_WRITE_LCTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL1r,_r._lctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL1r BCMI_MADURA_LCTL1r
#define LCTL1r_SIZE BCMI_MADURA_LCTL1r_SIZE
typedef BCMI_MADURA_LCTL1r_t LCTL1r_t;
#define LCTL1r_CLR BCMI_MADURA_LCTL1r_CLR
#define LCTL1r_SET BCMI_MADURA_LCTL1r_SET
#define LCTL1r_GET BCMI_MADURA_LCTL1r_GET
#define LCTL1r_LINE_FRC_RATE_SEL_1f_GET BCMI_MADURA_LCTL1r_LINE_FRC_RATE_SEL_1f_GET
#define LCTL1r_LINE_FRC_RATE_SEL_1f_SET BCMI_MADURA_LCTL1r_LINE_FRC_RATE_SEL_1f_SET
#define LCTL1r_LINE_FRC_CDR_PHASE_1f_GET BCMI_MADURA_LCTL1r_LINE_FRC_CDR_PHASE_1f_GET
#define LCTL1r_LINE_FRC_CDR_PHASE_1f_SET BCMI_MADURA_LCTL1r_LINE_FRC_CDR_PHASE_1f_SET
#define LCTL1r_LINE_SEL_LANE_1f_GET BCMI_MADURA_LCTL1r_LINE_SEL_LANE_1f_GET
#define LCTL1r_LINE_SEL_LANE_1f_SET BCMI_MADURA_LCTL1r_LINE_SEL_LANE_1f_SET
#define READ_LCTL1r BCMI_MADURA_READ_LCTL1r
#define WRITE_LCTL1r BCMI_MADURA_WRITE_LCTL1r
#define MODIFY_LCTL1r BCMI_MADURA_MODIFY_LCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL2
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa802
 * DEVAD:    1
 * DESC:     control register-2 for PI mux controls for transmit lane-2, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_2  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_2 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_2 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL2r (0x0001a802 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL2r_SIZE 4

/*
 * This structure should be used to declare and program LCTL2.
 */
typedef union BCMI_MADURA_LCTL2r_s {
	uint32_t v[1];
	uint32_t lctl2[1];
	uint32_t _lctl2;
} BCMI_MADURA_LCTL2r_t;

#define BCMI_MADURA_LCTL2r_CLR(r) (r).lctl2[0] = 0
#define BCMI_MADURA_LCTL2r_SET(r,d) (r).lctl2[0] = d
#define BCMI_MADURA_LCTL2r_GET(r) (r).lctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL2r_LINE_FRC_RATE_SEL_2f_GET(r) ((((r).lctl2[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL2r_LINE_FRC_RATE_SEL_2f_SET(r,f) (r).lctl2[0]=(((r).lctl2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL2r_LINE_FRC_CDR_PHASE_2f_GET(r) ((((r).lctl2[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL2r_LINE_FRC_CDR_PHASE_2f_SET(r,f) (r).lctl2[0]=(((r).lctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL2r_LINE_SEL_LANE_2f_GET(r) (((r).lctl2[0]) & 0x7)
#define BCMI_MADURA_LCTL2r_LINE_SEL_LANE_2f_SET(r,f) (r).lctl2[0]=(((r).lctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL2.
 */
#define BCMI_MADURA_READ_LCTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL2r,_r._lctl2)
#define BCMI_MADURA_WRITE_LCTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL2r,_r._lctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL2r BCMI_MADURA_LCTL2r
#define LCTL2r_SIZE BCMI_MADURA_LCTL2r_SIZE
typedef BCMI_MADURA_LCTL2r_t LCTL2r_t;
#define LCTL2r_CLR BCMI_MADURA_LCTL2r_CLR
#define LCTL2r_SET BCMI_MADURA_LCTL2r_SET
#define LCTL2r_GET BCMI_MADURA_LCTL2r_GET
#define LCTL2r_LINE_FRC_RATE_SEL_2f_GET BCMI_MADURA_LCTL2r_LINE_FRC_RATE_SEL_2f_GET
#define LCTL2r_LINE_FRC_RATE_SEL_2f_SET BCMI_MADURA_LCTL2r_LINE_FRC_RATE_SEL_2f_SET
#define LCTL2r_LINE_FRC_CDR_PHASE_2f_GET BCMI_MADURA_LCTL2r_LINE_FRC_CDR_PHASE_2f_GET
#define LCTL2r_LINE_FRC_CDR_PHASE_2f_SET BCMI_MADURA_LCTL2r_LINE_FRC_CDR_PHASE_2f_SET
#define LCTL2r_LINE_SEL_LANE_2f_GET BCMI_MADURA_LCTL2r_LINE_SEL_LANE_2f_GET
#define LCTL2r_LINE_SEL_LANE_2f_SET BCMI_MADURA_LCTL2r_LINE_SEL_LANE_2f_SET
#define READ_LCTL2r BCMI_MADURA_READ_LCTL2r
#define WRITE_LCTL2r BCMI_MADURA_WRITE_LCTL2r
#define MODIFY_LCTL2r BCMI_MADURA_MODIFY_LCTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL3
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa803
 * DEVAD:    1
 * DESC:     control register-3 for PI mux controls for transmit lane-3, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_3  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_3 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_3 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL3r (0x0001a803 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL3r_SIZE 4

/*
 * This structure should be used to declare and program LCTL3.
 */
typedef union BCMI_MADURA_LCTL3r_s {
	uint32_t v[1];
	uint32_t lctl3[1];
	uint32_t _lctl3;
} BCMI_MADURA_LCTL3r_t;

#define BCMI_MADURA_LCTL3r_CLR(r) (r).lctl3[0] = 0
#define BCMI_MADURA_LCTL3r_SET(r,d) (r).lctl3[0] = d
#define BCMI_MADURA_LCTL3r_GET(r) (r).lctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL3r_LINE_FRC_RATE_SEL_3f_GET(r) ((((r).lctl3[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL3r_LINE_FRC_RATE_SEL_3f_SET(r,f) (r).lctl3[0]=(((r).lctl3[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL3r_LINE_FRC_CDR_PHASE_3f_GET(r) ((((r).lctl3[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL3r_LINE_FRC_CDR_PHASE_3f_SET(r,f) (r).lctl3[0]=(((r).lctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL3r_LINE_SEL_LANE_3f_GET(r) (((r).lctl3[0]) & 0x7)
#define BCMI_MADURA_LCTL3r_LINE_SEL_LANE_3f_SET(r,f) (r).lctl3[0]=(((r).lctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL3.
 */
#define BCMI_MADURA_READ_LCTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL3r,_r._lctl3)
#define BCMI_MADURA_WRITE_LCTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL3r,_r._lctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL3r BCMI_MADURA_LCTL3r
#define LCTL3r_SIZE BCMI_MADURA_LCTL3r_SIZE
typedef BCMI_MADURA_LCTL3r_t LCTL3r_t;
#define LCTL3r_CLR BCMI_MADURA_LCTL3r_CLR
#define LCTL3r_SET BCMI_MADURA_LCTL3r_SET
#define LCTL3r_GET BCMI_MADURA_LCTL3r_GET
#define LCTL3r_LINE_FRC_RATE_SEL_3f_GET BCMI_MADURA_LCTL3r_LINE_FRC_RATE_SEL_3f_GET
#define LCTL3r_LINE_FRC_RATE_SEL_3f_SET BCMI_MADURA_LCTL3r_LINE_FRC_RATE_SEL_3f_SET
#define LCTL3r_LINE_FRC_CDR_PHASE_3f_GET BCMI_MADURA_LCTL3r_LINE_FRC_CDR_PHASE_3f_GET
#define LCTL3r_LINE_FRC_CDR_PHASE_3f_SET BCMI_MADURA_LCTL3r_LINE_FRC_CDR_PHASE_3f_SET
#define LCTL3r_LINE_SEL_LANE_3f_GET BCMI_MADURA_LCTL3r_LINE_SEL_LANE_3f_GET
#define LCTL3r_LINE_SEL_LANE_3f_SET BCMI_MADURA_LCTL3r_LINE_SEL_LANE_3f_SET
#define READ_LCTL3r BCMI_MADURA_READ_LCTL3r
#define WRITE_LCTL3r BCMI_MADURA_WRITE_LCTL3r
#define MODIFY_LCTL3r BCMI_MADURA_MODIFY_LCTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL4
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa804
 * DEVAD:    1
 * DESC:     control register-4 for PI mux controls for transmit lane-4, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_4  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_4 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_4 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL4r (0x0001a804 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL4r_SIZE 4

/*
 * This structure should be used to declare and program LCTL4.
 */
typedef union BCMI_MADURA_LCTL4r_s {
	uint32_t v[1];
	uint32_t lctl4[1];
	uint32_t _lctl4;
} BCMI_MADURA_LCTL4r_t;

#define BCMI_MADURA_LCTL4r_CLR(r) (r).lctl4[0] = 0
#define BCMI_MADURA_LCTL4r_SET(r,d) (r).lctl4[0] = d
#define BCMI_MADURA_LCTL4r_GET(r) (r).lctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL4r_LINE_FRC_RATE_SEL_4f_GET(r) ((((r).lctl4[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL4r_LINE_FRC_RATE_SEL_4f_SET(r,f) (r).lctl4[0]=(((r).lctl4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL4r_LINE_FRC_CDR_PHASE_4f_GET(r) ((((r).lctl4[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL4r_LINE_FRC_CDR_PHASE_4f_SET(r,f) (r).lctl4[0]=(((r).lctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL4r_LINE_SEL_LANE_4f_GET(r) (((r).lctl4[0]) & 0x7)
#define BCMI_MADURA_LCTL4r_LINE_SEL_LANE_4f_SET(r,f) (r).lctl4[0]=(((r).lctl4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL4.
 */
#define BCMI_MADURA_READ_LCTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL4r,_r._lctl4)
#define BCMI_MADURA_WRITE_LCTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL4r,_r._lctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL4r BCMI_MADURA_LCTL4r
#define LCTL4r_SIZE BCMI_MADURA_LCTL4r_SIZE
typedef BCMI_MADURA_LCTL4r_t LCTL4r_t;
#define LCTL4r_CLR BCMI_MADURA_LCTL4r_CLR
#define LCTL4r_SET BCMI_MADURA_LCTL4r_SET
#define LCTL4r_GET BCMI_MADURA_LCTL4r_GET
#define LCTL4r_LINE_FRC_RATE_SEL_4f_GET BCMI_MADURA_LCTL4r_LINE_FRC_RATE_SEL_4f_GET
#define LCTL4r_LINE_FRC_RATE_SEL_4f_SET BCMI_MADURA_LCTL4r_LINE_FRC_RATE_SEL_4f_SET
#define LCTL4r_LINE_FRC_CDR_PHASE_4f_GET BCMI_MADURA_LCTL4r_LINE_FRC_CDR_PHASE_4f_GET
#define LCTL4r_LINE_FRC_CDR_PHASE_4f_SET BCMI_MADURA_LCTL4r_LINE_FRC_CDR_PHASE_4f_SET
#define LCTL4r_LINE_SEL_LANE_4f_GET BCMI_MADURA_LCTL4r_LINE_SEL_LANE_4f_GET
#define LCTL4r_LINE_SEL_LANE_4f_SET BCMI_MADURA_LCTL4r_LINE_SEL_LANE_4f_SET
#define READ_LCTL4r BCMI_MADURA_READ_LCTL4r
#define WRITE_LCTL4r BCMI_MADURA_WRITE_LCTL4r
#define MODIFY_LCTL4r BCMI_MADURA_MODIFY_LCTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL5
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa805
 * DEVAD:    1
 * DESC:     control register-5 for PI mux controls for transmit lane-5, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_5  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_5 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_5 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL5r (0x0001a805 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL5r_SIZE 4

/*
 * This structure should be used to declare and program LCTL5.
 */
typedef union BCMI_MADURA_LCTL5r_s {
	uint32_t v[1];
	uint32_t lctl5[1];
	uint32_t _lctl5;
} BCMI_MADURA_LCTL5r_t;

#define BCMI_MADURA_LCTL5r_CLR(r) (r).lctl5[0] = 0
#define BCMI_MADURA_LCTL5r_SET(r,d) (r).lctl5[0] = d
#define BCMI_MADURA_LCTL5r_GET(r) (r).lctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL5r_LINE_FRC_RATE_SEL_5f_GET(r) ((((r).lctl5[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL5r_LINE_FRC_RATE_SEL_5f_SET(r,f) (r).lctl5[0]=(((r).lctl5[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL5r_LINE_FRC_CDR_PHASE_5f_GET(r) ((((r).lctl5[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL5r_LINE_FRC_CDR_PHASE_5f_SET(r,f) (r).lctl5[0]=(((r).lctl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL5r_LINE_SEL_LANE_5f_GET(r) (((r).lctl5[0]) & 0x7)
#define BCMI_MADURA_LCTL5r_LINE_SEL_LANE_5f_SET(r,f) (r).lctl5[0]=(((r).lctl5[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL5.
 */
#define BCMI_MADURA_READ_LCTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL5r,_r._lctl5)
#define BCMI_MADURA_WRITE_LCTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL5r,_r._lctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL5r BCMI_MADURA_LCTL5r
#define LCTL5r_SIZE BCMI_MADURA_LCTL5r_SIZE
typedef BCMI_MADURA_LCTL5r_t LCTL5r_t;
#define LCTL5r_CLR BCMI_MADURA_LCTL5r_CLR
#define LCTL5r_SET BCMI_MADURA_LCTL5r_SET
#define LCTL5r_GET BCMI_MADURA_LCTL5r_GET
#define LCTL5r_LINE_FRC_RATE_SEL_5f_GET BCMI_MADURA_LCTL5r_LINE_FRC_RATE_SEL_5f_GET
#define LCTL5r_LINE_FRC_RATE_SEL_5f_SET BCMI_MADURA_LCTL5r_LINE_FRC_RATE_SEL_5f_SET
#define LCTL5r_LINE_FRC_CDR_PHASE_5f_GET BCMI_MADURA_LCTL5r_LINE_FRC_CDR_PHASE_5f_GET
#define LCTL5r_LINE_FRC_CDR_PHASE_5f_SET BCMI_MADURA_LCTL5r_LINE_FRC_CDR_PHASE_5f_SET
#define LCTL5r_LINE_SEL_LANE_5f_GET BCMI_MADURA_LCTL5r_LINE_SEL_LANE_5f_GET
#define LCTL5r_LINE_SEL_LANE_5f_SET BCMI_MADURA_LCTL5r_LINE_SEL_LANE_5f_SET
#define READ_LCTL5r BCMI_MADURA_READ_LCTL5r
#define WRITE_LCTL5r BCMI_MADURA_WRITE_LCTL5r
#define MODIFY_LCTL5r BCMI_MADURA_MODIFY_LCTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL6
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa806
 * DEVAD:    1
 * DESC:     control register-6 for PI mux controls for transmit lane-6, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_6  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_6 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_6 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL6r (0x0001a806 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL6r_SIZE 4

/*
 * This structure should be used to declare and program LCTL6.
 */
typedef union BCMI_MADURA_LCTL6r_s {
	uint32_t v[1];
	uint32_t lctl6[1];
	uint32_t _lctl6;
} BCMI_MADURA_LCTL6r_t;

#define BCMI_MADURA_LCTL6r_CLR(r) (r).lctl6[0] = 0
#define BCMI_MADURA_LCTL6r_SET(r,d) (r).lctl6[0] = d
#define BCMI_MADURA_LCTL6r_GET(r) (r).lctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL6r_LINE_FRC_RATE_SEL_6f_GET(r) ((((r).lctl6[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL6r_LINE_FRC_RATE_SEL_6f_SET(r,f) (r).lctl6[0]=(((r).lctl6[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL6r_LINE_FRC_CDR_PHASE_6f_GET(r) ((((r).lctl6[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL6r_LINE_FRC_CDR_PHASE_6f_SET(r,f) (r).lctl6[0]=(((r).lctl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL6r_LINE_SEL_LANE_6f_GET(r) (((r).lctl6[0]) & 0x7)
#define BCMI_MADURA_LCTL6r_LINE_SEL_LANE_6f_SET(r,f) (r).lctl6[0]=(((r).lctl6[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL6.
 */
#define BCMI_MADURA_READ_LCTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL6r,_r._lctl6)
#define BCMI_MADURA_WRITE_LCTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL6r,_r._lctl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL6r BCMI_MADURA_LCTL6r
#define LCTL6r_SIZE BCMI_MADURA_LCTL6r_SIZE
typedef BCMI_MADURA_LCTL6r_t LCTL6r_t;
#define LCTL6r_CLR BCMI_MADURA_LCTL6r_CLR
#define LCTL6r_SET BCMI_MADURA_LCTL6r_SET
#define LCTL6r_GET BCMI_MADURA_LCTL6r_GET
#define LCTL6r_LINE_FRC_RATE_SEL_6f_GET BCMI_MADURA_LCTL6r_LINE_FRC_RATE_SEL_6f_GET
#define LCTL6r_LINE_FRC_RATE_SEL_6f_SET BCMI_MADURA_LCTL6r_LINE_FRC_RATE_SEL_6f_SET
#define LCTL6r_LINE_FRC_CDR_PHASE_6f_GET BCMI_MADURA_LCTL6r_LINE_FRC_CDR_PHASE_6f_GET
#define LCTL6r_LINE_FRC_CDR_PHASE_6f_SET BCMI_MADURA_LCTL6r_LINE_FRC_CDR_PHASE_6f_SET
#define LCTL6r_LINE_SEL_LANE_6f_GET BCMI_MADURA_LCTL6r_LINE_SEL_LANE_6f_GET
#define LCTL6r_LINE_SEL_LANE_6f_SET BCMI_MADURA_LCTL6r_LINE_SEL_LANE_6f_SET
#define READ_LCTL6r BCMI_MADURA_READ_LCTL6r
#define WRITE_LCTL6r BCMI_MADURA_WRITE_LCTL6r
#define MODIFY_LCTL6r BCMI_MADURA_MODIFY_LCTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LCTL7
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa807
 * DEVAD:    1
 * DESC:     control register-7 for PI mux controls for transmit lane-7, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_SEL_LANE_7  select the CDR phase receive lane that needs to go in to the transmit lane
 *     LINE_FRC_CDR_PHASE_7 override the mode_decode based controls and use line_sel_lane to select the receive lane
 *     LINE_FRC_RATE_SEL_7 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_LCTL7r (0x0001a807 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LCTL7r_SIZE 4

/*
 * This structure should be used to declare and program LCTL7.
 */
typedef union BCMI_MADURA_LCTL7r_s {
	uint32_t v[1];
	uint32_t lctl7[1];
	uint32_t _lctl7;
} BCMI_MADURA_LCTL7r_t;

#define BCMI_MADURA_LCTL7r_CLR(r) (r).lctl7[0] = 0
#define BCMI_MADURA_LCTL7r_SET(r,d) (r).lctl7[0] = d
#define BCMI_MADURA_LCTL7r_GET(r) (r).lctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LCTL7r_LINE_FRC_RATE_SEL_7f_GET(r) ((((r).lctl7[0]) >> 8) & 0x3)
#define BCMI_MADURA_LCTL7r_LINE_FRC_RATE_SEL_7f_SET(r,f) (r).lctl7[0]=(((r).lctl7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_LCTL7r_LINE_FRC_CDR_PHASE_7f_GET(r) ((((r).lctl7[0]) >> 4) & 0x1)
#define BCMI_MADURA_LCTL7r_LINE_FRC_CDR_PHASE_7f_SET(r,f) (r).lctl7[0]=(((r).lctl7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LCTL7r_LINE_SEL_LANE_7f_GET(r) (((r).lctl7[0]) & 0x7)
#define BCMI_MADURA_LCTL7r_LINE_SEL_LANE_7f_SET(r,f) (r).lctl7[0]=(((r).lctl7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LCTL7.
 */
#define BCMI_MADURA_READ_LCTL7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LCTL7r,_r._lctl7)
#define BCMI_MADURA_WRITE_LCTL7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LCTL7r,_r._lctl7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LCTL7r BCMI_MADURA_LCTL7r
#define LCTL7r_SIZE BCMI_MADURA_LCTL7r_SIZE
typedef BCMI_MADURA_LCTL7r_t LCTL7r_t;
#define LCTL7r_CLR BCMI_MADURA_LCTL7r_CLR
#define LCTL7r_SET BCMI_MADURA_LCTL7r_SET
#define LCTL7r_GET BCMI_MADURA_LCTL7r_GET
#define LCTL7r_LINE_FRC_RATE_SEL_7f_GET BCMI_MADURA_LCTL7r_LINE_FRC_RATE_SEL_7f_GET
#define LCTL7r_LINE_FRC_RATE_SEL_7f_SET BCMI_MADURA_LCTL7r_LINE_FRC_RATE_SEL_7f_SET
#define LCTL7r_LINE_FRC_CDR_PHASE_7f_GET BCMI_MADURA_LCTL7r_LINE_FRC_CDR_PHASE_7f_GET
#define LCTL7r_LINE_FRC_CDR_PHASE_7f_SET BCMI_MADURA_LCTL7r_LINE_FRC_CDR_PHASE_7f_SET
#define LCTL7r_LINE_SEL_LANE_7f_GET BCMI_MADURA_LCTL7r_LINE_SEL_LANE_7f_GET
#define LCTL7r_LINE_SEL_LANE_7f_SET BCMI_MADURA_LCTL7r_LINE_SEL_LANE_7f_SET
#define READ_LCTL7r BCMI_MADURA_READ_LCTL7r
#define WRITE_LCTL7r BCMI_MADURA_WRITE_LCTL7r
#define MODIFY_LCTL7r BCMI_MADURA_MODIFY_LCTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LCTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LALTER
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa808
 * DEVAD:    1
 * DESC:     control register for PI mux controls for transmit lane[0 7], line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINE_ALTER       In 2:1 mode there are two options for picking the lanes for phase transfer lanes 0 or 1 from system sideeach bit represents a unique transmit lane
 */
#define BCMI_MADURA_LALTERr (0x0001a808 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LALTERr_SIZE 4

/*
 * This structure should be used to declare and program LALTER.
 */
typedef union BCMI_MADURA_LALTERr_s {
	uint32_t v[1];
	uint32_t lalter[1];
	uint32_t _lalter;
} BCMI_MADURA_LALTERr_t;

#define BCMI_MADURA_LALTERr_CLR(r) (r).lalter[0] = 0
#define BCMI_MADURA_LALTERr_SET(r,d) (r).lalter[0] = d
#define BCMI_MADURA_LALTERr_GET(r) (r).lalter[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LALTERr_LINE_ALTERf_GET(r) (((r).lalter[0]) & 0xff)
#define BCMI_MADURA_LALTERr_LINE_ALTERf_SET(r,f) (r).lalter[0]=(((r).lalter[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access LALTER.
 */
#define BCMI_MADURA_READ_LALTERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LALTERr,_r._lalter)
#define BCMI_MADURA_WRITE_LALTERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LALTERr,_r._lalter)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LALTERr BCMI_MADURA_LALTERr
#define LALTERr_SIZE BCMI_MADURA_LALTERr_SIZE
typedef BCMI_MADURA_LALTERr_t LALTERr_t;
#define LALTERr_CLR BCMI_MADURA_LALTERr_CLR
#define LALTERr_SET BCMI_MADURA_LALTERr_SET
#define LALTERr_GET BCMI_MADURA_LALTERr_GET
#define LALTERr_LINE_ALTERf_GET BCMI_MADURA_LALTERr_LINE_ALTERf_GET
#define LALTERr_LINE_ALTERf_SET BCMI_MADURA_LALTERr_LINE_ALTERf_SET
#define READ_LALTERr BCMI_MADURA_READ_LALTERr
#define WRITE_LALTERr BCMI_MADURA_WRITE_LALTERr
#define MODIFY_LALTERr BCMI_MADURA_MODIFY_LALTERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LALTERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL0
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa810
 * DEVAD:    1
 * DESC:     control register-0 for PI mux controls for transmit lane-0, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_0   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_0 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_0 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL0r (0x0001a810 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL0r_SIZE 4

/*
 * This structure should be used to declare and program SCTL0.
 */
typedef union BCMI_MADURA_SCTL0r_s {
	uint32_t v[1];
	uint32_t sctl0[1];
	uint32_t _sctl0;
} BCMI_MADURA_SCTL0r_t;

#define BCMI_MADURA_SCTL0r_CLR(r) (r).sctl0[0] = 0
#define BCMI_MADURA_SCTL0r_SET(r,d) (r).sctl0[0] = d
#define BCMI_MADURA_SCTL0r_GET(r) (r).sctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL0r_SYS_FRC_RATE_SEL_0f_GET(r) ((((r).sctl0[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL0r_SYS_FRC_RATE_SEL_0f_SET(r,f) (r).sctl0[0]=(((r).sctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL0r_SYS_FRC_CDR_PHASE_0f_GET(r) ((((r).sctl0[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL0r_SYS_FRC_CDR_PHASE_0f_SET(r,f) (r).sctl0[0]=(((r).sctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL0r_SYS_SEL_LANE_0f_GET(r) (((r).sctl0[0]) & 0x7)
#define BCMI_MADURA_SCTL0r_SYS_SEL_LANE_0f_SET(r,f) (r).sctl0[0]=(((r).sctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL0.
 */
#define BCMI_MADURA_READ_SCTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL0r,_r._sctl0)
#define BCMI_MADURA_WRITE_SCTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL0r,_r._sctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL0r BCMI_MADURA_SCTL0r
#define SCTL0r_SIZE BCMI_MADURA_SCTL0r_SIZE
typedef BCMI_MADURA_SCTL0r_t SCTL0r_t;
#define SCTL0r_CLR BCMI_MADURA_SCTL0r_CLR
#define SCTL0r_SET BCMI_MADURA_SCTL0r_SET
#define SCTL0r_GET BCMI_MADURA_SCTL0r_GET
#define SCTL0r_SYS_FRC_RATE_SEL_0f_GET BCMI_MADURA_SCTL0r_SYS_FRC_RATE_SEL_0f_GET
#define SCTL0r_SYS_FRC_RATE_SEL_0f_SET BCMI_MADURA_SCTL0r_SYS_FRC_RATE_SEL_0f_SET
#define SCTL0r_SYS_FRC_CDR_PHASE_0f_GET BCMI_MADURA_SCTL0r_SYS_FRC_CDR_PHASE_0f_GET
#define SCTL0r_SYS_FRC_CDR_PHASE_0f_SET BCMI_MADURA_SCTL0r_SYS_FRC_CDR_PHASE_0f_SET
#define SCTL0r_SYS_SEL_LANE_0f_GET BCMI_MADURA_SCTL0r_SYS_SEL_LANE_0f_GET
#define SCTL0r_SYS_SEL_LANE_0f_SET BCMI_MADURA_SCTL0r_SYS_SEL_LANE_0f_SET
#define READ_SCTL0r BCMI_MADURA_READ_SCTL0r
#define WRITE_SCTL0r BCMI_MADURA_WRITE_SCTL0r
#define MODIFY_SCTL0r BCMI_MADURA_MODIFY_SCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL1
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa811
 * DEVAD:    1
 * DESC:     control register-1 for PI mux controls for transmit lane-1, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_1   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_1 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_1 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL1r (0x0001a811 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL1r_SIZE 4

/*
 * This structure should be used to declare and program SCTL1.
 */
typedef union BCMI_MADURA_SCTL1r_s {
	uint32_t v[1];
	uint32_t sctl1[1];
	uint32_t _sctl1;
} BCMI_MADURA_SCTL1r_t;

#define BCMI_MADURA_SCTL1r_CLR(r) (r).sctl1[0] = 0
#define BCMI_MADURA_SCTL1r_SET(r,d) (r).sctl1[0] = d
#define BCMI_MADURA_SCTL1r_GET(r) (r).sctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL1r_SYS_FRC_RATE_SEL_1f_GET(r) ((((r).sctl1[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL1r_SYS_FRC_RATE_SEL_1f_SET(r,f) (r).sctl1[0]=(((r).sctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL1r_SYS_FRC_CDR_PHASE_1f_GET(r) ((((r).sctl1[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL1r_SYS_FRC_CDR_PHASE_1f_SET(r,f) (r).sctl1[0]=(((r).sctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL1r_SYS_SEL_LANE_1f_GET(r) (((r).sctl1[0]) & 0x7)
#define BCMI_MADURA_SCTL1r_SYS_SEL_LANE_1f_SET(r,f) (r).sctl1[0]=(((r).sctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL1.
 */
#define BCMI_MADURA_READ_SCTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL1r,_r._sctl1)
#define BCMI_MADURA_WRITE_SCTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL1r,_r._sctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL1r BCMI_MADURA_SCTL1r
#define SCTL1r_SIZE BCMI_MADURA_SCTL1r_SIZE
typedef BCMI_MADURA_SCTL1r_t SCTL1r_t;
#define SCTL1r_CLR BCMI_MADURA_SCTL1r_CLR
#define SCTL1r_SET BCMI_MADURA_SCTL1r_SET
#define SCTL1r_GET BCMI_MADURA_SCTL1r_GET
#define SCTL1r_SYS_FRC_RATE_SEL_1f_GET BCMI_MADURA_SCTL1r_SYS_FRC_RATE_SEL_1f_GET
#define SCTL1r_SYS_FRC_RATE_SEL_1f_SET BCMI_MADURA_SCTL1r_SYS_FRC_RATE_SEL_1f_SET
#define SCTL1r_SYS_FRC_CDR_PHASE_1f_GET BCMI_MADURA_SCTL1r_SYS_FRC_CDR_PHASE_1f_GET
#define SCTL1r_SYS_FRC_CDR_PHASE_1f_SET BCMI_MADURA_SCTL1r_SYS_FRC_CDR_PHASE_1f_SET
#define SCTL1r_SYS_SEL_LANE_1f_GET BCMI_MADURA_SCTL1r_SYS_SEL_LANE_1f_GET
#define SCTL1r_SYS_SEL_LANE_1f_SET BCMI_MADURA_SCTL1r_SYS_SEL_LANE_1f_SET
#define READ_SCTL1r BCMI_MADURA_READ_SCTL1r
#define WRITE_SCTL1r BCMI_MADURA_WRITE_SCTL1r
#define MODIFY_SCTL1r BCMI_MADURA_MODIFY_SCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL2
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa812
 * DEVAD:    1
 * DESC:     control register-2 for PI mux controls for transmit lane-2, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_2   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_2 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_2 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL2r (0x0001a812 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL2r_SIZE 4

/*
 * This structure should be used to declare and program SCTL2.
 */
typedef union BCMI_MADURA_SCTL2r_s {
	uint32_t v[1];
	uint32_t sctl2[1];
	uint32_t _sctl2;
} BCMI_MADURA_SCTL2r_t;

#define BCMI_MADURA_SCTL2r_CLR(r) (r).sctl2[0] = 0
#define BCMI_MADURA_SCTL2r_SET(r,d) (r).sctl2[0] = d
#define BCMI_MADURA_SCTL2r_GET(r) (r).sctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL2r_SYS_FRC_RATE_SEL_2f_GET(r) ((((r).sctl2[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL2r_SYS_FRC_RATE_SEL_2f_SET(r,f) (r).sctl2[0]=(((r).sctl2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL2r_SYS_FRC_CDR_PHASE_2f_GET(r) ((((r).sctl2[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL2r_SYS_FRC_CDR_PHASE_2f_SET(r,f) (r).sctl2[0]=(((r).sctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL2r_SYS_SEL_LANE_2f_GET(r) (((r).sctl2[0]) & 0x7)
#define BCMI_MADURA_SCTL2r_SYS_SEL_LANE_2f_SET(r,f) (r).sctl2[0]=(((r).sctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL2.
 */
#define BCMI_MADURA_READ_SCTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL2r,_r._sctl2)
#define BCMI_MADURA_WRITE_SCTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL2r,_r._sctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL2r BCMI_MADURA_SCTL2r
#define SCTL2r_SIZE BCMI_MADURA_SCTL2r_SIZE
typedef BCMI_MADURA_SCTL2r_t SCTL2r_t;
#define SCTL2r_CLR BCMI_MADURA_SCTL2r_CLR
#define SCTL2r_SET BCMI_MADURA_SCTL2r_SET
#define SCTL2r_GET BCMI_MADURA_SCTL2r_GET
#define SCTL2r_SYS_FRC_RATE_SEL_2f_GET BCMI_MADURA_SCTL2r_SYS_FRC_RATE_SEL_2f_GET
#define SCTL2r_SYS_FRC_RATE_SEL_2f_SET BCMI_MADURA_SCTL2r_SYS_FRC_RATE_SEL_2f_SET
#define SCTL2r_SYS_FRC_CDR_PHASE_2f_GET BCMI_MADURA_SCTL2r_SYS_FRC_CDR_PHASE_2f_GET
#define SCTL2r_SYS_FRC_CDR_PHASE_2f_SET BCMI_MADURA_SCTL2r_SYS_FRC_CDR_PHASE_2f_SET
#define SCTL2r_SYS_SEL_LANE_2f_GET BCMI_MADURA_SCTL2r_SYS_SEL_LANE_2f_GET
#define SCTL2r_SYS_SEL_LANE_2f_SET BCMI_MADURA_SCTL2r_SYS_SEL_LANE_2f_SET
#define READ_SCTL2r BCMI_MADURA_READ_SCTL2r
#define WRITE_SCTL2r BCMI_MADURA_WRITE_SCTL2r
#define MODIFY_SCTL2r BCMI_MADURA_MODIFY_SCTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL3
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa813
 * DEVAD:    1
 * DESC:     control register-3 for PI mux controls for transmit lane-3, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_3   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_3 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_3 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL3r (0x0001a813 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL3r_SIZE 4

/*
 * This structure should be used to declare and program SCTL3.
 */
typedef union BCMI_MADURA_SCTL3r_s {
	uint32_t v[1];
	uint32_t sctl3[1];
	uint32_t _sctl3;
} BCMI_MADURA_SCTL3r_t;

#define BCMI_MADURA_SCTL3r_CLR(r) (r).sctl3[0] = 0
#define BCMI_MADURA_SCTL3r_SET(r,d) (r).sctl3[0] = d
#define BCMI_MADURA_SCTL3r_GET(r) (r).sctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL3r_SYS_FRC_RATE_SEL_3f_GET(r) ((((r).sctl3[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL3r_SYS_FRC_RATE_SEL_3f_SET(r,f) (r).sctl3[0]=(((r).sctl3[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL3r_SYS_FRC_CDR_PHASE_3f_GET(r) ((((r).sctl3[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL3r_SYS_FRC_CDR_PHASE_3f_SET(r,f) (r).sctl3[0]=(((r).sctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL3r_SYS_SEL_LANE_3f_GET(r) (((r).sctl3[0]) & 0x7)
#define BCMI_MADURA_SCTL3r_SYS_SEL_LANE_3f_SET(r,f) (r).sctl3[0]=(((r).sctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL3.
 */
#define BCMI_MADURA_READ_SCTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL3r,_r._sctl3)
#define BCMI_MADURA_WRITE_SCTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL3r,_r._sctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL3r BCMI_MADURA_SCTL3r
#define SCTL3r_SIZE BCMI_MADURA_SCTL3r_SIZE
typedef BCMI_MADURA_SCTL3r_t SCTL3r_t;
#define SCTL3r_CLR BCMI_MADURA_SCTL3r_CLR
#define SCTL3r_SET BCMI_MADURA_SCTL3r_SET
#define SCTL3r_GET BCMI_MADURA_SCTL3r_GET
#define SCTL3r_SYS_FRC_RATE_SEL_3f_GET BCMI_MADURA_SCTL3r_SYS_FRC_RATE_SEL_3f_GET
#define SCTL3r_SYS_FRC_RATE_SEL_3f_SET BCMI_MADURA_SCTL3r_SYS_FRC_RATE_SEL_3f_SET
#define SCTL3r_SYS_FRC_CDR_PHASE_3f_GET BCMI_MADURA_SCTL3r_SYS_FRC_CDR_PHASE_3f_GET
#define SCTL3r_SYS_FRC_CDR_PHASE_3f_SET BCMI_MADURA_SCTL3r_SYS_FRC_CDR_PHASE_3f_SET
#define SCTL3r_SYS_SEL_LANE_3f_GET BCMI_MADURA_SCTL3r_SYS_SEL_LANE_3f_GET
#define SCTL3r_SYS_SEL_LANE_3f_SET BCMI_MADURA_SCTL3r_SYS_SEL_LANE_3f_SET
#define READ_SCTL3r BCMI_MADURA_READ_SCTL3r
#define WRITE_SCTL3r BCMI_MADURA_WRITE_SCTL3r
#define MODIFY_SCTL3r BCMI_MADURA_MODIFY_SCTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL4
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa814
 * DEVAD:    1
 * DESC:     control register-4 for PI mux controls for transmit lane-4, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_4   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_4 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_4 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL4r (0x0001a814 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL4r_SIZE 4

/*
 * This structure should be used to declare and program SCTL4.
 */
typedef union BCMI_MADURA_SCTL4r_s {
	uint32_t v[1];
	uint32_t sctl4[1];
	uint32_t _sctl4;
} BCMI_MADURA_SCTL4r_t;

#define BCMI_MADURA_SCTL4r_CLR(r) (r).sctl4[0] = 0
#define BCMI_MADURA_SCTL4r_SET(r,d) (r).sctl4[0] = d
#define BCMI_MADURA_SCTL4r_GET(r) (r).sctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL4r_SYS_FRC_RATE_SEL_4f_GET(r) ((((r).sctl4[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL4r_SYS_FRC_RATE_SEL_4f_SET(r,f) (r).sctl4[0]=(((r).sctl4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL4r_SYS_FRC_CDR_PHASE_4f_GET(r) ((((r).sctl4[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL4r_SYS_FRC_CDR_PHASE_4f_SET(r,f) (r).sctl4[0]=(((r).sctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL4r_SYS_SEL_LANE_4f_GET(r) (((r).sctl4[0]) & 0x7)
#define BCMI_MADURA_SCTL4r_SYS_SEL_LANE_4f_SET(r,f) (r).sctl4[0]=(((r).sctl4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL4.
 */
#define BCMI_MADURA_READ_SCTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL4r,_r._sctl4)
#define BCMI_MADURA_WRITE_SCTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL4r,_r._sctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL4r BCMI_MADURA_SCTL4r
#define SCTL4r_SIZE BCMI_MADURA_SCTL4r_SIZE
typedef BCMI_MADURA_SCTL4r_t SCTL4r_t;
#define SCTL4r_CLR BCMI_MADURA_SCTL4r_CLR
#define SCTL4r_SET BCMI_MADURA_SCTL4r_SET
#define SCTL4r_GET BCMI_MADURA_SCTL4r_GET
#define SCTL4r_SYS_FRC_RATE_SEL_4f_GET BCMI_MADURA_SCTL4r_SYS_FRC_RATE_SEL_4f_GET
#define SCTL4r_SYS_FRC_RATE_SEL_4f_SET BCMI_MADURA_SCTL4r_SYS_FRC_RATE_SEL_4f_SET
#define SCTL4r_SYS_FRC_CDR_PHASE_4f_GET BCMI_MADURA_SCTL4r_SYS_FRC_CDR_PHASE_4f_GET
#define SCTL4r_SYS_FRC_CDR_PHASE_4f_SET BCMI_MADURA_SCTL4r_SYS_FRC_CDR_PHASE_4f_SET
#define SCTL4r_SYS_SEL_LANE_4f_GET BCMI_MADURA_SCTL4r_SYS_SEL_LANE_4f_GET
#define SCTL4r_SYS_SEL_LANE_4f_SET BCMI_MADURA_SCTL4r_SYS_SEL_LANE_4f_SET
#define READ_SCTL4r BCMI_MADURA_READ_SCTL4r
#define WRITE_SCTL4r BCMI_MADURA_WRITE_SCTL4r
#define MODIFY_SCTL4r BCMI_MADURA_MODIFY_SCTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL5
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa815
 * DEVAD:    1
 * DESC:     control register-5 for PI mux controls for transmit lane-5, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_5   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_5 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_5 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL5r (0x0001a815 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL5r_SIZE 4

/*
 * This structure should be used to declare and program SCTL5.
 */
typedef union BCMI_MADURA_SCTL5r_s {
	uint32_t v[1];
	uint32_t sctl5[1];
	uint32_t _sctl5;
} BCMI_MADURA_SCTL5r_t;

#define BCMI_MADURA_SCTL5r_CLR(r) (r).sctl5[0] = 0
#define BCMI_MADURA_SCTL5r_SET(r,d) (r).sctl5[0] = d
#define BCMI_MADURA_SCTL5r_GET(r) (r).sctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL5r_SYS_FRC_RATE_SEL_5f_GET(r) ((((r).sctl5[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL5r_SYS_FRC_RATE_SEL_5f_SET(r,f) (r).sctl5[0]=(((r).sctl5[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL5r_SYS_FRC_CDR_PHASE_5f_GET(r) ((((r).sctl5[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL5r_SYS_FRC_CDR_PHASE_5f_SET(r,f) (r).sctl5[0]=(((r).sctl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL5r_SYS_SEL_LANE_5f_GET(r) (((r).sctl5[0]) & 0x7)
#define BCMI_MADURA_SCTL5r_SYS_SEL_LANE_5f_SET(r,f) (r).sctl5[0]=(((r).sctl5[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL5.
 */
#define BCMI_MADURA_READ_SCTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL5r,_r._sctl5)
#define BCMI_MADURA_WRITE_SCTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL5r,_r._sctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL5r BCMI_MADURA_SCTL5r
#define SCTL5r_SIZE BCMI_MADURA_SCTL5r_SIZE
typedef BCMI_MADURA_SCTL5r_t SCTL5r_t;
#define SCTL5r_CLR BCMI_MADURA_SCTL5r_CLR
#define SCTL5r_SET BCMI_MADURA_SCTL5r_SET
#define SCTL5r_GET BCMI_MADURA_SCTL5r_GET
#define SCTL5r_SYS_FRC_RATE_SEL_5f_GET BCMI_MADURA_SCTL5r_SYS_FRC_RATE_SEL_5f_GET
#define SCTL5r_SYS_FRC_RATE_SEL_5f_SET BCMI_MADURA_SCTL5r_SYS_FRC_RATE_SEL_5f_SET
#define SCTL5r_SYS_FRC_CDR_PHASE_5f_GET BCMI_MADURA_SCTL5r_SYS_FRC_CDR_PHASE_5f_GET
#define SCTL5r_SYS_FRC_CDR_PHASE_5f_SET BCMI_MADURA_SCTL5r_SYS_FRC_CDR_PHASE_5f_SET
#define SCTL5r_SYS_SEL_LANE_5f_GET BCMI_MADURA_SCTL5r_SYS_SEL_LANE_5f_GET
#define SCTL5r_SYS_SEL_LANE_5f_SET BCMI_MADURA_SCTL5r_SYS_SEL_LANE_5f_SET
#define READ_SCTL5r BCMI_MADURA_READ_SCTL5r
#define WRITE_SCTL5r BCMI_MADURA_WRITE_SCTL5r
#define MODIFY_SCTL5r BCMI_MADURA_MODIFY_SCTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL6
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa816
 * DEVAD:    1
 * DESC:     control register-6 for PI mux controls for transmit lane-6, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_6   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_6 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_6 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL6r (0x0001a816 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL6r_SIZE 4

/*
 * This structure should be used to declare and program SCTL6.
 */
typedef union BCMI_MADURA_SCTL6r_s {
	uint32_t v[1];
	uint32_t sctl6[1];
	uint32_t _sctl6;
} BCMI_MADURA_SCTL6r_t;

#define BCMI_MADURA_SCTL6r_CLR(r) (r).sctl6[0] = 0
#define BCMI_MADURA_SCTL6r_SET(r,d) (r).sctl6[0] = d
#define BCMI_MADURA_SCTL6r_GET(r) (r).sctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL6r_SYS_FRC_RATE_SEL_6f_GET(r) ((((r).sctl6[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL6r_SYS_FRC_RATE_SEL_6f_SET(r,f) (r).sctl6[0]=(((r).sctl6[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL6r_SYS_FRC_CDR_PHASE_6f_GET(r) ((((r).sctl6[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL6r_SYS_FRC_CDR_PHASE_6f_SET(r,f) (r).sctl6[0]=(((r).sctl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL6r_SYS_SEL_LANE_6f_GET(r) (((r).sctl6[0]) & 0x7)
#define BCMI_MADURA_SCTL6r_SYS_SEL_LANE_6f_SET(r,f) (r).sctl6[0]=(((r).sctl6[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL6.
 */
#define BCMI_MADURA_READ_SCTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL6r,_r._sctl6)
#define BCMI_MADURA_WRITE_SCTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL6r,_r._sctl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL6r BCMI_MADURA_SCTL6r
#define SCTL6r_SIZE BCMI_MADURA_SCTL6r_SIZE
typedef BCMI_MADURA_SCTL6r_t SCTL6r_t;
#define SCTL6r_CLR BCMI_MADURA_SCTL6r_CLR
#define SCTL6r_SET BCMI_MADURA_SCTL6r_SET
#define SCTL6r_GET BCMI_MADURA_SCTL6r_GET
#define SCTL6r_SYS_FRC_RATE_SEL_6f_GET BCMI_MADURA_SCTL6r_SYS_FRC_RATE_SEL_6f_GET
#define SCTL6r_SYS_FRC_RATE_SEL_6f_SET BCMI_MADURA_SCTL6r_SYS_FRC_RATE_SEL_6f_SET
#define SCTL6r_SYS_FRC_CDR_PHASE_6f_GET BCMI_MADURA_SCTL6r_SYS_FRC_CDR_PHASE_6f_GET
#define SCTL6r_SYS_FRC_CDR_PHASE_6f_SET BCMI_MADURA_SCTL6r_SYS_FRC_CDR_PHASE_6f_SET
#define SCTL6r_SYS_SEL_LANE_6f_GET BCMI_MADURA_SCTL6r_SYS_SEL_LANE_6f_GET
#define SCTL6r_SYS_SEL_LANE_6f_SET BCMI_MADURA_SCTL6r_SYS_SEL_LANE_6f_SET
#define READ_SCTL6r BCMI_MADURA_READ_SCTL6r
#define WRITE_SCTL6r BCMI_MADURA_WRITE_SCTL6r
#define MODIFY_SCTL6r BCMI_MADURA_MODIFY_SCTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SCTL7
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa817
 * DEVAD:    1
 * DESC:     control register-7 for PI mux controls for transmit lane-7, line side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_SEL_LANE_7   select the CDR phase receive lane that needs to go in to the transmit lane
 *     SYS_FRC_CDR_PHASE_7 override the mode_decode based controls and use sys_sel_lane to select the receive lane
 *     SYS_FRC_RATE_SEL_7 rate selection 2'b00 defaults to the mode decoder based setting,rate selection 2'b01 mode 1to2,rate selection 2'b10 mode 2to1,rate selection 2'b11 mode 1to1.
 */
#define BCMI_MADURA_SCTL7r (0x0001a817 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SCTL7r_SIZE 4

/*
 * This structure should be used to declare and program SCTL7.
 */
typedef union BCMI_MADURA_SCTL7r_s {
	uint32_t v[1];
	uint32_t sctl7[1];
	uint32_t _sctl7;
} BCMI_MADURA_SCTL7r_t;

#define BCMI_MADURA_SCTL7r_CLR(r) (r).sctl7[0] = 0
#define BCMI_MADURA_SCTL7r_SET(r,d) (r).sctl7[0] = d
#define BCMI_MADURA_SCTL7r_GET(r) (r).sctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SCTL7r_SYS_FRC_RATE_SEL_7f_GET(r) ((((r).sctl7[0]) >> 8) & 0x3)
#define BCMI_MADURA_SCTL7r_SYS_FRC_RATE_SEL_7f_SET(r,f) (r).sctl7[0]=(((r).sctl7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_SCTL7r_SYS_FRC_CDR_PHASE_7f_GET(r) ((((r).sctl7[0]) >> 4) & 0x1)
#define BCMI_MADURA_SCTL7r_SYS_FRC_CDR_PHASE_7f_SET(r,f) (r).sctl7[0]=(((r).sctl7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SCTL7r_SYS_SEL_LANE_7f_GET(r) (((r).sctl7[0]) & 0x7)
#define BCMI_MADURA_SCTL7r_SYS_SEL_LANE_7f_SET(r,f) (r).sctl7[0]=(((r).sctl7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SCTL7.
 */
#define BCMI_MADURA_READ_SCTL7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SCTL7r,_r._sctl7)
#define BCMI_MADURA_WRITE_SCTL7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SCTL7r,_r._sctl7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SCTL7r BCMI_MADURA_SCTL7r
#define SCTL7r_SIZE BCMI_MADURA_SCTL7r_SIZE
typedef BCMI_MADURA_SCTL7r_t SCTL7r_t;
#define SCTL7r_CLR BCMI_MADURA_SCTL7r_CLR
#define SCTL7r_SET BCMI_MADURA_SCTL7r_SET
#define SCTL7r_GET BCMI_MADURA_SCTL7r_GET
#define SCTL7r_SYS_FRC_RATE_SEL_7f_GET BCMI_MADURA_SCTL7r_SYS_FRC_RATE_SEL_7f_GET
#define SCTL7r_SYS_FRC_RATE_SEL_7f_SET BCMI_MADURA_SCTL7r_SYS_FRC_RATE_SEL_7f_SET
#define SCTL7r_SYS_FRC_CDR_PHASE_7f_GET BCMI_MADURA_SCTL7r_SYS_FRC_CDR_PHASE_7f_GET
#define SCTL7r_SYS_FRC_CDR_PHASE_7f_SET BCMI_MADURA_SCTL7r_SYS_FRC_CDR_PHASE_7f_SET
#define SCTL7r_SYS_SEL_LANE_7f_GET BCMI_MADURA_SCTL7r_SYS_SEL_LANE_7f_GET
#define SCTL7r_SYS_SEL_LANE_7f_SET BCMI_MADURA_SCTL7r_SYS_SEL_LANE_7f_SET
#define READ_SCTL7r BCMI_MADURA_READ_SCTL7r
#define WRITE_SCTL7r BCMI_MADURA_WRITE_SCTL7r
#define MODIFY_SCTL7r BCMI_MADURA_MODIFY_SCTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SCTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SALTER
 * BLOCKS:   PI_XFR
 * REGADDR:  0xa818
 * DEVAD:    1
 * DESC:     control register for PI mux controls for transmit lane[0 7], system side.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYS_ALTER        In 1:2 mode there are two options for picking the lanes for phase transfer lanes 0 or 1 from line sideeach bit represents a unique transmit lane
 */
#define BCMI_MADURA_SALTERr (0x0001a818 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SALTERr_SIZE 4

/*
 * This structure should be used to declare and program SALTER.
 */
typedef union BCMI_MADURA_SALTERr_s {
	uint32_t v[1];
	uint32_t salter[1];
	uint32_t _salter;
} BCMI_MADURA_SALTERr_t;

#define BCMI_MADURA_SALTERr_CLR(r) (r).salter[0] = 0
#define BCMI_MADURA_SALTERr_SET(r,d) (r).salter[0] = d
#define BCMI_MADURA_SALTERr_GET(r) (r).salter[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SALTERr_SYS_ALTERf_GET(r) (((r).salter[0]) & 0xff)
#define BCMI_MADURA_SALTERr_SYS_ALTERf_SET(r,f) (r).salter[0]=(((r).salter[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SALTER.
 */
#define BCMI_MADURA_READ_SALTERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SALTERr,_r._salter)
#define BCMI_MADURA_WRITE_SALTERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SALTERr,_r._salter)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SALTERr BCMI_MADURA_SALTERr
#define SALTERr_SIZE BCMI_MADURA_SALTERr_SIZE
typedef BCMI_MADURA_SALTERr_t SALTERr_t;
#define SALTERr_CLR BCMI_MADURA_SALTERr_CLR
#define SALTERr_SET BCMI_MADURA_SALTERr_SET
#define SALTERr_GET BCMI_MADURA_SALTERr_GET
#define SALTERr_SYS_ALTERf_GET BCMI_MADURA_SALTERr_SYS_ALTERf_GET
#define SALTERr_SYS_ALTERf_SET BCMI_MADURA_SALTERr_SYS_ALTERf_SET
#define READ_SALTERr BCMI_MADURA_READ_SALTERr
#define WRITE_SALTERr BCMI_MADURA_WRITE_SALTERr
#define MODIFY_SALTERr BCMI_MADURA_MODIFY_SALTERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SALTERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DP_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb000
 * DEVAD:    1
 * DESC:     data path phase FIFO and reset control
 * RESETVAL: 0x838 (2104)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_RSTB          active low reset for receiving
 *     TX_RSTB          active low reset for transmision
 *     RSTB_FRC         active low reset force
 *     PF_RSTB          active low reset for receiving Phase FIFOs
 *     PTR_SYNC         Write pointer value use to synchronize read pointer in Phase FIFO\This value determines to how many cycles the read pointer is behind the write pointer
 *     COL_FLTR         Threshold to declare FIFO collision
 *     AUTO_RESET_DIS   Phase FIFO auto reset at collision disable control. If set, no reset when collision happens
 *     PD_EN            set this bit to enable Phase Detect data path rather than Phase FIFO data path
 *     IDLE_FAULTSEL    used to select different IDLE pattern for scrambled IDLE generation2'b00, 2'b11: IDLE, 2'b01: Local Failure, 2'b10: Remode Failure
 */
#define BCMI_MADURA_DP_CTLr (0x0001b000 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DP_CTL.
 */
typedef union BCMI_MADURA_DP_CTLr_s {
	uint32_t v[1];
	uint32_t dp_ctl[1];
	uint32_t _dp_ctl;
} BCMI_MADURA_DP_CTLr_t;

#define BCMI_MADURA_DP_CTLr_CLR(r) (r).dp_ctl[0] = 0
#define BCMI_MADURA_DP_CTLr_SET(r,d) (r).dp_ctl[0] = d
#define BCMI_MADURA_DP_CTLr_GET(r) (r).dp_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DP_CTLr_IDLE_FAULTSELf_GET(r) ((((r).dp_ctl[0]) >> 14) & 0x3)
#define BCMI_MADURA_DP_CTLr_IDLE_FAULTSELf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_DP_CTLr_PD_ENf_GET(r) ((((r).dp_ctl[0]) >> 13) & 0x1)
#define BCMI_MADURA_DP_CTLr_PD_ENf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_DP_CTLr_AUTO_RESET_DISf_GET(r) ((((r).dp_ctl[0]) >> 12) & 0x1)
#define BCMI_MADURA_DP_CTLr_AUTO_RESET_DISf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_DP_CTLr_COL_FLTRf_GET(r) ((((r).dp_ctl[0]) >> 8) & 0xf)
#define BCMI_MADURA_DP_CTLr_COL_FLTRf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DP_CTLr_PTR_SYNCf_GET(r) ((((r).dp_ctl[0]) >> 4) & 0xf)
#define BCMI_MADURA_DP_CTLr_PTR_SYNCf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DP_CTLr_PF_RSTBf_GET(r) ((((r).dp_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_DP_CTLr_PF_RSTBf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DP_CTLr_RSTB_FRCf_GET(r) ((((r).dp_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_DP_CTLr_RSTB_FRCf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DP_CTLr_TX_RSTBf_GET(r) ((((r).dp_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_DP_CTLr_TX_RSTBf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DP_CTLr_RX_RSTBf_GET(r) (((r).dp_ctl[0]) & 0x1)
#define BCMI_MADURA_DP_CTLr_RX_RSTBf_SET(r,f) (r).dp_ctl[0]=(((r).dp_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DP_CTL.
 */
#define BCMI_MADURA_READ_DP_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DP_CTLr,_r._dp_ctl)
#define BCMI_MADURA_WRITE_DP_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DP_CTLr,_r._dp_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DP_CTLr BCMI_MADURA_DP_CTLr
#define DP_CTLr_SIZE BCMI_MADURA_DP_CTLr_SIZE
typedef BCMI_MADURA_DP_CTLr_t DP_CTLr_t;
#define DP_CTLr_CLR BCMI_MADURA_DP_CTLr_CLR
#define DP_CTLr_SET BCMI_MADURA_DP_CTLr_SET
#define DP_CTLr_GET BCMI_MADURA_DP_CTLr_GET
#define DP_CTLr_IDLE_FAULTSELf_GET BCMI_MADURA_DP_CTLr_IDLE_FAULTSELf_GET
#define DP_CTLr_IDLE_FAULTSELf_SET BCMI_MADURA_DP_CTLr_IDLE_FAULTSELf_SET
#define DP_CTLr_PD_ENf_GET BCMI_MADURA_DP_CTLr_PD_ENf_GET
#define DP_CTLr_PD_ENf_SET BCMI_MADURA_DP_CTLr_PD_ENf_SET
#define DP_CTLr_AUTO_RESET_DISf_GET BCMI_MADURA_DP_CTLr_AUTO_RESET_DISf_GET
#define DP_CTLr_AUTO_RESET_DISf_SET BCMI_MADURA_DP_CTLr_AUTO_RESET_DISf_SET
#define DP_CTLr_COL_FLTRf_GET BCMI_MADURA_DP_CTLr_COL_FLTRf_GET
#define DP_CTLr_COL_FLTRf_SET BCMI_MADURA_DP_CTLr_COL_FLTRf_SET
#define DP_CTLr_PTR_SYNCf_GET BCMI_MADURA_DP_CTLr_PTR_SYNCf_GET
#define DP_CTLr_PTR_SYNCf_SET BCMI_MADURA_DP_CTLr_PTR_SYNCf_SET
#define DP_CTLr_PF_RSTBf_GET BCMI_MADURA_DP_CTLr_PF_RSTBf_GET
#define DP_CTLr_PF_RSTBf_SET BCMI_MADURA_DP_CTLr_PF_RSTBf_SET
#define DP_CTLr_RSTB_FRCf_GET BCMI_MADURA_DP_CTLr_RSTB_FRCf_GET
#define DP_CTLr_RSTB_FRCf_SET BCMI_MADURA_DP_CTLr_RSTB_FRCf_SET
#define DP_CTLr_TX_RSTBf_GET BCMI_MADURA_DP_CTLr_TX_RSTBf_GET
#define DP_CTLr_TX_RSTBf_SET BCMI_MADURA_DP_CTLr_TX_RSTBf_SET
#define DP_CTLr_RX_RSTBf_GET BCMI_MADURA_DP_CTLr_RX_RSTBf_GET
#define DP_CTLr_RX_RSTBf_SET BCMI_MADURA_DP_CTLr_RX_RSTBf_SET
#define READ_DP_CTLr BCMI_MADURA_READ_DP_CTLr
#define WRITE_DP_CTLr BCMI_MADURA_WRITE_DP_CTLr
#define MODIFY_DP_CTLr BCMI_MADURA_MODIFY_DP_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATT_MON_GEN_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb001
 * DEVAD:    1
 * DESC:     pattern monitor and generation control
 * RESETVAL: 0x8080 (32896)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_MON_CTRL      select link monitor and sspr checker to monitor the input data stream2'b00 : no link monitor or SSPR monitor enabled2'b01 : enable SSPR check2'b10 : enable link monitor, link monitor type decided by mode automatically2'b11 : enable link monitor, link monitor mode use force value in bit 2:3
 *     LINK_MON_MODE    2'b00 : PCS mode, 64b/66b coding, CLause 49 FSM2'b01 : PCS mode, 64b/66b coding, CLause 82 FSM2'b10 : FC mode, 8b/10b coding, FC-4G2'b11 : FC mode, 8b/10b coding, FC-8G
 *     TX_GEN_CTRL      select data pattern to be sent to Falcon2'b00 : data path enable, pass through data2'b01 : enable SSPR generation2'b10 : enable scrambled IDLE generation2'b11 : enable isolated pulse generation
 *     TX_AUTO_RESET_DIS FEC TX Phase FIFO auto reset at collision disable control. If set, no reset when collision happens
 *     TX_PF_RSTB       active low reset for FEC TX Phase FIFOs
 *     TX_PTR_SYNC      Write pointer value use to synchronize read pointer in FEC TX Phase FIFO\This value determines to how many cycles the read pointer is behind the write pointer
 *     TX_COL_FLTR      Threshold to declare FEC TX FIFO collision
 */
#define BCMI_MADURA_PATT_MON_GEN_CTLr (0x0001b001 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATT_MON_GEN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PATT_MON_GEN_CTL.
 */
typedef union BCMI_MADURA_PATT_MON_GEN_CTLr_s {
	uint32_t v[1];
	uint32_t patt_mon_gen_ctl[1];
	uint32_t _patt_mon_gen_ctl;
} BCMI_MADURA_PATT_MON_GEN_CTLr_t;

#define BCMI_MADURA_PATT_MON_GEN_CTLr_CLR(r) (r).patt_mon_gen_ctl[0] = 0
#define BCMI_MADURA_PATT_MON_GEN_CTLr_SET(r,d) (r).patt_mon_gen_ctl[0] = d
#define BCMI_MADURA_PATT_MON_GEN_CTLr_GET(r) (r).patt_mon_gen_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_COL_FLTRf_GET(r) ((((r).patt_mon_gen_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_COL_FLTRf_SET(r,f) (r).patt_mon_gen_ctl[0]=(((r).patt_mon_gen_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PTR_SYNCf_GET(r) ((((r).patt_mon_gen_ctl[0]) >> 8) & 0xf)
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PTR_SYNCf_SET(r,f) (r).patt_mon_gen_ctl[0]=(((r).patt_mon_gen_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PF_RSTBf_GET(r) ((((r).patt_mon_gen_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PF_RSTBf_SET(r,f) (r).patt_mon_gen_ctl[0]=(((r).patt_mon_gen_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_AUTO_RESET_DISf_GET(r) ((((r).patt_mon_gen_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_AUTO_RESET_DISf_SET(r,f) (r).patt_mon_gen_ctl[0]=(((r).patt_mon_gen_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_GEN_CTRLf_GET(r) ((((r).patt_mon_gen_ctl[0]) >> 4) & 0x3)
#define BCMI_MADURA_PATT_MON_GEN_CTLr_TX_GEN_CTRLf_SET(r,f) (r).patt_mon_gen_ctl[0]=(((r).patt_mon_gen_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_PATT_MON_GEN_CTLr_LINK_MON_MODEf_GET(r) ((((r).patt_mon_gen_ctl[0]) >> 2) & 0x3)
#define BCMI_MADURA_PATT_MON_GEN_CTLr_LINK_MON_MODEf_SET(r,f) (r).patt_mon_gen_ctl[0]=(((r).patt_mon_gen_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_PATT_MON_GEN_CTLr_RX_MON_CTRLf_GET(r) (((r).patt_mon_gen_ctl[0]) & 0x3)
#define BCMI_MADURA_PATT_MON_GEN_CTLr_RX_MON_CTRLf_SET(r,f) (r).patt_mon_gen_ctl[0]=(((r).patt_mon_gen_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PATT_MON_GEN_CTL.
 */
#define BCMI_MADURA_READ_PATT_MON_GEN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATT_MON_GEN_CTLr,_r._patt_mon_gen_ctl)
#define BCMI_MADURA_WRITE_PATT_MON_GEN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATT_MON_GEN_CTLr,_r._patt_mon_gen_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_MON_GEN_CTLr BCMI_MADURA_PATT_MON_GEN_CTLr
#define PATT_MON_GEN_CTLr_SIZE BCMI_MADURA_PATT_MON_GEN_CTLr_SIZE
typedef BCMI_MADURA_PATT_MON_GEN_CTLr_t PATT_MON_GEN_CTLr_t;
#define PATT_MON_GEN_CTLr_CLR BCMI_MADURA_PATT_MON_GEN_CTLr_CLR
#define PATT_MON_GEN_CTLr_SET BCMI_MADURA_PATT_MON_GEN_CTLr_SET
#define PATT_MON_GEN_CTLr_GET BCMI_MADURA_PATT_MON_GEN_CTLr_GET
#define PATT_MON_GEN_CTLr_TX_COL_FLTRf_GET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_COL_FLTRf_GET
#define PATT_MON_GEN_CTLr_TX_COL_FLTRf_SET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_COL_FLTRf_SET
#define PATT_MON_GEN_CTLr_TX_PTR_SYNCf_GET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PTR_SYNCf_GET
#define PATT_MON_GEN_CTLr_TX_PTR_SYNCf_SET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PTR_SYNCf_SET
#define PATT_MON_GEN_CTLr_TX_PF_RSTBf_GET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PF_RSTBf_GET
#define PATT_MON_GEN_CTLr_TX_PF_RSTBf_SET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_PF_RSTBf_SET
#define PATT_MON_GEN_CTLr_TX_AUTO_RESET_DISf_GET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_AUTO_RESET_DISf_GET
#define PATT_MON_GEN_CTLr_TX_AUTO_RESET_DISf_SET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_AUTO_RESET_DISf_SET
#define PATT_MON_GEN_CTLr_TX_GEN_CTRLf_GET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_GEN_CTRLf_GET
#define PATT_MON_GEN_CTLr_TX_GEN_CTRLf_SET BCMI_MADURA_PATT_MON_GEN_CTLr_TX_GEN_CTRLf_SET
#define PATT_MON_GEN_CTLr_LINK_MON_MODEf_GET BCMI_MADURA_PATT_MON_GEN_CTLr_LINK_MON_MODEf_GET
#define PATT_MON_GEN_CTLr_LINK_MON_MODEf_SET BCMI_MADURA_PATT_MON_GEN_CTLr_LINK_MON_MODEf_SET
#define PATT_MON_GEN_CTLr_RX_MON_CTRLf_GET BCMI_MADURA_PATT_MON_GEN_CTLr_RX_MON_CTRLf_GET
#define PATT_MON_GEN_CTLr_RX_MON_CTRLf_SET BCMI_MADURA_PATT_MON_GEN_CTLr_RX_MON_CTRLf_SET
#define READ_PATT_MON_GEN_CTLr BCMI_MADURA_READ_PATT_MON_GEN_CTLr
#define WRITE_PATT_MON_GEN_CTLr BCMI_MADURA_WRITE_PATT_MON_GEN_CTLr
#define MODIFY_PATT_MON_GEN_CTLr BCMI_MADURA_MODIFY_PATT_MON_GEN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATT_MON_GEN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_MON_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb002
 * DEVAD:    1
 * DESC:     PCS monitor main control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOGIC_LANE       logic lane, valid range 0 to 4
 *     BER_MON_DIS      Disable BER monitor
 *     VALID_SH_CNT_FRC valid sh_cnt threshold force bit. 1'b1: use valid_sh_cnt as configuration, 1'b0: default
 *     INVALID_SH_CNT_FRC invalid sh_cnt threshold force bit. 1'b1: use invalid_sh_cnt as configuration, 1'b0: default
 *     PCS_MON_FRC      If set, PCS monitor multi logic lane mode use configuration; otherwisre use mode decode
 *     MODE_100G        indicate each physical lane contains 5 logic lanes, used only when pcs_mon_frc is set
 *     MODE_20G         indicate each physical lane contains 2 logic lanes, used only when pcs_mon_frc is set
 */
#define BCMI_MADURA_PCS_MON_CTLr (0x0001b002 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_MON_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PCS_MON_CTL.
 */
typedef union BCMI_MADURA_PCS_MON_CTLr_s {
	uint32_t v[1];
	uint32_t pcs_mon_ctl[1];
	uint32_t _pcs_mon_ctl;
} BCMI_MADURA_PCS_MON_CTLr_t;

#define BCMI_MADURA_PCS_MON_CTLr_CLR(r) (r).pcs_mon_ctl[0] = 0
#define BCMI_MADURA_PCS_MON_CTLr_SET(r,d) (r).pcs_mon_ctl[0] = d
#define BCMI_MADURA_PCS_MON_CTLr_GET(r) (r).pcs_mon_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_MON_CTLr_MODE_20Gf_GET(r) ((((r).pcs_mon_ctl[0]) >> 8) & 0x1)
#define BCMI_MADURA_PCS_MON_CTLr_MODE_20Gf_SET(r,f) (r).pcs_mon_ctl[0]=(((r).pcs_mon_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PCS_MON_CTLr_MODE_100Gf_GET(r) ((((r).pcs_mon_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_PCS_MON_CTLr_MODE_100Gf_SET(r,f) (r).pcs_mon_ctl[0]=(((r).pcs_mon_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PCS_MON_CTLr_PCS_MON_FRCf_GET(r) ((((r).pcs_mon_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_PCS_MON_CTLr_PCS_MON_FRCf_SET(r,f) (r).pcs_mon_ctl[0]=(((r).pcs_mon_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PCS_MON_CTLr_INVALID_SH_CNT_FRCf_GET(r) ((((r).pcs_mon_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_PCS_MON_CTLr_INVALID_SH_CNT_FRCf_SET(r,f) (r).pcs_mon_ctl[0]=(((r).pcs_mon_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PCS_MON_CTLr_VALID_SH_CNT_FRCf_GET(r) ((((r).pcs_mon_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_PCS_MON_CTLr_VALID_SH_CNT_FRCf_SET(r,f) (r).pcs_mon_ctl[0]=(((r).pcs_mon_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PCS_MON_CTLr_BER_MON_DISf_GET(r) ((((r).pcs_mon_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_PCS_MON_CTLr_BER_MON_DISf_SET(r,f) (r).pcs_mon_ctl[0]=(((r).pcs_mon_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PCS_MON_CTLr_LOGIC_LANEf_GET(r) (((r).pcs_mon_ctl[0]) & 0x7)
#define BCMI_MADURA_PCS_MON_CTLr_LOGIC_LANEf_SET(r,f) (r).pcs_mon_ctl[0]=(((r).pcs_mon_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access PCS_MON_CTL.
 */
#define BCMI_MADURA_READ_PCS_MON_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_MON_CTLr,_r._pcs_mon_ctl)
#define BCMI_MADURA_WRITE_PCS_MON_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_MON_CTLr,_r._pcs_mon_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_MON_CTLr BCMI_MADURA_PCS_MON_CTLr
#define PCS_MON_CTLr_SIZE BCMI_MADURA_PCS_MON_CTLr_SIZE
typedef BCMI_MADURA_PCS_MON_CTLr_t PCS_MON_CTLr_t;
#define PCS_MON_CTLr_CLR BCMI_MADURA_PCS_MON_CTLr_CLR
#define PCS_MON_CTLr_SET BCMI_MADURA_PCS_MON_CTLr_SET
#define PCS_MON_CTLr_GET BCMI_MADURA_PCS_MON_CTLr_GET
#define PCS_MON_CTLr_MODE_20Gf_GET BCMI_MADURA_PCS_MON_CTLr_MODE_20Gf_GET
#define PCS_MON_CTLr_MODE_20Gf_SET BCMI_MADURA_PCS_MON_CTLr_MODE_20Gf_SET
#define PCS_MON_CTLr_MODE_100Gf_GET BCMI_MADURA_PCS_MON_CTLr_MODE_100Gf_GET
#define PCS_MON_CTLr_MODE_100Gf_SET BCMI_MADURA_PCS_MON_CTLr_MODE_100Gf_SET
#define PCS_MON_CTLr_PCS_MON_FRCf_GET BCMI_MADURA_PCS_MON_CTLr_PCS_MON_FRCf_GET
#define PCS_MON_CTLr_PCS_MON_FRCf_SET BCMI_MADURA_PCS_MON_CTLr_PCS_MON_FRCf_SET
#define PCS_MON_CTLr_INVALID_SH_CNT_FRCf_GET BCMI_MADURA_PCS_MON_CTLr_INVALID_SH_CNT_FRCf_GET
#define PCS_MON_CTLr_INVALID_SH_CNT_FRCf_SET BCMI_MADURA_PCS_MON_CTLr_INVALID_SH_CNT_FRCf_SET
#define PCS_MON_CTLr_VALID_SH_CNT_FRCf_GET BCMI_MADURA_PCS_MON_CTLr_VALID_SH_CNT_FRCf_GET
#define PCS_MON_CTLr_VALID_SH_CNT_FRCf_SET BCMI_MADURA_PCS_MON_CTLr_VALID_SH_CNT_FRCf_SET
#define PCS_MON_CTLr_BER_MON_DISf_GET BCMI_MADURA_PCS_MON_CTLr_BER_MON_DISf_GET
#define PCS_MON_CTLr_BER_MON_DISf_SET BCMI_MADURA_PCS_MON_CTLr_BER_MON_DISf_SET
#define PCS_MON_CTLr_LOGIC_LANEf_GET BCMI_MADURA_PCS_MON_CTLr_LOGIC_LANEf_GET
#define PCS_MON_CTLr_LOGIC_LANEf_SET BCMI_MADURA_PCS_MON_CTLr_LOGIC_LANEf_SET
#define READ_PCS_MON_CTLr BCMI_MADURA_READ_PCS_MON_CTLr
#define WRITE_PCS_MON_CTLr BCMI_MADURA_WRITE_PCS_MON_CTLr
#define MODIFY_PCS_MON_CTLr BCMI_MADURA_MODIFY_PCS_MON_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_MON_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_XUS_TMR_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb003
 * DEVAD:    1
 * DESC:     PCS monitor xus timer for BER monitor
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     XUS_TIMER_LSB    pcs monitor xus timer, bit 15:0
 */
#define BCMI_MADURA_PCS_XUS_TMR_CTLr (0x0001b003 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_XUS_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PCS_XUS_TMR_CTL.
 */
typedef union BCMI_MADURA_PCS_XUS_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t pcs_xus_tmr_ctl[1];
	uint32_t _pcs_xus_tmr_ctl;
} BCMI_MADURA_PCS_XUS_TMR_CTLr_t;

#define BCMI_MADURA_PCS_XUS_TMR_CTLr_CLR(r) (r).pcs_xus_tmr_ctl[0] = 0
#define BCMI_MADURA_PCS_XUS_TMR_CTLr_SET(r,d) (r).pcs_xus_tmr_ctl[0] = d
#define BCMI_MADURA_PCS_XUS_TMR_CTLr_GET(r) (r).pcs_xus_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_XUS_TMR_CTLr_XUS_TIMER_LSBf_GET(r) (((r).pcs_xus_tmr_ctl[0]) & 0xffff)
#define BCMI_MADURA_PCS_XUS_TMR_CTLr_XUS_TIMER_LSBf_SET(r,f) (r).pcs_xus_tmr_ctl[0]=(((r).pcs_xus_tmr_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PCS_XUS_TMR_CTL.
 */
#define BCMI_MADURA_READ_PCS_XUS_TMR_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_XUS_TMR_CTLr,_r._pcs_xus_tmr_ctl)
#define BCMI_MADURA_WRITE_PCS_XUS_TMR_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_XUS_TMR_CTLr,_r._pcs_xus_tmr_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_XUS_TMR_CTLr BCMI_MADURA_PCS_XUS_TMR_CTLr
#define PCS_XUS_TMR_CTLr_SIZE BCMI_MADURA_PCS_XUS_TMR_CTLr_SIZE
typedef BCMI_MADURA_PCS_XUS_TMR_CTLr_t PCS_XUS_TMR_CTLr_t;
#define PCS_XUS_TMR_CTLr_CLR BCMI_MADURA_PCS_XUS_TMR_CTLr_CLR
#define PCS_XUS_TMR_CTLr_SET BCMI_MADURA_PCS_XUS_TMR_CTLr_SET
#define PCS_XUS_TMR_CTLr_GET BCMI_MADURA_PCS_XUS_TMR_CTLr_GET
#define PCS_XUS_TMR_CTLr_XUS_TIMER_LSBf_GET BCMI_MADURA_PCS_XUS_TMR_CTLr_XUS_TIMER_LSBf_GET
#define PCS_XUS_TMR_CTLr_XUS_TIMER_LSBf_SET BCMI_MADURA_PCS_XUS_TMR_CTLr_XUS_TIMER_LSBf_SET
#define READ_PCS_XUS_TMR_CTLr BCMI_MADURA_READ_PCS_XUS_TMR_CTLr
#define WRITE_PCS_XUS_TMR_CTLr BCMI_MADURA_WRITE_PCS_XUS_TMR_CTLr
#define MODIFY_PCS_XUS_TMR_CTLr BCMI_MADURA_MODIFY_PCS_XUS_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_XUS_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_BER_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb004
 * DEVAD:    1
 * DESC:     PCS monitor BER calculation main control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_CNT_TH       ber_cnt threshold to declare hi_ber
 *     BER_CNT_TH_FRC   ber_cnt threshold force bit. 1'b1: use ber_cnt_th as configuration, 1'b0: default
 *     XUS_TIMER_MSB    pcs monitor xus timer, bit 19:16
 *     XUS_TIMER_FRC    xus_timer force bit. 1'b1: use xus_timer_msb and xus_timer_lsb as configuration, 1'b0: default
 */
#define BCMI_MADURA_PCS_BER_CTLr (0x0001b004 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_BER_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PCS_BER_CTL.
 */
typedef union BCMI_MADURA_PCS_BER_CTLr_s {
	uint32_t v[1];
	uint32_t pcs_ber_ctl[1];
	uint32_t _pcs_ber_ctl;
} BCMI_MADURA_PCS_BER_CTLr_t;

#define BCMI_MADURA_PCS_BER_CTLr_CLR(r) (r).pcs_ber_ctl[0] = 0
#define BCMI_MADURA_PCS_BER_CTLr_SET(r,d) (r).pcs_ber_ctl[0] = d
#define BCMI_MADURA_PCS_BER_CTLr_GET(r) (r).pcs_ber_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_FRCf_GET(r) ((((r).pcs_ber_ctl[0]) >> 12) & 0x1)
#define BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_FRCf_SET(r,f) (r).pcs_ber_ctl[0]=(((r).pcs_ber_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_MSBf_GET(r) ((((r).pcs_ber_ctl[0]) >> 8) & 0xf)
#define BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_MSBf_SET(r,f) (r).pcs_ber_ctl[0]=(((r).pcs_ber_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_PCS_BER_CTLr_BER_CNT_TH_FRCf_GET(r) ((((r).pcs_ber_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_PCS_BER_CTLr_BER_CNT_TH_FRCf_SET(r,f) (r).pcs_ber_ctl[0]=(((r).pcs_ber_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PCS_BER_CTLr_BER_CNT_THf_GET(r) (((r).pcs_ber_ctl[0]) & 0x7f)
#define BCMI_MADURA_PCS_BER_CTLr_BER_CNT_THf_SET(r,f) (r).pcs_ber_ctl[0]=(((r).pcs_ber_ctl[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access PCS_BER_CTL.
 */
#define BCMI_MADURA_READ_PCS_BER_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_BER_CTLr,_r._pcs_ber_ctl)
#define BCMI_MADURA_WRITE_PCS_BER_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_BER_CTLr,_r._pcs_ber_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_BER_CTLr BCMI_MADURA_PCS_BER_CTLr
#define PCS_BER_CTLr_SIZE BCMI_MADURA_PCS_BER_CTLr_SIZE
typedef BCMI_MADURA_PCS_BER_CTLr_t PCS_BER_CTLr_t;
#define PCS_BER_CTLr_CLR BCMI_MADURA_PCS_BER_CTLr_CLR
#define PCS_BER_CTLr_SET BCMI_MADURA_PCS_BER_CTLr_SET
#define PCS_BER_CTLr_GET BCMI_MADURA_PCS_BER_CTLr_GET
#define PCS_BER_CTLr_XUS_TIMER_FRCf_GET BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_FRCf_GET
#define PCS_BER_CTLr_XUS_TIMER_FRCf_SET BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_FRCf_SET
#define PCS_BER_CTLr_XUS_TIMER_MSBf_GET BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_MSBf_GET
#define PCS_BER_CTLr_XUS_TIMER_MSBf_SET BCMI_MADURA_PCS_BER_CTLr_XUS_TIMER_MSBf_SET
#define PCS_BER_CTLr_BER_CNT_TH_FRCf_GET BCMI_MADURA_PCS_BER_CTLr_BER_CNT_TH_FRCf_GET
#define PCS_BER_CTLr_BER_CNT_TH_FRCf_SET BCMI_MADURA_PCS_BER_CTLr_BER_CNT_TH_FRCf_SET
#define PCS_BER_CTLr_BER_CNT_THf_GET BCMI_MADURA_PCS_BER_CTLr_BER_CNT_THf_GET
#define PCS_BER_CTLr_BER_CNT_THf_SET BCMI_MADURA_PCS_BER_CTLr_BER_CNT_THf_SET
#define READ_PCS_BER_CTLr BCMI_MADURA_READ_PCS_BER_CTLr
#define WRITE_PCS_BER_CTLr BCMI_MADURA_WRITE_PCS_BER_CTLr
#define MODIFY_PCS_BER_CTLr BCMI_MADURA_MODIFY_PCS_BER_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_BER_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_INVALID_SH_CNT_82
 * BLOCKS:   LANE
 * REGADDR:  0xb005
 * DEVAD:    1
 * DESC:     PCS monitor Lock State Machine CL82 parameters invalid_sh_cnt2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     INVALID_SH_CNT_82 invalid sh_cnt_82 threshold to deassert block_lock in Clause 82
 *     INVALID_SH_CNT_82_FRC invalid sh_cnt_82 threshold force bit. 1'b1: use invalid_sh_cnt_82 as configuration, 1'b0: default
 */
#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r (0x0001b005 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_SIZE 4

/*
 * This structure should be used to declare and program PCS_INVALID_SH_CNT_82.
 */
typedef union BCMI_MADURA_PCS_INVALID_SH_CNT_82r_s {
	uint32_t v[1];
	uint32_t pcs_invalid_sh_cnt_82[1];
	uint32_t _pcs_invalid_sh_cnt_82;
} BCMI_MADURA_PCS_INVALID_SH_CNT_82r_t;

#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_CLR(r) (r).pcs_invalid_sh_cnt_82[0] = 0
#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_SET(r,d) (r).pcs_invalid_sh_cnt_82[0] = d
#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_GET(r) (r).pcs_invalid_sh_cnt_82[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82_FRCf_GET(r) ((((r).pcs_invalid_sh_cnt_82[0]) >> 12) & 0x1)
#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82_FRCf_SET(r,f) (r).pcs_invalid_sh_cnt_82[0]=(((r).pcs_invalid_sh_cnt_82[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82f_GET(r) (((r).pcs_invalid_sh_cnt_82[0]) & 0xfff)
#define BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82f_SET(r,f) (r).pcs_invalid_sh_cnt_82[0]=(((r).pcs_invalid_sh_cnt_82[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access PCS_INVALID_SH_CNT_82.
 */
#define BCMI_MADURA_READ_PCS_INVALID_SH_CNT_82r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_INVALID_SH_CNT_82r,_r._pcs_invalid_sh_cnt_82)
#define BCMI_MADURA_WRITE_PCS_INVALID_SH_CNT_82r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_INVALID_SH_CNT_82r,_r._pcs_invalid_sh_cnt_82)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_INVALID_SH_CNT_82r BCMI_MADURA_PCS_INVALID_SH_CNT_82r
#define PCS_INVALID_SH_CNT_82r_SIZE BCMI_MADURA_PCS_INVALID_SH_CNT_82r_SIZE
typedef BCMI_MADURA_PCS_INVALID_SH_CNT_82r_t PCS_INVALID_SH_CNT_82r_t;
#define PCS_INVALID_SH_CNT_82r_CLR BCMI_MADURA_PCS_INVALID_SH_CNT_82r_CLR
#define PCS_INVALID_SH_CNT_82r_SET BCMI_MADURA_PCS_INVALID_SH_CNT_82r_SET
#define PCS_INVALID_SH_CNT_82r_GET BCMI_MADURA_PCS_INVALID_SH_CNT_82r_GET
#define PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82_FRCf_GET BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82_FRCf_GET
#define PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82_FRCf_SET BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82_FRCf_SET
#define PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82f_GET BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82f_GET
#define PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82f_SET BCMI_MADURA_PCS_INVALID_SH_CNT_82r_INVALID_SH_CNT_82f_SET
#define READ_PCS_INVALID_SH_CNT_82r BCMI_MADURA_READ_PCS_INVALID_SH_CNT_82r
#define WRITE_PCS_INVALID_SH_CNT_82r BCMI_MADURA_WRITE_PCS_INVALID_SH_CNT_82r
#define MODIFY_PCS_INVALID_SH_CNT_82r BCMI_MADURA_MODIFY_PCS_INVALID_SH_CNT_82r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_INVALID_SH_CNT_82r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_VALID_SH_CNT_82
 * BLOCKS:   LANE
 * REGADDR:  0xb006
 * DEVAD:    1
 * DESC:     PCS monitor Lock State Machine CL82 parameters valid_sh_cnt2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     VALID_SH_CNT_82  valid sh_cnt threshold to transit from state VALID_SH2 to RESET_CNT
 *     VALID_SH_CNT_82_FRC valid sh_cnt_82 threshold force bit. 1'b1: use valid_sh_cnt_82 as configuration, 1'b0: default
 */
#define BCMI_MADURA_PCS_VALID_SH_CNT_82r (0x0001b006 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_SIZE 4

/*
 * This structure should be used to declare and program PCS_VALID_SH_CNT_82.
 */
typedef union BCMI_MADURA_PCS_VALID_SH_CNT_82r_s {
	uint32_t v[1];
	uint32_t pcs_valid_sh_cnt_82[1];
	uint32_t _pcs_valid_sh_cnt_82;
} BCMI_MADURA_PCS_VALID_SH_CNT_82r_t;

#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_CLR(r) (r).pcs_valid_sh_cnt_82[0] = 0
#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_SET(r,d) (r).pcs_valid_sh_cnt_82[0] = d
#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_GET(r) (r).pcs_valid_sh_cnt_82[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82_FRCf_GET(r) ((((r).pcs_valid_sh_cnt_82[0]) >> 12) & 0x1)
#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82_FRCf_SET(r,f) (r).pcs_valid_sh_cnt_82[0]=(((r).pcs_valid_sh_cnt_82[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82f_GET(r) (((r).pcs_valid_sh_cnt_82[0]) & 0xfff)
#define BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82f_SET(r,f) (r).pcs_valid_sh_cnt_82[0]=(((r).pcs_valid_sh_cnt_82[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access PCS_VALID_SH_CNT_82.
 */
#define BCMI_MADURA_READ_PCS_VALID_SH_CNT_82r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_VALID_SH_CNT_82r,_r._pcs_valid_sh_cnt_82)
#define BCMI_MADURA_WRITE_PCS_VALID_SH_CNT_82r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_VALID_SH_CNT_82r,_r._pcs_valid_sh_cnt_82)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_VALID_SH_CNT_82r BCMI_MADURA_PCS_VALID_SH_CNT_82r
#define PCS_VALID_SH_CNT_82r_SIZE BCMI_MADURA_PCS_VALID_SH_CNT_82r_SIZE
typedef BCMI_MADURA_PCS_VALID_SH_CNT_82r_t PCS_VALID_SH_CNT_82r_t;
#define PCS_VALID_SH_CNT_82r_CLR BCMI_MADURA_PCS_VALID_SH_CNT_82r_CLR
#define PCS_VALID_SH_CNT_82r_SET BCMI_MADURA_PCS_VALID_SH_CNT_82r_SET
#define PCS_VALID_SH_CNT_82r_GET BCMI_MADURA_PCS_VALID_SH_CNT_82r_GET
#define PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82_FRCf_GET BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82_FRCf_GET
#define PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82_FRCf_SET BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82_FRCf_SET
#define PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82f_GET BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82f_GET
#define PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82f_SET BCMI_MADURA_PCS_VALID_SH_CNT_82r_VALID_SH_CNT_82f_SET
#define READ_PCS_VALID_SH_CNT_82r BCMI_MADURA_READ_PCS_VALID_SH_CNT_82r
#define WRITE_PCS_VALID_SH_CNT_82r BCMI_MADURA_WRITE_PCS_VALID_SH_CNT_82r
#define MODIFY_PCS_VALID_SH_CNT_82r BCMI_MADURA_MODIFY_PCS_VALID_SH_CNT_82r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_VALID_SH_CNT_82r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_CL49_PARAM_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb007
 * DEVAD:    1
 * DESC:     PCS monitor Lock State Machine CL49 parameters
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     VALID_SH_CNT     valid sh_cnt threshold for LSM to transit from VALID_SH to 64_GOOD or SLIP
 *     INVALID_SH_CNT   invalid sh_cnt threshold for LSM to transit from INVALID_SH to SLIP
 */
#define BCMI_MADURA_PCS_CL49_PARAM_CTLr (0x0001b007 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PCS_CL49_PARAM_CTL.
 */
typedef union BCMI_MADURA_PCS_CL49_PARAM_CTLr_s {
	uint32_t v[1];
	uint32_t pcs_cl49_param_ctl[1];
	uint32_t _pcs_cl49_param_ctl;
} BCMI_MADURA_PCS_CL49_PARAM_CTLr_t;

#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_CLR(r) (r).pcs_cl49_param_ctl[0] = 0
#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_SET(r,d) (r).pcs_cl49_param_ctl[0] = d
#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_GET(r) (r).pcs_cl49_param_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_INVALID_SH_CNTf_GET(r) ((((r).pcs_cl49_param_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_INVALID_SH_CNTf_SET(r,f) (r).pcs_cl49_param_ctl[0]=(((r).pcs_cl49_param_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_VALID_SH_CNTf_GET(r) (((r).pcs_cl49_param_ctl[0]) & 0xff)
#define BCMI_MADURA_PCS_CL49_PARAM_CTLr_VALID_SH_CNTf_SET(r,f) (r).pcs_cl49_param_ctl[0]=(((r).pcs_cl49_param_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PCS_CL49_PARAM_CTL.
 */
#define BCMI_MADURA_READ_PCS_CL49_PARAM_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_CL49_PARAM_CTLr,_r._pcs_cl49_param_ctl)
#define BCMI_MADURA_WRITE_PCS_CL49_PARAM_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_CL49_PARAM_CTLr,_r._pcs_cl49_param_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_CL49_PARAM_CTLr BCMI_MADURA_PCS_CL49_PARAM_CTLr
#define PCS_CL49_PARAM_CTLr_SIZE BCMI_MADURA_PCS_CL49_PARAM_CTLr_SIZE
typedef BCMI_MADURA_PCS_CL49_PARAM_CTLr_t PCS_CL49_PARAM_CTLr_t;
#define PCS_CL49_PARAM_CTLr_CLR BCMI_MADURA_PCS_CL49_PARAM_CTLr_CLR
#define PCS_CL49_PARAM_CTLr_SET BCMI_MADURA_PCS_CL49_PARAM_CTLr_SET
#define PCS_CL49_PARAM_CTLr_GET BCMI_MADURA_PCS_CL49_PARAM_CTLr_GET
#define PCS_CL49_PARAM_CTLr_INVALID_SH_CNTf_GET BCMI_MADURA_PCS_CL49_PARAM_CTLr_INVALID_SH_CNTf_GET
#define PCS_CL49_PARAM_CTLr_INVALID_SH_CNTf_SET BCMI_MADURA_PCS_CL49_PARAM_CTLr_INVALID_SH_CNTf_SET
#define PCS_CL49_PARAM_CTLr_VALID_SH_CNTf_GET BCMI_MADURA_PCS_CL49_PARAM_CTLr_VALID_SH_CNTf_GET
#define PCS_CL49_PARAM_CTLr_VALID_SH_CNTf_SET BCMI_MADURA_PCS_CL49_PARAM_CTLr_VALID_SH_CNTf_SET
#define READ_PCS_CL49_PARAM_CTLr BCMI_MADURA_READ_PCS_CL49_PARAM_CTLr
#define WRITE_PCS_CL49_PARAM_CTLr BCMI_MADURA_WRITE_PCS_CL49_PARAM_CTLr
#define MODIFY_PCS_CL49_PARAM_CTLr BCMI_MADURA_MODIFY_PCS_CL49_PARAM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_CL49_PARAM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_MON_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb008
 * DEVAD:    1
 * DESC:     FC monitor main control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     COMMA_TEST_WINDOW comma test window size3'b000: 3200us3'b001: 1600us3'b010: 800us3'b011: 400us3'b100: 200us3'b101: 100us3'b110: 50us3'b111: 25us
 *     FSM_RESET        active high reset for word sync state machine
 *     COMMA_TEST_FRC   force bit to use comma_test_window_msb and comma_test_window_lsb for comma test window1'b1: use configuration comma_test_window_msb and comma_test_window_lsb1'b0: use per mode defaults
 *     LINK_TEST_FRC    force bit to use link_test_window_msb and link_test_window_lsb  for link test window size1'b1: use configuration link_test_window_msb and link_test_window_lsb1'b0: use per mode defaults
 *     SYNC_TEST_FRC    force bit to use sync_test_window for sync test window size1'b1: use configuration sync_test_window1'b0: use per mode defaults
 *     FC_SYNC_TEST_START set to start sync test
 *     FC_SYNC_MODE     word sync mode, 0: use comma, 1: use K28.5 to find word boundary
 */
#define BCMI_MADURA_FC_MON_CTLr (0x0001b008 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_MON_CTLr_SIZE 4

/*
 * This structure should be used to declare and program FC_MON_CTL.
 */
typedef union BCMI_MADURA_FC_MON_CTLr_s {
	uint32_t v[1];
	uint32_t fc_mon_ctl[1];
	uint32_t _fc_mon_ctl;
} BCMI_MADURA_FC_MON_CTLr_t;

#define BCMI_MADURA_FC_MON_CTLr_CLR(r) (r).fc_mon_ctl[0] = 0
#define BCMI_MADURA_FC_MON_CTLr_SET(r,d) (r).fc_mon_ctl[0] = d
#define BCMI_MADURA_FC_MON_CTLr_GET(r) (r).fc_mon_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_MON_CTLr_FC_SYNC_MODEf_GET(r) ((((r).fc_mon_ctl[0]) >> 8) & 0x1)
#define BCMI_MADURA_FC_MON_CTLr_FC_SYNC_MODEf_SET(r,f) (r).fc_mon_ctl[0]=(((r).fc_mon_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_FC_MON_CTLr_FC_SYNC_TEST_STARTf_GET(r) ((((r).fc_mon_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_FC_MON_CTLr_FC_SYNC_TEST_STARTf_SET(r,f) (r).fc_mon_ctl[0]=(((r).fc_mon_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_FC_MON_CTLr_SYNC_TEST_FRCf_GET(r) ((((r).fc_mon_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_FC_MON_CTLr_SYNC_TEST_FRCf_SET(r,f) (r).fc_mon_ctl[0]=(((r).fc_mon_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_FC_MON_CTLr_LINK_TEST_FRCf_GET(r) ((((r).fc_mon_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_FC_MON_CTLr_LINK_TEST_FRCf_SET(r,f) (r).fc_mon_ctl[0]=(((r).fc_mon_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_FRCf_GET(r) ((((r).fc_mon_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_FRCf_SET(r,f) (r).fc_mon_ctl[0]=(((r).fc_mon_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_FC_MON_CTLr_FSM_RESETf_GET(r) ((((r).fc_mon_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_FC_MON_CTLr_FSM_RESETf_SET(r,f) (r).fc_mon_ctl[0]=(((r).fc_mon_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_WINDOWf_GET(r) (((r).fc_mon_ctl[0]) & 0x7)
#define BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_WINDOWf_SET(r,f) (r).fc_mon_ctl[0]=(((r).fc_mon_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access FC_MON_CTL.
 */
#define BCMI_MADURA_READ_FC_MON_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_MON_CTLr,_r._fc_mon_ctl)
#define BCMI_MADURA_WRITE_FC_MON_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_MON_CTLr,_r._fc_mon_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_CTLr BCMI_MADURA_FC_MON_CTLr
#define FC_MON_CTLr_SIZE BCMI_MADURA_FC_MON_CTLr_SIZE
typedef BCMI_MADURA_FC_MON_CTLr_t FC_MON_CTLr_t;
#define FC_MON_CTLr_CLR BCMI_MADURA_FC_MON_CTLr_CLR
#define FC_MON_CTLr_SET BCMI_MADURA_FC_MON_CTLr_SET
#define FC_MON_CTLr_GET BCMI_MADURA_FC_MON_CTLr_GET
#define FC_MON_CTLr_FC_SYNC_MODEf_GET BCMI_MADURA_FC_MON_CTLr_FC_SYNC_MODEf_GET
#define FC_MON_CTLr_FC_SYNC_MODEf_SET BCMI_MADURA_FC_MON_CTLr_FC_SYNC_MODEf_SET
#define FC_MON_CTLr_FC_SYNC_TEST_STARTf_GET BCMI_MADURA_FC_MON_CTLr_FC_SYNC_TEST_STARTf_GET
#define FC_MON_CTLr_FC_SYNC_TEST_STARTf_SET BCMI_MADURA_FC_MON_CTLr_FC_SYNC_TEST_STARTf_SET
#define FC_MON_CTLr_SYNC_TEST_FRCf_GET BCMI_MADURA_FC_MON_CTLr_SYNC_TEST_FRCf_GET
#define FC_MON_CTLr_SYNC_TEST_FRCf_SET BCMI_MADURA_FC_MON_CTLr_SYNC_TEST_FRCf_SET
#define FC_MON_CTLr_LINK_TEST_FRCf_GET BCMI_MADURA_FC_MON_CTLr_LINK_TEST_FRCf_GET
#define FC_MON_CTLr_LINK_TEST_FRCf_SET BCMI_MADURA_FC_MON_CTLr_LINK_TEST_FRCf_SET
#define FC_MON_CTLr_COMMA_TEST_FRCf_GET BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_FRCf_GET
#define FC_MON_CTLr_COMMA_TEST_FRCf_SET BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_FRCf_SET
#define FC_MON_CTLr_FSM_RESETf_GET BCMI_MADURA_FC_MON_CTLr_FSM_RESETf_GET
#define FC_MON_CTLr_FSM_RESETf_SET BCMI_MADURA_FC_MON_CTLr_FSM_RESETf_SET
#define FC_MON_CTLr_COMMA_TEST_WINDOWf_GET BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_WINDOWf_GET
#define FC_MON_CTLr_COMMA_TEST_WINDOWf_SET BCMI_MADURA_FC_MON_CTLr_COMMA_TEST_WINDOWf_SET
#define READ_FC_MON_CTLr BCMI_MADURA_READ_FC_MON_CTLr
#define WRITE_FC_MON_CTLr BCMI_MADURA_WRITE_FC_MON_CTLr
#define MODIFY_FC_MON_CTLr BCMI_MADURA_MODIFY_FC_MON_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_MON_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_COMMA_TEST_WIN_LSB
 * BLOCKS:   LANE
 * REGADDR:  0xb009
 * DEVAD:    1
 * DESC:     FC monitor comma test window LSB
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     COMMA_TEST_WINDOW_LSB comma test window timer, bit 15:0
 */
#define BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr (0x0001b009 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_SIZE 4

/*
 * This structure should be used to declare and program FC_COMMA_TEST_WIN_LSB.
 */
typedef union BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_s {
	uint32_t v[1];
	uint32_t fc_comma_test_win_lsb[1];
	uint32_t _fc_comma_test_win_lsb;
} BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_t;

#define BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_CLR(r) (r).fc_comma_test_win_lsb[0] = 0
#define BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_SET(r,d) (r).fc_comma_test_win_lsb[0] = d
#define BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_GET(r) (r).fc_comma_test_win_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_COMMA_TEST_WINDOW_LSBf_GET(r) (((r).fc_comma_test_win_lsb[0]) & 0xffff)
#define BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_COMMA_TEST_WINDOW_LSBf_SET(r,f) (r).fc_comma_test_win_lsb[0]=(((r).fc_comma_test_win_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FC_COMMA_TEST_WIN_LSB.
 */
#define BCMI_MADURA_READ_FC_COMMA_TEST_WIN_LSBr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr,_r._fc_comma_test_win_lsb)
#define BCMI_MADURA_WRITE_FC_COMMA_TEST_WIN_LSBr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr,_r._fc_comma_test_win_lsb)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_COMMA_TEST_WIN_LSBr BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr
#define FC_COMMA_TEST_WIN_LSBr_SIZE BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_SIZE
typedef BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_t FC_COMMA_TEST_WIN_LSBr_t;
#define FC_COMMA_TEST_WIN_LSBr_CLR BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_CLR
#define FC_COMMA_TEST_WIN_LSBr_SET BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_SET
#define FC_COMMA_TEST_WIN_LSBr_GET BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_GET
#define FC_COMMA_TEST_WIN_LSBr_COMMA_TEST_WINDOW_LSBf_GET BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_COMMA_TEST_WINDOW_LSBf_GET
#define FC_COMMA_TEST_WIN_LSBr_COMMA_TEST_WINDOW_LSBf_SET BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr_COMMA_TEST_WINDOW_LSBf_SET
#define READ_FC_COMMA_TEST_WIN_LSBr BCMI_MADURA_READ_FC_COMMA_TEST_WIN_LSBr
#define WRITE_FC_COMMA_TEST_WIN_LSBr BCMI_MADURA_WRITE_FC_COMMA_TEST_WIN_LSBr
#define MODIFY_FC_COMMA_TEST_WIN_LSBr BCMI_MADURA_MODIFY_FC_COMMA_TEST_WIN_LSBr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_COMMA_TEST_WIN_LSBr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_COMMA_TEST_WIN_MSB
 * BLOCKS:   LANE
 * REGADDR:  0xb00a
 * DEVAD:    1
 * DESC:     FC monitor comma test window MSB
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     COMMA_TEST_WINDOW_MSB comma test window timer, bit 31:16
 */
#define BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr (0x0001b00a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_SIZE 4

/*
 * This structure should be used to declare and program FC_COMMA_TEST_WIN_MSB.
 */
typedef union BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_s {
	uint32_t v[1];
	uint32_t fc_comma_test_win_msb[1];
	uint32_t _fc_comma_test_win_msb;
} BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_t;

#define BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_CLR(r) (r).fc_comma_test_win_msb[0] = 0
#define BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_SET(r,d) (r).fc_comma_test_win_msb[0] = d
#define BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_GET(r) (r).fc_comma_test_win_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_COMMA_TEST_WINDOW_MSBf_GET(r) (((r).fc_comma_test_win_msb[0]) & 0xffff)
#define BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_COMMA_TEST_WINDOW_MSBf_SET(r,f) (r).fc_comma_test_win_msb[0]=(((r).fc_comma_test_win_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FC_COMMA_TEST_WIN_MSB.
 */
#define BCMI_MADURA_READ_FC_COMMA_TEST_WIN_MSBr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr,_r._fc_comma_test_win_msb)
#define BCMI_MADURA_WRITE_FC_COMMA_TEST_WIN_MSBr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr,_r._fc_comma_test_win_msb)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_COMMA_TEST_WIN_MSBr BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr
#define FC_COMMA_TEST_WIN_MSBr_SIZE BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_SIZE
typedef BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_t FC_COMMA_TEST_WIN_MSBr_t;
#define FC_COMMA_TEST_WIN_MSBr_CLR BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_CLR
#define FC_COMMA_TEST_WIN_MSBr_SET BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_SET
#define FC_COMMA_TEST_WIN_MSBr_GET BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_GET
#define FC_COMMA_TEST_WIN_MSBr_COMMA_TEST_WINDOW_MSBf_GET BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_COMMA_TEST_WINDOW_MSBf_GET
#define FC_COMMA_TEST_WIN_MSBr_COMMA_TEST_WINDOW_MSBf_SET BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr_COMMA_TEST_WINDOW_MSBf_SET
#define READ_FC_COMMA_TEST_WIN_MSBr BCMI_MADURA_READ_FC_COMMA_TEST_WIN_MSBr
#define WRITE_FC_COMMA_TEST_WIN_MSBr BCMI_MADURA_WRITE_FC_COMMA_TEST_WIN_MSBr
#define MODIFY_FC_COMMA_TEST_WIN_MSBr BCMI_MADURA_MODIFY_FC_COMMA_TEST_WIN_MSBr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_COMMA_TEST_WIN_MSBr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_LNK_TEST_WIN_LSB
 * BLOCKS:   LANE
 * REGADDR:  0xb00b
 * DEVAD:    1
 * DESC:     FC monitor Link test window LSB
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_TEST_WINDOW_LSB link test window timer, bit 15:0
 */
#define BCMI_MADURA_FC_LNK_TEST_WIN_LSBr (0x0001b00b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_SIZE 4

/*
 * This structure should be used to declare and program FC_LNK_TEST_WIN_LSB.
 */
typedef union BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_s {
	uint32_t v[1];
	uint32_t fc_lnk_test_win_lsb[1];
	uint32_t _fc_lnk_test_win_lsb;
} BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_t;

#define BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_CLR(r) (r).fc_lnk_test_win_lsb[0] = 0
#define BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_SET(r,d) (r).fc_lnk_test_win_lsb[0] = d
#define BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_GET(r) (r).fc_lnk_test_win_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_LINK_TEST_WINDOW_LSBf_GET(r) (((r).fc_lnk_test_win_lsb[0]) & 0xffff)
#define BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_LINK_TEST_WINDOW_LSBf_SET(r,f) (r).fc_lnk_test_win_lsb[0]=(((r).fc_lnk_test_win_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FC_LNK_TEST_WIN_LSB.
 */
#define BCMI_MADURA_READ_FC_LNK_TEST_WIN_LSBr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_LNK_TEST_WIN_LSBr,_r._fc_lnk_test_win_lsb)
#define BCMI_MADURA_WRITE_FC_LNK_TEST_WIN_LSBr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_LNK_TEST_WIN_LSBr,_r._fc_lnk_test_win_lsb)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_LNK_TEST_WIN_LSBr BCMI_MADURA_FC_LNK_TEST_WIN_LSBr
#define FC_LNK_TEST_WIN_LSBr_SIZE BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_SIZE
typedef BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_t FC_LNK_TEST_WIN_LSBr_t;
#define FC_LNK_TEST_WIN_LSBr_CLR BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_CLR
#define FC_LNK_TEST_WIN_LSBr_SET BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_SET
#define FC_LNK_TEST_WIN_LSBr_GET BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_GET
#define FC_LNK_TEST_WIN_LSBr_LINK_TEST_WINDOW_LSBf_GET BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_LINK_TEST_WINDOW_LSBf_GET
#define FC_LNK_TEST_WIN_LSBr_LINK_TEST_WINDOW_LSBf_SET BCMI_MADURA_FC_LNK_TEST_WIN_LSBr_LINK_TEST_WINDOW_LSBf_SET
#define READ_FC_LNK_TEST_WIN_LSBr BCMI_MADURA_READ_FC_LNK_TEST_WIN_LSBr
#define WRITE_FC_LNK_TEST_WIN_LSBr BCMI_MADURA_WRITE_FC_LNK_TEST_WIN_LSBr
#define MODIFY_FC_LNK_TEST_WIN_LSBr BCMI_MADURA_MODIFY_FC_LNK_TEST_WIN_LSBr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_LNK_TEST_WIN_LSBr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_LNK_TEST_WIN_MSB
 * BLOCKS:   LANE
 * REGADDR:  0xb00c
 * DEVAD:    1
 * DESC:     FC monitor Link test window MSB
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_TEST_WINDOW_MSB link test window timer, bit 31:16
 */
#define BCMI_MADURA_FC_LNK_TEST_WIN_MSBr (0x0001b00c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_SIZE 4

/*
 * This structure should be used to declare and program FC_LNK_TEST_WIN_MSB.
 */
typedef union BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_s {
	uint32_t v[1];
	uint32_t fc_lnk_test_win_msb[1];
	uint32_t _fc_lnk_test_win_msb;
} BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_t;

#define BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_CLR(r) (r).fc_lnk_test_win_msb[0] = 0
#define BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_SET(r,d) (r).fc_lnk_test_win_msb[0] = d
#define BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_GET(r) (r).fc_lnk_test_win_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_LINK_TEST_WINDOW_MSBf_GET(r) (((r).fc_lnk_test_win_msb[0]) & 0xffff)
#define BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_LINK_TEST_WINDOW_MSBf_SET(r,f) (r).fc_lnk_test_win_msb[0]=(((r).fc_lnk_test_win_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FC_LNK_TEST_WIN_MSB.
 */
#define BCMI_MADURA_READ_FC_LNK_TEST_WIN_MSBr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_LNK_TEST_WIN_MSBr,_r._fc_lnk_test_win_msb)
#define BCMI_MADURA_WRITE_FC_LNK_TEST_WIN_MSBr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_LNK_TEST_WIN_MSBr,_r._fc_lnk_test_win_msb)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_LNK_TEST_WIN_MSBr BCMI_MADURA_FC_LNK_TEST_WIN_MSBr
#define FC_LNK_TEST_WIN_MSBr_SIZE BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_SIZE
typedef BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_t FC_LNK_TEST_WIN_MSBr_t;
#define FC_LNK_TEST_WIN_MSBr_CLR BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_CLR
#define FC_LNK_TEST_WIN_MSBr_SET BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_SET
#define FC_LNK_TEST_WIN_MSBr_GET BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_GET
#define FC_LNK_TEST_WIN_MSBr_LINK_TEST_WINDOW_MSBf_GET BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_LINK_TEST_WINDOW_MSBf_GET
#define FC_LNK_TEST_WIN_MSBr_LINK_TEST_WINDOW_MSBf_SET BCMI_MADURA_FC_LNK_TEST_WIN_MSBr_LINK_TEST_WINDOW_MSBf_SET
#define READ_FC_LNK_TEST_WIN_MSBr BCMI_MADURA_READ_FC_LNK_TEST_WIN_MSBr
#define WRITE_FC_LNK_TEST_WIN_MSBr BCMI_MADURA_WRITE_FC_LNK_TEST_WIN_MSBr
#define MODIFY_FC_LNK_TEST_WIN_MSBr BCMI_MADURA_MODIFY_FC_LNK_TEST_WIN_MSBr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_LNK_TEST_WIN_MSBr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_SYNC_TEST_WIN
 * BLOCKS:   LANE
 * REGADDR:  0xb00d
 * DEVAD:    1
 * DESC:     FC monitor Sync test window
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNC_TEST_WINDOW sync test window size
 */
#define BCMI_MADURA_FC_SYNC_TEST_WINr (0x0001b00d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_SYNC_TEST_WINr_SIZE 4

/*
 * This structure should be used to declare and program FC_SYNC_TEST_WIN.
 */
typedef union BCMI_MADURA_FC_SYNC_TEST_WINr_s {
	uint32_t v[1];
	uint32_t fc_sync_test_win[1];
	uint32_t _fc_sync_test_win;
} BCMI_MADURA_FC_SYNC_TEST_WINr_t;

#define BCMI_MADURA_FC_SYNC_TEST_WINr_CLR(r) (r).fc_sync_test_win[0] = 0
#define BCMI_MADURA_FC_SYNC_TEST_WINr_SET(r,d) (r).fc_sync_test_win[0] = d
#define BCMI_MADURA_FC_SYNC_TEST_WINr_GET(r) (r).fc_sync_test_win[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_SYNC_TEST_WINr_SYNC_TEST_WINDOWf_GET(r) (((r).fc_sync_test_win[0]) & 0xffff)
#define BCMI_MADURA_FC_SYNC_TEST_WINr_SYNC_TEST_WINDOWf_SET(r,f) (r).fc_sync_test_win[0]=(((r).fc_sync_test_win[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FC_SYNC_TEST_WIN.
 */
#define BCMI_MADURA_READ_FC_SYNC_TEST_WINr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_SYNC_TEST_WINr,_r._fc_sync_test_win)
#define BCMI_MADURA_WRITE_FC_SYNC_TEST_WINr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_SYNC_TEST_WINr,_r._fc_sync_test_win)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_SYNC_TEST_WINr BCMI_MADURA_FC_SYNC_TEST_WINr
#define FC_SYNC_TEST_WINr_SIZE BCMI_MADURA_FC_SYNC_TEST_WINr_SIZE
typedef BCMI_MADURA_FC_SYNC_TEST_WINr_t FC_SYNC_TEST_WINr_t;
#define FC_SYNC_TEST_WINr_CLR BCMI_MADURA_FC_SYNC_TEST_WINr_CLR
#define FC_SYNC_TEST_WINr_SET BCMI_MADURA_FC_SYNC_TEST_WINr_SET
#define FC_SYNC_TEST_WINr_GET BCMI_MADURA_FC_SYNC_TEST_WINr_GET
#define FC_SYNC_TEST_WINr_SYNC_TEST_WINDOWf_GET BCMI_MADURA_FC_SYNC_TEST_WINr_SYNC_TEST_WINDOWf_GET
#define FC_SYNC_TEST_WINr_SYNC_TEST_WINDOWf_SET BCMI_MADURA_FC_SYNC_TEST_WINr_SYNC_TEST_WINDOWf_SET
#define READ_FC_SYNC_TEST_WINr BCMI_MADURA_READ_FC_SYNC_TEST_WINr
#define WRITE_FC_SYNC_TEST_WINr BCMI_MADURA_WRITE_FC_SYNC_TEST_WINr
#define MODIFY_FC_SYNC_TEST_WINr BCMI_MADURA_MODIFY_FC_SYNC_TEST_WINr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_SYNC_TEST_WINr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_CHK_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb00e
 * DEVAD:    1
 * DESC:     SSPR check main control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SSPR_UNLOCK_DIS  SSPR monitor FSM unlock disable
 *     SSPR_BER_MNTR_EN SSPR BER monitor enable
 *     SSPR_START_BER_MNTR SSPR BER monitor start at the positive edge of this signal
 */
#define BCMI_MADURA_SSPR_CHK_CTLr (0x0001b00e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_CHK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SSPR_CHK_CTL.
 */
typedef union BCMI_MADURA_SSPR_CHK_CTLr_s {
	uint32_t v[1];
	uint32_t sspr_chk_ctl[1];
	uint32_t _sspr_chk_ctl;
} BCMI_MADURA_SSPR_CHK_CTLr_t;

#define BCMI_MADURA_SSPR_CHK_CTLr_CLR(r) (r).sspr_chk_ctl[0] = 0
#define BCMI_MADURA_SSPR_CHK_CTLr_SET(r,d) (r).sspr_chk_ctl[0] = d
#define BCMI_MADURA_SSPR_CHK_CTLr_GET(r) (r).sspr_chk_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_CHK_CTLr_SSPR_START_BER_MNTRf_GET(r) ((((r).sspr_chk_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_SSPR_CHK_CTLr_SSPR_START_BER_MNTRf_SET(r,f) (r).sspr_chk_ctl[0]=(((r).sspr_chk_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_SSPR_CHK_CTLr_SSPR_BER_MNTR_ENf_GET(r) ((((r).sspr_chk_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_SSPR_CHK_CTLr_SSPR_BER_MNTR_ENf_SET(r,f) (r).sspr_chk_ctl[0]=(((r).sspr_chk_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SSPR_CHK_CTLr_SSPR_UNLOCK_DISf_GET(r) (((r).sspr_chk_ctl[0]) & 0x1)
#define BCMI_MADURA_SSPR_CHK_CTLr_SSPR_UNLOCK_DISf_SET(r,f) (r).sspr_chk_ctl[0]=(((r).sspr_chk_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SSPR_CHK_CTL.
 */
#define BCMI_MADURA_READ_SSPR_CHK_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_CHK_CTLr,_r._sspr_chk_ctl)
#define BCMI_MADURA_WRITE_SSPR_CHK_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_CHK_CTLr,_r._sspr_chk_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_CHK_CTLr BCMI_MADURA_SSPR_CHK_CTLr
#define SSPR_CHK_CTLr_SIZE BCMI_MADURA_SSPR_CHK_CTLr_SIZE
typedef BCMI_MADURA_SSPR_CHK_CTLr_t SSPR_CHK_CTLr_t;
#define SSPR_CHK_CTLr_CLR BCMI_MADURA_SSPR_CHK_CTLr_CLR
#define SSPR_CHK_CTLr_SET BCMI_MADURA_SSPR_CHK_CTLr_SET
#define SSPR_CHK_CTLr_GET BCMI_MADURA_SSPR_CHK_CTLr_GET
#define SSPR_CHK_CTLr_SSPR_START_BER_MNTRf_GET BCMI_MADURA_SSPR_CHK_CTLr_SSPR_START_BER_MNTRf_GET
#define SSPR_CHK_CTLr_SSPR_START_BER_MNTRf_SET BCMI_MADURA_SSPR_CHK_CTLr_SSPR_START_BER_MNTRf_SET
#define SSPR_CHK_CTLr_SSPR_BER_MNTR_ENf_GET BCMI_MADURA_SSPR_CHK_CTLr_SSPR_BER_MNTR_ENf_GET
#define SSPR_CHK_CTLr_SSPR_BER_MNTR_ENf_SET BCMI_MADURA_SSPR_CHK_CTLr_SSPR_BER_MNTR_ENf_SET
#define SSPR_CHK_CTLr_SSPR_UNLOCK_DISf_GET BCMI_MADURA_SSPR_CHK_CTLr_SSPR_UNLOCK_DISf_GET
#define SSPR_CHK_CTLr_SSPR_UNLOCK_DISf_SET BCMI_MADURA_SSPR_CHK_CTLr_SSPR_UNLOCK_DISf_SET
#define READ_SSPR_CHK_CTLr BCMI_MADURA_READ_SSPR_CHK_CTLr
#define WRITE_SSPR_CHK_CTLr BCMI_MADURA_WRITE_SSPR_CHK_CTLr
#define MODIFY_SSPR_CHK_CTLr BCMI_MADURA_MODIFY_SSPR_CHK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_CHK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_BER_TMR_CNT2
 * BLOCKS:   LANE
 * REGADDR:  0xb00f
 * DEVAD:    1
 * DESC:     SSPR BER timer bit 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_TIMER_CNT2   SSPR monitor BER monitoring period, bit 47:32
 */
#define BCMI_MADURA_SSPR_BER_TMR_CNT2r (0x0001b00f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_BER_TMR_CNT2r_SIZE 4

/*
 * This structure should be used to declare and program SSPR_BER_TMR_CNT2.
 */
typedef union BCMI_MADURA_SSPR_BER_TMR_CNT2r_s {
	uint32_t v[1];
	uint32_t sspr_ber_tmr_cnt2[1];
	uint32_t _sspr_ber_tmr_cnt2;
} BCMI_MADURA_SSPR_BER_TMR_CNT2r_t;

#define BCMI_MADURA_SSPR_BER_TMR_CNT2r_CLR(r) (r).sspr_ber_tmr_cnt2[0] = 0
#define BCMI_MADURA_SSPR_BER_TMR_CNT2r_SET(r,d) (r).sspr_ber_tmr_cnt2[0] = d
#define BCMI_MADURA_SSPR_BER_TMR_CNT2r_GET(r) (r).sspr_ber_tmr_cnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_BER_TMR_CNT2r_BER_TIMER_CNT2f_GET(r) (((r).sspr_ber_tmr_cnt2[0]) & 0xffff)
#define BCMI_MADURA_SSPR_BER_TMR_CNT2r_BER_TIMER_CNT2f_SET(r,f) (r).sspr_ber_tmr_cnt2[0]=(((r).sspr_ber_tmr_cnt2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SSPR_BER_TMR_CNT2.
 */
#define BCMI_MADURA_READ_SSPR_BER_TMR_CNT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_BER_TMR_CNT2r,_r._sspr_ber_tmr_cnt2)
#define BCMI_MADURA_WRITE_SSPR_BER_TMR_CNT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_BER_TMR_CNT2r,_r._sspr_ber_tmr_cnt2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_BER_TMR_CNT2r BCMI_MADURA_SSPR_BER_TMR_CNT2r
#define SSPR_BER_TMR_CNT2r_SIZE BCMI_MADURA_SSPR_BER_TMR_CNT2r_SIZE
typedef BCMI_MADURA_SSPR_BER_TMR_CNT2r_t SSPR_BER_TMR_CNT2r_t;
#define SSPR_BER_TMR_CNT2r_CLR BCMI_MADURA_SSPR_BER_TMR_CNT2r_CLR
#define SSPR_BER_TMR_CNT2r_SET BCMI_MADURA_SSPR_BER_TMR_CNT2r_SET
#define SSPR_BER_TMR_CNT2r_GET BCMI_MADURA_SSPR_BER_TMR_CNT2r_GET
#define SSPR_BER_TMR_CNT2r_BER_TIMER_CNT2f_GET BCMI_MADURA_SSPR_BER_TMR_CNT2r_BER_TIMER_CNT2f_GET
#define SSPR_BER_TMR_CNT2r_BER_TIMER_CNT2f_SET BCMI_MADURA_SSPR_BER_TMR_CNT2r_BER_TIMER_CNT2f_SET
#define READ_SSPR_BER_TMR_CNT2r BCMI_MADURA_READ_SSPR_BER_TMR_CNT2r
#define WRITE_SSPR_BER_TMR_CNT2r BCMI_MADURA_WRITE_SSPR_BER_TMR_CNT2r
#define MODIFY_SSPR_BER_TMR_CNT2r BCMI_MADURA_MODIFY_SSPR_BER_TMR_CNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_BER_TMR_CNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_BER_TMR_CNT1
 * BLOCKS:   LANE
 * REGADDR:  0xb010
 * DEVAD:    1
 * DESC:     SSPR BER timer bit 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_TIMER_CNT1   SSPR monitor BER monitoring period, bit 31:16
 */
#define BCMI_MADURA_SSPR_BER_TMR_CNT1r (0x0001b010 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_BER_TMR_CNT1r_SIZE 4

/*
 * This structure should be used to declare and program SSPR_BER_TMR_CNT1.
 */
typedef union BCMI_MADURA_SSPR_BER_TMR_CNT1r_s {
	uint32_t v[1];
	uint32_t sspr_ber_tmr_cnt1[1];
	uint32_t _sspr_ber_tmr_cnt1;
} BCMI_MADURA_SSPR_BER_TMR_CNT1r_t;

#define BCMI_MADURA_SSPR_BER_TMR_CNT1r_CLR(r) (r).sspr_ber_tmr_cnt1[0] = 0
#define BCMI_MADURA_SSPR_BER_TMR_CNT1r_SET(r,d) (r).sspr_ber_tmr_cnt1[0] = d
#define BCMI_MADURA_SSPR_BER_TMR_CNT1r_GET(r) (r).sspr_ber_tmr_cnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_BER_TMR_CNT1r_BER_TIMER_CNT1f_GET(r) (((r).sspr_ber_tmr_cnt1[0]) & 0xffff)
#define BCMI_MADURA_SSPR_BER_TMR_CNT1r_BER_TIMER_CNT1f_SET(r,f) (r).sspr_ber_tmr_cnt1[0]=(((r).sspr_ber_tmr_cnt1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SSPR_BER_TMR_CNT1.
 */
#define BCMI_MADURA_READ_SSPR_BER_TMR_CNT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_BER_TMR_CNT1r,_r._sspr_ber_tmr_cnt1)
#define BCMI_MADURA_WRITE_SSPR_BER_TMR_CNT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_BER_TMR_CNT1r,_r._sspr_ber_tmr_cnt1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_BER_TMR_CNT1r BCMI_MADURA_SSPR_BER_TMR_CNT1r
#define SSPR_BER_TMR_CNT1r_SIZE BCMI_MADURA_SSPR_BER_TMR_CNT1r_SIZE
typedef BCMI_MADURA_SSPR_BER_TMR_CNT1r_t SSPR_BER_TMR_CNT1r_t;
#define SSPR_BER_TMR_CNT1r_CLR BCMI_MADURA_SSPR_BER_TMR_CNT1r_CLR
#define SSPR_BER_TMR_CNT1r_SET BCMI_MADURA_SSPR_BER_TMR_CNT1r_SET
#define SSPR_BER_TMR_CNT1r_GET BCMI_MADURA_SSPR_BER_TMR_CNT1r_GET
#define SSPR_BER_TMR_CNT1r_BER_TIMER_CNT1f_GET BCMI_MADURA_SSPR_BER_TMR_CNT1r_BER_TIMER_CNT1f_GET
#define SSPR_BER_TMR_CNT1r_BER_TIMER_CNT1f_SET BCMI_MADURA_SSPR_BER_TMR_CNT1r_BER_TIMER_CNT1f_SET
#define READ_SSPR_BER_TMR_CNT1r BCMI_MADURA_READ_SSPR_BER_TMR_CNT1r
#define WRITE_SSPR_BER_TMR_CNT1r BCMI_MADURA_WRITE_SSPR_BER_TMR_CNT1r
#define MODIFY_SSPR_BER_TMR_CNT1r BCMI_MADURA_MODIFY_SSPR_BER_TMR_CNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_BER_TMR_CNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_BER_TMR_CNT0
 * BLOCKS:   LANE
 * REGADDR:  0xb011
 * DEVAD:    1
 * DESC:     SSPR BER timer bit 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_TIMER_CNT0   SSPR monitor BER monitoring period, bit 15:0
 */
#define BCMI_MADURA_SSPR_BER_TMR_CNT0r (0x0001b011 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_BER_TMR_CNT0r_SIZE 4

/*
 * This structure should be used to declare and program SSPR_BER_TMR_CNT0.
 */
typedef union BCMI_MADURA_SSPR_BER_TMR_CNT0r_s {
	uint32_t v[1];
	uint32_t sspr_ber_tmr_cnt0[1];
	uint32_t _sspr_ber_tmr_cnt0;
} BCMI_MADURA_SSPR_BER_TMR_CNT0r_t;

#define BCMI_MADURA_SSPR_BER_TMR_CNT0r_CLR(r) (r).sspr_ber_tmr_cnt0[0] = 0
#define BCMI_MADURA_SSPR_BER_TMR_CNT0r_SET(r,d) (r).sspr_ber_tmr_cnt0[0] = d
#define BCMI_MADURA_SSPR_BER_TMR_CNT0r_GET(r) (r).sspr_ber_tmr_cnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_BER_TMR_CNT0r_BER_TIMER_CNT0f_GET(r) (((r).sspr_ber_tmr_cnt0[0]) & 0xffff)
#define BCMI_MADURA_SSPR_BER_TMR_CNT0r_BER_TIMER_CNT0f_SET(r,f) (r).sspr_ber_tmr_cnt0[0]=(((r).sspr_ber_tmr_cnt0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SSPR_BER_TMR_CNT0.
 */
#define BCMI_MADURA_READ_SSPR_BER_TMR_CNT0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_BER_TMR_CNT0r,_r._sspr_ber_tmr_cnt0)
#define BCMI_MADURA_WRITE_SSPR_BER_TMR_CNT0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_BER_TMR_CNT0r,_r._sspr_ber_tmr_cnt0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_BER_TMR_CNT0r BCMI_MADURA_SSPR_BER_TMR_CNT0r
#define SSPR_BER_TMR_CNT0r_SIZE BCMI_MADURA_SSPR_BER_TMR_CNT0r_SIZE
typedef BCMI_MADURA_SSPR_BER_TMR_CNT0r_t SSPR_BER_TMR_CNT0r_t;
#define SSPR_BER_TMR_CNT0r_CLR BCMI_MADURA_SSPR_BER_TMR_CNT0r_CLR
#define SSPR_BER_TMR_CNT0r_SET BCMI_MADURA_SSPR_BER_TMR_CNT0r_SET
#define SSPR_BER_TMR_CNT0r_GET BCMI_MADURA_SSPR_BER_TMR_CNT0r_GET
#define SSPR_BER_TMR_CNT0r_BER_TIMER_CNT0f_GET BCMI_MADURA_SSPR_BER_TMR_CNT0r_BER_TIMER_CNT0f_GET
#define SSPR_BER_TMR_CNT0r_BER_TIMER_CNT0f_SET BCMI_MADURA_SSPR_BER_TMR_CNT0r_BER_TIMER_CNT0f_SET
#define READ_SSPR_BER_TMR_CNT0r BCMI_MADURA_READ_SSPR_BER_TMR_CNT0r
#define WRITE_SSPR_BER_TMR_CNT0r BCMI_MADURA_WRITE_SSPR_BER_TMR_CNT0r
#define MODIFY_SSPR_BER_TMR_CNT0r BCMI_MADURA_MODIFY_SSPR_BER_TMR_CNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_BER_TMR_CNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb012
 * DEVAD:    1
 * DESC:     isolated pulse, scrambled IDLE, and SSPR generation control
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_INSERT       Insert error into SSPR or scrambled IDLE generator
 *     ERR_INSERT_CNT   Count for number of cycles error need to be inserted in SSPR generator
 *     PULSE_WIDTH      isolated pulse width1: 40ns2: 80ns...255: 10200ns
 */
#define BCMI_MADURA_PATGEN_CTLr (0x0001b012 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_CTL.
 */
typedef union BCMI_MADURA_PATGEN_CTLr_s {
	uint32_t v[1];
	uint32_t patgen_ctl[1];
	uint32_t _patgen_ctl;
} BCMI_MADURA_PATGEN_CTLr_t;

#define BCMI_MADURA_PATGEN_CTLr_CLR(r) (r).patgen_ctl[0] = 0
#define BCMI_MADURA_PATGEN_CTLr_SET(r,d) (r).patgen_ctl[0] = d
#define BCMI_MADURA_PATGEN_CTLr_GET(r) (r).patgen_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_CTLr_PULSE_WIDTHf_GET(r) ((((r).patgen_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_PATGEN_CTLr_PULSE_WIDTHf_SET(r,f) (r).patgen_ctl[0]=(((r).patgen_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PATGEN_CTLr_ERR_INSERT_CNTf_GET(r) ((((r).patgen_ctl[0]) >> 1) & 0xf)
#define BCMI_MADURA_PATGEN_CTLr_ERR_INSERT_CNTf_SET(r,f) (r).patgen_ctl[0]=(((r).patgen_ctl[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))
#define BCMI_MADURA_PATGEN_CTLr_ERR_INSERTf_GET(r) (((r).patgen_ctl[0]) & 0x1)
#define BCMI_MADURA_PATGEN_CTLr_ERR_INSERTf_SET(r,f) (r).patgen_ctl[0]=(((r).patgen_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PATGEN_CTL.
 */
#define BCMI_MADURA_READ_PATGEN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_CTLr,_r._patgen_ctl)
#define BCMI_MADURA_WRITE_PATGEN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_CTLr,_r._patgen_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_CTLr BCMI_MADURA_PATGEN_CTLr
#define PATGEN_CTLr_SIZE BCMI_MADURA_PATGEN_CTLr_SIZE
typedef BCMI_MADURA_PATGEN_CTLr_t PATGEN_CTLr_t;
#define PATGEN_CTLr_CLR BCMI_MADURA_PATGEN_CTLr_CLR
#define PATGEN_CTLr_SET BCMI_MADURA_PATGEN_CTLr_SET
#define PATGEN_CTLr_GET BCMI_MADURA_PATGEN_CTLr_GET
#define PATGEN_CTLr_PULSE_WIDTHf_GET BCMI_MADURA_PATGEN_CTLr_PULSE_WIDTHf_GET
#define PATGEN_CTLr_PULSE_WIDTHf_SET BCMI_MADURA_PATGEN_CTLr_PULSE_WIDTHf_SET
#define PATGEN_CTLr_ERR_INSERT_CNTf_GET BCMI_MADURA_PATGEN_CTLr_ERR_INSERT_CNTf_GET
#define PATGEN_CTLr_ERR_INSERT_CNTf_SET BCMI_MADURA_PATGEN_CTLr_ERR_INSERT_CNTf_SET
#define PATGEN_CTLr_ERR_INSERTf_GET BCMI_MADURA_PATGEN_CTLr_ERR_INSERTf_GET
#define PATGEN_CTLr_ERR_INSERTf_SET BCMI_MADURA_PATGEN_CTLr_ERR_INSERTf_SET
#define READ_PATGEN_CTLr BCMI_MADURA_READ_PATGEN_CTLr
#define WRITE_PATGEN_CTLr BCMI_MADURA_WRITE_PATGEN_CTLr
#define MODIFY_PATGEN_CTLr BCMI_MADURA_MODIFY_PATGEN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_PRBS_LEN1
 * BLOCKS:   LANE
 * REGADDR:  0xb013
 * DEVAD:    1
 * DESC:     SSPR PRBS length value bit 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_LEN1        PRBS31 sequence length, bit 30:16
 */
#define BCMI_MADURA_SSPR_PRBS_LEN1r (0x0001b013 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_PRBS_LEN1r_SIZE 4

/*
 * This structure should be used to declare and program SSPR_PRBS_LEN1.
 */
typedef union BCMI_MADURA_SSPR_PRBS_LEN1r_s {
	uint32_t v[1];
	uint32_t sspr_prbs_len1[1];
	uint32_t _sspr_prbs_len1;
} BCMI_MADURA_SSPR_PRBS_LEN1r_t;

#define BCMI_MADURA_SSPR_PRBS_LEN1r_CLR(r) (r).sspr_prbs_len1[0] = 0
#define BCMI_MADURA_SSPR_PRBS_LEN1r_SET(r,d) (r).sspr_prbs_len1[0] = d
#define BCMI_MADURA_SSPR_PRBS_LEN1r_GET(r) (r).sspr_prbs_len1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_PRBS_LEN1r_PRBS_LEN1f_GET(r) (((r).sspr_prbs_len1[0]) & 0x7fff)
#define BCMI_MADURA_SSPR_PRBS_LEN1r_PRBS_LEN1f_SET(r,f) (r).sspr_prbs_len1[0]=(((r).sspr_prbs_len1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access SSPR_PRBS_LEN1.
 */
#define BCMI_MADURA_READ_SSPR_PRBS_LEN1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_PRBS_LEN1r,_r._sspr_prbs_len1)
#define BCMI_MADURA_WRITE_SSPR_PRBS_LEN1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_PRBS_LEN1r,_r._sspr_prbs_len1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_PRBS_LEN1r BCMI_MADURA_SSPR_PRBS_LEN1r
#define SSPR_PRBS_LEN1r_SIZE BCMI_MADURA_SSPR_PRBS_LEN1r_SIZE
typedef BCMI_MADURA_SSPR_PRBS_LEN1r_t SSPR_PRBS_LEN1r_t;
#define SSPR_PRBS_LEN1r_CLR BCMI_MADURA_SSPR_PRBS_LEN1r_CLR
#define SSPR_PRBS_LEN1r_SET BCMI_MADURA_SSPR_PRBS_LEN1r_SET
#define SSPR_PRBS_LEN1r_GET BCMI_MADURA_SSPR_PRBS_LEN1r_GET
#define SSPR_PRBS_LEN1r_PRBS_LEN1f_GET BCMI_MADURA_SSPR_PRBS_LEN1r_PRBS_LEN1f_GET
#define SSPR_PRBS_LEN1r_PRBS_LEN1f_SET BCMI_MADURA_SSPR_PRBS_LEN1r_PRBS_LEN1f_SET
#define READ_SSPR_PRBS_LEN1r BCMI_MADURA_READ_SSPR_PRBS_LEN1r
#define WRITE_SSPR_PRBS_LEN1r BCMI_MADURA_WRITE_SSPR_PRBS_LEN1r
#define MODIFY_SSPR_PRBS_LEN1r BCMI_MADURA_MODIFY_SSPR_PRBS_LEN1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_PRBS_LEN1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_PRBS_LEN0
 * BLOCKS:   LANE
 * REGADDR:  0xb014
 * DEVAD:    1
 * DESC:     SSPR PRBS length value bit 15:0
 * RESETVAL: 0x2858 (10328)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_LEN0        PRBS31 sequence length, bit 15:0Length specified in this register need to be multiple of 8.
 */
#define BCMI_MADURA_SSPR_PRBS_LEN0r (0x0001b014 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_PRBS_LEN0r_SIZE 4

/*
 * This structure should be used to declare and program SSPR_PRBS_LEN0.
 */
typedef union BCMI_MADURA_SSPR_PRBS_LEN0r_s {
	uint32_t v[1];
	uint32_t sspr_prbs_len0[1];
	uint32_t _sspr_prbs_len0;
} BCMI_MADURA_SSPR_PRBS_LEN0r_t;

#define BCMI_MADURA_SSPR_PRBS_LEN0r_CLR(r) (r).sspr_prbs_len0[0] = 0
#define BCMI_MADURA_SSPR_PRBS_LEN0r_SET(r,d) (r).sspr_prbs_len0[0] = d
#define BCMI_MADURA_SSPR_PRBS_LEN0r_GET(r) (r).sspr_prbs_len0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_PRBS_LEN0r_PRBS_LEN0f_GET(r) (((r).sspr_prbs_len0[0]) & 0xffff)
#define BCMI_MADURA_SSPR_PRBS_LEN0r_PRBS_LEN0f_SET(r,f) (r).sspr_prbs_len0[0]=(((r).sspr_prbs_len0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SSPR_PRBS_LEN0.
 */
#define BCMI_MADURA_READ_SSPR_PRBS_LEN0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_PRBS_LEN0r,_r._sspr_prbs_len0)
#define BCMI_MADURA_WRITE_SSPR_PRBS_LEN0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_PRBS_LEN0r,_r._sspr_prbs_len0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_PRBS_LEN0r BCMI_MADURA_SSPR_PRBS_LEN0r
#define SSPR_PRBS_LEN0r_SIZE BCMI_MADURA_SSPR_PRBS_LEN0r_SIZE
typedef BCMI_MADURA_SSPR_PRBS_LEN0r_t SSPR_PRBS_LEN0r_t;
#define SSPR_PRBS_LEN0r_CLR BCMI_MADURA_SSPR_PRBS_LEN0r_CLR
#define SSPR_PRBS_LEN0r_SET BCMI_MADURA_SSPR_PRBS_LEN0r_SET
#define SSPR_PRBS_LEN0r_GET BCMI_MADURA_SSPR_PRBS_LEN0r_GET
#define SSPR_PRBS_LEN0r_PRBS_LEN0f_GET BCMI_MADURA_SSPR_PRBS_LEN0r_PRBS_LEN0f_GET
#define SSPR_PRBS_LEN0r_PRBS_LEN0f_SET BCMI_MADURA_SSPR_PRBS_LEN0r_PRBS_LEN0f_SET
#define READ_SSPR_PRBS_LEN0r BCMI_MADURA_READ_SSPR_PRBS_LEN0r
#define WRITE_SSPR_PRBS_LEN0r BCMI_MADURA_WRITE_SSPR_PRBS_LEN0r
#define MODIFY_SSPR_PRBS_LEN0r BCMI_MADURA_MODIFY_SSPR_PRBS_LEN0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_PRBS_LEN0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  COLLIDE_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb020
 * DEVAD:    1
 * DESC:     Phase FIFO collision status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     COLLIDE_LH       phase FIFO collision latch high status, 1 bit per read port
 */
#define BCMI_MADURA_COLLIDE_STSr (0x0001b020 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_COLLIDE_STSr_SIZE 4

/*
 * This structure should be used to declare and program COLLIDE_STS.
 */
typedef union BCMI_MADURA_COLLIDE_STSr_s {
	uint32_t v[1];
	uint32_t collide_sts[1];
	uint32_t _collide_sts;
} BCMI_MADURA_COLLIDE_STSr_t;

#define BCMI_MADURA_COLLIDE_STSr_CLR(r) (r).collide_sts[0] = 0
#define BCMI_MADURA_COLLIDE_STSr_SET(r,d) (r).collide_sts[0] = d
#define BCMI_MADURA_COLLIDE_STSr_GET(r) (r).collide_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_COLLIDE_STSr_COLLIDE_LHf_GET(r) (((r).collide_sts[0]) & 0x1ff)
#define BCMI_MADURA_COLLIDE_STSr_COLLIDE_LHf_SET(r,f) (r).collide_sts[0]=(((r).collide_sts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access COLLIDE_STS.
 */
#define BCMI_MADURA_READ_COLLIDE_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_COLLIDE_STSr,_r._collide_sts)
#define BCMI_MADURA_WRITE_COLLIDE_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_COLLIDE_STSr,_r._collide_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define COLLIDE_STSr BCMI_MADURA_COLLIDE_STSr
#define COLLIDE_STSr_SIZE BCMI_MADURA_COLLIDE_STSr_SIZE
typedef BCMI_MADURA_COLLIDE_STSr_t COLLIDE_STSr_t;
#define COLLIDE_STSr_CLR BCMI_MADURA_COLLIDE_STSr_CLR
#define COLLIDE_STSr_SET BCMI_MADURA_COLLIDE_STSr_SET
#define COLLIDE_STSr_GET BCMI_MADURA_COLLIDE_STSr_GET
#define COLLIDE_STSr_COLLIDE_LHf_GET BCMI_MADURA_COLLIDE_STSr_COLLIDE_LHf_GET
#define COLLIDE_STSr_COLLIDE_LHf_SET BCMI_MADURA_COLLIDE_STSr_COLLIDE_LHf_SET
#define READ_COLLIDE_STSr BCMI_MADURA_READ_COLLIDE_STSr
#define WRITE_COLLIDE_STSr BCMI_MADURA_WRITE_COLLIDE_STSr
#define MODIFY_COLLIDE_STSr BCMI_MADURA_MODIFY_COLLIDE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_COLLIDE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  COLLIDE_LIVE_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb021
 * DEVAD:    1
 * DESC:     Phase FIFO collision live status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     COLLIDE          phase FIFO collision live status, 1 bit per read port
 */
#define BCMI_MADURA_COLLIDE_LIVE_STSr (0x0001b021 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_COLLIDE_LIVE_STSr_SIZE 4

/*
 * This structure should be used to declare and program COLLIDE_LIVE_STS.
 */
typedef union BCMI_MADURA_COLLIDE_LIVE_STSr_s {
	uint32_t v[1];
	uint32_t collide_live_sts[1];
	uint32_t _collide_live_sts;
} BCMI_MADURA_COLLIDE_LIVE_STSr_t;

#define BCMI_MADURA_COLLIDE_LIVE_STSr_CLR(r) (r).collide_live_sts[0] = 0
#define BCMI_MADURA_COLLIDE_LIVE_STSr_SET(r,d) (r).collide_live_sts[0] = d
#define BCMI_MADURA_COLLIDE_LIVE_STSr_GET(r) (r).collide_live_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_COLLIDE_LIVE_STSr_COLLIDEf_GET(r) (((r).collide_live_sts[0]) & 0x1ff)
#define BCMI_MADURA_COLLIDE_LIVE_STSr_COLLIDEf_SET(r,f) (r).collide_live_sts[0]=(((r).collide_live_sts[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access COLLIDE_LIVE_STS.
 */
#define BCMI_MADURA_READ_COLLIDE_LIVE_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_COLLIDE_LIVE_STSr,_r._collide_live_sts)
#define BCMI_MADURA_WRITE_COLLIDE_LIVE_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_COLLIDE_LIVE_STSr,_r._collide_live_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define COLLIDE_LIVE_STSr BCMI_MADURA_COLLIDE_LIVE_STSr
#define COLLIDE_LIVE_STSr_SIZE BCMI_MADURA_COLLIDE_LIVE_STSr_SIZE
typedef BCMI_MADURA_COLLIDE_LIVE_STSr_t COLLIDE_LIVE_STSr_t;
#define COLLIDE_LIVE_STSr_CLR BCMI_MADURA_COLLIDE_LIVE_STSr_CLR
#define COLLIDE_LIVE_STSr_SET BCMI_MADURA_COLLIDE_LIVE_STSr_SET
#define COLLIDE_LIVE_STSr_GET BCMI_MADURA_COLLIDE_LIVE_STSr_GET
#define COLLIDE_LIVE_STSr_COLLIDEf_GET BCMI_MADURA_COLLIDE_LIVE_STSr_COLLIDEf_GET
#define COLLIDE_LIVE_STSr_COLLIDEf_SET BCMI_MADURA_COLLIDE_LIVE_STSr_COLLIDEf_SET
#define READ_COLLIDE_LIVE_STSr BCMI_MADURA_READ_COLLIDE_LIVE_STSr
#define WRITE_COLLIDE_LIVE_STSr BCMI_MADURA_WRITE_COLLIDE_LIVE_STSr
#define MODIFY_COLLIDE_LIVE_STSr BCMI_MADURA_MODIFY_COLLIDE_LIVE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_COLLIDE_LIVE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_MON_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb022
 * DEVAD:    1
 * DESC:     PCS monitor main status
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     BLOCK_LOCK_LL    PCS monitor lock status, latch low
 *     BLOCK_LOCK_LH    PCS monitor lock status, latch high
 *     PCS_STATUS_LL    pcs_status is an inverse of receive_fault_lh
 *     RECEIVE_FAULT_LH receive fault, either block_lock is not achieved or hi_ber
 *     LSM_LSTATE       Lock State Machine latched state
 */
#define BCMI_MADURA_PCS_MON_STSr (0x0001b022 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_MON_STSr_SIZE 4

/*
 * This structure should be used to declare and program PCS_MON_STS.
 */
typedef union BCMI_MADURA_PCS_MON_STSr_s {
	uint32_t v[1];
	uint32_t pcs_mon_sts[1];
	uint32_t _pcs_mon_sts;
} BCMI_MADURA_PCS_MON_STSr_t;

#define BCMI_MADURA_PCS_MON_STSr_CLR(r) (r).pcs_mon_sts[0] = 0
#define BCMI_MADURA_PCS_MON_STSr_SET(r,d) (r).pcs_mon_sts[0] = d
#define BCMI_MADURA_PCS_MON_STSr_GET(r) (r).pcs_mon_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_MON_STSr_LSM_LSTATEf_GET(r) ((((r).pcs_mon_sts[0]) >> 4) & 0x1ff)
#define BCMI_MADURA_PCS_MON_STSr_LSM_LSTATEf_SET(r,f) (r).pcs_mon_sts[0]=(((r).pcs_mon_sts[0] & ~((uint32_t)0x1ff << 4)) | ((((uint32_t)f) & 0x1ff) << 4)) | (511 << (16 + 4))
#define BCMI_MADURA_PCS_MON_STSr_RECEIVE_FAULT_LHf_GET(r) ((((r).pcs_mon_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_PCS_MON_STSr_RECEIVE_FAULT_LHf_SET(r,f) (r).pcs_mon_sts[0]=(((r).pcs_mon_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PCS_MON_STSr_PCS_STATUS_LLf_GET(r) ((((r).pcs_mon_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_PCS_MON_STSr_PCS_STATUS_LLf_SET(r,f) (r).pcs_mon_sts[0]=(((r).pcs_mon_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LHf_GET(r) ((((r).pcs_mon_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LHf_SET(r,f) (r).pcs_mon_sts[0]=(((r).pcs_mon_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LLf_GET(r) (((r).pcs_mon_sts[0]) & 0x1)
#define BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LLf_SET(r,f) (r).pcs_mon_sts[0]=(((r).pcs_mon_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PCS_MON_STS.
 */
#define BCMI_MADURA_READ_PCS_MON_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_MON_STSr,_r._pcs_mon_sts)
#define BCMI_MADURA_WRITE_PCS_MON_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_MON_STSr,_r._pcs_mon_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_MON_STSr BCMI_MADURA_PCS_MON_STSr
#define PCS_MON_STSr_SIZE BCMI_MADURA_PCS_MON_STSr_SIZE
typedef BCMI_MADURA_PCS_MON_STSr_t PCS_MON_STSr_t;
#define PCS_MON_STSr_CLR BCMI_MADURA_PCS_MON_STSr_CLR
#define PCS_MON_STSr_SET BCMI_MADURA_PCS_MON_STSr_SET
#define PCS_MON_STSr_GET BCMI_MADURA_PCS_MON_STSr_GET
#define PCS_MON_STSr_LSM_LSTATEf_GET BCMI_MADURA_PCS_MON_STSr_LSM_LSTATEf_GET
#define PCS_MON_STSr_LSM_LSTATEf_SET BCMI_MADURA_PCS_MON_STSr_LSM_LSTATEf_SET
#define PCS_MON_STSr_RECEIVE_FAULT_LHf_GET BCMI_MADURA_PCS_MON_STSr_RECEIVE_FAULT_LHf_GET
#define PCS_MON_STSr_RECEIVE_FAULT_LHf_SET BCMI_MADURA_PCS_MON_STSr_RECEIVE_FAULT_LHf_SET
#define PCS_MON_STSr_PCS_STATUS_LLf_GET BCMI_MADURA_PCS_MON_STSr_PCS_STATUS_LLf_GET
#define PCS_MON_STSr_PCS_STATUS_LLf_SET BCMI_MADURA_PCS_MON_STSr_PCS_STATUS_LLf_SET
#define PCS_MON_STSr_BLOCK_LOCK_LHf_GET BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LHf_GET
#define PCS_MON_STSr_BLOCK_LOCK_LHf_SET BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LHf_SET
#define PCS_MON_STSr_BLOCK_LOCK_LLf_GET BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LLf_GET
#define PCS_MON_STSr_BLOCK_LOCK_LLf_SET BCMI_MADURA_PCS_MON_STSr_BLOCK_LOCK_LLf_SET
#define READ_PCS_MON_STSr BCMI_MADURA_READ_PCS_MON_STSr
#define WRITE_PCS_MON_STSr BCMI_MADURA_WRITE_PCS_MON_STSr
#define MODIFY_PCS_MON_STSr BCMI_MADURA_MODIFY_PCS_MON_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_MON_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL49_BER_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb023
 * DEVAD:    1
 * DESC:     Clause 49 BER status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_COUNT        Clause 49 ber_count, bit 5:0
 *     HI_BER_LH        hi_ber latch high status
 *     BER_TIMER_DONE   BER monitor timer done
 *     BER_LSTATE       BER monitor latched state
 */
#define BCMI_MADURA_CL49_BER_STSr (0x0001b023 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL49_BER_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL49_BER_STS.
 */
typedef union BCMI_MADURA_CL49_BER_STSr_s {
	uint32_t v[1];
	uint32_t cl49_ber_sts[1];
	uint32_t _cl49_ber_sts;
} BCMI_MADURA_CL49_BER_STSr_t;

#define BCMI_MADURA_CL49_BER_STSr_CLR(r) (r).cl49_ber_sts[0] = 0
#define BCMI_MADURA_CL49_BER_STSr_SET(r,d) (r).cl49_ber_sts[0] = d
#define BCMI_MADURA_CL49_BER_STSr_GET(r) (r).cl49_ber_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL49_BER_STSr_BER_LSTATEf_GET(r) ((((r).cl49_ber_sts[0]) >> 8) & 0x7f)
#define BCMI_MADURA_CL49_BER_STSr_BER_LSTATEf_SET(r,f) (r).cl49_ber_sts[0]=(((r).cl49_ber_sts[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_CL49_BER_STSr_BER_TIMER_DONEf_GET(r) ((((r).cl49_ber_sts[0]) >> 7) & 0x1)
#define BCMI_MADURA_CL49_BER_STSr_BER_TIMER_DONEf_SET(r,f) (r).cl49_ber_sts[0]=(((r).cl49_ber_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_CL49_BER_STSr_HI_BER_LHf_GET(r) ((((r).cl49_ber_sts[0]) >> 6) & 0x1)
#define BCMI_MADURA_CL49_BER_STSr_HI_BER_LHf_SET(r,f) (r).cl49_ber_sts[0]=(((r).cl49_ber_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_CL49_BER_STSr_BER_COUNTf_GET(r) (((r).cl49_ber_sts[0]) & 0x3f)
#define BCMI_MADURA_CL49_BER_STSr_BER_COUNTf_SET(r,f) (r).cl49_ber_sts[0]=(((r).cl49_ber_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access CL49_BER_STS.
 */
#define BCMI_MADURA_READ_CL49_BER_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL49_BER_STSr,_r._cl49_ber_sts)
#define BCMI_MADURA_WRITE_CL49_BER_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL49_BER_STSr,_r._cl49_ber_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL49_BER_STSr BCMI_MADURA_CL49_BER_STSr
#define CL49_BER_STSr_SIZE BCMI_MADURA_CL49_BER_STSr_SIZE
typedef BCMI_MADURA_CL49_BER_STSr_t CL49_BER_STSr_t;
#define CL49_BER_STSr_CLR BCMI_MADURA_CL49_BER_STSr_CLR
#define CL49_BER_STSr_SET BCMI_MADURA_CL49_BER_STSr_SET
#define CL49_BER_STSr_GET BCMI_MADURA_CL49_BER_STSr_GET
#define CL49_BER_STSr_BER_LSTATEf_GET BCMI_MADURA_CL49_BER_STSr_BER_LSTATEf_GET
#define CL49_BER_STSr_BER_LSTATEf_SET BCMI_MADURA_CL49_BER_STSr_BER_LSTATEf_SET
#define CL49_BER_STSr_BER_TIMER_DONEf_GET BCMI_MADURA_CL49_BER_STSr_BER_TIMER_DONEf_GET
#define CL49_BER_STSr_BER_TIMER_DONEf_SET BCMI_MADURA_CL49_BER_STSr_BER_TIMER_DONEf_SET
#define CL49_BER_STSr_HI_BER_LHf_GET BCMI_MADURA_CL49_BER_STSr_HI_BER_LHf_GET
#define CL49_BER_STSr_HI_BER_LHf_SET BCMI_MADURA_CL49_BER_STSr_HI_BER_LHf_SET
#define CL49_BER_STSr_BER_COUNTf_GET BCMI_MADURA_CL49_BER_STSr_BER_COUNTf_GET
#define CL49_BER_STSr_BER_COUNTf_SET BCMI_MADURA_CL49_BER_STSr_BER_COUNTf_SET
#define READ_CL49_BER_STSr BCMI_MADURA_READ_CL49_BER_STSr
#define WRITE_CL49_BER_STSr BCMI_MADURA_WRITE_CL49_BER_STSr
#define MODIFY_CL49_BER_STSr BCMI_MADURA_MODIFY_CL49_BER_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL49_BER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL82_BER_CNT
 * BLOCKS:   LANE
 * REGADDR:  0xb024
 * DEVAD:    1
 * DESC:     Clause 82 ber_count[21:6]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_COUNT_MSB    Clause 82 ber_count[21:6]please read cl49_ber_status before read this register to hold ber_count
 */
#define BCMI_MADURA_CL82_BER_CNTr (0x0001b024 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL82_BER_CNTr_SIZE 4

/*
 * This structure should be used to declare and program CL82_BER_CNT.
 */
typedef union BCMI_MADURA_CL82_BER_CNTr_s {
	uint32_t v[1];
	uint32_t cl82_ber_cnt[1];
	uint32_t _cl82_ber_cnt;
} BCMI_MADURA_CL82_BER_CNTr_t;

#define BCMI_MADURA_CL82_BER_CNTr_CLR(r) (r).cl82_ber_cnt[0] = 0
#define BCMI_MADURA_CL82_BER_CNTr_SET(r,d) (r).cl82_ber_cnt[0] = d
#define BCMI_MADURA_CL82_BER_CNTr_GET(r) (r).cl82_ber_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL82_BER_CNTr_BER_COUNT_MSBf_GET(r) (((r).cl82_ber_cnt[0]) & 0xffff)
#define BCMI_MADURA_CL82_BER_CNTr_BER_COUNT_MSBf_SET(r,f) (r).cl82_ber_cnt[0]=(((r).cl82_ber_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_BER_CNT.
 */
#define BCMI_MADURA_READ_CL82_BER_CNTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL82_BER_CNTr,_r._cl82_ber_cnt)
#define BCMI_MADURA_WRITE_CL82_BER_CNTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL82_BER_CNTr,_r._cl82_ber_cnt)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_BER_CNTr BCMI_MADURA_CL82_BER_CNTr
#define CL82_BER_CNTr_SIZE BCMI_MADURA_CL82_BER_CNTr_SIZE
typedef BCMI_MADURA_CL82_BER_CNTr_t CL82_BER_CNTr_t;
#define CL82_BER_CNTr_CLR BCMI_MADURA_CL82_BER_CNTr_CLR
#define CL82_BER_CNTr_SET BCMI_MADURA_CL82_BER_CNTr_SET
#define CL82_BER_CNTr_GET BCMI_MADURA_CL82_BER_CNTr_GET
#define CL82_BER_CNTr_BER_COUNT_MSBf_GET BCMI_MADURA_CL82_BER_CNTr_BER_COUNT_MSBf_GET
#define CL82_BER_CNTr_BER_COUNT_MSBf_SET BCMI_MADURA_CL82_BER_CNTr_BER_COUNT_MSBf_SET
#define READ_CL82_BER_CNTr BCMI_MADURA_READ_CL82_BER_CNTr
#define WRITE_CL82_BER_CNTr BCMI_MADURA_WRITE_CL82_BER_CNTr
#define MODIFY_CL82_BER_CNTr BCMI_MADURA_MODIFY_CL82_BER_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL82_BER_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PCS_MON_LIVE_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb025
 * DEVAD:    1
 * DESC:     PCS monitor live status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_STATUS       pcs_status live state
 *     BLOCK_LOCK       block_locklive state
 *     HI_BER           hi_ber live state
 *     LSM_STATE        lock state machine live state
 *     BER_STATE        BER monitor live state
 */
#define BCMI_MADURA_PCS_MON_LIVE_STSr (0x0001b025 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PCS_MON_LIVE_STSr_SIZE 4

/*
 * This structure should be used to declare and program PCS_MON_LIVE_STS.
 */
typedef union BCMI_MADURA_PCS_MON_LIVE_STSr_s {
	uint32_t v[1];
	uint32_t pcs_mon_live_sts[1];
	uint32_t _pcs_mon_live_sts;
} BCMI_MADURA_PCS_MON_LIVE_STSr_t;

#define BCMI_MADURA_PCS_MON_LIVE_STSr_CLR(r) (r).pcs_mon_live_sts[0] = 0
#define BCMI_MADURA_PCS_MON_LIVE_STSr_SET(r,d) (r).pcs_mon_live_sts[0] = d
#define BCMI_MADURA_PCS_MON_LIVE_STSr_GET(r) (r).pcs_mon_live_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PCS_MON_LIVE_STSr_BER_STATEf_GET(r) ((((r).pcs_mon_live_sts[0]) >> 6) & 0x3)
#define BCMI_MADURA_PCS_MON_LIVE_STSr_BER_STATEf_SET(r,f) (r).pcs_mon_live_sts[0]=(((r).pcs_mon_live_sts[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_PCS_MON_LIVE_STSr_LSM_STATEf_GET(r) ((((r).pcs_mon_live_sts[0]) >> 4) & 0x3)
#define BCMI_MADURA_PCS_MON_LIVE_STSr_LSM_STATEf_SET(r,f) (r).pcs_mon_live_sts[0]=(((r).pcs_mon_live_sts[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_PCS_MON_LIVE_STSr_HI_BERf_GET(r) ((((r).pcs_mon_live_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_PCS_MON_LIVE_STSr_HI_BERf_SET(r,f) (r).pcs_mon_live_sts[0]=(((r).pcs_mon_live_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PCS_MON_LIVE_STSr_BLOCK_LOCKf_GET(r) ((((r).pcs_mon_live_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_PCS_MON_LIVE_STSr_BLOCK_LOCKf_SET(r,f) (r).pcs_mon_live_sts[0]=(((r).pcs_mon_live_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PCS_MON_LIVE_STSr_PCS_STATUSf_GET(r) (((r).pcs_mon_live_sts[0]) & 0x1)
#define BCMI_MADURA_PCS_MON_LIVE_STSr_PCS_STATUSf_SET(r,f) (r).pcs_mon_live_sts[0]=(((r).pcs_mon_live_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PCS_MON_LIVE_STS.
 */
#define BCMI_MADURA_READ_PCS_MON_LIVE_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PCS_MON_LIVE_STSr,_r._pcs_mon_live_sts)
#define BCMI_MADURA_WRITE_PCS_MON_LIVE_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PCS_MON_LIVE_STSr,_r._pcs_mon_live_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PCS_MON_LIVE_STSr BCMI_MADURA_PCS_MON_LIVE_STSr
#define PCS_MON_LIVE_STSr_SIZE BCMI_MADURA_PCS_MON_LIVE_STSr_SIZE
typedef BCMI_MADURA_PCS_MON_LIVE_STSr_t PCS_MON_LIVE_STSr_t;
#define PCS_MON_LIVE_STSr_CLR BCMI_MADURA_PCS_MON_LIVE_STSr_CLR
#define PCS_MON_LIVE_STSr_SET BCMI_MADURA_PCS_MON_LIVE_STSr_SET
#define PCS_MON_LIVE_STSr_GET BCMI_MADURA_PCS_MON_LIVE_STSr_GET
#define PCS_MON_LIVE_STSr_BER_STATEf_GET BCMI_MADURA_PCS_MON_LIVE_STSr_BER_STATEf_GET
#define PCS_MON_LIVE_STSr_BER_STATEf_SET BCMI_MADURA_PCS_MON_LIVE_STSr_BER_STATEf_SET
#define PCS_MON_LIVE_STSr_LSM_STATEf_GET BCMI_MADURA_PCS_MON_LIVE_STSr_LSM_STATEf_GET
#define PCS_MON_LIVE_STSr_LSM_STATEf_SET BCMI_MADURA_PCS_MON_LIVE_STSr_LSM_STATEf_SET
#define PCS_MON_LIVE_STSr_HI_BERf_GET BCMI_MADURA_PCS_MON_LIVE_STSr_HI_BERf_GET
#define PCS_MON_LIVE_STSr_HI_BERf_SET BCMI_MADURA_PCS_MON_LIVE_STSr_HI_BERf_SET
#define PCS_MON_LIVE_STSr_BLOCK_LOCKf_GET BCMI_MADURA_PCS_MON_LIVE_STSr_BLOCK_LOCKf_GET
#define PCS_MON_LIVE_STSr_BLOCK_LOCKf_SET BCMI_MADURA_PCS_MON_LIVE_STSr_BLOCK_LOCKf_SET
#define PCS_MON_LIVE_STSr_PCS_STATUSf_GET BCMI_MADURA_PCS_MON_LIVE_STSr_PCS_STATUSf_GET
#define PCS_MON_LIVE_STSr_PCS_STATUSf_SET BCMI_MADURA_PCS_MON_LIVE_STSr_PCS_STATUSf_SET
#define READ_PCS_MON_LIVE_STSr BCMI_MADURA_READ_PCS_MON_LIVE_STSr
#define WRITE_PCS_MON_LIVE_STSr BCMI_MADURA_WRITE_PCS_MON_LIVE_STSr
#define MODIFY_PCS_MON_LIVE_STSr BCMI_MADURA_MODIFY_PCS_MON_LIVE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PCS_MON_LIVE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_MON_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb026
 * DEVAD:    1
 * DESC:     FC monitor main status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     COMMA_FAIL_LH    comma fail latch status
 *     WSYN_SYNC_LOSE_LH Word synchronization lost
 *     WSYN_SYNC_GAIN_LH Word synchronization achieved
 *     DEC_RD_ERR_LH    8b/10b decode running disparity error latch high status
 *     DEC_ERR_LH       8b/10b decode error latch high status
 *     WSYN_LINK_FAIL_LH Word Sync link failed latch high status
 *     SYNC_TEST_FAIL   Sync Test fail
 *     SYNC_TEST_END    Sync Test ended
 *     WSYN_FSM_LSTATE  Word Sync State Machine latched state
 */
#define BCMI_MADURA_FC_MON_STSr (0x0001b026 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_MON_STSr_SIZE 4

/*
 * This structure should be used to declare and program FC_MON_STS.
 */
typedef union BCMI_MADURA_FC_MON_STSr_s {
	uint32_t v[1];
	uint32_t fc_mon_sts[1];
	uint32_t _fc_mon_sts;
} BCMI_MADURA_FC_MON_STSr_t;

#define BCMI_MADURA_FC_MON_STSr_CLR(r) (r).fc_mon_sts[0] = 0
#define BCMI_MADURA_FC_MON_STSr_SET(r,d) (r).fc_mon_sts[0] = d
#define BCMI_MADURA_FC_MON_STSr_GET(r) (r).fc_mon_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_MON_STSr_WSYN_FSM_LSTATEf_GET(r) ((((r).fc_mon_sts[0]) >> 8) & 0xff)
#define BCMI_MADURA_FC_MON_STSr_WSYN_FSM_LSTATEf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_FC_MON_STSr_SYNC_TEST_ENDf_GET(r) ((((r).fc_mon_sts[0]) >> 7) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_SYNC_TEST_ENDf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_FC_MON_STSr_SYNC_TEST_FAILf_GET(r) ((((r).fc_mon_sts[0]) >> 6) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_SYNC_TEST_FAILf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_FC_MON_STSr_WSYN_LINK_FAIL_LHf_GET(r) ((((r).fc_mon_sts[0]) >> 5) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_WSYN_LINK_FAIL_LHf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_FC_MON_STSr_DEC_ERR_LHf_GET(r) ((((r).fc_mon_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_DEC_ERR_LHf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_FC_MON_STSr_DEC_RD_ERR_LHf_GET(r) ((((r).fc_mon_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_DEC_RD_ERR_LHf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_GAIN_LHf_GET(r) ((((r).fc_mon_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_GAIN_LHf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_LOSE_LHf_GET(r) ((((r).fc_mon_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_LOSE_LHf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FC_MON_STSr_COMMA_FAIL_LHf_GET(r) (((r).fc_mon_sts[0]) & 0x1)
#define BCMI_MADURA_FC_MON_STSr_COMMA_FAIL_LHf_SET(r,f) (r).fc_mon_sts[0]=(((r).fc_mon_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FC_MON_STS.
 */
#define BCMI_MADURA_READ_FC_MON_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_MON_STSr,_r._fc_mon_sts)
#define BCMI_MADURA_WRITE_FC_MON_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_MON_STSr,_r._fc_mon_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_STSr BCMI_MADURA_FC_MON_STSr
#define FC_MON_STSr_SIZE BCMI_MADURA_FC_MON_STSr_SIZE
typedef BCMI_MADURA_FC_MON_STSr_t FC_MON_STSr_t;
#define FC_MON_STSr_CLR BCMI_MADURA_FC_MON_STSr_CLR
#define FC_MON_STSr_SET BCMI_MADURA_FC_MON_STSr_SET
#define FC_MON_STSr_GET BCMI_MADURA_FC_MON_STSr_GET
#define FC_MON_STSr_WSYN_FSM_LSTATEf_GET BCMI_MADURA_FC_MON_STSr_WSYN_FSM_LSTATEf_GET
#define FC_MON_STSr_WSYN_FSM_LSTATEf_SET BCMI_MADURA_FC_MON_STSr_WSYN_FSM_LSTATEf_SET
#define FC_MON_STSr_SYNC_TEST_ENDf_GET BCMI_MADURA_FC_MON_STSr_SYNC_TEST_ENDf_GET
#define FC_MON_STSr_SYNC_TEST_ENDf_SET BCMI_MADURA_FC_MON_STSr_SYNC_TEST_ENDf_SET
#define FC_MON_STSr_SYNC_TEST_FAILf_GET BCMI_MADURA_FC_MON_STSr_SYNC_TEST_FAILf_GET
#define FC_MON_STSr_SYNC_TEST_FAILf_SET BCMI_MADURA_FC_MON_STSr_SYNC_TEST_FAILf_SET
#define FC_MON_STSr_WSYN_LINK_FAIL_LHf_GET BCMI_MADURA_FC_MON_STSr_WSYN_LINK_FAIL_LHf_GET
#define FC_MON_STSr_WSYN_LINK_FAIL_LHf_SET BCMI_MADURA_FC_MON_STSr_WSYN_LINK_FAIL_LHf_SET
#define FC_MON_STSr_DEC_ERR_LHf_GET BCMI_MADURA_FC_MON_STSr_DEC_ERR_LHf_GET
#define FC_MON_STSr_DEC_ERR_LHf_SET BCMI_MADURA_FC_MON_STSr_DEC_ERR_LHf_SET
#define FC_MON_STSr_DEC_RD_ERR_LHf_GET BCMI_MADURA_FC_MON_STSr_DEC_RD_ERR_LHf_GET
#define FC_MON_STSr_DEC_RD_ERR_LHf_SET BCMI_MADURA_FC_MON_STSr_DEC_RD_ERR_LHf_SET
#define FC_MON_STSr_WSYN_SYNC_GAIN_LHf_GET BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_GAIN_LHf_GET
#define FC_MON_STSr_WSYN_SYNC_GAIN_LHf_SET BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_GAIN_LHf_SET
#define FC_MON_STSr_WSYN_SYNC_LOSE_LHf_GET BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_LOSE_LHf_GET
#define FC_MON_STSr_WSYN_SYNC_LOSE_LHf_SET BCMI_MADURA_FC_MON_STSr_WSYN_SYNC_LOSE_LHf_SET
#define FC_MON_STSr_COMMA_FAIL_LHf_GET BCMI_MADURA_FC_MON_STSr_COMMA_FAIL_LHf_GET
#define FC_MON_STSr_COMMA_FAIL_LHf_SET BCMI_MADURA_FC_MON_STSr_COMMA_FAIL_LHf_SET
#define READ_FC_MON_STSr BCMI_MADURA_READ_FC_MON_STSr
#define WRITE_FC_MON_STSr BCMI_MADURA_WRITE_FC_MON_STSr
#define MODIFY_FC_MON_STSr BCMI_MADURA_MODIFY_FC_MON_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_MON_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FC_MON_LIVE_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb027
 * DEVAD:    1
 * DESC:     FC monitor live status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     WSYN_LOSS_SYNC   Word synchronization lost
 *     DEC_RD_ERR       8b/10b decode running disparity error
 *     DEC_ERR          8b/10b decode error
 *     WSYN_LINK_FAIL   Word Sync link failed
 *     WSYN_STATE       Word Sync State
 */
#define BCMI_MADURA_FC_MON_LIVE_STSr (0x0001b027 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FC_MON_LIVE_STSr_SIZE 4

/*
 * This structure should be used to declare and program FC_MON_LIVE_STS.
 */
typedef union BCMI_MADURA_FC_MON_LIVE_STSr_s {
	uint32_t v[1];
	uint32_t fc_mon_live_sts[1];
	uint32_t _fc_mon_live_sts;
} BCMI_MADURA_FC_MON_LIVE_STSr_t;

#define BCMI_MADURA_FC_MON_LIVE_STSr_CLR(r) (r).fc_mon_live_sts[0] = 0
#define BCMI_MADURA_FC_MON_LIVE_STSr_SET(r,d) (r).fc_mon_live_sts[0] = d
#define BCMI_MADURA_FC_MON_LIVE_STSr_GET(r) (r).fc_mon_live_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_STATEf_GET(r) ((((r).fc_mon_live_sts[0]) >> 4) & 0x7)
#define BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_STATEf_SET(r,f) (r).fc_mon_live_sts[0]=(((r).fc_mon_live_sts[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LINK_FAILf_GET(r) ((((r).fc_mon_live_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LINK_FAILf_SET(r,f) (r).fc_mon_live_sts[0]=(((r).fc_mon_live_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_FC_MON_LIVE_STSr_DEC_ERRf_GET(r) ((((r).fc_mon_live_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_FC_MON_LIVE_STSr_DEC_ERRf_SET(r,f) (r).fc_mon_live_sts[0]=(((r).fc_mon_live_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FC_MON_LIVE_STSr_DEC_RD_ERRf_GET(r) ((((r).fc_mon_live_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_FC_MON_LIVE_STSr_DEC_RD_ERRf_SET(r,f) (r).fc_mon_live_sts[0]=(((r).fc_mon_live_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LOSS_SYNCf_GET(r) (((r).fc_mon_live_sts[0]) & 0x1)
#define BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LOSS_SYNCf_SET(r,f) (r).fc_mon_live_sts[0]=(((r).fc_mon_live_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FC_MON_LIVE_STS.
 */
#define BCMI_MADURA_READ_FC_MON_LIVE_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FC_MON_LIVE_STSr,_r._fc_mon_live_sts)
#define BCMI_MADURA_WRITE_FC_MON_LIVE_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FC_MON_LIVE_STSr,_r._fc_mon_live_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FC_MON_LIVE_STSr BCMI_MADURA_FC_MON_LIVE_STSr
#define FC_MON_LIVE_STSr_SIZE BCMI_MADURA_FC_MON_LIVE_STSr_SIZE
typedef BCMI_MADURA_FC_MON_LIVE_STSr_t FC_MON_LIVE_STSr_t;
#define FC_MON_LIVE_STSr_CLR BCMI_MADURA_FC_MON_LIVE_STSr_CLR
#define FC_MON_LIVE_STSr_SET BCMI_MADURA_FC_MON_LIVE_STSr_SET
#define FC_MON_LIVE_STSr_GET BCMI_MADURA_FC_MON_LIVE_STSr_GET
#define FC_MON_LIVE_STSr_WSYN_STATEf_GET BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_STATEf_GET
#define FC_MON_LIVE_STSr_WSYN_STATEf_SET BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_STATEf_SET
#define FC_MON_LIVE_STSr_WSYN_LINK_FAILf_GET BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LINK_FAILf_GET
#define FC_MON_LIVE_STSr_WSYN_LINK_FAILf_SET BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LINK_FAILf_SET
#define FC_MON_LIVE_STSr_DEC_ERRf_GET BCMI_MADURA_FC_MON_LIVE_STSr_DEC_ERRf_GET
#define FC_MON_LIVE_STSr_DEC_ERRf_SET BCMI_MADURA_FC_MON_LIVE_STSr_DEC_ERRf_SET
#define FC_MON_LIVE_STSr_DEC_RD_ERRf_GET BCMI_MADURA_FC_MON_LIVE_STSr_DEC_RD_ERRf_GET
#define FC_MON_LIVE_STSr_DEC_RD_ERRf_SET BCMI_MADURA_FC_MON_LIVE_STSr_DEC_RD_ERRf_SET
#define FC_MON_LIVE_STSr_WSYN_LOSS_SYNCf_GET BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LOSS_SYNCf_GET
#define FC_MON_LIVE_STSr_WSYN_LOSS_SYNCf_SET BCMI_MADURA_FC_MON_LIVE_STSr_WSYN_LOSS_SYNCf_SET
#define READ_FC_MON_LIVE_STSr BCMI_MADURA_READ_FC_MON_LIVE_STSr
#define WRITE_FC_MON_LIVE_STSr BCMI_MADURA_WRITE_FC_MON_LIVE_STSr
#define MODIFY_FC_MON_LIVE_STSr BCMI_MADURA_MODIFY_FC_MON_LIVE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FC_MON_LIVE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_CHK_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb028
 * DEVAD:    1
 * DESC:     SSPR checker main status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_MNTR_DONE    SSPR monitor BER calculation has completed
 *     WAITING_FOR_LOCK SSPR monitor is hunting for a pattern
 *     SSPR_LOCK_LL     SSPR pattern locked, latch low status
 *     SSPR_LOCK        SSPR pattern locked, live status
 */
#define BCMI_MADURA_SSPR_CHK_STSr (0x0001b028 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_CHK_STSr_SIZE 4

/*
 * This structure should be used to declare and program SSPR_CHK_STS.
 */
typedef union BCMI_MADURA_SSPR_CHK_STSr_s {
	uint32_t v[1];
	uint32_t sspr_chk_sts[1];
	uint32_t _sspr_chk_sts;
} BCMI_MADURA_SSPR_CHK_STSr_t;

#define BCMI_MADURA_SSPR_CHK_STSr_CLR(r) (r).sspr_chk_sts[0] = 0
#define BCMI_MADURA_SSPR_CHK_STSr_SET(r,d) (r).sspr_chk_sts[0] = d
#define BCMI_MADURA_SSPR_CHK_STSr_GET(r) (r).sspr_chk_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCKf_GET(r) ((((r).sspr_chk_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCKf_SET(r,f) (r).sspr_chk_sts[0]=(((r).sspr_chk_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCK_LLf_GET(r) ((((r).sspr_chk_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCK_LLf_SET(r,f) (r).sspr_chk_sts[0]=(((r).sspr_chk_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_SSPR_CHK_STSr_WAITING_FOR_LOCKf_GET(r) ((((r).sspr_chk_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_SSPR_CHK_STSr_WAITING_FOR_LOCKf_SET(r,f) (r).sspr_chk_sts[0]=(((r).sspr_chk_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SSPR_CHK_STSr_BER_MNTR_DONEf_GET(r) (((r).sspr_chk_sts[0]) & 0x1)
#define BCMI_MADURA_SSPR_CHK_STSr_BER_MNTR_DONEf_SET(r,f) (r).sspr_chk_sts[0]=(((r).sspr_chk_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SSPR_CHK_STS.
 */
#define BCMI_MADURA_READ_SSPR_CHK_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_CHK_STSr,_r._sspr_chk_sts)
#define BCMI_MADURA_WRITE_SSPR_CHK_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_CHK_STSr,_r._sspr_chk_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_CHK_STSr BCMI_MADURA_SSPR_CHK_STSr
#define SSPR_CHK_STSr_SIZE BCMI_MADURA_SSPR_CHK_STSr_SIZE
typedef BCMI_MADURA_SSPR_CHK_STSr_t SSPR_CHK_STSr_t;
#define SSPR_CHK_STSr_CLR BCMI_MADURA_SSPR_CHK_STSr_CLR
#define SSPR_CHK_STSr_SET BCMI_MADURA_SSPR_CHK_STSr_SET
#define SSPR_CHK_STSr_GET BCMI_MADURA_SSPR_CHK_STSr_GET
#define SSPR_CHK_STSr_SSPR_LOCKf_GET BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCKf_GET
#define SSPR_CHK_STSr_SSPR_LOCKf_SET BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCKf_SET
#define SSPR_CHK_STSr_SSPR_LOCK_LLf_GET BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCK_LLf_GET
#define SSPR_CHK_STSr_SSPR_LOCK_LLf_SET BCMI_MADURA_SSPR_CHK_STSr_SSPR_LOCK_LLf_SET
#define SSPR_CHK_STSr_WAITING_FOR_LOCKf_GET BCMI_MADURA_SSPR_CHK_STSr_WAITING_FOR_LOCKf_GET
#define SSPR_CHK_STSr_WAITING_FOR_LOCKf_SET BCMI_MADURA_SSPR_CHK_STSr_WAITING_FOR_LOCKf_SET
#define SSPR_CHK_STSr_BER_MNTR_DONEf_GET BCMI_MADURA_SSPR_CHK_STSr_BER_MNTR_DONEf_GET
#define SSPR_CHK_STSr_BER_MNTR_DONEf_SET BCMI_MADURA_SSPR_CHK_STSr_BER_MNTR_DONEf_SET
#define READ_SSPR_CHK_STSr BCMI_MADURA_READ_SSPR_CHK_STSr
#define WRITE_SSPR_CHK_STSr BCMI_MADURA_WRITE_SSPR_CHK_STSr
#define MODIFY_SSPR_CHK_STSr BCMI_MADURA_MODIFY_SSPR_CHK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_CHK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_ERR_CNT_LSB
 * BLOCKS:   LANE
 * REGADDR:  0xb029
 * DEVAD:    1
 * DESC:     SSPR checker BER count, bit [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_CNT_LSB      SSPR monitor BER count, bit [15:0]
 */
#define BCMI_MADURA_SSPR_ERR_CNT_LSBr (0x0001b029 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_ERR_CNT_LSBr_SIZE 4

/*
 * This structure should be used to declare and program SSPR_ERR_CNT_LSB.
 */
typedef union BCMI_MADURA_SSPR_ERR_CNT_LSBr_s {
	uint32_t v[1];
	uint32_t sspr_err_cnt_lsb[1];
	uint32_t _sspr_err_cnt_lsb;
} BCMI_MADURA_SSPR_ERR_CNT_LSBr_t;

#define BCMI_MADURA_SSPR_ERR_CNT_LSBr_CLR(r) (r).sspr_err_cnt_lsb[0] = 0
#define BCMI_MADURA_SSPR_ERR_CNT_LSBr_SET(r,d) (r).sspr_err_cnt_lsb[0] = d
#define BCMI_MADURA_SSPR_ERR_CNT_LSBr_GET(r) (r).sspr_err_cnt_lsb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_ERR_CNT_LSBr_ERR_CNT_LSBf_GET(r) (((r).sspr_err_cnt_lsb[0]) & 0xffff)
#define BCMI_MADURA_SSPR_ERR_CNT_LSBr_ERR_CNT_LSBf_SET(r,f) (r).sspr_err_cnt_lsb[0]=(((r).sspr_err_cnt_lsb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SSPR_ERR_CNT_LSB.
 */
#define BCMI_MADURA_READ_SSPR_ERR_CNT_LSBr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_ERR_CNT_LSBr,_r._sspr_err_cnt_lsb)
#define BCMI_MADURA_WRITE_SSPR_ERR_CNT_LSBr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_ERR_CNT_LSBr,_r._sspr_err_cnt_lsb)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_ERR_CNT_LSBr BCMI_MADURA_SSPR_ERR_CNT_LSBr
#define SSPR_ERR_CNT_LSBr_SIZE BCMI_MADURA_SSPR_ERR_CNT_LSBr_SIZE
typedef BCMI_MADURA_SSPR_ERR_CNT_LSBr_t SSPR_ERR_CNT_LSBr_t;
#define SSPR_ERR_CNT_LSBr_CLR BCMI_MADURA_SSPR_ERR_CNT_LSBr_CLR
#define SSPR_ERR_CNT_LSBr_SET BCMI_MADURA_SSPR_ERR_CNT_LSBr_SET
#define SSPR_ERR_CNT_LSBr_GET BCMI_MADURA_SSPR_ERR_CNT_LSBr_GET
#define SSPR_ERR_CNT_LSBr_ERR_CNT_LSBf_GET BCMI_MADURA_SSPR_ERR_CNT_LSBr_ERR_CNT_LSBf_GET
#define SSPR_ERR_CNT_LSBr_ERR_CNT_LSBf_SET BCMI_MADURA_SSPR_ERR_CNT_LSBr_ERR_CNT_LSBf_SET
#define READ_SSPR_ERR_CNT_LSBr BCMI_MADURA_READ_SSPR_ERR_CNT_LSBr
#define WRITE_SSPR_ERR_CNT_LSBr BCMI_MADURA_WRITE_SSPR_ERR_CNT_LSBr
#define MODIFY_SSPR_ERR_CNT_LSBr BCMI_MADURA_MODIFY_SSPR_ERR_CNT_LSBr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_ERR_CNT_LSBr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SSPR_ERR_CNT_MSB
 * BLOCKS:   LANE
 * REGADDR:  0xb02a
 * DEVAD:    1
 * DESC:     SSPR checker BER count, bit [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_CNT_MSB      SSPR monitor BER count, bit [31:16]
 */
#define BCMI_MADURA_SSPR_ERR_CNT_MSBr (0x0001b02a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SSPR_ERR_CNT_MSBr_SIZE 4

/*
 * This structure should be used to declare and program SSPR_ERR_CNT_MSB.
 */
typedef union BCMI_MADURA_SSPR_ERR_CNT_MSBr_s {
	uint32_t v[1];
	uint32_t sspr_err_cnt_msb[1];
	uint32_t _sspr_err_cnt_msb;
} BCMI_MADURA_SSPR_ERR_CNT_MSBr_t;

#define BCMI_MADURA_SSPR_ERR_CNT_MSBr_CLR(r) (r).sspr_err_cnt_msb[0] = 0
#define BCMI_MADURA_SSPR_ERR_CNT_MSBr_SET(r,d) (r).sspr_err_cnt_msb[0] = d
#define BCMI_MADURA_SSPR_ERR_CNT_MSBr_GET(r) (r).sspr_err_cnt_msb[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SSPR_ERR_CNT_MSBr_ERR_CNT_MSBf_GET(r) (((r).sspr_err_cnt_msb[0]) & 0xffff)
#define BCMI_MADURA_SSPR_ERR_CNT_MSBr_ERR_CNT_MSBf_SET(r,f) (r).sspr_err_cnt_msb[0]=(((r).sspr_err_cnt_msb[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SSPR_ERR_CNT_MSB.
 */
#define BCMI_MADURA_READ_SSPR_ERR_CNT_MSBr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SSPR_ERR_CNT_MSBr,_r._sspr_err_cnt_msb)
#define BCMI_MADURA_WRITE_SSPR_ERR_CNT_MSBr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SSPR_ERR_CNT_MSBr,_r._sspr_err_cnt_msb)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SSPR_ERR_CNT_MSBr BCMI_MADURA_SSPR_ERR_CNT_MSBr
#define SSPR_ERR_CNT_MSBr_SIZE BCMI_MADURA_SSPR_ERR_CNT_MSBr_SIZE
typedef BCMI_MADURA_SSPR_ERR_CNT_MSBr_t SSPR_ERR_CNT_MSBr_t;
#define SSPR_ERR_CNT_MSBr_CLR BCMI_MADURA_SSPR_ERR_CNT_MSBr_CLR
#define SSPR_ERR_CNT_MSBr_SET BCMI_MADURA_SSPR_ERR_CNT_MSBr_SET
#define SSPR_ERR_CNT_MSBr_GET BCMI_MADURA_SSPR_ERR_CNT_MSBr_GET
#define SSPR_ERR_CNT_MSBr_ERR_CNT_MSBf_GET BCMI_MADURA_SSPR_ERR_CNT_MSBr_ERR_CNT_MSBf_GET
#define SSPR_ERR_CNT_MSBr_ERR_CNT_MSBf_SET BCMI_MADURA_SSPR_ERR_CNT_MSBr_ERR_CNT_MSBf_SET
#define READ_SSPR_ERR_CNT_MSBr BCMI_MADURA_READ_SSPR_ERR_CNT_MSBr
#define WRITE_SSPR_ERR_CNT_MSBr BCMI_MADURA_WRITE_SSPR_ERR_CNT_MSBr
#define MODIFY_SSPR_ERR_CNT_MSBr BCMI_MADURA_MODIFY_SSPR_ERR_CNT_MSBr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SSPR_ERR_CNT_MSBr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PRBS_CTL
 * BLOCKS:   LANE
 * REGADDR:  0xb02b
 * DEVAD:    1
 * DESC:     PRBS9 checker control on a lane carrying bit-interleaved traffic from 2 polynomials
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_UNLOCK_DIS  Forces the lock to remain ON.
 *     PRBS_INV_IN      Enables prbs checking on polarity-inverted polynomial
 *     PRBS_CHK_EN      Enables PRBS9 checking on odd and even bit-interleaved lanes simultanously
 *     PRBS_AUTODET_DIS Disable autodetection of PRBS - only for debug
 */
#define BCMI_MADURA_PRBS_CTLr (0x0001b02b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PRBS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PRBS_CTL.
 */
typedef union BCMI_MADURA_PRBS_CTLr_s {
	uint32_t v[1];
	uint32_t prbs_ctl[1];
	uint32_t _prbs_ctl;
} BCMI_MADURA_PRBS_CTLr_t;

#define BCMI_MADURA_PRBS_CTLr_CLR(r) (r).prbs_ctl[0] = 0
#define BCMI_MADURA_PRBS_CTLr_SET(r,d) (r).prbs_ctl[0] = d
#define BCMI_MADURA_PRBS_CTLr_GET(r) (r).prbs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PRBS_CTLr_PRBS_AUTODET_DISf_GET(r) ((((r).prbs_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_PRBS_CTLr_PRBS_AUTODET_DISf_SET(r,f) (r).prbs_ctl[0]=(((r).prbs_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PRBS_CTLr_PRBS_CHK_ENf_GET(r) ((((r).prbs_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_PRBS_CTLr_PRBS_CHK_ENf_SET(r,f) (r).prbs_ctl[0]=(((r).prbs_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PRBS_CTLr_PRBS_INV_INf_GET(r) ((((r).prbs_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_PRBS_CTLr_PRBS_INV_INf_SET(r,f) (r).prbs_ctl[0]=(((r).prbs_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PRBS_CTLr_PRBS_UNLOCK_DISf_GET(r) (((r).prbs_ctl[0]) & 0x1)
#define BCMI_MADURA_PRBS_CTLr_PRBS_UNLOCK_DISf_SET(r,f) (r).prbs_ctl[0]=(((r).prbs_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PRBS_CTL.
 */
#define BCMI_MADURA_READ_PRBS_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PRBS_CTLr,_r._prbs_ctl)
#define BCMI_MADURA_WRITE_PRBS_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PRBS_CTLr,_r._prbs_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PRBS_CTLr BCMI_MADURA_PRBS_CTLr
#define PRBS_CTLr_SIZE BCMI_MADURA_PRBS_CTLr_SIZE
typedef BCMI_MADURA_PRBS_CTLr_t PRBS_CTLr_t;
#define PRBS_CTLr_CLR BCMI_MADURA_PRBS_CTLr_CLR
#define PRBS_CTLr_SET BCMI_MADURA_PRBS_CTLr_SET
#define PRBS_CTLr_GET BCMI_MADURA_PRBS_CTLr_GET
#define PRBS_CTLr_PRBS_AUTODET_DISf_GET BCMI_MADURA_PRBS_CTLr_PRBS_AUTODET_DISf_GET
#define PRBS_CTLr_PRBS_AUTODET_DISf_SET BCMI_MADURA_PRBS_CTLr_PRBS_AUTODET_DISf_SET
#define PRBS_CTLr_PRBS_CHK_ENf_GET BCMI_MADURA_PRBS_CTLr_PRBS_CHK_ENf_GET
#define PRBS_CTLr_PRBS_CHK_ENf_SET BCMI_MADURA_PRBS_CTLr_PRBS_CHK_ENf_SET
#define PRBS_CTLr_PRBS_INV_INf_GET BCMI_MADURA_PRBS_CTLr_PRBS_INV_INf_GET
#define PRBS_CTLr_PRBS_INV_INf_SET BCMI_MADURA_PRBS_CTLr_PRBS_INV_INf_SET
#define PRBS_CTLr_PRBS_UNLOCK_DISf_GET BCMI_MADURA_PRBS_CTLr_PRBS_UNLOCK_DISf_GET
#define PRBS_CTLr_PRBS_UNLOCK_DISf_SET BCMI_MADURA_PRBS_CTLr_PRBS_UNLOCK_DISf_SET
#define READ_PRBS_CTLr BCMI_MADURA_READ_PRBS_CTLr
#define WRITE_PRBS_CTLr BCMI_MADURA_WRITE_PRBS_CTLr
#define MODIFY_PRBS_CTLr BCMI_MADURA_MODIFY_PRBS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PRBS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PRBS_STS
 * BLOCKS:   LANE
 * REGADDR:  0xb02c
 * DEVAD:    1
 * DESC:     PRBS9 checker status on a lane carrying bit-interleaved traffic from 2 polynomials
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EVEN_PRBS_LOCK_LL Latch-low status of even lane PRBS lock
 *     EVEN_PRBS_ERR_LH Latch-high status of even lane PRBS error.
 *     ODD_PRBS_LOCK_LL Latch-low status of odd lane PRBS lock
 *     ODD_PRBS_ERR_LH  Latch-high status of odd lane PRBS error.
 */
#define BCMI_MADURA_PRBS_STSr (0x0001b02c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PRBS_STSr_SIZE 4

/*
 * This structure should be used to declare and program PRBS_STS.
 */
typedef union BCMI_MADURA_PRBS_STSr_s {
	uint32_t v[1];
	uint32_t prbs_sts[1];
	uint32_t _prbs_sts;
} BCMI_MADURA_PRBS_STSr_t;

#define BCMI_MADURA_PRBS_STSr_CLR(r) (r).prbs_sts[0] = 0
#define BCMI_MADURA_PRBS_STSr_SET(r,d) (r).prbs_sts[0] = d
#define BCMI_MADURA_PRBS_STSr_GET(r) (r).prbs_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PRBS_STSr_ODD_PRBS_ERR_LHf_GET(r) ((((r).prbs_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_PRBS_STSr_ODD_PRBS_ERR_LHf_SET(r,f) (r).prbs_sts[0]=(((r).prbs_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PRBS_STSr_ODD_PRBS_LOCK_LLf_GET(r) ((((r).prbs_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_PRBS_STSr_ODD_PRBS_LOCK_LLf_SET(r,f) (r).prbs_sts[0]=(((r).prbs_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PRBS_STSr_EVEN_PRBS_ERR_LHf_GET(r) ((((r).prbs_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_PRBS_STSr_EVEN_PRBS_ERR_LHf_SET(r,f) (r).prbs_sts[0]=(((r).prbs_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PRBS_STSr_EVEN_PRBS_LOCK_LLf_GET(r) (((r).prbs_sts[0]) & 0x1)
#define BCMI_MADURA_PRBS_STSr_EVEN_PRBS_LOCK_LLf_SET(r,f) (r).prbs_sts[0]=(((r).prbs_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PRBS_STS.
 */
#define BCMI_MADURA_READ_PRBS_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PRBS_STSr,_r._prbs_sts)
#define BCMI_MADURA_WRITE_PRBS_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PRBS_STSr,_r._prbs_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PRBS_STSr BCMI_MADURA_PRBS_STSr
#define PRBS_STSr_SIZE BCMI_MADURA_PRBS_STSr_SIZE
typedef BCMI_MADURA_PRBS_STSr_t PRBS_STSr_t;
#define PRBS_STSr_CLR BCMI_MADURA_PRBS_STSr_CLR
#define PRBS_STSr_SET BCMI_MADURA_PRBS_STSr_SET
#define PRBS_STSr_GET BCMI_MADURA_PRBS_STSr_GET
#define PRBS_STSr_ODD_PRBS_ERR_LHf_GET BCMI_MADURA_PRBS_STSr_ODD_PRBS_ERR_LHf_GET
#define PRBS_STSr_ODD_PRBS_ERR_LHf_SET BCMI_MADURA_PRBS_STSr_ODD_PRBS_ERR_LHf_SET
#define PRBS_STSr_ODD_PRBS_LOCK_LLf_GET BCMI_MADURA_PRBS_STSr_ODD_PRBS_LOCK_LLf_GET
#define PRBS_STSr_ODD_PRBS_LOCK_LLf_SET BCMI_MADURA_PRBS_STSr_ODD_PRBS_LOCK_LLf_SET
#define PRBS_STSr_EVEN_PRBS_ERR_LHf_GET BCMI_MADURA_PRBS_STSr_EVEN_PRBS_ERR_LHf_GET
#define PRBS_STSr_EVEN_PRBS_ERR_LHf_SET BCMI_MADURA_PRBS_STSr_EVEN_PRBS_ERR_LHf_SET
#define PRBS_STSr_EVEN_PRBS_LOCK_LLf_GET BCMI_MADURA_PRBS_STSr_EVEN_PRBS_LOCK_LLf_GET
#define PRBS_STSr_EVEN_PRBS_LOCK_LLf_SET BCMI_MADURA_PRBS_STSr_EVEN_PRBS_LOCK_LLf_SET
#define READ_PRBS_STSr BCMI_MADURA_READ_PRBS_STSr
#define WRITE_PRBS_STSr BCMI_MADURA_WRITE_PRBS_STSr
#define MODIFY_PRBS_STSr BCMI_MADURA_MODIFY_PRBS_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PRBS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL1
 * BLOCKS:   PD
 * REGADDR:  0xb101
 * DEVAD:    1
 * DESC:     control register-1  for half rate
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CNTL_FRC_1       PD module force control signals,bit-0, force the enable or disable the PD,bit-1, force the bypass of the update filter, PD will converge faster once you bypass,bit-2, force the swapping of the phase increment and decrement functionality,
 *     CNTL_FRC_VAL_1   PD module force val signals,bit-0, enable or disable the PD,bit-1, bypass the update filter, PD will converge faster once you bypass,bit-2, swap the phase increment and decrement functionality,
 */
#define BCMI_MADURA_ICTL1r (0x0001b101 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL1r_SIZE 4

/*
 * This structure should be used to declare and program ICTL1.
 */
typedef union BCMI_MADURA_ICTL1r_s {
	uint32_t v[1];
	uint32_t ictl1[1];
	uint32_t _ictl1;
} BCMI_MADURA_ICTL1r_t;

#define BCMI_MADURA_ICTL1r_CLR(r) (r).ictl1[0] = 0
#define BCMI_MADURA_ICTL1r_SET(r,d) (r).ictl1[0] = d
#define BCMI_MADURA_ICTL1r_GET(r) (r).ictl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL1r_CNTL_FRC_VAL_1f_GET(r) ((((r).ictl1[0]) >> 4) & 0x7)
#define BCMI_MADURA_ICTL1r_CNTL_FRC_VAL_1f_SET(r,f) (r).ictl1[0]=(((r).ictl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_ICTL1r_CNTL_FRC_1f_GET(r) (((r).ictl1[0]) & 0x7)
#define BCMI_MADURA_ICTL1r_CNTL_FRC_1f_SET(r,f) (r).ictl1[0]=(((r).ictl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access ICTL1.
 */
#define BCMI_MADURA_READ_ICTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL1r,_r._ictl1)
#define BCMI_MADURA_WRITE_ICTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL1r,_r._ictl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL1r BCMI_MADURA_ICTL1r
#define ICTL1r_SIZE BCMI_MADURA_ICTL1r_SIZE
typedef BCMI_MADURA_ICTL1r_t ICTL1r_t;
#define ICTL1r_CLR BCMI_MADURA_ICTL1r_CLR
#define ICTL1r_SET BCMI_MADURA_ICTL1r_SET
#define ICTL1r_GET BCMI_MADURA_ICTL1r_GET
#define ICTL1r_CNTL_FRC_VAL_1f_GET BCMI_MADURA_ICTL1r_CNTL_FRC_VAL_1f_GET
#define ICTL1r_CNTL_FRC_VAL_1f_SET BCMI_MADURA_ICTL1r_CNTL_FRC_VAL_1f_SET
#define ICTL1r_CNTL_FRC_1f_GET BCMI_MADURA_ICTL1r_CNTL_FRC_1f_GET
#define ICTL1r_CNTL_FRC_1f_SET BCMI_MADURA_ICTL1r_CNTL_FRC_1f_SET
#define READ_ICTL1r BCMI_MADURA_READ_ICTL1r
#define WRITE_ICTL1r BCMI_MADURA_WRITE_ICTL1r
#define MODIFY_ICTL1r BCMI_MADURA_MODIFY_ICTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL2
 * BLOCKS:   PD
 * REGADDR:  0xb102
 * DEVAD:    1
 * DESC:     control register-2 for half rate
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CNTL_FRC_2       PD module force control signals,bit-0, force the enable or disable the PD,bit-1, force the bypass of the update filter, PD will converge faster once you bypass,bit-2, force the swapping of the phase increment and decrement functionality,
 *     CNTL_FRC_VAL_2   PD module force val signals,bit-0, enable or disable the PD,bit-1, bypass the update filter, PD will converge faster once you bypass,bit-2, swap the phase increment and decrement functionality,
 */
#define BCMI_MADURA_ICTL2r (0x0001b102 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL2r_SIZE 4

/*
 * This structure should be used to declare and program ICTL2.
 */
typedef union BCMI_MADURA_ICTL2r_s {
	uint32_t v[1];
	uint32_t ictl2[1];
	uint32_t _ictl2;
} BCMI_MADURA_ICTL2r_t;

#define BCMI_MADURA_ICTL2r_CLR(r) (r).ictl2[0] = 0
#define BCMI_MADURA_ICTL2r_SET(r,d) (r).ictl2[0] = d
#define BCMI_MADURA_ICTL2r_GET(r) (r).ictl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL2r_CNTL_FRC_VAL_2f_GET(r) ((((r).ictl2[0]) >> 4) & 0x7)
#define BCMI_MADURA_ICTL2r_CNTL_FRC_VAL_2f_SET(r,f) (r).ictl2[0]=(((r).ictl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_ICTL2r_CNTL_FRC_2f_GET(r) (((r).ictl2[0]) & 0x7)
#define BCMI_MADURA_ICTL2r_CNTL_FRC_2f_SET(r,f) (r).ictl2[0]=(((r).ictl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access ICTL2.
 */
#define BCMI_MADURA_READ_ICTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL2r,_r._ictl2)
#define BCMI_MADURA_WRITE_ICTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL2r,_r._ictl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL2r BCMI_MADURA_ICTL2r
#define ICTL2r_SIZE BCMI_MADURA_ICTL2r_SIZE
typedef BCMI_MADURA_ICTL2r_t ICTL2r_t;
#define ICTL2r_CLR BCMI_MADURA_ICTL2r_CLR
#define ICTL2r_SET BCMI_MADURA_ICTL2r_SET
#define ICTL2r_GET BCMI_MADURA_ICTL2r_GET
#define ICTL2r_CNTL_FRC_VAL_2f_GET BCMI_MADURA_ICTL2r_CNTL_FRC_VAL_2f_GET
#define ICTL2r_CNTL_FRC_VAL_2f_SET BCMI_MADURA_ICTL2r_CNTL_FRC_VAL_2f_SET
#define ICTL2r_CNTL_FRC_2f_GET BCMI_MADURA_ICTL2r_CNTL_FRC_2f_GET
#define ICTL2r_CNTL_FRC_2f_SET BCMI_MADURA_ICTL2r_CNTL_FRC_2f_SET
#define READ_ICTL2r BCMI_MADURA_READ_ICTL2r
#define WRITE_ICTL2r BCMI_MADURA_WRITE_ICTL2r
#define MODIFY_ICTL2r BCMI_MADURA_MODIFY_ICTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL3
 * BLOCKS:   PD
 * REGADDR:  0xb103
 * DEVAD:    1
 * DESC:     control register-3  for half rate
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CNTL_FRC_3       PD module force control signals,bit-0, force the enable or disable the PD,bit-1, force the bypass of the update filter, PD will converge faster once you bypass,bit-2, force the swapping of the phase increment and decrement functionality,
 *     CNTL_FRC_VAL_3   PD module force val signals,bit-0, enable or disable the PD,bit-1, bypass the update filter, PD will converge faster once you bypass,bit-2, swap the phase increment and decrement functionality,
 */
#define BCMI_MADURA_ICTL3r (0x0001b103 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL3r_SIZE 4

/*
 * This structure should be used to declare and program ICTL3.
 */
typedef union BCMI_MADURA_ICTL3r_s {
	uint32_t v[1];
	uint32_t ictl3[1];
	uint32_t _ictl3;
} BCMI_MADURA_ICTL3r_t;

#define BCMI_MADURA_ICTL3r_CLR(r) (r).ictl3[0] = 0
#define BCMI_MADURA_ICTL3r_SET(r,d) (r).ictl3[0] = d
#define BCMI_MADURA_ICTL3r_GET(r) (r).ictl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL3r_CNTL_FRC_VAL_3f_GET(r) ((((r).ictl3[0]) >> 4) & 0x7)
#define BCMI_MADURA_ICTL3r_CNTL_FRC_VAL_3f_SET(r,f) (r).ictl3[0]=(((r).ictl3[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_ICTL3r_CNTL_FRC_3f_GET(r) (((r).ictl3[0]) & 0x7)
#define BCMI_MADURA_ICTL3r_CNTL_FRC_3f_SET(r,f) (r).ictl3[0]=(((r).ictl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access ICTL3.
 */
#define BCMI_MADURA_READ_ICTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL3r,_r._ictl3)
#define BCMI_MADURA_WRITE_ICTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL3r,_r._ictl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL3r BCMI_MADURA_ICTL3r
#define ICTL3r_SIZE BCMI_MADURA_ICTL3r_SIZE
typedef BCMI_MADURA_ICTL3r_t ICTL3r_t;
#define ICTL3r_CLR BCMI_MADURA_ICTL3r_CLR
#define ICTL3r_SET BCMI_MADURA_ICTL3r_SET
#define ICTL3r_GET BCMI_MADURA_ICTL3r_GET
#define ICTL3r_CNTL_FRC_VAL_3f_GET BCMI_MADURA_ICTL3r_CNTL_FRC_VAL_3f_GET
#define ICTL3r_CNTL_FRC_VAL_3f_SET BCMI_MADURA_ICTL3r_CNTL_FRC_VAL_3f_SET
#define ICTL3r_CNTL_FRC_3f_GET BCMI_MADURA_ICTL3r_CNTL_FRC_3f_GET
#define ICTL3r_CNTL_FRC_3f_SET BCMI_MADURA_ICTL3r_CNTL_FRC_3f_SET
#define READ_ICTL3r BCMI_MADURA_READ_ICTL3r
#define WRITE_ICTL3r BCMI_MADURA_WRITE_ICTL3r
#define MODIFY_ICTL3r BCMI_MADURA_MODIFY_ICTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL4
 * BLOCKS:   PD
 * REGADDR:  0xb104
 * DEVAD:    1
 * DESC:     control register-4  for half rate
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CNTL_FRC_4       PD module force control signals,bit-0, force the enable or disable the PD,bit-1, force the bypass of the update filter, PD will converge faster once you bypass,bit-2, force the swapping of the phase increment and decrement functionality,
 *     CNTL_FRC_VAL_4   PD module force val signals,bit-0, enable or disable the PD,bit-1, bypass the update filter, PD will converge faster once you bypass,bit-2, swap the phase increment and decrement functionality,
 */
#define BCMI_MADURA_ICTL4r (0x0001b104 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL4r_SIZE 4

/*
 * This structure should be used to declare and program ICTL4.
 */
typedef union BCMI_MADURA_ICTL4r_s {
	uint32_t v[1];
	uint32_t ictl4[1];
	uint32_t _ictl4;
} BCMI_MADURA_ICTL4r_t;

#define BCMI_MADURA_ICTL4r_CLR(r) (r).ictl4[0] = 0
#define BCMI_MADURA_ICTL4r_SET(r,d) (r).ictl4[0] = d
#define BCMI_MADURA_ICTL4r_GET(r) (r).ictl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL4r_CNTL_FRC_VAL_4f_GET(r) ((((r).ictl4[0]) >> 4) & 0x7)
#define BCMI_MADURA_ICTL4r_CNTL_FRC_VAL_4f_SET(r,f) (r).ictl4[0]=(((r).ictl4[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_ICTL4r_CNTL_FRC_4f_GET(r) (((r).ictl4[0]) & 0x7)
#define BCMI_MADURA_ICTL4r_CNTL_FRC_4f_SET(r,f) (r).ictl4[0]=(((r).ictl4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access ICTL4.
 */
#define BCMI_MADURA_READ_ICTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL4r,_r._ictl4)
#define BCMI_MADURA_WRITE_ICTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL4r,_r._ictl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL4r BCMI_MADURA_ICTL4r
#define ICTL4r_SIZE BCMI_MADURA_ICTL4r_SIZE
typedef BCMI_MADURA_ICTL4r_t ICTL4r_t;
#define ICTL4r_CLR BCMI_MADURA_ICTL4r_CLR
#define ICTL4r_SET BCMI_MADURA_ICTL4r_SET
#define ICTL4r_GET BCMI_MADURA_ICTL4r_GET
#define ICTL4r_CNTL_FRC_VAL_4f_GET BCMI_MADURA_ICTL4r_CNTL_FRC_VAL_4f_GET
#define ICTL4r_CNTL_FRC_VAL_4f_SET BCMI_MADURA_ICTL4r_CNTL_FRC_VAL_4f_SET
#define ICTL4r_CNTL_FRC_4f_GET BCMI_MADURA_ICTL4r_CNTL_FRC_4f_GET
#define ICTL4r_CNTL_FRC_4f_SET BCMI_MADURA_ICTL4r_CNTL_FRC_4f_SET
#define READ_ICTL4r BCMI_MADURA_READ_ICTL4r
#define WRITE_ICTL4r BCMI_MADURA_WRITE_ICTL4r
#define MODIFY_ICTL4r BCMI_MADURA_MODIFY_ICTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL5
 * BLOCKS:   PD
 * REGADDR:  0xb105
 * DEVAD:    1
 * DESC:     control register-5  for half rate
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CNTL_FRC_5       PD module force control signals,bit-0, force the enable or disable the PD,bit-1, force the bypass of the update filter, PD will converge faster once you bypass,bit-2, force the swapping of the phase increment and decrement functionality,
 *     CNTL_FRC_VAL_5   PD module force val signals,bit-0, enable or disable the PD,bit-1, bypass the update filter, PD will converge faster once you bypass,bit-2, swap the phase increment and decrement functionality,
 */
#define BCMI_MADURA_ICTL5r (0x0001b105 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL5r_SIZE 4

/*
 * This structure should be used to declare and program ICTL5.
 */
typedef union BCMI_MADURA_ICTL5r_s {
	uint32_t v[1];
	uint32_t ictl5[1];
	uint32_t _ictl5;
} BCMI_MADURA_ICTL5r_t;

#define BCMI_MADURA_ICTL5r_CLR(r) (r).ictl5[0] = 0
#define BCMI_MADURA_ICTL5r_SET(r,d) (r).ictl5[0] = d
#define BCMI_MADURA_ICTL5r_GET(r) (r).ictl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL5r_CNTL_FRC_VAL_5f_GET(r) ((((r).ictl5[0]) >> 4) & 0x7)
#define BCMI_MADURA_ICTL5r_CNTL_FRC_VAL_5f_SET(r,f) (r).ictl5[0]=(((r).ictl5[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_ICTL5r_CNTL_FRC_5f_GET(r) (((r).ictl5[0]) & 0x7)
#define BCMI_MADURA_ICTL5r_CNTL_FRC_5f_SET(r,f) (r).ictl5[0]=(((r).ictl5[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access ICTL5.
 */
#define BCMI_MADURA_READ_ICTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL5r,_r._ictl5)
#define BCMI_MADURA_WRITE_ICTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL5r,_r._ictl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL5r BCMI_MADURA_ICTL5r
#define ICTL5r_SIZE BCMI_MADURA_ICTL5r_SIZE
typedef BCMI_MADURA_ICTL5r_t ICTL5r_t;
#define ICTL5r_CLR BCMI_MADURA_ICTL5r_CLR
#define ICTL5r_SET BCMI_MADURA_ICTL5r_SET
#define ICTL5r_GET BCMI_MADURA_ICTL5r_GET
#define ICTL5r_CNTL_FRC_VAL_5f_GET BCMI_MADURA_ICTL5r_CNTL_FRC_VAL_5f_GET
#define ICTL5r_CNTL_FRC_VAL_5f_SET BCMI_MADURA_ICTL5r_CNTL_FRC_VAL_5f_SET
#define ICTL5r_CNTL_FRC_5f_GET BCMI_MADURA_ICTL5r_CNTL_FRC_5f_GET
#define ICTL5r_CNTL_FRC_5f_SET BCMI_MADURA_ICTL5r_CNTL_FRC_5f_SET
#define READ_ICTL5r BCMI_MADURA_READ_ICTL5r
#define WRITE_ICTL5r BCMI_MADURA_WRITE_ICTL5r
#define MODIFY_ICTL5r BCMI_MADURA_MODIFY_ICTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ISTS1
 * BLOCKS:   PD
 * REGADDR:  0xb111
 * DEVAD:    1
 * DESC:     status register-1 for half rate
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     STS_1            PD module status,toggles  between 2'b01 and 2'b10 once locked,if stuck at 2'b01 or 2'b10 indicates phase detector has not locked,
 *     LOCK_STS_1       Live status bit indicating the lock or a failure of locking for the PD
 *     LOCK_STS_LATCHED_LOW_STICKY_1 Status bit indicating the lock or a failure of locking for the PD, latched low needs soft_reset based clear
 *     DIS_STS_LATCHED_HIGH_STICKY_1 Status bit indicating, failure to lock under large PPM drifts, needs soft_reset based clear
 */
#define BCMI_MADURA_ISTS1r (0x0001b111 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ISTS1r_SIZE 4

/*
 * This structure should be used to declare and program ISTS1.
 */
typedef union BCMI_MADURA_ISTS1r_s {
	uint32_t v[1];
	uint32_t ists1[1];
	uint32_t _ists1;
} BCMI_MADURA_ISTS1r_t;

#define BCMI_MADURA_ISTS1r_CLR(r) (r).ists1[0] = 0
#define BCMI_MADURA_ISTS1r_SET(r,d) (r).ists1[0] = d
#define BCMI_MADURA_ISTS1r_GET(r) (r).ists1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ISTS1r_DIS_STS_LATCHED_HIGH_STICKY_1f_GET(r) ((((r).ists1[0]) >> 4) & 0x1)
#define BCMI_MADURA_ISTS1r_DIS_STS_LATCHED_HIGH_STICKY_1f_SET(r,f) (r).ists1[0]=(((r).ists1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ISTS1r_LOCK_STS_LATCHED_LOW_STICKY_1f_GET(r) ((((r).ists1[0]) >> 3) & 0x1)
#define BCMI_MADURA_ISTS1r_LOCK_STS_LATCHED_LOW_STICKY_1f_SET(r,f) (r).ists1[0]=(((r).ists1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_ISTS1r_LOCK_STS_1f_GET(r) ((((r).ists1[0]) >> 2) & 0x1)
#define BCMI_MADURA_ISTS1r_LOCK_STS_1f_SET(r,f) (r).ists1[0]=(((r).ists1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ISTS1r_STS_1f_GET(r) (((r).ists1[0]) & 0x3)
#define BCMI_MADURA_ISTS1r_STS_1f_SET(r,f) (r).ists1[0]=(((r).ists1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access ISTS1.
 */
#define BCMI_MADURA_READ_ISTS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ISTS1r,_r._ists1)
#define BCMI_MADURA_WRITE_ISTS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ISTS1r,_r._ists1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ISTS1r BCMI_MADURA_ISTS1r
#define ISTS1r_SIZE BCMI_MADURA_ISTS1r_SIZE
typedef BCMI_MADURA_ISTS1r_t ISTS1r_t;
#define ISTS1r_CLR BCMI_MADURA_ISTS1r_CLR
#define ISTS1r_SET BCMI_MADURA_ISTS1r_SET
#define ISTS1r_GET BCMI_MADURA_ISTS1r_GET
#define ISTS1r_DIS_STS_LATCHED_HIGH_STICKY_1f_GET BCMI_MADURA_ISTS1r_DIS_STS_LATCHED_HIGH_STICKY_1f_GET
#define ISTS1r_DIS_STS_LATCHED_HIGH_STICKY_1f_SET BCMI_MADURA_ISTS1r_DIS_STS_LATCHED_HIGH_STICKY_1f_SET
#define ISTS1r_LOCK_STS_LATCHED_LOW_STICKY_1f_GET BCMI_MADURA_ISTS1r_LOCK_STS_LATCHED_LOW_STICKY_1f_GET
#define ISTS1r_LOCK_STS_LATCHED_LOW_STICKY_1f_SET BCMI_MADURA_ISTS1r_LOCK_STS_LATCHED_LOW_STICKY_1f_SET
#define ISTS1r_LOCK_STS_1f_GET BCMI_MADURA_ISTS1r_LOCK_STS_1f_GET
#define ISTS1r_LOCK_STS_1f_SET BCMI_MADURA_ISTS1r_LOCK_STS_1f_SET
#define ISTS1r_STS_1f_GET BCMI_MADURA_ISTS1r_STS_1f_GET
#define ISTS1r_STS_1f_SET BCMI_MADURA_ISTS1r_STS_1f_SET
#define READ_ISTS1r BCMI_MADURA_READ_ISTS1r
#define WRITE_ISTS1r BCMI_MADURA_WRITE_ISTS1r
#define MODIFY_ISTS1r BCMI_MADURA_MODIFY_ISTS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ISTS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ISTS2
 * BLOCKS:   PD
 * REGADDR:  0xb112
 * DEVAD:    1
 * DESC:     status register-2 for half rate
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     STS_2            PD module status,toggles  between 2'b01 and 2'b10 once locked,if stuck at 2'b01 or 2'b10 indicates phase detector has not locked,
 *     LOCK_STS_2       Live status bit indicating the lock or a failure of locking for the PD
 *     LOCK_STS_LATCHED_LOW_STICKY_2 Status bit indicating the lock or a failure of locking for the PD, latched low needs soft_reset based clear
 *     DIS_STS_LATCHED_HIGH_STICKY_2 Status bit indicating, failure to lock under large PPM drifts, needs soft_reset based clear
 */
#define BCMI_MADURA_ISTS2r (0x0001b112 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ISTS2r_SIZE 4

/*
 * This structure should be used to declare and program ISTS2.
 */
typedef union BCMI_MADURA_ISTS2r_s {
	uint32_t v[1];
	uint32_t ists2[1];
	uint32_t _ists2;
} BCMI_MADURA_ISTS2r_t;

#define BCMI_MADURA_ISTS2r_CLR(r) (r).ists2[0] = 0
#define BCMI_MADURA_ISTS2r_SET(r,d) (r).ists2[0] = d
#define BCMI_MADURA_ISTS2r_GET(r) (r).ists2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ISTS2r_DIS_STS_LATCHED_HIGH_STICKY_2f_GET(r) ((((r).ists2[0]) >> 4) & 0x1)
#define BCMI_MADURA_ISTS2r_DIS_STS_LATCHED_HIGH_STICKY_2f_SET(r,f) (r).ists2[0]=(((r).ists2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ISTS2r_LOCK_STS_LATCHED_LOW_STICKY_2f_GET(r) ((((r).ists2[0]) >> 3) & 0x1)
#define BCMI_MADURA_ISTS2r_LOCK_STS_LATCHED_LOW_STICKY_2f_SET(r,f) (r).ists2[0]=(((r).ists2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_ISTS2r_LOCK_STS_2f_GET(r) ((((r).ists2[0]) >> 2) & 0x1)
#define BCMI_MADURA_ISTS2r_LOCK_STS_2f_SET(r,f) (r).ists2[0]=(((r).ists2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ISTS2r_STS_2f_GET(r) (((r).ists2[0]) & 0x3)
#define BCMI_MADURA_ISTS2r_STS_2f_SET(r,f) (r).ists2[0]=(((r).ists2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access ISTS2.
 */
#define BCMI_MADURA_READ_ISTS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ISTS2r,_r._ists2)
#define BCMI_MADURA_WRITE_ISTS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ISTS2r,_r._ists2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ISTS2r BCMI_MADURA_ISTS2r
#define ISTS2r_SIZE BCMI_MADURA_ISTS2r_SIZE
typedef BCMI_MADURA_ISTS2r_t ISTS2r_t;
#define ISTS2r_CLR BCMI_MADURA_ISTS2r_CLR
#define ISTS2r_SET BCMI_MADURA_ISTS2r_SET
#define ISTS2r_GET BCMI_MADURA_ISTS2r_GET
#define ISTS2r_DIS_STS_LATCHED_HIGH_STICKY_2f_GET BCMI_MADURA_ISTS2r_DIS_STS_LATCHED_HIGH_STICKY_2f_GET
#define ISTS2r_DIS_STS_LATCHED_HIGH_STICKY_2f_SET BCMI_MADURA_ISTS2r_DIS_STS_LATCHED_HIGH_STICKY_2f_SET
#define ISTS2r_LOCK_STS_LATCHED_LOW_STICKY_2f_GET BCMI_MADURA_ISTS2r_LOCK_STS_LATCHED_LOW_STICKY_2f_GET
#define ISTS2r_LOCK_STS_LATCHED_LOW_STICKY_2f_SET BCMI_MADURA_ISTS2r_LOCK_STS_LATCHED_LOW_STICKY_2f_SET
#define ISTS2r_LOCK_STS_2f_GET BCMI_MADURA_ISTS2r_LOCK_STS_2f_GET
#define ISTS2r_LOCK_STS_2f_SET BCMI_MADURA_ISTS2r_LOCK_STS_2f_SET
#define ISTS2r_STS_2f_GET BCMI_MADURA_ISTS2r_STS_2f_GET
#define ISTS2r_STS_2f_SET BCMI_MADURA_ISTS2r_STS_2f_SET
#define READ_ISTS2r BCMI_MADURA_READ_ISTS2r
#define WRITE_ISTS2r BCMI_MADURA_WRITE_ISTS2r
#define MODIFY_ISTS2r BCMI_MADURA_MODIFY_ISTS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ISTS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ISTS3
 * BLOCKS:   PD
 * REGADDR:  0xb113
 * DEVAD:    1
 * DESC:     status register-3 for half rate
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     STS_3            PD module status,toggles  between 2'b01 and 2'b10 once locked,if stuck at 2'b01 or 2'b10 indicates phase detector has not locked,
 *     LOCK_STS_3       Live status bit indicating the lock or a failure of locking for the PD
 *     LOCK_STS_LATCHED_LOW_STICKY_3 Status bit indicating the lock or a failure of locking for the PD, latched low needs soft_reset based clear
 *     DIS_STS_LATCHED_HIGH_STICKY_3 Status bit indicating, failure to lock under large PPM drifts, needs soft_reset based clear
 */
#define BCMI_MADURA_ISTS3r (0x0001b113 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ISTS3r_SIZE 4

/*
 * This structure should be used to declare and program ISTS3.
 */
typedef union BCMI_MADURA_ISTS3r_s {
	uint32_t v[1];
	uint32_t ists3[1];
	uint32_t _ists3;
} BCMI_MADURA_ISTS3r_t;

#define BCMI_MADURA_ISTS3r_CLR(r) (r).ists3[0] = 0
#define BCMI_MADURA_ISTS3r_SET(r,d) (r).ists3[0] = d
#define BCMI_MADURA_ISTS3r_GET(r) (r).ists3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ISTS3r_DIS_STS_LATCHED_HIGH_STICKY_3f_GET(r) ((((r).ists3[0]) >> 4) & 0x1)
#define BCMI_MADURA_ISTS3r_DIS_STS_LATCHED_HIGH_STICKY_3f_SET(r,f) (r).ists3[0]=(((r).ists3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ISTS3r_LOCK_STS_LATCHED_LOW_STICKY_3f_GET(r) ((((r).ists3[0]) >> 3) & 0x1)
#define BCMI_MADURA_ISTS3r_LOCK_STS_LATCHED_LOW_STICKY_3f_SET(r,f) (r).ists3[0]=(((r).ists3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_ISTS3r_LOCK_STS_3f_GET(r) ((((r).ists3[0]) >> 2) & 0x1)
#define BCMI_MADURA_ISTS3r_LOCK_STS_3f_SET(r,f) (r).ists3[0]=(((r).ists3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ISTS3r_STS_3f_GET(r) (((r).ists3[0]) & 0x3)
#define BCMI_MADURA_ISTS3r_STS_3f_SET(r,f) (r).ists3[0]=(((r).ists3[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access ISTS3.
 */
#define BCMI_MADURA_READ_ISTS3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ISTS3r,_r._ists3)
#define BCMI_MADURA_WRITE_ISTS3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ISTS3r,_r._ists3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ISTS3r BCMI_MADURA_ISTS3r
#define ISTS3r_SIZE BCMI_MADURA_ISTS3r_SIZE
typedef BCMI_MADURA_ISTS3r_t ISTS3r_t;
#define ISTS3r_CLR BCMI_MADURA_ISTS3r_CLR
#define ISTS3r_SET BCMI_MADURA_ISTS3r_SET
#define ISTS3r_GET BCMI_MADURA_ISTS3r_GET
#define ISTS3r_DIS_STS_LATCHED_HIGH_STICKY_3f_GET BCMI_MADURA_ISTS3r_DIS_STS_LATCHED_HIGH_STICKY_3f_GET
#define ISTS3r_DIS_STS_LATCHED_HIGH_STICKY_3f_SET BCMI_MADURA_ISTS3r_DIS_STS_LATCHED_HIGH_STICKY_3f_SET
#define ISTS3r_LOCK_STS_LATCHED_LOW_STICKY_3f_GET BCMI_MADURA_ISTS3r_LOCK_STS_LATCHED_LOW_STICKY_3f_GET
#define ISTS3r_LOCK_STS_LATCHED_LOW_STICKY_3f_SET BCMI_MADURA_ISTS3r_LOCK_STS_LATCHED_LOW_STICKY_3f_SET
#define ISTS3r_LOCK_STS_3f_GET BCMI_MADURA_ISTS3r_LOCK_STS_3f_GET
#define ISTS3r_LOCK_STS_3f_SET BCMI_MADURA_ISTS3r_LOCK_STS_3f_SET
#define ISTS3r_STS_3f_GET BCMI_MADURA_ISTS3r_STS_3f_GET
#define ISTS3r_STS_3f_SET BCMI_MADURA_ISTS3r_STS_3f_SET
#define READ_ISTS3r BCMI_MADURA_READ_ISTS3r
#define WRITE_ISTS3r BCMI_MADURA_WRITE_ISTS3r
#define MODIFY_ISTS3r BCMI_MADURA_MODIFY_ISTS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ISTS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ISTS4
 * BLOCKS:   PD
 * REGADDR:  0xb114
 * DEVAD:    1
 * DESC:     status register-4 for half rate
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     STS_4            PD module status,toggles  between 2'b01 and 2'b10 once locked,if stuck at 2'b01 or 2'b10 indicates phase detector has not locked,
 *     LOCK_STS_4       Live status bit indicating the lock or a failure of locking for the PD
 *     LOCK_STS_LATCHED_LOW_STICKY_4 Status bit indicating the lock or a failure of locking for the PD, latched low needs soft_reset based clear
 *     DIS_STS_LATCHED_HIGH_STICKY_4 Status bit indicating, failure to lock under large PPM drifts, needs soft_reset based clear
 */
#define BCMI_MADURA_ISTS4r (0x0001b114 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ISTS4r_SIZE 4

/*
 * This structure should be used to declare and program ISTS4.
 */
typedef union BCMI_MADURA_ISTS4r_s {
	uint32_t v[1];
	uint32_t ists4[1];
	uint32_t _ists4;
} BCMI_MADURA_ISTS4r_t;

#define BCMI_MADURA_ISTS4r_CLR(r) (r).ists4[0] = 0
#define BCMI_MADURA_ISTS4r_SET(r,d) (r).ists4[0] = d
#define BCMI_MADURA_ISTS4r_GET(r) (r).ists4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ISTS4r_DIS_STS_LATCHED_HIGH_STICKY_4f_GET(r) ((((r).ists4[0]) >> 4) & 0x1)
#define BCMI_MADURA_ISTS4r_DIS_STS_LATCHED_HIGH_STICKY_4f_SET(r,f) (r).ists4[0]=(((r).ists4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ISTS4r_LOCK_STS_LATCHED_LOW_STICKY_4f_GET(r) ((((r).ists4[0]) >> 3) & 0x1)
#define BCMI_MADURA_ISTS4r_LOCK_STS_LATCHED_LOW_STICKY_4f_SET(r,f) (r).ists4[0]=(((r).ists4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_ISTS4r_LOCK_STS_4f_GET(r) ((((r).ists4[0]) >> 2) & 0x1)
#define BCMI_MADURA_ISTS4r_LOCK_STS_4f_SET(r,f) (r).ists4[0]=(((r).ists4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ISTS4r_STS_4f_GET(r) (((r).ists4[0]) & 0x3)
#define BCMI_MADURA_ISTS4r_STS_4f_SET(r,f) (r).ists4[0]=(((r).ists4[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access ISTS4.
 */
#define BCMI_MADURA_READ_ISTS4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ISTS4r,_r._ists4)
#define BCMI_MADURA_WRITE_ISTS4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ISTS4r,_r._ists4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ISTS4r BCMI_MADURA_ISTS4r
#define ISTS4r_SIZE BCMI_MADURA_ISTS4r_SIZE
typedef BCMI_MADURA_ISTS4r_t ISTS4r_t;
#define ISTS4r_CLR BCMI_MADURA_ISTS4r_CLR
#define ISTS4r_SET BCMI_MADURA_ISTS4r_SET
#define ISTS4r_GET BCMI_MADURA_ISTS4r_GET
#define ISTS4r_DIS_STS_LATCHED_HIGH_STICKY_4f_GET BCMI_MADURA_ISTS4r_DIS_STS_LATCHED_HIGH_STICKY_4f_GET
#define ISTS4r_DIS_STS_LATCHED_HIGH_STICKY_4f_SET BCMI_MADURA_ISTS4r_DIS_STS_LATCHED_HIGH_STICKY_4f_SET
#define ISTS4r_LOCK_STS_LATCHED_LOW_STICKY_4f_GET BCMI_MADURA_ISTS4r_LOCK_STS_LATCHED_LOW_STICKY_4f_GET
#define ISTS4r_LOCK_STS_LATCHED_LOW_STICKY_4f_SET BCMI_MADURA_ISTS4r_LOCK_STS_LATCHED_LOW_STICKY_4f_SET
#define ISTS4r_LOCK_STS_4f_GET BCMI_MADURA_ISTS4r_LOCK_STS_4f_GET
#define ISTS4r_LOCK_STS_4f_SET BCMI_MADURA_ISTS4r_LOCK_STS_4f_SET
#define ISTS4r_STS_4f_GET BCMI_MADURA_ISTS4r_STS_4f_GET
#define ISTS4r_STS_4f_SET BCMI_MADURA_ISTS4r_STS_4f_SET
#define READ_ISTS4r BCMI_MADURA_READ_ISTS4r
#define WRITE_ISTS4r BCMI_MADURA_WRITE_ISTS4r
#define MODIFY_ISTS4r BCMI_MADURA_MODIFY_ISTS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ISTS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ISTS5
 * BLOCKS:   PD
 * REGADDR:  0xb115
 * DEVAD:    1
 * DESC:     status register-5 for half rate
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     STS_5            PD module statustoggles  between 2'b01 and 2'b10 once locked,if stuck at 2'b01 or 2'b10 indicates phase detector has not locked,
 *     LOCK_STS_5       Live status bit indicating the lock or a failure of locking for the PD
 *     LOCK_STS_LATCHED_LOW_STICKY_5 Status bit indicating the lock or a failure of locking for the PD, latched low needs soft_reset based clear
 *     DIS_STS_LATCHED_HIGH_STICKY_5 Status bit indicating, failure to lock under large PPM drifts, needs soft_reset based clear
 */
#define BCMI_MADURA_ISTS5r (0x0001b115 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ISTS5r_SIZE 4

/*
 * This structure should be used to declare and program ISTS5.
 */
typedef union BCMI_MADURA_ISTS5r_s {
	uint32_t v[1];
	uint32_t ists5[1];
	uint32_t _ists5;
} BCMI_MADURA_ISTS5r_t;

#define BCMI_MADURA_ISTS5r_CLR(r) (r).ists5[0] = 0
#define BCMI_MADURA_ISTS5r_SET(r,d) (r).ists5[0] = d
#define BCMI_MADURA_ISTS5r_GET(r) (r).ists5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ISTS5r_DIS_STS_LATCHED_HIGH_STICKY_5f_GET(r) ((((r).ists5[0]) >> 4) & 0x1)
#define BCMI_MADURA_ISTS5r_DIS_STS_LATCHED_HIGH_STICKY_5f_SET(r,f) (r).ists5[0]=(((r).ists5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ISTS5r_LOCK_STS_LATCHED_LOW_STICKY_5f_GET(r) ((((r).ists5[0]) >> 3) & 0x1)
#define BCMI_MADURA_ISTS5r_LOCK_STS_LATCHED_LOW_STICKY_5f_SET(r,f) (r).ists5[0]=(((r).ists5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_ISTS5r_LOCK_STS_5f_GET(r) ((((r).ists5[0]) >> 2) & 0x1)
#define BCMI_MADURA_ISTS5r_LOCK_STS_5f_SET(r,f) (r).ists5[0]=(((r).ists5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ISTS5r_STS_5f_GET(r) (((r).ists5[0]) & 0x3)
#define BCMI_MADURA_ISTS5r_STS_5f_SET(r,f) (r).ists5[0]=(((r).ists5[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access ISTS5.
 */
#define BCMI_MADURA_READ_ISTS5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ISTS5r,_r._ists5)
#define BCMI_MADURA_WRITE_ISTS5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ISTS5r,_r._ists5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ISTS5r BCMI_MADURA_ISTS5r
#define ISTS5r_SIZE BCMI_MADURA_ISTS5r_SIZE
typedef BCMI_MADURA_ISTS5r_t ISTS5r_t;
#define ISTS5r_CLR BCMI_MADURA_ISTS5r_CLR
#define ISTS5r_SET BCMI_MADURA_ISTS5r_SET
#define ISTS5r_GET BCMI_MADURA_ISTS5r_GET
#define ISTS5r_DIS_STS_LATCHED_HIGH_STICKY_5f_GET BCMI_MADURA_ISTS5r_DIS_STS_LATCHED_HIGH_STICKY_5f_GET
#define ISTS5r_DIS_STS_LATCHED_HIGH_STICKY_5f_SET BCMI_MADURA_ISTS5r_DIS_STS_LATCHED_HIGH_STICKY_5f_SET
#define ISTS5r_LOCK_STS_LATCHED_LOW_STICKY_5f_GET BCMI_MADURA_ISTS5r_LOCK_STS_LATCHED_LOW_STICKY_5f_GET
#define ISTS5r_LOCK_STS_LATCHED_LOW_STICKY_5f_SET BCMI_MADURA_ISTS5r_LOCK_STS_LATCHED_LOW_STICKY_5f_SET
#define ISTS5r_LOCK_STS_5f_GET BCMI_MADURA_ISTS5r_LOCK_STS_5f_GET
#define ISTS5r_LOCK_STS_5f_SET BCMI_MADURA_ISTS5r_LOCK_STS_5f_SET
#define ISTS5r_STS_5f_GET BCMI_MADURA_ISTS5r_STS_5f_GET
#define ISTS5r_STS_5f_SET BCMI_MADURA_ISTS5r_STS_5f_SET
#define READ_ISTS5r BCMI_MADURA_READ_ISTS5r
#define WRITE_ISTS5r BCMI_MADURA_WRITE_ISTS5r
#define MODIFY_ISTS5r BCMI_MADURA_MODIFY_ISTS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ISTS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL_LOCK
 * BLOCKS:   PD
 * REGADDR:  0xb116
 * DEVAD:    1
 * DESC:     control register-1  for lock
 * RESETVAL: 0x32 (50)
 * ACCESS:   R/W
 * FIELDS:
 *     CNTL_MAX_THRES   the maximum count value before declaring a lock
 */
#define BCMI_MADURA_ICTL_LOCKr (0x0001b116 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program ICTL_LOCK.
 */
typedef union BCMI_MADURA_ICTL_LOCKr_s {
	uint32_t v[1];
	uint32_t ictl_lock[1];
	uint32_t _ictl_lock;
} BCMI_MADURA_ICTL_LOCKr_t;

#define BCMI_MADURA_ICTL_LOCKr_CLR(r) (r).ictl_lock[0] = 0
#define BCMI_MADURA_ICTL_LOCKr_SET(r,d) (r).ictl_lock[0] = d
#define BCMI_MADURA_ICTL_LOCKr_GET(r) (r).ictl_lock[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL_LOCKr_CNTL_MAX_THRESf_GET(r) (((r).ictl_lock[0]) & 0xfff)
#define BCMI_MADURA_ICTL_LOCKr_CNTL_MAX_THRESf_SET(r,f) (r).ictl_lock[0]=(((r).ictl_lock[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access ICTL_LOCK.
 */
#define BCMI_MADURA_READ_ICTL_LOCKr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL_LOCKr,_r._ictl_lock)
#define BCMI_MADURA_WRITE_ICTL_LOCKr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL_LOCKr,_r._ictl_lock)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL_LOCKr BCMI_MADURA_ICTL_LOCKr
#define ICTL_LOCKr_SIZE BCMI_MADURA_ICTL_LOCKr_SIZE
typedef BCMI_MADURA_ICTL_LOCKr_t ICTL_LOCKr_t;
#define ICTL_LOCKr_CLR BCMI_MADURA_ICTL_LOCKr_CLR
#define ICTL_LOCKr_SET BCMI_MADURA_ICTL_LOCKr_SET
#define ICTL_LOCKr_GET BCMI_MADURA_ICTL_LOCKr_GET
#define ICTL_LOCKr_CNTL_MAX_THRESf_GET BCMI_MADURA_ICTL_LOCKr_CNTL_MAX_THRESf_GET
#define ICTL_LOCKr_CNTL_MAX_THRESf_SET BCMI_MADURA_ICTL_LOCKr_CNTL_MAX_THRESf_SET
#define READ_ICTL_LOCKr BCMI_MADURA_READ_ICTL_LOCKr
#define WRITE_ICTL_LOCKr BCMI_MADURA_WRITE_ICTL_LOCKr
#define MODIFY_ICTL_LOCKr BCMI_MADURA_MODIFY_ICTL_LOCKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL_LOCKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL_SFT_RST
 * BLOCKS:   PD
 * REGADDR:  0xb117
 * DEVAD:    1
 * DESC:     control register  for soft reset of the pd sub blocks
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CNTL_SFT_RST     This vector signal resets one more of the PD engines for each lane. Each lane can have up to 5-engines indexed from 1 to 5
 */
#define BCMI_MADURA_ICTL_SFT_RSTr (0x0001b117 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL_SFT_RSTr_SIZE 4

/*
 * This structure should be used to declare and program ICTL_SFT_RST.
 */
typedef union BCMI_MADURA_ICTL_SFT_RSTr_s {
	uint32_t v[1];
	uint32_t ictl_sft_rst[1];
	uint32_t _ictl_sft_rst;
} BCMI_MADURA_ICTL_SFT_RSTr_t;

#define BCMI_MADURA_ICTL_SFT_RSTr_CLR(r) (r).ictl_sft_rst[0] = 0
#define BCMI_MADURA_ICTL_SFT_RSTr_SET(r,d) (r).ictl_sft_rst[0] = d
#define BCMI_MADURA_ICTL_SFT_RSTr_GET(r) (r).ictl_sft_rst[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL_SFT_RSTr_CNTL_SFT_RSTf_GET(r) ((((r).ictl_sft_rst[0]) >> 1) & 0x1f)
#define BCMI_MADURA_ICTL_SFT_RSTr_CNTL_SFT_RSTf_SET(r,f) (r).ictl_sft_rst[0]=(((r).ictl_sft_rst[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))

/*
 * These macros can be used to access ICTL_SFT_RST.
 */
#define BCMI_MADURA_READ_ICTL_SFT_RSTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL_SFT_RSTr,_r._ictl_sft_rst)
#define BCMI_MADURA_WRITE_ICTL_SFT_RSTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL_SFT_RSTr,_r._ictl_sft_rst)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL_SFT_RSTr BCMI_MADURA_ICTL_SFT_RSTr
#define ICTL_SFT_RSTr_SIZE BCMI_MADURA_ICTL_SFT_RSTr_SIZE
typedef BCMI_MADURA_ICTL_SFT_RSTr_t ICTL_SFT_RSTr_t;
#define ICTL_SFT_RSTr_CLR BCMI_MADURA_ICTL_SFT_RSTr_CLR
#define ICTL_SFT_RSTr_SET BCMI_MADURA_ICTL_SFT_RSTr_SET
#define ICTL_SFT_RSTr_GET BCMI_MADURA_ICTL_SFT_RSTr_GET
#define ICTL_SFT_RSTr_CNTL_SFT_RSTf_GET BCMI_MADURA_ICTL_SFT_RSTr_CNTL_SFT_RSTf_GET
#define ICTL_SFT_RSTr_CNTL_SFT_RSTf_SET BCMI_MADURA_ICTL_SFT_RSTr_CNTL_SFT_RSTf_SET
#define READ_ICTL_SFT_RSTr BCMI_MADURA_READ_ICTL_SFT_RSTr
#define WRITE_ICTL_SFT_RSTr BCMI_MADURA_WRITE_ICTL_SFT_RSTr
#define MODIFY_ICTL_SFT_RSTr BCMI_MADURA_MODIFY_ICTL_SFT_RSTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL_SFT_RSTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ICTL_DIS
 * BLOCKS:   PD
 * REGADDR:  0xb118
 * DEVAD:    1
 * DESC:     control register for disparity threshold
 * RESETVAL: 0x800 (2048)
 * ACCESS:   R/W
 * FIELDS:
 *     DISPARITY_THRES  If this threshold setting is violated then there is large PPM drift, this value needs to be empirically determined
 */
#define BCMI_MADURA_ICTL_DISr (0x0001b118 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ICTL_DISr_SIZE 4

/*
 * This structure should be used to declare and program ICTL_DIS.
 */
typedef union BCMI_MADURA_ICTL_DISr_s {
	uint32_t v[1];
	uint32_t ictl_dis[1];
	uint32_t _ictl_dis;
} BCMI_MADURA_ICTL_DISr_t;

#define BCMI_MADURA_ICTL_DISr_CLR(r) (r).ictl_dis[0] = 0
#define BCMI_MADURA_ICTL_DISr_SET(r,d) (r).ictl_dis[0] = d
#define BCMI_MADURA_ICTL_DISr_GET(r) (r).ictl_dis[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ICTL_DISr_DISPARITY_THRESf_GET(r) (((r).ictl_dis[0]) & 0xffff)
#define BCMI_MADURA_ICTL_DISr_DISPARITY_THRESf_SET(r,f) (r).ictl_dis[0]=(((r).ictl_dis[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access ICTL_DIS.
 */
#define BCMI_MADURA_READ_ICTL_DISr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ICTL_DISr,_r._ictl_dis)
#define BCMI_MADURA_WRITE_ICTL_DISr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ICTL_DISr,_r._ictl_dis)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ICTL_DISr BCMI_MADURA_ICTL_DISr
#define ICTL_DISr_SIZE BCMI_MADURA_ICTL_DISr_SIZE
typedef BCMI_MADURA_ICTL_DISr_t ICTL_DISr_t;
#define ICTL_DISr_CLR BCMI_MADURA_ICTL_DISr_CLR
#define ICTL_DISr_SET BCMI_MADURA_ICTL_DISr_SET
#define ICTL_DISr_GET BCMI_MADURA_ICTL_DISr_GET
#define ICTL_DISr_DISPARITY_THRESf_GET BCMI_MADURA_ICTL_DISr_DISPARITY_THRESf_GET
#define ICTL_DISr_DISPARITY_THRESf_SET BCMI_MADURA_ICTL_DISr_DISPARITY_THRESf_SET
#define READ_ICTL_DISr BCMI_MADURA_READ_ICTL_DISr
#define WRITE_ICTL_DISr BCMI_MADURA_WRITE_ICTL_DISr
#define MODIFY_ICTL_DISr BCMI_MADURA_MODIFY_ICTL_DISr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ICTL_DISr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CFGS
 * BLOCKS:   MSG_SNF
 * REGADDR:  0xb300
 * DEVAD:    1
 * DESC:     message sniffer main control
 * RESETVAL: 0x2655 (9813)
 * ACCESS:   R/W
 * FIELDS:
 *     HDR_ID           4-bit pattern to indicate headers
 *     MSG_ID           4-bit pattern to indicate messages
 *     MSG_NO           number of 16-bit messages to be captured
 *     RSTB_FRC_VAL     message sniffer active low reset force value
 *     RSTB_FRC         message sniffer active low reset force bit
 *     CLEAR_LINE_TX_DISABLE set to clear line_tx_disable manually
 *     USE_SYS_PMD_LOCK Use sys_pmd_lock for line_tx_disable
 *     ENABLE           message sniffer enable
 *     DIN_SWAP         1G Rx input data swap for message sniffer
 */
#define BCMI_MADURA_CFGSr (0x0001b300 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CFGSr_SIZE 4

/*
 * This structure should be used to declare and program CFGS.
 */
typedef union BCMI_MADURA_CFGSr_s {
	uint32_t v[1];
	uint32_t cfgs[1];
	uint32_t _cfgs;
} BCMI_MADURA_CFGSr_t;

#define BCMI_MADURA_CFGSr_CLR(r) (r).cfgs[0] = 0
#define BCMI_MADURA_CFGSr_SET(r,d) (r).cfgs[0] = d
#define BCMI_MADURA_CFGSr_GET(r) (r).cfgs[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CFGSr_DIN_SWAPf_GET(r) ((((r).cfgs[0]) >> 15) & 0x1)
#define BCMI_MADURA_CFGSr_DIN_SWAPf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CFGSr_ENABLEf_GET(r) ((((r).cfgs[0]) >> 14) & 0x1)
#define BCMI_MADURA_CFGSr_ENABLEf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CFGSr_USE_SYS_PMD_LOCKf_GET(r) ((((r).cfgs[0]) >> 13) & 0x1)
#define BCMI_MADURA_CFGSr_USE_SYS_PMD_LOCKf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CFGSr_CLEAR_LINE_TX_DISABLEf_GET(r) ((((r).cfgs[0]) >> 12) & 0x1)
#define BCMI_MADURA_CFGSr_CLEAR_LINE_TX_DISABLEf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CFGSr_RSTB_FRCf_GET(r) ((((r).cfgs[0]) >> 11) & 0x1)
#define BCMI_MADURA_CFGSr_RSTB_FRCf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_CFGSr_RSTB_FRC_VALf_GET(r) ((((r).cfgs[0]) >> 10) & 0x1)
#define BCMI_MADURA_CFGSr_RSTB_FRC_VALf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CFGSr_MSG_NOf_GET(r) ((((r).cfgs[0]) >> 8) & 0x3)
#define BCMI_MADURA_CFGSr_MSG_NOf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_CFGSr_MSG_IDf_GET(r) ((((r).cfgs[0]) >> 4) & 0xf)
#define BCMI_MADURA_CFGSr_MSG_IDf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_CFGSr_HDR_IDf_GET(r) (((r).cfgs[0]) & 0xf)
#define BCMI_MADURA_CFGSr_HDR_IDf_SET(r,f) (r).cfgs[0]=(((r).cfgs[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CFGS.
 */
#define BCMI_MADURA_READ_CFGSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CFGSr,_r._cfgs)
#define BCMI_MADURA_WRITE_CFGSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CFGSr,_r._cfgs)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CFGSr BCMI_MADURA_CFGSr
#define CFGSr_SIZE BCMI_MADURA_CFGSr_SIZE
typedef BCMI_MADURA_CFGSr_t CFGSr_t;
#define CFGSr_CLR BCMI_MADURA_CFGSr_CLR
#define CFGSr_SET BCMI_MADURA_CFGSr_SET
#define CFGSr_GET BCMI_MADURA_CFGSr_GET
#define CFGSr_DIN_SWAPf_GET BCMI_MADURA_CFGSr_DIN_SWAPf_GET
#define CFGSr_DIN_SWAPf_SET BCMI_MADURA_CFGSr_DIN_SWAPf_SET
#define CFGSr_ENABLEf_GET BCMI_MADURA_CFGSr_ENABLEf_GET
#define CFGSr_ENABLEf_SET BCMI_MADURA_CFGSr_ENABLEf_SET
#define CFGSr_USE_SYS_PMD_LOCKf_GET BCMI_MADURA_CFGSr_USE_SYS_PMD_LOCKf_GET
#define CFGSr_USE_SYS_PMD_LOCKf_SET BCMI_MADURA_CFGSr_USE_SYS_PMD_LOCKf_SET
#define CFGSr_CLEAR_LINE_TX_DISABLEf_GET BCMI_MADURA_CFGSr_CLEAR_LINE_TX_DISABLEf_GET
#define CFGSr_CLEAR_LINE_TX_DISABLEf_SET BCMI_MADURA_CFGSr_CLEAR_LINE_TX_DISABLEf_SET
#define CFGSr_RSTB_FRCf_GET BCMI_MADURA_CFGSr_RSTB_FRCf_GET
#define CFGSr_RSTB_FRCf_SET BCMI_MADURA_CFGSr_RSTB_FRCf_SET
#define CFGSr_RSTB_FRC_VALf_GET BCMI_MADURA_CFGSr_RSTB_FRC_VALf_GET
#define CFGSr_RSTB_FRC_VALf_SET BCMI_MADURA_CFGSr_RSTB_FRC_VALf_SET
#define CFGSr_MSG_NOf_GET BCMI_MADURA_CFGSr_MSG_NOf_GET
#define CFGSr_MSG_NOf_SET BCMI_MADURA_CFGSr_MSG_NOf_SET
#define CFGSr_MSG_IDf_GET BCMI_MADURA_CFGSr_MSG_IDf_GET
#define CFGSr_MSG_IDf_SET BCMI_MADURA_CFGSr_MSG_IDf_SET
#define CFGSr_HDR_IDf_GET BCMI_MADURA_CFGSr_HDR_IDf_GET
#define CFGSr_HDR_IDf_SET BCMI_MADURA_CFGSr_HDR_IDf_SET
#define READ_CFGSr BCMI_MADURA_READ_CFGSr
#define WRITE_CFGSr BCMI_MADURA_WRITE_CFGSr
#define MODIFY_CFGSr BCMI_MADURA_MODIFY_CFGSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CFGSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  HYS_CNT
 * BLOCKS:   MSG_SNF
 * REGADDR:  0xb301
 * DEVAD:    1
 * DESC:     FSM configurations
 * RESETVAL: 0x144 (324)
 * ACCESS:   R/W
 * FIELDS:
 *     LOL_HYS          When unlock_dis is not set, this is the number of consecutive header mismatchesfor state machine to loss lock. No message matches is checked since when message is latched,the shift registers which used to store captured messages are no longer shifting
 *     LOCK_HYS         number of consecutive complete header and message matches for state machine to get into lock state
 *     UNLOCK_DIS       Unlock disable, once lock is asserted, it remains lock until reset
 */
#define BCMI_MADURA_HYS_CNTr (0x0001b301 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_HYS_CNTr_SIZE 4

/*
 * This structure should be used to declare and program HYS_CNT.
 */
typedef union BCMI_MADURA_HYS_CNTr_s {
	uint32_t v[1];
	uint32_t hys_cnt[1];
	uint32_t _hys_cnt;
} BCMI_MADURA_HYS_CNTr_t;

#define BCMI_MADURA_HYS_CNTr_CLR(r) (r).hys_cnt[0] = 0
#define BCMI_MADURA_HYS_CNTr_SET(r,d) (r).hys_cnt[0] = d
#define BCMI_MADURA_HYS_CNTr_GET(r) (r).hys_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_HYS_CNTr_UNLOCK_DISf_GET(r) ((((r).hys_cnt[0]) >> 8) & 0x1)
#define BCMI_MADURA_HYS_CNTr_UNLOCK_DISf_SET(r,f) (r).hys_cnt[0]=(((r).hys_cnt[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_HYS_CNTr_LOCK_HYSf_GET(r) ((((r).hys_cnt[0]) >> 4) & 0xf)
#define BCMI_MADURA_HYS_CNTr_LOCK_HYSf_SET(r,f) (r).hys_cnt[0]=(((r).hys_cnt[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_HYS_CNTr_LOL_HYSf_GET(r) (((r).hys_cnt[0]) & 0xf)
#define BCMI_MADURA_HYS_CNTr_LOL_HYSf_SET(r,f) (r).hys_cnt[0]=(((r).hys_cnt[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access HYS_CNT.
 */
#define BCMI_MADURA_READ_HYS_CNTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_HYS_CNTr,_r._hys_cnt)
#define BCMI_MADURA_WRITE_HYS_CNTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_HYS_CNTr,_r._hys_cnt)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define HYS_CNTr BCMI_MADURA_HYS_CNTr
#define HYS_CNTr_SIZE BCMI_MADURA_HYS_CNTr_SIZE
typedef BCMI_MADURA_HYS_CNTr_t HYS_CNTr_t;
#define HYS_CNTr_CLR BCMI_MADURA_HYS_CNTr_CLR
#define HYS_CNTr_SET BCMI_MADURA_HYS_CNTr_SET
#define HYS_CNTr_GET BCMI_MADURA_HYS_CNTr_GET
#define HYS_CNTr_UNLOCK_DISf_GET BCMI_MADURA_HYS_CNTr_UNLOCK_DISf_GET
#define HYS_CNTr_UNLOCK_DISf_SET BCMI_MADURA_HYS_CNTr_UNLOCK_DISf_SET
#define HYS_CNTr_LOCK_HYSf_GET BCMI_MADURA_HYS_CNTr_LOCK_HYSf_GET
#define HYS_CNTr_LOCK_HYSf_SET BCMI_MADURA_HYS_CNTr_LOCK_HYSf_SET
#define HYS_CNTr_LOL_HYSf_GET BCMI_MADURA_HYS_CNTr_LOL_HYSf_GET
#define HYS_CNTr_LOL_HYSf_SET BCMI_MADURA_HYS_CNTr_LOL_HYSf_SET
#define READ_HYS_CNTr BCMI_MADURA_READ_HYS_CNTr
#define WRITE_HYS_CNTr BCMI_MADURA_WRITE_HYS_CNTr
#define MODIFY_HYS_CNTr BCMI_MADURA_MODIFY_HYS_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_HYS_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  INDICATOR
 * BLOCKS:   MSG_SNF
 * REGADDR:  0xb302
 * DEVAD:    1
 * DESC:     message sniffer main status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOCK_LL          indicate the complete header and message pattern loss of lock, latch low status
 *     LOCK_LH          indicate the complete header and message pattern is successfully locked, latch high  status
 *     LOCK             indicate the complete header and message pattern is successfully locked, live status
 *     MSG_LATCHED      Indicate all messages are successfully latched, it is assert when lock is asserted,and cleared when the first header is seen after release reset.Since this bit is not affected by reset, it reads out unknown value if lock has never been achievedThe latched messages are only valid when msg_latched is asserted,and not affected by reset either. So their read out values are unknown if lock has never been achieved
 */
#define BCMI_MADURA_INDICATORr (0x0001b302 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_INDICATORr_SIZE 4

/*
 * This structure should be used to declare and program INDICATOR.
 */
typedef union BCMI_MADURA_INDICATORr_s {
	uint32_t v[1];
	uint32_t indicator[1];
	uint32_t _indicator;
} BCMI_MADURA_INDICATORr_t;

#define BCMI_MADURA_INDICATORr_CLR(r) (r).indicator[0] = 0
#define BCMI_MADURA_INDICATORr_SET(r,d) (r).indicator[0] = d
#define BCMI_MADURA_INDICATORr_GET(r) (r).indicator[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_INDICATORr_MSG_LATCHEDf_GET(r) ((((r).indicator[0]) >> 3) & 0x1)
#define BCMI_MADURA_INDICATORr_MSG_LATCHEDf_SET(r,f) (r).indicator[0]=(((r).indicator[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_INDICATORr_LOCKf_GET(r) ((((r).indicator[0]) >> 2) & 0x1)
#define BCMI_MADURA_INDICATORr_LOCKf_SET(r,f) (r).indicator[0]=(((r).indicator[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_INDICATORr_LOCK_LHf_GET(r) ((((r).indicator[0]) >> 1) & 0x1)
#define BCMI_MADURA_INDICATORr_LOCK_LHf_SET(r,f) (r).indicator[0]=(((r).indicator[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_INDICATORr_LOCK_LLf_GET(r) (((r).indicator[0]) & 0x1)
#define BCMI_MADURA_INDICATORr_LOCK_LLf_SET(r,f) (r).indicator[0]=(((r).indicator[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access INDICATOR.
 */
#define BCMI_MADURA_READ_INDICATORr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_INDICATORr,_r._indicator)
#define BCMI_MADURA_WRITE_INDICATORr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_INDICATORr,_r._indicator)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define INDICATORr BCMI_MADURA_INDICATORr
#define INDICATORr_SIZE BCMI_MADURA_INDICATORr_SIZE
typedef BCMI_MADURA_INDICATORr_t INDICATORr_t;
#define INDICATORr_CLR BCMI_MADURA_INDICATORr_CLR
#define INDICATORr_SET BCMI_MADURA_INDICATORr_SET
#define INDICATORr_GET BCMI_MADURA_INDICATORr_GET
#define INDICATORr_MSG_LATCHEDf_GET BCMI_MADURA_INDICATORr_MSG_LATCHEDf_GET
#define INDICATORr_MSG_LATCHEDf_SET BCMI_MADURA_INDICATORr_MSG_LATCHEDf_SET
#define INDICATORr_LOCKf_GET BCMI_MADURA_INDICATORr_LOCKf_GET
#define INDICATORr_LOCKf_SET BCMI_MADURA_INDICATORr_LOCKf_SET
#define INDICATORr_LOCK_LHf_GET BCMI_MADURA_INDICATORr_LOCK_LHf_GET
#define INDICATORr_LOCK_LHf_SET BCMI_MADURA_INDICATORr_LOCK_LHf_SET
#define INDICATORr_LOCK_LLf_GET BCMI_MADURA_INDICATORr_LOCK_LLf_GET
#define INDICATORr_LOCK_LLf_SET BCMI_MADURA_INDICATORr_LOCK_LLf_SET
#define READ_INDICATORr BCMI_MADURA_READ_INDICATORr
#define WRITE_INDICATORr BCMI_MADURA_WRITE_INDICATORr
#define MODIFY_INDICATORr BCMI_MADURA_MODIFY_INDICATORr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_INDICATORr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MESSAGE0
 * BLOCKS:   MSG_SNF
 * REGADDR:  0xb303
 * DEVAD:    1
 * DESC:     latched message 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MSG0             latched message 0, initial value is unknown
 */
#define BCMI_MADURA_MESSAGE0r (0x0001b303 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MESSAGE0r_SIZE 4

/*
 * This structure should be used to declare and program MESSAGE0.
 */
typedef union BCMI_MADURA_MESSAGE0r_s {
	uint32_t v[1];
	uint32_t message0[1];
	uint32_t _message0;
} BCMI_MADURA_MESSAGE0r_t;

#define BCMI_MADURA_MESSAGE0r_CLR(r) (r).message0[0] = 0
#define BCMI_MADURA_MESSAGE0r_SET(r,d) (r).message0[0] = d
#define BCMI_MADURA_MESSAGE0r_GET(r) (r).message0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MESSAGE0r_MSG0f_GET(r) (((r).message0[0]) & 0xffff)
#define BCMI_MADURA_MESSAGE0r_MSG0f_SET(r,f) (r).message0[0]=(((r).message0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MESSAGE0.
 */
#define BCMI_MADURA_READ_MESSAGE0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MESSAGE0r,_r._message0)
#define BCMI_MADURA_WRITE_MESSAGE0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MESSAGE0r,_r._message0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MESSAGE0r BCMI_MADURA_MESSAGE0r
#define MESSAGE0r_SIZE BCMI_MADURA_MESSAGE0r_SIZE
typedef BCMI_MADURA_MESSAGE0r_t MESSAGE0r_t;
#define MESSAGE0r_CLR BCMI_MADURA_MESSAGE0r_CLR
#define MESSAGE0r_SET BCMI_MADURA_MESSAGE0r_SET
#define MESSAGE0r_GET BCMI_MADURA_MESSAGE0r_GET
#define MESSAGE0r_MSG0f_GET BCMI_MADURA_MESSAGE0r_MSG0f_GET
#define MESSAGE0r_MSG0f_SET BCMI_MADURA_MESSAGE0r_MSG0f_SET
#define READ_MESSAGE0r BCMI_MADURA_READ_MESSAGE0r
#define WRITE_MESSAGE0r BCMI_MADURA_WRITE_MESSAGE0r
#define MODIFY_MESSAGE0r BCMI_MADURA_MODIFY_MESSAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MESSAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MESSAGE1
 * BLOCKS:   MSG_SNF
 * REGADDR:  0xb304
 * DEVAD:    1
 * DESC:     latched message 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MSG1             latched message 1, initial value is unknown
 */
#define BCMI_MADURA_MESSAGE1r (0x0001b304 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MESSAGE1r_SIZE 4

/*
 * This structure should be used to declare and program MESSAGE1.
 */
typedef union BCMI_MADURA_MESSAGE1r_s {
	uint32_t v[1];
	uint32_t message1[1];
	uint32_t _message1;
} BCMI_MADURA_MESSAGE1r_t;

#define BCMI_MADURA_MESSAGE1r_CLR(r) (r).message1[0] = 0
#define BCMI_MADURA_MESSAGE1r_SET(r,d) (r).message1[0] = d
#define BCMI_MADURA_MESSAGE1r_GET(r) (r).message1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MESSAGE1r_MSG1f_GET(r) (((r).message1[0]) & 0xffff)
#define BCMI_MADURA_MESSAGE1r_MSG1f_SET(r,f) (r).message1[0]=(((r).message1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MESSAGE1.
 */
#define BCMI_MADURA_READ_MESSAGE1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MESSAGE1r,_r._message1)
#define BCMI_MADURA_WRITE_MESSAGE1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MESSAGE1r,_r._message1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MESSAGE1r BCMI_MADURA_MESSAGE1r
#define MESSAGE1r_SIZE BCMI_MADURA_MESSAGE1r_SIZE
typedef BCMI_MADURA_MESSAGE1r_t MESSAGE1r_t;
#define MESSAGE1r_CLR BCMI_MADURA_MESSAGE1r_CLR
#define MESSAGE1r_SET BCMI_MADURA_MESSAGE1r_SET
#define MESSAGE1r_GET BCMI_MADURA_MESSAGE1r_GET
#define MESSAGE1r_MSG1f_GET BCMI_MADURA_MESSAGE1r_MSG1f_GET
#define MESSAGE1r_MSG1f_SET BCMI_MADURA_MESSAGE1r_MSG1f_SET
#define READ_MESSAGE1r BCMI_MADURA_READ_MESSAGE1r
#define WRITE_MESSAGE1r BCMI_MADURA_WRITE_MESSAGE1r
#define MODIFY_MESSAGE1r BCMI_MADURA_MODIFY_MESSAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MESSAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MESSAGE2
 * BLOCKS:   MSG_SNF
 * REGADDR:  0xb305
 * DEVAD:    1
 * DESC:     latched message 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MSG2             latched message 2, initial value is unknown
 */
#define BCMI_MADURA_MESSAGE2r (0x0001b305 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MESSAGE2r_SIZE 4

/*
 * This structure should be used to declare and program MESSAGE2.
 */
typedef union BCMI_MADURA_MESSAGE2r_s {
	uint32_t v[1];
	uint32_t message2[1];
	uint32_t _message2;
} BCMI_MADURA_MESSAGE2r_t;

#define BCMI_MADURA_MESSAGE2r_CLR(r) (r).message2[0] = 0
#define BCMI_MADURA_MESSAGE2r_SET(r,d) (r).message2[0] = d
#define BCMI_MADURA_MESSAGE2r_GET(r) (r).message2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MESSAGE2r_MSG2f_GET(r) (((r).message2[0]) & 0xffff)
#define BCMI_MADURA_MESSAGE2r_MSG2f_SET(r,f) (r).message2[0]=(((r).message2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MESSAGE2.
 */
#define BCMI_MADURA_READ_MESSAGE2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MESSAGE2r,_r._message2)
#define BCMI_MADURA_WRITE_MESSAGE2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MESSAGE2r,_r._message2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MESSAGE2r BCMI_MADURA_MESSAGE2r
#define MESSAGE2r_SIZE BCMI_MADURA_MESSAGE2r_SIZE
typedef BCMI_MADURA_MESSAGE2r_t MESSAGE2r_t;
#define MESSAGE2r_CLR BCMI_MADURA_MESSAGE2r_CLR
#define MESSAGE2r_SET BCMI_MADURA_MESSAGE2r_SET
#define MESSAGE2r_GET BCMI_MADURA_MESSAGE2r_GET
#define MESSAGE2r_MSG2f_GET BCMI_MADURA_MESSAGE2r_MSG2f_GET
#define MESSAGE2r_MSG2f_SET BCMI_MADURA_MESSAGE2r_MSG2f_SET
#define READ_MESSAGE2r BCMI_MADURA_READ_MESSAGE2r
#define WRITE_MESSAGE2r BCMI_MADURA_WRITE_MESSAGE2r
#define MODIFY_MESSAGE2r BCMI_MADURA_MODIFY_MESSAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MESSAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MESSAGE3
 * BLOCKS:   MSG_SNF
 * REGADDR:  0xb306
 * DEVAD:    1
 * DESC:     latched message 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MSG3             latched message 3, initial value is unknown
 */
#define BCMI_MADURA_MESSAGE3r (0x0001b306 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MESSAGE3r_SIZE 4

/*
 * This structure should be used to declare and program MESSAGE3.
 */
typedef union BCMI_MADURA_MESSAGE3r_s {
	uint32_t v[1];
	uint32_t message3[1];
	uint32_t _message3;
} BCMI_MADURA_MESSAGE3r_t;

#define BCMI_MADURA_MESSAGE3r_CLR(r) (r).message3[0] = 0
#define BCMI_MADURA_MESSAGE3r_SET(r,d) (r).message3[0] = d
#define BCMI_MADURA_MESSAGE3r_GET(r) (r).message3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MESSAGE3r_MSG3f_GET(r) (((r).message3[0]) & 0xffff)
#define BCMI_MADURA_MESSAGE3r_MSG3f_SET(r,f) (r).message3[0]=(((r).message3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MESSAGE3.
 */
#define BCMI_MADURA_READ_MESSAGE3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MESSAGE3r,_r._message3)
#define BCMI_MADURA_WRITE_MESSAGE3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MESSAGE3r,_r._message3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MESSAGE3r BCMI_MADURA_MESSAGE3r
#define MESSAGE3r_SIZE BCMI_MADURA_MESSAGE3r_SIZE
typedef BCMI_MADURA_MESSAGE3r_t MESSAGE3r_t;
#define MESSAGE3r_CLR BCMI_MADURA_MESSAGE3r_CLR
#define MESSAGE3r_SET BCMI_MADURA_MESSAGE3r_SET
#define MESSAGE3r_GET BCMI_MADURA_MESSAGE3r_GET
#define MESSAGE3r_MSG3f_GET BCMI_MADURA_MESSAGE3r_MSG3f_GET
#define MESSAGE3r_MSG3f_SET BCMI_MADURA_MESSAGE3r_MSG3f_SET
#define READ_MESSAGE3r BCMI_MADURA_READ_MESSAGE3r
#define WRITE_MESSAGE3r BCMI_MADURA_WRITE_MESSAGE3r
#define MODIFY_MESSAGE3r BCMI_MADURA_MODIFY_MESSAGE3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MESSAGE3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  COMMON_CTL
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc00
 * DEVAD:    1
 * DESC:     clocks and reset control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_POR_H_RSTB_FRCVAL power on reset, active low
 *     PMD_POR_H_RSTB_FRC If this bit is set; then software can bypass the hardware state machine driven controls for that specific signal or signal group
 *     PMD_CORE_PLL0_DP_H_RSTB_FRCVAL pll0 data path reset, active low
 *     PMD_CORE_PLL0_DP_H_RSTB_FRC If this bit is set; then software can bypass the hardware state machine driven controls for that specific signal or signal group
 *     PMD_CORE_PLL1_DP_H_RSTB_FRCVAL pll1 data path reset, active low
 *     PMD_CORE_PLL1_DP_H_RSTB_FRC If this bit is set; then software can bypass the hardware state machine driven controls for that specific signal or signal group
 *     PMD_IDDQ         enable iddq testing
 *     TX_DRV_HV_DISABLE if set to one then the high voltage drive is disabled
 */
#define BCMI_MADURA_COMMON_CTLr (0x0001bc00 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_COMMON_CTLr_SIZE 4

/*
 * This structure should be used to declare and program COMMON_CTL.
 */
typedef union BCMI_MADURA_COMMON_CTLr_s {
	uint32_t v[1];
	uint32_t common_ctl[1];
	uint32_t _common_ctl;
} BCMI_MADURA_COMMON_CTLr_t;

#define BCMI_MADURA_COMMON_CTLr_CLR(r) (r).common_ctl[0] = 0
#define BCMI_MADURA_COMMON_CTLr_SET(r,d) (r).common_ctl[0] = d
#define BCMI_MADURA_COMMON_CTLr_GET(r) (r).common_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_COMMON_CTLr_TX_DRV_HV_DISABLEf_GET(r) ((((r).common_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_TX_DRV_HV_DISABLEf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_COMMON_CTLr_PMD_IDDQf_GET(r) ((((r).common_ctl[0]) >> 8) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_PMD_IDDQf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCf_GET(r) ((((r).common_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCVALf_GET(r) ((((r).common_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCVALf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCf_GET(r) ((((r).common_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCVALf_GET(r) ((((r).common_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCVALf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCf_GET(r) ((((r).common_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCVALf_GET(r) (((r).common_ctl[0]) & 0x1)
#define BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCVALf_SET(r,f) (r).common_ctl[0]=(((r).common_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access COMMON_CTL.
 */
#define BCMI_MADURA_READ_COMMON_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_COMMON_CTLr,_r._common_ctl)
#define BCMI_MADURA_WRITE_COMMON_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_COMMON_CTLr,_r._common_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define COMMON_CTLr BCMI_MADURA_COMMON_CTLr
#define COMMON_CTLr_SIZE BCMI_MADURA_COMMON_CTLr_SIZE
typedef BCMI_MADURA_COMMON_CTLr_t COMMON_CTLr_t;
#define COMMON_CTLr_CLR BCMI_MADURA_COMMON_CTLr_CLR
#define COMMON_CTLr_SET BCMI_MADURA_COMMON_CTLr_SET
#define COMMON_CTLr_GET BCMI_MADURA_COMMON_CTLr_GET
#define COMMON_CTLr_TX_DRV_HV_DISABLEf_GET BCMI_MADURA_COMMON_CTLr_TX_DRV_HV_DISABLEf_GET
#define COMMON_CTLr_TX_DRV_HV_DISABLEf_SET BCMI_MADURA_COMMON_CTLr_TX_DRV_HV_DISABLEf_SET
#define COMMON_CTLr_PMD_IDDQf_GET BCMI_MADURA_COMMON_CTLr_PMD_IDDQf_GET
#define COMMON_CTLr_PMD_IDDQf_SET BCMI_MADURA_COMMON_CTLr_PMD_IDDQf_SET
#define COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCf_GET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCf_GET
#define COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCf_SET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCf_SET
#define COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCVALf_GET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCVALf_GET
#define COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCVALf_SET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL1_DP_H_RSTB_FRCVALf_SET
#define COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCf_GET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCf_GET
#define COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCf_SET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCf_SET
#define COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCVALf_GET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCVALf_GET
#define COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCVALf_SET BCMI_MADURA_COMMON_CTLr_PMD_CORE_PLL0_DP_H_RSTB_FRCVALf_SET
#define COMMON_CTLr_PMD_POR_H_RSTB_FRCf_GET BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCf_GET
#define COMMON_CTLr_PMD_POR_H_RSTB_FRCf_SET BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCf_SET
#define COMMON_CTLr_PMD_POR_H_RSTB_FRCVALf_GET BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCVALf_GET
#define COMMON_CTLr_PMD_POR_H_RSTB_FRCVALf_SET BCMI_MADURA_COMMON_CTLr_PMD_POR_H_RSTB_FRCVALf_SET
#define READ_COMMON_CTLr BCMI_MADURA_READ_COMMON_CTLr
#define WRITE_COMMON_CTLr BCMI_MADURA_WRITE_COMMON_CTLr
#define MODIFY_COMMON_CTLr BCMI_MADURA_MODIFY_COMMON_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_COMMON_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RESCAL
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc01
 * DEVAD:    1
 * DESC:     resistor calibration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_RESCAL_FRCVAL resistor calibration value
 *     PMD_RESCAL_FRC   select the programmed value
 *     PMD_RESCAL_DONE_BYPASS select the programmed value
 */
#define BCMI_MADURA_RESCALr (0x0001bc01 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RESCALr_SIZE 4

/*
 * This structure should be used to declare and program RESCAL.
 */
typedef union BCMI_MADURA_RESCALr_s {
	uint32_t v[1];
	uint32_t rescal[1];
	uint32_t _rescal;
} BCMI_MADURA_RESCALr_t;

#define BCMI_MADURA_RESCALr_CLR(r) (r).rescal[0] = 0
#define BCMI_MADURA_RESCALr_SET(r,d) (r).rescal[0] = d
#define BCMI_MADURA_RESCALr_GET(r) (r).rescal[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RESCALr_PMD_RESCAL_DONE_BYPASSf_GET(r) ((((r).rescal[0]) >> 5) & 0x1)
#define BCMI_MADURA_RESCALr_PMD_RESCAL_DONE_BYPASSf_SET(r,f) (r).rescal[0]=(((r).rescal[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_RESCALr_PMD_RESCAL_FRCf_GET(r) ((((r).rescal[0]) >> 4) & 0x1)
#define BCMI_MADURA_RESCALr_PMD_RESCAL_FRCf_SET(r,f) (r).rescal[0]=(((r).rescal[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_RESCALr_PMD_RESCAL_FRCVALf_GET(r) (((r).rescal[0]) & 0xf)
#define BCMI_MADURA_RESCALr_PMD_RESCAL_FRCVALf_SET(r,f) (r).rescal[0]=(((r).rescal[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RESCAL.
 */
#define BCMI_MADURA_READ_RESCALr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RESCALr,_r._rescal)
#define BCMI_MADURA_WRITE_RESCALr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RESCALr,_r._rescal)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RESCALr BCMI_MADURA_RESCALr
#define RESCALr_SIZE BCMI_MADURA_RESCALr_SIZE
typedef BCMI_MADURA_RESCALr_t RESCALr_t;
#define RESCALr_CLR BCMI_MADURA_RESCALr_CLR
#define RESCALr_SET BCMI_MADURA_RESCALr_SET
#define RESCALr_GET BCMI_MADURA_RESCALr_GET
#define RESCALr_PMD_RESCAL_DONE_BYPASSf_GET BCMI_MADURA_RESCALr_PMD_RESCAL_DONE_BYPASSf_GET
#define RESCALr_PMD_RESCAL_DONE_BYPASSf_SET BCMI_MADURA_RESCALr_PMD_RESCAL_DONE_BYPASSf_SET
#define RESCALr_PMD_RESCAL_FRCf_GET BCMI_MADURA_RESCALr_PMD_RESCAL_FRCf_GET
#define RESCALr_PMD_RESCAL_FRCf_SET BCMI_MADURA_RESCALr_PMD_RESCAL_FRCf_SET
#define RESCALr_PMD_RESCAL_FRCVALf_GET BCMI_MADURA_RESCALr_PMD_RESCAL_FRCVALf_GET
#define RESCALr_PMD_RESCAL_FRCVALf_SET BCMI_MADURA_RESCALr_PMD_RESCAL_FRCVALf_SET
#define READ_RESCALr BCMI_MADURA_READ_RESCALr
#define WRITE_RESCALr BCMI_MADURA_WRITE_RESCALr
#define MODIFY_RESCALr BCMI_MADURA_MODIFY_RESCALr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RESCALr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  WDOG_CTL
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc02
 * DEVAD:    1
 * DESC:     PMI watchdog control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMI_ARB_WDOG_EN  PMI watchdog timer enable.
 */
#define BCMI_MADURA_WDOG_CTLr (0x0001bc02 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_WDOG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program WDOG_CTL.
 */
typedef union BCMI_MADURA_WDOG_CTLr_s {
	uint32_t v[1];
	uint32_t wdog_ctl[1];
	uint32_t _wdog_ctl;
} BCMI_MADURA_WDOG_CTLr_t;

#define BCMI_MADURA_WDOG_CTLr_CLR(r) (r).wdog_ctl[0] = 0
#define BCMI_MADURA_WDOG_CTLr_SET(r,d) (r).wdog_ctl[0] = d
#define BCMI_MADURA_WDOG_CTLr_GET(r) (r).wdog_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_WDOG_CTLr_PMI_ARB_WDOG_ENf_GET(r) (((r).wdog_ctl[0]) & 0x1)
#define BCMI_MADURA_WDOG_CTLr_PMI_ARB_WDOG_ENf_SET(r,f) (r).wdog_ctl[0]=(((r).wdog_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access WDOG_CTL.
 */
#define BCMI_MADURA_READ_WDOG_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_WDOG_CTLr,_r._wdog_ctl)
#define BCMI_MADURA_WRITE_WDOG_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_WDOG_CTLr,_r._wdog_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define WDOG_CTLr BCMI_MADURA_WDOG_CTLr
#define WDOG_CTLr_SIZE BCMI_MADURA_WDOG_CTLr_SIZE
typedef BCMI_MADURA_WDOG_CTLr_t WDOG_CTLr_t;
#define WDOG_CTLr_CLR BCMI_MADURA_WDOG_CTLr_CLR
#define WDOG_CTLr_SET BCMI_MADURA_WDOG_CTLr_SET
#define WDOG_CTLr_GET BCMI_MADURA_WDOG_CTLr_GET
#define WDOG_CTLr_PMI_ARB_WDOG_ENf_GET BCMI_MADURA_WDOG_CTLr_PMI_ARB_WDOG_ENf_GET
#define WDOG_CTLr_PMI_ARB_WDOG_ENf_SET BCMI_MADURA_WDOG_CTLr_PMI_ARB_WDOG_ENf_SET
#define READ_WDOG_CTLr BCMI_MADURA_READ_WDOG_CTLr
#define WRITE_WDOG_CTLr BCMI_MADURA_WRITE_WDOG_CTLr
#define MODIFY_WDOG_CTLr BCMI_MADURA_MODIFY_WDOG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_WDOG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  WDOG_STS
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc03
 * DEVAD:    1
 * DESC:     PMI watchdog status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMI_ARB_ERROR_LH Latched high status of pmi_arb_error signal
 */
#define BCMI_MADURA_WDOG_STSr (0x0001bc03 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_WDOG_STSr_SIZE 4

/*
 * This structure should be used to declare and program WDOG_STS.
 */
typedef union BCMI_MADURA_WDOG_STSr_s {
	uint32_t v[1];
	uint32_t wdog_sts[1];
	uint32_t _wdog_sts;
} BCMI_MADURA_WDOG_STSr_t;

#define BCMI_MADURA_WDOG_STSr_CLR(r) (r).wdog_sts[0] = 0
#define BCMI_MADURA_WDOG_STSr_SET(r,d) (r).wdog_sts[0] = d
#define BCMI_MADURA_WDOG_STSr_GET(r) (r).wdog_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_WDOG_STSr_PMI_ARB_ERROR_LHf_GET(r) (((r).wdog_sts[0]) & 0x1)
#define BCMI_MADURA_WDOG_STSr_PMI_ARB_ERROR_LHf_SET(r,f) (r).wdog_sts[0]=(((r).wdog_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access WDOG_STS.
 */
#define BCMI_MADURA_READ_WDOG_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_WDOG_STSr,_r._wdog_sts)
#define BCMI_MADURA_WRITE_WDOG_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_WDOG_STSr,_r._wdog_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define WDOG_STSr BCMI_MADURA_WDOG_STSr
#define WDOG_STSr_SIZE BCMI_MADURA_WDOG_STSr_SIZE
typedef BCMI_MADURA_WDOG_STSr_t WDOG_STSr_t;
#define WDOG_STSr_CLR BCMI_MADURA_WDOG_STSr_CLR
#define WDOG_STSr_SET BCMI_MADURA_WDOG_STSr_SET
#define WDOG_STSr_GET BCMI_MADURA_WDOG_STSr_GET
#define WDOG_STSr_PMI_ARB_ERROR_LHf_GET BCMI_MADURA_WDOG_STSr_PMI_ARB_ERROR_LHf_GET
#define WDOG_STSr_PMI_ARB_ERROR_LHf_SET BCMI_MADURA_WDOG_STSr_PMI_ARB_ERROR_LHf_SET
#define READ_WDOG_STSr BCMI_MADURA_READ_WDOG_STSr
#define WRITE_WDOG_STSr BCMI_MADURA_WRITE_WDOG_STSr
#define MODIFY_WDOG_STSr BCMI_MADURA_MODIFY_WDOG_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_WDOG_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_CORE_MODE_CTL
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc04
 * DEVAD:    1
 * DESC:     pmd_core_mode setting
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_CORE_MODE    connects to pmd_core_mode[15:0] falcon core inputs
 */
#define BCMI_MADURA_PMD_CORE_MODE_CTLr (0x0001bc04 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_CORE_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_CORE_MODE_CTL.
 */
typedef union BCMI_MADURA_PMD_CORE_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_core_mode_ctl[1];
	uint32_t _pmd_core_mode_ctl;
} BCMI_MADURA_PMD_CORE_MODE_CTLr_t;

#define BCMI_MADURA_PMD_CORE_MODE_CTLr_CLR(r) (r).pmd_core_mode_ctl[0] = 0
#define BCMI_MADURA_PMD_CORE_MODE_CTLr_SET(r,d) (r).pmd_core_mode_ctl[0] = d
#define BCMI_MADURA_PMD_CORE_MODE_CTLr_GET(r) (r).pmd_core_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_CORE_MODE_CTLr_PMD_CORE_MODEf_GET(r) (((r).pmd_core_mode_ctl[0]) & 0xffff)
#define BCMI_MADURA_PMD_CORE_MODE_CTLr_PMD_CORE_MODEf_SET(r,f) (r).pmd_core_mode_ctl[0]=(((r).pmd_core_mode_ctl[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_CORE_MODE_CTL.
 */
#define BCMI_MADURA_READ_PMD_CORE_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_CORE_MODE_CTLr,_r._pmd_core_mode_ctl)
#define BCMI_MADURA_WRITE_PMD_CORE_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_CORE_MODE_CTLr,_r._pmd_core_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_CORE_MODE_CTLr BCMI_MADURA_PMD_CORE_MODE_CTLr
#define PMD_CORE_MODE_CTLr_SIZE BCMI_MADURA_PMD_CORE_MODE_CTLr_SIZE
typedef BCMI_MADURA_PMD_CORE_MODE_CTLr_t PMD_CORE_MODE_CTLr_t;
#define PMD_CORE_MODE_CTLr_CLR BCMI_MADURA_PMD_CORE_MODE_CTLr_CLR
#define PMD_CORE_MODE_CTLr_SET BCMI_MADURA_PMD_CORE_MODE_CTLr_SET
#define PMD_CORE_MODE_CTLr_GET BCMI_MADURA_PMD_CORE_MODE_CTLr_GET
#define PMD_CORE_MODE_CTLr_PMD_CORE_MODEf_GET BCMI_MADURA_PMD_CORE_MODE_CTLr_PMD_CORE_MODEf_GET
#define PMD_CORE_MODE_CTLr_PMD_CORE_MODEf_SET BCMI_MADURA_PMD_CORE_MODE_CTLr_PMD_CORE_MODEf_SET
#define READ_PMD_CORE_MODE_CTLr BCMI_MADURA_READ_PMD_CORE_MODE_CTLr
#define WRITE_PMD_CORE_MODE_CTLr BCMI_MADURA_WRITE_PMD_CORE_MODE_CTLr
#define MODIFY_PMD_CORE_MODE_CTLr BCMI_MADURA_MODIFY_PMD_CORE_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_CORE_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_PLL_STS
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc05
 * DEVAD:    1
 * DESC:     PLL lock indicator
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_PLL0_LOCK    this is a status indication for pll 0 lock
 *     PMD_PLL1_LOCK    this is a status indication for pll 1 lock
 */
#define BCMI_MADURA_PMD_PLL_STSr (0x0001bc05 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_PLL_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_PLL_STS.
 */
typedef union BCMI_MADURA_PMD_PLL_STSr_s {
	uint32_t v[1];
	uint32_t pmd_pll_sts[1];
	uint32_t _pmd_pll_sts;
} BCMI_MADURA_PMD_PLL_STSr_t;

#define BCMI_MADURA_PMD_PLL_STSr_CLR(r) (r).pmd_pll_sts[0] = 0
#define BCMI_MADURA_PMD_PLL_STSr_SET(r,d) (r).pmd_pll_sts[0] = d
#define BCMI_MADURA_PMD_PLL_STSr_GET(r) (r).pmd_pll_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_PLL_STSr_PMD_PLL1_LOCKf_GET(r) ((((r).pmd_pll_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_PMD_PLL_STSr_PMD_PLL1_LOCKf_SET(r,f) (r).pmd_pll_sts[0]=(((r).pmd_pll_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PMD_PLL_STSr_PMD_PLL0_LOCKf_GET(r) (((r).pmd_pll_sts[0]) & 0x1)
#define BCMI_MADURA_PMD_PLL_STSr_PMD_PLL0_LOCKf_SET(r,f) (r).pmd_pll_sts[0]=(((r).pmd_pll_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_PLL_STS.
 */
#define BCMI_MADURA_READ_PMD_PLL_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_PLL_STSr,_r._pmd_pll_sts)
#define BCMI_MADURA_WRITE_PMD_PLL_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_PLL_STSr,_r._pmd_pll_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_PLL_STSr BCMI_MADURA_PMD_PLL_STSr
#define PMD_PLL_STSr_SIZE BCMI_MADURA_PMD_PLL_STSr_SIZE
typedef BCMI_MADURA_PMD_PLL_STSr_t PMD_PLL_STSr_t;
#define PMD_PLL_STSr_CLR BCMI_MADURA_PMD_PLL_STSr_CLR
#define PMD_PLL_STSr_SET BCMI_MADURA_PMD_PLL_STSr_SET
#define PMD_PLL_STSr_GET BCMI_MADURA_PMD_PLL_STSr_GET
#define PMD_PLL_STSr_PMD_PLL1_LOCKf_GET BCMI_MADURA_PMD_PLL_STSr_PMD_PLL1_LOCKf_GET
#define PMD_PLL_STSr_PMD_PLL1_LOCKf_SET BCMI_MADURA_PMD_PLL_STSr_PMD_PLL1_LOCKf_SET
#define PMD_PLL_STSr_PMD_PLL0_LOCKf_GET BCMI_MADURA_PMD_PLL_STSr_PMD_PLL0_LOCKf_GET
#define PMD_PLL_STSr_PMD_PLL0_LOCKf_SET BCMI_MADURA_PMD_PLL_STSr_PMD_PLL0_LOCKf_SET
#define READ_PMD_PLL_STSr BCMI_MADURA_READ_PMD_PLL_STSr
#define WRITE_PMD_PLL_STSr BCMI_MADURA_WRITE_PMD_PLL_STSr
#define MODIFY_PMD_PLL_STSr BCMI_MADURA_MODIFY_PMD_PLL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_PLL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AFE_CLK_CTL
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc06
 * DEVAD:    1
 * DESC:     control AFE clock sources and dividers
 * RESETVAL: 0x16b (363)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL1_LCREF_SEL   Programming this to 0 will use the buffered version of ref clock instead of pad refclockTo be used only for debug
 *     PLL1_REFOUT_EN   Programming this to 0 will turn off buffered ref clock and cut off connection to other PLLTo be used to save power.
 *     PLL1_REFIN_EN    Programming this to 1 will allow selection of ref clock1 for PLL1By default PLL1 is associated with ref clock2
 *     PLL1_PMD_REFCLK_DIV4 Enable divide by 4 on AFE clock pll1_pmd_refclkonly valid in CDR3.0 pkg
 *     PLL1_PMD_REFCLK_DIV2 Enable divide by 2 on AFE clock pll1_pmd_refclkonly valid in CDR3.0 pkg
 *     PLL0_LCREF_SEL   Programming this to 0 will use the buffered version of ref clock instead of pad refclockTo be used only for debug
 *     PLL0_REFOUT_EN   Programming this to 0 will turn off buffered ref clock and cut off connection to other PLLTo be used to save power.
 *     PLL0_REFIN_EN    Programming this to 1 will allow selection of ref clock2 for PLL0By default PLL0 is associated with ref clock1
 *     PLL0_PMD_REFCLK_DIV4 Enable divide by 4 on AFE clock pll0_pmd_refclkonly valid in CDR3.0 pkg
 *     PLL0_PMD_REFCLK_DIV2 Enable divide by 2 on AFE clock pll0_pmd_refclkonly valid in CDR3.0 pkg
 */
#define BCMI_MADURA_AFE_CLK_CTLr (0x0001bc06 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AFE_CLK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AFE_CLK_CTL.
 */
typedef union BCMI_MADURA_AFE_CLK_CTLr_s {
	uint32_t v[1];
	uint32_t afe_clk_ctl[1];
	uint32_t _afe_clk_ctl;
} BCMI_MADURA_AFE_CLK_CTLr_t;

#define BCMI_MADURA_AFE_CLK_CTLr_CLR(r) (r).afe_clk_ctl[0] = 0
#define BCMI_MADURA_AFE_CLK_CTLr_SET(r,d) (r).afe_clk_ctl[0] = d
#define BCMI_MADURA_AFE_CLK_CTLr_GET(r) (r).afe_clk_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV2f_GET(r) ((((r).afe_clk_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV2f_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV4f_GET(r) ((((r).afe_clk_ctl[0]) >> 8) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV4f_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFIN_ENf_GET(r) ((((r).afe_clk_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFIN_ENf_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFOUT_ENf_GET(r) ((((r).afe_clk_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFOUT_ENf_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_LCREF_SELf_GET(r) ((((r).afe_clk_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL0_LCREF_SELf_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV2f_GET(r) ((((r).afe_clk_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV2f_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV4f_GET(r) ((((r).afe_clk_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV4f_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFIN_ENf_GET(r) ((((r).afe_clk_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFIN_ENf_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFOUT_ENf_GET(r) ((((r).afe_clk_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFOUT_ENf_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_LCREF_SELf_GET(r) (((r).afe_clk_ctl[0]) & 0x1)
#define BCMI_MADURA_AFE_CLK_CTLr_PLL1_LCREF_SELf_SET(r,f) (r).afe_clk_ctl[0]=(((r).afe_clk_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AFE_CLK_CTL.
 */
#define BCMI_MADURA_READ_AFE_CLK_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AFE_CLK_CTLr,_r._afe_clk_ctl)
#define BCMI_MADURA_WRITE_AFE_CLK_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AFE_CLK_CTLr,_r._afe_clk_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AFE_CLK_CTLr BCMI_MADURA_AFE_CLK_CTLr
#define AFE_CLK_CTLr_SIZE BCMI_MADURA_AFE_CLK_CTLr_SIZE
typedef BCMI_MADURA_AFE_CLK_CTLr_t AFE_CLK_CTLr_t;
#define AFE_CLK_CTLr_CLR BCMI_MADURA_AFE_CLK_CTLr_CLR
#define AFE_CLK_CTLr_SET BCMI_MADURA_AFE_CLK_CTLr_SET
#define AFE_CLK_CTLr_GET BCMI_MADURA_AFE_CLK_CTLr_GET
#define AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV2f_GET BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV2f_GET
#define AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV2f_SET BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV2f_SET
#define AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV4f_GET BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV4f_GET
#define AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV4f_SET BCMI_MADURA_AFE_CLK_CTLr_PLL0_PMD_REFCLK_DIV4f_SET
#define AFE_CLK_CTLr_PLL0_REFIN_ENf_GET BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFIN_ENf_GET
#define AFE_CLK_CTLr_PLL0_REFIN_ENf_SET BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFIN_ENf_SET
#define AFE_CLK_CTLr_PLL0_REFOUT_ENf_GET BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFOUT_ENf_GET
#define AFE_CLK_CTLr_PLL0_REFOUT_ENf_SET BCMI_MADURA_AFE_CLK_CTLr_PLL0_REFOUT_ENf_SET
#define AFE_CLK_CTLr_PLL0_LCREF_SELf_GET BCMI_MADURA_AFE_CLK_CTLr_PLL0_LCREF_SELf_GET
#define AFE_CLK_CTLr_PLL0_LCREF_SELf_SET BCMI_MADURA_AFE_CLK_CTLr_PLL0_LCREF_SELf_SET
#define AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV2f_GET BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV2f_GET
#define AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV2f_SET BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV2f_SET
#define AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV4f_GET BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV4f_GET
#define AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV4f_SET BCMI_MADURA_AFE_CLK_CTLr_PLL1_PMD_REFCLK_DIV4f_SET
#define AFE_CLK_CTLr_PLL1_REFIN_ENf_GET BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFIN_ENf_GET
#define AFE_CLK_CTLr_PLL1_REFIN_ENf_SET BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFIN_ENf_SET
#define AFE_CLK_CTLr_PLL1_REFOUT_ENf_GET BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFOUT_ENf_GET
#define AFE_CLK_CTLr_PLL1_REFOUT_ENf_SET BCMI_MADURA_AFE_CLK_CTLr_PLL1_REFOUT_ENf_SET
#define AFE_CLK_CTLr_PLL1_LCREF_SELf_GET BCMI_MADURA_AFE_CLK_CTLr_PLL1_LCREF_SELf_GET
#define AFE_CLK_CTLr_PLL1_LCREF_SELf_SET BCMI_MADURA_AFE_CLK_CTLr_PLL1_LCREF_SELf_SET
#define READ_AFE_CLK_CTLr BCMI_MADURA_READ_AFE_CLK_CTLr
#define WRITE_AFE_CLK_CTLr BCMI_MADURA_WRITE_AFE_CLK_CTLr
#define MODIFY_AFE_CLK_CTLr BCMI_MADURA_MODIFY_AFE_CLK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AFE_CLK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RTERM_CTL
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc07
 * DEVAD:    1
 * DESC:     RTERM controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL1_RTERMHIZ    Enable RTERM HiZ for Falcon ref clock termination.
 *     PLL1_RTERM600_FRCVAL Forced value for rterm 600 ohms
 *     PLL1_RTERM600_FRC Force bit for rterm 600 ohms
 *     PLL1_RTERM400_FRCVAL Forced value for rterm 400 ohms
 *     PLL1_RTERM400_FRC Force bit for rterm 400 ohms
 *     PLL1_RTERM200_FRCVAL Forced value for rterm 200 ohms
 *     PLL1_RTERM200_FRC Force bit for rterm 200 ohms
 *     PLL0_RTERMHIZ    Enable RTERM HiZ for Falcon ref clock termination.
 *     PLL0_RTERM600_FRCVAL Forced value for rterm 600 ohms
 *     PLL0_RTERM600_FRC Force bit for rterm 600 ohms
 *     PLL0_RTERM400_FRCVAL Forced value for rterm 400 ohms
 *     PLL0_RTERM400_FRC Force bit for rterm 400 ohms
 *     PLL0_RTERM200_FRCVAL Forced value for rterm 200 ohms
 *     PLL0_RTERM200_FRC Force bit for rterm 200 ohms
 */
#define BCMI_MADURA_RTERM_CTLr (0x0001bc07 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RTERM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RTERM_CTL.
 */
typedef union BCMI_MADURA_RTERM_CTLr_s {
	uint32_t v[1];
	uint32_t rterm_ctl[1];
	uint32_t _rterm_ctl;
} BCMI_MADURA_RTERM_CTLr_t;

#define BCMI_MADURA_RTERM_CTLr_CLR(r) (r).rterm_ctl[0] = 0
#define BCMI_MADURA_RTERM_CTLr_SET(r,d) (r).rterm_ctl[0] = d
#define BCMI_MADURA_RTERM_CTLr_GET(r) (r).rterm_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCf_GET(r) ((((r).rterm_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCVALf_GET(r) ((((r).rterm_ctl[0]) >> 13) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCVALf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCf_GET(r) ((((r).rterm_ctl[0]) >> 12) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCVALf_GET(r) ((((r).rterm_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCVALf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCf_GET(r) ((((r).rterm_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCVALf_GET(r) ((((r).rterm_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCVALf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERMHIZf_GET(r) ((((r).rterm_ctl[0]) >> 8) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL0_RTERMHIZf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCf_GET(r) ((((r).rterm_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCVALf_GET(r) ((((r).rterm_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCVALf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCf_GET(r) ((((r).rterm_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCVALf_GET(r) ((((r).rterm_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCVALf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCf_GET(r) ((((r).rterm_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCVALf_GET(r) ((((r).rterm_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCVALf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERMHIZf_GET(r) (((r).rterm_ctl[0]) & 0x1)
#define BCMI_MADURA_RTERM_CTLr_PLL1_RTERMHIZf_SET(r,f) (r).rterm_ctl[0]=(((r).rterm_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RTERM_CTL.
 */
#define BCMI_MADURA_READ_RTERM_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RTERM_CTLr,_r._rterm_ctl)
#define BCMI_MADURA_WRITE_RTERM_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RTERM_CTLr,_r._rterm_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RTERM_CTLr BCMI_MADURA_RTERM_CTLr
#define RTERM_CTLr_SIZE BCMI_MADURA_RTERM_CTLr_SIZE
typedef BCMI_MADURA_RTERM_CTLr_t RTERM_CTLr_t;
#define RTERM_CTLr_CLR BCMI_MADURA_RTERM_CTLr_CLR
#define RTERM_CTLr_SET BCMI_MADURA_RTERM_CTLr_SET
#define RTERM_CTLr_GET BCMI_MADURA_RTERM_CTLr_GET
#define RTERM_CTLr_PLL0_RTERM200_FRCf_GET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCf_GET
#define RTERM_CTLr_PLL0_RTERM200_FRCf_SET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCf_SET
#define RTERM_CTLr_PLL0_RTERM200_FRCVALf_GET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCVALf_GET
#define RTERM_CTLr_PLL0_RTERM200_FRCVALf_SET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM200_FRCVALf_SET
#define RTERM_CTLr_PLL0_RTERM400_FRCf_GET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCf_GET
#define RTERM_CTLr_PLL0_RTERM400_FRCf_SET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCf_SET
#define RTERM_CTLr_PLL0_RTERM400_FRCVALf_GET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCVALf_GET
#define RTERM_CTLr_PLL0_RTERM400_FRCVALf_SET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM400_FRCVALf_SET
#define RTERM_CTLr_PLL0_RTERM600_FRCf_GET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCf_GET
#define RTERM_CTLr_PLL0_RTERM600_FRCf_SET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCf_SET
#define RTERM_CTLr_PLL0_RTERM600_FRCVALf_GET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCVALf_GET
#define RTERM_CTLr_PLL0_RTERM600_FRCVALf_SET BCMI_MADURA_RTERM_CTLr_PLL0_RTERM600_FRCVALf_SET
#define RTERM_CTLr_PLL0_RTERMHIZf_GET BCMI_MADURA_RTERM_CTLr_PLL0_RTERMHIZf_GET
#define RTERM_CTLr_PLL0_RTERMHIZf_SET BCMI_MADURA_RTERM_CTLr_PLL0_RTERMHIZf_SET
#define RTERM_CTLr_PLL1_RTERM200_FRCf_GET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCf_GET
#define RTERM_CTLr_PLL1_RTERM200_FRCf_SET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCf_SET
#define RTERM_CTLr_PLL1_RTERM200_FRCVALf_GET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCVALf_GET
#define RTERM_CTLr_PLL1_RTERM200_FRCVALf_SET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM200_FRCVALf_SET
#define RTERM_CTLr_PLL1_RTERM400_FRCf_GET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCf_GET
#define RTERM_CTLr_PLL1_RTERM400_FRCf_SET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCf_SET
#define RTERM_CTLr_PLL1_RTERM400_FRCVALf_GET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCVALf_GET
#define RTERM_CTLr_PLL1_RTERM400_FRCVALf_SET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM400_FRCVALf_SET
#define RTERM_CTLr_PLL1_RTERM600_FRCf_GET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCf_GET
#define RTERM_CTLr_PLL1_RTERM600_FRCf_SET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCf_SET
#define RTERM_CTLr_PLL1_RTERM600_FRCVALf_GET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCVALf_GET
#define RTERM_CTLr_PLL1_RTERM600_FRCVALf_SET BCMI_MADURA_RTERM_CTLr_PLL1_RTERM600_FRCVALf_SET
#define RTERM_CTLr_PLL1_RTERMHIZf_GET BCMI_MADURA_RTERM_CTLr_PLL1_RTERMHIZf_GET
#define RTERM_CTLr_PLL1_RTERMHIZf_SET BCMI_MADURA_RTERM_CTLr_PLL1_RTERMHIZf_SET
#define READ_RTERM_CTLr BCMI_MADURA_READ_RTERM_CTLr
#define WRITE_RTERM_CTLr BCMI_MADURA_WRITE_RTERM_CTLr
#define MODIFY_RTERM_CTLr BCMI_MADURA_MODIFY_RTERM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RTERM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SESTO_AFE_CTL_DBG
 * BLOCKS:   FALCON_IF_COMMON
 * REGADDR:  0xbc10
 * DEVAD:    1
 * DESC:     Sesto 2.0 AFE Divider override for debug
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SES_PLL1_PMD_REFCLK_DIV4_FRCVAL Force val bit for overriding the pin div4 value.This applies only to PLL1.
 *     SES_PLL1_PMD_REFCLK_DIV4_FRC Force bit for overriding the pin div4 value.This applies only to PLL1.
 *     SES_PLL1_PMD_REFCLK_DIV2_FRCVAL Force val bit for overriding the pin div2 value.This applies only to PLL1.
 *     SES_PLL1_PMD_REFCLK_DIV2_FRC Force bit for overriding the pin div2 value.This applies only to PLL1.
 *     SES_PLL0_PMD_REFCLK_DIV4_FRCVAL Force val bit for overriding the pin div4 value.This applies only to PLL0.
 *     SES_PLL0_PMD_REFCLK_DIV4_FRC Force bit for overriding the pin div4 value.This applies only to PLL0.
 *     SES_PLL0_PMD_REFCLK_DIV2_FRCVAL Force val bit for overriding the pin div2 value.This applies only to PLL0.
 *     SES_PLL0_PMD_REFCLK_DIV2_FRC Force bit for overriding the pin div2 value.This applies only to PLL0.
 */
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr (0x0001bc10 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SIZE 4

/*
 * This structure should be used to declare and program SESTO_AFE_CTL_DBG.
 */
typedef union BCMI_MADURA_SESTO_AFE_CTL_DBGr_s {
	uint32_t v[1];
	uint32_t sesto_afe_ctl_dbg[1];
	uint32_t _sesto_afe_ctl_dbg;
} BCMI_MADURA_SESTO_AFE_CTL_DBGr_t;

#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_CLR(r) (r).sesto_afe_ctl_dbg[0] = 0
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SET(r,d) (r).sesto_afe_ctl_dbg[0] = d
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_GET(r) (r).sesto_afe_ctl_dbg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 11) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCVALf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 10) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCVALf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 9) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCVALf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 8) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCVALf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 7) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCVALf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 6) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCVALf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 5) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCVALf_GET(r) ((((r).sesto_afe_ctl_dbg[0]) >> 4) & 0x1)
#define BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCVALf_SET(r,f) (r).sesto_afe_ctl_dbg[0]=(((r).sesto_afe_ctl_dbg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access SESTO_AFE_CTL_DBG.
 */
#define BCMI_MADURA_READ_SESTO_AFE_CTL_DBGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SESTO_AFE_CTL_DBGr,_r._sesto_afe_ctl_dbg)
#define BCMI_MADURA_WRITE_SESTO_AFE_CTL_DBGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SESTO_AFE_CTL_DBGr,_r._sesto_afe_ctl_dbg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SESTO_AFE_CTL_DBGr BCMI_MADURA_SESTO_AFE_CTL_DBGr
#define SESTO_AFE_CTL_DBGr_SIZE BCMI_MADURA_SESTO_AFE_CTL_DBGr_SIZE
typedef BCMI_MADURA_SESTO_AFE_CTL_DBGr_t SESTO_AFE_CTL_DBGr_t;
#define SESTO_AFE_CTL_DBGr_CLR BCMI_MADURA_SESTO_AFE_CTL_DBGr_CLR
#define SESTO_AFE_CTL_DBGr_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SET
#define SESTO_AFE_CTL_DBGr_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCf_SET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCVALf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCVALf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCVALf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV2_FRCVALf_SET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCf_SET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCVALf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCVALf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCVALf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL0_PMD_REFCLK_DIV4_FRCVALf_SET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCf_SET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCVALf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCVALf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCVALf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV2_FRCVALf_SET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCf_SET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCVALf_GET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCVALf_GET
#define SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCVALf_SET BCMI_MADURA_SESTO_AFE_CTL_DBGr_SES_PLL1_PMD_REFCLK_DIV4_FRCVALf_SET
#define READ_SESTO_AFE_CTL_DBGr BCMI_MADURA_READ_SESTO_AFE_CTL_DBGr
#define WRITE_SESTO_AFE_CTL_DBGr BCMI_MADURA_WRITE_SESTO_AFE_CTL_DBGr
#define MODIFY_SESTO_AFE_CTL_DBGr BCMI_MADURA_MODIFY_SESTO_AFE_CTL_DBGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SESTO_AFE_CTL_DBGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FALCON_IF_PER_LN_CTL1_PER_LANE
 * BLOCKS:   FALCON_IF_PER_LANE
 * REGADDR:  0xbe00
 * DEVAD:    1
 * DESC:     software control bit to force certain values
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_EXT_LOS_FRCVAL indicate loss of signal
 *     PMD_EXT_LOS_FRC  indicate loss of signal
 *     PMD_TX_DISABLE_FRCVAL squelch signal one  a perlane basis
 *     PMD_TX_DISABLE_FRC If this bit is set the software can bypass the hardware state machine driven controls for that specific signal or signal group
 *     PMD_OSR_MODE_FRCVAL oversample rate control
 *     PMD_OSR_MODE_FRC This bit when set would select the OSR mode signals to be software programmed
 */
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr (0x0001be00 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_SIZE 4

/*
 * This structure should be used to declare and program FALCON_IF_PER_LN_CTL1_PER_LANE.
 */
typedef union BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_s {
	uint32_t v[1];
	uint32_t falcon_if_per_ln_ctl1_per_lane[1];
	uint32_t _falcon_if_per_ln_ctl1_per_lane;
} BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_t;

#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_CLR(r) (r).falcon_if_per_ln_ctl1_per_lane[0] = 0
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_SET(r,d) (r).falcon_if_per_ln_ctl1_per_lane[0] = d
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_GET(r) (r).falcon_if_per_ln_ctl1_per_lane[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCf_GET(r) ((((r).falcon_if_per_ln_ctl1_per_lane[0]) >> 8) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCf_SET(r,f) (r).falcon_if_per_ln_ctl1_per_lane[0]=(((r).falcon_if_per_ln_ctl1_per_lane[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCVALf_GET(r) ((((r).falcon_if_per_ln_ctl1_per_lane[0]) >> 4) & 0xf)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCVALf_SET(r,f) (r).falcon_if_per_ln_ctl1_per_lane[0]=(((r).falcon_if_per_ln_ctl1_per_lane[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCf_GET(r) ((((r).falcon_if_per_ln_ctl1_per_lane[0]) >> 3) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCf_SET(r,f) (r).falcon_if_per_ln_ctl1_per_lane[0]=(((r).falcon_if_per_ln_ctl1_per_lane[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCVALf_GET(r) ((((r).falcon_if_per_ln_ctl1_per_lane[0]) >> 2) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCVALf_SET(r,f) (r).falcon_if_per_ln_ctl1_per_lane[0]=(((r).falcon_if_per_ln_ctl1_per_lane[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCf_GET(r) ((((r).falcon_if_per_ln_ctl1_per_lane[0]) >> 1) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCf_SET(r,f) (r).falcon_if_per_ln_ctl1_per_lane[0]=(((r).falcon_if_per_ln_ctl1_per_lane[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCVALf_GET(r) (((r).falcon_if_per_ln_ctl1_per_lane[0]) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCVALf_SET(r,f) (r).falcon_if_per_ln_ctl1_per_lane[0]=(((r).falcon_if_per_ln_ctl1_per_lane[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FALCON_IF_PER_LN_CTL1_PER_LANE.
 */
#define BCMI_MADURA_READ_FALCON_IF_PER_LN_CTL1_PER_LANEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr,_r._falcon_if_per_ln_ctl1_per_lane)
#define BCMI_MADURA_WRITE_FALCON_IF_PER_LN_CTL1_PER_LANEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr,_r._falcon_if_per_ln_ctl1_per_lane)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FALCON_IF_PER_LN_CTL1_PER_LANEr BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_SIZE BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_SIZE
typedef BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_t FALCON_IF_PER_LN_CTL1_PER_LANEr_t;
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_CLR BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_CLR
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_SET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_GET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCf_GET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCf_SET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCVALf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCVALf_GET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCVALf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_OSR_MODE_FRCVALf_SET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCf_GET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCf_SET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCVALf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCVALf_GET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCVALf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_TX_DISABLE_FRCVALf_SET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCf_GET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCf_SET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCVALf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCVALf_GET
#define FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCVALf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr_PMD_EXT_LOS_FRCVALf_SET
#define READ_FALCON_IF_PER_LN_CTL1_PER_LANEr BCMI_MADURA_READ_FALCON_IF_PER_LN_CTL1_PER_LANEr
#define WRITE_FALCON_IF_PER_LN_CTL1_PER_LANEr BCMI_MADURA_WRITE_FALCON_IF_PER_LN_CTL1_PER_LANEr
#define MODIFY_FALCON_IF_PER_LN_CTL1_PER_LANEr BCMI_MADURA_MODIFY_FALCON_IF_PER_LN_CTL1_PER_LANEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FALCON_IF_PER_LN_CTL1_PER_LANEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  FALCON_IF_PER_LN_CTL2_PER_LANE
 * BLOCKS:   FALCON_IF_PER_LANE
 * REGADDR:  0xbe01
 * DEVAD:    1
 * DESC:     software control bit to force certain values
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_H_RSTB_FRCVAL per lane reset, active low
 *     PMD_LN_H_RSTB_FRC If this bit is set; then software can bypass the hardware state machine driven controls for that specific signal or signal group
 *     PMD_LN_DP_H_RSTB_FRCVAL per lane datapath reset, active low
 *     PMD_LN_DP_H_RSTB_FRC If this bit is set; then software can bypass the hardware state machine driven controls for that specific signal or signal group
 *     PMD_LN_RX_H_PWRDN_FRCVAL power down transmitter lanes
 *     PMD_LN_RX_H_PWRDN_FRC If this bit is set the software can bypass the hardware state machine driven controls for that specific signal or signal group
 *     PMD_LN_TX_H_PWRDN_FRCVAL power down transmitter lanes
 *     PMD_LN_TX_H_PWRDN_FRC If this bit is set the software can bypass the hardware state machine driven controls for that specific signal or signal group
 */
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr (0x0001be01 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_SIZE 4

/*
 * This structure should be used to declare and program FALCON_IF_PER_LN_CTL2_PER_LANE.
 */
typedef union BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_s {
	uint32_t v[1];
	uint32_t falcon_if_per_ln_ctl2_per_lane[1];
	uint32_t _falcon_if_per_ln_ctl2_per_lane;
} BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_t;

#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_CLR(r) (r).falcon_if_per_ln_ctl2_per_lane[0] = 0
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_SET(r,d) (r).falcon_if_per_ln_ctl2_per_lane[0] = d
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_GET(r) (r).falcon_if_per_ln_ctl2_per_lane[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCf_GET(r) ((((r).falcon_if_per_ln_ctl2_per_lane[0]) >> 7) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCVALf_GET(r) ((((r).falcon_if_per_ln_ctl2_per_lane[0]) >> 6) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCVALf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCf_GET(r) ((((r).falcon_if_per_ln_ctl2_per_lane[0]) >> 5) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCVALf_GET(r) ((((r).falcon_if_per_ln_ctl2_per_lane[0]) >> 4) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCVALf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCf_GET(r) ((((r).falcon_if_per_ln_ctl2_per_lane[0]) >> 3) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCVALf_GET(r) ((((r).falcon_if_per_ln_ctl2_per_lane[0]) >> 2) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCVALf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCf_GET(r) ((((r).falcon_if_per_ln_ctl2_per_lane[0]) >> 1) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCVALf_GET(r) (((r).falcon_if_per_ln_ctl2_per_lane[0]) & 0x1)
#define BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCVALf_SET(r,f) (r).falcon_if_per_ln_ctl2_per_lane[0]=(((r).falcon_if_per_ln_ctl2_per_lane[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access FALCON_IF_PER_LN_CTL2_PER_LANE.
 */
#define BCMI_MADURA_READ_FALCON_IF_PER_LN_CTL2_PER_LANEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr,_r._falcon_if_per_ln_ctl2_per_lane)
#define BCMI_MADURA_WRITE_FALCON_IF_PER_LN_CTL2_PER_LANEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr,_r._falcon_if_per_ln_ctl2_per_lane)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FALCON_IF_PER_LN_CTL2_PER_LANEr BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_SIZE BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_SIZE
typedef BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_t FALCON_IF_PER_LN_CTL2_PER_LANEr_t;
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_CLR BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_CLR
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCf_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCVALf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCVALf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCVALf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_TX_H_PWRDN_FRCVALf_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCf_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCVALf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCVALf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCVALf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_RX_H_PWRDN_FRCVALf_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCf_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCVALf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCVALf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCVALf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_DP_H_RSTB_FRCVALf_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCf_SET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCVALf_GET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCVALf_GET
#define FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCVALf_SET BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr_PMD_LN_H_RSTB_FRCVALf_SET
#define READ_FALCON_IF_PER_LN_CTL2_PER_LANEr BCMI_MADURA_READ_FALCON_IF_PER_LN_CTL2_PER_LANEr
#define WRITE_FALCON_IF_PER_LN_CTL2_PER_LANEr BCMI_MADURA_WRITE_FALCON_IF_PER_LN_CTL2_PER_LANEr
#define MODIFY_FALCON_IF_PER_LN_CTL2_PER_LANEr BCMI_MADURA_MODIFY_FALCON_IF_PER_LN_CTL2_PER_LANEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_FALCON_IF_PER_LN_CTL2_PER_LANEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  REPEATER_STS_PER_LANE
 * BLOCKS:   FALCON_IF_PER_LANE
 * REGADDR:  0xbe02
 * DEVAD:    1
 * DESC:     repeater status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_RX_CLK_VLD   receive clock valid
 *     PMD_TX_CLK_VLD   transmit clock valid
 *     PMD_SIGNAL_DETECT pmd signal detect status
 */
#define BCMI_MADURA_REPEATER_STS_PER_LANEr (0x0001be02 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_REPEATER_STS_PER_LANEr_SIZE 4

/*
 * This structure should be used to declare and program REPEATER_STS_PER_LANE.
 */
typedef union BCMI_MADURA_REPEATER_STS_PER_LANEr_s {
	uint32_t v[1];
	uint32_t repeater_sts_per_lane[1];
	uint32_t _repeater_sts_per_lane;
} BCMI_MADURA_REPEATER_STS_PER_LANEr_t;

#define BCMI_MADURA_REPEATER_STS_PER_LANEr_CLR(r) (r).repeater_sts_per_lane[0] = 0
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_SET(r,d) (r).repeater_sts_per_lane[0] = d
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_GET(r) (r).repeater_sts_per_lane[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_SIGNAL_DETECTf_GET(r) ((((r).repeater_sts_per_lane[0]) >> 2) & 0x1)
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_SIGNAL_DETECTf_SET(r,f) (r).repeater_sts_per_lane[0]=(((r).repeater_sts_per_lane[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_TX_CLK_VLDf_GET(r) ((((r).repeater_sts_per_lane[0]) >> 1) & 0x1)
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_TX_CLK_VLDf_SET(r,f) (r).repeater_sts_per_lane[0]=(((r).repeater_sts_per_lane[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_RX_CLK_VLDf_GET(r) (((r).repeater_sts_per_lane[0]) & 0x1)
#define BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_RX_CLK_VLDf_SET(r,f) (r).repeater_sts_per_lane[0]=(((r).repeater_sts_per_lane[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access REPEATER_STS_PER_LANE.
 */
#define BCMI_MADURA_READ_REPEATER_STS_PER_LANEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_REPEATER_STS_PER_LANEr,_r._repeater_sts_per_lane)
#define BCMI_MADURA_WRITE_REPEATER_STS_PER_LANEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_REPEATER_STS_PER_LANEr,_r._repeater_sts_per_lane)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define REPEATER_STS_PER_LANEr BCMI_MADURA_REPEATER_STS_PER_LANEr
#define REPEATER_STS_PER_LANEr_SIZE BCMI_MADURA_REPEATER_STS_PER_LANEr_SIZE
typedef BCMI_MADURA_REPEATER_STS_PER_LANEr_t REPEATER_STS_PER_LANEr_t;
#define REPEATER_STS_PER_LANEr_CLR BCMI_MADURA_REPEATER_STS_PER_LANEr_CLR
#define REPEATER_STS_PER_LANEr_SET BCMI_MADURA_REPEATER_STS_PER_LANEr_SET
#define REPEATER_STS_PER_LANEr_GET BCMI_MADURA_REPEATER_STS_PER_LANEr_GET
#define REPEATER_STS_PER_LANEr_PMD_SIGNAL_DETECTf_GET BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_SIGNAL_DETECTf_GET
#define REPEATER_STS_PER_LANEr_PMD_SIGNAL_DETECTf_SET BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_SIGNAL_DETECTf_SET
#define REPEATER_STS_PER_LANEr_PMD_TX_CLK_VLDf_GET BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_TX_CLK_VLDf_GET
#define REPEATER_STS_PER_LANEr_PMD_TX_CLK_VLDf_SET BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_TX_CLK_VLDf_SET
#define REPEATER_STS_PER_LANEr_PMD_RX_CLK_VLDf_GET BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_RX_CLK_VLDf_GET
#define REPEATER_STS_PER_LANEr_PMD_RX_CLK_VLDf_SET BCMI_MADURA_REPEATER_STS_PER_LANEr_PMD_RX_CLK_VLDf_SET
#define READ_REPEATER_STS_PER_LANEr BCMI_MADURA_READ_REPEATER_STS_PER_LANEr
#define WRITE_REPEATER_STS_PER_LANEr BCMI_MADURA_WRITE_REPEATER_STS_PER_LANEr
#define MODIFY_REPEATER_STS_PER_LANEr BCMI_MADURA_MODIFY_REPEATER_STS_PER_LANEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_REPEATER_STS_PER_LANEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_RX_LN_MODE_CTL_PER_LANE
 * BLOCKS:   FALCON_IF_PER_LANE
 * REGADDR:  0xbe03
 * DEVAD:    1
 * DESC:     software control to drive pmd_rx_lane_mode
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_RX_LANE_MODE connects to pmd_rx_lane_mode[15:0] falcon core inputs
 */
#define BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr (0x0001be03 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_RX_LN_MODE_CTL_PER_LANE.
 */
typedef union BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_s {
	uint32_t v[1];
	uint32_t pmd_rx_ln_mode_ctl_per_lane[1];
	uint32_t _pmd_rx_ln_mode_ctl_per_lane;
} BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_t;

#define BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_CLR(r) (r).pmd_rx_ln_mode_ctl_per_lane[0] = 0
#define BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_SET(r,d) (r).pmd_rx_ln_mode_ctl_per_lane[0] = d
#define BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_GET(r) (r).pmd_rx_ln_mode_ctl_per_lane[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_PMD_RX_LANE_MODEf_GET(r) (((r).pmd_rx_ln_mode_ctl_per_lane[0]) & 0xffff)
#define BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_PMD_RX_LANE_MODEf_SET(r,f) (r).pmd_rx_ln_mode_ctl_per_lane[0]=(((r).pmd_rx_ln_mode_ctl_per_lane[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_RX_LN_MODE_CTL_PER_LANE.
 */
#define BCMI_MADURA_READ_PMD_RX_LN_MODE_CTL_PER_LANEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr,_r._pmd_rx_ln_mode_ctl_per_lane)
#define BCMI_MADURA_WRITE_PMD_RX_LN_MODE_CTL_PER_LANEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr,_r._pmd_rx_ln_mode_ctl_per_lane)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_RX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr
#define PMD_RX_LN_MODE_CTL_PER_LANEr_SIZE BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_SIZE
typedef BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_t PMD_RX_LN_MODE_CTL_PER_LANEr_t;
#define PMD_RX_LN_MODE_CTL_PER_LANEr_CLR BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_CLR
#define PMD_RX_LN_MODE_CTL_PER_LANEr_SET BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_SET
#define PMD_RX_LN_MODE_CTL_PER_LANEr_GET BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_GET
#define PMD_RX_LN_MODE_CTL_PER_LANEr_PMD_RX_LANE_MODEf_GET BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_PMD_RX_LANE_MODEf_GET
#define PMD_RX_LN_MODE_CTL_PER_LANEr_PMD_RX_LANE_MODEf_SET BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr_PMD_RX_LANE_MODEf_SET
#define READ_PMD_RX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_READ_PMD_RX_LN_MODE_CTL_PER_LANEr
#define WRITE_PMD_RX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_WRITE_PMD_RX_LN_MODE_CTL_PER_LANEr
#define MODIFY_PMD_RX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_MODIFY_PMD_RX_LN_MODE_CTL_PER_LANEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_RX_LN_MODE_CTL_PER_LANEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_TX_LN_MODE_CTL_PER_LANE
 * BLOCKS:   FALCON_IF_PER_LANE
 * REGADDR:  0xbe04
 * DEVAD:    1
 * DESC:     software control to drive pmd_tx_lane_mode
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_TX_LANE_MODE connects to pmd_tx_lane_mode[15:0] falcon core inputs
 */
#define BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr (0x0001be04 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_TX_LN_MODE_CTL_PER_LANE.
 */
typedef union BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_s {
	uint32_t v[1];
	uint32_t pmd_tx_ln_mode_ctl_per_lane[1];
	uint32_t _pmd_tx_ln_mode_ctl_per_lane;
} BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_t;

#define BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_CLR(r) (r).pmd_tx_ln_mode_ctl_per_lane[0] = 0
#define BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_SET(r,d) (r).pmd_tx_ln_mode_ctl_per_lane[0] = d
#define BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_GET(r) (r).pmd_tx_ln_mode_ctl_per_lane[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_PMD_TX_LANE_MODEf_GET(r) (((r).pmd_tx_ln_mode_ctl_per_lane[0]) & 0xffff)
#define BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_PMD_TX_LANE_MODEf_SET(r,f) (r).pmd_tx_ln_mode_ctl_per_lane[0]=(((r).pmd_tx_ln_mode_ctl_per_lane[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_TX_LN_MODE_CTL_PER_LANE.
 */
#define BCMI_MADURA_READ_PMD_TX_LN_MODE_CTL_PER_LANEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr,_r._pmd_tx_ln_mode_ctl_per_lane)
#define BCMI_MADURA_WRITE_PMD_TX_LN_MODE_CTL_PER_LANEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr,_r._pmd_tx_ln_mode_ctl_per_lane)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_TX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr
#define PMD_TX_LN_MODE_CTL_PER_LANEr_SIZE BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_SIZE
typedef BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_t PMD_TX_LN_MODE_CTL_PER_LANEr_t;
#define PMD_TX_LN_MODE_CTL_PER_LANEr_CLR BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_CLR
#define PMD_TX_LN_MODE_CTL_PER_LANEr_SET BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_SET
#define PMD_TX_LN_MODE_CTL_PER_LANEr_GET BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_GET
#define PMD_TX_LN_MODE_CTL_PER_LANEr_PMD_TX_LANE_MODEf_GET BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_PMD_TX_LANE_MODEf_GET
#define PMD_TX_LN_MODE_CTL_PER_LANEr_PMD_TX_LANE_MODEf_SET BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr_PMD_TX_LANE_MODEf_SET
#define READ_PMD_TX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_READ_PMD_TX_LN_MODE_CTL_PER_LANEr
#define WRITE_PMD_TX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_WRITE_PMD_TX_LN_MODE_CTL_PER_LANEr
#define MODIFY_PMD_TX_LN_MODE_CTL_PER_LANEr BCMI_MADURA_MODIFY_PMD_TX_LN_MODE_CTL_PER_LANEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_TX_LN_MODE_CTL_PER_LANEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  XGXSCTL
 * BLOCKS:   XGXS_BLK0
 * REGADDR:  0xc000
 * DEVAD:    1
 * DESC:     XGXS Control register
 * RESETVAL: 0x2000 (8192)
 * ACCESS:   R/W
 * FIELDS:
 *     START_SEQUENCER  1 = Enable Pll sequencer(also reset the Falcon Core and LN DP)0 = Reset Pll sequencer (also reset the Falcon Core and LN DP)
 */
#define BCMI_MADURA_XGXSCTLr (0x0001c000 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_XGXSCTLr_SIZE 4

/*
 * This structure should be used to declare and program XGXSCTL.
 */
typedef union BCMI_MADURA_XGXSCTLr_s {
	uint32_t v[1];
	uint32_t xgxsctl[1];
	uint32_t _xgxsctl;
} BCMI_MADURA_XGXSCTLr_t;

#define BCMI_MADURA_XGXSCTLr_CLR(r) (r).xgxsctl[0] = 0
#define BCMI_MADURA_XGXSCTLr_SET(r,d) (r).xgxsctl[0] = d
#define BCMI_MADURA_XGXSCTLr_GET(r) (r).xgxsctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_XGXSCTLr_START_SEQUENCERf_GET(r) ((((r).xgxsctl[0]) >> 13) & 0x1)
#define BCMI_MADURA_XGXSCTLr_START_SEQUENCERf_SET(r,f) (r).xgxsctl[0]=(((r).xgxsctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access XGXSCTL.
 */
#define BCMI_MADURA_READ_XGXSCTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_XGXSCTLr,_r._xgxsctl)
#define BCMI_MADURA_WRITE_XGXSCTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_XGXSCTLr,_r._xgxsctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define XGXSCTLr BCMI_MADURA_XGXSCTLr
#define XGXSCTLr_SIZE BCMI_MADURA_XGXSCTLr_SIZE
typedef BCMI_MADURA_XGXSCTLr_t XGXSCTLr_t;
#define XGXSCTLr_CLR BCMI_MADURA_XGXSCTLr_CLR
#define XGXSCTLr_SET BCMI_MADURA_XGXSCTLr_SET
#define XGXSCTLr_GET BCMI_MADURA_XGXSCTLr_GET
#define XGXSCTLr_START_SEQUENCERf_GET BCMI_MADURA_XGXSCTLr_START_SEQUENCERf_GET
#define XGXSCTLr_START_SEQUENCERf_SET BCMI_MADURA_XGXSCTLr_START_SEQUENCERf_SET
#define READ_XGXSCTLr BCMI_MADURA_READ_XGXSCTLr
#define WRITE_XGXSCTLr BCMI_MADURA_WRITE_XGXSCTLr
#define MODIFY_XGXSCTLr BCMI_MADURA_MODIFY_XGXSCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_XGXSCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  XGXSSTS
 * BLOCKS:   XGXS_BLK0
 * REGADDR:  0xc001
 * DEVAD:    1
 * DESC:     XGXS Status register
 * RESETVAL: 0x800 (2048)
 * ACCESS:   R/W
 * FIELDS:
 *     TXPLL_LOCK       Transmit pll lock indicator (from analog tx_pll block)
 */
#define BCMI_MADURA_XGXSSTSr (0x0001c001 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_XGXSSTSr_SIZE 4

/*
 * This structure should be used to declare and program XGXSSTS.
 */
typedef union BCMI_MADURA_XGXSSTSr_s {
	uint32_t v[1];
	uint32_t xgxssts[1];
	uint32_t _xgxssts;
} BCMI_MADURA_XGXSSTSr_t;

#define BCMI_MADURA_XGXSSTSr_CLR(r) (r).xgxssts[0] = 0
#define BCMI_MADURA_XGXSSTSr_SET(r,d) (r).xgxssts[0] = d
#define BCMI_MADURA_XGXSSTSr_GET(r) (r).xgxssts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_XGXSSTSr_TXPLL_LOCKf_GET(r) ((((r).xgxssts[0]) >> 11) & 0x1)
#define BCMI_MADURA_XGXSSTSr_TXPLL_LOCKf_SET(r,f) (r).xgxssts[0]=(((r).xgxssts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))

/*
 * These macros can be used to access XGXSSTS.
 */
#define BCMI_MADURA_READ_XGXSSTSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_XGXSSTSr,_r._xgxssts)
#define BCMI_MADURA_WRITE_XGXSSTSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_XGXSSTSr,_r._xgxssts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define XGXSSTSr BCMI_MADURA_XGXSSTSr
#define XGXSSTSr_SIZE BCMI_MADURA_XGXSSTSr_SIZE
typedef BCMI_MADURA_XGXSSTSr_t XGXSSTSr_t;
#define XGXSSTSr_CLR BCMI_MADURA_XGXSSTSr_CLR
#define XGXSSTSr_SET BCMI_MADURA_XGXSSTSr_SET
#define XGXSSTSr_GET BCMI_MADURA_XGXSSTSr_GET
#define XGXSSTSr_TXPLL_LOCKf_GET BCMI_MADURA_XGXSSTSr_TXPLL_LOCKf_GET
#define XGXSSTSr_TXPLL_LOCKf_SET BCMI_MADURA_XGXSSTSr_TXPLL_LOCKf_SET
#define READ_XGXSSTSr BCMI_MADURA_READ_XGXSSTSr
#define WRITE_XGXSSTSr BCMI_MADURA_WRITE_XGXSSTSr
#define MODIFY_XGXSSTSr BCMI_MADURA_MODIFY_XGXSSTSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_XGXSSTSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MISCCTL1
 * BLOCKS:   XGXS_BLK0
 * REGADDR:  0xc00e
 * DEVAD:    1
 * DESC:     Miscellaneous Control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LANE0_TX_DISABLE 1 = Disable output on transmit lane 00 = Enable output on transmit lane 0
 *     PMD_LANE1_TX_DISABLE 1 = Disable output on transmit lane 10 = Enable output on transmit lane 1
 *     PMD_LANE2_TX_DISABLE 1 = Disable output on transmit lane 20 = Enable output on transmit lane 2
 *     PMD_LANE3_TX_DISABLE 1 = Disable output on transmit lane 30 = Enable output on transmit lane 3
 *     PMD_LANE4_TX_DISABLE 1 = Disable output on transmit lane 40 = Enable output on transmit lane 4
 *     PMD_LANE5_TX_DISABLE 1 = Disable output on transmit lane 50 = Enable output on transmit lane 5
 *     PMD_LANE6_TX_DISABLE 1 = Disable output on transmit lane 60 = Enable output on transmit lane 6
 *     PMD_LANE7_TX_DISABLE 1 = Disable output on transmit lane 70 = Enable output on transmit lane 7
 *     PMD_LANE8_TX_DISABLE 1 = Disable output on transmit lane 80 = Enable output on transmit lane 8
 *     PMD_LANE9_TX_DISABLE 1 = Disable output on transmit lane 90 = Enable output on transmit lane 9
 *     GLOBAL_PMD_TX_DISABLE 1 = Disable all transmitter outputs0 = Enable all transmitter outputs
 */
#define BCMI_MADURA_MISCCTL1r (0x0001c00e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MISCCTL1r_SIZE 4

/*
 * This structure should be used to declare and program MISCCTL1.
 */
typedef union BCMI_MADURA_MISCCTL1r_s {
	uint32_t v[1];
	uint32_t miscctl1[1];
	uint32_t _miscctl1;
} BCMI_MADURA_MISCCTL1r_t;

#define BCMI_MADURA_MISCCTL1r_CLR(r) (r).miscctl1[0] = 0
#define BCMI_MADURA_MISCCTL1r_SET(r,d) (r).miscctl1[0] = d
#define BCMI_MADURA_MISCCTL1r_GET(r) (r).miscctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MISCCTL1r_GLOBAL_PMD_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_MISCCTL1r_GLOBAL_PMD_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE9_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 9) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE9_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE8_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 8) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE8_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE7_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 7) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE7_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE6_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 6) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE6_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE5_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 5) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE5_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE4_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 4) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE4_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE3_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 3) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE3_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE2_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 2) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE2_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE1_TX_DISABLEf_GET(r) ((((r).miscctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE1_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_MISCCTL1r_PMD_LANE0_TX_DISABLEf_GET(r) (((r).miscctl1[0]) & 0x1)
#define BCMI_MADURA_MISCCTL1r_PMD_LANE0_TX_DISABLEf_SET(r,f) (r).miscctl1[0]=(((r).miscctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MISCCTL1.
 */
#define BCMI_MADURA_READ_MISCCTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MISCCTL1r,_r._miscctl1)
#define BCMI_MADURA_WRITE_MISCCTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MISCCTL1r,_r._miscctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MISCCTL1r BCMI_MADURA_MISCCTL1r
#define MISCCTL1r_SIZE BCMI_MADURA_MISCCTL1r_SIZE
typedef BCMI_MADURA_MISCCTL1r_t MISCCTL1r_t;
#define MISCCTL1r_CLR BCMI_MADURA_MISCCTL1r_CLR
#define MISCCTL1r_SET BCMI_MADURA_MISCCTL1r_SET
#define MISCCTL1r_GET BCMI_MADURA_MISCCTL1r_GET
#define MISCCTL1r_GLOBAL_PMD_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_GLOBAL_PMD_TX_DISABLEf_GET
#define MISCCTL1r_GLOBAL_PMD_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_GLOBAL_PMD_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE9_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE9_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE9_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE9_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE8_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE8_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE8_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE8_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE7_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE7_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE7_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE7_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE6_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE6_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE6_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE6_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE5_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE5_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE5_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE5_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE4_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE4_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE4_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE4_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE3_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE3_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE3_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE3_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE2_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE2_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE2_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE2_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE1_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE1_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE1_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE1_TX_DISABLEf_SET
#define MISCCTL1r_PMD_LANE0_TX_DISABLEf_GET BCMI_MADURA_MISCCTL1r_PMD_LANE0_TX_DISABLEf_GET
#define MISCCTL1r_PMD_LANE0_TX_DISABLEf_SET BCMI_MADURA_MISCCTL1r_PMD_LANE0_TX_DISABLEf_SET
#define READ_MISCCTL1r BCMI_MADURA_READ_MISCCTL1r
#define WRITE_MISCCTL1r BCMI_MADURA_WRITE_MISCCTL1r
#define MODIFY_MISCCTL1r BCMI_MADURA_MODIFY_MISCCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MISCCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LANERESET
 * BLOCKS:   XGXS_BLK2
 * REGADDR:  0xc10a
 * DEVAD:    1
 * DESC:     Lane reset register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_RESET       Reset lane 3-0 for Falcon.Asserts lane dp reset to selected lanes on Serdes core.Does not reset mdio regs.
 *     RESET_PLL        Reset the pll.Asserts lane dp reset to all lanes on Serdes core.4 lanes for Falcon.Does not reset mdio regs.
 *     RESET_MDIO       Reset all mdio registers and datapath for every lane.4 lanes for Falcon.Complete core-wide reset.
 */
#define BCMI_MADURA_LANERESETr (0x0001c10a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LANERESETr_SIZE 4

/*
 * This structure should be used to declare and program LANERESET.
 */
typedef union BCMI_MADURA_LANERESETr_s {
	uint32_t v[1];
	uint32_t lanereset[1];
	uint32_t _lanereset;
} BCMI_MADURA_LANERESETr_t;

#define BCMI_MADURA_LANERESETr_CLR(r) (r).lanereset[0] = 0
#define BCMI_MADURA_LANERESETr_SET(r,d) (r).lanereset[0] = d
#define BCMI_MADURA_LANERESETr_GET(r) (r).lanereset[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LANERESETr_RESET_MDIOf_GET(r) ((((r).lanereset[0]) >> 15) & 0x1)
#define BCMI_MADURA_LANERESETr_RESET_MDIOf_SET(r,f) (r).lanereset[0]=(((r).lanereset[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_LANERESETr_RESET_PLLf_GET(r) ((((r).lanereset[0]) >> 12) & 0x1)
#define BCMI_MADURA_LANERESETr_RESET_PLLf_SET(r,f) (r).lanereset[0]=(((r).lanereset[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_LANERESETr_LANE_RESETf_GET(r) (((r).lanereset[0]) & 0x3ff)
#define BCMI_MADURA_LANERESETr_LANE_RESETf_SET(r,f) (r).lanereset[0]=(((r).lanereset[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access LANERESET.
 */
#define BCMI_MADURA_READ_LANERESETr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LANERESETr,_r._lanereset)
#define BCMI_MADURA_WRITE_LANERESETr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LANERESETr,_r._lanereset)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LANERESETr BCMI_MADURA_LANERESETr
#define LANERESETr_SIZE BCMI_MADURA_LANERESETr_SIZE
typedef BCMI_MADURA_LANERESETr_t LANERESETr_t;
#define LANERESETr_CLR BCMI_MADURA_LANERESETr_CLR
#define LANERESETr_SET BCMI_MADURA_LANERESETr_SET
#define LANERESETr_GET BCMI_MADURA_LANERESETr_GET
#define LANERESETr_RESET_MDIOf_GET BCMI_MADURA_LANERESETr_RESET_MDIOf_GET
#define LANERESETr_RESET_MDIOf_SET BCMI_MADURA_LANERESETr_RESET_MDIOf_SET
#define LANERESETr_RESET_PLLf_GET BCMI_MADURA_LANERESETr_RESET_PLLf_GET
#define LANERESETr_RESET_PLLf_SET BCMI_MADURA_LANERESETr_RESET_PLLf_SET
#define LANERESETr_LANE_RESETf_GET BCMI_MADURA_LANERESETr_LANE_RESETf_GET
#define LANERESETr_LANE_RESETf_SET BCMI_MADURA_LANERESETr_LANE_RESETf_SET
#define READ_LANERESETr BCMI_MADURA_READ_LANERESETr
#define WRITE_LANERESETr BCMI_MADURA_WRITE_LANERESETr
#define MODIFY_LANERESETr BCMI_MADURA_MODIFY_LANERESETr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LANERESETr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PF_CTL_DC_OFFS
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd000
 * DEVAD:    1
 * DESC:     rx_pf_ctrl_dc_offset register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PF2_CTRL      DC cut (Low PF),
 *     RX_PF_CTRL       Main Peaking Filter
 */
#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr (0x0001d000 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PF_CTL_DC_OFFS.
 */
typedef union BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pf_ctl_dc_offs[1];
	uint32_t _dsc_rx_pf_ctl_dc_offs;
} BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_t;

#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_CLR(r) (r).dsc_rx_pf_ctl_dc_offs[0] = 0
#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_SET(r,d) (r).dsc_rx_pf_ctl_dc_offs[0] = d
#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_GET(r) (r).dsc_rx_pf_ctl_dc_offs[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs[0]) >> 11) & 0xf)
#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs[0]=(((r).dsc_rx_pf_ctl_dc_offs[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs[0]) >> 8) & 0x7)
#define BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs[0]=(((r).dsc_rx_pf_ctl_dc_offs[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))

/*
 * These macros can be used to access DSC_RX_PF_CTL_DC_OFFS.
 */
#define BCMI_MADURA_READ_DSC_RX_PF_CTL_DC_OFFSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr,_r._dsc_rx_pf_ctl_dc_offs)
#define BCMI_MADURA_WRITE_DSC_RX_PF_CTL_DC_OFFSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr,_r._dsc_rx_pf_ctl_dc_offs)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PF_CTL_DC_OFFSr BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr
#define DSC_RX_PF_CTL_DC_OFFSr_SIZE BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_SIZE
typedef BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_t DSC_RX_PF_CTL_DC_OFFSr_t;
#define DSC_RX_PF_CTL_DC_OFFSr_CLR BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_CLR
#define DSC_RX_PF_CTL_DC_OFFSr_SET BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_SET
#define DSC_RX_PF_CTL_DC_OFFSr_GET BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_GET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_GET BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_GET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_SET BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_SET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_GET BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_GET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_SET BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_SET
#define READ_DSC_RX_PF_CTL_DC_OFFSr BCMI_MADURA_READ_DSC_RX_PF_CTL_DC_OFFSr
#define WRITE_DSC_RX_PF_CTL_DC_OFFSr BCMI_MADURA_WRITE_DSC_RX_PF_CTL_DC_OFFSr
#define MODIFY_DSC_RX_PF_CTL_DC_OFFSr BCMI_MADURA_MODIFY_DSC_RX_PF_CTL_DC_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PF_CTL_DC_OFFSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd001
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_DP signed 2's complement rxa slicer offset adjust for data_pos[5:0]
 *     RXA_SLICER_OFFSET_ADJ_DN signed 2's complement rxa slicer offset adjust for data_neg[5:0]
 */
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr (0x0001d001 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxa_slcr_offs_adj_dn_dp;
} BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxa_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxa_slcr_offs_adj_dn_dp[0] = d
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxa_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxa_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxa_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxa_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxa_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_MADURA_READ_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxa_slcr_offs_adj_dn_dp)
#define BCMI_MADURA_WRITE_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxa_slcr_offs_adj_dn_dp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_GET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_SET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_GET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_SET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_READ_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_WRITE_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_MODIFY_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd002
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_ZP signed 2's complement rxa slicer offset adjust for phs_neg[5:0]
 *     RXA_SLICER_OFFSET_ADJ_ZN signed 2's complement rxa slicer offset adjust for phs_pos[5:0]
 */
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d002 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxa_slcr_offs_adj_zn_zp;
} BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxa_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxa_slcr_offs_adj_zn_zp[0] = d
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxa_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxa_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxa_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxa_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxa_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_MADURA_READ_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxa_slcr_offs_adj_zn_zp)
#define BCMI_MADURA_WRITE_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxa_slcr_offs_adj_zn_zp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_GET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_SET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_GET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_SET BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_READ_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_WRITE_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_MODIFY_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXAB_SLCR_OFFS_ADJ_LMS
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd003
 * DEVAD:    1
 * DESC:     rxab_slicer_offset_adj_lms register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_LMS signed 2's complement rxb slicer offset adjust for lms[5:0]
 *     RXA_SLICER_OFFSET_ADJ_LMS signed 2's complement rxa slicer offset adjust for lms[5:0]
 */
#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr (0x0001d003 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXAB_SLCR_OFFS_ADJ_LMS.
 */
typedef union BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_s {
	uint32_t v[1];
	uint32_t dsc_rxab_slcr_offs_adj_lms[1];
	uint32_t _dsc_rxab_slcr_offs_adj_lms;
} BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_t;

#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_CLR(r) (r).dsc_rxab_slcr_offs_adj_lms[0] = 0
#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SET(r,d) (r).dsc_rxab_slcr_offs_adj_lms[0] = d
#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_GET(r) (r).dsc_rxab_slcr_offs_adj_lms[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_GET(r) ((((r).dsc_rxab_slcr_offs_adj_lms[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxab_slcr_offs_adj_lms[0]=(((r).dsc_rxab_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_GET(r) (((r).dsc_rxab_slcr_offs_adj_lms[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxab_slcr_offs_adj_lms[0]=(((r).dsc_rxab_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXAB_SLCR_OFFS_ADJ_LMS.
 */
#define BCMI_MADURA_READ_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr,_r._dsc_rxab_slcr_offs_adj_lms)
#define BCMI_MADURA_WRITE_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr,_r._dsc_rxab_slcr_offs_adj_lms)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SIZE BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SIZE
typedef BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_t DSC_RXAB_SLCR_OFFS_ADJ_LMSr_t;
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_CLR BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_CLR
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SET BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_GET BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_GET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_GET BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_SET BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_SET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_GET BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_SET BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_SET
#define READ_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_READ_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define WRITE_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_WRITE_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define MODIFY_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_MODIFY_DSC_RXAB_SLCR_OFFS_ADJ_LMSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXAB_SLCR_OFFS_ADJ_LMSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd004
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_DP signed 2's complement rxb slicer offset adjust for data_pos[5:0]
 *     RXB_SLICER_OFFSET_ADJ_DN signed 2's complement rxb slicer offset adjust for data_neg[5:0]
 */
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr (0x0001d004 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxb_slcr_offs_adj_dn_dp;
} BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxb_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxb_slcr_offs_adj_dn_dp[0] = d
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxb_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxb_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxb_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxb_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxb_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_MADURA_READ_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxb_slcr_offs_adj_dn_dp)
#define BCMI_MADURA_WRITE_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxb_slcr_offs_adj_dn_dp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_GET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_SET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_GET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_SET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_READ_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_WRITE_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_MODIFY_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd005
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_ZP signed 2's complement rxb slicer offset adjust for phs_pos[5:0]
 *     RXB_SLICER_OFFSET_ADJ_ZN signed 2's complement rxb slicer offset adjust for phs_neg[5:0]
 */
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d005 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxb_slcr_offs_adj_zn_zp;
} BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxb_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxb_slcr_offs_adj_zn_zp[0] = d
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxb_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxb_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxb_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxb_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxb_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_MADURA_READ_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxb_slcr_offs_adj_zn_zp)
#define BCMI_MADURA_WRITE_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxb_slcr_offs_adj_zn_zp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_GET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_SET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_GET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_SET BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_READ_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_WRITE_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_MODIFY_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd006
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_DP signed 2's complement rxc slicer offset adjust for data_pos[5:0]
 *     RXC_SLICER_OFFSET_ADJ_DN signed 2's complement rxc slicer offset adjust for data_neg[5:0]
 */
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr (0x0001d006 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxc_slcr_offs_adj_dn_dp;
} BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxc_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxc_slcr_offs_adj_dn_dp[0] = d
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxc_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxc_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxc_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxc_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxc_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_MADURA_READ_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxc_slcr_offs_adj_dn_dp)
#define BCMI_MADURA_WRITE_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxc_slcr_offs_adj_dn_dp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_GET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_SET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_GET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_SET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_READ_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_WRITE_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_MODIFY_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd007
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_ZP signed 2's complement rxc slicer offset adjust for phs_pos[5:0]
 *     RXC_SLICER_OFFSET_ADJ_ZN signed 2's complement rxc slicer offset adjust for phs_neg[5:0]
 */
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d007 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxc_slcr_offs_adj_zn_zp;
} BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxc_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxc_slcr_offs_adj_zn_zp[0] = d
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxc_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxc_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxc_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxc_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxc_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_MADURA_READ_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxc_slcr_offs_adj_zn_zp)
#define BCMI_MADURA_WRITE_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxc_slcr_offs_adj_zn_zp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_GET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_SET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_GET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_SET BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_READ_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_WRITE_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_MODIFY_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXCD_SLCR_OFFS_ADJ_LMS
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd008
 * DEVAD:    1
 * DESC:     rxcd_slicer_offset_adj_lms register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_LMS signed 2's complement rxd slicer offset adjust for lms[5:0]
 *     RXC_SLICER_OFFSET_ADJ_LMS signed 2's complement rxc slicer offset adjust for lms[5:0]
 */
#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr (0x0001d008 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXCD_SLCR_OFFS_ADJ_LMS.
 */
typedef union BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_s {
	uint32_t v[1];
	uint32_t dsc_rxcd_slcr_offs_adj_lms[1];
	uint32_t _dsc_rxcd_slcr_offs_adj_lms;
} BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_t;

#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_CLR(r) (r).dsc_rxcd_slcr_offs_adj_lms[0] = 0
#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SET(r,d) (r).dsc_rxcd_slcr_offs_adj_lms[0] = d
#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_GET(r) (r).dsc_rxcd_slcr_offs_adj_lms[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_GET(r) ((((r).dsc_rxcd_slcr_offs_adj_lms[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxcd_slcr_offs_adj_lms[0]=(((r).dsc_rxcd_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_GET(r) (((r).dsc_rxcd_slcr_offs_adj_lms[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxcd_slcr_offs_adj_lms[0]=(((r).dsc_rxcd_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXCD_SLCR_OFFS_ADJ_LMS.
 */
#define BCMI_MADURA_READ_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr,_r._dsc_rxcd_slcr_offs_adj_lms)
#define BCMI_MADURA_WRITE_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr,_r._dsc_rxcd_slcr_offs_adj_lms)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SIZE BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SIZE
typedef BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_t DSC_RXCD_SLCR_OFFS_ADJ_LMSr_t;
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_CLR BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_CLR
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SET BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_GET BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_GET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_GET BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_SET BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_SET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_GET BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_SET BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_SET
#define READ_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_READ_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define WRITE_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_WRITE_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define MODIFY_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_MADURA_MODIFY_DSC_RXCD_SLCR_OFFS_ADJ_LMSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXCD_SLCR_OFFS_ADJ_LMSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd009
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_DP signed 2's complement rxd slicer offset adjust for data_pos[5:0]
 *     RXD_SLICER_OFFSET_ADJ_DN signed 2's complement rxd slicer offset adjust for data_neg[5:0]
 */
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr (0x0001d009 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxd_slcr_offs_adj_dn_dp;
} BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxd_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxd_slcr_offs_adj_dn_dp[0] = d
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxd_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxd_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxd_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxd_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxd_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_MADURA_READ_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxd_slcr_offs_adj_dn_dp)
#define BCMI_MADURA_WRITE_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr,_r._dsc_rxd_slcr_offs_adj_dn_dp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_GET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_SET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_GET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_SET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_READ_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_WRITE_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_MADURA_MODIFY_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00a
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_ZP signed 2's complement rxd slicer offset adjust for phs_pos[5:0]
 *     RXD_SLICER_OFFSET_ADJ_ZN signed 2's complement rxd slicer offset adjust for phs_neg[5:0]
 */
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d00a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxd_slcr_offs_adj_zn_zp;
} BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxd_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxd_slcr_offs_adj_zn_zp[0] = d
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxd_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxd_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxd_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxd_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxd_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_MADURA_READ_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxd_slcr_offs_adj_zn_zp)
#define BCMI_MADURA_WRITE_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr,_r._dsc_rxd_slcr_offs_adj_zn_zp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_GET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_SET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_GET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_SET BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_READ_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_WRITE_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_MADURA_MODIFY_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PHASE_LMS_THR_SEL
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00b
 * DEVAD:    1
 * DESC:     rx_phase_lms_thresh_sel register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LMS_THRESH_SEL signed 2's complement +/-127. 127=300mV
 *     RX_PHASE_THRESH_SEL signed 2's complement -63 to +63. 63=150mV
 */
#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr (0x0001d00b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PHASE_LMS_THR_SEL.
 */
typedef union BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_s {
	uint32_t v[1];
	uint32_t dsc_rx_phase_lms_thr_sel[1];
	uint32_t _dsc_rx_phase_lms_thr_sel;
} BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_t;

#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_CLR(r) (r).dsc_rx_phase_lms_thr_sel[0] = 0
#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_SET(r,d) (r).dsc_rx_phase_lms_thr_sel[0] = d
#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_GET(r) (r).dsc_rx_phase_lms_thr_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_GET(r) ((((r).dsc_rx_phase_lms_thr_sel[0]) >> 8) & 0x7f)
#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_SET(r,f) (r).dsc_rx_phase_lms_thr_sel[0]=(((r).dsc_rx_phase_lms_thr_sel[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_GET(r) (((r).dsc_rx_phase_lms_thr_sel[0]) & 0xff)
#define BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_SET(r,f) (r).dsc_rx_phase_lms_thr_sel[0]=(((r).dsc_rx_phase_lms_thr_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PHASE_LMS_THR_SEL.
 */
#define BCMI_MADURA_READ_DSC_RX_PHASE_LMS_THR_SELr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr,_r._dsc_rx_phase_lms_thr_sel)
#define BCMI_MADURA_WRITE_DSC_RX_PHASE_LMS_THR_SELr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr,_r._dsc_rx_phase_lms_thr_sel)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PHASE_LMS_THR_SELr BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr
#define DSC_RX_PHASE_LMS_THR_SELr_SIZE BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_SIZE
typedef BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_t DSC_RX_PHASE_LMS_THR_SELr_t;
#define DSC_RX_PHASE_LMS_THR_SELr_CLR BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_CLR
#define DSC_RX_PHASE_LMS_THR_SELr_SET BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_SET
#define DSC_RX_PHASE_LMS_THR_SELr_GET BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_GET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_GET BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_GET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_SET BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_SET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_GET BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_GET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_SET BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_SET
#define READ_DSC_RX_PHASE_LMS_THR_SELr BCMI_MADURA_READ_DSC_RX_PHASE_LMS_THR_SELr
#define WRITE_DSC_RX_PHASE_LMS_THR_SELr BCMI_MADURA_WRITE_DSC_RX_PHASE_LMS_THR_SELr
#define MODIFY_DSC_RX_PHASE_LMS_THR_SELr BCMI_MADURA_MODIFY_DSC_RX_PHASE_LMS_THR_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PHASE_LMS_THR_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP2_AB
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd010
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_ab register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP2     signed 2's complement  +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2     signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr (0x0001d010 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_AB.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_ab[1];
	uint32_t _dsc_rx_dfe_tap2_ab;
} BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_CLR(r) (r).dsc_rx_dfe_tap2_ab[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_SET(r,d) (r).dsc_rx_dfe_tap2_ab[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_GET(r) (r).dsc_rx_dfe_tap2_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_GET(r) ((((r).dsc_rx_dfe_tap2_ab[0]) >> 8) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_ab[0]=(((r).dsc_rx_dfe_tap2_ab[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_GET(r) (((r).dsc_rx_dfe_tap2_ab[0]) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_ab[0]=(((r).dsc_rx_dfe_tap2_ab[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_AB.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP2_ABr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP2_ABr,_r._dsc_rx_dfe_tap2_ab)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP2_ABr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP2_ABr,_r._dsc_rx_dfe_tap2_ab)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_ABr BCMI_MADURA_DSC_RX_DFE_TAP2_ABr
#define DSC_RX_DFE_TAP2_ABr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_t DSC_RX_DFE_TAP2_ABr_t;
#define DSC_RX_DFE_TAP2_ABr_CLR BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_CLR
#define DSC_RX_DFE_TAP2_ABr_SET BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_SET
#define DSC_RX_DFE_TAP2_ABr_GET BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_GET
#define DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_GET BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_SET BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_SET
#define DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_GET BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_SET BCMI_MADURA_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_SET
#define READ_DSC_RX_DFE_TAP2_ABr BCMI_MADURA_READ_DSC_RX_DFE_TAP2_ABr
#define WRITE_DSC_RX_DFE_TAP2_ABr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP2_ABr
#define MODIFY_DSC_RX_DFE_TAP2_ABr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP2_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP2_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP2_CD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd011
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_cd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP2     signed 2's complement +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP2     signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr (0x0001d011 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_CD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_cd[1];
	uint32_t _dsc_rx_dfe_tap2_cd;
} BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_CLR(r) (r).dsc_rx_dfe_tap2_cd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_SET(r,d) (r).dsc_rx_dfe_tap2_cd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_GET(r) (r).dsc_rx_dfe_tap2_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_GET(r) ((((r).dsc_rx_dfe_tap2_cd[0]) >> 8) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_cd[0]=(((r).dsc_rx_dfe_tap2_cd[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_GET(r) (((r).dsc_rx_dfe_tap2_cd[0]) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_cd[0]=(((r).dsc_rx_dfe_tap2_cd[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_CD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP2_CDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP2_CDr,_r._dsc_rx_dfe_tap2_cd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP2_CDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP2_CDr,_r._dsc_rx_dfe_tap2_cd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_CDr BCMI_MADURA_DSC_RX_DFE_TAP2_CDr
#define DSC_RX_DFE_TAP2_CDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_t DSC_RX_DFE_TAP2_CDr_t;
#define DSC_RX_DFE_TAP2_CDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_CLR
#define DSC_RX_DFE_TAP2_CDr_SET BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_SET
#define DSC_RX_DFE_TAP2_CDr_GET BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_GET
#define DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_GET BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_SET BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_SET
#define DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_GET BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_SET BCMI_MADURA_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_SET
#define READ_DSC_RX_DFE_TAP2_CDr BCMI_MADURA_READ_DSC_RX_DFE_TAP2_CDr
#define WRITE_DSC_RX_DFE_TAP2_CDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP2_CDr
#define MODIFY_DSC_RX_DFE_TAP2_CDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP2_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP2_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP3_AB
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd012
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_ab register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP3     signed 2's complement +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP3     signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr (0x0001d012 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_AB.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_ab[1];
	uint32_t _dsc_rx_dfe_tap3_ab;
} BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_CLR(r) (r).dsc_rx_dfe_tap3_ab[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_SET(r,d) (r).dsc_rx_dfe_tap3_ab[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_GET(r) (r).dsc_rx_dfe_tap3_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_GET(r) ((((r).dsc_rx_dfe_tap3_ab[0]) >> 8) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_ab[0]=(((r).dsc_rx_dfe_tap3_ab[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_GET(r) (((r).dsc_rx_dfe_tap3_ab[0]) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_ab[0]=(((r).dsc_rx_dfe_tap3_ab[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_AB.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP3_ABr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP3_ABr,_r._dsc_rx_dfe_tap3_ab)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP3_ABr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP3_ABr,_r._dsc_rx_dfe_tap3_ab)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_ABr BCMI_MADURA_DSC_RX_DFE_TAP3_ABr
#define DSC_RX_DFE_TAP3_ABr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_t DSC_RX_DFE_TAP3_ABr_t;
#define DSC_RX_DFE_TAP3_ABr_CLR BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_CLR
#define DSC_RX_DFE_TAP3_ABr_SET BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_SET
#define DSC_RX_DFE_TAP3_ABr_GET BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_GET
#define DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_GET BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_SET BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_SET
#define DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_GET BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_SET BCMI_MADURA_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_SET
#define READ_DSC_RX_DFE_TAP3_ABr BCMI_MADURA_READ_DSC_RX_DFE_TAP3_ABr
#define WRITE_DSC_RX_DFE_TAP3_ABr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP3_ABr
#define MODIFY_DSC_RX_DFE_TAP3_ABr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP3_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP3_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP3_CD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd013
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_cd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP3     signed 2's complement +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP3     signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr (0x0001d013 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_CD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_cd[1];
	uint32_t _dsc_rx_dfe_tap3_cd;
} BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_CLR(r) (r).dsc_rx_dfe_tap3_cd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_SET(r,d) (r).dsc_rx_dfe_tap3_cd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_GET(r) (r).dsc_rx_dfe_tap3_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_GET(r) ((((r).dsc_rx_dfe_tap3_cd[0]) >> 8) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_cd[0]=(((r).dsc_rx_dfe_tap3_cd[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_GET(r) (((r).dsc_rx_dfe_tap3_cd[0]) & 0x1f)
#define BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_cd[0]=(((r).dsc_rx_dfe_tap3_cd[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_CD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP3_CDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP3_CDr,_r._dsc_rx_dfe_tap3_cd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP3_CDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP3_CDr,_r._dsc_rx_dfe_tap3_cd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_CDr BCMI_MADURA_DSC_RX_DFE_TAP3_CDr
#define DSC_RX_DFE_TAP3_CDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_t DSC_RX_DFE_TAP3_CDr_t;
#define DSC_RX_DFE_TAP3_CDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_CLR
#define DSC_RX_DFE_TAP3_CDr_SET BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_SET
#define DSC_RX_DFE_TAP3_CDr_GET BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_GET
#define DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_GET BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_SET BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_SET
#define DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_GET BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_SET BCMI_MADURA_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_SET
#define READ_DSC_RX_DFE_TAP3_CDr BCMI_MADURA_READ_DSC_RX_DFE_TAP3_CDr
#define WRITE_DSC_RX_DFE_TAP3_CDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP3_CDr
#define MODIFY_DSC_RX_DFE_TAP3_CDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP3_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP3_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP4_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd014
 * DEVAD:    1
 * DESC:     rx_dfe_tap4_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr (0x0001d014 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP4_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap4_abcd[1];
	uint32_t _dsc_rx_dfe_tap4_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_CLR(r) (r).dsc_rx_dfe_tap4_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap4_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_GET(r) (r).dsc_rx_dfe_tap4_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_GET(r) (((r).dsc_rx_dfe_tap4_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP4_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP4_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr,_r._dsc_rx_dfe_tap4_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP4_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr,_r._dsc_rx_dfe_tap4_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP4_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr
#define DSC_RX_DFE_TAP4_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_t DSC_RX_DFE_TAP4_ABCDr_t;
#define DSC_RX_DFE_TAP4_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_CLR
#define DSC_RX_DFE_TAP4_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_SET
#define DSC_RX_DFE_TAP4_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_GET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_SET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_GET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_SET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_GET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_SET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_GET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_SET BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_SET
#define READ_DSC_RX_DFE_TAP4_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP4_ABCDr
#define WRITE_DSC_RX_DFE_TAP4_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP4_ABCDr
#define MODIFY_DSC_RX_DFE_TAP4_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP4_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP4_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP5_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd015
 * DEVAD:    1
 * DESC:     rx_dfe_tap5_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr (0x0001d015 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP5_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap5_abcd[1];
	uint32_t _dsc_rx_dfe_tap5_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_CLR(r) (r).dsc_rx_dfe_tap5_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap5_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_GET(r) (r).dsc_rx_dfe_tap5_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET(r) (((r).dsc_rx_dfe_tap5_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP5_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr,_r._dsc_rx_dfe_tap5_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr,_r._dsc_rx_dfe_tap5_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP5_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr
#define DSC_RX_DFE_TAP5_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_t DSC_RX_DFE_TAP5_ABCDr_t;
#define DSC_RX_DFE_TAP5_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_CLR
#define DSC_RX_DFE_TAP5_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_SET
#define DSC_RX_DFE_TAP5_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET
#define READ_DSC_RX_DFE_TAP5_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP5_ABCDr
#define WRITE_DSC_RX_DFE_TAP5_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP5_ABCDr
#define MODIFY_DSC_RX_DFE_TAP5_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP5_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP5_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP6_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd016
 * DEVAD:    1
 * DESC:     rx_dfe_tap6_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr (0x0001d016 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP6_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap6_abcd[1];
	uint32_t _dsc_rx_dfe_tap6_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_CLR(r) (r).dsc_rx_dfe_tap6_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap6_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_GET(r) (r).dsc_rx_dfe_tap6_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET(r) (((r).dsc_rx_dfe_tap6_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP6_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr,_r._dsc_rx_dfe_tap6_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr,_r._dsc_rx_dfe_tap6_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP6_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr
#define DSC_RX_DFE_TAP6_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_t DSC_RX_DFE_TAP6_ABCDr_t;
#define DSC_RX_DFE_TAP6_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_CLR
#define DSC_RX_DFE_TAP6_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_SET
#define DSC_RX_DFE_TAP6_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET
#define READ_DSC_RX_DFE_TAP6_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP6_ABCDr
#define WRITE_DSC_RX_DFE_TAP6_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP6_ABCDr
#define MODIFY_DSC_RX_DFE_TAP6_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP6_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP6_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP7_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd017
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr (0x0001d017 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET(r) (((r).dsc_rx_dfe_tap7_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr,_r._dsc_rx_dfe_tap7_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr,_r._dsc_rx_dfe_tap7_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr
#define DSC_RX_DFE_TAP7_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_t DSC_RX_DFE_TAP7_ABCDr_t;
#define DSC_RX_DFE_TAP7_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_CLR
#define DSC_RX_DFE_TAP7_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_SET
#define DSC_RX_DFE_TAP7_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET
#define READ_DSC_RX_DFE_TAP7_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP7_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP7_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP7_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP7_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP8_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd018
 * DEVAD:    1
 * DESC:     rx_dfe_tap8_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr (0x0001d018 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP8_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap8_abcd[1];
	uint32_t _dsc_rx_dfe_tap8_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_CLR(r) (r).dsc_rx_dfe_tap8_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap8_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_GET(r) (r).dsc_rx_dfe_tap8_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET(r) (((r).dsc_rx_dfe_tap8_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP8_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr,_r._dsc_rx_dfe_tap8_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr,_r._dsc_rx_dfe_tap8_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP8_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr
#define DSC_RX_DFE_TAP8_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_t DSC_RX_DFE_TAP8_ABCDr_t;
#define DSC_RX_DFE_TAP8_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_CLR
#define DSC_RX_DFE_TAP8_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_SET
#define DSC_RX_DFE_TAP8_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET
#define READ_DSC_RX_DFE_TAP8_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP8_ABCDr
#define WRITE_DSC_RX_DFE_TAP8_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP8_ABCDr
#define MODIFY_DSC_RX_DFE_TAP8_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP8_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP8_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP9_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd019
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr (0x0001d019 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET(r) (((r).dsc_rx_dfe_tap9_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr,_r._dsc_rx_dfe_tap9_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr,_r._dsc_rx_dfe_tap9_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr
#define DSC_RX_DFE_TAP9_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_t DSC_RX_DFE_TAP9_ABCDr_t;
#define DSC_RX_DFE_TAP9_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_CLR
#define DSC_RX_DFE_TAP9_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_SET
#define DSC_RX_DFE_TAP9_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET
#define READ_DSC_RX_DFE_TAP9_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP9_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP9_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP9_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP9_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP10_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd020
 * DEVAD:    1
 * DESC:     rx_dfe_tap10_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr (0x0001d020 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP10_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap10_abcd[1];
	uint32_t _dsc_rx_dfe_tap10_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_CLR(r) (r).dsc_rx_dfe_tap10_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap10_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_GET(r) (r).dsc_rx_dfe_tap10_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET(r) (((r).dsc_rx_dfe_tap10_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP10_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr,_r._dsc_rx_dfe_tap10_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr,_r._dsc_rx_dfe_tap10_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP10_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr
#define DSC_RX_DFE_TAP10_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_t DSC_RX_DFE_TAP10_ABCDr_t;
#define DSC_RX_DFE_TAP10_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_CLR
#define DSC_RX_DFE_TAP10_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_SET
#define DSC_RX_DFE_TAP10_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET
#define READ_DSC_RX_DFE_TAP10_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP10_ABCDr
#define WRITE_DSC_RX_DFE_TAP10_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP10_ABCDr
#define MODIFY_DSC_RX_DFE_TAP10_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP10_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP10_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP11_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd021
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr (0x0001d021 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET(r) (((r).dsc_rx_dfe_tap11_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr,_r._dsc_rx_dfe_tap11_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr,_r._dsc_rx_dfe_tap11_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr
#define DSC_RX_DFE_TAP11_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_t DSC_RX_DFE_TAP11_ABCDr_t;
#define DSC_RX_DFE_TAP11_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_CLR
#define DSC_RX_DFE_TAP11_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_SET
#define DSC_RX_DFE_TAP11_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET
#define READ_DSC_RX_DFE_TAP11_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP11_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP11_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP11_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP11_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP12_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd022
 * DEVAD:    1
 * DESC:     rx_dfe_tap12_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr (0x0001d022 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP12_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap12_abcd[1];
	uint32_t _dsc_rx_dfe_tap12_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_CLR(r) (r).dsc_rx_dfe_tap12_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap12_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_GET(r) (r).dsc_rx_dfe_tap12_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET(r) (((r).dsc_rx_dfe_tap12_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP12_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr,_r._dsc_rx_dfe_tap12_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr,_r._dsc_rx_dfe_tap12_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP12_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr
#define DSC_RX_DFE_TAP12_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_t DSC_RX_DFE_TAP12_ABCDr_t;
#define DSC_RX_DFE_TAP12_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_CLR
#define DSC_RX_DFE_TAP12_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_SET
#define DSC_RX_DFE_TAP12_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET
#define READ_DSC_RX_DFE_TAP12_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP12_ABCDr
#define WRITE_DSC_RX_DFE_TAP12_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP12_ABCDr
#define MODIFY_DSC_RX_DFE_TAP12_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP12_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP12_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP13_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd023
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr (0x0001d023 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET(r) (((r).dsc_rx_dfe_tap13_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr,_r._dsc_rx_dfe_tap13_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr,_r._dsc_rx_dfe_tap13_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr
#define DSC_RX_DFE_TAP13_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_t DSC_RX_DFE_TAP13_ABCDr_t;
#define DSC_RX_DFE_TAP13_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_CLR
#define DSC_RX_DFE_TAP13_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_SET
#define DSC_RX_DFE_TAP13_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET
#define READ_DSC_RX_DFE_TAP13_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP13_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP13_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP13_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP13_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP14_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd024
 * DEVAD:    1
 * DESC:     rx_dfe_tap14_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr (0x0001d024 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP14_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap14_abcd[1];
	uint32_t _dsc_rx_dfe_tap14_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_CLR(r) (r).dsc_rx_dfe_tap14_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap14_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_GET(r) (r).dsc_rx_dfe_tap14_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET(r) (((r).dsc_rx_dfe_tap14_abcd[0]) & 0xf)
#define BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP14_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr,_r._dsc_rx_dfe_tap14_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr,_r._dsc_rx_dfe_tap14_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP14_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr
#define DSC_RX_DFE_TAP14_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_t DSC_RX_DFE_TAP14_ABCDr_t;
#define DSC_RX_DFE_TAP14_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_CLR
#define DSC_RX_DFE_TAP14_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_SET
#define DSC_RX_DFE_TAP14_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET
#define READ_DSC_RX_DFE_TAP14_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP14_ABCDr
#define WRITE_DSC_RX_DFE_TAP14_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP14_ABCDr
#define MODIFY_DSC_RX_DFE_TAP14_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP14_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP14_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP7_8_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd025
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_8_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr (0x0001d025 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_8_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_8_mux_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET(r) (((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr,_r._dsc_rx_dfe_tap7_8_mux_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr,_r._dsc_rx_dfe_tap7_8_mux_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET
#define READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP7_8_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP9_10_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd026
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_10_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr (0x0001d026 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_10_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_10_mux_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET(r) (((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr,_r._dsc_rx_dfe_tap9_10_mux_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr,_r._dsc_rx_dfe_tap9_10_mux_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET
#define READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP9_10_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP11_12_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd027
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_12_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr (0x0001d027 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_12_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_12_mux_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET(r) (((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr,_r._dsc_rx_dfe_tap11_12_mux_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr,_r._dsc_rx_dfe_tap11_12_mux_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET
#define READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP11_12_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DFE_TAP13_14_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd028
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_14_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr (0x0001d028 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
typedef union BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_14_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_14_mux_abcd;
} BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;

#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = 0
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = d
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET(r) (((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) & 0x3)
#define BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
#define BCMI_MADURA_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr,_r._dsc_rx_dfe_tap13_14_mux_abcd)
#define BCMI_MADURA_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr,_r._dsc_rx_dfe_tap13_14_mux_abcd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE
typedef BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET
#define READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_MADURA_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_MADURA_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_MADURA_MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DFE_TAP13_14_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_LOAD_PRESETS
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd029
 * DEVAD:    1
 * DESC:     load_presets.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRESET_AFE       Load presets for analog interface Registers
 */
#define BCMI_MADURA_DSC_LOAD_PRESETSr (0x0001d029 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_LOAD_PRESETSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_LOAD_PRESETS.
 */
typedef union BCMI_MADURA_DSC_LOAD_PRESETSr_s {
	uint32_t v[1];
	uint32_t dsc_load_presets[1];
	uint32_t _dsc_load_presets;
} BCMI_MADURA_DSC_LOAD_PRESETSr_t;

#define BCMI_MADURA_DSC_LOAD_PRESETSr_CLR(r) (r).dsc_load_presets[0] = 0
#define BCMI_MADURA_DSC_LOAD_PRESETSr_SET(r,d) (r).dsc_load_presets[0] = d
#define BCMI_MADURA_DSC_LOAD_PRESETSr_GET(r) (r).dsc_load_presets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_LOAD_PRESETSr_PRESET_AFEf_GET(r) (((r).dsc_load_presets[0]) & 0x1)
#define BCMI_MADURA_DSC_LOAD_PRESETSr_PRESET_AFEf_SET(r,f) (r).dsc_load_presets[0]=(((r).dsc_load_presets[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_LOAD_PRESETS.
 */
#define BCMI_MADURA_READ_DSC_LOAD_PRESETSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_LOAD_PRESETSr,_r._dsc_load_presets)
#define BCMI_MADURA_WRITE_DSC_LOAD_PRESETSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_LOAD_PRESETSr,_r._dsc_load_presets)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LOAD_PRESETSr BCMI_MADURA_DSC_LOAD_PRESETSr
#define DSC_LOAD_PRESETSr_SIZE BCMI_MADURA_DSC_LOAD_PRESETSr_SIZE
typedef BCMI_MADURA_DSC_LOAD_PRESETSr_t DSC_LOAD_PRESETSr_t;
#define DSC_LOAD_PRESETSr_CLR BCMI_MADURA_DSC_LOAD_PRESETSr_CLR
#define DSC_LOAD_PRESETSr_SET BCMI_MADURA_DSC_LOAD_PRESETSr_SET
#define DSC_LOAD_PRESETSr_GET BCMI_MADURA_DSC_LOAD_PRESETSr_GET
#define DSC_LOAD_PRESETSr_PRESET_AFEf_GET BCMI_MADURA_DSC_LOAD_PRESETSr_PRESET_AFEf_GET
#define DSC_LOAD_PRESETSr_PRESET_AFEf_SET BCMI_MADURA_DSC_LOAD_PRESETSr_PRESET_AFEf_SET
#define READ_DSC_LOAD_PRESETSr BCMI_MADURA_READ_DSC_LOAD_PRESETSr
#define WRITE_DSC_LOAD_PRESETSr BCMI_MADURA_WRITE_DSC_LOAD_PRESETSr
#define MODIFY_DSC_LOAD_PRESETSr BCMI_MADURA_MODIFY_DSC_LOAD_PRESETSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_LOAD_PRESETSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_UC_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03d
 * DEVAD:    1
 * DESC:     DSC uC Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_GP_UC_REQ gp_uc request
 *     UC_DSC_ERROR_FOUND Error Found.
 *     UC_DSC_READY_FOR_CMD Ready for command.
 *     UC_DSC_SUPP_INFO Supplemental information.
 */
#define BCMI_MADURA_DSC_UC_CTLr (0x0001d03d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_UC_CTL.
 */
typedef union BCMI_MADURA_DSC_UC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_uc_ctl[1];
	uint32_t _dsc_uc_ctl;
} BCMI_MADURA_DSC_UC_CTLr_t;

#define BCMI_MADURA_DSC_UC_CTLr_CLR(r) (r).dsc_uc_ctl[0] = 0
#define BCMI_MADURA_DSC_UC_CTLr_SET(r,d) (r).dsc_uc_ctl[0] = d
#define BCMI_MADURA_DSC_UC_CTLr_GET(r) (r).dsc_uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET(r) ((((r).dsc_uc_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET(r) (((r).dsc_uc_ctl[0]) & 0x3f)
#define BCMI_MADURA_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_UC_CTL.
 */
#define BCMI_MADURA_READ_DSC_UC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_UC_CTLr,_r._dsc_uc_ctl)
#define BCMI_MADURA_WRITE_DSC_UC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_UC_CTLr,_r._dsc_uc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_UC_CTLr BCMI_MADURA_DSC_UC_CTLr
#define DSC_UC_CTLr_SIZE BCMI_MADURA_DSC_UC_CTLr_SIZE
typedef BCMI_MADURA_DSC_UC_CTLr_t DSC_UC_CTLr_t;
#define DSC_UC_CTLr_CLR BCMI_MADURA_DSC_UC_CTLr_CLR
#define DSC_UC_CTLr_SET BCMI_MADURA_DSC_UC_CTLr_SET
#define DSC_UC_CTLr_GET BCMI_MADURA_DSC_UC_CTLr_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET BCMI_MADURA_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET
#define READ_DSC_UC_CTLr BCMI_MADURA_READ_DSC_UC_CTLr
#define WRITE_DSC_UC_CTLr BCMI_MADURA_WRITE_DSC_UC_CTLr
#define MODIFY_DSC_UC_CTLr BCMI_MADURA_MODIFY_DSC_UC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_UC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SCRATCH
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03e
 * DEVAD:    1
 * DESC:     DSC uC Scratch
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_SCRATCH   DSC scratch register.
 */
#define BCMI_MADURA_DSC_SCRATCHr (0x0001d03e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SCRATCHr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SCRATCH.
 */
typedef union BCMI_MADURA_DSC_SCRATCHr_s {
	uint32_t v[1];
	uint32_t dsc_scratch[1];
	uint32_t _dsc_scratch;
} BCMI_MADURA_DSC_SCRATCHr_t;

#define BCMI_MADURA_DSC_SCRATCHr_CLR(r) (r).dsc_scratch[0] = 0
#define BCMI_MADURA_DSC_SCRATCHr_SET(r,d) (r).dsc_scratch[0] = d
#define BCMI_MADURA_DSC_SCRATCHr_GET(r) (r).dsc_scratch[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET(r) (((r).dsc_scratch[0]) & 0xffff)
#define BCMI_MADURA_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET(r,f) (r).dsc_scratch[0]=(((r).dsc_scratch[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_SCRATCH.
 */
#define BCMI_MADURA_READ_DSC_SCRATCHr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SCRATCHr,_r._dsc_scratch)
#define BCMI_MADURA_WRITE_DSC_SCRATCHr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SCRATCHr,_r._dsc_scratch)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SCRATCHr BCMI_MADURA_DSC_SCRATCHr
#define DSC_SCRATCHr_SIZE BCMI_MADURA_DSC_SCRATCHr_SIZE
typedef BCMI_MADURA_DSC_SCRATCHr_t DSC_SCRATCHr_t;
#define DSC_SCRATCHr_CLR BCMI_MADURA_DSC_SCRATCHr_CLR
#define DSC_SCRATCHr_SET BCMI_MADURA_DSC_SCRATCHr_SET
#define DSC_SCRATCHr_GET BCMI_MADURA_DSC_SCRATCHr_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_GET BCMI_MADURA_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_SET BCMI_MADURA_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET
#define READ_DSC_SCRATCHr BCMI_MADURA_READ_DSC_SCRATCHr
#define WRITE_DSC_SCRATCHr BCMI_MADURA_WRITE_DSC_SCRATCHr
#define MODIFY_DSC_SCRATCHr BCMI_MADURA_MODIFY_DSC_SCRATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SCRATCHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_A_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd040
 * DEVAD:    1
 * DESC:     trnsum a low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_A_LOW     Trnsum interleave 'a' LSB result (7:0)
 */
#define BCMI_MADURA_DSC_TRNSUM_A_LOr (0x0001d040 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_A_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_A_LO.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_A_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_a_lo[1];
	uint32_t _dsc_trnsum_a_lo;
} BCMI_MADURA_DSC_TRNSUM_A_LOr_t;

#define BCMI_MADURA_DSC_TRNSUM_A_LOr_CLR(r) (r).dsc_trnsum_a_lo[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_A_LOr_SET(r,d) (r).dsc_trnsum_a_lo[0] = d
#define BCMI_MADURA_DSC_TRNSUM_A_LOr_GET(r) (r).dsc_trnsum_a_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET(r) ((((r).dsc_trnsum_a_lo[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET(r,f) (r).dsc_trnsum_a_lo[0]=(((r).dsc_trnsum_a_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_A_LO.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_A_LOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_A_LOr,_r._dsc_trnsum_a_lo)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_A_LOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_A_LOr,_r._dsc_trnsum_a_lo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_A_LOr BCMI_MADURA_DSC_TRNSUM_A_LOr
#define DSC_TRNSUM_A_LOr_SIZE BCMI_MADURA_DSC_TRNSUM_A_LOr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_A_LOr_t DSC_TRNSUM_A_LOr_t;
#define DSC_TRNSUM_A_LOr_CLR BCMI_MADURA_DSC_TRNSUM_A_LOr_CLR
#define DSC_TRNSUM_A_LOr_SET BCMI_MADURA_DSC_TRNSUM_A_LOr_SET
#define DSC_TRNSUM_A_LOr_GET BCMI_MADURA_DSC_TRNSUM_A_LOr_GET
#define DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET BCMI_MADURA_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET
#define DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET BCMI_MADURA_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET
#define READ_DSC_TRNSUM_A_LOr BCMI_MADURA_READ_DSC_TRNSUM_A_LOr
#define WRITE_DSC_TRNSUM_A_LOr BCMI_MADURA_WRITE_DSC_TRNSUM_A_LOr
#define MODIFY_DSC_TRNSUM_A_LOr BCMI_MADURA_MODIFY_DSC_TRNSUM_A_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_A_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_A
 * BLOCKS:   DSC_B
 * REGADDR:  0xd041
 * DEVAD:    1
 * DESC:     trnsum a register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_A         Trnsum interleave 'a' result (23:8)
 */
#define BCMI_MADURA_DSC_TRNSUM_Ar (0x0001d041 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_Ar_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_A.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_Ar_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_a[1];
	uint32_t _dsc_trnsum_a;
} BCMI_MADURA_DSC_TRNSUM_Ar_t;

#define BCMI_MADURA_DSC_TRNSUM_Ar_CLR(r) (r).dsc_trnsum_a[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_Ar_SET(r,d) (r).dsc_trnsum_a[0] = d
#define BCMI_MADURA_DSC_TRNSUM_Ar_GET(r) (r).dsc_trnsum_a[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_Ar_TRNSUM_Af_GET(r) (((r).dsc_trnsum_a[0]) & 0xffff)
#define BCMI_MADURA_DSC_TRNSUM_Ar_TRNSUM_Af_SET(r,f) (r).dsc_trnsum_a[0]=(((r).dsc_trnsum_a[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_A.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_Ar(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_Ar,_r._dsc_trnsum_a)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_Ar(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_Ar,_r._dsc_trnsum_a)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Ar BCMI_MADURA_DSC_TRNSUM_Ar
#define DSC_TRNSUM_Ar_SIZE BCMI_MADURA_DSC_TRNSUM_Ar_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_Ar_t DSC_TRNSUM_Ar_t;
#define DSC_TRNSUM_Ar_CLR BCMI_MADURA_DSC_TRNSUM_Ar_CLR
#define DSC_TRNSUM_Ar_SET BCMI_MADURA_DSC_TRNSUM_Ar_SET
#define DSC_TRNSUM_Ar_GET BCMI_MADURA_DSC_TRNSUM_Ar_GET
#define DSC_TRNSUM_Ar_TRNSUM_Af_GET BCMI_MADURA_DSC_TRNSUM_Ar_TRNSUM_Af_GET
#define DSC_TRNSUM_Ar_TRNSUM_Af_SET BCMI_MADURA_DSC_TRNSUM_Ar_TRNSUM_Af_SET
#define READ_DSC_TRNSUM_Ar BCMI_MADURA_READ_DSC_TRNSUM_Ar
#define WRITE_DSC_TRNSUM_Ar BCMI_MADURA_WRITE_DSC_TRNSUM_Ar
#define MODIFY_DSC_TRNSUM_Ar BCMI_MADURA_MODIFY_DSC_TRNSUM_Ar

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_Ar'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_B_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd042
 * DEVAD:    1
 * DESC:     trnsum b low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_B_LOW     Trnsum interleave 'b' LSB result (7:0)
 */
#define BCMI_MADURA_DSC_TRNSUM_B_LOr (0x0001d042 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_B_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_B_LO.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_B_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_b_lo[1];
	uint32_t _dsc_trnsum_b_lo;
} BCMI_MADURA_DSC_TRNSUM_B_LOr_t;

#define BCMI_MADURA_DSC_TRNSUM_B_LOr_CLR(r) (r).dsc_trnsum_b_lo[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_B_LOr_SET(r,d) (r).dsc_trnsum_b_lo[0] = d
#define BCMI_MADURA_DSC_TRNSUM_B_LOr_GET(r) (r).dsc_trnsum_b_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET(r) ((((r).dsc_trnsum_b_lo[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET(r,f) (r).dsc_trnsum_b_lo[0]=(((r).dsc_trnsum_b_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_B_LO.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_B_LOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_B_LOr,_r._dsc_trnsum_b_lo)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_B_LOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_B_LOr,_r._dsc_trnsum_b_lo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_B_LOr BCMI_MADURA_DSC_TRNSUM_B_LOr
#define DSC_TRNSUM_B_LOr_SIZE BCMI_MADURA_DSC_TRNSUM_B_LOr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_B_LOr_t DSC_TRNSUM_B_LOr_t;
#define DSC_TRNSUM_B_LOr_CLR BCMI_MADURA_DSC_TRNSUM_B_LOr_CLR
#define DSC_TRNSUM_B_LOr_SET BCMI_MADURA_DSC_TRNSUM_B_LOr_SET
#define DSC_TRNSUM_B_LOr_GET BCMI_MADURA_DSC_TRNSUM_B_LOr_GET
#define DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET BCMI_MADURA_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET
#define DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET BCMI_MADURA_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET
#define READ_DSC_TRNSUM_B_LOr BCMI_MADURA_READ_DSC_TRNSUM_B_LOr
#define WRITE_DSC_TRNSUM_B_LOr BCMI_MADURA_WRITE_DSC_TRNSUM_B_LOr
#define MODIFY_DSC_TRNSUM_B_LOr BCMI_MADURA_MODIFY_DSC_TRNSUM_B_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_B_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_B
 * BLOCKS:   DSC_B
 * REGADDR:  0xd043
 * DEVAD:    1
 * DESC:     trnsum b register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_B         Trnsum interleave 'b' result (23:8)
 */
#define BCMI_MADURA_DSC_TRNSUM_Br (0x0001d043 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_Br_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_B.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_Br_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_b[1];
	uint32_t _dsc_trnsum_b;
} BCMI_MADURA_DSC_TRNSUM_Br_t;

#define BCMI_MADURA_DSC_TRNSUM_Br_CLR(r) (r).dsc_trnsum_b[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_Br_SET(r,d) (r).dsc_trnsum_b[0] = d
#define BCMI_MADURA_DSC_TRNSUM_Br_GET(r) (r).dsc_trnsum_b[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_Br_TRNSUM_Bf_GET(r) (((r).dsc_trnsum_b[0]) & 0xffff)
#define BCMI_MADURA_DSC_TRNSUM_Br_TRNSUM_Bf_SET(r,f) (r).dsc_trnsum_b[0]=(((r).dsc_trnsum_b[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_B.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_Br(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_Br,_r._dsc_trnsum_b)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_Br(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_Br,_r._dsc_trnsum_b)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Br BCMI_MADURA_DSC_TRNSUM_Br
#define DSC_TRNSUM_Br_SIZE BCMI_MADURA_DSC_TRNSUM_Br_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_Br_t DSC_TRNSUM_Br_t;
#define DSC_TRNSUM_Br_CLR BCMI_MADURA_DSC_TRNSUM_Br_CLR
#define DSC_TRNSUM_Br_SET BCMI_MADURA_DSC_TRNSUM_Br_SET
#define DSC_TRNSUM_Br_GET BCMI_MADURA_DSC_TRNSUM_Br_GET
#define DSC_TRNSUM_Br_TRNSUM_Bf_GET BCMI_MADURA_DSC_TRNSUM_Br_TRNSUM_Bf_GET
#define DSC_TRNSUM_Br_TRNSUM_Bf_SET BCMI_MADURA_DSC_TRNSUM_Br_TRNSUM_Bf_SET
#define READ_DSC_TRNSUM_Br BCMI_MADURA_READ_DSC_TRNSUM_Br
#define WRITE_DSC_TRNSUM_Br BCMI_MADURA_WRITE_DSC_TRNSUM_Br
#define MODIFY_DSC_TRNSUM_Br BCMI_MADURA_MODIFY_DSC_TRNSUM_Br

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_Br'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_C_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd044
 * DEVAD:    1
 * DESC:     trnsum c low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_C_LOW     Trnsum interleave 'c' LSB result (7:0)
 */
#define BCMI_MADURA_DSC_TRNSUM_C_LOr (0x0001d044 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_C_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_C_LO.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_C_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_c_lo[1];
	uint32_t _dsc_trnsum_c_lo;
} BCMI_MADURA_DSC_TRNSUM_C_LOr_t;

#define BCMI_MADURA_DSC_TRNSUM_C_LOr_CLR(r) (r).dsc_trnsum_c_lo[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_C_LOr_SET(r,d) (r).dsc_trnsum_c_lo[0] = d
#define BCMI_MADURA_DSC_TRNSUM_C_LOr_GET(r) (r).dsc_trnsum_c_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET(r) ((((r).dsc_trnsum_c_lo[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET(r,f) (r).dsc_trnsum_c_lo[0]=(((r).dsc_trnsum_c_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_C_LO.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_C_LOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_C_LOr,_r._dsc_trnsum_c_lo)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_C_LOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_C_LOr,_r._dsc_trnsum_c_lo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_C_LOr BCMI_MADURA_DSC_TRNSUM_C_LOr
#define DSC_TRNSUM_C_LOr_SIZE BCMI_MADURA_DSC_TRNSUM_C_LOr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_C_LOr_t DSC_TRNSUM_C_LOr_t;
#define DSC_TRNSUM_C_LOr_CLR BCMI_MADURA_DSC_TRNSUM_C_LOr_CLR
#define DSC_TRNSUM_C_LOr_SET BCMI_MADURA_DSC_TRNSUM_C_LOr_SET
#define DSC_TRNSUM_C_LOr_GET BCMI_MADURA_DSC_TRNSUM_C_LOr_GET
#define DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET BCMI_MADURA_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET
#define DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET BCMI_MADURA_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET
#define READ_DSC_TRNSUM_C_LOr BCMI_MADURA_READ_DSC_TRNSUM_C_LOr
#define WRITE_DSC_TRNSUM_C_LOr BCMI_MADURA_WRITE_DSC_TRNSUM_C_LOr
#define MODIFY_DSC_TRNSUM_C_LOr BCMI_MADURA_MODIFY_DSC_TRNSUM_C_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_C_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_C
 * BLOCKS:   DSC_B
 * REGADDR:  0xd045
 * DEVAD:    1
 * DESC:     trnsum c register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_C         Trnsum interleave 'c' result (23:8)
 */
#define BCMI_MADURA_DSC_TRNSUM_Cr (0x0001d045 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_Cr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_C.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_Cr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_c[1];
	uint32_t _dsc_trnsum_c;
} BCMI_MADURA_DSC_TRNSUM_Cr_t;

#define BCMI_MADURA_DSC_TRNSUM_Cr_CLR(r) (r).dsc_trnsum_c[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_Cr_SET(r,d) (r).dsc_trnsum_c[0] = d
#define BCMI_MADURA_DSC_TRNSUM_Cr_GET(r) (r).dsc_trnsum_c[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_Cr_TRNSUM_Cf_GET(r) (((r).dsc_trnsum_c[0]) & 0xffff)
#define BCMI_MADURA_DSC_TRNSUM_Cr_TRNSUM_Cf_SET(r,f) (r).dsc_trnsum_c[0]=(((r).dsc_trnsum_c[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_C.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_Cr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_Cr,_r._dsc_trnsum_c)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_Cr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_Cr,_r._dsc_trnsum_c)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Cr BCMI_MADURA_DSC_TRNSUM_Cr
#define DSC_TRNSUM_Cr_SIZE BCMI_MADURA_DSC_TRNSUM_Cr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_Cr_t DSC_TRNSUM_Cr_t;
#define DSC_TRNSUM_Cr_CLR BCMI_MADURA_DSC_TRNSUM_Cr_CLR
#define DSC_TRNSUM_Cr_SET BCMI_MADURA_DSC_TRNSUM_Cr_SET
#define DSC_TRNSUM_Cr_GET BCMI_MADURA_DSC_TRNSUM_Cr_GET
#define DSC_TRNSUM_Cr_TRNSUM_Cf_GET BCMI_MADURA_DSC_TRNSUM_Cr_TRNSUM_Cf_GET
#define DSC_TRNSUM_Cr_TRNSUM_Cf_SET BCMI_MADURA_DSC_TRNSUM_Cr_TRNSUM_Cf_SET
#define READ_DSC_TRNSUM_Cr BCMI_MADURA_READ_DSC_TRNSUM_Cr
#define WRITE_DSC_TRNSUM_Cr BCMI_MADURA_WRITE_DSC_TRNSUM_Cr
#define MODIFY_DSC_TRNSUM_Cr BCMI_MADURA_MODIFY_DSC_TRNSUM_Cr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_Cr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_D_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd046
 * DEVAD:    1
 * DESC:     trnsum d low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_D_LOW     Trnsum interleave 'd' LSB result (7:0)
 */
#define BCMI_MADURA_DSC_TRNSUM_D_LOr (0x0001d046 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_D_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_D_LO.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_D_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_d_lo[1];
	uint32_t _dsc_trnsum_d_lo;
} BCMI_MADURA_DSC_TRNSUM_D_LOr_t;

#define BCMI_MADURA_DSC_TRNSUM_D_LOr_CLR(r) (r).dsc_trnsum_d_lo[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_D_LOr_SET(r,d) (r).dsc_trnsum_d_lo[0] = d
#define BCMI_MADURA_DSC_TRNSUM_D_LOr_GET(r) (r).dsc_trnsum_d_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET(r) ((((r).dsc_trnsum_d_lo[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET(r,f) (r).dsc_trnsum_d_lo[0]=(((r).dsc_trnsum_d_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_D_LO.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_D_LOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_D_LOr,_r._dsc_trnsum_d_lo)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_D_LOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_D_LOr,_r._dsc_trnsum_d_lo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_D_LOr BCMI_MADURA_DSC_TRNSUM_D_LOr
#define DSC_TRNSUM_D_LOr_SIZE BCMI_MADURA_DSC_TRNSUM_D_LOr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_D_LOr_t DSC_TRNSUM_D_LOr_t;
#define DSC_TRNSUM_D_LOr_CLR BCMI_MADURA_DSC_TRNSUM_D_LOr_CLR
#define DSC_TRNSUM_D_LOr_SET BCMI_MADURA_DSC_TRNSUM_D_LOr_SET
#define DSC_TRNSUM_D_LOr_GET BCMI_MADURA_DSC_TRNSUM_D_LOr_GET
#define DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET BCMI_MADURA_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET
#define DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET BCMI_MADURA_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET
#define READ_DSC_TRNSUM_D_LOr BCMI_MADURA_READ_DSC_TRNSUM_D_LOr
#define WRITE_DSC_TRNSUM_D_LOr BCMI_MADURA_WRITE_DSC_TRNSUM_D_LOr
#define MODIFY_DSC_TRNSUM_D_LOr BCMI_MADURA_MODIFY_DSC_TRNSUM_D_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_D_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_D
 * BLOCKS:   DSC_B
 * REGADDR:  0xd047
 * DEVAD:    1
 * DESC:     trnsum d register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_D         Trnsum interleave 'd' result (15:8)
 */
#define BCMI_MADURA_DSC_TRNSUM_Dr (0x0001d047 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_D.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_Dr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_d[1];
	uint32_t _dsc_trnsum_d;
} BCMI_MADURA_DSC_TRNSUM_Dr_t;

#define BCMI_MADURA_DSC_TRNSUM_Dr_CLR(r) (r).dsc_trnsum_d[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_Dr_SET(r,d) (r).dsc_trnsum_d[0] = d
#define BCMI_MADURA_DSC_TRNSUM_Dr_GET(r) (r).dsc_trnsum_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_Dr_TRNSUM_Df_GET(r) (((r).dsc_trnsum_d[0]) & 0xffff)
#define BCMI_MADURA_DSC_TRNSUM_Dr_TRNSUM_Df_SET(r,f) (r).dsc_trnsum_d[0]=(((r).dsc_trnsum_d[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_D.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_Dr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_Dr,_r._dsc_trnsum_d)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_Dr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_Dr,_r._dsc_trnsum_d)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Dr BCMI_MADURA_DSC_TRNSUM_Dr
#define DSC_TRNSUM_Dr_SIZE BCMI_MADURA_DSC_TRNSUM_Dr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_Dr_t DSC_TRNSUM_Dr_t;
#define DSC_TRNSUM_Dr_CLR BCMI_MADURA_DSC_TRNSUM_Dr_CLR
#define DSC_TRNSUM_Dr_SET BCMI_MADURA_DSC_TRNSUM_Dr_SET
#define DSC_TRNSUM_Dr_GET BCMI_MADURA_DSC_TRNSUM_Dr_GET
#define DSC_TRNSUM_Dr_TRNSUM_Df_GET BCMI_MADURA_DSC_TRNSUM_Dr_TRNSUM_Df_GET
#define DSC_TRNSUM_Dr_TRNSUM_Df_SET BCMI_MADURA_DSC_TRNSUM_Dr_TRNSUM_Df_SET
#define READ_DSC_TRNSUM_Dr BCMI_MADURA_READ_DSC_TRNSUM_Dr
#define WRITE_DSC_TRNSUM_Dr BCMI_MADURA_WRITE_DSC_TRNSUM_Dr
#define MODIFY_DSC_TRNSUM_Dr BCMI_MADURA_MODIFY_DSC_TRNSUM_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd048
 * DEVAD:    1
 * DESC:     trnsum low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_LOW       Trnsum  LSB result (9:0)
 */
#define BCMI_MADURA_DSC_TRNSUM_LOr (0x0001d048 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_LO.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_lo[1];
	uint32_t _dsc_trnsum_lo;
} BCMI_MADURA_DSC_TRNSUM_LOr_t;

#define BCMI_MADURA_DSC_TRNSUM_LOr_CLR(r) (r).dsc_trnsum_lo[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_LOr_SET(r,d) (r).dsc_trnsum_lo[0] = d
#define BCMI_MADURA_DSC_TRNSUM_LOr_GET(r) (r).dsc_trnsum_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_LOr_TRNSUM_LOWf_GET(r) ((((r).dsc_trnsum_lo[0]) >> 6) & 0x3ff)
#define BCMI_MADURA_DSC_TRNSUM_LOr_TRNSUM_LOWf_SET(r,f) (r).dsc_trnsum_lo[0]=(((r).dsc_trnsum_lo[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access DSC_TRNSUM_LO.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_LOr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_LOr,_r._dsc_trnsum_lo)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_LOr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_LOr,_r._dsc_trnsum_lo)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_LOr BCMI_MADURA_DSC_TRNSUM_LOr
#define DSC_TRNSUM_LOr_SIZE BCMI_MADURA_DSC_TRNSUM_LOr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_LOr_t DSC_TRNSUM_LOr_t;
#define DSC_TRNSUM_LOr_CLR BCMI_MADURA_DSC_TRNSUM_LOr_CLR
#define DSC_TRNSUM_LOr_SET BCMI_MADURA_DSC_TRNSUM_LOr_SET
#define DSC_TRNSUM_LOr_GET BCMI_MADURA_DSC_TRNSUM_LOr_GET
#define DSC_TRNSUM_LOr_TRNSUM_LOWf_GET BCMI_MADURA_DSC_TRNSUM_LOr_TRNSUM_LOWf_GET
#define DSC_TRNSUM_LOr_TRNSUM_LOWf_SET BCMI_MADURA_DSC_TRNSUM_LOr_TRNSUM_LOWf_SET
#define READ_DSC_TRNSUM_LOr BCMI_MADURA_READ_DSC_TRNSUM_LOr
#define WRITE_DSC_TRNSUM_LOr BCMI_MADURA_WRITE_DSC_TRNSUM_LOr
#define MODIFY_DSC_TRNSUM_LOr BCMI_MADURA_MODIFY_DSC_TRNSUM_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM
 * BLOCKS:   DSC_B
 * REGADDR:  0xd049
 * DEVAD:    1
 * DESC:     trnsum register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM           Trnsum result (25:10)
 */
#define BCMI_MADURA_DSC_TRNSUMr (0x0001d049 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUMr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM.
 */
typedef union BCMI_MADURA_DSC_TRNSUMr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum[1];
	uint32_t _dsc_trnsum;
} BCMI_MADURA_DSC_TRNSUMr_t;

#define BCMI_MADURA_DSC_TRNSUMr_CLR(r) (r).dsc_trnsum[0] = 0
#define BCMI_MADURA_DSC_TRNSUMr_SET(r,d) (r).dsc_trnsum[0] = d
#define BCMI_MADURA_DSC_TRNSUMr_GET(r) (r).dsc_trnsum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUMr_TRNSUMf_GET(r) (((r).dsc_trnsum[0]) & 0xffff)
#define BCMI_MADURA_DSC_TRNSUMr_TRNSUMf_SET(r,f) (r).dsc_trnsum[0]=(((r).dsc_trnsum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM.
 */
#define BCMI_MADURA_READ_DSC_TRNSUMr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUMr,_r._dsc_trnsum)
#define BCMI_MADURA_WRITE_DSC_TRNSUMr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUMr,_r._dsc_trnsum)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUMr BCMI_MADURA_DSC_TRNSUMr
#define DSC_TRNSUMr_SIZE BCMI_MADURA_DSC_TRNSUMr_SIZE
typedef BCMI_MADURA_DSC_TRNSUMr_t DSC_TRNSUMr_t;
#define DSC_TRNSUMr_CLR BCMI_MADURA_DSC_TRNSUMr_CLR
#define DSC_TRNSUMr_SET BCMI_MADURA_DSC_TRNSUMr_SET
#define DSC_TRNSUMr_GET BCMI_MADURA_DSC_TRNSUMr_GET
#define DSC_TRNSUMr_TRNSUMf_GET BCMI_MADURA_DSC_TRNSUMr_TRNSUMf_GET
#define DSC_TRNSUMr_TRNSUMf_SET BCMI_MADURA_DSC_TRNSUMr_TRNSUMf_SET
#define READ_DSC_TRNSUMr BCMI_MADURA_READ_DSC_TRNSUMr
#define WRITE_DSC_TRNSUMr BCMI_MADURA_WRITE_DSC_TRNSUMr
#define MODIFY_DSC_TRNSUMr BCMI_MADURA_MODIFY_DSC_TRNSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_DC_OFFS_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04c
 * DEVAD:    1
 * DESC:     dc offset status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DC_OFFSET_BIN    rx dc offset
 */
#define BCMI_MADURA_DSC_DC_OFFS_STSr (0x0001d04c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_DC_OFFS_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS_STS.
 */
typedef union BCMI_MADURA_DSC_DC_OFFS_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs_sts[1];
	uint32_t _dsc_dc_offs_sts;
} BCMI_MADURA_DSC_DC_OFFS_STSr_t;

#define BCMI_MADURA_DSC_DC_OFFS_STSr_CLR(r) (r).dsc_dc_offs_sts[0] = 0
#define BCMI_MADURA_DSC_DC_OFFS_STSr_SET(r,d) (r).dsc_dc_offs_sts[0] = d
#define BCMI_MADURA_DSC_DC_OFFS_STSr_GET(r) (r).dsc_dc_offs_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET(r) (((r).dsc_dc_offs_sts[0]) & 0x7f)
#define BCMI_MADURA_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET(r,f) (r).dsc_dc_offs_sts[0]=(((r).dsc_dc_offs_sts[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_DC_OFFS_STS.
 */
#define BCMI_MADURA_READ_DSC_DC_OFFS_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_DC_OFFS_STSr,_r._dsc_dc_offs_sts)
#define BCMI_MADURA_WRITE_DSC_DC_OFFS_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_DC_OFFS_STSr,_r._dsc_dc_offs_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFS_STSr BCMI_MADURA_DSC_DC_OFFS_STSr
#define DSC_DC_OFFS_STSr_SIZE BCMI_MADURA_DSC_DC_OFFS_STSr_SIZE
typedef BCMI_MADURA_DSC_DC_OFFS_STSr_t DSC_DC_OFFS_STSr_t;
#define DSC_DC_OFFS_STSr_CLR BCMI_MADURA_DSC_DC_OFFS_STSr_CLR
#define DSC_DC_OFFS_STSr_SET BCMI_MADURA_DSC_DC_OFFS_STSr_SET
#define DSC_DC_OFFS_STSr_GET BCMI_MADURA_DSC_DC_OFFS_STSr_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET BCMI_MADURA_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET BCMI_MADURA_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET
#define READ_DSC_DC_OFFS_STSr BCMI_MADURA_READ_DSC_DC_OFFS_STSr
#define WRITE_DSC_DC_OFFS_STSr BCMI_MADURA_WRITE_DSC_DC_OFFS_STSr
#define MODIFY_DSC_DC_OFFS_STSr BCMI_MADURA_MODIFY_DSC_DC_OFFS_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_DC_OFFS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_VGA_D_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04d
 * DEVAD:    1
 * DESC:     vga gain and data threshold status register.
 * RESETVAL: 0x2700 (9984)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_THRESH_SEL Read out of the Data Slicer threshold in 2's complement signed format.
 *     RX_VGA_CTRL      Read out of the VGA control.
 */
#define BCMI_MADURA_DSC_VGA_D_THR_STSr (0x0001d04d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_VGA_D_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_D_THR_STS.
 */
typedef union BCMI_MADURA_DSC_VGA_D_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_d_thr_sts[1];
	uint32_t _dsc_vga_d_thr_sts;
} BCMI_MADURA_DSC_VGA_D_THR_STSr_t;

#define BCMI_MADURA_DSC_VGA_D_THR_STSr_CLR(r) (r).dsc_vga_d_thr_sts[0] = 0
#define BCMI_MADURA_DSC_VGA_D_THR_STSr_SET(r,d) (r).dsc_vga_d_thr_sts[0] = d
#define BCMI_MADURA_DSC_VGA_D_THR_STSr_GET(r) (r).dsc_vga_d_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_GET(r) ((((r).dsc_vga_d_thr_sts[0]) >> 8) & 0x7f)
#define BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_GET(r) (((r).dsc_vga_d_thr_sts[0]) & 0x7f)
#define BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_VGA_D_THR_STS.
 */
#define BCMI_MADURA_READ_DSC_VGA_D_THR_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_VGA_D_THR_STSr,_r._dsc_vga_d_thr_sts)
#define BCMI_MADURA_WRITE_DSC_VGA_D_THR_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_VGA_D_THR_STSr,_r._dsc_vga_d_thr_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_D_THR_STSr BCMI_MADURA_DSC_VGA_D_THR_STSr
#define DSC_VGA_D_THR_STSr_SIZE BCMI_MADURA_DSC_VGA_D_THR_STSr_SIZE
typedef BCMI_MADURA_DSC_VGA_D_THR_STSr_t DSC_VGA_D_THR_STSr_t;
#define DSC_VGA_D_THR_STSr_CLR BCMI_MADURA_DSC_VGA_D_THR_STSr_CLR
#define DSC_VGA_D_THR_STSr_SET BCMI_MADURA_DSC_VGA_D_THR_STSr_SET
#define DSC_VGA_D_THR_STSr_GET BCMI_MADURA_DSC_VGA_D_THR_STSr_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_GET BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_SET BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_SET
#define DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_GET BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_GET
#define DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_SET BCMI_MADURA_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_SET
#define READ_DSC_VGA_D_THR_STSr BCMI_MADURA_READ_DSC_VGA_D_THR_STSr
#define WRITE_DSC_VGA_D_THR_STSr BCMI_MADURA_WRITE_DSC_VGA_D_THR_STSr
#define MODIFY_DSC_VGA_D_THR_STSr BCMI_MADURA_MODIFY_DSC_VGA_D_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_VGA_D_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_CDR_CTL0
 * BLOCKS:   DSC_C
 * REGADDR:  0xd050
 * DEVAD:    1
 * DESC:     cdr control register 0.
 * RESETVAL: 0x9 (9)
 * ACCESS:   R/W
 * FIELDS:
 *     OS_ALL_EDGES     0: 001/110 (and os_pattern_enhanced ==0 and br_pd_en ==0) , 1: x01/x10 patterns
 *     BR_PD_EN         0: (refer to os_all_edges) 1: use 011/100 patterns
 *     OS_PATTERN_ENHANCED when 1, selects 001/110 and also 010/101 from 4 locations {n,n+1, n+9, n+10}
 *     CDR_FREQ_EN      1: 2nd order loop output to contribute
 *     CDR_INTEG_REG_CLR clear integ Register
 *     CDR_PHASE_ERR_FRZ 1: override phase error to be 0
 *     CDR_INTEG_SAT_SEL 0:(-24576, 24575), 1:(-16384, 16383)
 *     CDR_FREQ_OVERRIDE_EN 1:override integ Register with cdr_freq_override_val
 *     CDR_ZERO_POLARITY inverts the phase slicer information before the phase detector
 */
#define BCMI_MADURA_DSC_CDR_CTL0r (0x0001d050 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_CDR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL0.
 */
typedef union BCMI_MADURA_DSC_CDR_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl0[1];
	uint32_t _dsc_cdr_ctl0;
} BCMI_MADURA_DSC_CDR_CTL0r_t;

#define BCMI_MADURA_DSC_CDR_CTL0r_CLR(r) (r).dsc_cdr_ctl0[0] = 0
#define BCMI_MADURA_DSC_CDR_CTL0r_SET(r,d) (r).dsc_cdr_ctl0[0] = d
#define BCMI_MADURA_DSC_CDR_CTL0r_GET(r) (r).dsc_cdr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 9) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 6) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 5) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 3) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DSC_CDR_CTL0r_BR_PD_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_BR_PD_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_CDR_CTL0r_OS_ALL_EDGESf_GET(r) (((r).dsc_cdr_ctl0[0]) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL0r_OS_ALL_EDGESf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL0.
 */
#define BCMI_MADURA_READ_DSC_CDR_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_CDR_CTL0r,_r._dsc_cdr_ctl0)
#define BCMI_MADURA_WRITE_DSC_CDR_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_CDR_CTL0r,_r._dsc_cdr_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL0r BCMI_MADURA_DSC_CDR_CTL0r
#define DSC_CDR_CTL0r_SIZE BCMI_MADURA_DSC_CDR_CTL0r_SIZE
typedef BCMI_MADURA_DSC_CDR_CTL0r_t DSC_CDR_CTL0r_t;
#define DSC_CDR_CTL0r_CLR BCMI_MADURA_DSC_CDR_CTL0r_CLR
#define DSC_CDR_CTL0r_SET BCMI_MADURA_DSC_CDR_CTL0r_SET
#define DSC_CDR_CTL0r_GET BCMI_MADURA_DSC_CDR_CTL0r_GET
#define DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET BCMI_MADURA_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET
#define DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET BCMI_MADURA_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET BCMI_MADURA_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET BCMI_MADURA_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET BCMI_MADURA_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_GET BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_SET BCMI_MADURA_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET
#define DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET BCMI_MADURA_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET
#define DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET BCMI_MADURA_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET
#define DSC_CDR_CTL0r_BR_PD_ENf_GET BCMI_MADURA_DSC_CDR_CTL0r_BR_PD_ENf_GET
#define DSC_CDR_CTL0r_BR_PD_ENf_SET BCMI_MADURA_DSC_CDR_CTL0r_BR_PD_ENf_SET
#define DSC_CDR_CTL0r_OS_ALL_EDGESf_GET BCMI_MADURA_DSC_CDR_CTL0r_OS_ALL_EDGESf_GET
#define DSC_CDR_CTL0r_OS_ALL_EDGESf_SET BCMI_MADURA_DSC_CDR_CTL0r_OS_ALL_EDGESf_SET
#define READ_DSC_CDR_CTL0r BCMI_MADURA_READ_DSC_CDR_CTL0r
#define WRITE_DSC_CDR_CTL0r BCMI_MADURA_WRITE_DSC_CDR_CTL0r
#define MODIFY_DSC_CDR_CTL0r BCMI_MADURA_MODIFY_DSC_CDR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_CDR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_CDR_CTL1
 * BLOCKS:   DSC_C
 * REGADDR:  0xd051
 * DEVAD:    1
 * DESC:     cdr control register 1.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_FREQ_OVERRIDE_VAL Gets loaded into the integ reg @ reset. Also, see alternate use in description of cdr_freq_override_en
 */
#define BCMI_MADURA_DSC_CDR_CTL1r (0x0001d051 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_CDR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL1.
 */
typedef union BCMI_MADURA_DSC_CDR_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl1[1];
	uint32_t _dsc_cdr_ctl1;
} BCMI_MADURA_DSC_CDR_CTL1r_t;

#define BCMI_MADURA_DSC_CDR_CTL1r_CLR(r) (r).dsc_cdr_ctl1[0] = 0
#define BCMI_MADURA_DSC_CDR_CTL1r_SET(r,d) (r).dsc_cdr_ctl1[0] = d
#define BCMI_MADURA_DSC_CDR_CTL1r_GET(r) (r).dsc_cdr_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET(r) ((((r).dsc_cdr_ctl1[0]) >> 5) & 0x7ff)
#define BCMI_MADURA_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))

/*
 * These macros can be used to access DSC_CDR_CTL1.
 */
#define BCMI_MADURA_READ_DSC_CDR_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_CDR_CTL1r,_r._dsc_cdr_ctl1)
#define BCMI_MADURA_WRITE_DSC_CDR_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_CDR_CTL1r,_r._dsc_cdr_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL1r BCMI_MADURA_DSC_CDR_CTL1r
#define DSC_CDR_CTL1r_SIZE BCMI_MADURA_DSC_CDR_CTL1r_SIZE
typedef BCMI_MADURA_DSC_CDR_CTL1r_t DSC_CDR_CTL1r_t;
#define DSC_CDR_CTL1r_CLR BCMI_MADURA_DSC_CDR_CTL1r_CLR
#define DSC_CDR_CTL1r_SET BCMI_MADURA_DSC_CDR_CTL1r_SET
#define DSC_CDR_CTL1r_GET BCMI_MADURA_DSC_CDR_CTL1r_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET BCMI_MADURA_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET BCMI_MADURA_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET
#define READ_DSC_CDR_CTL1r BCMI_MADURA_READ_DSC_CDR_CTL1r
#define WRITE_DSC_CDR_CTL1r BCMI_MADURA_WRITE_DSC_CDR_CTL1r
#define MODIFY_DSC_CDR_CTL1r BCMI_MADURA_MODIFY_DSC_CDR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_CDR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_CDR_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd052
 * DEVAD:    1
 * DESC:     cdr control register 2
 * RESETVAL: 0x80 (128)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_LM_THR_SEL   cdr lock monitor looks for integ reg to be within sat level - (cdr_lm_thr_sel +1)*512 in magnitude
 *     CDR_1G_SWAP_PZ   When 1, this will swap the peaks and zeros going out as the DME data. It will still use the original peaks and zeros for data recovery.
 *     CDR_1G_FORCE_EN  Forces the enable on the 1g logic. Else it should be enabled with osr mode setting to correct value.
 *     TX_PI_LOOP_TIMING_SRC_SEL Needs to be 1 in order to gate the phase sum on.
 *     PHS_SUM_IGNORE_DSC_LOCK Normally the phase summer waits for dsc lock. This bit overrides that wait.
 *     CDR_1G_MANUAL_MODE Puts the 1G CDR in manual mode.
 *     CDR_1G_MANUAL_STROBE Manual Strobe for the 1G CDR.
 *     CDR_PROP_BW_EXTEND When 1, the proportional BW is increased by 2{cdr_prop_bw_extend, cdr_bwsel_prop_[norm/acqcdr]}: Gain===============================================0, 0                   :                 *10, 1                   :                 *21, 0                   :                 *31, 1                   :                 *4
 */
#define BCMI_MADURA_DSC_CDR_CTL2r (0x0001d052 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_CDR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL2.
 */
typedef union BCMI_MADURA_DSC_CDR_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl2[1];
	uint32_t _dsc_cdr_ctl2;
} BCMI_MADURA_DSC_CDR_CTL2r_t;

#define BCMI_MADURA_DSC_CDR_CTL2r_CLR(r) (r).dsc_cdr_ctl2[0] = 0
#define BCMI_MADURA_DSC_CDR_CTL2r_SET(r,d) (r).dsc_cdr_ctl2[0] = d
#define BCMI_MADURA_DSC_CDR_CTL2r_GET(r) (r).dsc_cdr_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 10) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 9) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 8) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 6) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 5) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 4) & 0x1)
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET(r) (((r).dsc_cdr_ctl2[0]) & 0xf)
#define BCMI_MADURA_DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_CDR_CTL2.
 */
#define BCMI_MADURA_READ_DSC_CDR_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_CDR_CTL2r,_r._dsc_cdr_ctl2)
#define BCMI_MADURA_WRITE_DSC_CDR_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_CDR_CTL2r,_r._dsc_cdr_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL2r BCMI_MADURA_DSC_CDR_CTL2r
#define DSC_CDR_CTL2r_SIZE BCMI_MADURA_DSC_CDR_CTL2r_SIZE
typedef BCMI_MADURA_DSC_CDR_CTL2r_t DSC_CDR_CTL2r_t;
#define DSC_CDR_CTL2r_CLR BCMI_MADURA_DSC_CDR_CTL2r_CLR
#define DSC_CDR_CTL2r_SET BCMI_MADURA_DSC_CDR_CTL2r_SET
#define DSC_CDR_CTL2r_GET BCMI_MADURA_DSC_CDR_CTL2r_GET
#define DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_GET BCMI_MADURA_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_GET
#define DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_SET BCMI_MADURA_DSC_CDR_CTL2r_CDR_PROP_BW_EXTENDf_SET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET
#define DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET BCMI_MADURA_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET
#define DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET BCMI_MADURA_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET BCMI_MADURA_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET BCMI_MADURA_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET
#define DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET
#define DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET
#define DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET
#define DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET BCMI_MADURA_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET
#define DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET BCMI_MADURA_DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET
#define DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET BCMI_MADURA_DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET
#define READ_DSC_CDR_CTL2r BCMI_MADURA_READ_DSC_CDR_CTL2r
#define WRITE_DSC_CDR_CTL2r BCMI_MADURA_WRITE_DSC_CDR_CTL2r
#define MODIFY_DSC_CDR_CTL2r BCMI_MADURA_MODIFY_DSC_CDR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_CDR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PI_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd053
 * DEVAD:    1
 * DESC:     rx pi control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_SLICERS_EN bit-vector representing which PI's to adjust: [0] d, [1] dq, [2] p, [3] pq, [4] l, [6] lq
 *     RX_PI_PHASE_STEP_CNT # of steps to adjust: 0..7: [1, 46,52,58,64,70,76,84]
 *     RX_PI_PHASE_STEP_DIR 0: left shift, 1: right shift
 *     RX_PI_MANUAL_MODE 0: normal, 1:disconnect all PI's from CDR when enabled
 *     RX_PI_MANUAL_STROBE perform a manual override over specified number of clocks
 */
#define BCMI_MADURA_DSC_RX_PI_CTLr (0x0001d053 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PI_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CTL.
 */
typedef union BCMI_MADURA_DSC_RX_PI_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_ctl[1];
	uint32_t _dsc_rx_pi_ctl;
} BCMI_MADURA_DSC_RX_PI_CTLr_t;

#define BCMI_MADURA_DSC_RX_PI_CTLr_CLR(r) (r).dsc_rx_pi_ctl[0] = 0
#define BCMI_MADURA_DSC_RX_PI_CTLr_SET(r,d) (r).dsc_rx_pi_ctl[0] = d
#define BCMI_MADURA_DSC_RX_PI_CTLr_GET(r) (r).dsc_rx_pi_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 11) & 0x1)
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 10) & 0x1)
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 6) & 0x7)
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET(r) (((r).dsc_rx_pi_ctl[0]) & 0x3f)
#define BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CTL.
 */
#define BCMI_MADURA_READ_DSC_RX_PI_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PI_CTLr,_r._dsc_rx_pi_ctl)
#define BCMI_MADURA_WRITE_DSC_RX_PI_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PI_CTLr,_r._dsc_rx_pi_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CTLr BCMI_MADURA_DSC_RX_PI_CTLr
#define DSC_RX_PI_CTLr_SIZE BCMI_MADURA_DSC_RX_PI_CTLr_SIZE
typedef BCMI_MADURA_DSC_RX_PI_CTLr_t DSC_RX_PI_CTLr_t;
#define DSC_RX_PI_CTLr_CLR BCMI_MADURA_DSC_RX_PI_CTLr_CLR
#define DSC_RX_PI_CTLr_SET BCMI_MADURA_DSC_RX_PI_CTLr_SET
#define DSC_RX_PI_CTLr_GET BCMI_MADURA_DSC_RX_PI_CTLr_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET BCMI_MADURA_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET
#define READ_DSC_RX_PI_CTLr BCMI_MADURA_READ_DSC_RX_PI_CTLr
#define WRITE_DSC_RX_PI_CTLr BCMI_MADURA_WRITE_DSC_RX_PI_CTLr
#define MODIFY_DSC_RX_PI_CTLr BCMI_MADURA_MODIFY_DSC_RX_PI_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PI_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd054
 * DEVAD:    1
 * DESC:     trnsum control 2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_CLR_SC    Self Clearing bitWhen asserted, the trnsum accumulator clears.
 *     TRNSUM_DISABLE_SM_CLEAR When asserted,a pulse on uc_trnsum_en no longer clears the accumulator.
 *     TRNSUM_PATTERN_MATCH_SEL 0, 3: pattern matching on rx_data1: pattern matching on m1err2: pattern matching on expected prbs data
 *     TRNSUM_EYE_CLOSE_PREV_EN When 1, the first eye close event after previous 6 non-eye closure events is picked. The eye close condition settings need to be turned on for this setting to work.
 *     TRNSUM_EYE_CLOSURE_ERR_SEL When trnsum_eye_closure_en is set, this field determines what is compared against d slicer. d!=error_selected , where error_selected is:1'b0: emux1'b1: expected prbs
 */
#define BCMI_MADURA_DSC_TRNSUM_CTL2r (0x0001d054 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL2.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl2[1];
	uint32_t _dsc_trnsum_ctl2;
} BCMI_MADURA_DSC_TRNSUM_CTL2r_t;

#define BCMI_MADURA_DSC_TRNSUM_CTL2r_CLR(r) (r).dsc_trnsum_ctl2[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_SET(r,d) (r).dsc_trnsum_ctl2[0] = d
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_GET(r) (r).dsc_trnsum_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 5) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 4) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 2) & 0x3)
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_GET(r) ((((r).dsc_trnsum_ctl2[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_GET(r) (((r).dsc_trnsum_ctl2[0]) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_SET(r,f) (r).dsc_trnsum_ctl2[0]=(((r).dsc_trnsum_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL2.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_CTL2r,_r._dsc_trnsum_ctl2)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_CTL2r,_r._dsc_trnsum_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTL2r BCMI_MADURA_DSC_TRNSUM_CTL2r
#define DSC_TRNSUM_CTL2r_SIZE BCMI_MADURA_DSC_TRNSUM_CTL2r_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_CTL2r_t DSC_TRNSUM_CTL2r_t;
#define DSC_TRNSUM_CTL2r_CLR BCMI_MADURA_DSC_TRNSUM_CTL2r_CLR
#define DSC_TRNSUM_CTL2r_SET BCMI_MADURA_DSC_TRNSUM_CTL2r_SET
#define DSC_TRNSUM_CTL2r_GET BCMI_MADURA_DSC_TRNSUM_CTL2r_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSURE_ERR_SELf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_GET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_SET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_EYE_CLOSE_PREV_ENf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_GET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_SET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_PATTERN_MATCH_SELf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_GET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_SET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_DISABLE_SM_CLEARf_SET
#define DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_GET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_GET
#define DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_SET BCMI_MADURA_DSC_TRNSUM_CTL2r_TRNSUM_CLR_SCf_SET
#define READ_DSC_TRNSUM_CTL2r BCMI_MADURA_READ_DSC_TRNSUM_CTL2r
#define WRITE_DSC_TRNSUM_CTL2r BCMI_MADURA_WRITE_DSC_TRNSUM_CTL2r
#define MODIFY_DSC_TRNSUM_CTL2r BCMI_MADURA_MODIFY_DSC_TRNSUM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd055
 * DEVAD:    1
 * DESC:     trnsum control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_GAIN      bit-vector representing the gain to be applied: [0] 1, [1] 2, [2] 4, [3] 8
 *     TRNSUM_SEL_EMUX  0 selects phase slicer and 1 selects lms slicer
 *     TRNSUM_TAP_RANGE_SEL Taps -32 to 4 are broken into groups of 8 and                        this selects the range
 *     TRNSUM_COR_SEL   00: normal; 01: all 1s instead of emux; 10:                        count number of emux!= data; 11: all 1s instead of d[n-delay]
 *     TRNSUM_QPHASE_MULT_EN Enables cdr phase error to weigh the                        correlator output
 *     TRNSUM_RANDOM_TAPSEL_DISABLE Disables randomizing logic for tap                        selection. Enables sequential selection.
 *     TRNSUM_EYE_CLOSURE_EN When enabled this ands another term to the                        condition. d[n] != emux[n]
 *     TRNSUM_EN        Training sum enable
 */
#define BCMI_MADURA_DSC_TRNSUM_CTLr (0x0001d055 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl[1];
	uint32_t _dsc_trnsum_ctl;
} BCMI_MADURA_DSC_TRNSUM_CTLr_t;

#define BCMI_MADURA_DSC_TRNSUM_CTLr_CLR(r) (r).dsc_trnsum_ctl[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_CTLr_SET(r,d) (r).dsc_trnsum_ctl[0] = d
#define BCMI_MADURA_DSC_TRNSUM_CTLr_GET(r) (r).dsc_trnsum_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 13) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 12) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 8) & 0x3)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 4) & 0x7)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET(r) (((r).dsc_trnsum_ctl[0]) & 0x3)
#define BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_CTLr,_r._dsc_trnsum_ctl)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_CTLr,_r._dsc_trnsum_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTLr BCMI_MADURA_DSC_TRNSUM_CTLr
#define DSC_TRNSUM_CTLr_SIZE BCMI_MADURA_DSC_TRNSUM_CTLr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_CTLr_t DSC_TRNSUM_CTLr_t;
#define DSC_TRNSUM_CTLr_CLR BCMI_MADURA_DSC_TRNSUM_CTLr_CLR
#define DSC_TRNSUM_CTLr_SET BCMI_MADURA_DSC_TRNSUM_CTLr_SET
#define DSC_TRNSUM_CTLr_GET BCMI_MADURA_DSC_TRNSUM_CTLr_GET
#define DSC_TRNSUM_CTLr_TRNSUM_ENf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_ENf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET BCMI_MADURA_DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET
#define READ_DSC_TRNSUM_CTLr BCMI_MADURA_READ_DSC_TRNSUM_CTLr
#define WRITE_DSC_TRNSUM_CTLr BCMI_MADURA_WRITE_DSC_TRNSUM_CTLr
#define MODIFY_DSC_TRNSUM_CTLr BCMI_MADURA_MODIFY_DSC_TRNSUM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_PAT_CTL1
 * BLOCKS:   DSC_C
 * REGADDR:  0xd056
 * DEVAD:    1
 * DESC:     trnsum pattern control 1 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN   pattern to be compared
 *     TRNSUM_PATTERN_FULL_CHECK_OFF enables pattern matching
 *     TRNSUM_EDGE_PATTERN_EN enables pattern matching on edges {-6,-5,-4,-3,-2,-1,data,0,1,2} where a number (eg: -4) represents an edge between d[-4] and d[-3]
 *     TRNSUM_INV_PATTERN_EN enables inverted pattern matching
 */
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r (0x0001d056 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL1.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl1[1];
	uint32_t _dsc_trnsum_pat_ctl1;
} BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_t;

#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_CLR(r) (r).dsc_trnsum_pat_ctl1[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_SET(r,d) (r).dsc_trnsum_pat_ctl1[0] = d
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_GET(r) (r).dsc_trnsum_pat_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_pat_ctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_pat_ctl1[0]) >> 14) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET(r) ((((r).dsc_trnsum_pat_ctl1[0]) >> 12) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_GET(r) (((r).dsc_trnsum_pat_ctl1[0]) & 0x3ff)
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL1.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_PAT_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r,_r._dsc_trnsum_pat_ctl1)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_PAT_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r,_r._dsc_trnsum_pat_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL1r BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r
#define DSC_TRNSUM_PAT_CTL1r_SIZE BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_t DSC_TRNSUM_PAT_CTL1r_t;
#define DSC_TRNSUM_PAT_CTL1r_CLR BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_CLR
#define DSC_TRNSUM_PAT_CTL1r_SET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_SET
#define DSC_TRNSUM_PAT_CTL1r_GET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_GET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_SET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_SET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_GET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_SET BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_SET
#define READ_DSC_TRNSUM_PAT_CTL1r BCMI_MADURA_READ_DSC_TRNSUM_PAT_CTL1r
#define WRITE_DSC_TRNSUM_PAT_CTL1r BCMI_MADURA_WRITE_DSC_TRNSUM_PAT_CTL1r
#define MODIFY_DSC_TRNSUM_PAT_CTL1r BCMI_MADURA_MODIFY_DSC_TRNSUM_PAT_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_PAT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_PAT_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd057
 * DEVAD:    1
 * DESC:     trnsum pattern control 2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_BIT_EN pattern mask
 */
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r (0x0001d057 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL2.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl2[1];
	uint32_t _dsc_trnsum_pat_ctl2;
} BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_t;

#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_CLR(r) (r).dsc_trnsum_pat_ctl2[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_SET(r,d) (r).dsc_trnsum_pat_ctl2[0] = d
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_GET(r) (r).dsc_trnsum_pat_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET(r) (((r).dsc_trnsum_pat_ctl2[0]) & 0x3ff)
#define BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl2[0]=(((r).dsc_trnsum_pat_ctl2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL2.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_PAT_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r,_r._dsc_trnsum_pat_ctl2)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_PAT_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r,_r._dsc_trnsum_pat_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL2r BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r
#define DSC_TRNSUM_PAT_CTL2r_SIZE BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_t DSC_TRNSUM_PAT_CTL2r_t;
#define DSC_TRNSUM_PAT_CTL2r_CLR BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_CLR
#define DSC_TRNSUM_PAT_CTL2r_SET BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_SET
#define DSC_TRNSUM_PAT_CTL2r_GET BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_GET
#define DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET
#define DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET
#define READ_DSC_TRNSUM_PAT_CTL2r BCMI_MADURA_READ_DSC_TRNSUM_PAT_CTL2r
#define WRITE_DSC_TRNSUM_PAT_CTL2r BCMI_MADURA_WRITE_DSC_TRNSUM_PAT_CTL2r
#define MODIFY_DSC_TRNSUM_PAT_CTL2r BCMI_MADURA_MODIFY_DSC_TRNSUM_PAT_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_PAT_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_TAP_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd058
 * DEVAD:    1
 * DESC:     trnsum tap control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_TAP_EN    Training taps enabled (either randomize over                        them or not)
 *     TRNSUM_TAP_SIGN  Sign of the 8 taps in the group
 */
#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr (0x0001d058 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_TAP_CTL.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_tap_ctl[1];
	uint32_t _dsc_trnsum_tap_ctl;
} BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_t;

#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_CLR(r) (r).dsc_trnsum_tap_ctl[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_SET(r,d) (r).dsc_trnsum_tap_ctl[0] = d
#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_GET(r) (r).dsc_trnsum_tap_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET(r) ((((r).dsc_trnsum_tap_ctl[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET(r,f) (r).dsc_trnsum_tap_ctl[0]=(((r).dsc_trnsum_tap_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET(r) (((r).dsc_trnsum_tap_ctl[0]) & 0xff)
#define BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET(r,f) (r).dsc_trnsum_tap_ctl[0]=(((r).dsc_trnsum_tap_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_TAP_CTL.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_TAP_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_TAP_CTLr,_r._dsc_trnsum_tap_ctl)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_TAP_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_TAP_CTLr,_r._dsc_trnsum_tap_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_TAP_CTLr BCMI_MADURA_DSC_TRNSUM_TAP_CTLr
#define DSC_TRNSUM_TAP_CTLr_SIZE BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_t DSC_TRNSUM_TAP_CTLr_t;
#define DSC_TRNSUM_TAP_CTLr_CLR BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_CLR
#define DSC_TRNSUM_TAP_CTLr_SET BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_SET
#define DSC_TRNSUM_TAP_CTLr_GET BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET BCMI_MADURA_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET
#define READ_DSC_TRNSUM_TAP_CTLr BCMI_MADURA_READ_DSC_TRNSUM_TAP_CTLr
#define WRITE_DSC_TRNSUM_TAP_CTLr BCMI_MADURA_WRITE_DSC_TRNSUM_TAP_CTLr
#define MODIFY_DSC_TRNSUM_TAP_CTLr BCMI_MADURA_MODIFY_DSC_TRNSUM_TAP_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_TAP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_TDT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd059
 * DEVAD:    1
 * DESC:     trnsum tdt control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TDT_BIT_SEL      tdt bit select: range is 0 to 39
 *     TDT_PRBS_MODE    enables selection of every 511th bit or 255th bitIf tdt_cycle_sel[0] = 0, then it wraps @ 255, else @ 511
 *     TDT_TRNSUM_EN    enables the tdt featureAt no point should this be disabled in the middle of collecting data over multiple locations.The counters which figure out which cycle to select while this bit is 1.
 *     TDT_CYCLE_SEL    the cycle counter wraps at this number
 *     TDT_CYCLE_BIN    valid range: from 0 to tdt_cycle_sel; this cycle the tdt is enabled on bit indicated by tdt_bit_sel
 */
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr (0x0001d059 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_TDT_CTL.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_tdt_ctl[1];
	uint32_t _dsc_trnsum_tdt_ctl;
} BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_t;

#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_CLR(r) (r).dsc_trnsum_tdt_ctl[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_SET(r,d) (r).dsc_trnsum_tdt_ctl[0] = d
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_GET(r) (r).dsc_trnsum_tdt_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_GET(r) (((r).dsc_trnsum_tdt_ctl[0]) & 0x3f)
#define BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_TRNSUM_TDT_CTL.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_TDT_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_TDT_CTLr,_r._dsc_trnsum_tdt_ctl)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_TDT_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_TDT_CTLr,_r._dsc_trnsum_tdt_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_TDT_CTLr BCMI_MADURA_DSC_TRNSUM_TDT_CTLr
#define DSC_TRNSUM_TDT_CTLr_SIZE BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_t DSC_TRNSUM_TDT_CTLr_t;
#define DSC_TRNSUM_TDT_CTLr_CLR BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_CLR
#define DSC_TRNSUM_TDT_CTLr_SET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_SET
#define DSC_TRNSUM_TDT_CTLr_GET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_GET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_SET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_GET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_SET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_GET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_SET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_GET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_SET BCMI_MADURA_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_SET
#define READ_DSC_TRNSUM_TDT_CTLr BCMI_MADURA_READ_DSC_TRNSUM_TDT_CTLr
#define WRITE_DSC_TRNSUM_TDT_CTLr BCMI_MADURA_WRITE_DSC_TRNSUM_TDT_CTLr
#define MODIFY_DSC_TRNSUM_TDT_CTLr BCMI_MADURA_MODIFY_DSC_TRNSUM_TDT_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_TDT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_TRNSUM_MISC
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05a
 * DEVAD:    1
 * DESC:     trnsum misc register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TDT_PRBS_SLIP    tdt bit select: range is 0 to 39self clearing
 *     CDR_1G_TRNSUM_EN Enables accumulation of 1G CDR phase step.This logic is only supported in the repeater application - controlled by a strap bit @ kernel
 */
#define BCMI_MADURA_DSC_TRNSUM_MISCr (0x0001d05a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_TRNSUM_MISCr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_MISC.
 */
typedef union BCMI_MADURA_DSC_TRNSUM_MISCr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_misc[1];
	uint32_t _dsc_trnsum_misc;
} BCMI_MADURA_DSC_TRNSUM_MISCr_t;

#define BCMI_MADURA_DSC_TRNSUM_MISCr_CLR(r) (r).dsc_trnsum_misc[0] = 0
#define BCMI_MADURA_DSC_TRNSUM_MISCr_SET(r,d) (r).dsc_trnsum_misc[0] = d
#define BCMI_MADURA_DSC_TRNSUM_MISCr_GET(r) (r).dsc_trnsum_misc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET(r) (((r).dsc_trnsum_misc[0]) & 0x1)
#define BCMI_MADURA_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_MISC.
 */
#define BCMI_MADURA_READ_DSC_TRNSUM_MISCr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_TRNSUM_MISCr,_r._dsc_trnsum_misc)
#define BCMI_MADURA_WRITE_DSC_TRNSUM_MISCr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_TRNSUM_MISCr,_r._dsc_trnsum_misc)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_MISCr BCMI_MADURA_DSC_TRNSUM_MISCr
#define DSC_TRNSUM_MISCr_SIZE BCMI_MADURA_DSC_TRNSUM_MISCr_SIZE
typedef BCMI_MADURA_DSC_TRNSUM_MISCr_t DSC_TRNSUM_MISCr_t;
#define DSC_TRNSUM_MISCr_CLR BCMI_MADURA_DSC_TRNSUM_MISCr_CLR
#define DSC_TRNSUM_MISCr_SET BCMI_MADURA_DSC_TRNSUM_MISCr_SET
#define DSC_TRNSUM_MISCr_GET BCMI_MADURA_DSC_TRNSUM_MISCr_GET
#define DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_GET BCMI_MADURA_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_GET
#define DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_SET BCMI_MADURA_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_SET
#define DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET BCMI_MADURA_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET
#define DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET BCMI_MADURA_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET
#define READ_DSC_TRNSUM_MISCr BCMI_MADURA_READ_DSC_TRNSUM_MISCr
#define WRITE_DSC_TRNSUM_MISCr BCMI_MADURA_WRITE_DSC_TRNSUM_MISCr
#define MODIFY_DSC_TRNSUM_MISCr BCMI_MADURA_MODIFY_DSC_TRNSUM_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_TRNSUM_MISCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_VGA_CTL1
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05c
 * DEVAD:    1
 * DESC:     vga block control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     VGA_TIMER_T2     VGA timed write. Wait for  (1,2, ...8) cycles
 *     UC_TRNSUM_EN     1'b1 will move the state from UC_TUNE to MEASURE. This is a self-clear register bit.
 *     DC_OFFS_WRITE_EN self clearing dc offset write strobe
 *     VGA_DEC          self clearing vga dec
 *     VGA_INC          self clearing vga inc
 *     RX_VGA_CTRL_VAL  override val of vga
 *     VGA_WRITE        strobe to write VGA values
 */
#define BCMI_MADURA_DSC_VGA_CTL1r (0x0001d05c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_VGA_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_CTL1.
 */
typedef union BCMI_MADURA_DSC_VGA_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_vga_ctl1[1];
	uint32_t _dsc_vga_ctl1;
} BCMI_MADURA_DSC_VGA_CTL1r_t;

#define BCMI_MADURA_DSC_VGA_CTL1r_CLR(r) (r).dsc_vga_ctl1[0] = 0
#define BCMI_MADURA_DSC_VGA_CTL1r_SET(r,d) (r).dsc_vga_ctl1[0] = d
#define BCMI_MADURA_DSC_VGA_CTL1r_GET(r) (r).dsc_vga_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_WRITEf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_WRITEf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 8) & 0x7f)
#define BCMI_MADURA_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_INCf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_INCf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_DECf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 5) & 0x1)
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_DECf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 4) & 0x1)
#define BCMI_MADURA_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DSC_VGA_CTL1r_UC_TRNSUM_ENf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 3) & 0x1)
#define BCMI_MADURA_DSC_VGA_CTL1r_UC_TRNSUM_ENf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_TIMER_T2f_GET(r) (((r).dsc_vga_ctl1[0]) & 0x7)
#define BCMI_MADURA_DSC_VGA_CTL1r_VGA_TIMER_T2f_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DSC_VGA_CTL1.
 */
#define BCMI_MADURA_READ_DSC_VGA_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_VGA_CTL1r,_r._dsc_vga_ctl1)
#define BCMI_MADURA_WRITE_DSC_VGA_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_VGA_CTL1r,_r._dsc_vga_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_CTL1r BCMI_MADURA_DSC_VGA_CTL1r
#define DSC_VGA_CTL1r_SIZE BCMI_MADURA_DSC_VGA_CTL1r_SIZE
typedef BCMI_MADURA_DSC_VGA_CTL1r_t DSC_VGA_CTL1r_t;
#define DSC_VGA_CTL1r_CLR BCMI_MADURA_DSC_VGA_CTL1r_CLR
#define DSC_VGA_CTL1r_SET BCMI_MADURA_DSC_VGA_CTL1r_SET
#define DSC_VGA_CTL1r_GET BCMI_MADURA_DSC_VGA_CTL1r_GET
#define DSC_VGA_CTL1r_VGA_WRITEf_GET BCMI_MADURA_DSC_VGA_CTL1r_VGA_WRITEf_GET
#define DSC_VGA_CTL1r_VGA_WRITEf_SET BCMI_MADURA_DSC_VGA_CTL1r_VGA_WRITEf_SET
#define DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_GET BCMI_MADURA_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_GET
#define DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_SET BCMI_MADURA_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_SET
#define DSC_VGA_CTL1r_VGA_INCf_GET BCMI_MADURA_DSC_VGA_CTL1r_VGA_INCf_GET
#define DSC_VGA_CTL1r_VGA_INCf_SET BCMI_MADURA_DSC_VGA_CTL1r_VGA_INCf_SET
#define DSC_VGA_CTL1r_VGA_DECf_GET BCMI_MADURA_DSC_VGA_CTL1r_VGA_DECf_GET
#define DSC_VGA_CTL1r_VGA_DECf_SET BCMI_MADURA_DSC_VGA_CTL1r_VGA_DECf_SET
#define DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_GET BCMI_MADURA_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_GET
#define DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_SET BCMI_MADURA_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_SET
#define DSC_VGA_CTL1r_UC_TRNSUM_ENf_GET BCMI_MADURA_DSC_VGA_CTL1r_UC_TRNSUM_ENf_GET
#define DSC_VGA_CTL1r_UC_TRNSUM_ENf_SET BCMI_MADURA_DSC_VGA_CTL1r_UC_TRNSUM_ENf_SET
#define DSC_VGA_CTL1r_VGA_TIMER_T2f_GET BCMI_MADURA_DSC_VGA_CTL1r_VGA_TIMER_T2f_GET
#define DSC_VGA_CTL1r_VGA_TIMER_T2f_SET BCMI_MADURA_DSC_VGA_CTL1r_VGA_TIMER_T2f_SET
#define READ_DSC_VGA_CTL1r BCMI_MADURA_READ_DSC_VGA_CTL1r
#define WRITE_DSC_VGA_CTL1r BCMI_MADURA_WRITE_DSC_VGA_CTL1r
#define MODIFY_DSC_VGA_CTL1r BCMI_MADURA_MODIFY_DSC_VGA_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_VGA_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_DATA_SLCR_THR_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05d
 * DEVAD:    1
 * DESC:     data slicer threshold control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     THRESH_TIMER_T1  1,2,3,4 - indicates how many cycles to wait for before applying an inc or dec
 *     THRESH_STEP_SIZE 1,2,3 - auto increment step size for threshold
 *     DATA_THRESH_SEL_VAL Override mode value
 *     DATA_THRESH_WRITE self clearing data thresh write (for override mode)
 */
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr (0x0001d05d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DATA_SLCR_THR_CTL.
 */
typedef union BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_data_slcr_thr_ctl[1];
	uint32_t _dsc_data_slcr_thr_ctl;
} BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_t;

#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_CLR(r) (r).dsc_data_slcr_thr_ctl[0] = 0
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_SET(r,d) (r).dsc_data_slcr_thr_ctl[0] = d
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_GET(r) (r).dsc_data_slcr_thr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_GET(r) ((((r).dsc_data_slcr_thr_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_GET(r) ((((r).dsc_data_slcr_thr_ctl[0]) >> 8) & 0x7f)
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_data_slcr_thr_ctl[0]) >> 4) & 0x3)
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_GET(r) (((r).dsc_data_slcr_thr_ctl[0]) & 0x3)
#define BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_DATA_SLCR_THR_CTL.
 */
#define BCMI_MADURA_READ_DSC_DATA_SLCR_THR_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr,_r._dsc_data_slcr_thr_ctl)
#define BCMI_MADURA_WRITE_DSC_DATA_SLCR_THR_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr,_r._dsc_data_slcr_thr_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DATA_SLCR_THR_CTLr BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr
#define DSC_DATA_SLCR_THR_CTLr_SIZE BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_SIZE
typedef BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_t DSC_DATA_SLCR_THR_CTLr_t;
#define DSC_DATA_SLCR_THR_CTLr_CLR BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_CLR
#define DSC_DATA_SLCR_THR_CTLr_SET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_SET
#define DSC_DATA_SLCR_THR_CTLr_GET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_GET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_GET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_GET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_SET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_SET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_GET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_GET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_SET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_SET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_GET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_GET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_SET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_SET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_GET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_GET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_SET BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_SET
#define READ_DSC_DATA_SLCR_THR_CTLr BCMI_MADURA_READ_DSC_DATA_SLCR_THR_CTLr
#define WRITE_DSC_DATA_SLCR_THR_CTLr BCMI_MADURA_WRITE_DSC_DATA_SLCR_THR_CTLr
#define MODIFY_DSC_DATA_SLCR_THR_CTLr BCMI_MADURA_MODIFY_DSC_DATA_SLCR_THR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_DATA_SLCR_THR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_DC_OFFS_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05e
 * DEVAD:    1
 * DESC:     dc offset control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DC_OFFS_EN       Enables DC Offset tap for adaptation (still needs trnsum to be un-frozen)
 *     DC_OFFS_HYS_EN   Needs to be 1 for hysteresis to be on
 *     DC_OFFS_HYS_MAG  0: 11th bit <<7; 1: 11th bit <<5
 *     DC_OFFS_GRADIENT_INVERT Inverts the sense of the update (inc,dec swap)
 *     DC_OFFS_GAIN     multiplies the +-40 error by 2^{0,1,2,3}
 *     DC_OFFS_ACC_CLR  Clears the internal state except for the final tap
 *     DC_OFFS_WRITE_VAL write value for the dc offset in override modeThe logic walks to this value @ the start of automatic adaptation
 *     DC_OFFS_WRITE_FRC_EN self clearing dc offset force write strobeThis is simply an override to everything. This write gets sign gray converted and written to the dc_offset register
 */
#define BCMI_MADURA_DSC_DC_OFFS_CTLr (0x0001d05e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_DC_OFFS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS_CTL.
 */
typedef union BCMI_MADURA_DSC_DC_OFFS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs_ctl[1];
	uint32_t _dsc_dc_offs_ctl;
} BCMI_MADURA_DSC_DC_OFFS_CTLr_t;

#define BCMI_MADURA_DSC_DC_OFFS_CTLr_CLR(r) (r).dsc_dc_offs_ctl[0] = 0
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_SET(r,d) (r).dsc_dc_offs_ctl[0] = d
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_GET(r) (r).dsc_dc_offs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 8) & 0x7f)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 5) & 0x3)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET(r) (((r).dsc_dc_offs_ctl[0]) & 0x1)
#define BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DC_OFFS_CTL.
 */
#define BCMI_MADURA_READ_DSC_DC_OFFS_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_DC_OFFS_CTLr,_r._dsc_dc_offs_ctl)
#define BCMI_MADURA_WRITE_DSC_DC_OFFS_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_DC_OFFS_CTLr,_r._dsc_dc_offs_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFS_CTLr BCMI_MADURA_DSC_DC_OFFS_CTLr
#define DSC_DC_OFFS_CTLr_SIZE BCMI_MADURA_DSC_DC_OFFS_CTLr_SIZE
typedef BCMI_MADURA_DSC_DC_OFFS_CTLr_t DSC_DC_OFFS_CTLr_t;
#define DSC_DC_OFFS_CTLr_CLR BCMI_MADURA_DSC_DC_OFFS_CTLr_CLR
#define DSC_DC_OFFS_CTLr_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_SET
#define DSC_DC_OFFS_CTLr_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET BCMI_MADURA_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET
#define READ_DSC_DC_OFFS_CTLr BCMI_MADURA_READ_DSC_DC_OFFS_CTLr
#define WRITE_DSC_DC_OFFS_CTLr BCMI_MADURA_WRITE_DSC_DC_OFFS_CTLr
#define MODIFY_DSC_DC_OFFS_CTLr BCMI_MADURA_MODIFY_DSC_DC_OFFS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_DC_OFFS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL0
 * BLOCKS:   DSC_D
 * REGADDR:  0xd060
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 0
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_MODE_EN      1'b1 will enable the EEE mode.
 *     EEE_QUIET_RX_AFE_PWRDWN_VAL 1'b1 will enable the RX AFE powerdown in EEE_QUIET mode.
 *     IGNORE_RX_MODE   If set to 1'b1 then pmd_rx_mode input will be ignored in DSC SM.
 *     CL72_TIMER_EN    If enabled to 1'b1 then LFSR is loaded with 0x01CD else it is loaded with 0x1C1E for all non-EEE and non-MEASURE states.
 *     UC_TUNE_EN       uc_tune_en is used to move in and out of UC_TUNE state. Look for DSC SM state diagram for more details.
 *     HW_TUNE_EN       Should be 1'b1 along with uc_tune_en==1'b1 to move from UC_TUNE to HW_TUNE state.  This is a self-clear register bit.
 *     EEE_MEASURE_EN   1'b1 Enables the measurement during EEE_MEASURE.
 *     UC_ACK_DSC_EEE_DONE 1'b1 will enable the EEE_DONE to DONE transition. This is a self-clear bit.
 *     UC_ACK_DSC_RESTART 1'b1 will enable the RESTART to CONFIG transition. This is a self-clear bit.
 *     UC_ACK_DSC_CONFIG 1'b1 will enable the CONFIG to WAIT_FOR_SIG transition. This is a self-clear bit.
 *     SET_MEAS_INCOMPLETE 1'b1 will force meas_incomplete to be 1'b1 to start a new measurement in EEE mode. This is a self-clear bit.
 */
#define BCMI_MADURA_DSC_SM_CTL0r (0x0001d060 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL0.
 */
typedef union BCMI_MADURA_DSC_SM_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl0[1];
	uint32_t _dsc_sm_ctl0;
} BCMI_MADURA_DSC_SM_CTL0r_t;

#define BCMI_MADURA_DSC_SM_CTL0r_CLR(r) (r).dsc_sm_ctl0[0] = 0
#define BCMI_MADURA_DSC_SM_CTL0r_SET(r,d) (r).dsc_sm_ctl0[0] = d
#define BCMI_MADURA_DSC_SM_CTL0r_GET(r) (r).dsc_sm_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 15) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 14) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 13) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 11) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_DSC_SM_CTL0r_HW_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 6) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_HW_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DSC_SM_CTL0r_UC_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 5) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_UC_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DSC_SM_CTL0r_CL72_TIMER_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 4) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_CL72_TIMER_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 3) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DSC_SM_CTL0r_EEE_MODE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL0r_EEE_MODE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access DSC_SM_CTL0.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL0r,_r._dsc_sm_ctl0)
#define BCMI_MADURA_WRITE_DSC_SM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL0r,_r._dsc_sm_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL0r BCMI_MADURA_DSC_SM_CTL0r
#define DSC_SM_CTL0r_SIZE BCMI_MADURA_DSC_SM_CTL0r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL0r_t DSC_SM_CTL0r_t;
#define DSC_SM_CTL0r_CLR BCMI_MADURA_DSC_SM_CTL0r_CLR
#define DSC_SM_CTL0r_SET BCMI_MADURA_DSC_SM_CTL0r_SET
#define DSC_SM_CTL0r_GET BCMI_MADURA_DSC_SM_CTL0r_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET BCMI_MADURA_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET BCMI_MADURA_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET BCMI_MADURA_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_GET BCMI_MADURA_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_SET BCMI_MADURA_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET
#define DSC_SM_CTL0r_HW_TUNE_ENf_GET BCMI_MADURA_DSC_SM_CTL0r_HW_TUNE_ENf_GET
#define DSC_SM_CTL0r_HW_TUNE_ENf_SET BCMI_MADURA_DSC_SM_CTL0r_HW_TUNE_ENf_SET
#define DSC_SM_CTL0r_UC_TUNE_ENf_GET BCMI_MADURA_DSC_SM_CTL0r_UC_TUNE_ENf_GET
#define DSC_SM_CTL0r_UC_TUNE_ENf_SET BCMI_MADURA_DSC_SM_CTL0r_UC_TUNE_ENf_SET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_GET BCMI_MADURA_DSC_SM_CTL0r_CL72_TIMER_ENf_GET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_SET BCMI_MADURA_DSC_SM_CTL0r_CL72_TIMER_ENf_SET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_GET BCMI_MADURA_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_SET BCMI_MADURA_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET BCMI_MADURA_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET BCMI_MADURA_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET
#define DSC_SM_CTL0r_EEE_MODE_ENf_GET BCMI_MADURA_DSC_SM_CTL0r_EEE_MODE_ENf_GET
#define DSC_SM_CTL0r_EEE_MODE_ENf_SET BCMI_MADURA_DSC_SM_CTL0r_EEE_MODE_ENf_SET
#define READ_DSC_SM_CTL0r BCMI_MADURA_READ_DSC_SM_CTL0r
#define WRITE_DSC_SM_CTL0r BCMI_MADURA_WRITE_DSC_SM_CTL0r
#define MODIFY_DSC_SM_CTL0r BCMI_MADURA_MODIFY_DSC_SM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd061
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 1
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DSC_LOCK_FRC  rx_dsc_lock force.
 *     RX_DSC_LOCK_FRC_VAL rx_dsc_lock force value.
 *     DSC_CLR_FRC      DSC clear force.
 *     DSC_CLR_FRC_VAL  DSC clear force value.
 *     TRNSUM_FRZ_FRC   Training Sum freeze force.
 *     TRNSUM_FRZ_FRC_VAL raining Sum freeze force value.
 *     TIMER_DONE_FRC   Can be forced to 1'b1 which will disable the H/W timer in HW_TUNE and MEASURE states.
 *     TIMER_DONE_FRC_VAL If timer_done_frc is set to 1'b1 and DSC SM is in HW_TUNE or MEASURE states then setting this bit to 1 will move the state to next state.
 *     FREQ_UPD_EN_FRC  Frequency update force.
 *     FREQ_UPD_EN_FRC_VAL Frequency update force value.
 *     CDR_FRZ_FRC      CDR Freeze force.
 *     CDR_FRZ_FRC_VAL  CDR Freeze force value.
 *     TRNSUM_CLR_FRC   Training Sum freeze force.
 *     TRNSUM_CLR_FRC_VAL raining Sum freeze force value.
 */
#define BCMI_MADURA_DSC_SM_CTL1r (0x0001d061 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL1.
 */
typedef union BCMI_MADURA_DSC_SM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl1[1];
	uint32_t _dsc_sm_ctl1;
} BCMI_MADURA_DSC_SM_CTL1r_t;

#define BCMI_MADURA_DSC_SM_CTL1r_CLR(r) (r).dsc_sm_ctl1[0] = 0
#define BCMI_MADURA_DSC_SM_CTL1r_SET(r,d) (r).dsc_sm_ctl1[0] = d
#define BCMI_MADURA_DSC_SM_CTL1r_GET(r) (r).dsc_sm_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 13) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 12) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 11) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 10) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 9) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 8) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 6) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 5) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 4) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 3) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 2) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET(r) (((r).dsc_sm_ctl1[0]) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL1.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL1r,_r._dsc_sm_ctl1)
#define BCMI_MADURA_WRITE_DSC_SM_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL1r,_r._dsc_sm_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL1r BCMI_MADURA_DSC_SM_CTL1r
#define DSC_SM_CTL1r_SIZE BCMI_MADURA_DSC_SM_CTL1r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL1r_t DSC_SM_CTL1r_t;
#define DSC_SM_CTL1r_CLR BCMI_MADURA_DSC_SM_CTL1r_CLR
#define DSC_SM_CTL1r_SET BCMI_MADURA_DSC_SM_CTL1r_SET
#define DSC_SM_CTL1r_GET BCMI_MADURA_DSC_SM_CTL1r_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_GET BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_SET BCMI_MADURA_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET BCMI_MADURA_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_GET BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_SET BCMI_MADURA_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET BCMI_MADURA_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_GET BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRCf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_SET BCMI_MADURA_DSC_SM_CTL1r_DSC_CLR_FRCf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET BCMI_MADURA_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET
#define READ_DSC_SM_CTL1r BCMI_MADURA_READ_DSC_SM_CTL1r
#define WRITE_DSC_SM_CTL1r BCMI_MADURA_WRITE_DSC_SM_CTL1r
#define MODIFY_DSC_SM_CTL1r BCMI_MADURA_MODIFY_DSC_SM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL2
 * BLOCKS:   DSC_D
 * REGADDR:  0xd062
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 2
 * RESETVAL: 0x87 (135)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_LFSR_CNT     LFSR timer start value for all EEE timers except EEE_MEASURE.
 */
#define BCMI_MADURA_DSC_SM_CTL2r (0x0001d062 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL2.
 */
typedef union BCMI_MADURA_DSC_SM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl2[1];
	uint32_t _dsc_sm_ctl2;
} BCMI_MADURA_DSC_SM_CTL2r_t;

#define BCMI_MADURA_DSC_SM_CTL2r_CLR(r) (r).dsc_sm_ctl2[0] = 0
#define BCMI_MADURA_DSC_SM_CTL2r_SET(r,d) (r).dsc_sm_ctl2[0] = d
#define BCMI_MADURA_DSC_SM_CTL2r_GET(r) (r).dsc_sm_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl2[0]) & 0x1fff)
#define BCMI_MADURA_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl2[0]=(((r).dsc_sm_ctl2[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL2.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL2r,_r._dsc_sm_ctl2)
#define BCMI_MADURA_WRITE_DSC_SM_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL2r,_r._dsc_sm_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL2r BCMI_MADURA_DSC_SM_CTL2r
#define DSC_SM_CTL2r_SIZE BCMI_MADURA_DSC_SM_CTL2r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL2r_t DSC_SM_CTL2r_t;
#define DSC_SM_CTL2r_CLR BCMI_MADURA_DSC_SM_CTL2r_CLR
#define DSC_SM_CTL2r_SET BCMI_MADURA_DSC_SM_CTL2r_SET
#define DSC_SM_CTL2r_GET BCMI_MADURA_DSC_SM_CTL2r_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_GET BCMI_MADURA_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_SET BCMI_MADURA_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL2r BCMI_MADURA_READ_DSC_SM_CTL2r
#define WRITE_DSC_SM_CTL2r BCMI_MADURA_WRITE_DSC_SM_CTL2r
#define MODIFY_DSC_SM_CTL2r BCMI_MADURA_MODIFY_DSC_SM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL3
 * BLOCKS:   DSC_D
 * REGADDR:  0xd063
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 3
 * RESETVAL: 0x1c1e (7198)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_LFSR_CNT LFSR timer start value for MEASURE and EEE_MEASURE state timers.
 */
#define BCMI_MADURA_DSC_SM_CTL3r (0x0001d063 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL3.
 */
typedef union BCMI_MADURA_DSC_SM_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl3[1];
	uint32_t _dsc_sm_ctl3;
} BCMI_MADURA_DSC_SM_CTL3r_t;

#define BCMI_MADURA_DSC_SM_CTL3r_CLR(r) (r).dsc_sm_ctl3[0] = 0
#define BCMI_MADURA_DSC_SM_CTL3r_SET(r,d) (r).dsc_sm_ctl3[0] = d
#define BCMI_MADURA_DSC_SM_CTL3r_GET(r) (r).dsc_sm_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl3[0]) & 0x1fff)
#define BCMI_MADURA_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl3[0]=(((r).dsc_sm_ctl3[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL3.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL3r,_r._dsc_sm_ctl3)
#define BCMI_MADURA_WRITE_DSC_SM_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL3r,_r._dsc_sm_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL3r BCMI_MADURA_DSC_SM_CTL3r
#define DSC_SM_CTL3r_SIZE BCMI_MADURA_DSC_SM_CTL3r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL3r_t DSC_SM_CTL3r_t;
#define DSC_SM_CTL3r_CLR BCMI_MADURA_DSC_SM_CTL3r_CLR
#define DSC_SM_CTL3r_SET BCMI_MADURA_DSC_SM_CTL3r_SET
#define DSC_SM_CTL3r_GET BCMI_MADURA_DSC_SM_CTL3r_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET BCMI_MADURA_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET BCMI_MADURA_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL3r BCMI_MADURA_READ_DSC_SM_CTL3r
#define WRITE_DSC_SM_CTL3r BCMI_MADURA_WRITE_DSC_SM_CTL3r
#define MODIFY_DSC_SM_CTL3r BCMI_MADURA_MODIFY_DSC_SM_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL4
 * BLOCKS:   DSC_D
 * REGADDR:  0xd064
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ACQ_CDR_TIMEOUT  Defines timeout value for the ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     CDR_SETTLE_TIMEOUT Defines timeout value for the CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     HW_TUNE_TIMEOUT  Defines timeout value for the HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_MADURA_DSC_SM_CTL4r (0x0001d064 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL4.
 */
typedef union BCMI_MADURA_DSC_SM_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl4[1];
	uint32_t _dsc_sm_ctl4;
} BCMI_MADURA_DSC_SM_CTL4r_t;

#define BCMI_MADURA_DSC_SM_CTL4r_CLR(r) (r).dsc_sm_ctl4[0] = 0
#define BCMI_MADURA_DSC_SM_CTL4r_SET(r,d) (r).dsc_sm_ctl4[0] = d
#define BCMI_MADURA_DSC_SM_CTL4r_GET(r) (r).dsc_sm_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 10) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_MADURA_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 5) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET(r) (((r).dsc_sm_ctl4[0]) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL4.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL4r,_r._dsc_sm_ctl4)
#define BCMI_MADURA_WRITE_DSC_SM_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL4r,_r._dsc_sm_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL4r BCMI_MADURA_DSC_SM_CTL4r
#define DSC_SM_CTL4r_SIZE BCMI_MADURA_DSC_SM_CTL4r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL4r_t DSC_SM_CTL4r_t;
#define DSC_SM_CTL4r_CLR BCMI_MADURA_DSC_SM_CTL4r_CLR
#define DSC_SM_CTL4r_SET BCMI_MADURA_DSC_SM_CTL4r_SET
#define DSC_SM_CTL4r_GET BCMI_MADURA_DSC_SM_CTL4r_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET
#define READ_DSC_SM_CTL4r BCMI_MADURA_READ_DSC_SM_CTL4r
#define WRITE_DSC_SM_CTL4r BCMI_MADURA_WRITE_DSC_SM_CTL4r
#define MODIFY_DSC_SM_CTL4r BCMI_MADURA_MODIFY_DSC_SM_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL5
 * BLOCKS:   DSC_D
 * REGADDR:  0xd065
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 5
 * RESETVAL: 0x35ad (13741)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_TIMEOUT  Defines timeout value for the MEASURE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ACQ_CDR_TIMEOUT Defines timeout value for the EEE_ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_CDR_SETTLE_TIMEOUT Defines timeout value for the EEE_CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_MADURA_DSC_SM_CTL5r (0x0001d065 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL5.
 */
typedef union BCMI_MADURA_DSC_SM_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl5[1];
	uint32_t _dsc_sm_ctl5;
} BCMI_MADURA_DSC_SM_CTL5r_t;

#define BCMI_MADURA_DSC_SM_CTL5r_CLR(r) (r).dsc_sm_ctl5[0] = 0
#define BCMI_MADURA_DSC_SM_CTL5r_SET(r,d) (r).dsc_sm_ctl5[0] = d
#define BCMI_MADURA_DSC_SM_CTL5r_GET(r) (r).dsc_sm_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 10) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_MADURA_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 5) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl5[0]) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL5.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL5r,_r._dsc_sm_ctl5)
#define BCMI_MADURA_WRITE_DSC_SM_CTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL5r,_r._dsc_sm_ctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL5r BCMI_MADURA_DSC_SM_CTL5r
#define DSC_SM_CTL5r_SIZE BCMI_MADURA_DSC_SM_CTL5r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL5r_t DSC_SM_CTL5r_t;
#define DSC_SM_CTL5r_CLR BCMI_MADURA_DSC_SM_CTL5r_CLR
#define DSC_SM_CTL5r_SET BCMI_MADURA_DSC_SM_CTL5r_SET
#define DSC_SM_CTL5r_GET BCMI_MADURA_DSC_SM_CTL5r_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET
#define READ_DSC_SM_CTL5r BCMI_MADURA_READ_DSC_SM_CTL5r
#define WRITE_DSC_SM_CTL5r BCMI_MADURA_WRITE_DSC_SM_CTL5r
#define MODIFY_DSC_SM_CTL5r BCMI_MADURA_MODIFY_DSC_SM_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL6
 * BLOCKS:   DSC_D
 * REGADDR:  0xd066
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 6
 * RESETVAL: 0x340d (13325)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_HW_TUNE_TIMEOUT Defines timeout value for the EEE_HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ANA_PWR_TIMEOUT Defines timeout value for the EEE_ANA_PWR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_MADURA_DSC_SM_CTL6r (0x0001d066 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL6.
 */
typedef union BCMI_MADURA_DSC_SM_CTL6r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl6[1];
	uint32_t _dsc_sm_ctl6;
} BCMI_MADURA_DSC_SM_CTL6r_t;

#define BCMI_MADURA_DSC_SM_CTL6r_CLR(r) (r).dsc_sm_ctl6[0] = 0
#define BCMI_MADURA_DSC_SM_CTL6r_SET(r,d) (r).dsc_sm_ctl6[0] = d
#define BCMI_MADURA_DSC_SM_CTL6r_GET(r) (r).dsc_sm_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl6[0]) >> 10) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_MADURA_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl6[0]) & 0x1f)
#define BCMI_MADURA_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL6.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL6r,_r._dsc_sm_ctl6)
#define BCMI_MADURA_WRITE_DSC_SM_CTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL6r,_r._dsc_sm_ctl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL6r BCMI_MADURA_DSC_SM_CTL6r
#define DSC_SM_CTL6r_SIZE BCMI_MADURA_DSC_SM_CTL6r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL6r_t DSC_SM_CTL6r_t;
#define DSC_SM_CTL6r_CLR BCMI_MADURA_DSC_SM_CTL6r_CLR
#define DSC_SM_CTL6r_SET BCMI_MADURA_DSC_SM_CTL6r_SET
#define DSC_SM_CTL6r_GET BCMI_MADURA_DSC_SM_CTL6r_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET BCMI_MADURA_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET BCMI_MADURA_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET
#define READ_DSC_SM_CTL6r BCMI_MADURA_READ_DSC_SM_CTL6r
#define WRITE_DSC_SM_CTL6r BCMI_MADURA_WRITE_DSC_SM_CTL6r
#define MODIFY_DSC_SM_CTL6r BCMI_MADURA_MODIFY_DSC_SM_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL7
 * BLOCKS:   DSC_D
 * REGADDR:  0xd067
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_BWSEL_INTEG_ACQCDR CDR 2nd Order Loop Bandwidth select for ACQ_CDR state.{0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1}
 *     CDR_BWSEL_INTEG_EEE_ACQCDR CDR 2nd Order Loop Bandwidth select for EEE_ACQ_CDR state.{0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1}
 *     CDR_BWSEL_INTEG_NORM CDR 2nd Order Loop Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1}
 *     CDR_BWSEL_PROP_ACQCDR CDR Proportional Bandwidth select for ACQ_CDR state.{0, 1} map to {2^0, 2^1}
 *     CDR_BWSEL_PROP_NORM CDR Proportional Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.{0, 1} map to {2^0, 2^1}
 */
#define BCMI_MADURA_DSC_SM_CTL7r (0x0001d067 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL7.
 */
typedef union BCMI_MADURA_DSC_SM_CTL7r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl7[1];
	uint32_t _dsc_sm_ctl7;
} BCMI_MADURA_DSC_SM_CTL7r_t;

#define BCMI_MADURA_DSC_SM_CTL7r_CLR(r) (r).dsc_sm_ctl7[0] = 0
#define BCMI_MADURA_DSC_SM_CTL7r_SET(r,d) (r).dsc_sm_ctl7[0] = d
#define BCMI_MADURA_DSC_SM_CTL7r_GET(r) (r).dsc_sm_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 14) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 12) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 8) & 0xf)
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET(r) (((r).dsc_sm_ctl7[0]) & 0xf)
#define BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL7.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL7r,_r._dsc_sm_ctl7)
#define BCMI_MADURA_WRITE_DSC_SM_CTL7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL7r,_r._dsc_sm_ctl7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL7r BCMI_MADURA_DSC_SM_CTL7r
#define DSC_SM_CTL7r_SIZE BCMI_MADURA_DSC_SM_CTL7r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL7r_t DSC_SM_CTL7r_t;
#define DSC_SM_CTL7r_CLR BCMI_MADURA_DSC_SM_CTL7r_CLR
#define DSC_SM_CTL7r_SET BCMI_MADURA_DSC_SM_CTL7r_SET
#define DSC_SM_CTL7r_GET BCMI_MADURA_DSC_SM_CTL7r_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET BCMI_MADURA_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET
#define READ_DSC_SM_CTL7r BCMI_MADURA_READ_DSC_SM_CTL7r
#define WRITE_DSC_SM_CTL7r BCMI_MADURA_WRITE_DSC_SM_CTL7r
#define MODIFY_DSC_SM_CTL7r BCMI_MADURA_MODIFY_DSC_SM_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL8
 * BLOCKS:   DSC_D
 * REGADDR:  0xd068
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 8
 * RESETVAL: 0x11 (17)
 * ACCESS:   R/W
 * FIELDS:
 *     PHASE_ERR_OFFSET Phase Error Offset for non-EEE_ACQ_CDR states. Signed value. Valid range is -8 to 7. This translates to either -8/2 to 7/2 or -8/4 to 7/4, depending on how rg_phase_err_offset_mult_2 is set. By default is is -8/4 to 7/4 adding into VCO reg.
 *     EEE_PHASE_ERR_OFFSET Phase Error Offset for EEE_ACQ_CDR state. Signed value. Valid range is -8 to 7.
 *     PHASE_ERR_OFFSET_EN Phase Error Offset Enable for non-EEE_ACQ_CDR states.
 *     EEE_PHASE_ERR_OFFSET_EN Phase Error Offset Enable for EEE_ACQ_CDR state.
 *     CDR_BWSEL_PROP_EEE_ACQCDR CDR Proportional Bandwidth select for EEE_ACQ_CDR state.{0, 1} map to {2^0, 2^1}
 */
#define BCMI_MADURA_DSC_SM_CTL8r (0x0001d068 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL8.
 */
typedef union BCMI_MADURA_DSC_SM_CTL8r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl8[1];
	uint32_t _dsc_sm_ctl8;
} BCMI_MADURA_DSC_SM_CTL8r_t;

#define BCMI_MADURA_DSC_SM_CTL8r_CLR(r) (r).dsc_sm_ctl8[0] = 0
#define BCMI_MADURA_DSC_SM_CTL8r_SET(r,d) (r).dsc_sm_ctl8[0] = d
#define BCMI_MADURA_DSC_SM_CTL8r_GET(r) (r).dsc_sm_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 14) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 10) & 0x3)
#define BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 8) & 0x3)
#define BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 4) & 0xf)
#define BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET(r) (((r).dsc_sm_ctl8[0]) & 0xf)
#define BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL8.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL8r,_r._dsc_sm_ctl8)
#define BCMI_MADURA_WRITE_DSC_SM_CTL8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL8r,_r._dsc_sm_ctl8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL8r BCMI_MADURA_DSC_SM_CTL8r
#define DSC_SM_CTL8r_SIZE BCMI_MADURA_DSC_SM_CTL8r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL8r_t DSC_SM_CTL8r_t;
#define DSC_SM_CTL8r_CLR BCMI_MADURA_DSC_SM_CTL8r_CLR
#define DSC_SM_CTL8r_SET BCMI_MADURA_DSC_SM_CTL8r_SET
#define DSC_SM_CTL8r_GET BCMI_MADURA_DSC_SM_CTL8r_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET BCMI_MADURA_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET BCMI_MADURA_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET BCMI_MADURA_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET BCMI_MADURA_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET
#define READ_DSC_SM_CTL8r BCMI_MADURA_READ_DSC_SM_CTL8r
#define WRITE_DSC_SM_CTL8r BCMI_MADURA_WRITE_DSC_SM_CTL8r
#define MODIFY_DSC_SM_CTL8r BCMI_MADURA_MODIFY_DSC_SM_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_CTL9
 * BLOCKS:   DSC_D
 * REGADDR:  0xd069
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_RESTART_PMD   1: restarts the RX PMD. This is a self-clear register bit.
 *     RX_RESTART_PMD_HOLD 1: restarts the RX PMD and holds it in RESTART state until this bit is cleared.
 */
#define BCMI_MADURA_DSC_SM_CTL9r (0x0001d069 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL9.
 */
typedef union BCMI_MADURA_DSC_SM_CTL9r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl9[1];
	uint32_t _dsc_sm_ctl9;
} BCMI_MADURA_DSC_SM_CTL9r_t;

#define BCMI_MADURA_DSC_SM_CTL9r_CLR(r) (r).dsc_sm_ctl9[0] = 0
#define BCMI_MADURA_DSC_SM_CTL9r_SET(r,d) (r).dsc_sm_ctl9[0] = d
#define BCMI_MADURA_DSC_SM_CTL9r_GET(r) (r).dsc_sm_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET(r) ((((r).dsc_sm_ctl9[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMDf_GET(r) (((r).dsc_sm_ctl9[0]) & 0x1)
#define BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL9.
 */
#define BCMI_MADURA_READ_DSC_SM_CTL9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_CTL9r,_r._dsc_sm_ctl9)
#define BCMI_MADURA_WRITE_DSC_SM_CTL9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_CTL9r,_r._dsc_sm_ctl9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL9r BCMI_MADURA_DSC_SM_CTL9r
#define DSC_SM_CTL9r_SIZE BCMI_MADURA_DSC_SM_CTL9r_SIZE
typedef BCMI_MADURA_DSC_SM_CTL9r_t DSC_SM_CTL9r_t;
#define DSC_SM_CTL9r_CLR BCMI_MADURA_DSC_SM_CTL9r_CLR
#define DSC_SM_CTL9r_SET BCMI_MADURA_DSC_SM_CTL9r_SET
#define DSC_SM_CTL9r_GET BCMI_MADURA_DSC_SM_CTL9r_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_GET BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_SET BCMI_MADURA_DSC_SM_CTL9r_RX_RESTART_PMDf_SET
#define READ_DSC_SM_CTL9r BCMI_MADURA_READ_DSC_SM_CTL9r
#define WRITE_DSC_SM_CTL9r BCMI_MADURA_WRITE_DSC_SM_CTL9r
#define MODIFY_DSC_SM_CTL9r BCMI_MADURA_MODIFY_DSC_SM_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_STS_DSC_LOCK
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06a
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE DSC_LOCK STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DSC_LOCK      1 indicates that DSC is locked.
 *     MEAS_INCOMPLETE  1 indicates that measurement is incomplete. 0 indicates that measurement is complete.
 *     EEE_MEASURE_CNT  Indicates the eee_measure_cnt status. This is a debug register.
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr (0x0001d06a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_LOCK.
 */
typedef union BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_lock[1];
	uint32_t _dsc_sm_sts_dsc_lock;
} BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_t;

#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_CLR(r) (r).dsc_sm_sts_dsc_lock[0] = 0
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_SET(r,d) (r).dsc_sm_sts_dsc_lock[0] = d
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_GET(r) (r).dsc_sm_sts_dsc_lock[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 7) & 0x1ff)
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET(r) (((r).dsc_sm_sts_dsc_lock[0]) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_LOCK.
 */
#define BCMI_MADURA_READ_DSC_SM_STS_DSC_LOCKr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_STS_DSC_LOCKr,_r._dsc_sm_sts_dsc_lock)
#define BCMI_MADURA_WRITE_DSC_SM_STS_DSC_LOCKr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_STS_DSC_LOCKr,_r._dsc_sm_sts_dsc_lock)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_LOCKr BCMI_MADURA_DSC_SM_STS_DSC_LOCKr
#define DSC_SM_STS_DSC_LOCKr_SIZE BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_SIZE
typedef BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_t DSC_SM_STS_DSC_LOCKr_t;
#define DSC_SM_STS_DSC_LOCKr_CLR BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_CLR
#define DSC_SM_STS_DSC_LOCKr_SET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_SET
#define DSC_SM_STS_DSC_LOCKr_GET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET BCMI_MADURA_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET
#define READ_DSC_SM_STS_DSC_LOCKr BCMI_MADURA_READ_DSC_SM_STS_DSC_LOCKr
#define WRITE_DSC_SM_STS_DSC_LOCKr BCMI_MADURA_WRITE_DSC_SM_STS_DSC_LOCKr
#define MODIFY_DSC_SM_STS_DSC_LOCKr BCMI_MADURA_MODIFY_DSC_SM_STS_DSC_LOCKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_STS_DSC_LOCKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_STS_DSC_ST_ONE_HOT
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06b
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_ONE_HOT Sticky one-hot coded states. These registers are cleared on read.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr (0x0001d06b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_ONE_HOT.
 */
typedef union BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_one_hot;
} BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_t;

#define BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_one_hot[0] = 0
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_one_hot[0] = d
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_one_hot[0]) & 0x3ff)
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_one_hot[0]=(((r).dsc_sm_sts_dsc_st_one_hot[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_ONE_HOT.
 */
#define BCMI_MADURA_READ_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr,_r._dsc_sm_sts_dsc_st_one_hot)
#define BCMI_MADURA_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr,_r._dsc_sm_sts_dsc_st_one_hot)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE
typedef BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_t DSC_SM_STS_DSC_ST_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_ONE_HOTr_CLR BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SET BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_GET BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_MADURA_READ_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_MADURA_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_MADURA_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_STS_DSC_ST_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_STS_DSC_ST_EEE_ONE_HOT
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06c
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS EEE ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_EEE_ONE_HOT Sticky one-hot coded EEE state . These registers are cleared on read.EEE_QUIET       =  0EEE_ANA_PWR     =  1EEE_ACQ_CDR     =  2EEE_CDR_SETTLE  =  3EEE_HW_TUNE     =  4EEE_MEASURE     =  5EEE_DONE        =  6
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr (0x0001d06c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
typedef union BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_eee_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_eee_one_hot;
} BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;

#define BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = 0
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = d
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_eee_one_hot[0]) & 0x7f)
#define BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]=(((r).dsc_sm_sts_dsc_st_eee_one_hot[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
#define BCMI_MADURA_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,_r._dsc_sm_sts_dsc_st_eee_one_hot)
#define BCMI_MADURA_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,_r._dsc_sm_sts_dsc_st_eee_one_hot)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE
typedef BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_MADURA_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_MADURA_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_MADURA_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_STS_RESTART
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06d
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS RESTART
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESTART_PI_EXT_MODE Indicates when SM moves to RESTART state due to enabling of RX_PI external control (i.e. digital loopback enable). This is clear on read.
 *     RESTART_SIGDET   Indicates when SM moves to RESTART state due to sigdet==0 and eee_mode_en register is 1'b0. This is clear on read.
 *     RESTART_PMD_RESTART Indicates when SM moves to RESTART state due to assertion of pmd_restart to 1'b1. This is clear on read.
 *     EEE_QUIET_FROM_EEE_STATES Indicates when SM moves from any EEE states to EEE_QUIET state. This is clear on read.
 */
#define BCMI_MADURA_DSC_SM_STS_RESTARTr (0x0001d06d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_STS_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_RESTART.
 */
typedef union BCMI_MADURA_DSC_SM_STS_RESTARTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_restart[1];
	uint32_t _dsc_sm_sts_restart;
} BCMI_MADURA_DSC_SM_STS_RESTARTr_t;

#define BCMI_MADURA_DSC_SM_STS_RESTARTr_CLR(r) (r).dsc_sm_sts_restart[0] = 0
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_SET(r,d) (r).dsc_sm_sts_restart[0] = d
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_GET(r) (r).dsc_sm_sts_restart[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 3) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 2) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET(r) (((r).dsc_sm_sts_restart[0]) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_RESTART.
 */
#define BCMI_MADURA_READ_DSC_SM_STS_RESTARTr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_STS_RESTARTr,_r._dsc_sm_sts_restart)
#define BCMI_MADURA_WRITE_DSC_SM_STS_RESTARTr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_STS_RESTARTr,_r._dsc_sm_sts_restart)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_RESTARTr BCMI_MADURA_DSC_SM_STS_RESTARTr
#define DSC_SM_STS_RESTARTr_SIZE BCMI_MADURA_DSC_SM_STS_RESTARTr_SIZE
typedef BCMI_MADURA_DSC_SM_STS_RESTARTr_t DSC_SM_STS_RESTARTr_t;
#define DSC_SM_STS_RESTARTr_CLR BCMI_MADURA_DSC_SM_STS_RESTARTr_CLR
#define DSC_SM_STS_RESTARTr_SET BCMI_MADURA_DSC_SM_STS_RESTARTr_SET
#define DSC_SM_STS_RESTARTr_GET BCMI_MADURA_DSC_SM_STS_RESTARTr_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET BCMI_MADURA_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET BCMI_MADURA_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET BCMI_MADURA_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET
#define READ_DSC_SM_STS_RESTARTr BCMI_MADURA_READ_DSC_SM_STS_RESTARTr
#define WRITE_DSC_SM_STS_RESTARTr BCMI_MADURA_WRITE_DSC_SM_STS_RESTARTr
#define MODIFY_DSC_SM_STS_RESTARTr BCMI_MADURA_MODIFY_DSC_SM_STS_RESTARTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_STS_RESTARTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_SM_STS_DSC_ST
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06e
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS
 * RESETVAL: 0x80 (128)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_SM_READY_FOR_CMD Ready for Command.
 *     DSC_SM_GP_UC_REQ gp_uc_req.
 *     CDR_LM_OUTOFLOCK CDR Lock Monitor loss of lock (1 implies a potential loss of lock). This bit sets itself on register read.And if the cdr_integ_reg is within bounds it clears itself in the next cycle from which it detects within bounds. Note: Set on readThe valid bounds on the cdr_integ_reg are programmed using cdr_lm_thr_selHas more meaning after rx_dsc_lock is asserted.
 *     DSC_SM_SCRATCH   3 bits of dsc_scratch
 *     DSC_STATE        Live DSC SM state. Following are the state encodings.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9EEE_QUIET       =  10EEE_ANA_PWR     =  11EEE_ACQ_CDR     =  12EEE_CDR_SETTLE  =  13EEE_HW_TUNE     =  14EEE_MEASURE     =  15EEE_DONE        =  16
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_STr (0x0001d06e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_SM_STS_DSC_STr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST.
 */
typedef union BCMI_MADURA_DSC_SM_STS_DSC_STr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st[1];
	uint32_t _dsc_sm_sts_dsc_st;
} BCMI_MADURA_DSC_SM_STS_DSC_STr_t;

#define BCMI_MADURA_DSC_SM_STS_DSC_STr_CLR(r) (r).dsc_sm_sts_dsc_st[0] = 0
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_SET(r,d) (r).dsc_sm_sts_dsc_st[0] = d
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_GET(r) (r).dsc_sm_sts_dsc_st[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_STATEf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 11) & 0x1f)
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_STATEf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 8) & 0x7)
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 7) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 1) & 0x3f)
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1)) | (63 << (16 + 1))
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET(r) (((r).dsc_sm_sts_dsc_st[0]) & 0x1)
#define BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST.
 */
#define BCMI_MADURA_READ_DSC_SM_STS_DSC_STr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_SM_STS_DSC_STr,_r._dsc_sm_sts_dsc_st)
#define BCMI_MADURA_WRITE_DSC_SM_STS_DSC_STr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_SM_STS_DSC_STr,_r._dsc_sm_sts_dsc_st)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_STr BCMI_MADURA_DSC_SM_STS_DSC_STr
#define DSC_SM_STS_DSC_STr_SIZE BCMI_MADURA_DSC_SM_STS_DSC_STr_SIZE
typedef BCMI_MADURA_DSC_SM_STS_DSC_STr_t DSC_SM_STS_DSC_STr_t;
#define DSC_SM_STS_DSC_STr_CLR BCMI_MADURA_DSC_SM_STS_DSC_STr_CLR
#define DSC_SM_STS_DSC_STr_SET BCMI_MADURA_DSC_SM_STS_DSC_STr_SET
#define DSC_SM_STS_DSC_STr_GET BCMI_MADURA_DSC_SM_STS_DSC_STr_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_GET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_STATEf_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_SET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_STATEf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET
#define DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_GET BCMI_MADURA_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_GET
#define DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_SET BCMI_MADURA_DSC_SM_STS_DSC_STr_CDR_LM_OUTOFLOCKf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET BCMI_MADURA_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET
#define READ_DSC_SM_STS_DSC_STr BCMI_MADURA_READ_DSC_SM_STS_DSC_STr
#define WRITE_DSC_SM_STS_DSC_STr BCMI_MADURA_WRITE_DSC_SM_STS_DSC_STr
#define MODIFY_DSC_SM_STS_DSC_STr BCMI_MADURA_MODIFY_DSC_SM_STS_DSC_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_SM_STS_DSC_STr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PI_CNT_BIN_PD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd070
 * DEVAD:    1
 * DESC:     rx_pi status register, both p and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_P_PD     PI counter value for phase slicer
 *     CNT_BIN_D_PD     PI counter value for phase quadrature slicer
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr (0x0001d070 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_PD.
 */
typedef union BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_pd[1];
	uint32_t _dsc_rx_pi_cnt_bin_pd;
} BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_t;

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CLR(r) (r).dsc_rx_pi_cnt_bin_pd[0] = 0
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_pd[0] = d
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_GET(r) (r).dsc_rx_pi_cnt_bin_pd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_pd[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET(r) (((r).dsc_rx_pi_cnt_bin_pd[0]) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_PD.
 */
#define BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr,_r._dsc_rx_pi_cnt_bin_pd)
#define BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr,_r._dsc_rx_pi_cnt_bin_pd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_PDr BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr
#define DSC_RX_PI_CNT_BIN_PDr_SIZE BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_SIZE
typedef BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_t DSC_RX_PI_CNT_BIN_PDr_t;
#define DSC_RX_PI_CNT_BIN_PDr_CLR BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CLR
#define DSC_RX_PI_CNT_BIN_PDr_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_SET
#define DSC_RX_PI_CNT_BIN_PDr_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET
#define READ_DSC_RX_PI_CNT_BIN_PDr BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_PDr
#define WRITE_DSC_RX_PI_CNT_BIN_PDr BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_PDr
#define MODIFY_DSC_RX_PI_CNT_BIN_PDr BCMI_MADURA_MODIFY_DSC_RX_PI_CNT_BIN_PDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PI_CNT_BIN_PDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PI_CNT_BIN_LD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd071
 * DEVAD:    1
 * DESC:     rx_pi status register, both l and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_L_LD     PI counter value for LMS slicer
 *     CNT_BIN_D_LD     PI counter value for LMS quadrature slicer
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr (0x0001d071 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_LD.
 */
typedef union BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_ld[1];
	uint32_t _dsc_rx_pi_cnt_bin_ld;
} BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_t;

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CLR(r) (r).dsc_rx_pi_cnt_bin_ld[0] = 0
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_ld[0] = d
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_GET(r) (r).dsc_rx_pi_cnt_bin_ld[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_ld[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET(r) (((r).dsc_rx_pi_cnt_bin_ld[0]) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_LD.
 */
#define BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr,_r._dsc_rx_pi_cnt_bin_ld)
#define BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr,_r._dsc_rx_pi_cnt_bin_ld)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_LDr BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr
#define DSC_RX_PI_CNT_BIN_LDr_SIZE BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_SIZE
typedef BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_t DSC_RX_PI_CNT_BIN_LDr_t;
#define DSC_RX_PI_CNT_BIN_LDr_CLR BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CLR
#define DSC_RX_PI_CNT_BIN_LDr_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_SET
#define DSC_RX_PI_CNT_BIN_LDr_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET
#define READ_DSC_RX_PI_CNT_BIN_LDr BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_LDr
#define WRITE_DSC_RX_PI_CNT_BIN_LDr BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_LDr
#define MODIFY_DSC_RX_PI_CNT_BIN_LDr BCMI_MADURA_MODIFY_DSC_RX_PI_CNT_BIN_LDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PI_CNT_BIN_LDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DATA_15_TO0
 * BLOCKS:   DSC_E
 * REGADDR:  0xd072
 * DEVAD:    1
 * DESC:     rx data bits 15 to 0.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_15_TO_0  Rx data is 40 bit wide in rclk40 domain. These are bits 15 to 0.
 */
#define BCMI_MADURA_DSC_RX_DATA_15_TO0r (0x0001d072 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DATA_15_TO0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DATA_15_TO0.
 */
typedef union BCMI_MADURA_DSC_RX_DATA_15_TO0r_s {
	uint32_t v[1];
	uint32_t dsc_rx_data_15_to0[1];
	uint32_t _dsc_rx_data_15_to0;
} BCMI_MADURA_DSC_RX_DATA_15_TO0r_t;

#define BCMI_MADURA_DSC_RX_DATA_15_TO0r_CLR(r) (r).dsc_rx_data_15_to0[0] = 0
#define BCMI_MADURA_DSC_RX_DATA_15_TO0r_SET(r,d) (r).dsc_rx_data_15_to0[0] = d
#define BCMI_MADURA_DSC_RX_DATA_15_TO0r_GET(r) (r).dsc_rx_data_15_to0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET(r) (((r).dsc_rx_data_15_to0[0]) & 0xffff)
#define BCMI_MADURA_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET(r,f) (r).dsc_rx_data_15_to0[0]=(((r).dsc_rx_data_15_to0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_RX_DATA_15_TO0.
 */
#define BCMI_MADURA_READ_DSC_RX_DATA_15_TO0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DATA_15_TO0r,_r._dsc_rx_data_15_to0)
#define BCMI_MADURA_WRITE_DSC_RX_DATA_15_TO0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DATA_15_TO0r,_r._dsc_rx_data_15_to0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DATA_15_TO0r BCMI_MADURA_DSC_RX_DATA_15_TO0r
#define DSC_RX_DATA_15_TO0r_SIZE BCMI_MADURA_DSC_RX_DATA_15_TO0r_SIZE
typedef BCMI_MADURA_DSC_RX_DATA_15_TO0r_t DSC_RX_DATA_15_TO0r_t;
#define DSC_RX_DATA_15_TO0r_CLR BCMI_MADURA_DSC_RX_DATA_15_TO0r_CLR
#define DSC_RX_DATA_15_TO0r_SET BCMI_MADURA_DSC_RX_DATA_15_TO0r_SET
#define DSC_RX_DATA_15_TO0r_GET BCMI_MADURA_DSC_RX_DATA_15_TO0r_GET
#define DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET BCMI_MADURA_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET
#define DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET BCMI_MADURA_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET
#define READ_DSC_RX_DATA_15_TO0r BCMI_MADURA_READ_DSC_RX_DATA_15_TO0r
#define WRITE_DSC_RX_DATA_15_TO0r BCMI_MADURA_WRITE_DSC_RX_DATA_15_TO0r
#define MODIFY_DSC_RX_DATA_15_TO0r BCMI_MADURA_MODIFY_DSC_RX_DATA_15_TO0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DATA_15_TO0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_DATA_35_TO_20
 * BLOCKS:   DSC_E
 * REGADDR:  0xd073
 * DEVAD:    1
 * DESC:     rx data bits 35 to 20.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_35_TO_20 Rx data is 40 bit wide in rclk40 domain. These are bits 35 to 20.
 */
#define BCMI_MADURA_DSC_RX_DATA_35_TO_20r (0x0001d073 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_DATA_35_TO_20r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DATA_35_TO_20.
 */
typedef union BCMI_MADURA_DSC_RX_DATA_35_TO_20r_s {
	uint32_t v[1];
	uint32_t dsc_rx_data_35_to_20[1];
	uint32_t _dsc_rx_data_35_to_20;
} BCMI_MADURA_DSC_RX_DATA_35_TO_20r_t;

#define BCMI_MADURA_DSC_RX_DATA_35_TO_20r_CLR(r) (r).dsc_rx_data_35_to_20[0] = 0
#define BCMI_MADURA_DSC_RX_DATA_35_TO_20r_SET(r,d) (r).dsc_rx_data_35_to_20[0] = d
#define BCMI_MADURA_DSC_RX_DATA_35_TO_20r_GET(r) (r).dsc_rx_data_35_to_20[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET(r) (((r).dsc_rx_data_35_to_20[0]) & 0xffff)
#define BCMI_MADURA_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET(r,f) (r).dsc_rx_data_35_to_20[0]=(((r).dsc_rx_data_35_to_20[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_RX_DATA_35_TO_20.
 */
#define BCMI_MADURA_READ_DSC_RX_DATA_35_TO_20r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_DATA_35_TO_20r,_r._dsc_rx_data_35_to_20)
#define BCMI_MADURA_WRITE_DSC_RX_DATA_35_TO_20r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_DATA_35_TO_20r,_r._dsc_rx_data_35_to_20)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DATA_35_TO_20r BCMI_MADURA_DSC_RX_DATA_35_TO_20r
#define DSC_RX_DATA_35_TO_20r_SIZE BCMI_MADURA_DSC_RX_DATA_35_TO_20r_SIZE
typedef BCMI_MADURA_DSC_RX_DATA_35_TO_20r_t DSC_RX_DATA_35_TO_20r_t;
#define DSC_RX_DATA_35_TO_20r_CLR BCMI_MADURA_DSC_RX_DATA_35_TO_20r_CLR
#define DSC_RX_DATA_35_TO_20r_SET BCMI_MADURA_DSC_RX_DATA_35_TO_20r_SET
#define DSC_RX_DATA_35_TO_20r_GET BCMI_MADURA_DSC_RX_DATA_35_TO_20r_GET
#define DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET BCMI_MADURA_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET
#define DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET BCMI_MADURA_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET
#define READ_DSC_RX_DATA_35_TO_20r BCMI_MADURA_READ_DSC_RX_DATA_35_TO_20r
#define WRITE_DSC_RX_DATA_35_TO_20r BCMI_MADURA_WRITE_DSC_RX_DATA_35_TO_20r
#define MODIFY_DSC_RX_DATA_35_TO_20r BCMI_MADURA_MODIFY_DSC_RX_DATA_35_TO_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_DATA_35_TO_20r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_CDR_STS_PHASE_ERR
 * BLOCKS:   DSC_E
 * REGADDR:  0xd074
 * DEVAD:    1
 * DESC:     cdr status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_PHASE_ERROR  shadowed version of phase error value
 *     CDR_VCO_REG      shadowed version of cdr_vco_reg[3:0]
 */
#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr (0x0001d074 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_PHASE_ERR.
 */
typedef union BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_phase_err[1];
	uint32_t _dsc_cdr_sts_phase_err;
} BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_t;

#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CLR(r) (r).dsc_cdr_sts_phase_err[0] = 0
#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_SET(r,d) (r).dsc_cdr_sts_phase_err[0] = d
#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_GET(r) (r).dsc_cdr_sts_phase_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET(r) ((((r).dsc_cdr_sts_phase_err[0]) >> 12) & 0xf)
#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET(r) (((r).dsc_cdr_sts_phase_err[0]) & 0x3f)
#define BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_CDR_STS_PHASE_ERR.
 */
#define BCMI_MADURA_READ_DSC_CDR_STS_PHASE_ERRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr,_r._dsc_cdr_sts_phase_err)
#define BCMI_MADURA_WRITE_DSC_CDR_STS_PHASE_ERRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr,_r._dsc_cdr_sts_phase_err)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_PHASE_ERRr BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr
#define DSC_CDR_STS_PHASE_ERRr_SIZE BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_SIZE
typedef BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_t DSC_CDR_STS_PHASE_ERRr_t;
#define DSC_CDR_STS_PHASE_ERRr_CLR BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CLR
#define DSC_CDR_STS_PHASE_ERRr_SET BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_SET
#define DSC_CDR_STS_PHASE_ERRr_GET BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET
#define READ_DSC_CDR_STS_PHASE_ERRr BCMI_MADURA_READ_DSC_CDR_STS_PHASE_ERRr
#define WRITE_DSC_CDR_STS_PHASE_ERRr BCMI_MADURA_WRITE_DSC_CDR_STS_PHASE_ERRr
#define MODIFY_DSC_CDR_STS_PHASE_ERRr BCMI_MADURA_MODIFY_DSC_CDR_STS_PHASE_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_CDR_STS_PHASE_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PI_CNT_BIN_D
 * BLOCKS:   DSC_E
 * REGADDR:  0xd075
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_D        PI counter value for data slicer
 *     CNT_BIN_DQ       PI counter value for data quadrature slicer
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr (0x0001d075 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_D.
 */
typedef union BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_d[1];
	uint32_t _dsc_rx_pi_cnt_bin_d;
} BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_t;

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CLR(r) (r).dsc_rx_pi_cnt_bin_d[0] = 0
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_SET(r,d) (r).dsc_rx_pi_cnt_bin_d[0] = d
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_GET(r) (r).dsc_rx_pi_cnt_bin_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_d[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET(r) (((r).dsc_rx_pi_cnt_bin_d[0]) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_D.
 */
#define BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr,_r._dsc_rx_pi_cnt_bin_d)
#define BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr,_r._dsc_rx_pi_cnt_bin_d)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Dr BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr
#define DSC_RX_PI_CNT_BIN_Dr_SIZE BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_SIZE
typedef BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_t DSC_RX_PI_CNT_BIN_Dr_t;
#define DSC_RX_PI_CNT_BIN_Dr_CLR BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CLR
#define DSC_RX_PI_CNT_BIN_Dr_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_SET
#define DSC_RX_PI_CNT_BIN_Dr_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET
#define READ_DSC_RX_PI_CNT_BIN_Dr BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_Dr
#define WRITE_DSC_RX_PI_CNT_BIN_Dr BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_Dr
#define MODIFY_DSC_RX_PI_CNT_BIN_Dr BCMI_MADURA_MODIFY_DSC_RX_PI_CNT_BIN_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PI_CNT_BIN_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PI_CNT_BIN_P
 * BLOCKS:   DSC_E
 * REGADDR:  0xd076
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_P        PI counter value for phase slicer
 *     CNT_BIN_PQ       PI counter value for phase quadrature slicer
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr (0x0001d076 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_P.
 */
typedef union BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_p[1];
	uint32_t _dsc_rx_pi_cnt_bin_p;
} BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_t;

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CLR(r) (r).dsc_rx_pi_cnt_bin_p[0] = 0
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_SET(r,d) (r).dsc_rx_pi_cnt_bin_p[0] = d
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_GET(r) (r).dsc_rx_pi_cnt_bin_p[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_p[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET(r) (((r).dsc_rx_pi_cnt_bin_p[0]) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_P.
 */
#define BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr,_r._dsc_rx_pi_cnt_bin_p)
#define BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr,_r._dsc_rx_pi_cnt_bin_p)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Pr BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr
#define DSC_RX_PI_CNT_BIN_Pr_SIZE BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_SIZE
typedef BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_t DSC_RX_PI_CNT_BIN_Pr_t;
#define DSC_RX_PI_CNT_BIN_Pr_CLR BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CLR
#define DSC_RX_PI_CNT_BIN_Pr_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_SET
#define DSC_RX_PI_CNT_BIN_Pr_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET
#define READ_DSC_RX_PI_CNT_BIN_Pr BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_Pr
#define WRITE_DSC_RX_PI_CNT_BIN_Pr BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_Pr
#define MODIFY_DSC_RX_PI_CNT_BIN_Pr BCMI_MADURA_MODIFY_DSC_RX_PI_CNT_BIN_Pr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PI_CNT_BIN_Pr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_RX_PI_CNT_BIN_L
 * BLOCKS:   DSC_E
 * REGADDR:  0xd077
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_L        PI counter value for LMS slicer
 *     CNT_BIN_LQ       PI counter value for LMS quadrature slicer
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr (0x0001d077 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_L.
 */
typedef union BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_l[1];
	uint32_t _dsc_rx_pi_cnt_bin_l;
} BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_t;

#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CLR(r) (r).dsc_rx_pi_cnt_bin_l[0] = 0
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_SET(r,d) (r).dsc_rx_pi_cnt_bin_l[0] = d
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_GET(r) (r).dsc_rx_pi_cnt_bin_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_l[0]) >> 8) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET(r) (((r).dsc_rx_pi_cnt_bin_l[0]) & 0xff)
#define BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_L.
 */
#define BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr,_r._dsc_rx_pi_cnt_bin_l)
#define BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr,_r._dsc_rx_pi_cnt_bin_l)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Lr BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr
#define DSC_RX_PI_CNT_BIN_Lr_SIZE BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_SIZE
typedef BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_t DSC_RX_PI_CNT_BIN_Lr_t;
#define DSC_RX_PI_CNT_BIN_Lr_CLR BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CLR
#define DSC_RX_PI_CNT_BIN_Lr_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_SET
#define DSC_RX_PI_CNT_BIN_Lr_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET
#define READ_DSC_RX_PI_CNT_BIN_Lr BCMI_MADURA_READ_DSC_RX_PI_CNT_BIN_Lr
#define WRITE_DSC_RX_PI_CNT_BIN_Lr BCMI_MADURA_WRITE_DSC_RX_PI_CNT_BIN_Lr
#define MODIFY_DSC_RX_PI_CNT_BIN_Lr BCMI_MADURA_MODIFY_DSC_RX_PI_CNT_BIN_Lr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_RX_PI_CNT_BIN_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_CDR_STS_INTEG
 * BLOCKS:   DSC_E
 * REGADDR:  0xd078
 * DEVAD:    1
 * DESC:     cdr status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_INTEG_REG    Divide this by 83.886 to get the approximate ppm frequency offset the CDR is tracking. (The CDR must settle first - rx_dsc_lock asserted high).
 */
#define BCMI_MADURA_DSC_CDR_STS_INTEGr (0x0001d078 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_CDR_STS_INTEGr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_INTEG.
 */
typedef union BCMI_MADURA_DSC_CDR_STS_INTEGr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_integ[1];
	uint32_t _dsc_cdr_sts_integ;
} BCMI_MADURA_DSC_CDR_STS_INTEGr_t;

#define BCMI_MADURA_DSC_CDR_STS_INTEGr_CLR(r) (r).dsc_cdr_sts_integ[0] = 0
#define BCMI_MADURA_DSC_CDR_STS_INTEGr_SET(r,d) (r).dsc_cdr_sts_integ[0] = d
#define BCMI_MADURA_DSC_CDR_STS_INTEGr_GET(r) (r).dsc_cdr_sts_integ[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET(r) (((r).dsc_cdr_sts_integ[0]) & 0xffff)
#define BCMI_MADURA_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET(r,f) (r).dsc_cdr_sts_integ[0]=(((r).dsc_cdr_sts_integ[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_CDR_STS_INTEG.
 */
#define BCMI_MADURA_READ_DSC_CDR_STS_INTEGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_CDR_STS_INTEGr,_r._dsc_cdr_sts_integ)
#define BCMI_MADURA_WRITE_DSC_CDR_STS_INTEGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_CDR_STS_INTEGr,_r._dsc_cdr_sts_integ)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_INTEGr BCMI_MADURA_DSC_CDR_STS_INTEGr
#define DSC_CDR_STS_INTEGr_SIZE BCMI_MADURA_DSC_CDR_STS_INTEGr_SIZE
typedef BCMI_MADURA_DSC_CDR_STS_INTEGr_t DSC_CDR_STS_INTEGr_t;
#define DSC_CDR_STS_INTEGr_CLR BCMI_MADURA_DSC_CDR_STS_INTEGr_CLR
#define DSC_CDR_STS_INTEGr_SET BCMI_MADURA_DSC_CDR_STS_INTEGr_SET
#define DSC_CDR_STS_INTEGr_GET BCMI_MADURA_DSC_CDR_STS_INTEGr_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET BCMI_MADURA_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET BCMI_MADURA_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET
#define READ_DSC_CDR_STS_INTEGr BCMI_MADURA_READ_DSC_CDR_STS_INTEGr
#define WRITE_DSC_CDR_STS_INTEGr BCMI_MADURA_WRITE_DSC_CDR_STS_INTEGr
#define MODIFY_DSC_CDR_STS_INTEGr BCMI_MADURA_MODIFY_DSC_CDR_STS_INTEGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_CDR_STS_INTEGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_CDR_1G_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07a
 * DEVAD:    1
 * DESC:     1g cdr status reg
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_1G_PHASE_POINTER 1G phase pointer - currently wraps @ 33. Not used for 20.625
 */
#define BCMI_MADURA_DSC_CDR_1G_STSr (0x0001d07a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_CDR_1G_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_1G_STS.
 */
typedef union BCMI_MADURA_DSC_CDR_1G_STSr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_1g_sts[1];
	uint32_t _dsc_cdr_1g_sts;
} BCMI_MADURA_DSC_CDR_1G_STSr_t;

#define BCMI_MADURA_DSC_CDR_1G_STSr_CLR(r) (r).dsc_cdr_1g_sts[0] = 0
#define BCMI_MADURA_DSC_CDR_1G_STSr_SET(r,d) (r).dsc_cdr_1g_sts[0] = d
#define BCMI_MADURA_DSC_CDR_1G_STSr_GET(r) (r).dsc_cdr_1g_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET(r) (((r).dsc_cdr_1g_sts[0]) & 0xff)
#define BCMI_MADURA_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET(r,f) (r).dsc_cdr_1g_sts[0]=(((r).dsc_cdr_1g_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_CDR_1G_STS.
 */
#define BCMI_MADURA_READ_DSC_CDR_1G_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_CDR_1G_STSr,_r._dsc_cdr_1g_sts)
#define BCMI_MADURA_WRITE_DSC_CDR_1G_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_CDR_1G_STSr,_r._dsc_cdr_1g_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_1G_STSr BCMI_MADURA_DSC_CDR_1G_STSr
#define DSC_CDR_1G_STSr_SIZE BCMI_MADURA_DSC_CDR_1G_STSr_SIZE
typedef BCMI_MADURA_DSC_CDR_1G_STSr_t DSC_CDR_1G_STSr_t;
#define DSC_CDR_1G_STSr_CLR BCMI_MADURA_DSC_CDR_1G_STSr_CLR
#define DSC_CDR_1G_STSr_SET BCMI_MADURA_DSC_CDR_1G_STSr_SET
#define DSC_CDR_1G_STSr_GET BCMI_MADURA_DSC_CDR_1G_STSr_GET
#define DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET BCMI_MADURA_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET
#define DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET BCMI_MADURA_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET
#define READ_DSC_CDR_1G_STSr BCMI_MADURA_READ_DSC_CDR_1G_STSr
#define WRITE_DSC_CDR_1G_STSr BCMI_MADURA_WRITE_DSC_CDR_1G_STSr
#define MODIFY_DSC_CDR_1G_STSr BCMI_MADURA_MODIFY_DSC_CDR_1G_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_CDR_1G_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DSC_PRESET
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07e
 * DEVAD:    1
 * DESC:     preset register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRESET_C         Preset bit 1. Hooked up to dsc_sm bank
 *     PRESET_D         Preset bit 2. Hooked up to CDR trnsum bank
 *     PRESET_A         Preset bit 3. Hooked up to gen purpose bank a
 */
#define BCMI_MADURA_DSC_PRESETr (0x0001d07e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DSC_PRESETr_SIZE 4

/*
 * This structure should be used to declare and program DSC_PRESET.
 */
typedef union BCMI_MADURA_DSC_PRESETr_s {
	uint32_t v[1];
	uint32_t dsc_preset[1];
	uint32_t _dsc_preset;
} BCMI_MADURA_DSC_PRESETr_t;

#define BCMI_MADURA_DSC_PRESETr_CLR(r) (r).dsc_preset[0] = 0
#define BCMI_MADURA_DSC_PRESETr_SET(r,d) (r).dsc_preset[0] = d
#define BCMI_MADURA_DSC_PRESETr_GET(r) (r).dsc_preset[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DSC_PRESETr_PRESET_Af_GET(r) ((((r).dsc_preset[0]) >> 2) & 0x1)
#define BCMI_MADURA_DSC_PRESETr_PRESET_Af_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DSC_PRESETr_PRESET_Df_GET(r) ((((r).dsc_preset[0]) >> 1) & 0x1)
#define BCMI_MADURA_DSC_PRESETr_PRESET_Df_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DSC_PRESETr_PRESET_Cf_GET(r) (((r).dsc_preset[0]) & 0x1)
#define BCMI_MADURA_DSC_PRESETr_PRESET_Cf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_PRESET.
 */
#define BCMI_MADURA_READ_DSC_PRESETr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DSC_PRESETr,_r._dsc_preset)
#define BCMI_MADURA_WRITE_DSC_PRESETr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DSC_PRESETr,_r._dsc_preset)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_PRESETr BCMI_MADURA_DSC_PRESETr
#define DSC_PRESETr_SIZE BCMI_MADURA_DSC_PRESETr_SIZE
typedef BCMI_MADURA_DSC_PRESETr_t DSC_PRESETr_t;
#define DSC_PRESETr_CLR BCMI_MADURA_DSC_PRESETr_CLR
#define DSC_PRESETr_SET BCMI_MADURA_DSC_PRESETr_SET
#define DSC_PRESETr_GET BCMI_MADURA_DSC_PRESETr_GET
#define DSC_PRESETr_PRESET_Af_GET BCMI_MADURA_DSC_PRESETr_PRESET_Af_GET
#define DSC_PRESETr_PRESET_Af_SET BCMI_MADURA_DSC_PRESETr_PRESET_Af_SET
#define DSC_PRESETr_PRESET_Df_GET BCMI_MADURA_DSC_PRESETr_PRESET_Df_GET
#define DSC_PRESETr_PRESET_Df_SET BCMI_MADURA_DSC_PRESETr_PRESET_Df_SET
#define DSC_PRESETr_PRESET_Cf_GET BCMI_MADURA_DSC_PRESETr_PRESET_Cf_GET
#define DSC_PRESETr_PRESET_Cf_SET BCMI_MADURA_DSC_PRESETr_PRESET_Cf_SET
#define READ_DSC_PRESETr BCMI_MADURA_READ_DSC_PRESETr
#define WRITE_DSC_PRESETr BCMI_MADURA_WRITE_DSC_PRESETr
#define MODIFY_DSC_PRESETr BCMI_MADURA_MODIFY_DSC_PRESETr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DSC_PRESETr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UR_CTL0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd080
 * DEVAD:    1
 * DESC:     Control 0 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_RX_TRAINING_EN RX Training EnableEnables the frame lock fsm on the RX sides
 *     CL93N72_TR_COARSE_LOCK Set to TRUE (1'b1) by the micro when coarse lock to recovered clock has occured.cl93n72_pmd, then, proceeds with establishing frame_lock.
 *     CL93N72_RX_SIGNAL_OK Firmware sets this bit to 1'b0 when the training is in progressand sets this bit to 1'b1 when the training is complete
 */
#define BCMI_MADURA_CL93N72_UR_CTL0r (0x0001d080 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_CTL0.
 */
typedef union BCMI_MADURA_CL93N72_UR_CTL0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_ctl0[1];
	uint32_t _cl93n72_ur_ctl0;
} BCMI_MADURA_CL93N72_UR_CTL0r_t;

#define BCMI_MADURA_CL93N72_UR_CTL0r_CLR(r) (r).cl93n72_ur_ctl0[0] = 0
#define BCMI_MADURA_CL93N72_UR_CTL0r_SET(r,d) (r).cl93n72_ur_ctl0[0] = d
#define BCMI_MADURA_CL93N72_UR_CTL0r_GET(r) (r).cl93n72_ur_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_GET(r) ((((r).cl93n72_ur_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_SET(r,f) (r).cl93n72_ur_ctl0[0]=(((r).cl93n72_ur_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_GET(r) ((((r).cl93n72_ur_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_SET(r,f) (r).cl93n72_ur_ctl0[0]=(((r).cl93n72_ur_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_GET(r) (((r).cl93n72_ur_ctl0[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_SET(r,f) (r).cl93n72_ur_ctl0[0]=(((r).cl93n72_ur_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_CTL0.
 */
#define BCMI_MADURA_READ_CL93N72_UR_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UR_CTL0r,_r._cl93n72_ur_ctl0)
#define BCMI_MADURA_WRITE_CL93N72_UR_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UR_CTL0r,_r._cl93n72_ur_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_CTL0r BCMI_MADURA_CL93N72_UR_CTL0r
#define CL93N72_UR_CTL0r_SIZE BCMI_MADURA_CL93N72_UR_CTL0r_SIZE
typedef BCMI_MADURA_CL93N72_UR_CTL0r_t CL93N72_UR_CTL0r_t;
#define CL93N72_UR_CTL0r_CLR BCMI_MADURA_CL93N72_UR_CTL0r_CLR
#define CL93N72_UR_CTL0r_SET BCMI_MADURA_CL93N72_UR_CTL0r_SET
#define CL93N72_UR_CTL0r_GET BCMI_MADURA_CL93N72_UR_CTL0r_GET
#define CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_GET BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_GET
#define CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_SET BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_SET
#define CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_GET BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_GET
#define CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_SET BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_SET
#define CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_GET BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_GET
#define CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_SET BCMI_MADURA_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_SET
#define READ_CL93N72_UR_CTL0r BCMI_MADURA_READ_CL93N72_UR_CTL0r
#define WRITE_CL93N72_UR_CTL0r BCMI_MADURA_WRITE_CL93N72_UR_CTL0r
#define MODIFY_CL93N72_UR_CTL0r BCMI_MADURA_MODIFY_CL93N72_UR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UR_CTL1
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd081
 * DEVAD:    1
 * DESC:     Control 1 Register
 * RESETVAL: 0x52 (82)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_GOOD_MARKER_CNT Number of good marker to checkbefore enabling frame lock
 *     CL93N72_BAD_MARKER_CNT Number of bad marker to checkbefore losing frame lock
 */
#define BCMI_MADURA_CL93N72_UR_CTL1r (0x0001d081 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_CTL1.
 */
typedef union BCMI_MADURA_CL93N72_UR_CTL1r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_ctl1[1];
	uint32_t _cl93n72_ur_ctl1;
} BCMI_MADURA_CL93N72_UR_CTL1r_t;

#define BCMI_MADURA_CL93N72_UR_CTL1r_CLR(r) (r).cl93n72_ur_ctl1[0] = 0
#define BCMI_MADURA_CL93N72_UR_CTL1r_SET(r,d) (r).cl93n72_ur_ctl1[0] = d
#define BCMI_MADURA_CL93N72_UR_CTL1r_GET(r) (r).cl93n72_ur_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_GET(r) ((((r).cl93n72_ur_ctl1[0]) >> 4) & 0x7)
#define BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_SET(r,f) (r).cl93n72_ur_ctl1[0]=(((r).cl93n72_ur_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_GET(r) (((r).cl93n72_ur_ctl1[0]) & 0x3)
#define BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_SET(r,f) (r).cl93n72_ur_ctl1[0]=(((r).cl93n72_ur_ctl1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access CL93N72_UR_CTL1.
 */
#define BCMI_MADURA_READ_CL93N72_UR_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UR_CTL1r,_r._cl93n72_ur_ctl1)
#define BCMI_MADURA_WRITE_CL93N72_UR_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UR_CTL1r,_r._cl93n72_ur_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_CTL1r BCMI_MADURA_CL93N72_UR_CTL1r
#define CL93N72_UR_CTL1r_SIZE BCMI_MADURA_CL93N72_UR_CTL1r_SIZE
typedef BCMI_MADURA_CL93N72_UR_CTL1r_t CL93N72_UR_CTL1r_t;
#define CL93N72_UR_CTL1r_CLR BCMI_MADURA_CL93N72_UR_CTL1r_CLR
#define CL93N72_UR_CTL1r_SET BCMI_MADURA_CL93N72_UR_CTL1r_SET
#define CL93N72_UR_CTL1r_GET BCMI_MADURA_CL93N72_UR_CTL1r_GET
#define CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_GET BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_GET
#define CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_SET BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_SET
#define CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_GET BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_GET
#define CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_SET BCMI_MADURA_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_SET
#define READ_CL93N72_UR_CTL1r BCMI_MADURA_READ_CL93N72_UR_CTL1r
#define WRITE_CL93N72_UR_CTL1r BCMI_MADURA_WRITE_CL93N72_UR_CTL1r
#define MODIFY_CL93N72_UR_CTL1r BCMI_MADURA_MODIFY_CL93N72_UR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UR_CTL2
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd082
 * DEVAD:    1
 * DESC:     Control 2 Register
 * RESETVAL: 0x310 (784)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_CTRL_FRAME_DLY 0   : dis1-7 : early delay w.r.t cl93n72 rcvd data (7 vals)8  : sync to cl93n72 rcvd data9-15 : late delay w.r.t cl93n72 rcvd data (7 vals)
 *     CL93N72_DME_CELL_BOUNDARY_CHK Check for DME cell boundary transitions0 - disabled1 - enabled
 *     CL93N72_STRICT_DME_CHK This field specifies whether the edges of DME cells are allowedto shift by a couple samples0 - ignore bits 0, 3, 4 and 7 of the DME cell1 - check all 8 bits of the DME cell
 *     CL93N72_STRICT_MARKER_CHK When determining frame lock, this field can be used tospecifies whether the edges of frame markers are allowedto shift by a couple samples0 - ignore first and last two samples of the marker1 - do not ignore first and last two samples of the markercheck for all 16 ones followed by 16 zeros
 *     CL93N72_PPM_OFFSET_EN if enabled, cl93n72 tracks ppm offset of incoming datawhile checking from frame lock, one bit offset ineither direction for every frame (~4384 bits)0 - disabled1 - enabled
 *     CL93N72_RX_DP_LN_CLK_EN cl93n72 Rx datapath lane clock enable0 - disabled1 - enabled
 *     CL93N72_FRAME_CONSISTENCY_CHK_EN cl93n72 frame consistency check enable0 - disabled1 - enabled - checks that three consective frames from the link partnerhas the same status response/coffcient update request informationbefore it set the sets the latched status bits
 *     CL93N72_BLOCK_LP_IEEE_UPDATES cl93n72 Block new lp ieee control/status page updates while an interrupt is pending0 - when the consistency checks are disabled, allow lp ieee control/status pagesto be updated upon receiving new pages all of the time1 - when the consistency checks are disabled, block lp ieee control/status pagesto be updated upon receiving new pages if an interrupt is already pending
 */
#define BCMI_MADURA_CL93N72_UR_CTL2r (0x0001d082 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_CTL2.
 */
typedef union BCMI_MADURA_CL93N72_UR_CTL2r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_ctl2[1];
	uint32_t _cl93n72_ur_ctl2;
} BCMI_MADURA_CL93N72_UR_CTL2r_t;

#define BCMI_MADURA_CL93N72_UR_CTL2r_CLR(r) (r).cl93n72_ur_ctl2[0] = 0
#define BCMI_MADURA_CL93N72_UR_CTL2r_SET(r,d) (r).cl93n72_ur_ctl2[0] = d
#define BCMI_MADURA_CL93N72_UR_CTL2r_GET(r) (r).cl93n72_ur_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_BLOCK_LP_IEEE_UPDATESf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 10) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_BLOCK_LP_IEEE_UPDATESf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 9) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 8) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 7) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 6) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 5) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 4) & 0x1)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_GET(r) (((r).cl93n72_ur_ctl2[0]) & 0xf)
#define BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CL93N72_UR_CTL2.
 */
#define BCMI_MADURA_READ_CL93N72_UR_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UR_CTL2r,_r._cl93n72_ur_ctl2)
#define BCMI_MADURA_WRITE_CL93N72_UR_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UR_CTL2r,_r._cl93n72_ur_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_CTL2r BCMI_MADURA_CL93N72_UR_CTL2r
#define CL93N72_UR_CTL2r_SIZE BCMI_MADURA_CL93N72_UR_CTL2r_SIZE
typedef BCMI_MADURA_CL93N72_UR_CTL2r_t CL93N72_UR_CTL2r_t;
#define CL93N72_UR_CTL2r_CLR BCMI_MADURA_CL93N72_UR_CTL2r_CLR
#define CL93N72_UR_CTL2r_SET BCMI_MADURA_CL93N72_UR_CTL2r_SET
#define CL93N72_UR_CTL2r_GET BCMI_MADURA_CL93N72_UR_CTL2r_GET
#define CL93N72_UR_CTL2r_CL93N72_BLOCK_LP_IEEE_UPDATESf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_BLOCK_LP_IEEE_UPDATESf_GET
#define CL93N72_UR_CTL2r_CL93N72_BLOCK_LP_IEEE_UPDATESf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_BLOCK_LP_IEEE_UPDATESf_SET
#define CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_GET
#define CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_SET
#define CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_GET
#define CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_SET
#define CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_GET
#define CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_SET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_GET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_SET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_GET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_SET
#define CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_GET
#define CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_SET
#define CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_GET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_GET
#define CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_SET BCMI_MADURA_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_SET
#define READ_CL93N72_UR_CTL2r BCMI_MADURA_READ_CL93N72_UR_CTL2r
#define WRITE_CL93N72_UR_CTL2r BCMI_MADURA_WRITE_CL93N72_UR_CTL2r
#define MODIFY_CL93N72_UR_CTL2r BCMI_MADURA_MODIFY_CL93N72_UR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UR_STS0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd083
 * DEVAD:    1
 * DESC:     Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_FRAME_LOCK Frame Lock signal statusThis bit provides status of the frame lock signal from the frame lock fsm.1 - frame locked0 - frame not lockedThe status bit in the IEEE registers space is set by firmware
 *     CL93N72_REMOTE_RX_READY remote_rx_ready statusThis bit provides status of the remote_rx_ready signal from the link partner.
 */
#define BCMI_MADURA_CL93N72_UR_STS0r (0x0001d083 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_STS0.
 */
typedef union BCMI_MADURA_CL93N72_UR_STS0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_sts0[1];
	uint32_t _cl93n72_ur_sts0;
} BCMI_MADURA_CL93N72_UR_STS0r_t;

#define BCMI_MADURA_CL93N72_UR_STS0r_CLR(r) (r).cl93n72_ur_sts0[0] = 0
#define BCMI_MADURA_CL93N72_UR_STS0r_SET(r,d) (r).cl93n72_ur_sts0[0] = d
#define BCMI_MADURA_CL93N72_UR_STS0r_GET(r) (r).cl93n72_ur_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_REMOTE_RX_READYf_GET(r) ((((r).cl93n72_ur_sts0[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_REMOTE_RX_READYf_SET(r,f) (r).cl93n72_ur_sts0[0]=(((r).cl93n72_ur_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_GET(r) (((r).cl93n72_ur_sts0[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_SET(r,f) (r).cl93n72_ur_sts0[0]=(((r).cl93n72_ur_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_STS0.
 */
#define BCMI_MADURA_READ_CL93N72_UR_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UR_STS0r,_r._cl93n72_ur_sts0)
#define BCMI_MADURA_WRITE_CL93N72_UR_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UR_STS0r,_r._cl93n72_ur_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_STS0r BCMI_MADURA_CL93N72_UR_STS0r
#define CL93N72_UR_STS0r_SIZE BCMI_MADURA_CL93N72_UR_STS0r_SIZE
typedef BCMI_MADURA_CL93N72_UR_STS0r_t CL93N72_UR_STS0r_t;
#define CL93N72_UR_STS0r_CLR BCMI_MADURA_CL93N72_UR_STS0r_CLR
#define CL93N72_UR_STS0r_SET BCMI_MADURA_CL93N72_UR_STS0r_SET
#define CL93N72_UR_STS0r_GET BCMI_MADURA_CL93N72_UR_STS0r_GET
#define CL93N72_UR_STS0r_CL93N72_REMOTE_RX_READYf_GET BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_REMOTE_RX_READYf_GET
#define CL93N72_UR_STS0r_CL93N72_REMOTE_RX_READYf_SET BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_REMOTE_RX_READYf_SET
#define CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_GET BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_GET
#define CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_SET BCMI_MADURA_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_SET
#define READ_CL93N72_UR_STS0r BCMI_MADURA_READ_CL93N72_UR_STS0r
#define WRITE_CL93N72_UR_STS0r BCMI_MADURA_WRITE_CL93N72_UR_STS0r
#define MODIFY_CL93N72_UR_STS0r BCMI_MADURA_MODIFY_CL93N72_UR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UR_UC_INTR_CTL0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd084
 * DEVAD:    1
 * DESC:     Micro Interrupt Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_MICRO_UPDATE_CHG_INT_EN Update field micro interrupt enable. Enables an interrupt when the update field value changes in the training frame received from Link PartnerThe Link parnter request a change to the Local Device TX FIR tap values via the update field1 - Enable. Generates an interrupt when cl93n72_micro_lstatus_update_chg = 1'b1.0 - Disable
 *     CL93N72_MICRO_STATUS_CHG_INT_EN Status field change micro interrupt enable. Enables an interrupt when the status field value changes in the training frame received from Link PartnerWhen the Local Devices requests Link Partner to change its TX FIR tap values, then the Link Partner updatestaps and sends a response on the stataus field of the training frame1 - Enable. Generates an interrupt when cl93n72_micro_lstatus_status_chg = 1'b1.0 - Disable
 *     CL93N72_MICRO_FRAME_LOCK_INT_EN frame_lock change micro interrupt enable.1 - Enable0 - Disable
 *     CL93N72_MICRO_UPDATE_REQ_INT_FRC Force an interrupt on cl93n72_micro_update_req_int pin0 -  interrupt on the cl93n72_micro_update_req_int pingenerated when the update field value changes in the trainingframe received from Link Partner andcl93n72_micro_update_chg_int_en field is set to 1'b11 -  interrupt on the cl93n72_micro_update_req_int pingenerated by the cl93n72_micro_update_req_int_frc_val field
 *     CL93N72_MICRO_UPDATE_REQ_INT_FRC_VAL Force value on cl93n72_micro_update_req_int pinwhen cl93n72_micro_update_req_int_frc field is set to 1'b1
 *     CL93N72_MICRO_STATUS_RESP_INT_FRC Force an interrupt on cl93n72_micro_status_resp_int pin0 -  interrupt on the cl93n72_micro_status_resp_int pingenerated when the status field value changes in the trainingframe received from Link Partner andcl93n72_micro_status_chg_int_en field is set to 1'b11 -  interrupt on the cl93n72_micro_status_resp_int pingenerated by the cl93n72_micro_status_resp_int_frc_val field
 *     CL93N72_MICRO_STATUS_RESP_INT_FRC_VAL Force value on cl93n72_micro_status_resp_int pinwhen cl93n72_micro_status_resp_int_frc field is set to 1'b1
 */
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r (0x0001d084 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_UC_INTR_CTL0.
 */
typedef union BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_uc_intr_ctl0[1];
	uint32_t _cl93n72_ur_uc_intr_ctl0;
} BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_t;

#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CLR(r) (r).cl93n72_ur_uc_intr_ctl0[0] = 0
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_SET(r,d) (r).cl93n72_ur_uc_intr_ctl0[0] = d
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_GET(r) (r).cl93n72_ur_uc_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRC_VALf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 11) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRC_VALf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRCf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 10) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRCf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRC_VALf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRC_VALf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRCf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRCf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_GET(r) (((r).cl93n72_ur_uc_intr_ctl0[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_UC_INTR_CTL0.
 */
#define BCMI_MADURA_READ_CL93N72_UR_UC_INTR_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r,_r._cl93n72_ur_uc_intr_ctl0)
#define BCMI_MADURA_WRITE_CL93N72_UR_UC_INTR_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r,_r._cl93n72_ur_uc_intr_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_UC_INTR_CTL0r BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r
#define CL93N72_UR_UC_INTR_CTL0r_SIZE BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_SIZE
typedef BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_t CL93N72_UR_UC_INTR_CTL0r_t;
#define CL93N72_UR_UC_INTR_CTL0r_CLR BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CLR
#define CL93N72_UR_UC_INTR_CTL0r_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_SET
#define CL93N72_UR_UC_INTR_CTL0r_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRC_VALf_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRC_VALf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRC_VALf_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRC_VALf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRCf_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRCf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRCf_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_RESP_INT_FRCf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRC_VALf_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRC_VALf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRC_VALf_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRC_VALf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRCf_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRCf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRCf_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_REQ_INT_FRCf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_GET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_SET BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_SET
#define READ_CL93N72_UR_UC_INTR_CTL0r BCMI_MADURA_READ_CL93N72_UR_UC_INTR_CTL0r
#define WRITE_CL93N72_UR_UC_INTR_CTL0r BCMI_MADURA_WRITE_CL93N72_UR_UC_INTR_CTL0r
#define MODIFY_CL93N72_UR_UC_INTR_CTL0r BCMI_MADURA_MODIFY_CL93N72_UR_UC_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UR_UC_INTR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UR_UC_STS0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd085
 * DEVAD:    1
 * DESC:     Micro Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_MICRO_UPDATE_CHG_LSTATUS coeffcient update field change latched status -  This bit is set to 1'b1 when the update field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 */
#define BCMI_MADURA_CL93N72_UR_UC_STS0r (0x0001d085 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UR_UC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_UC_STS0.
 */
typedef union BCMI_MADURA_CL93N72_UR_UC_STS0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_uc_sts0[1];
	uint32_t _cl93n72_ur_uc_sts0;
} BCMI_MADURA_CL93N72_UR_UC_STS0r_t;

#define BCMI_MADURA_CL93N72_UR_UC_STS0r_CLR(r) (r).cl93n72_ur_uc_sts0[0] = 0
#define BCMI_MADURA_CL93N72_UR_UC_STS0r_SET(r,d) (r).cl93n72_ur_uc_sts0[0] = d
#define BCMI_MADURA_CL93N72_UR_UC_STS0r_GET(r) (r).cl93n72_ur_uc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_GET(r) (((r).cl93n72_ur_uc_sts0[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_SET(r,f) (r).cl93n72_ur_uc_sts0[0]=(((r).cl93n72_ur_uc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_UC_STS0.
 */
#define BCMI_MADURA_READ_CL93N72_UR_UC_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UR_UC_STS0r,_r._cl93n72_ur_uc_sts0)
#define BCMI_MADURA_WRITE_CL93N72_UR_UC_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UR_UC_STS0r,_r._cl93n72_ur_uc_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_UC_STS0r BCMI_MADURA_CL93N72_UR_UC_STS0r
#define CL93N72_UR_UC_STS0r_SIZE BCMI_MADURA_CL93N72_UR_UC_STS0r_SIZE
typedef BCMI_MADURA_CL93N72_UR_UC_STS0r_t CL93N72_UR_UC_STS0r_t;
#define CL93N72_UR_UC_STS0r_CLR BCMI_MADURA_CL93N72_UR_UC_STS0r_CLR
#define CL93N72_UR_UC_STS0r_SET BCMI_MADURA_CL93N72_UR_UC_STS0r_SET
#define CL93N72_UR_UC_STS0r_GET BCMI_MADURA_CL93N72_UR_UC_STS0r_GET
#define CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_GET BCMI_MADURA_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_GET
#define CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_SET BCMI_MADURA_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_SET
#define READ_CL93N72_UR_UC_STS0r BCMI_MADURA_READ_CL93N72_UR_UC_STS0r
#define WRITE_CL93N72_UR_UC_STS0r BCMI_MADURA_WRITE_CL93N72_UR_UC_STS0r
#define MODIFY_CL93N72_UR_UC_STS0r BCMI_MADURA_MODIFY_CL93N72_UR_UC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UR_UC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UR_UC_STS1
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd086
 * DEVAD:    1
 * DESC:     Micro Status 1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_MICRO_STATUS_CHG_LSTATUS coeffcient status field latched status - This bit is set to 1'b1 when the status field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 *     CL93N72_MICRO_FRAME_LOCK_LSTATUS Frame lock change latched status - This bit is set to 1'b1 when a change is detected on the frame lock signalThis bit cleared when this register is read.
 */
#define BCMI_MADURA_CL93N72_UR_UC_STS1r (0x0001d086 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UR_UC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_UC_STS1.
 */
typedef union BCMI_MADURA_CL93N72_UR_UC_STS1r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_uc_sts1[1];
	uint32_t _cl93n72_ur_uc_sts1;
} BCMI_MADURA_CL93N72_UR_UC_STS1r_t;

#define BCMI_MADURA_CL93N72_UR_UC_STS1r_CLR(r) (r).cl93n72_ur_uc_sts1[0] = 0
#define BCMI_MADURA_CL93N72_UR_UC_STS1r_SET(r,d) (r).cl93n72_ur_uc_sts1[0] = d
#define BCMI_MADURA_CL93N72_UR_UC_STS1r_GET(r) (r).cl93n72_ur_uc_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_GET(r) ((((r).cl93n72_ur_uc_sts1[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_SET(r,f) (r).cl93n72_ur_uc_sts1[0]=(((r).cl93n72_ur_uc_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_GET(r) (((r).cl93n72_ur_uc_sts1[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_SET(r,f) (r).cl93n72_ur_uc_sts1[0]=(((r).cl93n72_ur_uc_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_UC_STS1.
 */
#define BCMI_MADURA_READ_CL93N72_UR_UC_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UR_UC_STS1r,_r._cl93n72_ur_uc_sts1)
#define BCMI_MADURA_WRITE_CL93N72_UR_UC_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UR_UC_STS1r,_r._cl93n72_ur_uc_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_UC_STS1r BCMI_MADURA_CL93N72_UR_UC_STS1r
#define CL93N72_UR_UC_STS1r_SIZE BCMI_MADURA_CL93N72_UR_UC_STS1r_SIZE
typedef BCMI_MADURA_CL93N72_UR_UC_STS1r_t CL93N72_UR_UC_STS1r_t;
#define CL93N72_UR_UC_STS1r_CLR BCMI_MADURA_CL93N72_UR_UC_STS1r_CLR
#define CL93N72_UR_UC_STS1r_SET BCMI_MADURA_CL93N72_UR_UC_STS1r_SET
#define CL93N72_UR_UC_STS1r_GET BCMI_MADURA_CL93N72_UR_UC_STS1r_GET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_GET BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_GET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_SET BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_SET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_GET BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_GET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_SET BCMI_MADURA_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_SET
#define READ_CL93N72_UR_UC_STS1r BCMI_MADURA_READ_CL93N72_UR_UC_STS1r
#define WRITE_CL93N72_UR_UC_STS1r BCMI_MADURA_WRITE_CL93N72_UR_UC_STS1r
#define MODIFY_CL93N72_UR_UC_STS1r BCMI_MADURA_MODIFY_CL93N72_UR_UC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UR_UC_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_XMT_UPD_PAGE
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd090
 * DEVAD:    1
 * DESC:     cl93n72 Send Coefficient Update Request to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_XMT_UPDATE_PAGE Local Device (LD) Coefficient Update registerContains correction information from the local receiverto the link partner transmit equalizer.Bit15:14   Reserved Transmitted as 0, ignored on reception.13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved Transmitted as 0, ignored on reception.5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr (0x0001d090 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_XMT_UPD_PAGE.
 */
typedef union BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_xmt_upd_page[1];
	uint32_t _cl93n72_ut_xmt_upd_page;
} BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_t;

#define BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_CLR(r) (r).cl93n72_ut_xmt_upd_page[0] = 0
#define BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_SET(r,d) (r).cl93n72_ut_xmt_upd_page[0] = d
#define BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_GET(r) (r).cl93n72_ut_xmt_upd_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_GET(r) (((r).cl93n72_ut_xmt_upd_page[0]) & 0xffff)
#define BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_SET(r,f) (r).cl93n72_ut_xmt_upd_page[0]=(((r).cl93n72_ut_xmt_upd_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_UT_XMT_UPD_PAGE.
 */
#define BCMI_MADURA_READ_CL93N72_UT_XMT_UPD_PAGEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr,_r._cl93n72_ut_xmt_upd_page)
#define BCMI_MADURA_WRITE_CL93N72_UT_XMT_UPD_PAGEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr,_r._cl93n72_ut_xmt_upd_page)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_XMT_UPD_PAGEr BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr
#define CL93N72_UT_XMT_UPD_PAGEr_SIZE BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_SIZE
typedef BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_t CL93N72_UT_XMT_UPD_PAGEr_t;
#define CL93N72_UT_XMT_UPD_PAGEr_CLR BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_CLR
#define CL93N72_UT_XMT_UPD_PAGEr_SET BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_SET
#define CL93N72_UT_XMT_UPD_PAGEr_GET BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_GET
#define CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_GET BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_GET
#define CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_SET BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_SET
#define READ_CL93N72_UT_XMT_UPD_PAGEr BCMI_MADURA_READ_CL93N72_UT_XMT_UPD_PAGEr
#define WRITE_CL93N72_UT_XMT_UPD_PAGEr BCMI_MADURA_WRITE_CL93N72_UT_XMT_UPD_PAGEr
#define MODIFY_CL93N72_UT_XMT_UPD_PAGEr BCMI_MADURA_MODIFY_CL93N72_UT_XMT_UPD_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_XMT_UPD_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_LD_XMT_STS_PAGE
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd091
 * DEVAD:    1
 * DESC:     cl93n72 Send Local Device's Coeffcient Status to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_LD_XMT_STATUS_PAGE Local Device's transmit status page
 */
#define BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr (0x0001d091 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_LD_XMT_STS_PAGE.
 */
typedef union BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ld_xmt_sts_page[1];
	uint32_t _cl93n72_ut_ld_xmt_sts_page;
} BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_t;

#define BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_CLR(r) (r).cl93n72_ut_ld_xmt_sts_page[0] = 0
#define BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_SET(r,d) (r).cl93n72_ut_ld_xmt_sts_page[0] = d
#define BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_GET(r) (r).cl93n72_ut_ld_xmt_sts_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_GET(r) (((r).cl93n72_ut_ld_xmt_sts_page[0]) & 0xffff)
#define BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_SET(r,f) (r).cl93n72_ut_ld_xmt_sts_page[0]=(((r).cl93n72_ut_ld_xmt_sts_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_UT_LD_XMT_STS_PAGE.
 */
#define BCMI_MADURA_READ_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr,_r._cl93n72_ut_ld_xmt_sts_page)
#define BCMI_MADURA_WRITE_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr,_r._cl93n72_ut_ld_xmt_sts_page)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_LD_XMT_STS_PAGEr BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr
#define CL93N72_UT_LD_XMT_STS_PAGEr_SIZE BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_SIZE
typedef BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_t CL93N72_UT_LD_XMT_STS_PAGEr_t;
#define CL93N72_UT_LD_XMT_STS_PAGEr_CLR BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_CLR
#define CL93N72_UT_LD_XMT_STS_PAGEr_SET BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_SET
#define CL93N72_UT_LD_XMT_STS_PAGEr_GET BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_GET
#define CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_GET BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_GET
#define CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_SET BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_SET
#define READ_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_MADURA_READ_CL93N72_UT_LD_XMT_STS_PAGEr
#define WRITE_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_MADURA_WRITE_CL93N72_UT_LD_XMT_STS_PAGEr
#define MODIFY_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_MADURA_MODIFY_CL93N72_UT_LD_XMT_STS_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_LD_XMT_STS_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_CTL0
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd092
 * DEVAD:    1
 * DESC:     cl93n72 Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_SW_RX_TRAINED Set to TRUE (1'b1) by the micro when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     CL93N72_SW_FRAME_LOCK Set to TRUE (1'b1) by the micro to indicate to the training fsmframe lock has been achieved
 *     CL93N72_SW_REMOTE_RX_READY Set to TRUE (1'b1) by the micro to indicate to the training fsmlink parnter rx ready bit is set. It indicates that the remote is trained
 */
#define BCMI_MADURA_CL93N72_UT_CTL0r (0x0001d092 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL0.
 */
typedef union BCMI_MADURA_CL93N72_UT_CTL0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl0[1];
	uint32_t _cl93n72_ut_ctl0;
} BCMI_MADURA_CL93N72_UT_CTL0r_t;

#define BCMI_MADURA_CL93N72_UT_CTL0r_CLR(r) (r).cl93n72_ut_ctl0[0] = 0
#define BCMI_MADURA_CL93N72_UT_CTL0r_SET(r,d) (r).cl93n72_ut_ctl0[0] = d
#define BCMI_MADURA_CL93N72_UT_CTL0r_GET(r) (r).cl93n72_ut_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_GET(r) ((((r).cl93n72_ut_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_GET(r) ((((r).cl93n72_ut_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_GET(r) (((r).cl93n72_ut_ctl0[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL0.
 */
#define BCMI_MADURA_READ_CL93N72_UT_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_CTL0r,_r._cl93n72_ut_ctl0)
#define BCMI_MADURA_WRITE_CL93N72_UT_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_CTL0r,_r._cl93n72_ut_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL0r BCMI_MADURA_CL93N72_UT_CTL0r
#define CL93N72_UT_CTL0r_SIZE BCMI_MADURA_CL93N72_UT_CTL0r_SIZE
typedef BCMI_MADURA_CL93N72_UT_CTL0r_t CL93N72_UT_CTL0r_t;
#define CL93N72_UT_CTL0r_CLR BCMI_MADURA_CL93N72_UT_CTL0r_CLR
#define CL93N72_UT_CTL0r_SET BCMI_MADURA_CL93N72_UT_CTL0r_SET
#define CL93N72_UT_CTL0r_GET BCMI_MADURA_CL93N72_UT_CTL0r_GET
#define CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_GET BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_GET
#define CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_SET BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_SET
#define CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_GET BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_GET
#define CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_SET BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_SET
#define CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_GET BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_GET
#define CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_SET BCMI_MADURA_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_SET
#define READ_CL93N72_UT_CTL0r BCMI_MADURA_READ_CL93N72_UT_CTL0r
#define WRITE_CL93N72_UT_CTL0r BCMI_MADURA_WRITE_CL93N72_UT_CTL0r
#define MODIFY_CL93N72_UT_CTL0r BCMI_MADURA_MODIFY_CL93N72_UT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_CTL1
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd093
 * DEVAD:    1
 * DESC:     cl93n72 Control 1 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_BRK_RING_OSC PRBS 11 Ring Oscillator control1: No oscillating - low power mode0: Osciallate - normal mode
 *     CL93N72_DIS_MAX_WAIT_TIMER disable max wait timer1 = max wait timer disabled0 = max wait timer enabled
 *     CL93N72_TX_DP_LN_CLK_EN cl93n72 Tx Datapath lane clock enable0 - disabled1 - enabled
 *     CL93N72_TIMER_VALUE_SEL This bit is used to select the register fields that sets themaximum training time and the number of frames to be sent bythe local device after it has been traininedThis field is normally set while the datapath reset is asserted.This bit is asynchronous to the txcom_* register fields1 = use txcom_cl93n72_wait_cntr_limit_2ndset/txcom_cl93n72_max_wait_timer_period_2ndset0 = use txcom_cl93n72_wait_cntr_limit/txcom_cl93n72_max_wait_timer_period
 */
#define BCMI_MADURA_CL93N72_UT_CTL1r (0x0001d093 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL1.
 */
typedef union BCMI_MADURA_CL93N72_UT_CTL1r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl1[1];
	uint32_t _cl93n72_ut_ctl1;
} BCMI_MADURA_CL93N72_UT_CTL1r_t;

#define BCMI_MADURA_CL93N72_UT_CTL1r_CLR(r) (r).cl93n72_ut_ctl1[0] = 0
#define BCMI_MADURA_CL93N72_UT_CTL1r_SET(r,d) (r).cl93n72_ut_ctl1[0] = d
#define BCMI_MADURA_CL93N72_UT_CTL1r_GET(r) (r).cl93n72_ut_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TIMER_VALUE_SELf_GET(r) ((((r).cl93n72_ut_ctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TIMER_VALUE_SELf_SET(r,f) (r).cl93n72_ut_ctl1[0]=(((r).cl93n72_ut_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_GET(r) ((((r).cl93n72_ut_ctl1[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_SET(r,f) (r).cl93n72_ut_ctl1[0]=(((r).cl93n72_ut_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_GET(r) ((((r).cl93n72_ut_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_SET(r,f) (r).cl93n72_ut_ctl1[0]=(((r).cl93n72_ut_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_GET(r) (((r).cl93n72_ut_ctl1[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_SET(r,f) (r).cl93n72_ut_ctl1[0]=(((r).cl93n72_ut_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL1.
 */
#define BCMI_MADURA_READ_CL93N72_UT_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_CTL1r,_r._cl93n72_ut_ctl1)
#define BCMI_MADURA_WRITE_CL93N72_UT_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_CTL1r,_r._cl93n72_ut_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL1r BCMI_MADURA_CL93N72_UT_CTL1r
#define CL93N72_UT_CTL1r_SIZE BCMI_MADURA_CL93N72_UT_CTL1r_SIZE
typedef BCMI_MADURA_CL93N72_UT_CTL1r_t CL93N72_UT_CTL1r_t;
#define CL93N72_UT_CTL1r_CLR BCMI_MADURA_CL93N72_UT_CTL1r_CLR
#define CL93N72_UT_CTL1r_SET BCMI_MADURA_CL93N72_UT_CTL1r_SET
#define CL93N72_UT_CTL1r_GET BCMI_MADURA_CL93N72_UT_CTL1r_GET
#define CL93N72_UT_CTL1r_CL93N72_TIMER_VALUE_SELf_GET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TIMER_VALUE_SELf_GET
#define CL93N72_UT_CTL1r_CL93N72_TIMER_VALUE_SELf_SET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TIMER_VALUE_SELf_SET
#define CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_GET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_GET
#define CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_SET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_SET
#define CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_GET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_GET
#define CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_SET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_SET
#define CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_GET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_GET
#define CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_SET BCMI_MADURA_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_SET
#define READ_CL93N72_UT_CTL1r BCMI_MADURA_READ_CL93N72_UT_CTL1r
#define WRITE_CL93N72_UT_CTL1r BCMI_MADURA_WRITE_CL93N72_UT_CTL1r
#define MODIFY_CL93N72_UT_CTL1r BCMI_MADURA_MODIFY_CL93N72_UT_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_CTL2
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd094
 * DEVAD:    1
 * DESC:     cl93n72 Control 2 Register
 * RESETVAL: 0x1808 (6152)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_TXFIR_PRE pre cursor tap coeeficient value.CAUI-4 chip to chip defaults
 *     CL93N72_TXFIR_POST post cursor tap coeeficient value.CAUI-4 chip to chip defaults
 */
#define BCMI_MADURA_CL93N72_UT_CTL2r (0x0001d094 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL2.
 */
typedef union BCMI_MADURA_CL93N72_UT_CTL2r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl2[1];
	uint32_t _cl93n72_ut_ctl2;
} BCMI_MADURA_CL93N72_UT_CTL2r_t;

#define BCMI_MADURA_CL93N72_UT_CTL2r_CLR(r) (r).cl93n72_ut_ctl2[0] = 0
#define BCMI_MADURA_CL93N72_UT_CTL2r_SET(r,d) (r).cl93n72_ut_ctl2[0] = d
#define BCMI_MADURA_CL93N72_UT_CTL2r_GET(r) (r).cl93n72_ut_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_GET(r) ((((r).cl93n72_ut_ctl2[0]) >> 8) & 0x3f)
#define BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_SET(r,f) (r).cl93n72_ut_ctl2[0]=(((r).cl93n72_ut_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_GET(r) (((r).cl93n72_ut_ctl2[0]) & 0x1f)
#define BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_SET(r,f) (r).cl93n72_ut_ctl2[0]=(((r).cl93n72_ut_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL2.
 */
#define BCMI_MADURA_READ_CL93N72_UT_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_CTL2r,_r._cl93n72_ut_ctl2)
#define BCMI_MADURA_WRITE_CL93N72_UT_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_CTL2r,_r._cl93n72_ut_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL2r BCMI_MADURA_CL93N72_UT_CTL2r
#define CL93N72_UT_CTL2r_SIZE BCMI_MADURA_CL93N72_UT_CTL2r_SIZE
typedef BCMI_MADURA_CL93N72_UT_CTL2r_t CL93N72_UT_CTL2r_t;
#define CL93N72_UT_CTL2r_CLR BCMI_MADURA_CL93N72_UT_CTL2r_CLR
#define CL93N72_UT_CTL2r_SET BCMI_MADURA_CL93N72_UT_CTL2r_SET
#define CL93N72_UT_CTL2r_GET BCMI_MADURA_CL93N72_UT_CTL2r_GET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_GET BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_GET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_SET BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_SET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_GET BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_GET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_SET BCMI_MADURA_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_SET
#define READ_CL93N72_UT_CTL2r BCMI_MADURA_READ_CL93N72_UT_CTL2r
#define WRITE_CL93N72_UT_CTL2r BCMI_MADURA_WRITE_CL93N72_UT_CTL2r
#define MODIFY_CL93N72_UT_CTL2r BCMI_MADURA_MODIFY_CL93N72_UT_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_CTL3
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd095
 * DEVAD:    1
 * DESC:     cl93n72 Control 3 Register
 * RESETVAL: 0x50 (80)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_TXFIR_MAIN main cursor tap coeeficient value.CAUI-4 chip to chip defaults
 */
#define BCMI_MADURA_CL93N72_UT_CTL3r (0x0001d095 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL3.
 */
typedef union BCMI_MADURA_CL93N72_UT_CTL3r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl3[1];
	uint32_t _cl93n72_ut_ctl3;
} BCMI_MADURA_CL93N72_UT_CTL3r_t;

#define BCMI_MADURA_CL93N72_UT_CTL3r_CLR(r) (r).cl93n72_ut_ctl3[0] = 0
#define BCMI_MADURA_CL93N72_UT_CTL3r_SET(r,d) (r).cl93n72_ut_ctl3[0] = d
#define BCMI_MADURA_CL93N72_UT_CTL3r_GET(r) (r).cl93n72_ut_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_GET(r) (((r).cl93n72_ut_ctl3[0]) & 0x7f)
#define BCMI_MADURA_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_SET(r,f) (r).cl93n72_ut_ctl3[0]=(((r).cl93n72_ut_ctl3[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL3.
 */
#define BCMI_MADURA_READ_CL93N72_UT_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_CTL3r,_r._cl93n72_ut_ctl3)
#define BCMI_MADURA_WRITE_CL93N72_UT_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_CTL3r,_r._cl93n72_ut_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL3r BCMI_MADURA_CL93N72_UT_CTL3r
#define CL93N72_UT_CTL3r_SIZE BCMI_MADURA_CL93N72_UT_CTL3r_SIZE
typedef BCMI_MADURA_CL93N72_UT_CTL3r_t CL93N72_UT_CTL3r_t;
#define CL93N72_UT_CTL3r_CLR BCMI_MADURA_CL93N72_UT_CTL3r_CLR
#define CL93N72_UT_CTL3r_SET BCMI_MADURA_CL93N72_UT_CTL3r_SET
#define CL93N72_UT_CTL3r_GET BCMI_MADURA_CL93N72_UT_CTL3r_GET
#define CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_GET BCMI_MADURA_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_GET
#define CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_SET BCMI_MADURA_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_SET
#define READ_CL93N72_UT_CTL3r BCMI_MADURA_READ_CL93N72_UT_CTL3r
#define WRITE_CL93N72_UT_CTL3r BCMI_MADURA_WRITE_CL93N72_UT_CTL3r
#define MODIFY_CL93N72_UT_CTL3r BCMI_MADURA_MODIFY_CL93N72_UT_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_STS0
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd096
 * DEVAD:    1
 * DESC:     cl93n72 Status 0 Register
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_LOCAL_RX_READY Set to TRUE (1'b1) by the FSM when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     CL93N72_TRAINING_FSM_SIGNAL_DETECT 1 - cl93n72 is in SEND_DATA state0 - cl93n72 is in training state
 *     CL93N72_SM_CURRENT_STATE Training State machine current state0 = ST_INITIALIZE1 = ST_SEND_TRAINING2 = ST_TRAIN_LOCAL3 = ST_TRAIN_REMOTE4 = ST_LINK_READY5 = ST_SEND_DATA6 = ST_TRAINING_FAILURE
 */
#define BCMI_MADURA_CL93N72_UT_STS0r (0x0001d096 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_STS0.
 */
typedef union BCMI_MADURA_CL93N72_UT_STS0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_sts0[1];
	uint32_t _cl93n72_ut_sts0;
} BCMI_MADURA_CL93N72_UT_STS0r_t;

#define BCMI_MADURA_CL93N72_UT_STS0r_CLR(r) (r).cl93n72_ut_sts0[0] = 0
#define BCMI_MADURA_CL93N72_UT_STS0r_SET(r,d) (r).cl93n72_ut_sts0[0] = d
#define BCMI_MADURA_CL93N72_UT_STS0r_GET(r) (r).cl93n72_ut_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_SM_CURRENT_STATEf_GET(r) ((((r).cl93n72_ut_sts0[0]) >> 12) & 0x7)
#define BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_SM_CURRENT_STATEf_SET(r,f) (r).cl93n72_ut_sts0[0]=(((r).cl93n72_ut_sts0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_GET(r) ((((r).cl93n72_ut_sts0[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_SET(r,f) (r).cl93n72_ut_sts0[0]=(((r).cl93n72_ut_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_GET(r) (((r).cl93n72_ut_sts0[0]) & 0x1)
#define BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_SET(r,f) (r).cl93n72_ut_sts0[0]=(((r).cl93n72_ut_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UT_STS0.
 */
#define BCMI_MADURA_READ_CL93N72_UT_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_STS0r,_r._cl93n72_ut_sts0)
#define BCMI_MADURA_WRITE_CL93N72_UT_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_STS0r,_r._cl93n72_ut_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_STS0r BCMI_MADURA_CL93N72_UT_STS0r
#define CL93N72_UT_STS0r_SIZE BCMI_MADURA_CL93N72_UT_STS0r_SIZE
typedef BCMI_MADURA_CL93N72_UT_STS0r_t CL93N72_UT_STS0r_t;
#define CL93N72_UT_STS0r_CLR BCMI_MADURA_CL93N72_UT_STS0r_CLR
#define CL93N72_UT_STS0r_SET BCMI_MADURA_CL93N72_UT_STS0r_SET
#define CL93N72_UT_STS0r_GET BCMI_MADURA_CL93N72_UT_STS0r_GET
#define CL93N72_UT_STS0r_CL93N72_SM_CURRENT_STATEf_GET BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_SM_CURRENT_STATEf_GET
#define CL93N72_UT_STS0r_CL93N72_SM_CURRENT_STATEf_SET BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_SM_CURRENT_STATEf_SET
#define CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_GET BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_GET
#define CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_SET BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_SET
#define CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_GET BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_GET
#define CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_SET BCMI_MADURA_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_SET
#define READ_CL93N72_UT_STS0r BCMI_MADURA_READ_CL93N72_UT_STS0r
#define WRITE_CL93N72_UT_STS0r BCMI_MADURA_WRITE_CL93N72_UT_STS0r
#define MODIFY_CL93N72_UT_STS0r BCMI_MADURA_MODIFY_CL93N72_UT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_UT_CTL4
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd097
 * DEVAD:    1
 * DESC:     cl93n72 Control 4 Register
 * RESETVAL: 0x23f5 (9205)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_PRBS_SEED_VAL prbs seed valueThese bits can be used to specify the cl72/cl93 prbs seed valuesPLEASE NOTE: The default value of these register bits for each lane is unique. The IEEE P802.3bj/D2.1defines the following default seed values for each lane:Lane 0 - 11'h3F5Lane 1 - 11'h513Lane 2 - 11'h5A7Lane 3 - 11'h36F
 *     CL93N72_CL93PRBS_POLY_SEL cl93 mode prbs polynomial selectThese bits are used to select the following prbs polynomials when prbs_mode_sel field is set to 1'b1:2'b00: 1 + x5 + x6 + x10 + x112'b01: 1 + x5 + x6 + x9  + x112'b10: 1 + x4 + x6 + x8  + x112'b11: 1 + x4 + x6 + x7  + x11PLEASE NOTE:The default value of these register bits for each lane is unique. The IEEE P802.3bj/D2.1defines the following default seed values for each lane:Lane 0 - 2'b00Lane 1 - 2'b01Lane 2 - 2'b10Lane 3 - 2'b11
 *     CL93N72_PRBS_MODE_SEL This field is used to select prbs mode0 - cl72 mode. Uses 1 + x9  + x11 prbs polynomial1 - cl93 mode. The prbs polynomial is specified by the  cl93n72_cl93prbs_poly_sel field
 *     CL93N72_PRBS_SEED_SEL These bits used to select the seed for prbs generator during the training sequence:2'b00 - cl72 mode - random seed every frame, cl93 mode - seed specified by the cl93n72_prbs_seed_val field2'b01 - random seed every frame2'b10 - random seed first frame only and then same seed every frame2'b11 - seed specified by the prbs_seed_val field
 */
#define BCMI_MADURA_CL93N72_UT_CTL4r (0x0001d097 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_UT_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL4.
 */
typedef union BCMI_MADURA_CL93N72_UT_CTL4r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl4[1];
	uint32_t _cl93n72_ut_ctl4;
} BCMI_MADURA_CL93N72_UT_CTL4r_t;

#define BCMI_MADURA_CL93N72_UT_CTL4r_CLR(r) (r).cl93n72_ut_ctl4[0] = 0
#define BCMI_MADURA_CL93N72_UT_CTL4r_SET(r,d) (r).cl93n72_ut_ctl4[0] = d
#define BCMI_MADURA_CL93N72_UT_CTL4r_GET(r) (r).cl93n72_ut_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_SELf_GET(r) ((((r).cl93n72_ut_ctl4[0]) >> 14) & 0x3)
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_SELf_SET(r,f) (r).cl93n72_ut_ctl4[0]=(((r).cl93n72_ut_ctl4[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_MODE_SELf_GET(r) ((((r).cl93n72_ut_ctl4[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_MODE_SELf_SET(r,f) (r).cl93n72_ut_ctl4[0]=(((r).cl93n72_ut_ctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_CL93PRBS_POLY_SELf_GET(r) ((((r).cl93n72_ut_ctl4[0]) >> 11) & 0x3)
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_CL93PRBS_POLY_SELf_SET(r,f) (r).cl93n72_ut_ctl4[0]=(((r).cl93n72_ut_ctl4[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_VALf_GET(r) (((r).cl93n72_ut_ctl4[0]) & 0x7ff)
#define BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_VALf_SET(r,f) (r).cl93n72_ut_ctl4[0]=(((r).cl93n72_ut_ctl4[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (0x7ff << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL4.
 */
#define BCMI_MADURA_READ_CL93N72_UT_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_UT_CTL4r,_r._cl93n72_ut_ctl4)
#define BCMI_MADURA_WRITE_CL93N72_UT_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_UT_CTL4r,_r._cl93n72_ut_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL4r BCMI_MADURA_CL93N72_UT_CTL4r
#define CL93N72_UT_CTL4r_SIZE BCMI_MADURA_CL93N72_UT_CTL4r_SIZE
typedef BCMI_MADURA_CL93N72_UT_CTL4r_t CL93N72_UT_CTL4r_t;
#define CL93N72_UT_CTL4r_CLR BCMI_MADURA_CL93N72_UT_CTL4r_CLR
#define CL93N72_UT_CTL4r_SET BCMI_MADURA_CL93N72_UT_CTL4r_SET
#define CL93N72_UT_CTL4r_GET BCMI_MADURA_CL93N72_UT_CTL4r_GET
#define CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_SELf_GET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_SELf_GET
#define CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_SELf_SET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_SELf_SET
#define CL93N72_UT_CTL4r_CL93N72_PRBS_MODE_SELf_GET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_MODE_SELf_GET
#define CL93N72_UT_CTL4r_CL93N72_PRBS_MODE_SELf_SET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_MODE_SELf_SET
#define CL93N72_UT_CTL4r_CL93N72_CL93PRBS_POLY_SELf_GET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_CL93PRBS_POLY_SELf_GET
#define CL93N72_UT_CTL4r_CL93N72_CL93PRBS_POLY_SELf_SET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_CL93PRBS_POLY_SELf_SET
#define CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_VALf_GET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_VALf_GET
#define CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_VALf_SET BCMI_MADURA_CL93N72_UT_CTL4r_CL93N72_PRBS_SEED_VALf_SET
#define READ_CL93N72_UT_CTL4r BCMI_MADURA_READ_CL93N72_UT_CTL4r
#define WRITE_CL93N72_UT_CTL4r BCMI_MADURA_WRITE_CL93N72_UT_CTL4r
#define MODIFY_CL93N72_UT_CTL4r BCMI_MADURA_MODIFY_CL93N72_UT_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_UT_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_CTL0
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a0
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 0
 * RESETVAL: 0x7000 (28672)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_EN         Transmit Phase Interpolator Enable. If 1'b0 will gate off the TX PI clock and also freeze the PI code.
 *     TX_PI_JITTER_FILTER_EN This enables the IIR filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) .
 *     TX_PI_EXT_CTRL_EN Enable for the phase error (inc/dec) from the remote loopback ( or HS Phase FIFO in case of Repeater )
 *     TX_PI_FREQ_OVERRIDE_EN Enable for the frequency override mode. It should be 1'b1 for fixed frequency and jitter generation modes.
 *     TX_PI_SJ_GEN_EN  Sinusoidal Jitter (SJ) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_SSC_GEN_EN Spread Spectrum Jitter (SSC) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_JIT_SSC_FREQ_MODE SSJ Mode Select:1'b1 : 10G SSC mode and 1'b0: 6G SSC mode
 *     TX_PI_SECOND_ORDER_LOOP_EN 2nd Order Loop Enable. 1'b1 will enable the 2nd order loop of the IIR filter. 1'b0 will reset the all the flops related to the 2nd order loop.This bit is only valid when tx_pi_jitter_filter_en is set to 1'b1.
 *     TX_PI_FIRST_ORDER_BWSEL_INTEG First order bandwidth control.2'd0 -  80 KHz2'd1 - 160 KHz2'd2 - 321 KHz2'd3 - 642 KHz
 *     TX_PI_SECOND_ORDER_BWSEL_INTEG Second order bandwidth control. Valid values are 0, 1, 2 and 3.
 *     TX_PI_EXT_PHASE_BWSEL_INTEG External Phase bandwidth control. Valid values are 0 to 7.
 */
#define BCMI_MADURA_TX_PI_CTL0r (0x0001d0a0 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL0.
 */
typedef union BCMI_MADURA_TX_PI_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl0[1];
	uint32_t _tx_pi_ctl0;
} BCMI_MADURA_TX_PI_CTL0r_t;

#define BCMI_MADURA_TX_PI_CTL0r_CLR(r) (r).tx_pi_ctl0[0] = 0
#define BCMI_MADURA_TX_PI_CTL0r_SET(r,d) (r).tx_pi_ctl0[0] = d
#define BCMI_MADURA_TX_PI_CTL0r_GET(r) (r).tx_pi_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 12) & 0x7)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 10) & 0x3)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 8) & 0x3)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 7) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET(r) ((((r).tx_pi_ctl0[0]) >> 6) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 5) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 4) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 3) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_ENf_GET(r) (((r).tx_pi_ctl0[0]) & 0x1)
#define BCMI_MADURA_TX_PI_CTL0r_TX_PI_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL0.
 */
#define BCMI_MADURA_READ_TX_PI_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_CTL0r,_r._tx_pi_ctl0)
#define BCMI_MADURA_WRITE_TX_PI_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_CTL0r,_r._tx_pi_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL0r BCMI_MADURA_TX_PI_CTL0r
#define TX_PI_CTL0r_SIZE BCMI_MADURA_TX_PI_CTL0r_SIZE
typedef BCMI_MADURA_TX_PI_CTL0r_t TX_PI_CTL0r_t;
#define TX_PI_CTL0r_CLR BCMI_MADURA_TX_PI_CTL0r_CLR
#define TX_PI_CTL0r_SET BCMI_MADURA_TX_PI_CTL0r_SET
#define TX_PI_CTL0r_GET BCMI_MADURA_TX_PI_CTL0r_GET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET
#define TX_PI_CTL0r_TX_PI_ENf_GET BCMI_MADURA_TX_PI_CTL0r_TX_PI_ENf_GET
#define TX_PI_CTL0r_TX_PI_ENf_SET BCMI_MADURA_TX_PI_CTL0r_TX_PI_ENf_SET
#define READ_TX_PI_CTL0r BCMI_MADURA_READ_TX_PI_CTL0r
#define WRITE_TX_PI_CTL0r BCMI_MADURA_WRITE_TX_PI_CTL0r
#define MODIFY_TX_PI_CTL0r BCMI_MADURA_MODIFY_TX_PI_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_CTL1
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a1
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FREQ_OVERRIDE_VAL Fixed Frequncy Override Value: Valid values are -8192 to +8192. Register tx_pi_freq_override_en should be 1'b1 to enable the Fixed Frequncy Override mode.+8192 (-8192) value in this register will result into 1 TX PI phase inc (dec) every 20T tclk. This results into (1/64 * 1/20)UI phase inc (or dec) per UI = 781.25(-781.25) ppm. So 1 ppm = 10.486 value.If tx_pi_jit_gen_en is set to 1'b1 then this register provides initilization value for Jitter Gen Integ Reg. Valid values in jitter generation mode are -8192 to +8191
 */
#define BCMI_MADURA_TX_PI_CTL1r (0x0001d0a1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL1.
 */
typedef union BCMI_MADURA_TX_PI_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl1[1];
	uint32_t _tx_pi_ctl1;
} BCMI_MADURA_TX_PI_CTL1r_t;

#define BCMI_MADURA_TX_PI_CTL1r_CLR(r) (r).tx_pi_ctl1[0] = 0
#define BCMI_MADURA_TX_PI_CTL1r_SET(r,d) (r).tx_pi_ctl1[0] = d
#define BCMI_MADURA_TX_PI_CTL1r_GET(r) (r).tx_pi_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET(r) (((r).tx_pi_ctl1[0]) & 0x7fff)
#define BCMI_MADURA_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET(r,f) (r).tx_pi_ctl1[0]=(((r).tx_pi_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_CTL1.
 */
#define BCMI_MADURA_READ_TX_PI_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_CTL1r,_r._tx_pi_ctl1)
#define BCMI_MADURA_WRITE_TX_PI_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_CTL1r,_r._tx_pi_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL1r BCMI_MADURA_TX_PI_CTL1r
#define TX_PI_CTL1r_SIZE BCMI_MADURA_TX_PI_CTL1r_SIZE
typedef BCMI_MADURA_TX_PI_CTL1r_t TX_PI_CTL1r_t;
#define TX_PI_CTL1r_CLR BCMI_MADURA_TX_PI_CTL1r_CLR
#define TX_PI_CTL1r_SET BCMI_MADURA_TX_PI_CTL1r_SET
#define TX_PI_CTL1r_GET BCMI_MADURA_TX_PI_CTL1r_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET BCMI_MADURA_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET BCMI_MADURA_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET
#define READ_TX_PI_CTL1r BCMI_MADURA_READ_TX_PI_CTL1r
#define WRITE_TX_PI_CTL1r BCMI_MADURA_WRITE_TX_PI_CTL1r
#define MODIFY_TX_PI_CTL1r BCMI_MADURA_MODIFY_TX_PI_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_CTL2
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a2
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_JIT_FREQ_IDX Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator parameters.In SJ  mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details.In SSC mode: It provides Nssc.                                               Refer Jitter Generator spec for the table details.
 *     TX_PI_JIT_AMP    Jitter Generator Amplification Factor. Valid values are 0 to 63.
 */
#define BCMI_MADURA_TX_PI_CTL2r (0x0001d0a2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL2.
 */
typedef union BCMI_MADURA_TX_PI_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl2[1];
	uint32_t _tx_pi_ctl2;
} BCMI_MADURA_TX_PI_CTL2r_t;

#define BCMI_MADURA_TX_PI_CTL2r_CLR(r) (r).tx_pi_ctl2[0] = 0
#define BCMI_MADURA_TX_PI_CTL2r_SET(r,d) (r).tx_pi_ctl2[0] = d
#define BCMI_MADURA_TX_PI_CTL2r_GET(r) (r).tx_pi_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET(r) ((((r).tx_pi_ctl2[0]) >> 8) & 0x3f)
#define BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET(r) (((r).tx_pi_ctl2[0]) & 0x3f)
#define BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_CTL2.
 */
#define BCMI_MADURA_READ_TX_PI_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_CTL2r,_r._tx_pi_ctl2)
#define BCMI_MADURA_WRITE_TX_PI_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_CTL2r,_r._tx_pi_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL2r BCMI_MADURA_TX_PI_CTL2r
#define TX_PI_CTL2r_SIZE BCMI_MADURA_TX_PI_CTL2r_SIZE
typedef BCMI_MADURA_TX_PI_CTL2r_t TX_PI_CTL2r_t;
#define TX_PI_CTL2r_CLR BCMI_MADURA_TX_PI_CTL2r_CLR
#define TX_PI_CTL2r_SET BCMI_MADURA_TX_PI_CTL2r_SET
#define TX_PI_CTL2r_GET BCMI_MADURA_TX_PI_CTL2r_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_GET BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_SET BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET BCMI_MADURA_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET
#define READ_TX_PI_CTL2r BCMI_MADURA_READ_TX_PI_CTL2r
#define WRITE_TX_PI_CTL2r BCMI_MADURA_WRITE_TX_PI_CTL2r
#define MODIFY_TX_PI_CTL2r BCMI_MADURA_MODIFY_TX_PI_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_CTL3
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a3
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 3
 * RESETVAL: 0x100 (256)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_PHASE_OVERRIDE Manual Phase Override Mode. When 1'b1 the PI phase can be moved manually using registers. All the filter logic is bypassed during manual mode.
 *     TX_PI_PHASE_STROBE Manual Phase strobe. When set to 1'b1 then it will generate 1 phase step (inc/dec depending on tx_pi_phase_step_dir) or multiple phase steps if tx_pi_phase_step_osr is 1'b1.If tx_pi_phase_override is 1'b0 then manual phase steps will be added with the output of the IIR filter phase steps during the time when there is no phase steps from the IIR filter.Self Clearing Register. Must be polled for 1'b0 before writing it to 1'b1 again for correct Manual Phase Step Shift.
 *     TX_PI_PHASE_STEP_DIR Manual Phase Step direction.1'b0: Increment1'b1: Decrement
 *     TX_PI_PHASE_INVERT 1'b1 : will invert (i.e. swap) the final inc and dec before the PI code shifter logic.
 *     TX_PI_PHASE_STEP_NUM Defines the number of phase steps movement for every manual strobe. Valid values are 1 to 15.
 */
#define BCMI_MADURA_TX_PI_CTL3r (0x0001d0a3 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL3.
 */
typedef union BCMI_MADURA_TX_PI_CTL3r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl3[1];
	uint32_t _tx_pi_ctl3;
} BCMI_MADURA_TX_PI_CTL3r_t;

#define BCMI_MADURA_TX_PI_CTL3r_CLR(r) (r).tx_pi_ctl3[0] = 0
#define BCMI_MADURA_TX_PI_CTL3r_SET(r,d) (r).tx_pi_ctl3[0] = d
#define BCMI_MADURA_TX_PI_CTL3r_GET(r) (r).tx_pi_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET(r) ((((r).tx_pi_ctl3[0]) >> 8) & 0xf)
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET(r) ((((r).tx_pi_ctl3[0]) >> 4) & 0x1)
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET(r) ((((r).tx_pi_ctl3[0]) >> 2) & 0x1)
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET(r) ((((r).tx_pi_ctl3[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET(r) (((r).tx_pi_ctl3[0]) & 0x1)
#define BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET(r,f) (r).tx_pi_ctl3[0]=(((r).tx_pi_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL3.
 */
#define BCMI_MADURA_READ_TX_PI_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_CTL3r,_r._tx_pi_ctl3)
#define BCMI_MADURA_WRITE_TX_PI_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_CTL3r,_r._tx_pi_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL3r BCMI_MADURA_TX_PI_CTL3r
#define TX_PI_CTL3r_SIZE BCMI_MADURA_TX_PI_CTL3r_SIZE
typedef BCMI_MADURA_TX_PI_CTL3r_t TX_PI_CTL3r_t;
#define TX_PI_CTL3r_CLR BCMI_MADURA_TX_PI_CTL3r_CLR
#define TX_PI_CTL3r_SET BCMI_MADURA_TX_PI_CTL3r_SET
#define TX_PI_CTL3r_GET BCMI_MADURA_TX_PI_CTL3r_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_NUMf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_INVERTf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STEP_DIRf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_STROBEf_SET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_GET
#define TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET BCMI_MADURA_TX_PI_CTL3r_TX_PI_PHASE_OVERRIDEf_SET
#define READ_TX_PI_CTL3r BCMI_MADURA_READ_TX_PI_CTL3r
#define WRITE_TX_PI_CTL3r BCMI_MADURA_WRITE_TX_PI_CTL3r
#define MODIFY_TX_PI_CTL3r BCMI_MADURA_MODIFY_TX_PI_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_CTL4
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a4
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 4
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FRZ_FRC    IIR filter freeze control by force. 1'b1 will force the freeze value indicated by tx_pi_frz_frc_val otherwise Normal IIR operation.
 *     TX_PI_FRZ_FRC_VAL Force value for the IIR filter freeze. 1'b1 is freeze, 1'b0 is normal IIR operation.
 *     TX_PI_FRZ_MODE   Freeze Mode. 1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm from PLL/VCO clock.
 *     TX_PI_RESET_CODE_DBG Debug register.Resets the TX PI code going to AFE. This is just a debug register and is not recommended to be used during normal operation of TX PI.
 */
#define BCMI_MADURA_TX_PI_CTL4r (0x0001d0a4 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL4.
 */
typedef union BCMI_MADURA_TX_PI_CTL4r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl4[1];
	uint32_t _tx_pi_ctl4;
} BCMI_MADURA_TX_PI_CTL4r_t;

#define BCMI_MADURA_TX_PI_CTL4r_CLR(r) (r).tx_pi_ctl4[0] = 0
#define BCMI_MADURA_TX_PI_CTL4r_SET(r,d) (r).tx_pi_ctl4[0] = d
#define BCMI_MADURA_TX_PI_CTL4r_GET(r) (r).tx_pi_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET(r) ((((r).tx_pi_ctl4[0]) >> 3) & 0x1)
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET(r) ((((r).tx_pi_ctl4[0]) >> 2) & 0x1)
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET(r) ((((r).tx_pi_ctl4[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET(r) (((r).tx_pi_ctl4[0]) & 0x1)
#define BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET(r,f) (r).tx_pi_ctl4[0]=(((r).tx_pi_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL4.
 */
#define BCMI_MADURA_READ_TX_PI_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_CTL4r,_r._tx_pi_ctl4)
#define BCMI_MADURA_WRITE_TX_PI_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_CTL4r,_r._tx_pi_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL4r BCMI_MADURA_TX_PI_CTL4r
#define TX_PI_CTL4r_SIZE BCMI_MADURA_TX_PI_CTL4r_SIZE
typedef BCMI_MADURA_TX_PI_CTL4r_t TX_PI_CTL4r_t;
#define TX_PI_CTL4r_CLR BCMI_MADURA_TX_PI_CTL4r_CLR
#define TX_PI_CTL4r_SET BCMI_MADURA_TX_PI_CTL4r_SET
#define TX_PI_CTL4r_GET BCMI_MADURA_TX_PI_CTL4r_GET
#define TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET BCMI_MADURA_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_GET
#define TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET BCMI_MADURA_TX_PI_CTL4r_TX_PI_RESET_CODE_DBGf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_MODEf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_MODEf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRC_VALf_SET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRCf_GET
#define TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET BCMI_MADURA_TX_PI_CTL4r_TX_PI_FRZ_FRCf_SET
#define READ_TX_PI_CTL4r BCMI_MADURA_READ_TX_PI_CTL4r
#define WRITE_TX_PI_CTL4r BCMI_MADURA_WRITE_TX_PI_CTL4r
#define MODIFY_TX_PI_CTL4r BCMI_MADURA_MODIFY_TX_PI_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_CTL5
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a5
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 5
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR_INVERT 1'b1: Inverts the hs_fifo_phserr[4:0] to invert the meaning of inc/dec from hs_fifo_phserr[4:0]. When this bit is 1'b0, 1'b1 is increment and 1'b0 is decrement.
 *     TX_PI_REPEATER_MODE_EN Selects the source of the Loop Timing CDR and Phase Detector inc/dec information.1'b1: Select external CDR and hs_fifo_phserr[4:0] from the high speed Phase FIFO PD inside AFE for ultra-low latency path.1'b0: selects the internal CDR and inc/dec from the Remote Loopback Phase Detector.
 *     TX_PI_EXT_PD_SEL Selects the source of the Phase Detector inc/dec information.1'b1: Select external PD path irrespective of rg_tx_pi_repeater_mode_en1'b0: Select PD path based on rg_tx_pi_repeater_mode_en
 *     AFE_TX_FIFO_RESETB 1'b0: will assert the reset pin tx_fifo_resetb to 1'b0.1'b1: Once this bit is written to 1'b1 then phase error (bit 4) from FIFO is looked for 2 transitions and then reset is de-asserted to the Phase FIFO.
 *     AFE_TX_FIFO_RESETB_FRC 1'b0: Normal mode where reset pin tx_fifo_resetb is controlled as per the description of the register afe_tx_fifo_resetb.1'b1: force the reset pin tx_fifo_resetb to value indicated in the register afe_tx_fifo_resetb.
 *     TX_PI_PD_BYPASS_FLT 1'b1 will enable filter bypass for inc/dec indication from all sources to get a quicker phase locking time.
 *     TX_PI_PD_BYPASS_VCO 1'b1 will enable filter and vco bypass for inc/dec indication from all sources to get a quicker phase locking time.
 */
#define BCMI_MADURA_TX_PI_CTL5r (0x0001d0a5 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL5.
 */
typedef union BCMI_MADURA_TX_PI_CTL5r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl5[1];
	uint32_t _tx_pi_ctl5;
} BCMI_MADURA_TX_PI_CTL5r_t;

#define BCMI_MADURA_TX_PI_CTL5r_CLR(r) (r).tx_pi_ctl5[0] = 0
#define BCMI_MADURA_TX_PI_CTL5r_SET(r,d) (r).tx_pi_ctl5[0] = d
#define BCMI_MADURA_TX_PI_CTL5r_GET(r) (r).tx_pi_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET(r) ((((r).tx_pi_ctl5[0]) >> 11) & 0x1)
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 10) & 0x1)
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET(r) ((((r).tx_pi_ctl5[0]) >> 9) & 0x1)
#define BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_ctl5[0]) >> 8) & 0x1)
#define BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 3) & 0x1)
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET(r) ((((r).tx_pi_ctl5[0]) >> 2) & 0x1)
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access TX_PI_CTL5.
 */
#define BCMI_MADURA_READ_TX_PI_CTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_CTL5r,_r._tx_pi_ctl5)
#define BCMI_MADURA_WRITE_TX_PI_CTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_CTL5r,_r._tx_pi_ctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL5r BCMI_MADURA_TX_PI_CTL5r
#define TX_PI_CTL5r_SIZE BCMI_MADURA_TX_PI_CTL5r_SIZE
typedef BCMI_MADURA_TX_PI_CTL5r_t TX_PI_CTL5r_t;
#define TX_PI_CTL5r_CLR BCMI_MADURA_TX_PI_CTL5r_CLR
#define TX_PI_CTL5r_SET BCMI_MADURA_TX_PI_CTL5r_SET
#define TX_PI_CTL5r_GET BCMI_MADURA_TX_PI_CTL5r_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET BCMI_MADURA_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET BCMI_MADURA_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET BCMI_MADURA_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET BCMI_MADURA_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET BCMI_MADURA_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET BCMI_MADURA_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET BCMI_MADURA_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET BCMI_MADURA_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET
#define READ_TX_PI_CTL5r BCMI_MADURA_READ_TX_PI_CTL5r
#define WRITE_TX_PI_CTL5r BCMI_MADURA_WRITE_TX_PI_CTL5r
#define MODIFY_TX_PI_CTL5r BCMI_MADURA_MODIFY_TX_PI_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_STS0
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a8
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_CNTR TX PI Phase Counter. Signed Value.
 */
#define BCMI_MADURA_TX_PI_STS0r (0x0001d0a8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS0.
 */
typedef union BCMI_MADURA_TX_PI_STS0r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts0[1];
	uint32_t _tx_pi_sts0;
} BCMI_MADURA_TX_PI_STS0r_t;

#define BCMI_MADURA_TX_PI_STS0r_CLR(r) (r).tx_pi_sts0[0] = 0
#define BCMI_MADURA_TX_PI_STS0r_SET(r,d) (r).tx_pi_sts0[0] = d
#define BCMI_MADURA_TX_PI_STS0r_GET(r) (r).tx_pi_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET(r) (((r).tx_pi_sts0[0]) & 0x7f)
#define BCMI_MADURA_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET(r,f) (r).tx_pi_sts0[0]=(((r).tx_pi_sts0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TX_PI_STS0.
 */
#define BCMI_MADURA_READ_TX_PI_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_STS0r,_r._tx_pi_sts0)
#define BCMI_MADURA_WRITE_TX_PI_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_STS0r,_r._tx_pi_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS0r BCMI_MADURA_TX_PI_STS0r
#define TX_PI_STS0r_SIZE BCMI_MADURA_TX_PI_STS0r_SIZE
typedef BCMI_MADURA_TX_PI_STS0r_t TX_PI_STS0r_t;
#define TX_PI_STS0r_CLR BCMI_MADURA_TX_PI_STS0r_CLR
#define TX_PI_STS0r_SET BCMI_MADURA_TX_PI_STS0r_SET
#define TX_PI_STS0r_GET BCMI_MADURA_TX_PI_STS0r_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET BCMI_MADURA_TX_PI_STS0r_TX_PI_PHASE_CNTRf_GET
#define TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET BCMI_MADURA_TX_PI_STS0r_TX_PI_PHASE_CNTRf_SET
#define READ_TX_PI_STS0r BCMI_MADURA_READ_TX_PI_STS0r
#define WRITE_TX_PI_STS0r BCMI_MADURA_WRITE_TX_PI_STS0r
#define MODIFY_TX_PI_STS0r BCMI_MADURA_MODIFY_TX_PI_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_STS1
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0a9
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG1_REG TX PI integ1 register. Signed Value.This field is meant for internal debug only.
 */
#define BCMI_MADURA_TX_PI_STS1r (0x0001d0a9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS1.
 */
typedef union BCMI_MADURA_TX_PI_STS1r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts1[1];
	uint32_t _tx_pi_sts1;
} BCMI_MADURA_TX_PI_STS1r_t;

#define BCMI_MADURA_TX_PI_STS1r_CLR(r) (r).tx_pi_sts1[0] = 0
#define BCMI_MADURA_TX_PI_STS1r_SET(r,d) (r).tx_pi_sts1[0] = d
#define BCMI_MADURA_TX_PI_STS1r_GET(r) (r).tx_pi_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET(r) (((r).tx_pi_sts1[0]) & 0x3fff)
#define BCMI_MADURA_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET(r,f) (r).tx_pi_sts1[0]=(((r).tx_pi_sts1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_PI_STS1.
 */
#define BCMI_MADURA_READ_TX_PI_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_STS1r,_r._tx_pi_sts1)
#define BCMI_MADURA_WRITE_TX_PI_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_STS1r,_r._tx_pi_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS1r BCMI_MADURA_TX_PI_STS1r
#define TX_PI_STS1r_SIZE BCMI_MADURA_TX_PI_STS1r_SIZE
typedef BCMI_MADURA_TX_PI_STS1r_t TX_PI_STS1r_t;
#define TX_PI_STS1r_CLR BCMI_MADURA_TX_PI_STS1r_CLR
#define TX_PI_STS1r_SET BCMI_MADURA_TX_PI_STS1r_SET
#define TX_PI_STS1r_GET BCMI_MADURA_TX_PI_STS1r_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_GET BCMI_MADURA_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_SET BCMI_MADURA_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET
#define READ_TX_PI_STS1r BCMI_MADURA_READ_TX_PI_STS1r
#define WRITE_TX_PI_STS1r BCMI_MADURA_WRITE_TX_PI_STS1r
#define MODIFY_TX_PI_STS1r BCMI_MADURA_MODIFY_TX_PI_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_STS2
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0aa
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG2_REG TX PI integ2 register. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock.+8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock.Divide this register value by 10.485 to get the tclk ppm.
 */
#define BCMI_MADURA_TX_PI_STS2r (0x0001d0aa | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS2.
 */
typedef union BCMI_MADURA_TX_PI_STS2r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts2[1];
	uint32_t _tx_pi_sts2;
} BCMI_MADURA_TX_PI_STS2r_t;

#define BCMI_MADURA_TX_PI_STS2r_CLR(r) (r).tx_pi_sts2[0] = 0
#define BCMI_MADURA_TX_PI_STS2r_SET(r,d) (r).tx_pi_sts2[0] = d
#define BCMI_MADURA_TX_PI_STS2r_GET(r) (r).tx_pi_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET(r) (((r).tx_pi_sts2[0]) & 0x7fff)
#define BCMI_MADURA_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET(r,f) (r).tx_pi_sts2[0]=(((r).tx_pi_sts2[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_STS2.
 */
#define BCMI_MADURA_READ_TX_PI_STS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_STS2r,_r._tx_pi_sts2)
#define BCMI_MADURA_WRITE_TX_PI_STS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_STS2r,_r._tx_pi_sts2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS2r BCMI_MADURA_TX_PI_STS2r
#define TX_PI_STS2r_SIZE BCMI_MADURA_TX_PI_STS2r_SIZE
typedef BCMI_MADURA_TX_PI_STS2r_t TX_PI_STS2r_t;
#define TX_PI_STS2r_CLR BCMI_MADURA_TX_PI_STS2r_CLR
#define TX_PI_STS2r_SET BCMI_MADURA_TX_PI_STS2r_SET
#define TX_PI_STS2r_GET BCMI_MADURA_TX_PI_STS2r_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_GET BCMI_MADURA_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_SET BCMI_MADURA_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET
#define READ_TX_PI_STS2r BCMI_MADURA_READ_TX_PI_STS2r
#define WRITE_TX_PI_STS2r BCMI_MADURA_WRITE_TX_PI_STS2r
#define MODIFY_TX_PI_STS2r BCMI_MADURA_MODIFY_TX_PI_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_STS3
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0ab
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_ERR  TX PI Phase Error. Signed Value. Valid values are -8 to +8.
 */
#define BCMI_MADURA_TX_PI_STS3r (0x0001d0ab | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS3.
 */
typedef union BCMI_MADURA_TX_PI_STS3r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts3[1];
	uint32_t _tx_pi_sts3;
} BCMI_MADURA_TX_PI_STS3r_t;

#define BCMI_MADURA_TX_PI_STS3r_CLR(r) (r).tx_pi_sts3[0] = 0
#define BCMI_MADURA_TX_PI_STS3r_SET(r,d) (r).tx_pi_sts3[0] = d
#define BCMI_MADURA_TX_PI_STS3r_GET(r) (r).tx_pi_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET(r) (((r).tx_pi_sts3[0]) & 0x3f)
#define BCMI_MADURA_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET(r,f) (r).tx_pi_sts3[0]=(((r).tx_pi_sts3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_STS3.
 */
#define BCMI_MADURA_READ_TX_PI_STS3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_STS3r,_r._tx_pi_sts3)
#define BCMI_MADURA_WRITE_TX_PI_STS3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_STS3r,_r._tx_pi_sts3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS3r BCMI_MADURA_TX_PI_STS3r
#define TX_PI_STS3r_SIZE BCMI_MADURA_TX_PI_STS3r_SIZE
typedef BCMI_MADURA_TX_PI_STS3r_t TX_PI_STS3r_t;
#define TX_PI_STS3r_CLR BCMI_MADURA_TX_PI_STS3r_CLR
#define TX_PI_STS3r_SET BCMI_MADURA_TX_PI_STS3r_SET
#define TX_PI_STS3r_GET BCMI_MADURA_TX_PI_STS3r_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_GET BCMI_MADURA_TX_PI_STS3r_TX_PI_PHASE_ERRf_GET
#define TX_PI_STS3r_TX_PI_PHASE_ERRf_SET BCMI_MADURA_TX_PI_STS3r_TX_PI_PHASE_ERRf_SET
#define READ_TX_PI_STS3r BCMI_MADURA_READ_TX_PI_STS3r
#define WRITE_TX_PI_STS3r BCMI_MADURA_WRITE_TX_PI_STS3r
#define MODIFY_TX_PI_STS3r BCMI_MADURA_MODIFY_TX_PI_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_STS4
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0ac
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR Bit 4 of hs_fifo_pherr.
 *     ST_AFE_TX_FIFO_RESETB Status of the final afe_tx_fifo_resetb signal connected to the AFE pin.
 */
#define BCMI_MADURA_TX_PI_STS4r (0x0001d0ac | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS4.
 */
typedef union BCMI_MADURA_TX_PI_STS4r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts4[1];
	uint32_t _tx_pi_sts4;
} BCMI_MADURA_TX_PI_STS4r_t;

#define BCMI_MADURA_TX_PI_STS4r_CLR(r) (r).tx_pi_sts4[0] = 0
#define BCMI_MADURA_TX_PI_STS4r_SET(r,d) (r).tx_pi_sts4[0] = d
#define BCMI_MADURA_TX_PI_STS4r_GET(r) (r).tx_pi_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_sts4[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET(r) (((r).tx_pi_sts4[0]) & 0x1)
#define BCMI_MADURA_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_STS4.
 */
#define BCMI_MADURA_READ_TX_PI_STS4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_STS4r,_r._tx_pi_sts4)
#define BCMI_MADURA_WRITE_TX_PI_STS4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_STS4r,_r._tx_pi_sts4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS4r BCMI_MADURA_TX_PI_STS4r
#define TX_PI_STS4r_SIZE BCMI_MADURA_TX_PI_STS4r_SIZE
typedef BCMI_MADURA_TX_PI_STS4r_t TX_PI_STS4r_t;
#define TX_PI_STS4r_CLR BCMI_MADURA_TX_PI_STS4r_CLR
#define TX_PI_STS4r_SET BCMI_MADURA_TX_PI_STS4r_SET
#define TX_PI_STS4r_GET BCMI_MADURA_TX_PI_STS4r_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET BCMI_MADURA_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET BCMI_MADURA_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET BCMI_MADURA_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET BCMI_MADURA_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET
#define READ_TX_PI_STS4r BCMI_MADURA_READ_TX_PI_STS4r
#define WRITE_TX_PI_STS4r BCMI_MADURA_WRITE_TX_PI_STS4r
#define MODIFY_TX_PI_STS4r BCMI_MADURA_MODIFY_TX_PI_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_PI_TX_FIFO_OVFB_STS
 * BLOCKS:   TX_PI_MADURA
 * REGADDR:  0xd0ad
 * DEVAD:    1
 * DESC:     TX FIFO Overflow Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_FIFO_OVFB     Indiactes live status of the tx_fifo_ovfb signal from AFE/High Speed Phase FIFO.
 *     TX_FIFO_OVFB_FALL_EDGE_LH lathc high indication for 1 -> 0 transition on tx_fifo_ovfb signal from AFE/High Speed Phase FIFO. This is clear on read status.
 */
#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr (0x0001d0ad | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_TX_FIFO_OVFB_STS.
 */
typedef union BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_s {
	uint32_t v[1];
	uint32_t tx_pi_tx_fifo_ovfb_sts[1];
	uint32_t _tx_pi_tx_fifo_ovfb_sts;
} BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_t;

#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_CLR(r) (r).tx_pi_tx_fifo_ovfb_sts[0] = 0
#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_SET(r,d) (r).tx_pi_tx_fifo_ovfb_sts[0] = d
#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_GET(r) (r).tx_pi_tx_fifo_ovfb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET(r) ((((r).tx_pi_tx_fifo_ovfb_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET(r,f) (r).tx_pi_tx_fifo_ovfb_sts[0]=(((r).tx_pi_tx_fifo_ovfb_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET(r) (((r).tx_pi_tx_fifo_ovfb_sts[0]) & 0x1)
#define BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET(r,f) (r).tx_pi_tx_fifo_ovfb_sts[0]=(((r).tx_pi_tx_fifo_ovfb_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_TX_FIFO_OVFB_STS.
 */
#define BCMI_MADURA_READ_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr,_r._tx_pi_tx_fifo_ovfb_sts)
#define BCMI_MADURA_WRITE_TX_PI_TX_FIFO_OVFB_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr,_r._tx_pi_tx_fifo_ovfb_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_TX_FIFO_OVFB_STSr BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr
#define TX_PI_TX_FIFO_OVFB_STSr_SIZE BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_SIZE
typedef BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_t TX_PI_TX_FIFO_OVFB_STSr_t;
#define TX_PI_TX_FIFO_OVFB_STSr_CLR BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_CLR
#define TX_PI_TX_FIFO_OVFB_STSr_SET BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_SET
#define TX_PI_TX_FIFO_OVFB_STSr_GET BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFB_FALL_EDGE_LHf_SET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_GET
#define TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr_TX_FIFO_OVFBf_SET
#define READ_TX_PI_TX_FIFO_OVFB_STSr BCMI_MADURA_READ_TX_PI_TX_FIFO_OVFB_STSr
#define WRITE_TX_PI_TX_FIFO_OVFB_STSr BCMI_MADURA_WRITE_TX_PI_TX_FIFO_OVFB_STSr
#define MODIFY_TX_PI_TX_FIFO_OVFB_STSr BCMI_MADURA_MODIFY_TX_PI_TX_FIFO_OVFB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_PI_TX_FIFO_OVFB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RXTX_LN_S_RSTB_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd0be
 * DEVAD:    1
 * DESC:     LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_S_RSTB        Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 */
#define BCMI_MADURA_RXTX_LN_S_RSTB_CTLr (0x0001d0be | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTX_LN_S_RSTB_CTL.
 */
typedef union BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rxtx_ln_s_rstb_ctl[1];
	uint32_t _rxtx_ln_s_rstb_ctl;
} BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_t;

#define BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_CLR(r) (r).rxtx_ln_s_rstb_ctl[0] = 0
#define BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_SET(r,d) (r).rxtx_ln_s_rstb_ctl[0] = d
#define BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_GET(r) (r).rxtx_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_LN_S_RSTBf_GET(r) (((r).rxtx_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_LN_S_RSTBf_SET(r,f) (r).rxtx_ln_s_rstb_ctl[0]=(((r).rxtx_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTX_LN_S_RSTB_CTL.
 */
#define BCMI_MADURA_READ_RXTX_LN_S_RSTB_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RXTX_LN_S_RSTB_CTLr,_r._rxtx_ln_s_rstb_ctl)
#define BCMI_MADURA_WRITE_RXTX_LN_S_RSTB_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RXTX_LN_S_RSTB_CTLr,_r._rxtx_ln_s_rstb_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTX_LN_S_RSTB_CTLr BCMI_MADURA_RXTX_LN_S_RSTB_CTLr
#define RXTX_LN_S_RSTB_CTLr_SIZE BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_SIZE
typedef BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_t RXTX_LN_S_RSTB_CTLr_t;
#define RXTX_LN_S_RSTB_CTLr_CLR BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_CLR
#define RXTX_LN_S_RSTB_CTLr_SET BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_SET
#define RXTX_LN_S_RSTB_CTLr_GET BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_GET
#define RXTX_LN_S_RSTB_CTLr_LN_S_RSTBf_GET BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_LN_S_RSTBf_GET
#define RXTX_LN_S_RSTB_CTLr_LN_S_RSTBf_SET BCMI_MADURA_RXTX_LN_S_RSTB_CTLr_LN_S_RSTBf_SET
#define READ_RXTX_LN_S_RSTB_CTLr BCMI_MADURA_READ_RXTX_LN_S_RSTB_CTLr
#define WRITE_RXTX_LN_S_RSTB_CTLr BCMI_MADURA_WRITE_RXTX_LN_S_RSTB_CTLr
#define MODIFY_RXTX_LN_S_RSTB_CTLr BCMI_MADURA_MODIFY_RXTX_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RXTX_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL0
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c0
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_0
 * RESETVAL: 0x10 (16)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_MASTER_DIODES_IBIAS master diodes ibias (max, mode, min) amsbus ctrl_out  2:0DFT_MUX
 *     AMS_RX_SIGDET_THRESHOLD NA. Please use afe_sigdet_thresh from sigdet module. amsbus ctrl_out  5:3
 *     AMS_RX_SIGDET_PWRDN default=0 for enable signal detector amsbus ctrl_out  6:6DFT_MUX
 *     AMS_RX_SIGDET_BYPASS force sigdet output = 1 amsbus ctrl_out  7:7
 *     AMS_RX_TPORT_EN  output rx_rclk20 to PLL test port amsbus ctrl_out  8:8DFT_MUX
 *     AMS_RX_VGA_10G_BW enables lower freq EQ peaking used in 10G mode amsbus ctrl_out  9:9
 *     AMS_RX_EQ_LZ_EN  DFE summer and buffer for non-DFE modes amsbus ctrl_out  10:10
 *     AMS_RX_DFE_HGAIN_EN enables high, fixed gain for the DFE summer and buffer. amsbus ctrl_out  11:11
 *     AMS_RX_DC_COUPLE for QSGMII DC mode with 50 Ohm pull-up to RVDD1p0 amsbus ctrl_out  12:12DFT_DFS=1'b0
 *     AMS_RX_PEAKING_FILTER_IBIAS peaking filter ibias (max, mode, min) amsbus ctrl_out  15:13
 */
#define BCMI_MADURA_AMS_RX_RX_CTL0r (0x0001d0c0 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL0.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl0[1];
	uint32_t _ams_rx_rx_ctl0;
} BCMI_MADURA_AMS_RX_RX_CTL0r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL0r_CLR(r) (r).ams_rx_rx_ctl0[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL0r_SET(r,d) (r).ams_rx_rx_ctl0[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL0r_GET(r) (r).ams_rx_rx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 13) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 12) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 9) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 7) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 6) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET(r) ((((r).ams_rx_rx_ctl0[0]) >> 3) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET(r) (((r).ams_rx_rx_ctl0[0]) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET(r,f) (r).ams_rx_rx_ctl0[0]=(((r).ams_rx_rx_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL0.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL0r,_r._ams_rx_rx_ctl0)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL0r,_r._ams_rx_rx_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL0r BCMI_MADURA_AMS_RX_RX_CTL0r
#define AMS_RX_RX_CTL0r_SIZE BCMI_MADURA_AMS_RX_RX_CTL0r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL0r_t AMS_RX_RX_CTL0r_t;
#define AMS_RX_RX_CTL0r_CLR BCMI_MADURA_AMS_RX_RX_CTL0r_CLR
#define AMS_RX_RX_CTL0r_SET BCMI_MADURA_AMS_RX_RX_CTL0r_SET
#define AMS_RX_RX_CTL0r_GET BCMI_MADURA_AMS_RX_RX_CTL0r_GET
#define AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DC_COUPLEf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_TPORT_ENf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET
#define AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET
#define AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET
#define READ_AMS_RX_RX_CTL0r BCMI_MADURA_READ_AMS_RX_RX_CTL0r
#define WRITE_AMS_RX_RX_CTL0r BCMI_MADURA_WRITE_AMS_RX_RX_CTL0r
#define MODIFY_AMS_RX_RX_CTL0r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL1
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c1
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_SPARE_16  ams rx reserved [16] amsbus ctrl_out  16:16
 *     AMS_RX_VGA0_IBIAS VGA0 ibias (max, mode, min) amsbus ctrl_out  19:17
 *     AMS_RX_VGA1_IBIAS VGA1 ibias (max, mode, min) amsbus ctrl_out  22:20
 *     AMS_RX_VGA2_IBIAS VGA2 ibias (max, mode, min) amsbus ctrl_out  25:23
 *     AMS_RX_VGA3_IBIAS VGA3 ibias (max, mode, min) amsbus ctrl_out  28:26
 *     AMS_RX_CM_VOLTAGE_IBIAS input CM voltage ibias (max, mode, min) amsbus ctrl_out  31:29
 */
#define BCMI_MADURA_AMS_RX_RX_CTL1r (0x0001d0c1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL1.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl1[1];
	uint32_t _ams_rx_rx_ctl1;
} BCMI_MADURA_AMS_RX_RX_CTL1r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL1r_CLR(r) (r).ams_rx_rx_ctl1[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL1r_SET(r,d) (r).ams_rx_rx_ctl1[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL1r_GET(r) (r).ams_rx_rx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 13) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA3_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 10) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA3_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 7) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 4) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET(r) ((((r).ams_rx_rx_ctl1[0]) >> 1) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_SPARE_16f_GET(r) (((r).ams_rx_rx_ctl1[0]) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_SPARE_16f_SET(r,f) (r).ams_rx_rx_ctl1[0]=(((r).ams_rx_rx_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL1.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL1r,_r._ams_rx_rx_ctl1)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL1r,_r._ams_rx_rx_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL1r BCMI_MADURA_AMS_RX_RX_CTL1r
#define AMS_RX_RX_CTL1r_SIZE BCMI_MADURA_AMS_RX_RX_CTL1r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL1r_t AMS_RX_RX_CTL1r_t;
#define AMS_RX_RX_CTL1r_CLR BCMI_MADURA_AMS_RX_RX_CTL1r_CLR
#define AMS_RX_RX_CTL1r_SET BCMI_MADURA_AMS_RX_RX_CTL1r_SET
#define AMS_RX_RX_CTL1r_GET BCMI_MADURA_AMS_RX_RX_CTL1r_GET
#define AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA3_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA3_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA3_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA3_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET
#define AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET
#define AMS_RX_RX_CTL1r_AMS_RX_SPARE_16f_GET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_SPARE_16f_GET
#define AMS_RX_RX_CTL1r_AMS_RX_SPARE_16f_SET BCMI_MADURA_AMS_RX_RX_CTL1r_AMS_RX_SPARE_16f_SET
#define READ_AMS_RX_RX_CTL1r BCMI_MADURA_READ_AMS_RX_RX_CTL1r
#define WRITE_AMS_RX_RX_CTL1r BCMI_MADURA_WRITE_AMS_RX_RX_CTL1r
#define MODIFY_AMS_RX_RX_CTL1r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL2
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c2
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_2
 * RESETVAL: 0xe00 (3584)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_SIGDET_IBIAS signal detect ibias (max, mode, min) amsbus ctrl_out  34:32
 *     AMS_RX_PHASE_INTERPOLATORS_IBIAS phase interpolators ibias (max, mode, min) amsbus ctrl_out  37:35DFT_MUX
 *     AMS_RX_DFE_TAP_WEIGHT_IBIAS DFE tap weight ibias (max, mode, min) amsbus ctrl_out  40:38
 *     AMS_RX_SEL_UGBW  unity gain buffer BW amsbus ctrl_out  42:41
 *     AMS_RX_SEL_TH4DFE DFE tap threshold voltage amsbus ctrl_out  44:43
 *     AMS_RX_PD_CH_P1  powers down the p1 amsbus ctrl_out  45:45
 *     AMS_RX_SIGDET_POWER_SAVE see AMS amsbus ctrl_out  46:46
 *     AMS_RX_PWRDN_FTAP power down for floating taps amsbus ctrl_out  47:47
 */
#define BCMI_MADURA_AMS_RX_RX_CTL2r (0x0001d0c2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL2.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl2[1];
	uint32_t _ams_rx_rx_ctl2;
} BCMI_MADURA_AMS_RX_RX_CTL2r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL2r_CLR(r) (r).ams_rx_rx_ctl2[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL2r_SET(r,d) (r).ams_rx_rx_ctl2[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL2r_GET(r) (r).ams_rx_rx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 13) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 11) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_UGBWf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 9) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_UGBWf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 6) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET(r) ((((r).ams_rx_rx_ctl2[0]) >> 3) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET(r) (((r).ams_rx_rx_ctl2[0]) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET(r,f) (r).ams_rx_rx_ctl2[0]=(((r).ams_rx_rx_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL2.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL2r,_r._ams_rx_rx_ctl2)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL2r,_r._ams_rx_rx_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL2r BCMI_MADURA_AMS_RX_RX_CTL2r
#define AMS_RX_RX_CTL2r_SIZE BCMI_MADURA_AMS_RX_RX_CTL2r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL2r_t AMS_RX_RX_CTL2r_t;
#define AMS_RX_RX_CTL2r_CLR BCMI_MADURA_AMS_RX_RX_CTL2r_CLR
#define AMS_RX_RX_CTL2r_SET BCMI_MADURA_AMS_RX_RX_CTL2r_SET
#define AMS_RX_RX_CTL2r_GET BCMI_MADURA_AMS_RX_RX_CTL2r_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PD_CH_P1f_SET
#define AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_SEL_UGBWf_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_UGBWf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_SEL_UGBWf_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SEL_UGBWf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET
#define AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET
#define AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET
#define READ_AMS_RX_RX_CTL2r BCMI_MADURA_READ_AMS_RX_RX_CTL2r
#define WRITE_AMS_RX_RX_CTL2r BCMI_MADURA_WRITE_AMS_RX_RX_CTL2r
#define MODIFY_AMS_RX_RX_CTL2r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL3
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c3
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_MET_R_IBIAS met R ibias (max, mode, min) amsbus ctrl_out  50:48
 *     AMS_RX_DLL_IBIAS DLL ibias (max, mode, min) amsbus ctrl_out  53:51DFT_MUX
 *     AMS_RX_OFFSET_CORRECTION_IBIAS offset correction ibias (max, mode, min) amsbus ctrl_out  56:54
 *     AMS_RX_DFE_SUM_BUF_IBIAS DFE sum/buf ibias (max, mode, min) amsbus ctrl_out  59:57
 *     AMS_RX_DFE_SLICER_IBIAS dfe_slicer_ibias amsbus ctrl_out  62:60
 *     AMS_RX_SPARE_63  ams rx reserved[63] amsbus ctrl_out  63:63
 */
#define BCMI_MADURA_AMS_RX_RX_CTL3r (0x0001d0c3 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL3.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl3[1];
	uint32_t _ams_rx_rx_ctl3;
} BCMI_MADURA_AMS_RX_RX_CTL3r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL3r_CLR(r) (r).ams_rx_rx_ctl3[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL3r_SET(r,d) (r).ams_rx_rx_ctl3[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL3r_GET(r) (r).ams_rx_rx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_SPARE_63f_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_SPARE_63f_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 12) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 9) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 6) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_GET(r) ((((r).ams_rx_rx_ctl3[0]) >> 3) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET(r) (((r).ams_rx_rx_ctl3[0]) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET(r,f) (r).ams_rx_rx_ctl3[0]=(((r).ams_rx_rx_ctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL3.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL3r,_r._ams_rx_rx_ctl3)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL3r,_r._ams_rx_rx_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL3r BCMI_MADURA_AMS_RX_RX_CTL3r
#define AMS_RX_RX_CTL3r_SIZE BCMI_MADURA_AMS_RX_RX_CTL3r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL3r_t AMS_RX_RX_CTL3r_t;
#define AMS_RX_RX_CTL3r_CLR BCMI_MADURA_AMS_RX_RX_CTL3r_CLR
#define AMS_RX_RX_CTL3r_SET BCMI_MADURA_AMS_RX_RX_CTL3r_SET
#define AMS_RX_RX_CTL3r_GET BCMI_MADURA_AMS_RX_RX_CTL3r_GET
#define AMS_RX_RX_CTL3r_AMS_RX_SPARE_63f_GET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_SPARE_63f_GET
#define AMS_RX_RX_CTL3r_AMS_RX_SPARE_63f_SET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_SPARE_63f_SET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_DLL_IBIASf_SET
#define AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET
#define AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET
#define READ_AMS_RX_RX_CTL3r BCMI_MADURA_READ_AMS_RX_RX_CTL3r
#define WRITE_AMS_RX_RX_CTL3r BCMI_MADURA_WRITE_AMS_RX_RX_CTL3r
#define MODIFY_AMS_RX_RX_CTL3r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL4
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c4
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DFE_SLICER_CAL_IBIAS DFE slicer cal ibias (max, mode, min) amsbus ctrl_out  66:64
 *     AMS_RX_TBD_IBIAS TBD ibias (max, mode, min) amsbus ctrl_out  69:67
 *     AMS_RX_VGA0_RESCAL_MUX VGA0 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  74:70
 *     AMS_RX_VGA1_RESCAL_MUX VGA1 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  79:75
 */
#define BCMI_MADURA_AMS_RX_RX_CTL4r (0x0001d0c4 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL4.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl4[1];
	uint32_t _ams_rx_rx_ctl4;
} BCMI_MADURA_AMS_RX_RX_CTL4r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL4r_CLR(r) (r).ams_rx_rx_ctl4[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL4r_SET(r,d) (r).ams_rx_rx_ctl4[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL4r_GET(r) (r).ams_rx_rx_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl4[0]) >> 11) & 0x1f)
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl4[0]) >> 6) & 0x1f)
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_TBD_IBIASf_GET(r) ((((r).ams_rx_rx_ctl4[0]) >> 3) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_TBD_IBIASf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_GET(r) (((r).ams_rx_rx_ctl4[0]) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_SET(r,f) (r).ams_rx_rx_ctl4[0]=(((r).ams_rx_rx_ctl4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL4.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL4r,_r._ams_rx_rx_ctl4)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL4r,_r._ams_rx_rx_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL4r BCMI_MADURA_AMS_RX_RX_CTL4r
#define AMS_RX_RX_CTL4r_SIZE BCMI_MADURA_AMS_RX_RX_CTL4r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL4r_t AMS_RX_RX_CTL4r_t;
#define AMS_RX_RX_CTL4r_CLR BCMI_MADURA_AMS_RX_RX_CTL4r_CLR
#define AMS_RX_RX_CTL4r_SET BCMI_MADURA_AMS_RX_RX_CTL4r_SET
#define AMS_RX_RX_CTL4r_GET BCMI_MADURA_AMS_RX_RX_CTL4r_GET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL4r_AMS_RX_TBD_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_TBD_IBIASf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_TBD_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_TBD_IBIASf_SET
#define AMS_RX_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_GET
#define AMS_RX_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_SET
#define READ_AMS_RX_RX_CTL4r BCMI_MADURA_READ_AMS_RX_RX_CTL4r
#define WRITE_AMS_RX_RX_CTL4r BCMI_MADURA_WRITE_AMS_RX_RX_CTL4r
#define MODIFY_AMS_RX_RX_CTL4r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL5
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c5
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_VGA2_RESCAL_MUX VGA2 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  84:80
 *     AMS_RX_VGA3_RESCAL_MUX VGA3 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  89:85
 *     AMS_RX_SPARE_91_90 ams rx reserved[91:90] amsbus ctrl_out  91:90
 *     AMS_RX_TESTCLK_DIV divides rclk20 for test port. 00=OFF; 01=div2; 10=div4; 11=div8 amsbus ctrl_out  93:92
 *     AMS_RX_TESTCLK_MUX 0=local test clock; 1=adjacent lane test clock amsbus ctrl_out  94:94
 *     AMS_RX_RXCLK_MUX NA. Use rx_pll_select or pll_select register fields from ckrst_ctrl regmap. 0=4T clks from PLL0; 1=4T clks from PLL1 amsbus ctrl_out  95:95
 */
#define BCMI_MADURA_AMS_RX_RX_CTL5r (0x0001d0c5 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL5.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL5r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl5[1];
	uint32_t _ams_rx_rx_ctl5;
} BCMI_MADURA_AMS_RX_RX_CTL5r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL5r_CLR(r) (r).ams_rx_rx_ctl5[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL5r_SET(r,d) (r).ams_rx_rx_ctl5[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL5r_GET(r) (r).ams_rx_rx_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_RXCLK_MUXf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_RXCLK_MUXf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 12) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_SPARE_91_90f_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 10) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_SPARE_91_90f_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl5[0]) >> 5) & 0x1f)
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET(r) (((r).ams_rx_rx_ctl5[0]) & 0x1f)
#define BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl5[0]=(((r).ams_rx_rx_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL5.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL5r,_r._ams_rx_rx_ctl5)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL5r,_r._ams_rx_rx_ctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL5r BCMI_MADURA_AMS_RX_RX_CTL5r
#define AMS_RX_RX_CTL5r_SIZE BCMI_MADURA_AMS_RX_RX_CTL5r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL5r_t AMS_RX_RX_CTL5r_t;
#define AMS_RX_RX_CTL5r_CLR BCMI_MADURA_AMS_RX_RX_CTL5r_CLR
#define AMS_RX_RX_CTL5r_SET BCMI_MADURA_AMS_RX_RX_CTL5r_SET
#define AMS_RX_RX_CTL5r_GET BCMI_MADURA_AMS_RX_RX_CTL5r_GET
#define AMS_RX_RX_CTL5r_AMS_RX_RXCLK_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_RXCLK_MUXf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_RXCLK_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_RXCLK_MUXf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_MUXf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_GET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_SET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_TESTCLK_DIVf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_SPARE_91_90f_GET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_SPARE_91_90f_GET
#define AMS_RX_RX_CTL5r_AMS_RX_SPARE_91_90f_SET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_SPARE_91_90f_SET
#define AMS_RX_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET
#define READ_AMS_RX_RX_CTL5r BCMI_MADURA_READ_AMS_RX_RX_CTL5r
#define WRITE_AMS_RX_RX_CTL5r BCMI_MADURA_WRITE_AMS_RX_RX_CTL5r
#define MODIFY_AMS_RX_RX_CTL5r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL6
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c6
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_PEAKING_FILTER_RESCAL_MUX peaking filter rescal mux- (force, ctrl[3:1]) -rescal override amsbus ctrl_out  99:96
 *     AMS_RX_OFFSET_CORRECTION_RESCAL_MUX offset correction rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out  103:100
 *     AMS_RX_SPARE_111_104 ams rx reserved[111:104] amsbus ctrl_out  111:104
 */
#define BCMI_MADURA_AMS_RX_RX_CTL6r (0x0001d0c6 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL6.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl6[1];
	uint32_t _ams_rx_rx_ctl6;
} BCMI_MADURA_AMS_RX_RX_CTL6r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL6r_CLR(r) (r).ams_rx_rx_ctl6[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL6r_SET(r,d) (r).ams_rx_rx_ctl6[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL6r_GET(r) (r).ams_rx_rx_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_SPARE_111_104f_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 8) & 0xff)
#define BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_SPARE_111_104f_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET(r) ((((r).ams_rx_rx_ctl6[0]) >> 4) & 0xf)
#define BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET(r) (((r).ams_rx_rx_ctl6[0]) & 0xf)
#define BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET(r,f) (r).ams_rx_rx_ctl6[0]=(((r).ams_rx_rx_ctl6[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL6.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL6r,_r._ams_rx_rx_ctl6)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL6r,_r._ams_rx_rx_ctl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL6r BCMI_MADURA_AMS_RX_RX_CTL6r
#define AMS_RX_RX_CTL6r_SIZE BCMI_MADURA_AMS_RX_RX_CTL6r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL6r_t AMS_RX_RX_CTL6r_t;
#define AMS_RX_RX_CTL6r_CLR BCMI_MADURA_AMS_RX_RX_CTL6r_CLR
#define AMS_RX_RX_CTL6r_SET BCMI_MADURA_AMS_RX_RX_CTL6r_SET
#define AMS_RX_RX_CTL6r_GET BCMI_MADURA_AMS_RX_RX_CTL6r_GET
#define AMS_RX_RX_CTL6r_AMS_RX_SPARE_111_104f_GET BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_SPARE_111_104f_GET
#define AMS_RX_RX_CTL6r_AMS_RX_SPARE_111_104f_SET BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_SPARE_111_104f_SET
#define AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET
#define AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET
#define AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET BCMI_MADURA_AMS_RX_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET
#define READ_AMS_RX_RX_CTL6r BCMI_MADURA_READ_AMS_RX_RX_CTL6r
#define WRITE_AMS_RX_RX_CTL6r BCMI_MADURA_WRITE_AMS_RX_RX_CTL6r
#define MODIFY_AMS_RX_RX_CTL6r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL7
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c7
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DC_OFFSET dc_offset amsbus ctrl_out  118:112
 *     AMS_RX_FORCE_DC_OFFSET enables override using register bits amsbus ctrl_out  119:119
 *     AMS_RX_DC_OFFSET_RANGE dc_offset range, 2x amsbus ctrl_out  120:120
 *     AMS_RX_RX_OFFSET_PD pwrdn AFE offset cancellation DAC amsbus ctrl_out  121:121
 *     AMS_RX_SHORT_VGA_OUTPUT used for slicer calibration amsbus ctrl_out  122:122
 *     AMS_RX_SPARE_123 ams rx reserved [123] amsbus ctrl_out  123:123
 *     AMS_RX_VGA_LOW_GAIN extends low gain range by ~ -4dB per stage amsbus ctrl_out  125:124
 *     AMS_RX_VGA_STEP_MODE stage sequential. See AMS amsbus ctrl_out  127:126
 */
#define BCMI_MADURA_AMS_RX_RX_CTL7r (0x0001d0c7 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL7.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl7[1];
	uint32_t _ams_rx_rx_ctl7;
} BCMI_MADURA_AMS_RX_RX_CTL7r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL7r_CLR(r) (r).ams_rx_rx_ctl7[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL7r_SET(r,d) (r).ams_rx_rx_ctl7[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL7r_GET(r) (r).ams_rx_rx_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 14) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 12) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SPARE_123f_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SPARE_123f_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 9) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 8) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET(r) ((((r).ams_rx_rx_ctl7[0]) >> 7) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_GET(r) (((r).ams_rx_rx_ctl7[0]) & 0x7f)
#define BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_SET(r,f) (r).ams_rx_rx_ctl7[0]=(((r).ams_rx_rx_ctl7[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL7.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL7r,_r._ams_rx_rx_ctl7)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL7r,_r._ams_rx_rx_ctl7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL7r BCMI_MADURA_AMS_RX_RX_CTL7r
#define AMS_RX_RX_CTL7r_SIZE BCMI_MADURA_AMS_RX_RX_CTL7r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL7r_t AMS_RX_RX_CTL7r_t;
#define AMS_RX_RX_CTL7r_CLR BCMI_MADURA_AMS_RX_RX_CTL7r_CLR
#define AMS_RX_RX_CTL7r_SET BCMI_MADURA_AMS_RX_RX_CTL7r_SET
#define AMS_RX_RX_CTL7r_GET BCMI_MADURA_AMS_RX_RX_CTL7r_GET
#define AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_SPARE_123f_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SPARE_123f_GET
#define AMS_RX_RX_CTL7r_AMS_RX_SPARE_123f_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SPARE_123f_SET
#define AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_GET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_GET
#define AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_SET BCMI_MADURA_AMS_RX_RX_CTL7r_AMS_RX_DC_OFFSETf_SET
#define READ_AMS_RX_RX_CTL7r BCMI_MADURA_READ_AMS_RX_RX_CTL7r
#define WRITE_AMS_RX_RX_CTL7r BCMI_MADURA_WRITE_AMS_RX_RX_CTL7r
#define MODIFY_AMS_RX_RX_CTL7r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL8
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c8
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DAC4CK_LMS dac4ck_lms amsbus ctrl_out  133:128
 *     AMS_RX_SPARE_135_134 ams rx reserved[135:134] amsbus ctrl_out  135:134DFT_MUX
 *     AMS_RX_DAC4CK_PHS dac4ck_phs amsbus ctrl_out  141:136
 *     AMS_RX_SPARE_143_142 ams rx reserved[143:142] amsbus ctrl_out  143:142
 */
#define BCMI_MADURA_AMS_RX_RX_CTL8r (0x0001d0c8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL8.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL8r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl8[1];
	uint32_t _ams_rx_rx_ctl8;
} BCMI_MADURA_AMS_RX_RX_CTL8r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL8r_CLR(r) (r).ams_rx_rx_ctl8[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL8r_SET(r,d) (r).ams_rx_rx_ctl8[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL8r_GET(r) (r).ams_rx_rx_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_143_142f_GET(r) ((((r).ams_rx_rx_ctl8[0]) >> 14) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_143_142f_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHSf_GET(r) ((((r).ams_rx_rx_ctl8[0]) >> 8) & 0x3f)
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHSf_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_135_134f_GET(r) ((((r).ams_rx_rx_ctl8[0]) >> 6) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_135_134f_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMSf_GET(r) (((r).ams_rx_rx_ctl8[0]) & 0x3f)
#define BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMSf_SET(r,f) (r).ams_rx_rx_ctl8[0]=(((r).ams_rx_rx_ctl8[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL8.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL8r,_r._ams_rx_rx_ctl8)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL8r,_r._ams_rx_rx_ctl8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL8r BCMI_MADURA_AMS_RX_RX_CTL8r
#define AMS_RX_RX_CTL8r_SIZE BCMI_MADURA_AMS_RX_RX_CTL8r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL8r_t AMS_RX_RX_CTL8r_t;
#define AMS_RX_RX_CTL8r_CLR BCMI_MADURA_AMS_RX_RX_CTL8r_CLR
#define AMS_RX_RX_CTL8r_SET BCMI_MADURA_AMS_RX_RX_CTL8r_SET
#define AMS_RX_RX_CTL8r_GET BCMI_MADURA_AMS_RX_RX_CTL8r_GET
#define AMS_RX_RX_CTL8r_AMS_RX_SPARE_143_142f_GET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_143_142f_GET
#define AMS_RX_RX_CTL8r_AMS_RX_SPARE_143_142f_SET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_143_142f_SET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHSf_GET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHSf_GET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHSf_SET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_PHSf_SET
#define AMS_RX_RX_CTL8r_AMS_RX_SPARE_135_134f_GET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_135_134f_GET
#define AMS_RX_RX_CTL8r_AMS_RX_SPARE_135_134f_SET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_SPARE_135_134f_SET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMSf_GET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMSf_GET
#define AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMSf_SET BCMI_MADURA_AMS_RX_RX_CTL8r_AMS_RX_DAC4CK_LMSf_SET
#define READ_AMS_RX_RX_CTL8r BCMI_MADURA_READ_AMS_RX_RX_CTL8r
#define WRITE_AMS_RX_RX_CTL8r BCMI_MADURA_WRITE_AMS_RX_RX_CTL8r
#define MODIFY_AMS_RX_RX_CTL8r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_CTL9
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c9
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_9
 * RESETVAL: 0x300 (768)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DAC4CK_DAT dac4ck_dat amsbus ctrl_out  149:144DFT_MUX
 *     AMS_RX_SPARE_151_150 ams rx reserved[151:150] amsbus ctrl_out  151:150
 *     AMS_RX_CLK_BW_CTRL clk_bw_ctrl<1:0> for 15G to 28G amsbus ctrl_out  153:152DFT_MUX
 *     AMS_RX_EN_TAP9DELAY 0=less delay for 25-28G; 1=more delay for <25G amsbus ctrl_out  154:154
 *     AMS_RX_SEL_D2CLP 0=high power for 25-28g; 1=low power for <25G amsbus ctrl_out  155:155DFT_MUX
 *     AMS_RX_D2C_CLKBUF_IBIAS d2c and clock buffer ibias (max, mode, min) amsbus ctrl_out  158:156DFT_MUX
 *     AMS_RX_DATA12T_LL_EN enable 12t data and clk ouputs for LL mode amsbus ctrl_out  159:159
 */
#define BCMI_MADURA_AMS_RX_RX_CTL9r (0x0001d0c9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL9.
 */
typedef union BCMI_MADURA_AMS_RX_RX_CTL9r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl9[1];
	uint32_t _ams_rx_rx_ctl9;
} BCMI_MADURA_AMS_RX_RX_CTL9r_t;

#define BCMI_MADURA_AMS_RX_RX_CTL9r_CLR(r) (r).ams_rx_rx_ctl9[0] = 0
#define BCMI_MADURA_AMS_RX_RX_CTL9r_SET(r,d) (r).ams_rx_rx_ctl9[0] = d
#define BCMI_MADURA_AMS_RX_RX_CTL9r_GET(r) (r).ams_rx_rx_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DATA12T_LL_ENf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DATA12T_LL_ENf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 12) & 0x7)
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 8) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SPARE_151_150f_GET(r) ((((r).ams_rx_rx_ctl9[0]) >> 6) & 0x3)
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SPARE_151_150f_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DATf_GET(r) (((r).ams_rx_rx_ctl9[0]) & 0x3f)
#define BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DATf_SET(r,f) (r).ams_rx_rx_ctl9[0]=(((r).ams_rx_rx_ctl9[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL9.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_CTL9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_CTL9r,_r._ams_rx_rx_ctl9)
#define BCMI_MADURA_WRITE_AMS_RX_RX_CTL9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_CTL9r,_r._ams_rx_rx_ctl9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL9r BCMI_MADURA_AMS_RX_RX_CTL9r
#define AMS_RX_RX_CTL9r_SIZE BCMI_MADURA_AMS_RX_RX_CTL9r_SIZE
typedef BCMI_MADURA_AMS_RX_RX_CTL9r_t AMS_RX_RX_CTL9r_t;
#define AMS_RX_RX_CTL9r_CLR BCMI_MADURA_AMS_RX_RX_CTL9r_CLR
#define AMS_RX_RX_CTL9r_SET BCMI_MADURA_AMS_RX_RX_CTL9r_SET
#define AMS_RX_RX_CTL9r_GET BCMI_MADURA_AMS_RX_RX_CTL9r_GET
#define AMS_RX_RX_CTL9r_AMS_RX_DATA12T_LL_ENf_GET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DATA12T_LL_ENf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_DATA12T_LL_ENf_SET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DATA12T_LL_ENf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_GET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_SET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET
#define AMS_RX_RX_CTL9r_AMS_RX_SPARE_151_150f_GET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SPARE_151_150f_GET
#define AMS_RX_RX_CTL9r_AMS_RX_SPARE_151_150f_SET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_SPARE_151_150f_SET
#define AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DATf_GET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DATf_GET
#define AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DATf_SET BCMI_MADURA_AMS_RX_RX_CTL9r_AMS_RX_DAC4CK_DATf_SET
#define READ_AMS_RX_RX_CTL9r BCMI_MADURA_READ_AMS_RX_RX_CTL9r
#define WRITE_AMS_RX_RX_CTL9r BCMI_MADURA_WRITE_AMS_RX_RX_CTL9r
#define MODIFY_AMS_RX_RX_CTL9r BCMI_MADURA_MODIFY_AMS_RX_RX_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_RX_RX_STS
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0cb
 * DEVAD:    1
 * DESC:     AMS RX STATUS
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_RX_VGA       Copy of VGA control vga_ctrl[4:0]
 *     AMS_RX_TAP1_DFE_GRAY Copy of tap1 dfe in gray code
 *     AMS_RX_PF        Copy of peaking filter control rx_pf_ctrl[3:0]
 *     AMS_RX_SIGDET    Signal Detect status
 */
#define BCMI_MADURA_AMS_RX_RX_STSr (0x0001d0cb | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_RX_RX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_STS.
 */
typedef union BCMI_MADURA_AMS_RX_RX_STSr_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_sts[1];
	uint32_t _ams_rx_rx_sts;
} BCMI_MADURA_AMS_RX_RX_STSr_t;

#define BCMI_MADURA_AMS_RX_RX_STSr_CLR(r) (r).ams_rx_rx_sts[0] = 0
#define BCMI_MADURA_AMS_RX_RX_STSr_SET(r,d) (r).ams_rx_rx_sts[0] = d
#define BCMI_MADURA_AMS_RX_RX_STSr_GET(r) (r).ams_rx_rx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_SIGDETf_GET(r) ((((r).ams_rx_rx_sts[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_SIGDETf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_PFf_GET(r) ((((r).ams_rx_rx_sts[0]) >> 11) & 0xf)
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_PFf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_TAP1_DFE_GRAYf_GET(r) ((((r).ams_rx_rx_sts[0]) >> 5) & 0x3f)
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_TAP1_DFE_GRAYf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_VGAf_GET(r) (((r).ams_rx_rx_sts[0]) & 0x1f)
#define BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_VGAf_SET(r,f) (r).ams_rx_rx_sts[0]=(((r).ams_rx_rx_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_RX_RX_STS.
 */
#define BCMI_MADURA_READ_AMS_RX_RX_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_RX_RX_STSr,_r._ams_rx_rx_sts)
#define BCMI_MADURA_WRITE_AMS_RX_RX_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_RX_RX_STSr,_r._ams_rx_rx_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_STSr BCMI_MADURA_AMS_RX_RX_STSr
#define AMS_RX_RX_STSr_SIZE BCMI_MADURA_AMS_RX_RX_STSr_SIZE
typedef BCMI_MADURA_AMS_RX_RX_STSr_t AMS_RX_RX_STSr_t;
#define AMS_RX_RX_STSr_CLR BCMI_MADURA_AMS_RX_RX_STSr_CLR
#define AMS_RX_RX_STSr_SET BCMI_MADURA_AMS_RX_RX_STSr_SET
#define AMS_RX_RX_STSr_GET BCMI_MADURA_AMS_RX_RX_STSr_GET
#define AMS_RX_RX_STSr_AMS_RX_SIGDETf_GET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_SIGDETf_GET
#define AMS_RX_RX_STSr_AMS_RX_SIGDETf_SET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_SIGDETf_SET
#define AMS_RX_RX_STSr_AMS_RX_PFf_GET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_PFf_GET
#define AMS_RX_RX_STSr_AMS_RX_PFf_SET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_PFf_SET
#define AMS_RX_RX_STSr_AMS_RX_TAP1_DFE_GRAYf_GET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_TAP1_DFE_GRAYf_GET
#define AMS_RX_RX_STSr_AMS_RX_TAP1_DFE_GRAYf_SET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_TAP1_DFE_GRAYf_SET
#define AMS_RX_RX_STSr_AMS_RX_VGAf_GET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_VGAf_GET
#define AMS_RX_RX_STSr_AMS_RX_VGAf_SET BCMI_MADURA_AMS_RX_RX_STSr_AMS_RX_VGAf_SET
#define READ_AMS_RX_RX_STSr BCMI_MADURA_READ_AMS_RX_RX_STSr
#define WRITE_AMS_RX_RX_STSr BCMI_MADURA_WRITE_AMS_RX_RX_STSr
#define MODIFY_AMS_RX_RX_STSr BCMI_MADURA_MODIFY_AMS_RX_RX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_RX_RX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_TX_TX_CTL0
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d0
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_0
 * RESETVAL: 0xc0 (192)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_TXCLK_MUX NA. Use tx_pll_select or pll_select register fields from ckrst_ctrl regmap. 0=2T clks from PLL0; 1=2T clks from PLL1 amsbus ctrl_out  0:0
 *     AMS_TX_SPARE_3_1 AMS reserved[3:1] amsbus ctrl_out  3:1
 *     AMS_TX_TEST_DATA generates output pattern amsbus ctrl_out  5:4
 *     AMS_TX_TICKSEL   timing control of load signal at ana/dig interface amsbus ctrl_out  7:6
 *     AMS_TX_VDDR_BGB  bias mode control amsbus ctrl_out  8:8DFT_MUX
 *     AMS_TX_DCC_SEL   select DCC mode. 0=using DCC circuit. 1= signle ended amsbus ctrl_out  9:9DFT_MUX
 *     AMS_TX_DCC_DIS   disable DCC amsbus ctrl_out  10:10DFT_MUX
 *     AMS_TX_CAL_OFF   disable RESCAL[3:0], enable cal_aux[3:0] amsbus ctrl_out  11:11DFT_MUX
 *     AMS_TX_CAL_AUX   Rescal manual control when cal_off=1 amsbus ctrl_out  15:12DFT_MUX
 */
#define BCMI_MADURA_AMS_TX_TX_CTL0r (0x0001d0d0 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_TX_TX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL0.
 */
typedef union BCMI_MADURA_AMS_TX_TX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl0[1];
	uint32_t _ams_tx_tx_ctl0;
} BCMI_MADURA_AMS_TX_TX_CTL0r_t;

#define BCMI_MADURA_AMS_TX_TX_CTL0r_CLR(r) (r).ams_tx_tx_ctl0[0] = 0
#define BCMI_MADURA_AMS_TX_TX_CTL0r_SET(r,d) (r).ams_tx_tx_ctl0[0] = d
#define BCMI_MADURA_AMS_TX_TX_CTL0r_GET(r) (r).ams_tx_tx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 12) & 0xf)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_SELf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 9) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_SELf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 6) & 0x3)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TEST_DATAf_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 4) & 0x3)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TEST_DATAf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_SPARE_3_1f_GET(r) ((((r).ams_tx_tx_ctl0[0]) >> 1) & 0x7)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_SPARE_3_1f_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TXCLK_MUXf_GET(r) (((r).ams_tx_tx_ctl0[0]) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TXCLK_MUXf_SET(r,f) (r).ams_tx_tx_ctl0[0]=(((r).ams_tx_tx_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL0.
 */
#define BCMI_MADURA_READ_AMS_TX_TX_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_TX_TX_CTL0r,_r._ams_tx_tx_ctl0)
#define BCMI_MADURA_WRITE_AMS_TX_TX_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_TX_TX_CTL0r,_r._ams_tx_tx_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL0r BCMI_MADURA_AMS_TX_TX_CTL0r
#define AMS_TX_TX_CTL0r_SIZE BCMI_MADURA_AMS_TX_TX_CTL0r_SIZE
typedef BCMI_MADURA_AMS_TX_TX_CTL0r_t AMS_TX_TX_CTL0r_t;
#define AMS_TX_TX_CTL0r_CLR BCMI_MADURA_AMS_TX_TX_CTL0r_CLR
#define AMS_TX_TX_CTL0r_SET BCMI_MADURA_AMS_TX_TX_CTL0r_SET
#define AMS_TX_TX_CTL0r_GET BCMI_MADURA_AMS_TX_TX_CTL0r_GET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_AUXf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_CAL_OFFf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_DISf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_DCC_SELf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_SELf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_DCC_SELf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_DCC_SELf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_VDDR_BGBf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TICKSELf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_TEST_DATAf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TEST_DATAf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_TEST_DATAf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TEST_DATAf_SET
#define AMS_TX_TX_CTL0r_AMS_TX_SPARE_3_1f_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_SPARE_3_1f_GET
#define AMS_TX_TX_CTL0r_AMS_TX_SPARE_3_1f_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_SPARE_3_1f_SET
#define AMS_TX_TX_CTL0r_AMS_TX_TXCLK_MUXf_GET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TXCLK_MUXf_GET
#define AMS_TX_TX_CTL0r_AMS_TX_TXCLK_MUXf_SET BCMI_MADURA_AMS_TX_TX_CTL0r_AMS_TX_TXCLK_MUXf_SET
#define READ_AMS_TX_TX_CTL0r BCMI_MADURA_READ_AMS_TX_TX_CTL0r
#define WRITE_AMS_TX_TX_CTL0r BCMI_MADURA_WRITE_AMS_TX_TX_CTL0r
#define MODIFY_AMS_TX_TX_CTL0r BCMI_MADURA_MODIFY_AMS_TX_TX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_TX_TX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_TX_TX_CTL1
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d1
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_1
 * RESETVAL: 0x2000 (8192)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_IBIAS     master bias diode amsbus ctrl_out  18:16DFT_MUX
 *     AMS_TX_IPHINT    phase interpolator current control amsbus ctrl_out  21:19DFT_MUX
 *     AMS_TX_ICML      clock input buffer current control amsbus ctrl_out  24:22DFT_MUX
 *     AMS_TX_ILDO      LDO bias current control amsbus ctrl_out  27:25
 *     AMS_TX_LDO_VREF  adjusts internal driver supply voltage, scales output amplitute amsbus ctrl_out  29:28DFT_MUX
 *     AMS_TX_SEL_EMPH_MODE select emphasis mode. See AMS amsbus ctrl_out  30
 *     AMS_TX_CLK20_EN  enables the 20T clock. This clock is used in OS2 and OS4 modes and is not meant to be used in OS1 mode. amsbus ctrl_out  31DFT_MUX
 */
#define BCMI_MADURA_AMS_TX_TX_CTL1r (0x0001d0d1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_TX_TX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL1.
 */
typedef union BCMI_MADURA_AMS_TX_TX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl1[1];
	uint32_t _ams_tx_tx_ctl1;
} BCMI_MADURA_AMS_TX_TX_CTL1r_t;

#define BCMI_MADURA_AMS_TX_TX_CTL1r_CLR(r) (r).ams_tx_tx_ctl1[0] = 0
#define BCMI_MADURA_AMS_TX_TX_CTL1r_SET(r,d) (r).ams_tx_tx_ctl1[0] = d
#define BCMI_MADURA_AMS_TX_TX_CTL1r_GET(r) (r).ams_tx_tx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_CLK20_ENf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_CLK20_ENf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 12) & 0x3)
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 9) & 0x7)
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ICMLf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 6) & 0x7)
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ICMLf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_GET(r) ((((r).ams_tx_tx_ctl1[0]) >> 3) & 0x7)
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_GET(r) (((r).ams_tx_tx_ctl1[0]) & 0x7)
#define BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_SET(r,f) (r).ams_tx_tx_ctl1[0]=(((r).ams_tx_tx_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL1.
 */
#define BCMI_MADURA_READ_AMS_TX_TX_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_TX_TX_CTL1r,_r._ams_tx_tx_ctl1)
#define BCMI_MADURA_WRITE_AMS_TX_TX_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_TX_TX_CTL1r,_r._ams_tx_tx_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL1r BCMI_MADURA_AMS_TX_TX_CTL1r
#define AMS_TX_TX_CTL1r_SIZE BCMI_MADURA_AMS_TX_TX_CTL1r_SIZE
typedef BCMI_MADURA_AMS_TX_TX_CTL1r_t AMS_TX_TX_CTL1r_t;
#define AMS_TX_TX_CTL1r_CLR BCMI_MADURA_AMS_TX_TX_CTL1r_CLR
#define AMS_TX_TX_CTL1r_SET BCMI_MADURA_AMS_TX_TX_CTL1r_SET
#define AMS_TX_TX_CTL1r_GET BCMI_MADURA_AMS_TX_TX_CTL1r_GET
#define AMS_TX_TX_CTL1r_AMS_TX_CLK20_ENf_GET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_CLK20_ENf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_CLK20_ENf_SET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_CLK20_ENf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_GET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_SET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_GET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_SET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_LDO_VREFf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_ILDOf_GET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_ILDOf_SET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ILDOf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_ICMLf_GET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ICMLf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_ICMLf_SET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_ICMLf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_GET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_SET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IPHINTf_SET
#define AMS_TX_TX_CTL1r_AMS_TX_IBIASf_GET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_GET
#define AMS_TX_TX_CTL1r_AMS_TX_IBIASf_SET BCMI_MADURA_AMS_TX_TX_CTL1r_AMS_TX_IBIASf_SET
#define READ_AMS_TX_TX_CTL1r BCMI_MADURA_READ_AMS_TX_TX_CTL1r
#define WRITE_AMS_TX_TX_CTL1r BCMI_MADURA_WRITE_AMS_TX_TX_CTL1r
#define MODIFY_AMS_TX_TX_CTL1r BCMI_MADURA_MODIFY_AMS_TX_TX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_TX_TX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_TX_TX_CTL2
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d2
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_AMP_CTL   see AMS amsbus ctrl_out  35:32
 *     AMS_TX_POST3_COEF 3rd post cursor de-emphasis tap, driven by hardware amsbus ctrl_out  38:36EXT_MUX=afe_tx_post3_coef[2:0]
 *     AMS_TX_SIGN_POST3 polarity control for 3rd post cursor tap, driven by hardware amsbus ctrl_out  39:39EXT_MUX=afe_tx_sign_post3
 *     AMS_TX_POST2_COEF 2nd post cursor de-emphasis tap, driven by hardware amsbus ctrl_out  43:40EXT_MUX=afe_tx_post2_coef[3:0]
 *     AMS_TX_SIGN_POST2 polarity control for 2nd post cursor tap, driven by hardware. amsbus ctrl_out  44:44EXT_MUX=afe_tx_sign_post2
 *     AMS_TX_DRIVER_MODE see AMS amsbus ctrl_out  46:45
 *     AMS_TX_ELEC_IDLE_AUX force electrical idle mode amsbus ctrl_out  47:47
 */
#define BCMI_MADURA_AMS_TX_TX_CTL2r (0x0001d0d2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_TX_TX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL2.
 */
typedef union BCMI_MADURA_AMS_TX_TX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl2[1];
	uint32_t _ams_tx_tx_ctl2;
} BCMI_MADURA_AMS_TX_TX_CTL2r_t;

#define BCMI_MADURA_AMS_TX_TX_CTL2r_CLR(r) (r).ams_tx_tx_ctl2[0] = 0
#define BCMI_MADURA_AMS_TX_TX_CTL2r_SET(r,d) (r).ams_tx_tx_ctl2[0] = d
#define BCMI_MADURA_AMS_TX_TX_CTL2r_GET(r) (r).ams_tx_tx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_MODEf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 13) & 0x3)
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_MODEf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST2f_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 12) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST2f_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST2_COEFf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 8) & 0xf)
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST2_COEFf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST3f_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 7) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST3f_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST3_COEFf_GET(r) ((((r).ams_tx_tx_ctl2[0]) >> 4) & 0x7)
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST3_COEFf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_AMP_CTLf_GET(r) (((r).ams_tx_tx_ctl2[0]) & 0xf)
#define BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_AMP_CTLf_SET(r,f) (r).ams_tx_tx_ctl2[0]=(((r).ams_tx_tx_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL2.
 */
#define BCMI_MADURA_READ_AMS_TX_TX_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_TX_TX_CTL2r,_r._ams_tx_tx_ctl2)
#define BCMI_MADURA_WRITE_AMS_TX_TX_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_TX_TX_CTL2r,_r._ams_tx_tx_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL2r BCMI_MADURA_AMS_TX_TX_CTL2r
#define AMS_TX_TX_CTL2r_SIZE BCMI_MADURA_AMS_TX_TX_CTL2r_SIZE
typedef BCMI_MADURA_AMS_TX_TX_CTL2r_t AMS_TX_TX_CTL2r_t;
#define AMS_TX_TX_CTL2r_CLR BCMI_MADURA_AMS_TX_TX_CTL2r_CLR
#define AMS_TX_TX_CTL2r_SET BCMI_MADURA_AMS_TX_TX_CTL2r_SET
#define AMS_TX_TX_CTL2r_GET BCMI_MADURA_AMS_TX_TX_CTL2r_GET
#define AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_DRIVER_MODEf_GET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_MODEf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_DRIVER_MODEf_SET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_DRIVER_MODEf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST2f_GET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST2f_GET
#define AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST2f_SET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST2f_SET
#define AMS_TX_TX_CTL2r_AMS_TX_POST2_COEFf_GET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST2_COEFf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_POST2_COEFf_SET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST2_COEFf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST3f_GET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST3f_GET
#define AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST3f_SET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_SIGN_POST3f_SET
#define AMS_TX_TX_CTL2r_AMS_TX_POST3_COEFf_GET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST3_COEFf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_POST3_COEFf_SET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_POST3_COEFf_SET
#define AMS_TX_TX_CTL2r_AMS_TX_AMP_CTLf_GET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_AMP_CTLf_GET
#define AMS_TX_TX_CTL2r_AMS_TX_AMP_CTLf_SET BCMI_MADURA_AMS_TX_TX_CTL2r_AMS_TX_AMP_CTLf_SET
#define READ_AMS_TX_TX_CTL2r BCMI_MADURA_READ_AMS_TX_TX_CTL2r
#define WRITE_AMS_TX_TX_CTL2r BCMI_MADURA_WRITE_AMS_TX_TX_CTL2r
#define MODIFY_AMS_TX_TX_CTL2r BCMI_MADURA_MODIFY_AMS_TX_TX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_TX_TX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_TX_TX_CTL3
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d3
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_FIFO_DEPTH select the depth of the FIFO amsbus ctrl_out  50:48
 *     AMS_TX_SEL_FIFO_POL invert FIFO data polarity amsbus ctrl_out  51:51
 *     AMS_TX_PDET_MODE see AMS. amsbus ctrl_out  53:52
 *     AMS_TX_SEL_LL    select low latency input path in the serializer, driven by hardware LL auto select. amsbus ctrl_out  54:54EXT_MUX=afe_tx_sel_ll
 *     AMS_TX_SEL_TXMASTER select TX lane as master, only one TX lane can be set to master. amsbus ctrl_out  55:55
 *     AMS_TX_PDET_LL_CLK 0= TCA clk, 1= LL clk amsbus ctrl_out  56:56
 *     AMS_TX_SPARE_63_57 AMS reserved[63:57] amsbus ctrl_out  63:57
 */
#define BCMI_MADURA_AMS_TX_TX_CTL3r (0x0001d0d3 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_TX_TX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL3.
 */
typedef union BCMI_MADURA_AMS_TX_TX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl3[1];
	uint32_t _ams_tx_tx_ctl3;
} BCMI_MADURA_AMS_TX_TX_CTL3r_t;

#define BCMI_MADURA_AMS_TX_TX_CTL3r_CLR(r) (r).ams_tx_tx_ctl3[0] = 0
#define BCMI_MADURA_AMS_TX_TX_CTL3r_SET(r,d) (r).ams_tx_tx_ctl3[0] = d
#define BCMI_MADURA_AMS_TX_TX_CTL3r_GET(r) (r).ams_tx_tx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_57f_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 9) & 0x7f)
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_57f_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9)) | (127 << (16 + 9))
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_LL_CLKf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 8) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_LL_CLKf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 7) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_LLf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 6) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_LLf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 4) & 0x3)
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_FIFO_POLf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 3) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_FIFO_POLf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_FIFO_DEPTHf_GET(r) (((r).ams_tx_tx_ctl3[0]) & 0x7)
#define BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_FIFO_DEPTHf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL3.
 */
#define BCMI_MADURA_READ_AMS_TX_TX_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_TX_TX_CTL3r,_r._ams_tx_tx_ctl3)
#define BCMI_MADURA_WRITE_AMS_TX_TX_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_TX_TX_CTL3r,_r._ams_tx_tx_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL3r BCMI_MADURA_AMS_TX_TX_CTL3r
#define AMS_TX_TX_CTL3r_SIZE BCMI_MADURA_AMS_TX_TX_CTL3r_SIZE
typedef BCMI_MADURA_AMS_TX_TX_CTL3r_t AMS_TX_TX_CTL3r_t;
#define AMS_TX_TX_CTL3r_CLR BCMI_MADURA_AMS_TX_TX_CTL3r_CLR
#define AMS_TX_TX_CTL3r_SET BCMI_MADURA_AMS_TX_TX_CTL3r_SET
#define AMS_TX_TX_CTL3r_GET BCMI_MADURA_AMS_TX_TX_CTL3r_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_57f_GET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_57f_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_57f_SET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_57f_SET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_LL_CLKf_GET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_LL_CLKf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_LL_CLKf_SET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_LL_CLKf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_LLf_GET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_LLf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_LLf_SET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_LLf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_FIFO_POLf_GET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_FIFO_POLf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_FIFO_POLf_SET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_SEL_FIFO_POLf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_FIFO_DEPTHf_GET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_FIFO_DEPTHf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_FIFO_DEPTHf_SET BCMI_MADURA_AMS_TX_TX_CTL3r_AMS_TX_FIFO_DEPTHf_SET
#define READ_AMS_TX_TX_CTL3r BCMI_MADURA_READ_AMS_TX_TX_CTL3r
#define WRITE_AMS_TX_TX_CTL3r BCMI_MADURA_WRITE_AMS_TX_TX_CTL3r
#define MODIFY_AMS_TX_TX_CTL3r BCMI_MADURA_MODIFY_AMS_TX_TX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_TX_TX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_TX_TX_INTCTL
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d8
 * DEVAD:    1
 * DESC:     INTERNAL TX CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AUTO_LL_SELPATH_TX_DIS 0= tx_disable or eee_alert_pattern, 1= use AMS bit
 */
#define BCMI_MADURA_AMS_TX_TX_INTCTLr (0x0001d0d8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_TX_TX_INTCTLr_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_INTCTL.
 */
typedef union BCMI_MADURA_AMS_TX_TX_INTCTLr_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_intctl[1];
	uint32_t _ams_tx_tx_intctl;
} BCMI_MADURA_AMS_TX_TX_INTCTLr_t;

#define BCMI_MADURA_AMS_TX_TX_INTCTLr_CLR(r) (r).ams_tx_tx_intctl[0] = 0
#define BCMI_MADURA_AMS_TX_TX_INTCTLr_SET(r,d) (r).ams_tx_tx_intctl[0] = d
#define BCMI_MADURA_AMS_TX_TX_INTCTLr_GET(r) (r).ams_tx_tx_intctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_TX_TX_INTCTLr_AUTO_LL_SELPATH_TX_DISf_GET(r) (((r).ams_tx_tx_intctl[0]) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_INTCTLr_AUTO_LL_SELPATH_TX_DISf_SET(r,f) (r).ams_tx_tx_intctl[0]=(((r).ams_tx_tx_intctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_TX_TX_INTCTL.
 */
#define BCMI_MADURA_READ_AMS_TX_TX_INTCTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_TX_TX_INTCTLr,_r._ams_tx_tx_intctl)
#define BCMI_MADURA_WRITE_AMS_TX_TX_INTCTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_TX_TX_INTCTLr,_r._ams_tx_tx_intctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_INTCTLr BCMI_MADURA_AMS_TX_TX_INTCTLr
#define AMS_TX_TX_INTCTLr_SIZE BCMI_MADURA_AMS_TX_TX_INTCTLr_SIZE
typedef BCMI_MADURA_AMS_TX_TX_INTCTLr_t AMS_TX_TX_INTCTLr_t;
#define AMS_TX_TX_INTCTLr_CLR BCMI_MADURA_AMS_TX_TX_INTCTLr_CLR
#define AMS_TX_TX_INTCTLr_SET BCMI_MADURA_AMS_TX_TX_INTCTLr_SET
#define AMS_TX_TX_INTCTLr_GET BCMI_MADURA_AMS_TX_TX_INTCTLr_GET
#define AMS_TX_TX_INTCTLr_AUTO_LL_SELPATH_TX_DISf_GET BCMI_MADURA_AMS_TX_TX_INTCTLr_AUTO_LL_SELPATH_TX_DISf_GET
#define AMS_TX_TX_INTCTLr_AUTO_LL_SELPATH_TX_DISf_SET BCMI_MADURA_AMS_TX_TX_INTCTLr_AUTO_LL_SELPATH_TX_DISf_SET
#define READ_AMS_TX_TX_INTCTLr BCMI_MADURA_READ_AMS_TX_TX_INTCTLr
#define WRITE_AMS_TX_TX_INTCTLr BCMI_MADURA_WRITE_AMS_TX_TX_INTCTLr
#define MODIFY_AMS_TX_TX_INTCTLr BCMI_MADURA_MODIFY_AMS_TX_TX_INTCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_TX_TX_INTCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_TX_TX_STS
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d9
 * DEVAD:    1
 * DESC:     AMS TX STATUS
 * RESETVAL: 0xa0 (160)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_TX_VERSION_ID AMS version ID. Used to track the core version.
 *     AMS_TX_ANA_RESCAL Copy of ana_rescal bus. Control cod efor global resistor calibration. See AMS for more details.
 *     AMS_TX_DRV_HV_DISABLE Copy of of tx_drv_hv_disable. By default, assume high voltage driver (HVD) mode and 1.25V
 *     AMS_TX_SPARE_STS_13 Reserved bit.
 *     AMS_TX_LANE_ID   TX Lane ID
 */
#define BCMI_MADURA_AMS_TX_TX_STSr (0x0001d0d9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_TX_TX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_STS.
 */
typedef union BCMI_MADURA_AMS_TX_TX_STSr_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_sts[1];
	uint32_t _ams_tx_tx_sts;
} BCMI_MADURA_AMS_TX_TX_STSr_t;

#define BCMI_MADURA_AMS_TX_TX_STSr_CLR(r) (r).ams_tx_tx_sts[0] = 0
#define BCMI_MADURA_AMS_TX_TX_STSr_SET(r,d) (r).ams_tx_tx_sts[0] = d
#define BCMI_MADURA_AMS_TX_TX_STSr_GET(r) (r).ams_tx_tx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 14) & 0x3)
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_SPARE_STS_13f_GET(r) ((((r).ams_tx_tx_sts[0]) >> 13) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_SPARE_STS_13f_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 12) & 0x1)
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 8) & 0xf)
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET(r) (((r).ams_tx_tx_sts[0]) & 0xff)
#define BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AMS_TX_TX_STS.
 */
#define BCMI_MADURA_READ_AMS_TX_TX_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_TX_TX_STSr,_r._ams_tx_tx_sts)
#define BCMI_MADURA_WRITE_AMS_TX_TX_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_TX_TX_STSr,_r._ams_tx_tx_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_STSr BCMI_MADURA_AMS_TX_TX_STSr
#define AMS_TX_TX_STSr_SIZE BCMI_MADURA_AMS_TX_TX_STSr_SIZE
typedef BCMI_MADURA_AMS_TX_TX_STSr_t AMS_TX_TX_STSr_t;
#define AMS_TX_TX_STSr_CLR BCMI_MADURA_AMS_TX_TX_STSr_CLR
#define AMS_TX_TX_STSr_SET BCMI_MADURA_AMS_TX_TX_STSr_SET
#define AMS_TX_TX_STSr_GET BCMI_MADURA_AMS_TX_TX_STSr_GET
#define AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET
#define AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET
#define AMS_TX_TX_STSr_AMS_TX_SPARE_STS_13f_GET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_SPARE_STS_13f_GET
#define AMS_TX_TX_STSr_AMS_TX_SPARE_STS_13f_SET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_SPARE_STS_13f_SET
#define AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET
#define AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET
#define AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET
#define AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET
#define AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET
#define AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET BCMI_MADURA_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET
#define READ_AMS_TX_TX_STSr BCMI_MADURA_READ_AMS_TX_TX_STSr
#define WRITE_AMS_TX_TX_STSr BCMI_MADURA_WRITE_AMS_TX_TX_STSr
#define MODIFY_AMS_TX_TX_STSr BCMI_MADURA_MODIFY_AMS_TX_TX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_TX_TX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_CTL0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e0
 * DEVAD:    1
 * DESC:     SIGDET_CTRL_0
 * RESETVAL: 0x1109 (4361)
 * ACCESS:   R/W
 * FIELDS:
 *     SIGNAL_DETECT_FILTER_COUNT Defines the width of the signal_detect==1'b1 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 *     LOS_FILTER_COUNT Defines the width of the signal_detect==1'b0 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 */
#define BCMI_MADURA_SIGDET_CTL0r (0x0001d0e0 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL0.
 */
typedef union BCMI_MADURA_SIGDET_CTL0r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl0[1];
	uint32_t _sigdet_ctl0;
} BCMI_MADURA_SIGDET_CTL0r_t;

#define BCMI_MADURA_SIGDET_CTL0r_CLR(r) (r).sigdet_ctl0[0] = 0
#define BCMI_MADURA_SIGDET_CTL0r_SET(r,d) (r).sigdet_ctl0[0] = d
#define BCMI_MADURA_SIGDET_CTL0r_GET(r) (r).sigdet_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET(r) ((((r).sigdet_ctl0[0]) >> 8) & 0x1f)
#define BCMI_MADURA_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET(r) (((r).sigdet_ctl0[0]) & 0x1f)
#define BCMI_MADURA_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SIGDET_CTL0.
 */
#define BCMI_MADURA_READ_SIGDET_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_CTL0r,_r._sigdet_ctl0)
#define BCMI_MADURA_WRITE_SIGDET_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_CTL0r,_r._sigdet_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL0r BCMI_MADURA_SIGDET_CTL0r
#define SIGDET_CTL0r_SIZE BCMI_MADURA_SIGDET_CTL0r_SIZE
typedef BCMI_MADURA_SIGDET_CTL0r_t SIGDET_CTL0r_t;
#define SIGDET_CTL0r_CLR BCMI_MADURA_SIGDET_CTL0r_CLR
#define SIGDET_CTL0r_SET BCMI_MADURA_SIGDET_CTL0r_SET
#define SIGDET_CTL0r_GET BCMI_MADURA_SIGDET_CTL0r_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_GET BCMI_MADURA_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_SET BCMI_MADURA_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET BCMI_MADURA_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET BCMI_MADURA_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET
#define READ_SIGDET_CTL0r BCMI_MADURA_READ_SIGDET_CTL0r
#define WRITE_SIGDET_CTL0r BCMI_MADURA_WRITE_SIGDET_CTL0r
#define MODIFY_SIGDET_CTL0r BCMI_MADURA_MODIFY_SIGDET_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_CTL1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e1
 * DEVAD:    1
 * DESC:     SIGDET_CTRL_1
 * RESETVAL: 0xa008 (40968)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_SIGNAL_DETECT_DIS 1'b1 will disable the signal_detect from AFE.
 *     EXT_LOS_EN       1'b1 will enable the external (optical) LOS path into the sigdet filter.
 *     EXT_LOS_INV      1'b1 will invert the polarity of the pmd_ext_los pin.
 *     IGNORE_LP_MODE   1'b1 will ignore the pmd_rx_mode (low power mode) input pin. Set to 1'b0 if EEE mode is supported by the PCS
 *     SIGNAL_DETECT_FILTER_1US 1'b1 will use 1us heartbeat for los_count counter instead of comclk.
 *     ENERGY_DETECT_FRC pmd_energy_detect Force.
 *     ENERGY_DETECT_FRC_VAL pmd_energy_detect Force Value.
 *     SIGNAL_DETECT_FRC pmd_signal_detect Force.
 *     SIGNAL_DETECT_FRC_VAL pmd_signal_detect Force Value.
 *     ENERGY_DETECT_MASK_COUNT Defines the mask_count timer for energy_detect. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 */
#define BCMI_MADURA_SIGDET_CTL1r (0x0001d0e1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL1.
 */
typedef union BCMI_MADURA_SIGDET_CTL1r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl1[1];
	uint32_t _sigdet_ctl1;
} BCMI_MADURA_SIGDET_CTL1r_t;

#define BCMI_MADURA_SIGDET_CTL1r_CLR(r) (r).sigdet_ctl1[0] = 0
#define BCMI_MADURA_SIGDET_CTL1r_SET(r,d) (r).sigdet_ctl1[0] = d
#define BCMI_MADURA_SIGDET_CTL1r_GET(r) (r).sigdet_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET(r) ((((r).sigdet_ctl1[0]) >> 11) & 0x1f)
#define BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 8) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 7) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 6) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 5) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET(r) ((((r).sigdet_ctl1[0]) >> 4) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SIGDET_CTL1r_IGNORE_LP_MODEf_GET(r) ((((r).sigdet_ctl1[0]) >> 3) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_IGNORE_LP_MODEf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_INVf_GET(r) ((((r).sigdet_ctl1[0]) >> 2) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_INVf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_ENf_GET(r) ((((r).sigdet_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_ENf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET(r) (((r).sigdet_ctl1[0]) & 0x1)
#define BCMI_MADURA_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_CTL1.
 */
#define BCMI_MADURA_READ_SIGDET_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_CTL1r,_r._sigdet_ctl1)
#define BCMI_MADURA_WRITE_SIGDET_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_CTL1r,_r._sigdet_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL1r BCMI_MADURA_SIGDET_CTL1r
#define SIGDET_CTL1r_SIZE BCMI_MADURA_SIGDET_CTL1r_SIZE
typedef BCMI_MADURA_SIGDET_CTL1r_t SIGDET_CTL1r_t;
#define SIGDET_CTL1r_CLR BCMI_MADURA_SIGDET_CTL1r_CLR
#define SIGDET_CTL1r_SET BCMI_MADURA_SIGDET_CTL1r_SET
#define SIGDET_CTL1r_GET BCMI_MADURA_SIGDET_CTL1r_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET BCMI_MADURA_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET BCMI_MADURA_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_GET BCMI_MADURA_SIGDET_CTL1r_IGNORE_LP_MODEf_GET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_SET BCMI_MADURA_SIGDET_CTL1r_IGNORE_LP_MODEf_SET
#define SIGDET_CTL1r_EXT_LOS_INVf_GET BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_INVf_GET
#define SIGDET_CTL1r_EXT_LOS_INVf_SET BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_INVf_SET
#define SIGDET_CTL1r_EXT_LOS_ENf_GET BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_ENf_GET
#define SIGDET_CTL1r_EXT_LOS_ENf_SET BCMI_MADURA_SIGDET_CTL1r_EXT_LOS_ENf_SET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET BCMI_MADURA_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET BCMI_MADURA_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET
#define READ_SIGDET_CTL1r BCMI_MADURA_READ_SIGDET_CTL1r
#define WRITE_SIGDET_CTL1r BCMI_MADURA_WRITE_SIGDET_CTL1r
#define MODIFY_SIGDET_CTL1r BCMI_MADURA_MODIFY_SIGDET_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_CTL2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e2
 * DEVAD:    1
 * DESC:     SIGDET_CTRL_2
 * RESETVAL: 0x3f22 (16162)
 * ACCESS:   R/W
 * FIELDS:
 *     LOS_THRESH       AFE signal detect threshold to be used when filtered signal_detect == 1.
 *     SIGNAL_DETECT_THRESH AFE signal detect threshold to be used when filtered signal_detect == 0.
 *     HOLD_LOS_COUNT   HOLD_LOS state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 *     HOLD_SD_COUNT    HOLD_SD state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 */
#define BCMI_MADURA_SIGDET_CTL2r (0x0001d0e2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL2.
 */
typedef union BCMI_MADURA_SIGDET_CTL2r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl2[1];
	uint32_t _sigdet_ctl2;
} BCMI_MADURA_SIGDET_CTL2r_t;

#define BCMI_MADURA_SIGDET_CTL2r_CLR(r) (r).sigdet_ctl2[0] = 0
#define BCMI_MADURA_SIGDET_CTL2r_SET(r,d) (r).sigdet_ctl2[0] = d
#define BCMI_MADURA_SIGDET_CTL2r_GET(r) (r).sigdet_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_CTL2r_HOLD_SD_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 11) & 0x7)
#define BCMI_MADURA_SIGDET_CTL2r_HOLD_SD_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_MADURA_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 8) & 0x7)
#define BCMI_MADURA_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_MADURA_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET(r) ((((r).sigdet_ctl2[0]) >> 4) & 0x7)
#define BCMI_MADURA_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_SIGDET_CTL2r_LOS_THRESHf_GET(r) (((r).sigdet_ctl2[0]) & 0x7)
#define BCMI_MADURA_SIGDET_CTL2r_LOS_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SIGDET_CTL2.
 */
#define BCMI_MADURA_READ_SIGDET_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_CTL2r,_r._sigdet_ctl2)
#define BCMI_MADURA_WRITE_SIGDET_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_CTL2r,_r._sigdet_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL2r BCMI_MADURA_SIGDET_CTL2r
#define SIGDET_CTL2r_SIZE BCMI_MADURA_SIGDET_CTL2r_SIZE
typedef BCMI_MADURA_SIGDET_CTL2r_t SIGDET_CTL2r_t;
#define SIGDET_CTL2r_CLR BCMI_MADURA_SIGDET_CTL2r_CLR
#define SIGDET_CTL2r_SET BCMI_MADURA_SIGDET_CTL2r_SET
#define SIGDET_CTL2r_GET BCMI_MADURA_SIGDET_CTL2r_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_GET BCMI_MADURA_SIGDET_CTL2r_HOLD_SD_COUNTf_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_SET BCMI_MADURA_SIGDET_CTL2r_HOLD_SD_COUNTf_SET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_GET BCMI_MADURA_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_SET BCMI_MADURA_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET BCMI_MADURA_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET BCMI_MADURA_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET
#define SIGDET_CTL2r_LOS_THRESHf_GET BCMI_MADURA_SIGDET_CTL2r_LOS_THRESHf_GET
#define SIGDET_CTL2r_LOS_THRESHf_SET BCMI_MADURA_SIGDET_CTL2r_LOS_THRESHf_SET
#define READ_SIGDET_CTL2r BCMI_MADURA_READ_SIGDET_CTL2r
#define WRITE_SIGDET_CTL2r BCMI_MADURA_WRITE_SIGDET_CTL2r
#define MODIFY_SIGDET_CTL2r BCMI_MADURA_MODIFY_SIGDET_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_STS0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e8
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SIGNAL_DETECT    Filtered version of Signal Detect after frc/frc_val.
 *     SIGNAL_DETECT_CHANGE This latches the transition on signal_detect and cleared on read.
 *     SIGNAL_DETECT_RAW Raw version of Signal Detect going into the filter.
 *     SIGNAL_DETECT_RAW_CHANGE This latches the transition on signal_detect_raw and cleared on read.
 *     EXT_SIGDET       External LOS/sigdet from the pin going into the sigdet filter.
 *     EXT_SIGDET_CHANGE This latches the transition on ext_sigdet and cleared on read.
 *     AFE_SIGDET       Internal sigdet from the AFE sigdet block going into the sigdet filter.
 *     AFE_SIGDET_CHANGE This latches the transition on afe_sigdet and cleared on read.
 */
#define BCMI_MADURA_SIGDET_STS0r (0x0001d0e8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_STS0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS0.
 */
typedef union BCMI_MADURA_SIGDET_STS0r_s {
	uint32_t v[1];
	uint32_t sigdet_sts0[1];
	uint32_t _sigdet_sts0;
} BCMI_MADURA_SIGDET_STS0r_t;

#define BCMI_MADURA_SIGDET_STS0r_CLR(r) (r).sigdet_sts0[0] = 0
#define BCMI_MADURA_SIGDET_STS0r_SET(r,d) (r).sigdet_sts0[0] = d
#define BCMI_MADURA_SIGDET_STS0r_GET(r) (r).sigdet_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 9) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_SIGDET_STS0r_AFE_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 8) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_AFE_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 7) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_SIGDET_STS0r_EXT_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 6) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_EXT_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 5) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET(r) ((((r).sigdet_sts0[0]) >> 4) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 1) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts0[0]) & 0x1)
#define BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS0.
 */
#define BCMI_MADURA_READ_SIGDET_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_STS0r,_r._sigdet_sts0)
#define BCMI_MADURA_WRITE_SIGDET_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_STS0r,_r._sigdet_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS0r BCMI_MADURA_SIGDET_STS0r
#define SIGDET_STS0r_SIZE BCMI_MADURA_SIGDET_STS0r_SIZE
typedef BCMI_MADURA_SIGDET_STS0r_t SIGDET_STS0r_t;
#define SIGDET_STS0r_CLR BCMI_MADURA_SIGDET_STS0r_CLR
#define SIGDET_STS0r_SET BCMI_MADURA_SIGDET_STS0r_SET
#define SIGDET_STS0r_GET BCMI_MADURA_SIGDET_STS0r_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET BCMI_MADURA_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET BCMI_MADURA_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_AFE_SIGDETf_GET BCMI_MADURA_SIGDET_STS0r_AFE_SIGDETf_GET
#define SIGDET_STS0r_AFE_SIGDETf_SET BCMI_MADURA_SIGDET_STS0r_AFE_SIGDETf_SET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET BCMI_MADURA_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET BCMI_MADURA_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_EXT_SIGDETf_GET BCMI_MADURA_SIGDET_STS0r_EXT_SIGDETf_GET
#define SIGDET_STS0r_EXT_SIGDETf_SET BCMI_MADURA_SIGDET_STS0r_EXT_SIGDETf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECTf_GET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECTf_GET
#define SIGDET_STS0r_SIGNAL_DETECTf_SET BCMI_MADURA_SIGDET_STS0r_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS0r BCMI_MADURA_READ_SIGDET_STS0r
#define WRITE_SIGDET_STS0r BCMI_MADURA_WRITE_SIGDET_STS0r
#define MODIFY_SIGDET_STS0r BCMI_MADURA_MODIFY_SIGDET_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_STS1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e9
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UC_SIGNAL_DETECT Filtered version of Signal Detect after frc/frc_val.
 *     UC_SIGNAL_DETECT_CHANGE This latches the transition on uc_signal_detect and cleared on read.
 *     UC_EXT_SIGDET    External LOS/sigdet from the pin going into the sigdet filter.
 *     UC_EXT_SIGDET_CHANGE This latches the transition on uc_ext_sigdet and cleared on read.
 *     UC_AFE_SIGDET    Internal sigdet from the AFE sigdet block going into the sigdet filter.
 *     UC_AFE_SIGDET_CHANGE This latches the transition on uc_afe_sigdet and cleared on read.
 */
#define BCMI_MADURA_SIGDET_STS1r (0x0001d0e9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_STS1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS1.
 */
typedef union BCMI_MADURA_SIGDET_STS1r_s {
	uint32_t v[1];
	uint32_t sigdet_sts1[1];
	uint32_t _sigdet_sts1;
} BCMI_MADURA_SIGDET_STS1r_t;

#define BCMI_MADURA_SIGDET_STS1r_CLR(r) (r).sigdet_sts1[0] = 0
#define BCMI_MADURA_SIGDET_STS1r_SET(r,d) (r).sigdet_sts1[0] = d
#define BCMI_MADURA_SIGDET_STS1r_GET(r) (r).sigdet_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 9) & 0x1)
#define BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDETf_GET(r) ((((r).sigdet_sts1[0]) >> 8) & 0x1)
#define BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDETf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 7) & 0x1)
#define BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDETf_GET(r) ((((r).sigdet_sts1[0]) >> 6) & 0x1)
#define BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDETf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts1[0]) >> 1) & 0x1)
#define BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts1[0]) & 0x1)
#define BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts1[0]=(((r).sigdet_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS1.
 */
#define BCMI_MADURA_READ_SIGDET_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_STS1r,_r._sigdet_sts1)
#define BCMI_MADURA_WRITE_SIGDET_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_STS1r,_r._sigdet_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS1r BCMI_MADURA_SIGDET_STS1r
#define SIGDET_STS1r_SIZE BCMI_MADURA_SIGDET_STS1r_SIZE
typedef BCMI_MADURA_SIGDET_STS1r_t SIGDET_STS1r_t;
#define SIGDET_STS1r_CLR BCMI_MADURA_SIGDET_STS1r_CLR
#define SIGDET_STS1r_SET BCMI_MADURA_SIGDET_STS1r_SET
#define SIGDET_STS1r_GET BCMI_MADURA_SIGDET_STS1r_GET
#define SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_GET
#define SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDET_CHANGEf_SET
#define SIGDET_STS1r_UC_AFE_SIGDETf_GET BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDETf_GET
#define SIGDET_STS1r_UC_AFE_SIGDETf_SET BCMI_MADURA_SIGDET_STS1r_UC_AFE_SIGDETf_SET
#define SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_GET
#define SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDET_CHANGEf_SET
#define SIGDET_STS1r_UC_EXT_SIGDETf_GET BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDETf_GET
#define SIGDET_STS1r_UC_EXT_SIGDETf_SET BCMI_MADURA_SIGDET_STS1r_UC_EXT_SIGDETf_SET
#define SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS1r_UC_SIGNAL_DETECTf_GET BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECTf_GET
#define SIGDET_STS1r_UC_SIGNAL_DETECTf_SET BCMI_MADURA_SIGDET_STS1r_UC_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS1r BCMI_MADURA_READ_SIGDET_STS1r
#define WRITE_SIGDET_STS1r BCMI_MADURA_WRITE_SIGDET_STS1r
#define MODIFY_SIGDET_STS1r BCMI_MADURA_MODIFY_SIGDET_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_STS2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0ea
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     ENERGY_DETECT    Filtered version of Energy Detect after frc/frc_val.
 *     ENERGY_DETECT_CHANGE This latches the transition on energy_detect and cleared on read.
 */
#define BCMI_MADURA_SIGDET_STS2r (0x0001d0ea | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_STS2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS2.
 */
typedef union BCMI_MADURA_SIGDET_STS2r_s {
	uint32_t v[1];
	uint32_t sigdet_sts2[1];
	uint32_t _sigdet_sts2;
} BCMI_MADURA_SIGDET_STS2r_t;

#define BCMI_MADURA_SIGDET_STS2r_CLR(r) (r).sigdet_sts2[0] = 0
#define BCMI_MADURA_SIGDET_STS2r_SET(r,d) (r).sigdet_sts2[0] = d
#define BCMI_MADURA_SIGDET_STS2r_GET(r) (r).sigdet_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts2[0]) >> 1) & 0x1)
#define BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts2[0]=(((r).sigdet_sts2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECTf_GET(r) (((r).sigdet_sts2[0]) & 0x1)
#define BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECTf_SET(r,f) (r).sigdet_sts2[0]=(((r).sigdet_sts2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS2.
 */
#define BCMI_MADURA_READ_SIGDET_STS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_STS2r,_r._sigdet_sts2)
#define BCMI_MADURA_WRITE_SIGDET_STS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_STS2r,_r._sigdet_sts2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS2r BCMI_MADURA_SIGDET_STS2r
#define SIGDET_STS2r_SIZE BCMI_MADURA_SIGDET_STS2r_SIZE
typedef BCMI_MADURA_SIGDET_STS2r_t SIGDET_STS2r_t;
#define SIGDET_STS2r_CLR BCMI_MADURA_SIGDET_STS2r_CLR
#define SIGDET_STS2r_SET BCMI_MADURA_SIGDET_STS2r_SET
#define SIGDET_STS2r_GET BCMI_MADURA_SIGDET_STS2r_GET
#define SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_GET
#define SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECT_CHANGEf_SET
#define SIGDET_STS2r_ENERGY_DETECTf_GET BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECTf_GET
#define SIGDET_STS2r_ENERGY_DETECTf_SET BCMI_MADURA_SIGDET_STS2r_ENERGY_DETECTf_SET
#define READ_SIGDET_STS2r BCMI_MADURA_READ_SIGDET_STS2r
#define WRITE_SIGDET_STS2r BCMI_MADURA_WRITE_SIGDET_STS2r
#define MODIFY_SIGDET_STS2r BCMI_MADURA_MODIFY_SIGDET_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_STS3
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0eb
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_SIGNAL_DETECT Filtered version of Signal Detect after frc/frc_val.
 */
#define BCMI_MADURA_SIGDET_STS3r (0x0001d0eb | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_STS3r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS3.
 */
typedef union BCMI_MADURA_SIGDET_STS3r_s {
	uint32_t v[1];
	uint32_t sigdet_sts3[1];
	uint32_t _sigdet_sts3;
} BCMI_MADURA_SIGDET_STS3r_t;

#define BCMI_MADURA_SIGDET_STS3r_CLR(r) (r).sigdet_sts3[0] = 0
#define BCMI_MADURA_SIGDET_STS3r_SET(r,d) (r).sigdet_sts3[0] = d
#define BCMI_MADURA_SIGDET_STS3r_GET(r) (r).sigdet_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts3[0]) & 0x1)
#define BCMI_MADURA_SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts3[0]=(((r).sigdet_sts3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS3.
 */
#define BCMI_MADURA_READ_SIGDET_STS3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_STS3r,_r._sigdet_sts3)
#define BCMI_MADURA_WRITE_SIGDET_STS3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_STS3r,_r._sigdet_sts3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS3r BCMI_MADURA_SIGDET_STS3r
#define SIGDET_STS3r_SIZE BCMI_MADURA_SIGDET_STS3r_SIZE
typedef BCMI_MADURA_SIGDET_STS3r_t SIGDET_STS3r_t;
#define SIGDET_STS3r_CLR BCMI_MADURA_SIGDET_STS3r_CLR
#define SIGDET_STS3r_SET BCMI_MADURA_SIGDET_STS3r_SET
#define SIGDET_STS3r_GET BCMI_MADURA_SIGDET_STS3r_GET
#define SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET BCMI_MADURA_SIGDET_STS3r_PMD_SIGNAL_DETECTf_GET
#define SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET BCMI_MADURA_SIGDET_STS3r_PMD_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS3r BCMI_MADURA_READ_SIGDET_STS3r
#define WRITE_SIGDET_STS3r BCMI_MADURA_WRITE_SIGDET_STS3r
#define MODIFY_SIGDET_STS3r BCMI_MADURA_MODIFY_SIGDET_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  SIGDET_STS4
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0ec
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_4
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_SIGDET_THRESH Live status of sigdet_thresh going to AFE.
 */
#define BCMI_MADURA_SIGDET_STS4r (0x0001d0ec | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_SIGDET_STS4r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS4.
 */
typedef union BCMI_MADURA_SIGDET_STS4r_s {
	uint32_t v[1];
	uint32_t sigdet_sts4[1];
	uint32_t _sigdet_sts4;
} BCMI_MADURA_SIGDET_STS4r_t;

#define BCMI_MADURA_SIGDET_STS4r_CLR(r) (r).sigdet_sts4[0] = 0
#define BCMI_MADURA_SIGDET_STS4r_SET(r,d) (r).sigdet_sts4[0] = d
#define BCMI_MADURA_SIGDET_STS4r_GET(r) (r).sigdet_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_SIGDET_STS4r_AFE_SIGDET_THRESHf_GET(r) (((r).sigdet_sts4[0]) & 0x7)
#define BCMI_MADURA_SIGDET_STS4r_AFE_SIGDET_THRESHf_SET(r,f) (r).sigdet_sts4[0]=(((r).sigdet_sts4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SIGDET_STS4.
 */
#define BCMI_MADURA_READ_SIGDET_STS4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_SIGDET_STS4r,_r._sigdet_sts4)
#define BCMI_MADURA_WRITE_SIGDET_STS4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_SIGDET_STS4r,_r._sigdet_sts4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS4r BCMI_MADURA_SIGDET_STS4r
#define SIGDET_STS4r_SIZE BCMI_MADURA_SIGDET_STS4r_SIZE
typedef BCMI_MADURA_SIGDET_STS4r_t SIGDET_STS4r_t;
#define SIGDET_STS4r_CLR BCMI_MADURA_SIGDET_STS4r_CLR
#define SIGDET_STS4r_SET BCMI_MADURA_SIGDET_STS4r_SET
#define SIGDET_STS4r_GET BCMI_MADURA_SIGDET_STS4r_GET
#define SIGDET_STS4r_AFE_SIGDET_THRESHf_GET BCMI_MADURA_SIGDET_STS4r_AFE_SIGDET_THRESHf_GET
#define SIGDET_STS4r_AFE_SIGDET_THRESHf_SET BCMI_MADURA_SIGDET_STS4r_AFE_SIGDET_THRESHf_SET
#define READ_SIGDET_STS4r BCMI_MADURA_READ_SIGDET_STS4r
#define WRITE_SIGDET_STS4r BCMI_MADURA_WRITE_SIGDET_STS4r
#define MODIFY_SIGDET_STS4r BCMI_MADURA_MODIFY_SIGDET_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_SIGDET_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_REVID0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd100
 * DEVAD:    1
 * DESC:     REVID0
 * RESETVAL: 0x2db (731)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_MODEL      model number
 *     REVID_PROCESS    technology process0 = 90nm1 = 65nm2 = 40nm3 = 28nm4 = 20nm5 = 16nm6-7 = reserved
 *     REVID_BONDING    bonding0 = wire bond1 = flip chip2-3 = reserved
 *     REVID_REV_NUMBER Metal mask revision number
 *     REVID_REV_LETTER All layer revision letter0 = revA1 = revB2 = revC3 = revD
 */
#define BCMI_MADURA_DIG_REVID0r (0x0001d100 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_REVID0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID0.
 */
typedef union BCMI_MADURA_DIG_REVID0r_s {
	uint32_t v[1];
	uint32_t dig_revid0[1];
	uint32_t _dig_revid0;
} BCMI_MADURA_DIG_REVID0r_t;

#define BCMI_MADURA_DIG_REVID0r_CLR(r) (r).dig_revid0[0] = 0
#define BCMI_MADURA_DIG_REVID0r_SET(r,d) (r).dig_revid0[0] = d
#define BCMI_MADURA_DIG_REVID0r_GET(r) (r).dig_revid0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_REVID0r_REVID_REV_LETTERf_GET(r) ((((r).dig_revid0[0]) >> 14) & 0x3)
#define BCMI_MADURA_DIG_REVID0r_REVID_REV_LETTERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_DIG_REVID0r_REVID_REV_NUMBERf_GET(r) ((((r).dig_revid0[0]) >> 11) & 0x7)
#define BCMI_MADURA_DIG_REVID0r_REVID_REV_NUMBERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_MADURA_DIG_REVID0r_REVID_BONDINGf_GET(r) ((((r).dig_revid0[0]) >> 9) & 0x3)
#define BCMI_MADURA_DIG_REVID0r_REVID_BONDINGf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_MADURA_DIG_REVID0r_REVID_PROCESSf_GET(r) ((((r).dig_revid0[0]) >> 6) & 0x7)
#define BCMI_MADURA_DIG_REVID0r_REVID_PROCESSf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_MADURA_DIG_REVID0r_REVID_MODELf_GET(r) (((r).dig_revid0[0]) & 0x3f)
#define BCMI_MADURA_DIG_REVID0r_REVID_MODELf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DIG_REVID0.
 */
#define BCMI_MADURA_READ_DIG_REVID0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_REVID0r,_r._dig_revid0)
#define BCMI_MADURA_WRITE_DIG_REVID0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_REVID0r,_r._dig_revid0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID0r BCMI_MADURA_DIG_REVID0r
#define DIG_REVID0r_SIZE BCMI_MADURA_DIG_REVID0r_SIZE
typedef BCMI_MADURA_DIG_REVID0r_t DIG_REVID0r_t;
#define DIG_REVID0r_CLR BCMI_MADURA_DIG_REVID0r_CLR
#define DIG_REVID0r_SET BCMI_MADURA_DIG_REVID0r_SET
#define DIG_REVID0r_GET BCMI_MADURA_DIG_REVID0r_GET
#define DIG_REVID0r_REVID_REV_LETTERf_GET BCMI_MADURA_DIG_REVID0r_REVID_REV_LETTERf_GET
#define DIG_REVID0r_REVID_REV_LETTERf_SET BCMI_MADURA_DIG_REVID0r_REVID_REV_LETTERf_SET
#define DIG_REVID0r_REVID_REV_NUMBERf_GET BCMI_MADURA_DIG_REVID0r_REVID_REV_NUMBERf_GET
#define DIG_REVID0r_REVID_REV_NUMBERf_SET BCMI_MADURA_DIG_REVID0r_REVID_REV_NUMBERf_SET
#define DIG_REVID0r_REVID_BONDINGf_GET BCMI_MADURA_DIG_REVID0r_REVID_BONDINGf_GET
#define DIG_REVID0r_REVID_BONDINGf_SET BCMI_MADURA_DIG_REVID0r_REVID_BONDINGf_SET
#define DIG_REVID0r_REVID_PROCESSf_GET BCMI_MADURA_DIG_REVID0r_REVID_PROCESSf_GET
#define DIG_REVID0r_REVID_PROCESSf_SET BCMI_MADURA_DIG_REVID0r_REVID_PROCESSf_SET
#define DIG_REVID0r_REVID_MODELf_GET BCMI_MADURA_DIG_REVID0r_REVID_MODELf_GET
#define DIG_REVID0r_REVID_MODELf_SET BCMI_MADURA_DIG_REVID0r_REVID_MODELf_SET
#define READ_DIG_REVID0r BCMI_MADURA_READ_DIG_REVID0r
#define WRITE_DIG_REVID0r BCMI_MADURA_WRITE_DIG_REVID0r
#define MODIFY_DIG_REVID0r BCMI_MADURA_MODIFY_DIG_REVID0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_REVID0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_RST_CTL_PMD
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd101
 * DEVAD:    1
 * DESC:     RESET_CONTROL_PMD
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_S_RSTB      Active Low Core Level Soft Reset. If asserted by writing to 1'b0 will reset the whole core.This soft reset is equivalent to the hard reset input pin pmd_por_h_rstb. This regiter bit can only bereset by assertion of the hard reset input pin pmd_por_h_rstb
 */
#define BCMI_MADURA_DIG_RST_CTL_PMDr (0x0001d101 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_RST_CTL_PMDr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_PMD.
 */
typedef union BCMI_MADURA_DIG_RST_CTL_PMDr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_pmd[1];
	uint32_t _dig_rst_ctl_pmd;
} BCMI_MADURA_DIG_RST_CTL_PMDr_t;

#define BCMI_MADURA_DIG_RST_CTL_PMDr_CLR(r) (r).dig_rst_ctl_pmd[0] = 0
#define BCMI_MADURA_DIG_RST_CTL_PMDr_SET(r,d) (r).dig_rst_ctl_pmd[0] = d
#define BCMI_MADURA_DIG_RST_CTL_PMDr_GET(r) (r).dig_rst_ctl_pmd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET(r) (((r).dig_rst_ctl_pmd[0]) & 0x1)
#define BCMI_MADURA_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET(r,f) (r).dig_rst_ctl_pmd[0]=(((r).dig_rst_ctl_pmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_RST_CTL_PMD.
 */
#define BCMI_MADURA_READ_DIG_RST_CTL_PMDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_RST_CTL_PMDr,_r._dig_rst_ctl_pmd)
#define BCMI_MADURA_WRITE_DIG_RST_CTL_PMDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_RST_CTL_PMDr,_r._dig_rst_ctl_pmd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_PMDr BCMI_MADURA_DIG_RST_CTL_PMDr
#define DIG_RST_CTL_PMDr_SIZE BCMI_MADURA_DIG_RST_CTL_PMDr_SIZE
typedef BCMI_MADURA_DIG_RST_CTL_PMDr_t DIG_RST_CTL_PMDr_t;
#define DIG_RST_CTL_PMDr_CLR BCMI_MADURA_DIG_RST_CTL_PMDr_CLR
#define DIG_RST_CTL_PMDr_SET BCMI_MADURA_DIG_RST_CTL_PMDr_SET
#define DIG_RST_CTL_PMDr_GET BCMI_MADURA_DIG_RST_CTL_PMDr_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET BCMI_MADURA_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET BCMI_MADURA_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET
#define READ_DIG_RST_CTL_PMDr BCMI_MADURA_READ_DIG_RST_CTL_PMDr
#define WRITE_DIG_RST_CTL_PMDr BCMI_MADURA_WRITE_DIG_RST_CTL_PMDr
#define MODIFY_DIG_RST_CTL_PMDr BCMI_MADURA_MODIFY_DIG_RST_CTL_PMDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_RST_CTL_PMDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_RST_CTL_CORE_DP
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd102
 * DEVAD:    1
 * DESC:     RESET_CONTROL_CORE_DP
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SUP_RST_SEQ_FRC_VAL Suppress reset sequence force value.
 *     SUP_RST_SEQ_FRC  Suppress reset sequence force.
 *     PMD_MDIO_TRANS_PKILL 1'b1 will disable the pmd_mdio_trans pin.
 *     DISABLE_ACK_TIMEOUT Setting this bit to 1 disables the ack timeout for all ports.
 */
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr (0x0001d102 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_CORE_DP.
 */
typedef union BCMI_MADURA_DIG_RST_CTL_CORE_DPr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_core_dp[1];
	uint32_t _dig_rst_ctl_core_dp;
} BCMI_MADURA_DIG_RST_CTL_CORE_DPr_t;

#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_CLR(r) (r).dig_rst_ctl_core_dp[0] = 0
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SET(r,d) (r).dig_rst_ctl_core_dp[0] = d
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_GET(r) (r).dig_rst_ctl_core_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 15) & 0x1)
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 5) & 0x1)
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 4) & 0x1)
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 3) & 0x1)
#define BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))

/*
 * These macros can be used to access DIG_RST_CTL_CORE_DP.
 */
#define BCMI_MADURA_READ_DIG_RST_CTL_CORE_DPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_RST_CTL_CORE_DPr,_r._dig_rst_ctl_core_dp)
#define BCMI_MADURA_WRITE_DIG_RST_CTL_CORE_DPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_RST_CTL_CORE_DPr,_r._dig_rst_ctl_core_dp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_CORE_DPr BCMI_MADURA_DIG_RST_CTL_CORE_DPr
#define DIG_RST_CTL_CORE_DPr_SIZE BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SIZE
typedef BCMI_MADURA_DIG_RST_CTL_CORE_DPr_t DIG_RST_CTL_CORE_DPr_t;
#define DIG_RST_CTL_CORE_DPr_CLR BCMI_MADURA_DIG_RST_CTL_CORE_DPr_CLR
#define DIG_RST_CTL_CORE_DPr_SET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SET
#define DIG_RST_CTL_CORE_DPr_GET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_GET
#define DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET
#define DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET BCMI_MADURA_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET
#define READ_DIG_RST_CTL_CORE_DPr BCMI_MADURA_READ_DIG_RST_CTL_CORE_DPr
#define WRITE_DIG_RST_CTL_CORE_DPr BCMI_MADURA_WRITE_DIG_RST_CTL_CORE_DPr
#define MODIFY_DIG_RST_CTL_CORE_DPr BCMI_MADURA_MODIFY_DIG_RST_CTL_CORE_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_RST_CTL_CORE_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_MASKDATA
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd103
 * DEVAD:    1
 * DESC:     MASKDATA_REG
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MASKDATA         maskdata for writes that can be used with any PMI port (PMI_HP, PMI_LP or PMI_MDIO). This register will get reset to 0 after each transaction.
 */
#define BCMI_MADURA_DIG_MASKDATAr (0x0001d103 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_MASKDATAr_SIZE 4

/*
 * This structure should be used to declare and program DIG_MASKDATA.
 */
typedef union BCMI_MADURA_DIG_MASKDATAr_s {
	uint32_t v[1];
	uint32_t dig_maskdata[1];
	uint32_t _dig_maskdata;
} BCMI_MADURA_DIG_MASKDATAr_t;

#define BCMI_MADURA_DIG_MASKDATAr_CLR(r) (r).dig_maskdata[0] = 0
#define BCMI_MADURA_DIG_MASKDATAr_SET(r,d) (r).dig_maskdata[0] = d
#define BCMI_MADURA_DIG_MASKDATAr_GET(r) (r).dig_maskdata[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_MASKDATAr_MASKDATAf_GET(r) (((r).dig_maskdata[0]) & 0xffff)
#define BCMI_MADURA_DIG_MASKDATAr_MASKDATAf_SET(r,f) (r).dig_maskdata[0]=(((r).dig_maskdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DIG_MASKDATA.
 */
#define BCMI_MADURA_READ_DIG_MASKDATAr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_MASKDATAr,_r._dig_maskdata)
#define BCMI_MADURA_WRITE_DIG_MASKDATAr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_MASKDATAr,_r._dig_maskdata)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_MASKDATAr BCMI_MADURA_DIG_MASKDATAr
#define DIG_MASKDATAr_SIZE BCMI_MADURA_DIG_MASKDATAr_SIZE
typedef BCMI_MADURA_DIG_MASKDATAr_t DIG_MASKDATAr_t;
#define DIG_MASKDATAr_CLR BCMI_MADURA_DIG_MASKDATAr_CLR
#define DIG_MASKDATAr_SET BCMI_MADURA_DIG_MASKDATAr_SET
#define DIG_MASKDATAr_GET BCMI_MADURA_DIG_MASKDATAr_GET
#define DIG_MASKDATAr_MASKDATAf_GET BCMI_MADURA_DIG_MASKDATAr_MASKDATAf_GET
#define DIG_MASKDATAr_MASKDATAf_SET BCMI_MADURA_DIG_MASKDATAr_MASKDATAf_SET
#define READ_DIG_MASKDATAr BCMI_MADURA_READ_DIG_MASKDATAr
#define WRITE_DIG_MASKDATAr BCMI_MADURA_WRITE_DIG_MASKDATAr
#define MODIFY_DIG_MASKDATAr BCMI_MADURA_MODIFY_DIG_MASKDATAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_MASKDATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_TOP_USER_CTL0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd104
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL_0
 * RESETVAL: 0x271 (625)
 * ACCESS:   R/W
 * FIELDS:
 *     HEARTBEAT_COUNT_1US Heartbeat timer count in comclk cycles to create 1us heartbeat_1us period. It should be programmed to the nearest increment of 0.25Mhz value of the comclk frequency in Mhz.For example, for comclk of 125 Mhz, it should be programmed to 10'd500. For 156.25 Mhz comclk, it should be programmed to 10'd625 and similarly for any other comclk frequency.
 *     MASKDATA_BUS_ASSIGN This 2-bit register is used to assign the maskdata bus to any port .00: maskdata register is assigned to MDIO port01: maskdata register is assigned to PMI_HP port10: maskdata register is assigned to PMI_LP port11: maskdata register is not assigned to any port
 *     UC_ACTIVE        When set to 1'b1 then Hardware should wait for uC handshakes to wake up from datapath resetWhen set to 1'b0 then Hardware can internally assume that uc_ack_* = 1.
 */
#define BCMI_MADURA_DIG_TOP_USER_CTL0r (0x0001d104 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_TOP_USER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TOP_USER_CTL0.
 */
typedef union BCMI_MADURA_DIG_TOP_USER_CTL0r_s {
	uint32_t v[1];
	uint32_t dig_top_user_ctl0[1];
	uint32_t _dig_top_user_ctl0;
} BCMI_MADURA_DIG_TOP_USER_CTL0r_t;

#define BCMI_MADURA_DIG_TOP_USER_CTL0r_CLR(r) (r).dig_top_user_ctl0[0] = 0
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_SET(r,d) (r).dig_top_user_ctl0[0] = d
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_GET(r) (r).dig_top_user_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 15) & 0x1)
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 10) & 0x3)
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET(r) (((r).dig_top_user_ctl0[0]) & 0x3ff)
#define BCMI_MADURA_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DIG_TOP_USER_CTL0.
 */
#define BCMI_MADURA_READ_DIG_TOP_USER_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_TOP_USER_CTL0r,_r._dig_top_user_ctl0)
#define BCMI_MADURA_WRITE_DIG_TOP_USER_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_TOP_USER_CTL0r,_r._dig_top_user_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_TOP_USER_CTL0r BCMI_MADURA_DIG_TOP_USER_CTL0r
#define DIG_TOP_USER_CTL0r_SIZE BCMI_MADURA_DIG_TOP_USER_CTL0r_SIZE
typedef BCMI_MADURA_DIG_TOP_USER_CTL0r_t DIG_TOP_USER_CTL0r_t;
#define DIG_TOP_USER_CTL0r_CLR BCMI_MADURA_DIG_TOP_USER_CTL0r_CLR
#define DIG_TOP_USER_CTL0r_SET BCMI_MADURA_DIG_TOP_USER_CTL0r_SET
#define DIG_TOP_USER_CTL0r_GET BCMI_MADURA_DIG_TOP_USER_CTL0r_GET
#define DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET BCMI_MADURA_DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET
#define DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET BCMI_MADURA_DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET
#define DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET BCMI_MADURA_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET
#define DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET BCMI_MADURA_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET BCMI_MADURA_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET BCMI_MADURA_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET
#define READ_DIG_TOP_USER_CTL0r BCMI_MADURA_READ_DIG_TOP_USER_CTL0r
#define WRITE_DIG_TOP_USER_CTL0r BCMI_MADURA_WRITE_DIG_TOP_USER_CTL0r
#define MODIFY_DIG_TOP_USER_CTL0r BCMI_MADURA_MODIFY_DIG_TOP_USER_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_TOP_USER_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_CORE_RST_OCC_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd106
 * DEVAD:    1
 * DESC:     CORE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_REG_RESET_OCCURRED Set to 1'b1 upon core level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_MADURA_DIG_CORE_RST_OCC_CTLr (0x0001d106 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_RST_OCC_CTL.
 */
typedef union BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t dig_core_rst_occ_ctl[1];
	uint32_t _dig_core_rst_occ_ctl;
} BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_t;

#define BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_CLR(r) (r).dig_core_rst_occ_ctl[0] = 0
#define BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_SET(r,d) (r).dig_core_rst_occ_ctl[0] = d
#define BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_GET(r) (r).dig_core_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET(r) (((r).dig_core_rst_occ_ctl[0]) & 0x1)
#define BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET(r,f) (r).dig_core_rst_occ_ctl[0]=(((r).dig_core_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_CORE_RST_OCC_CTL.
 */
#define BCMI_MADURA_READ_DIG_CORE_RST_OCC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_CORE_RST_OCC_CTLr,_r._dig_core_rst_occ_ctl)
#define BCMI_MADURA_WRITE_DIG_CORE_RST_OCC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_CORE_RST_OCC_CTLr,_r._dig_core_rst_occ_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_RST_OCC_CTLr BCMI_MADURA_DIG_CORE_RST_OCC_CTLr
#define DIG_CORE_RST_OCC_CTLr_SIZE BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_SIZE
typedef BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_t DIG_CORE_RST_OCC_CTLr_t;
#define DIG_CORE_RST_OCC_CTLr_CLR BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_CLR
#define DIG_CORE_RST_OCC_CTLr_SET BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_SET
#define DIG_CORE_RST_OCC_CTLr_GET BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET BCMI_MADURA_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET
#define READ_DIG_CORE_RST_OCC_CTLr BCMI_MADURA_READ_DIG_CORE_RST_OCC_CTLr
#define WRITE_DIG_CORE_RST_OCC_CTLr BCMI_MADURA_WRITE_DIG_CORE_RST_OCC_CTLr
#define MODIFY_DIG_CORE_RST_OCC_CTLr BCMI_MADURA_MODIFY_DIG_CORE_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_CORE_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_RST_SEQ_TMR_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd107
 * DEVAD:    1
 * DESC:     RST_SEQ_TIMER_CONTROL
 * RESETVAL: 0x8304 (33540)
 * ACCESS:   R/W
 * FIELDS:
 *     RST_SEQ_TIMER    Defines the number of comclk cycles between de-assertion of AFE RX/TX lane reset and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 2 to 16 clock cycles between de-assertion of AFE RX/TX lane resetand clock muxing from comclk to lane clock. Wait_time = 2 * (rst_seq_timer + 1).
 *     PWRDN_SEQ_TIMER  Defines the number of comclk cycles between de-assertion of AFE RX/TX lane pwrdn and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 8 to 64 clock cycles between de-assertion of AFE RX/TX lane pwrdnand clock muxing from comclk to lane clock. Wait_time = 8 * (pwrdn_seq_timer + 1).
 *     RST_SEQ_DIS_FLT_MODE Defines the filter mode for rst_seq_dis/pmd_mdio_trans pin.2'd0 - filter is bypassed where input is passed to output untouched.2'd1 - filter output is 16 comclk cycles if input is > 16 comclk cycles else output is same as input signal.2'd2 - filter output is 20 comclk cycles if input is > 20 comclk cycles else output is same as input signal.2'd3 - filter output is 24 comclk cycles if input is > 24 comclk cycles else output is same as input signal.
 */
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr (0x0001d107 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_SEQ_TMR_CTL.
 */
typedef union BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t dig_rst_seq_tmr_ctl[1];
	uint32_t _dig_rst_seq_tmr_ctl;
} BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_t;

#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_CLR(r) (r).dig_rst_seq_tmr_ctl[0] = 0
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_SET(r,d) (r).dig_rst_seq_tmr_ctl[0] = d
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_GET(r) (r).dig_rst_seq_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 14) & 0x3)
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 8) & 0x7)
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET(r) (((r).dig_rst_seq_tmr_ctl[0]) & 0x7)
#define BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DIG_RST_SEQ_TMR_CTL.
 */
#define BCMI_MADURA_READ_DIG_RST_SEQ_TMR_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr,_r._dig_rst_seq_tmr_ctl)
#define BCMI_MADURA_WRITE_DIG_RST_SEQ_TMR_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr,_r._dig_rst_seq_tmr_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_SEQ_TMR_CTLr BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr
#define DIG_RST_SEQ_TMR_CTLr_SIZE BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_SIZE
typedef BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_t DIG_RST_SEQ_TMR_CTLr_t;
#define DIG_RST_SEQ_TMR_CTLr_CLR BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_CLR
#define DIG_RST_SEQ_TMR_CTLr_SET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_SET
#define DIG_RST_SEQ_TMR_CTLr_GET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET
#define READ_DIG_RST_SEQ_TMR_CTLr BCMI_MADURA_READ_DIG_RST_SEQ_TMR_CTLr
#define WRITE_DIG_RST_SEQ_TMR_CTLr BCMI_MADURA_WRITE_DIG_RST_SEQ_TMR_CTLr
#define MODIFY_DIG_RST_SEQ_TMR_CTLr BCMI_MADURA_MODIFY_DIG_RST_SEQ_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_RST_SEQ_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_CORE_DP_RST_ST_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd108
 * DEVAD:    1
 * DESC:     CORE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_RESET_RELEASED_INDEX Index of the lane number of the first TX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED_INDEX Index of the lane number of the first RX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED indicates if a lane is currently at {rx_lane_dp_reset_active, rx_lane_dp_reset_occurred} = 01.
 *     TX_LANE_RESET_RELEASED indicates if a lane is currently at {tx_lane_dp_reset_active, tx_lane_dp_reset_occurred} = 01.
 */
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr (0x0001d108 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_DP_RST_ST_STS.
 */
typedef union BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t dig_core_dp_rst_st_sts[1];
	uint32_t _dig_core_dp_rst_st_sts;
} BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_t;

#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_CLR(r) (r).dig_core_dp_rst_st_sts[0] = 0
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_SET(r,d) (r).dig_core_dp_rst_st_sts[0] = d
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_GET(r) (r).dig_core_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 15) & 0x1)
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 14) & 0x1)
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 8) & 0x1f)
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 3) & 0x1f)
#define BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))

/*
 * These macros can be used to access DIG_CORE_DP_RST_ST_STS.
 */
#define BCMI_MADURA_READ_DIG_CORE_DP_RST_ST_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr,_r._dig_core_dp_rst_st_sts)
#define BCMI_MADURA_WRITE_DIG_CORE_DP_RST_ST_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr,_r._dig_core_dp_rst_st_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_DP_RST_ST_STSr BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr
#define DIG_CORE_DP_RST_ST_STSr_SIZE BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_SIZE
typedef BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_t DIG_CORE_DP_RST_ST_STSr_t;
#define DIG_CORE_DP_RST_ST_STSr_CLR BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_CLR
#define DIG_CORE_DP_RST_ST_STSr_SET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_SET
#define DIG_CORE_DP_RST_ST_STSr_GET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET
#define READ_DIG_CORE_DP_RST_ST_STSr BCMI_MADURA_READ_DIG_CORE_DP_RST_ST_STSr
#define WRITE_DIG_CORE_DP_RST_ST_STSr BCMI_MADURA_WRITE_DIG_CORE_DP_RST_ST_STSr
#define MODIFY_DIG_CORE_DP_RST_ST_STSr BCMI_MADURA_MODIFY_DIG_CORE_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_CORE_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_PMD_CORE_MODE_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd109
 * DEVAD:    1
 * DESC:     PMD_CORE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_CORE_MODE    This indicates the status of the core input pin pmd_core_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_MADURA_DIG_PMD_CORE_MODE_STSr (0x0001d109 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_PMD_CORE_MODE_STS.
 */
typedef union BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_s {
	uint32_t v[1];
	uint32_t dig_pmd_core_mode_sts[1];
	uint32_t _dig_pmd_core_mode_sts;
} BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_t;

#define BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_CLR(r) (r).dig_pmd_core_mode_sts[0] = 0
#define BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_SET(r,d) (r).dig_pmd_core_mode_sts[0] = d
#define BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_GET(r) (r).dig_pmd_core_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET(r) (((r).dig_pmd_core_mode_sts[0]) & 0xffff)
#define BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET(r,f) (r).dig_pmd_core_mode_sts[0]=(((r).dig_pmd_core_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DIG_PMD_CORE_MODE_STS.
 */
#define BCMI_MADURA_READ_DIG_PMD_CORE_MODE_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_PMD_CORE_MODE_STSr,_r._dig_pmd_core_mode_sts)
#define BCMI_MADURA_WRITE_DIG_PMD_CORE_MODE_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_PMD_CORE_MODE_STSr,_r._dig_pmd_core_mode_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_PMD_CORE_MODE_STSr BCMI_MADURA_DIG_PMD_CORE_MODE_STSr
#define DIG_PMD_CORE_MODE_STSr_SIZE BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_SIZE
typedef BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_t DIG_PMD_CORE_MODE_STSr_t;
#define DIG_PMD_CORE_MODE_STSr_CLR BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_CLR
#define DIG_PMD_CORE_MODE_STSr_SET BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_SET
#define DIG_PMD_CORE_MODE_STSr_GET BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_GET
#define DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET
#define DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET BCMI_MADURA_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET
#define READ_DIG_PMD_CORE_MODE_STSr BCMI_MADURA_READ_DIG_PMD_CORE_MODE_STSr
#define WRITE_DIG_PMD_CORE_MODE_STSr BCMI_MADURA_WRITE_DIG_PMD_CORE_MODE_STSr
#define MODIFY_DIG_PMD_CORE_MODE_STSr BCMI_MADURA_MODIFY_DIG_PMD_CORE_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_PMD_CORE_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_REVID1
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10a
 * DEVAD:    1
 * DESC:     REVID1
 * RESETVAL: 0x403e (16446)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_EEE        EEE support present in core
 *     REVID_LLP        Ultra low latency path present in core
 *     REVID_PIR        PCS interface retiming flops present in core
 *     REVID_CL72       Clause 72 present in core
 *     REVID_MICRO      Microcontroller present in core
 *     REVID_MDIO       MDIO interface present in core
 *     REVID_MULTIPLICITY Number of lanes
 */
#define BCMI_MADURA_DIG_REVID1r (0x0001d10a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_REVID1r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID1.
 */
typedef union BCMI_MADURA_DIG_REVID1r_s {
	uint32_t v[1];
	uint32_t dig_revid1[1];
	uint32_t _dig_revid1;
} BCMI_MADURA_DIG_REVID1r_t;

#define BCMI_MADURA_DIG_REVID1r_CLR(r) (r).dig_revid1[0] = 0
#define BCMI_MADURA_DIG_REVID1r_SET(r,d) (r).dig_revid1[0] = d
#define BCMI_MADURA_DIG_REVID1r_GET(r) (r).dig_revid1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_REVID1r_REVID_MULTIPLICITYf_GET(r) ((((r).dig_revid1[0]) >> 12) & 0xf)
#define BCMI_MADURA_DIG_REVID1r_REVID_MULTIPLICITYf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_DIG_REVID1r_REVID_MDIOf_GET(r) ((((r).dig_revid1[0]) >> 5) & 0x1)
#define BCMI_MADURA_DIG_REVID1r_REVID_MDIOf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_DIG_REVID1r_REVID_MICROf_GET(r) ((((r).dig_revid1[0]) >> 4) & 0x1)
#define BCMI_MADURA_DIG_REVID1r_REVID_MICROf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_DIG_REVID1r_REVID_CL72f_GET(r) ((((r).dig_revid1[0]) >> 3) & 0x1)
#define BCMI_MADURA_DIG_REVID1r_REVID_CL72f_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_DIG_REVID1r_REVID_PIRf_GET(r) ((((r).dig_revid1[0]) >> 2) & 0x1)
#define BCMI_MADURA_DIG_REVID1r_REVID_PIRf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_DIG_REVID1r_REVID_LLPf_GET(r) ((((r).dig_revid1[0]) >> 1) & 0x1)
#define BCMI_MADURA_DIG_REVID1r_REVID_LLPf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_DIG_REVID1r_REVID_EEEf_GET(r) (((r).dig_revid1[0]) & 0x1)
#define BCMI_MADURA_DIG_REVID1r_REVID_EEEf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_REVID1.
 */
#define BCMI_MADURA_READ_DIG_REVID1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_REVID1r,_r._dig_revid1)
#define BCMI_MADURA_WRITE_DIG_REVID1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_REVID1r,_r._dig_revid1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID1r BCMI_MADURA_DIG_REVID1r
#define DIG_REVID1r_SIZE BCMI_MADURA_DIG_REVID1r_SIZE
typedef BCMI_MADURA_DIG_REVID1r_t DIG_REVID1r_t;
#define DIG_REVID1r_CLR BCMI_MADURA_DIG_REVID1r_CLR
#define DIG_REVID1r_SET BCMI_MADURA_DIG_REVID1r_SET
#define DIG_REVID1r_GET BCMI_MADURA_DIG_REVID1r_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_GET BCMI_MADURA_DIG_REVID1r_REVID_MULTIPLICITYf_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_SET BCMI_MADURA_DIG_REVID1r_REVID_MULTIPLICITYf_SET
#define DIG_REVID1r_REVID_MDIOf_GET BCMI_MADURA_DIG_REVID1r_REVID_MDIOf_GET
#define DIG_REVID1r_REVID_MDIOf_SET BCMI_MADURA_DIG_REVID1r_REVID_MDIOf_SET
#define DIG_REVID1r_REVID_MICROf_GET BCMI_MADURA_DIG_REVID1r_REVID_MICROf_GET
#define DIG_REVID1r_REVID_MICROf_SET BCMI_MADURA_DIG_REVID1r_REVID_MICROf_SET
#define DIG_REVID1r_REVID_CL72f_GET BCMI_MADURA_DIG_REVID1r_REVID_CL72f_GET
#define DIG_REVID1r_REVID_CL72f_SET BCMI_MADURA_DIG_REVID1r_REVID_CL72f_SET
#define DIG_REVID1r_REVID_PIRf_GET BCMI_MADURA_DIG_REVID1r_REVID_PIRf_GET
#define DIG_REVID1r_REVID_PIRf_SET BCMI_MADURA_DIG_REVID1r_REVID_PIRf_SET
#define DIG_REVID1r_REVID_LLPf_GET BCMI_MADURA_DIG_REVID1r_REVID_LLPf_GET
#define DIG_REVID1r_REVID_LLPf_SET BCMI_MADURA_DIG_REVID1r_REVID_LLPf_SET
#define DIG_REVID1r_REVID_EEEf_GET BCMI_MADURA_DIG_REVID1r_REVID_EEEf_GET
#define DIG_REVID1r_REVID_EEEf_SET BCMI_MADURA_DIG_REVID1r_REVID_EEEf_SET
#define READ_DIG_REVID1r BCMI_MADURA_READ_DIG_REVID1r
#define WRITE_DIG_REVID1r BCMI_MADURA_WRITE_DIG_REVID1r
#define MODIFY_DIG_REVID1r BCMI_MADURA_MODIFY_DIG_REVID1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_REVID1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  DIG_REVID2
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10e
 * DEVAD:    1
 * DESC:     REVID2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID2           Revision ID2 code
 */
#define BCMI_MADURA_DIG_REVID2r (0x0001d10e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_DIG_REVID2r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID2.
 */
typedef union BCMI_MADURA_DIG_REVID2r_s {
	uint32_t v[1];
	uint32_t dig_revid2[1];
	uint32_t _dig_revid2;
} BCMI_MADURA_DIG_REVID2r_t;

#define BCMI_MADURA_DIG_REVID2r_CLR(r) (r).dig_revid2[0] = 0
#define BCMI_MADURA_DIG_REVID2r_SET(r,d) (r).dig_revid2[0] = d
#define BCMI_MADURA_DIG_REVID2r_GET(r) (r).dig_revid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_DIG_REVID2r_REVID2f_GET(r) (((r).dig_revid2[0]) & 0xf)
#define BCMI_MADURA_DIG_REVID2r_REVID2f_SET(r,f) (r).dig_revid2[0]=(((r).dig_revid2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DIG_REVID2.
 */
#define BCMI_MADURA_READ_DIG_REVID2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_DIG_REVID2r,_r._dig_revid2)
#define BCMI_MADURA_WRITE_DIG_REVID2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_DIG_REVID2r,_r._dig_revid2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID2r BCMI_MADURA_DIG_REVID2r
#define DIG_REVID2r_SIZE BCMI_MADURA_DIG_REVID2r_SIZE
typedef BCMI_MADURA_DIG_REVID2r_t DIG_REVID2r_t;
#define DIG_REVID2r_CLR BCMI_MADURA_DIG_REVID2r_CLR
#define DIG_REVID2r_SET BCMI_MADURA_DIG_REVID2r_SET
#define DIG_REVID2r_GET BCMI_MADURA_DIG_REVID2r_GET
#define DIG_REVID2r_REVID2f_GET BCMI_MADURA_DIG_REVID2r_REVID2f_GET
#define DIG_REVID2r_REVID2f_SET BCMI_MADURA_DIG_REVID2r_REVID2f_SET
#define READ_DIG_REVID2r BCMI_MADURA_READ_DIG_REVID2r
#define WRITE_DIG_REVID2r BCMI_MADURA_WRITE_DIG_REVID2r
#define MODIFY_DIG_REVID2r BCMI_MADURA_MODIFY_DIG_REVID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_DIG_REVID2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL0
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd110
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_SET_CLK4PCS program clk freq for clk4pcs amsbus ctrl_out  1:0DFT_MUX
 *     AMS_PLL_SPARE_7_2 AMS reserved[7:2] amsbus ctrl_out  7:2DFT_MUX=6'd0
 *     AMS_PLL_IMIN_ICLKIDRV1 see AMS amsbus ctrl_out  8:8DFT_MUX
 *     AMS_PLL_IMAX_ICLKIDRV1 see AMS amsbus ctrl_out  9:9DFT_MUX
 *     AMS_PLL_IMODE_ICLKIDRV1 Current control for input CML amsbus ctrl_out  10:10DFT_MUX
 *     AMS_PLL_CAL_OFF  Turns off ResCal, turns on cal_aux[3:0] amsbus ctrl_out  11:11DFT_MUX
 *     AMS_PLL_CAL_AUX  see AMS amsbus ctrl_out  15:12DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r (0x0001d110 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL0.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl0[1];
	uint32_t _ams_pll_pll_ctl0;
} BCMI_MADURA_AMS_PLL_PLL_CTL0r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_CLR(r) (r).ams_pll_pll_ctl0[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_SET(r,d) (r).ams_pll_pll_ctl0[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_GET(r) (r).ams_pll_pll_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_AUXf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 12) & 0xf)
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_AUXf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_OFFf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_OFFf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 9) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_7_2f_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 2) & 0x3f)
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_7_2f_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET(r) (((r).ams_pll_pll_ctl0[0]) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL0.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL0r,_r._ams_pll_pll_ctl0)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL0r,_r._ams_pll_pll_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL0r BCMI_MADURA_AMS_PLL_PLL_CTL0r
#define AMS_PLL_PLL_CTL0r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL0r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL0r_t AMS_PLL_PLL_CTL0r_t;
#define AMS_PLL_PLL_CTL0r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL0r_CLR
#define AMS_PLL_PLL_CTL0r_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_SET
#define AMS_PLL_PLL_CTL0r_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_AUXf_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_AUXf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_AUXf_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_AUXf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_OFFf_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_OFFf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_OFFf_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_CAL_OFFf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_7_2f_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_7_2f_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_7_2f_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SPARE_7_2f_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET BCMI_MADURA_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET
#define READ_AMS_PLL_PLL_CTL0r BCMI_MADURA_READ_AMS_PLL_PLL_CTL0r
#define WRITE_AMS_PLL_PLL_CTL0r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL0r
#define MODIFY_AMS_PLL_PLL_CTL0r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL1
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd111
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_1
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_IMIN_ICKGEN see AMS amsbus ctrl_out  16:16DFT_MUX
 *     AMS_PLL_IMAX_ICKGEN see AMS amsbus ctrl_out  17:17DFT_MUX
 *     AMS_PLL_IMODE_ICKGEN Master current mirror control amsbus ctrl_out  18:18DFT_MUX
 *     AMS_PLL_DRV_HV_DISABLE see AMS amsbus ctrl_out  19:19DFT_MUX
 *     AMS_PLL_TEST_BG_OPAMP_BIAS test BG opamp bias amsbus ctrl_out  21:20DFT_MUX
 *     AMS_PLL_SPARE_22 AMS reserved[22] amsbus ctrl_out  22:22DFT_DFS=1'b0
 *     AMS_PLL_VCO2_15G enable and select the 15-18G VCO amsbus ctrl_out  23:23DFT_MUX
 *     AMS_PLL_VCOICTRL adjusts VCO bias current amsbus ctrl_out  25:24DFT_MUX
 *     AMS_PLL_VCO_INDICATOR enables transformer mode amsbus ctrl_out  26:26DFT_MUX
 *     AMS_PLL_IVCO     see AMS amsbus ctrl_out  29:27DFT_MUX
 *     AMS_PLL_RESET    active high amsbus ctrl_out  30:30DFT_MUX
 *     AMS_PLL_ENABLE_FTUNE see AMS amsbus ctrl_out  31:31DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r (0x0001d111 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL1.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl1[1];
	uint32_t _ams_pll_pll_ctl1;
} BCMI_MADURA_AMS_PLL_PLL_CTL1r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_CLR(r) (r).ams_pll_pll_ctl1[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_SET(r,d) (r).ams_pll_pll_ctl1[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_GET(r) (r).ams_pll_pll_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 11) & 0x7)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 8) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 7) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_22f_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 6) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_22f_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 4) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 3) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 2) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_GET(r) (((r).ams_pll_pll_ctl1[0]) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL1.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL1r,_r._ams_pll_pll_ctl1)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL1r,_r._ams_pll_pll_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL1r BCMI_MADURA_AMS_PLL_PLL_CTL1r
#define AMS_PLL_PLL_CTL1r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL1r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL1r_t AMS_PLL_PLL_CTL1r_t;
#define AMS_PLL_PLL_CTL1r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL1r_CLR
#define AMS_PLL_PLL_CTL1r_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_SET
#define AMS_PLL_PLL_CTL1r_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_22f_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_22f_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_22f_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_SPARE_22f_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_GET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_SET BCMI_MADURA_AMS_PLL_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_SET
#define READ_AMS_PLL_PLL_CTL1r BCMI_MADURA_READ_AMS_PLL_PLL_CTL1r
#define WRITE_AMS_PLL_PLL_CTL1r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL1r
#define MODIFY_AMS_PLL_PLL_CTL1r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL2
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd112
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_2
 * RESETVAL: 0x1e (30)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_EN_HRZ   increases Rz, 2.4K ==> 4.8K amsbus ctrl_out  32:32DFT_MUX
 *     AMS_PLL_IQP      charge pump current, 50,100,150,..800uA amsbus ctrl_out  36:33DFT_MUX
 *     AMS_PLL_REFL_PLL see AMS amsbus ctrl_out  37:37DFT_MUX
 *     AMS_PLL_REFH_PLL see AMS amsbus ctrl_out  38:38DFT_MUX
 *     AMS_PLL_IMIN_IBIAS see AMS amsbus ctrl_out  39:39DFT_MUX
 *     AMS_PLL_IMODE_IBIAS see AMS amsbus ctrl_out  40:40DFT_MUX
 *     AMS_PLL_IMAX_IBIAS ibias all 6 above amsbus ctrl_out  41:41DFT_MUX
 *     AMS_PLL_IMIN_ICP see AMS amsbus ctrl_out  42:42DFT_MUX
 *     AMS_PLL_IMODE_ICP see AMS amsbus ctrl_out  43:43DFT_MUX
 *     AMS_PLL_IMAX_ICP charge pump amsbus ctrl_out  44:44DFT_MUX
 *     AMS_PLL_IMIN_ICK see AMS amsbus ctrl_out  45:45DFT_MUX
 *     AMS_PLL_IMODE_ICK see AMS amsbus ctrl_out  46:46DFT_MUX
 *     AMS_PLL_IMAX_ICK fref buffer amsbus ctrl_out  47:47DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r (0x0001d112 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL2.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl2[1];
	uint32_t _ams_pll_pll_ctl2;
} BCMI_MADURA_AMS_PLL_PLL_CTL2r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_CLR(r) (r).ams_pll_pll_ctl2[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_SET(r,d) (r).ams_pll_pll_ctl2[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_GET(r) (r).ams_pll_pll_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 13) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 12) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 9) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 8) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 7) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 6) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 5) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_GET(r) ((((r).ams_pll_pll_ctl2[0]) >> 1) & 0xf)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_EN_HRZf_GET(r) (((r).ams_pll_pll_ctl2[0]) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_EN_HRZf_SET(r,f) (r).ams_pll_pll_ctl2[0]=(((r).ams_pll_pll_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL2.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL2r,_r._ams_pll_pll_ctl2)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL2r,_r._ams_pll_pll_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL2r BCMI_MADURA_AMS_PLL_PLL_CTL2r
#define AMS_PLL_PLL_CTL2r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL2r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL2r_t AMS_PLL_PLL_CTL2r_t;
#define AMS_PLL_PLL_CTL2r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL2r_CLR
#define AMS_PLL_PLL_CTL2r_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_SET
#define AMS_PLL_PLL_CTL2r_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_IQPf_SET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_EN_HRZf_GET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_EN_HRZf_GET
#define AMS_PLL_PLL_CTL2r_AMS_PLL_EN_HRZf_SET BCMI_MADURA_AMS_PLL_PLL_CTL2r_AMS_PLL_EN_HRZf_SET
#define READ_AMS_PLL_PLL_CTL2r BCMI_MADURA_READ_AMS_PLL_PLL_CTL2r
#define WRITE_AMS_PLL_PLL_CTL2r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL2r
#define MODIFY_AMS_PLL_PLL_CTL2r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL3
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd113
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_IMIN_IRXCLKBUF see AMS amsbus ctrl_out  48:48DFT_MUX
 *     AMS_PLL_IMODE_IRXCLKBUF see AMS amsbus ctrl_out  49:49DFT_MUX
 *     AMS_PLL_IMAX_IRXCLKBUF rxclkbuf amsbus ctrl_out  50:50DFT_MUX
 *     AMS_PLL_IMIN_ICMLDIV see AMS amsbus ctrl_out  51:51DFT_MUX
 *     AMS_PLL_IMODE_ICMLDIV see AMS amsbus ctrl_out  52:52DFT_MUX
 *     AMS_PLL_IMAX_ICMLDIV VCO divider/buffer amsbus ctrl_out  53:53DFT_MUX
 *     AMS_PLL_IMIN_ICOMP see AMS amsbus ctrl_out  54:54DFT_MUX
 *     AMS_PLL_IMODE_ICOMP see AMS amsbus ctrl_out  55:55DFT_MUX
 *     AMS_PLL_IMAX_ICOMP VCO comparator amsbus ctrl_out  56:56DFT_MUX
 *     AMS_PLL_IMIN_IOP see AMS amsbus ctrl_out  57:57DFT_MUX
 *     AMS_PLL_IMODE_IOP see AMS amsbus ctrl_out  58:58DFT_MUX
 *     AMS_PLL_IMAX_IOP test current amsbus ctrl_out  59:59DFT_MUX
 *     AMS_PLL_TEST_VREF see AMS amsbus ctrl_out  60:60DFT_MUX
 *     AMS_PLL_TEST_VC  test Vcontrol amsbus ctrl_out  61:61DFT_MUX
 *     AMS_PLL_TEST_PLL test LC amsbus ctrl_out  62:62DFT_MUX
 *     AMS_PLL_TEST_RX  send RX word ck to PLL test port amsbus ctrl_out  63:63DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r (0x0001d113 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL3.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl3[1];
	uint32_t _ams_pll_pll_ctl3;
} BCMI_MADURA_AMS_PLL_PLL_CTL3r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_CLR(r) (r).ams_pll_pll_ctl3[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_SET(r,d) (r).ams_pll_pll_ctl3[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_GET(r) (r).ams_pll_pll_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 13) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 12) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 9) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 8) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 7) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 6) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 5) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 4) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 3) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 2) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET(r) ((((r).ams_pll_pll_ctl3[0]) >> 1) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET(r) (((r).ams_pll_pll_ctl3[0]) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET(r,f) (r).ams_pll_pll_ctl3[0]=(((r).ams_pll_pll_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL3.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL3r,_r._ams_pll_pll_ctl3)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL3r,_r._ams_pll_pll_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL3r BCMI_MADURA_AMS_PLL_PLL_CTL3r
#define AMS_PLL_PLL_CTL3r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL3r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL3r_t AMS_PLL_PLL_CTL3r_t;
#define AMS_PLL_PLL_CTL3r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL3r_CLR
#define AMS_PLL_PLL_CTL3r_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_SET
#define AMS_PLL_PLL_CTL3r_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_RXf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VCf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET
#define AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET BCMI_MADURA_AMS_PLL_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET
#define READ_AMS_PLL_PLL_CTL3r BCMI_MADURA_READ_AMS_PLL_PLL_CTL3r
#define WRITE_AMS_PLL_PLL_CTL3r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL3r
#define MODIFY_AMS_PLL_PLL_CTL3r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL4
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd114
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_4
 * RESETVAL: 0x77 (119)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_BGR_PTATADJ BG bias, same decoder as CTAT amsbus ctrl_out  67:64DFT_MUX
 *     AMS_PLL_BGR_CTATADJ BG CTAT bias control amsbus ctrl_out  71:68DFT_MUX
 *     AMS_PLL_PLL2RX_CLKBW controls BW of interpolator input amsbus ctrl_out  73:72DFT_MUX
 *     AMS_PLL_COMP_VTH tuning comparator threshold amsbus ctrl_out  74:74DFT_MUX
 *     AMS_PLL_VDDR_BGB select between PVDD or BG Vbias amsbus ctrl_out  75:75DFT_MUX
 *     AMS_PLL_KVH_FORCE force Kvco, override tuning control amsbus ctrl_out  77:76DFT_MUX
 *     AMS_PLL_FORCE_KVH_BW enable force kvh and bw modes amsbus ctrl_out  78:78DFT_MUX
 *     AMS_PLL_FORCE_RESCAL force_rescal with pll_ctrl<15:12> amsbus ctrl_out  79:79DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r (0x0001d114 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL4.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl4[1];
	uint32_t _ams_pll_pll_ctl4;
} BCMI_MADURA_AMS_PLL_PLL_CTL4r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_CLR(r) (r).ams_pll_pll_ctl4[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_SET(r,d) (r).ams_pll_pll_ctl4[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_GET(r) (r).ams_pll_pll_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 12) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 11) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_COMP_VTHf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 10) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_COMP_VTHf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 8) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 4) & 0xf)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET(r) (((r).ams_pll_pll_ctl4[0]) & 0xf)
#define BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL4.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL4r,_r._ams_pll_pll_ctl4)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL4r,_r._ams_pll_pll_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL4r BCMI_MADURA_AMS_PLL_PLL_CTL4r
#define AMS_PLL_PLL_CTL4r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL4r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL4r_t AMS_PLL_PLL_CTL4r_t;
#define AMS_PLL_PLL_CTL4r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL4r_CLR
#define AMS_PLL_PLL_CTL4r_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_SET
#define AMS_PLL_PLL_CTL4r_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_COMP_VTHf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_COMP_VTHf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_COMP_VTHf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_COMP_VTHf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET
#define READ_AMS_PLL_PLL_CTL4r BCMI_MADURA_READ_AMS_PLL_PLL_CTL4r
#define WRITE_AMS_PLL_PLL_CTL4r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL4r
#define MODIFY_AMS_PLL_PLL_CTL4r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL5
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd115
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_5
 * RESETVAL: 0x1f00 (7936)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_TEST_PORT_MAX_AMPLITUDE test port max amplitude amsbus ctrl_out  80:80DFT_MUX
 *     AMS_PLL_BGIP     test, measure Ibg internal PMOS current amsbus ctrl_out  81:81DFT_MUX
 *     AMS_PLL_BGINT    test, measure Vbg internal amsbus ctrl_out  82:82DFT_MUX
 *     AMS_PLL_VBYPASS  test, bypass test port opamp buffer amsbus ctrl_out  83:83DFT_MUX
 *     AMS_PLL_TEST_PNP see AMS amsbus ctrl_out  85:84DFT_MUX
 *     AMS_PLL_MIX3P1C_CALR_CTATADJ bias control for Mix3P1C/calR amsbus ctrl_out  90:86DFT_MUX
 *     AMS_PLL_MIX3P1C_CALR_PTATADJ bias control for Mix3P1C/calR amsbus ctrl_out  95:91DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r (0x0001d115 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL5.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL5r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl5[1];
	uint32_t _ams_pll_pll_ctl5;
} BCMI_MADURA_AMS_PLL_PLL_CTL5r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_CLR(r) (r).ams_pll_pll_ctl5[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_SET(r,d) (r).ams_pll_pll_ctl5[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_GET(r) (r).ams_pll_pll_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 11) & 0x1f)
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 6) & 0x1f)
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 4) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 3) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 2) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_GET(r) ((((r).ams_pll_pll_ctl5[0]) >> 1) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_GET(r) (((r).ams_pll_pll_ctl5[0]) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_SET(r,f) (r).ams_pll_pll_ctl5[0]=(((r).ams_pll_pll_ctl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL5.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL5r,_r._ams_pll_pll_ctl5)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL5r,_r._ams_pll_pll_ctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL5r BCMI_MADURA_AMS_PLL_PLL_CTL5r
#define AMS_PLL_PLL_CTL5r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL5r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL5r_t AMS_PLL_PLL_CTL5r_t;
#define AMS_PLL_PLL_CTL5r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL5r_CLR
#define AMS_PLL_PLL_CTL5r_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_SET
#define AMS_PLL_PLL_CTL5r_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_VBYPASSf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGINTf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_BGIPf_SET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_GET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_GET
#define AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_SET BCMI_MADURA_AMS_PLL_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_SET
#define READ_AMS_PLL_PLL_CTL5r BCMI_MADURA_READ_AMS_PLL_PLL_CTL5r
#define WRITE_AMS_PLL_PLL_CTL5r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL5r
#define MODIFY_AMS_PLL_PLL_CTL5r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL6
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd116
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_6
 * RESETVAL: 0xc1c0 (49600)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_RTERM200 set refclk termination impedance to 200 ohm amsbus ctrl_out  96:96DFT_MUX
 *     AMS_PLL_DIV2     divided 2 amsbus ctrl_out  97:97
 *     AMS_PLL_DIV4     divided 4 amsbus ctrl_out  98:98
 *     AMS_PLL_RTERM400 set refclk termination impedance to 400 ohm amsbus ctrl_out  99:99DFT_MUX
 *     AMS_PLL_RTERM600 set refclk termination impedance to 600 ohm amsbus ctrl_out  100:100DFT_MUX
 *     AMS_PLL_RTERMHIZ set refclk termination impedance to very high impedance amsbus ctrl_out  101:101DFT_MUX
 *     AMS_PLL_MIX1P2CR_CTATADJ CTAT bias control for Mix1P2C/R (see AMS) amsbus ctrl_out  106:102DFT_MUX
 *     AMS_PLL_MIX1P2CR_PTATADJ PTAT bias control for Mix1P2C/R, 20uA (See AMS) amsbus ctrl_out  111:107DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r (0x0001d116 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL6.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl6[1];
	uint32_t _ams_pll_pll_ctl6;
} BCMI_MADURA_AMS_PLL_PLL_CTL6r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_CLR(r) (r).ams_pll_pll_ctl6[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_SET(r,d) (r).ams_pll_pll_ctl6[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_GET(r) (r).ams_pll_pll_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 11) & 0x1f)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 6) & 0x1f)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 5) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM600f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 4) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM600f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 3) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 2) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 1) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET(r) (((r).ams_pll_pll_ctl6[0]) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL6.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL6r,_r._ams_pll_pll_ctl6)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL6r,_r._ams_pll_pll_ctl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL6r BCMI_MADURA_AMS_PLL_PLL_CTL6r
#define AMS_PLL_PLL_CTL6r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL6r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL6r_t AMS_PLL_PLL_CTL6r_t;
#define AMS_PLL_PLL_CTL6r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL6r_CLR
#define AMS_PLL_PLL_CTL6r_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_SET
#define AMS_PLL_PLL_CTL6r_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM600f_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM600f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM600f_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM600f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET BCMI_MADURA_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET
#define READ_AMS_PLL_PLL_CTL6r BCMI_MADURA_READ_AMS_PLL_PLL_CTL6r
#define WRITE_AMS_PLL_PLL_CTL6r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL6r
#define MODIFY_AMS_PLL_PLL_CTL6r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL7
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd117
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_7
 * RESETVAL: 0x1f00 (7936)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_REFCLK4COM_DIV2 divide the PLL input refclk by 2 to generate refclk4com output amsbus ctrl_out  112:112
 *     AMS_PLL_REFCLK4COM_DIV4 divide the PLL input refclk by 4 to generate refclk4com output amsbus ctrl_out  113:113
 *     AMS_PLL_SPARE_117_114 AMS reserved[117:114] amsbus ctrl_out  117:114DFT_DFS=4'd0
 *     AMS_PLL_MIX3P1CR_CTATADJ CTAT bias control for Mix3P1C/R amsbus ctrl_out  122:118DFT_MUX
 *     AMS_PLL_MIX3P1CR_PTATADJ PTAT bias control for Mix3P1C/R which is used in RX amsbus ctrl_out  127:123DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r (0x0001d117 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL7.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl7[1];
	uint32_t _ams_pll_pll_ctl7;
} BCMI_MADURA_AMS_PLL_PLL_CTL7r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_CLR(r) (r).ams_pll_pll_ctl7[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_SET(r,d) (r).ams_pll_pll_ctl7[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_GET(r) (r).ams_pll_pll_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 11) & 0x1f)
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 6) & 0x1f)
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_SPARE_117_114f_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 2) & 0xf)
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_SPARE_117_114f_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV4f_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 1) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV4f_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV2f_GET(r) (((r).ams_pll_pll_ctl7[0]) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV2f_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL7.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL7r,_r._ams_pll_pll_ctl7)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL7r,_r._ams_pll_pll_ctl7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL7r BCMI_MADURA_AMS_PLL_PLL_CTL7r
#define AMS_PLL_PLL_CTL7r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL7r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL7r_t AMS_PLL_PLL_CTL7r_t;
#define AMS_PLL_PLL_CTL7r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL7r_CLR
#define AMS_PLL_PLL_CTL7r_SET BCMI_MADURA_AMS_PLL_PLL_CTL7r_SET
#define AMS_PLL_PLL_CTL7r_GET BCMI_MADURA_AMS_PLL_PLL_CTL7r_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_SPARE_117_114f_GET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_SPARE_117_114f_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_SPARE_117_114f_SET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_SPARE_117_114f_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV4f_GET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV4f_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV4f_SET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV4f_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV2f_GET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV2f_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV2f_SET BCMI_MADURA_AMS_PLL_PLL_CTL7r_AMS_PLL_REFCLK4COM_DIV2f_SET
#define READ_AMS_PLL_PLL_CTL7r BCMI_MADURA_READ_AMS_PLL_PLL_CTL7r
#define WRITE_AMS_PLL_PLL_CTL7r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL7r
#define MODIFY_AMS_PLL_PLL_CTL7r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL8
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd118
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_FRACN_DIV lower 16 bits fractional control of feedback divider amsbus ctrl_out  143:128DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL8r (0x0001d118 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL8.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL8r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl8[1];
	uint32_t _ams_pll_pll_ctl8;
} BCMI_MADURA_AMS_PLL_PLL_CTL8r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL8r_CLR(r) (r).ams_pll_pll_ctl8[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL8r_SET(r,d) (r).ams_pll_pll_ctl8[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL8r_GET(r) (r).ams_pll_pll_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET(r) (((r).ams_pll_pll_ctl8[0]) & 0xffff)
#define BCMI_MADURA_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET(r,f) (r).ams_pll_pll_ctl8[0]=(((r).ams_pll_pll_ctl8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL8.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL8r,_r._ams_pll_pll_ctl8)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL8r,_r._ams_pll_pll_ctl8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL8r BCMI_MADURA_AMS_PLL_PLL_CTL8r
#define AMS_PLL_PLL_CTL8r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL8r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL8r_t AMS_PLL_PLL_CTL8r_t;
#define AMS_PLL_PLL_CTL8r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL8r_CLR
#define AMS_PLL_PLL_CTL8r_SET BCMI_MADURA_AMS_PLL_PLL_CTL8r_SET
#define AMS_PLL_PLL_CTL8r_GET BCMI_MADURA_AMS_PLL_PLL_CTL8r_GET
#define AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET BCMI_MADURA_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET
#define AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET BCMI_MADURA_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET
#define READ_AMS_PLL_PLL_CTL8r BCMI_MADURA_READ_AMS_PLL_PLL_CTL8r
#define WRITE_AMS_PLL_PLL_CTL8r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL8r
#define MODIFY_AMS_PLL_PLL_CTL8r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_CTL9
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd119
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_FRACN_DIV_17_16 higher 2 bits fractional control of feedback divider amsbus ctrl_out  145:144DFT_MUX
 *     AMS_PLL_FRACN_DIVRANGE selects MMD range amsbus ctrl_out  146:146DFT_MUX
 *     AMS_PLL_FRACN_BYPASS used for integer mode of fracn blk amsbus ctrl_out  147:147DFT_MUX
 *     AMS_PLL_FRACN_NDIV_INT must be programme for the initial div2 stage after VCO amsbus ctrl_out  157:148DFT_MUX
 *     AMS_PLL_DITHEREN enables dithering to reduce the refclk spur amsbus ctrl_out  158:158DFT_MUX
 *     AMS_PLL_FRACN_SEL master enable and select for the frac-N mode amsbus ctrl_out  159:159DFT_MUX
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r (0x0001d119 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL9.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_CTL9r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl9[1];
	uint32_t _ams_pll_pll_ctl9;
} BCMI_MADURA_AMS_PLL_PLL_CTL9r_t;

#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_CLR(r) (r).ams_pll_pll_ctl9[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_SET(r,d) (r).ams_pll_pll_ctl9[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_GET(r) (r).ams_pll_pll_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 15) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 14) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 4) & 0x3ff)
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x3ff << 4)) | ((((uint32_t)f) & 0x3ff) << 4)) | (1023 << (16 + 4))
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 3) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 2) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET(r) (((r).ams_pll_pll_ctl9[0]) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL9.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_CTL9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL9r,_r._ams_pll_pll_ctl9)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_CTL9r,_r._ams_pll_pll_ctl9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL9r BCMI_MADURA_AMS_PLL_PLL_CTL9r
#define AMS_PLL_PLL_CTL9r_SIZE BCMI_MADURA_AMS_PLL_PLL_CTL9r_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_CTL9r_t AMS_PLL_PLL_CTL9r_t;
#define AMS_PLL_PLL_CTL9r_CLR BCMI_MADURA_AMS_PLL_PLL_CTL9r_CLR
#define AMS_PLL_PLL_CTL9r_SET BCMI_MADURA_AMS_PLL_PLL_CTL9r_SET
#define AMS_PLL_PLL_CTL9r_GET BCMI_MADURA_AMS_PLL_PLL_CTL9r_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET BCMI_MADURA_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET
#define READ_AMS_PLL_PLL_CTL9r BCMI_MADURA_READ_AMS_PLL_PLL_CTL9r
#define WRITE_AMS_PLL_PLL_CTL9r BCMI_MADURA_WRITE_AMS_PLL_PLL_CTL9r
#define MODIFY_AMS_PLL_PLL_CTL9r BCMI_MADURA_MODIFY_AMS_PLL_PLL_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_INTCTL
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd11b
 * DEVAD:    1
 * DESC:     INTERNAL PLL CONTROL
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_RTERM_SEL when 0, sel rterm input pins, when 1 sel pll AMS ctrl
 *     AMS_PLL_DIV4_2_SEL when 0, sel div4/2 and refclk4com_div4/2 input pins, when 1 sel pll AMS ctrl
 *     AMS_PLL_PWRDN    when1, power down pll
 */
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr (0x0001d11b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_INTCTL.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_INTCTLr_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_intctl[1];
	uint32_t _ams_pll_pll_intctl;
} BCMI_MADURA_AMS_PLL_PLL_INTCTLr_t;

#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_CLR(r) (r).ams_pll_pll_intctl[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_SET(r,d) (r).ams_pll_pll_intctl[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_GET(r) (r).ams_pll_pll_intctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET(r) ((((r).ams_pll_pll_intctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET(r) ((((r).ams_pll_pll_intctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET(r) (((r).ams_pll_pll_intctl[0]) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_INTCTL.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_INTCTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_INTCTLr,_r._ams_pll_pll_intctl)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_INTCTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_INTCTLr,_r._ams_pll_pll_intctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_INTCTLr BCMI_MADURA_AMS_PLL_PLL_INTCTLr
#define AMS_PLL_PLL_INTCTLr_SIZE BCMI_MADURA_AMS_PLL_PLL_INTCTLr_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_INTCTLr_t AMS_PLL_PLL_INTCTLr_t;
#define AMS_PLL_PLL_INTCTLr_CLR BCMI_MADURA_AMS_PLL_PLL_INTCTLr_CLR
#define AMS_PLL_PLL_INTCTLr_SET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_SET
#define AMS_PLL_PLL_INTCTLr_GET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET BCMI_MADURA_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET
#define READ_AMS_PLL_PLL_INTCTLr BCMI_MADURA_READ_AMS_PLL_PLL_INTCTLr
#define WRITE_AMS_PLL_PLL_INTCTLr BCMI_MADURA_WRITE_AMS_PLL_PLL_INTCTLr
#define MODIFY_AMS_PLL_PLL_INTCTLr BCMI_MADURA_MODIFY_AMS_PLL_PLL_INTCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_INTCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AMS_PLL_PLL_STS
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd11c
 * DEVAD:    1
 * DESC:     AMS PLL STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_PLL_NDIV     Copy of pll_mode[4:0] bits
 *     AMS_PLL_LOW      VCO tuning output, HIGH when VCO Vctrl is low or PLL frequency is too low
 *     AMS_PLL_RANGE    VCO frequency range control (8 bits)
 *     AMS_PLL_KVH      KVH[1:0]
 */
#define BCMI_MADURA_AMS_PLL_PLL_STSr (0x0001d11c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AMS_PLL_PLL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_STS.
 */
typedef union BCMI_MADURA_AMS_PLL_PLL_STSr_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_sts[1];
	uint32_t _ams_pll_pll_sts;
} BCMI_MADURA_AMS_PLL_PLL_STSr_t;

#define BCMI_MADURA_AMS_PLL_PLL_STSr_CLR(r) (r).ams_pll_pll_sts[0] = 0
#define BCMI_MADURA_AMS_PLL_PLL_STSr_SET(r,d) (r).ams_pll_pll_sts[0] = d
#define BCMI_MADURA_AMS_PLL_PLL_STSr_GET(r) (r).ams_pll_pll_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 14) & 0x3)
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 6) & 0xff)
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 5) & 0x1)
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_NDIVf_GET(r) (((r).ams_pll_pll_sts[0]) & 0x1f)
#define BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_NDIVf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_STS.
 */
#define BCMI_MADURA_READ_AMS_PLL_PLL_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AMS_PLL_PLL_STSr,_r._ams_pll_pll_sts)
#define BCMI_MADURA_WRITE_AMS_PLL_PLL_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AMS_PLL_PLL_STSr,_r._ams_pll_pll_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_STSr BCMI_MADURA_AMS_PLL_PLL_STSr
#define AMS_PLL_PLL_STSr_SIZE BCMI_MADURA_AMS_PLL_PLL_STSr_SIZE
typedef BCMI_MADURA_AMS_PLL_PLL_STSr_t AMS_PLL_PLL_STSr_t;
#define AMS_PLL_PLL_STSr_CLR BCMI_MADURA_AMS_PLL_PLL_STSr_CLR
#define AMS_PLL_PLL_STSr_SET BCMI_MADURA_AMS_PLL_PLL_STSr_SET
#define AMS_PLL_PLL_STSr_GET BCMI_MADURA_AMS_PLL_PLL_STSr_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_NDIVf_GET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_NDIVf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_NDIVf_SET BCMI_MADURA_AMS_PLL_PLL_STSr_AMS_PLL_NDIVf_SET
#define READ_AMS_PLL_PLL_STSr BCMI_MADURA_READ_AMS_PLL_PLL_STSr
#define WRITE_AMS_PLL_PLL_STSr BCMI_MADURA_WRITE_AMS_PLL_PLL_STSr
#define MODIFY_AMS_PLL_PLL_STSr BCMI_MADURA_MODIFY_AMS_PLL_PLL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AMS_PLL_PLL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ0
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd120
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 0
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_0   Fixed Pattern Generator Sequence Word 0. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted last.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ0r (0x0001d120 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ0r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ0.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ0r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq0[1];
	uint32_t _patgen_patgen_seq0;
} BCMI_MADURA_PATGEN_PATGEN_SEQ0r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ0r_CLR(r) (r).patgen_patgen_seq0[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ0r_SET(r,d) (r).patgen_patgen_seq0[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ0r_GET(r) (r).patgen_patgen_seq0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET(r) (((r).patgen_patgen_seq0[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET(r,f) (r).patgen_patgen_seq0[0]=(((r).patgen_patgen_seq0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ0.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ0r,_r._patgen_patgen_seq0)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ0r,_r._patgen_patgen_seq0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ0r BCMI_MADURA_PATGEN_PATGEN_SEQ0r
#define PATGEN_PATGEN_SEQ0r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ0r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ0r_t PATGEN_PATGEN_SEQ0r_t;
#define PATGEN_PATGEN_SEQ0r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ0r_CLR
#define PATGEN_PATGEN_SEQ0r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ0r_SET
#define PATGEN_PATGEN_SEQ0r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ0r_GET
#define PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET
#define PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET
#define READ_PATGEN_PATGEN_SEQ0r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ0r
#define WRITE_PATGEN_PATGEN_SEQ0r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ0r
#define MODIFY_PATGEN_PATGEN_SEQ0r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ1
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd121
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 1
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_1   Fixed Pattern Generator Sequence Word 1. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ1r (0x0001d121 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ1r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ1.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ1r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq1[1];
	uint32_t _patgen_patgen_seq1;
} BCMI_MADURA_PATGEN_PATGEN_SEQ1r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ1r_CLR(r) (r).patgen_patgen_seq1[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ1r_SET(r,d) (r).patgen_patgen_seq1[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ1r_GET(r) (r).patgen_patgen_seq1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET(r) (((r).patgen_patgen_seq1[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET(r,f) (r).patgen_patgen_seq1[0]=(((r).patgen_patgen_seq1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ1.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ1r,_r._patgen_patgen_seq1)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ1r,_r._patgen_patgen_seq1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ1r BCMI_MADURA_PATGEN_PATGEN_SEQ1r
#define PATGEN_PATGEN_SEQ1r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ1r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ1r_t PATGEN_PATGEN_SEQ1r_t;
#define PATGEN_PATGEN_SEQ1r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ1r_CLR
#define PATGEN_PATGEN_SEQ1r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ1r_SET
#define PATGEN_PATGEN_SEQ1r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ1r_GET
#define PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET
#define PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET
#define READ_PATGEN_PATGEN_SEQ1r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ1r
#define WRITE_PATGEN_PATGEN_SEQ1r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ1r
#define MODIFY_PATGEN_PATGEN_SEQ1r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ2
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd122
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 2
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_2   Fixed Pattern Generator Sequence Word 2. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ2r (0x0001d122 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ2r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ2.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ2r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq2[1];
	uint32_t _patgen_patgen_seq2;
} BCMI_MADURA_PATGEN_PATGEN_SEQ2r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ2r_CLR(r) (r).patgen_patgen_seq2[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ2r_SET(r,d) (r).patgen_patgen_seq2[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ2r_GET(r) (r).patgen_patgen_seq2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET(r) (((r).patgen_patgen_seq2[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET(r,f) (r).patgen_patgen_seq2[0]=(((r).patgen_patgen_seq2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ2.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ2r,_r._patgen_patgen_seq2)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ2r,_r._patgen_patgen_seq2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ2r BCMI_MADURA_PATGEN_PATGEN_SEQ2r
#define PATGEN_PATGEN_SEQ2r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ2r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ2r_t PATGEN_PATGEN_SEQ2r_t;
#define PATGEN_PATGEN_SEQ2r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ2r_CLR
#define PATGEN_PATGEN_SEQ2r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ2r_SET
#define PATGEN_PATGEN_SEQ2r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ2r_GET
#define PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET
#define PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET
#define READ_PATGEN_PATGEN_SEQ2r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ2r
#define WRITE_PATGEN_PATGEN_SEQ2r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ2r
#define MODIFY_PATGEN_PATGEN_SEQ2r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ3
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd123
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 3
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_3   Fixed Pattern Generator Sequence Word 3. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ3r (0x0001d123 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ3r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ3.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ3r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq3[1];
	uint32_t _patgen_patgen_seq3;
} BCMI_MADURA_PATGEN_PATGEN_SEQ3r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ3r_CLR(r) (r).patgen_patgen_seq3[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ3r_SET(r,d) (r).patgen_patgen_seq3[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ3r_GET(r) (r).patgen_patgen_seq3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET(r) (((r).patgen_patgen_seq3[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET(r,f) (r).patgen_patgen_seq3[0]=(((r).patgen_patgen_seq3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ3.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ3r,_r._patgen_patgen_seq3)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ3r,_r._patgen_patgen_seq3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ3r BCMI_MADURA_PATGEN_PATGEN_SEQ3r
#define PATGEN_PATGEN_SEQ3r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ3r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ3r_t PATGEN_PATGEN_SEQ3r_t;
#define PATGEN_PATGEN_SEQ3r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ3r_CLR
#define PATGEN_PATGEN_SEQ3r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ3r_SET
#define PATGEN_PATGEN_SEQ3r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ3r_GET
#define PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET
#define PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET
#define READ_PATGEN_PATGEN_SEQ3r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ3r
#define WRITE_PATGEN_PATGEN_SEQ3r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ3r
#define MODIFY_PATGEN_PATGEN_SEQ3r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ4
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd124
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 4
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_4   Fixed Pattern Generator Sequence Word 4. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ4r (0x0001d124 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ4r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ4.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ4r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq4[1];
	uint32_t _patgen_patgen_seq4;
} BCMI_MADURA_PATGEN_PATGEN_SEQ4r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ4r_CLR(r) (r).patgen_patgen_seq4[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ4r_SET(r,d) (r).patgen_patgen_seq4[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ4r_GET(r) (r).patgen_patgen_seq4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET(r) (((r).patgen_patgen_seq4[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET(r,f) (r).patgen_patgen_seq4[0]=(((r).patgen_patgen_seq4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ4.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ4r,_r._patgen_patgen_seq4)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ4r,_r._patgen_patgen_seq4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ4r BCMI_MADURA_PATGEN_PATGEN_SEQ4r
#define PATGEN_PATGEN_SEQ4r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ4r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ4r_t PATGEN_PATGEN_SEQ4r_t;
#define PATGEN_PATGEN_SEQ4r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ4r_CLR
#define PATGEN_PATGEN_SEQ4r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ4r_SET
#define PATGEN_PATGEN_SEQ4r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ4r_GET
#define PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET
#define PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET
#define READ_PATGEN_PATGEN_SEQ4r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ4r
#define WRITE_PATGEN_PATGEN_SEQ4r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ4r
#define MODIFY_PATGEN_PATGEN_SEQ4r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ5
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd125
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 5
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_5   Fixed Pattern Generator Sequence Word 5. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ5r (0x0001d125 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ5r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ5.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ5r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq5[1];
	uint32_t _patgen_patgen_seq5;
} BCMI_MADURA_PATGEN_PATGEN_SEQ5r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ5r_CLR(r) (r).patgen_patgen_seq5[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ5r_SET(r,d) (r).patgen_patgen_seq5[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ5r_GET(r) (r).patgen_patgen_seq5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET(r) (((r).patgen_patgen_seq5[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET(r,f) (r).patgen_patgen_seq5[0]=(((r).patgen_patgen_seq5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ5.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ5r,_r._patgen_patgen_seq5)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ5r,_r._patgen_patgen_seq5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ5r BCMI_MADURA_PATGEN_PATGEN_SEQ5r
#define PATGEN_PATGEN_SEQ5r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ5r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ5r_t PATGEN_PATGEN_SEQ5r_t;
#define PATGEN_PATGEN_SEQ5r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ5r_CLR
#define PATGEN_PATGEN_SEQ5r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ5r_SET
#define PATGEN_PATGEN_SEQ5r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ5r_GET
#define PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET
#define PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET
#define READ_PATGEN_PATGEN_SEQ5r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ5r
#define WRITE_PATGEN_PATGEN_SEQ5r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ5r
#define MODIFY_PATGEN_PATGEN_SEQ5r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ6
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd126
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 6
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_6   Fixed Pattern Generator Sequence Word 6. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ6r (0x0001d126 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ6r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ6.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ6r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq6[1];
	uint32_t _patgen_patgen_seq6;
} BCMI_MADURA_PATGEN_PATGEN_SEQ6r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ6r_CLR(r) (r).patgen_patgen_seq6[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ6r_SET(r,d) (r).patgen_patgen_seq6[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ6r_GET(r) (r).patgen_patgen_seq6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET(r) (((r).patgen_patgen_seq6[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET(r,f) (r).patgen_patgen_seq6[0]=(((r).patgen_patgen_seq6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ6.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ6r,_r._patgen_patgen_seq6)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ6r,_r._patgen_patgen_seq6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ6r BCMI_MADURA_PATGEN_PATGEN_SEQ6r
#define PATGEN_PATGEN_SEQ6r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ6r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ6r_t PATGEN_PATGEN_SEQ6r_t;
#define PATGEN_PATGEN_SEQ6r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ6r_CLR
#define PATGEN_PATGEN_SEQ6r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ6r_SET
#define PATGEN_PATGEN_SEQ6r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ6r_GET
#define PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET
#define PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET
#define READ_PATGEN_PATGEN_SEQ6r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ6r
#define WRITE_PATGEN_PATGEN_SEQ6r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ6r
#define MODIFY_PATGEN_PATGEN_SEQ6r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ7
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd127
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 7
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_7   Fixed Pattern Generator Sequence Word 7. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ7r (0x0001d127 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ7r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ7.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ7r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq7[1];
	uint32_t _patgen_patgen_seq7;
} BCMI_MADURA_PATGEN_PATGEN_SEQ7r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ7r_CLR(r) (r).patgen_patgen_seq7[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ7r_SET(r,d) (r).patgen_patgen_seq7[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ7r_GET(r) (r).patgen_patgen_seq7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET(r) (((r).patgen_patgen_seq7[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET(r,f) (r).patgen_patgen_seq7[0]=(((r).patgen_patgen_seq7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ7.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ7r,_r._patgen_patgen_seq7)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ7r,_r._patgen_patgen_seq7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ7r BCMI_MADURA_PATGEN_PATGEN_SEQ7r
#define PATGEN_PATGEN_SEQ7r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ7r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ7r_t PATGEN_PATGEN_SEQ7r_t;
#define PATGEN_PATGEN_SEQ7r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ7r_CLR
#define PATGEN_PATGEN_SEQ7r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ7r_SET
#define PATGEN_PATGEN_SEQ7r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ7r_GET
#define PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET
#define PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET
#define READ_PATGEN_PATGEN_SEQ7r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ7r
#define WRITE_PATGEN_PATGEN_SEQ7r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ7r
#define MODIFY_PATGEN_PATGEN_SEQ7r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ8
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd128
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 8
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_8   Fixed Pattern Generator Sequence Word 8. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ8r (0x0001d128 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ8r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ8.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ8r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq8[1];
	uint32_t _patgen_patgen_seq8;
} BCMI_MADURA_PATGEN_PATGEN_SEQ8r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ8r_CLR(r) (r).patgen_patgen_seq8[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ8r_SET(r,d) (r).patgen_patgen_seq8[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ8r_GET(r) (r).patgen_patgen_seq8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET(r) (((r).patgen_patgen_seq8[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET(r,f) (r).patgen_patgen_seq8[0]=(((r).patgen_patgen_seq8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ8.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ8r,_r._patgen_patgen_seq8)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ8r,_r._patgen_patgen_seq8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ8r BCMI_MADURA_PATGEN_PATGEN_SEQ8r
#define PATGEN_PATGEN_SEQ8r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ8r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ8r_t PATGEN_PATGEN_SEQ8r_t;
#define PATGEN_PATGEN_SEQ8r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ8r_CLR
#define PATGEN_PATGEN_SEQ8r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ8r_SET
#define PATGEN_PATGEN_SEQ8r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ8r_GET
#define PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET
#define PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET
#define READ_PATGEN_PATGEN_SEQ8r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ8r
#define WRITE_PATGEN_PATGEN_SEQ8r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ8r
#define MODIFY_PATGEN_PATGEN_SEQ8r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ9
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd129
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 9
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_9   Fixed Pattern Generator Sequence Word 9. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ9r (0x0001d129 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ9r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ9.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ9r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq9[1];
	uint32_t _patgen_patgen_seq9;
} BCMI_MADURA_PATGEN_PATGEN_SEQ9r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ9r_CLR(r) (r).patgen_patgen_seq9[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ9r_SET(r,d) (r).patgen_patgen_seq9[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ9r_GET(r) (r).patgen_patgen_seq9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET(r) (((r).patgen_patgen_seq9[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET(r,f) (r).patgen_patgen_seq9[0]=(((r).patgen_patgen_seq9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ9.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ9r,_r._patgen_patgen_seq9)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ9r,_r._patgen_patgen_seq9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ9r BCMI_MADURA_PATGEN_PATGEN_SEQ9r
#define PATGEN_PATGEN_SEQ9r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ9r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ9r_t PATGEN_PATGEN_SEQ9r_t;
#define PATGEN_PATGEN_SEQ9r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ9r_CLR
#define PATGEN_PATGEN_SEQ9r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ9r_SET
#define PATGEN_PATGEN_SEQ9r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ9r_GET
#define PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET
#define PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET
#define READ_PATGEN_PATGEN_SEQ9r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ9r
#define WRITE_PATGEN_PATGEN_SEQ9r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ9r
#define MODIFY_PATGEN_PATGEN_SEQ9r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ_10
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12a
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 10
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_10  Fixed Pattern Generator Sequence Word 10. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_10r (0x0001d12a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_10.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_10[1];
	uint32_t _patgen_patgen_seq_10;
} BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_CLR(r) (r).patgen_patgen_seq_10[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_SET(r,d) (r).patgen_patgen_seq_10[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_GET(r) (r).patgen_patgen_seq_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET(r) (((r).patgen_patgen_seq_10[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET(r,f) (r).patgen_patgen_seq_10[0]=(((r).patgen_patgen_seq_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_10.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_10r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_10r,_r._patgen_patgen_seq_10)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_10r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_10r,_r._patgen_patgen_seq_10)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_10r BCMI_MADURA_PATGEN_PATGEN_SEQ_10r
#define PATGEN_PATGEN_SEQ_10r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_t PATGEN_PATGEN_SEQ_10r_t;
#define PATGEN_PATGEN_SEQ_10r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_CLR
#define PATGEN_PATGEN_SEQ_10r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_SET
#define PATGEN_PATGEN_SEQ_10r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_GET
#define PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET
#define PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET
#define READ_PATGEN_PATGEN_SEQ_10r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_10r
#define WRITE_PATGEN_PATGEN_SEQ_10r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_10r
#define MODIFY_PATGEN_PATGEN_SEQ_10r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ_11
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12b
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 11
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_11  Fixed Pattern Generator Sequence Word 11. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_11r (0x0001d12b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_11.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_11[1];
	uint32_t _patgen_patgen_seq_11;
} BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_CLR(r) (r).patgen_patgen_seq_11[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_SET(r,d) (r).patgen_patgen_seq_11[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_GET(r) (r).patgen_patgen_seq_11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET(r) (((r).patgen_patgen_seq_11[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET(r,f) (r).patgen_patgen_seq_11[0]=(((r).patgen_patgen_seq_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_11.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_11r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_11r,_r._patgen_patgen_seq_11)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_11r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_11r,_r._patgen_patgen_seq_11)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_11r BCMI_MADURA_PATGEN_PATGEN_SEQ_11r
#define PATGEN_PATGEN_SEQ_11r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_t PATGEN_PATGEN_SEQ_11r_t;
#define PATGEN_PATGEN_SEQ_11r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_CLR
#define PATGEN_PATGEN_SEQ_11r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_SET
#define PATGEN_PATGEN_SEQ_11r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_GET
#define PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET
#define PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET
#define READ_PATGEN_PATGEN_SEQ_11r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_11r
#define WRITE_PATGEN_PATGEN_SEQ_11r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_11r
#define MODIFY_PATGEN_PATGEN_SEQ_11r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ_11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ_12
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12c
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 12
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_12  Fixed Pattern Generator Sequence Word 12. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_12r (0x0001d12c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_12.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_12[1];
	uint32_t _patgen_patgen_seq_12;
} BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_CLR(r) (r).patgen_patgen_seq_12[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_SET(r,d) (r).patgen_patgen_seq_12[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_GET(r) (r).patgen_patgen_seq_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET(r) (((r).patgen_patgen_seq_12[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET(r,f) (r).patgen_patgen_seq_12[0]=(((r).patgen_patgen_seq_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_12.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_12r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_12r,_r._patgen_patgen_seq_12)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_12r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_12r,_r._patgen_patgen_seq_12)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_12r BCMI_MADURA_PATGEN_PATGEN_SEQ_12r
#define PATGEN_PATGEN_SEQ_12r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_t PATGEN_PATGEN_SEQ_12r_t;
#define PATGEN_PATGEN_SEQ_12r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_CLR
#define PATGEN_PATGEN_SEQ_12r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_SET
#define PATGEN_PATGEN_SEQ_12r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_GET
#define PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET
#define PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET
#define READ_PATGEN_PATGEN_SEQ_12r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_12r
#define WRITE_PATGEN_PATGEN_SEQ_12r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_12r
#define MODIFY_PATGEN_PATGEN_SEQ_12r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ_12r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ_13
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12d
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 13
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_13  Fixed Pattern Generator Sequence Word 13. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_13r (0x0001d12d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_13.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_13[1];
	uint32_t _patgen_patgen_seq_13;
} BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_CLR(r) (r).patgen_patgen_seq_13[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_SET(r,d) (r).patgen_patgen_seq_13[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_GET(r) (r).patgen_patgen_seq_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET(r) (((r).patgen_patgen_seq_13[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET(r,f) (r).patgen_patgen_seq_13[0]=(((r).patgen_patgen_seq_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_13.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_13r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_13r,_r._patgen_patgen_seq_13)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_13r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_13r,_r._patgen_patgen_seq_13)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_13r BCMI_MADURA_PATGEN_PATGEN_SEQ_13r
#define PATGEN_PATGEN_SEQ_13r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_t PATGEN_PATGEN_SEQ_13r_t;
#define PATGEN_PATGEN_SEQ_13r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_CLR
#define PATGEN_PATGEN_SEQ_13r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_SET
#define PATGEN_PATGEN_SEQ_13r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_GET
#define PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET
#define PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET
#define READ_PATGEN_PATGEN_SEQ_13r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_13r
#define WRITE_PATGEN_PATGEN_SEQ_13r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_13r
#define MODIFY_PATGEN_PATGEN_SEQ_13r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ_13r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PATGEN_PATGEN_SEQ_14
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12e
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 14
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_14  Fixed Pattern Generator Sequence Word 14. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted first.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_14r (0x0001d12e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_14.
 */
typedef union BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_14[1];
	uint32_t _patgen_patgen_seq_14;
} BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_t;

#define BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_CLR(r) (r).patgen_patgen_seq_14[0] = 0
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_SET(r,d) (r).patgen_patgen_seq_14[0] = d
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_GET(r) (r).patgen_patgen_seq_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET(r) (((r).patgen_patgen_seq_14[0]) & 0xffff)
#define BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET(r,f) (r).patgen_patgen_seq_14[0]=(((r).patgen_patgen_seq_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_14.
 */
#define BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_14r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_14r,_r._patgen_patgen_seq_14)
#define BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_14r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PATGEN_PATGEN_SEQ_14r,_r._patgen_patgen_seq_14)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_14r BCMI_MADURA_PATGEN_PATGEN_SEQ_14r
#define PATGEN_PATGEN_SEQ_14r_SIZE BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_SIZE
typedef BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_t PATGEN_PATGEN_SEQ_14r_t;
#define PATGEN_PATGEN_SEQ_14r_CLR BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_CLR
#define PATGEN_PATGEN_SEQ_14r_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_SET
#define PATGEN_PATGEN_SEQ_14r_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_GET
#define PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET
#define PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET BCMI_MADURA_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET
#define READ_PATGEN_PATGEN_SEQ_14r BCMI_MADURA_READ_PATGEN_PATGEN_SEQ_14r
#define WRITE_PATGEN_PATGEN_SEQ_14r BCMI_MADURA_WRITE_PATGEN_PATGEN_SEQ_14r
#define MODIFY_PATGEN_PATGEN_SEQ_14r BCMI_MADURA_MODIFY_PATGEN_PATGEN_SEQ_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PATGEN_PATGEN_SEQ_14r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd130
 * DEVAD:    1
 * DESC:     TX FIR Control0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_PRE_OFFSET tx fir pre tap offset values -8 to +7 (2's complement formati.e. 0=0, 1=+1,..7=+7, 8=-8, 9=-7,..15=-1 )This field is used to adjust the Pre tap values
 *     TXFIR_MAIN_OFFSET tx fir main tap offset value -8 to +7 (2's complement formati.e. 0=0, 1=+1,..7=+7, 8=-8, 9=-7,..15=-1 )This field is used to adjust the Main tap values
 *     TXFIR_POST_OFFSET tx fir post tap offset value -8 to +7 (2's complement formati.e. 0=0, 1=+1,..7=+7, 8=-8, 9=-7,..15=-1 )This field is used to adjust the Post tap values
 */
#define BCMI_MADURA_TXFIR_CTL0r (0x0001d130 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL0.
 */
typedef union BCMI_MADURA_TXFIR_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_ctl0[1];
	uint32_t _txfir_ctl0;
} BCMI_MADURA_TXFIR_CTL0r_t;

#define BCMI_MADURA_TXFIR_CTL0r_CLR(r) (r).txfir_ctl0[0] = 0
#define BCMI_MADURA_TXFIR_CTL0r_SET(r,d) (r).txfir_ctl0[0] = d
#define BCMI_MADURA_TXFIR_CTL0r_GET(r) (r).txfir_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_CTL0r_TXFIR_POST_OFFSETf_GET(r) ((((r).txfir_ctl0[0]) >> 8) & 0xf)
#define BCMI_MADURA_TXFIR_CTL0r_TXFIR_POST_OFFSETf_SET(r,f) (r).txfir_ctl0[0]=(((r).txfir_ctl0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_GET(r) ((((r).txfir_ctl0[0]) >> 4) & 0xf)
#define BCMI_MADURA_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_SET(r,f) (r).txfir_ctl0[0]=(((r).txfir_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_GET(r) (((r).txfir_ctl0[0]) & 0xf)
#define BCMI_MADURA_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_SET(r,f) (r).txfir_ctl0[0]=(((r).txfir_ctl0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXFIR_CTL0.
 */
#define BCMI_MADURA_READ_TXFIR_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_CTL0r,_r._txfir_ctl0)
#define BCMI_MADURA_WRITE_TXFIR_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_CTL0r,_r._txfir_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL0r BCMI_MADURA_TXFIR_CTL0r
#define TXFIR_CTL0r_SIZE BCMI_MADURA_TXFIR_CTL0r_SIZE
typedef BCMI_MADURA_TXFIR_CTL0r_t TXFIR_CTL0r_t;
#define TXFIR_CTL0r_CLR BCMI_MADURA_TXFIR_CTL0r_CLR
#define TXFIR_CTL0r_SET BCMI_MADURA_TXFIR_CTL0r_SET
#define TXFIR_CTL0r_GET BCMI_MADURA_TXFIR_CTL0r_GET
#define TXFIR_CTL0r_TXFIR_POST_OFFSETf_GET BCMI_MADURA_TXFIR_CTL0r_TXFIR_POST_OFFSETf_GET
#define TXFIR_CTL0r_TXFIR_POST_OFFSETf_SET BCMI_MADURA_TXFIR_CTL0r_TXFIR_POST_OFFSETf_SET
#define TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_GET BCMI_MADURA_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_GET
#define TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_SET BCMI_MADURA_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_SET
#define TXFIR_CTL0r_TXFIR_PRE_OFFSETf_GET BCMI_MADURA_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_GET
#define TXFIR_CTL0r_TXFIR_PRE_OFFSETf_SET BCMI_MADURA_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_SET
#define READ_TXFIR_CTL0r BCMI_MADURA_READ_TXFIR_CTL0r
#define WRITE_TXFIR_CTL0r BCMI_MADURA_WRITE_TXFIR_CTL0r
#define MODIFY_TXFIR_CTL0r BCMI_MADURA_MODIFY_TXFIR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_CTL1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd131
 * DEVAD:    1
 * DESC:     TX FIR Control1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_POST2_OFFSET tx fir post2 tap offset value -8 to +7 (2's complement formati.e. 0=0, 1=+1,..7=+7, 8=-8, 9=-7,..15=-1 )This field is used to adjust the Post2 tap values
 *     TXFIR_POST3_OFFSET tx fir post3 tap offset value -8 to +7 (2's complement formati.e. 0=0, 1=+1,..7=+7, 8=-8, 9=-7,..15=-1 )This field is used to adjust the Post3 tap values
 */
#define BCMI_MADURA_TXFIR_CTL1r (0x0001d131 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL1.
 */
typedef union BCMI_MADURA_TXFIR_CTL1r_s {
	uint32_t v[1];
	uint32_t txfir_ctl1[1];
	uint32_t _txfir_ctl1;
} BCMI_MADURA_TXFIR_CTL1r_t;

#define BCMI_MADURA_TXFIR_CTL1r_CLR(r) (r).txfir_ctl1[0] = 0
#define BCMI_MADURA_TXFIR_CTL1r_SET(r,d) (r).txfir_ctl1[0] = d
#define BCMI_MADURA_TXFIR_CTL1r_GET(r) (r).txfir_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST3_OFFSETf_GET(r) ((((r).txfir_ctl1[0]) >> 4) & 0xf)
#define BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST3_OFFSETf_SET(r,f) (r).txfir_ctl1[0]=(((r).txfir_ctl1[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_GET(r) (((r).txfir_ctl1[0]) & 0xf)
#define BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_SET(r,f) (r).txfir_ctl1[0]=(((r).txfir_ctl1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXFIR_CTL1.
 */
#define BCMI_MADURA_READ_TXFIR_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_CTL1r,_r._txfir_ctl1)
#define BCMI_MADURA_WRITE_TXFIR_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_CTL1r,_r._txfir_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL1r BCMI_MADURA_TXFIR_CTL1r
#define TXFIR_CTL1r_SIZE BCMI_MADURA_TXFIR_CTL1r_SIZE
typedef BCMI_MADURA_TXFIR_CTL1r_t TXFIR_CTL1r_t;
#define TXFIR_CTL1r_CLR BCMI_MADURA_TXFIR_CTL1r_CLR
#define TXFIR_CTL1r_SET BCMI_MADURA_TXFIR_CTL1r_SET
#define TXFIR_CTL1r_GET BCMI_MADURA_TXFIR_CTL1r_GET
#define TXFIR_CTL1r_TXFIR_POST3_OFFSETf_GET BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST3_OFFSETf_GET
#define TXFIR_CTL1r_TXFIR_POST3_OFFSETf_SET BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST3_OFFSETf_SET
#define TXFIR_CTL1r_TXFIR_POST2_OFFSETf_GET BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_GET
#define TXFIR_CTL1r_TXFIR_POST2_OFFSETf_SET BCMI_MADURA_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_SET
#define READ_TXFIR_CTL1r BCMI_MADURA_READ_TXFIR_CTL1r
#define WRITE_TXFIR_CTL1r BCMI_MADURA_WRITE_TXFIR_CTL1r
#define MODIFY_TXFIR_CTL1r BCMI_MADURA_MODIFY_TXFIR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_CTL2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd132
 * DEVAD:    1
 * DESC:     TX FIR Control2 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_POST2      tx fir post2 tap value -16 ..+15 (2's complement formati.e. 0=0, 1=+1,..15=+15, 16=-16, 17=-15,..31=-1 )Post2 tap value only driven from a register
 *     TXFIR_POST3      tx fir post3 tap value -8 ..+7 (2's complement formati.e. 0=0, 1=+1,..7=+7, 8=-8, 9=-7,..15=-1 )Post3 tap value only driven from a register
 */
#define BCMI_MADURA_TXFIR_CTL2r (0x0001d132 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL2.
 */
typedef union BCMI_MADURA_TXFIR_CTL2r_s {
	uint32_t v[1];
	uint32_t txfir_ctl2[1];
	uint32_t _txfir_ctl2;
} BCMI_MADURA_TXFIR_CTL2r_t;

#define BCMI_MADURA_TXFIR_CTL2r_CLR(r) (r).txfir_ctl2[0] = 0
#define BCMI_MADURA_TXFIR_CTL2r_SET(r,d) (r).txfir_ctl2[0] = d
#define BCMI_MADURA_TXFIR_CTL2r_GET(r) (r).txfir_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST3f_GET(r) ((((r).txfir_ctl2[0]) >> 8) & 0xf)
#define BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST3f_SET(r,f) (r).txfir_ctl2[0]=(((r).txfir_ctl2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST2f_GET(r) (((r).txfir_ctl2[0]) & 0x1f)
#define BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST2f_SET(r,f) (r).txfir_ctl2[0]=(((r).txfir_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TXFIR_CTL2.
 */
#define BCMI_MADURA_READ_TXFIR_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_CTL2r,_r._txfir_ctl2)
#define BCMI_MADURA_WRITE_TXFIR_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_CTL2r,_r._txfir_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL2r BCMI_MADURA_TXFIR_CTL2r
#define TXFIR_CTL2r_SIZE BCMI_MADURA_TXFIR_CTL2r_SIZE
typedef BCMI_MADURA_TXFIR_CTL2r_t TXFIR_CTL2r_t;
#define TXFIR_CTL2r_CLR BCMI_MADURA_TXFIR_CTL2r_CLR
#define TXFIR_CTL2r_SET BCMI_MADURA_TXFIR_CTL2r_SET
#define TXFIR_CTL2r_GET BCMI_MADURA_TXFIR_CTL2r_GET
#define TXFIR_CTL2r_TXFIR_POST3f_GET BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST3f_GET
#define TXFIR_CTL2r_TXFIR_POST3f_SET BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST3f_SET
#define TXFIR_CTL2r_TXFIR_POST2f_GET BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST2f_GET
#define TXFIR_CTL2r_TXFIR_POST2f_SET BCMI_MADURA_TXFIR_CTL2r_TXFIR_POST2f_SET
#define READ_TXFIR_CTL2r BCMI_MADURA_READ_TXFIR_CTL2r
#define WRITE_TXFIR_CTL2r BCMI_MADURA_WRITE_TXFIR_CTL2r
#define MODIFY_TXFIR_CTL2r BCMI_MADURA_MODIFY_TXFIR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_STS0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd133
 * DEVAD:    1
 * DESC:     TX FIR Status0 Register
 * RESETVAL: 0x1808 (6152)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_PRE_AFTER_OVR tx fir pre tap value after override mux. status
 *     TXFIR_POST_AFTER_OVR tx fir post tap value after override mux. status
 */
#define BCMI_MADURA_TXFIR_STS0r (0x0001d133 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS0.
 */
typedef union BCMI_MADURA_TXFIR_STS0r_s {
	uint32_t v[1];
	uint32_t txfir_sts0[1];
	uint32_t _txfir_sts0;
} BCMI_MADURA_TXFIR_STS0r_t;

#define BCMI_MADURA_TXFIR_STS0r_CLR(r) (r).txfir_sts0[0] = 0
#define BCMI_MADURA_TXFIR_STS0r_SET(r,d) (r).txfir_sts0[0] = d
#define BCMI_MADURA_TXFIR_STS0r_GET(r) (r).txfir_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_GET(r) ((((r).txfir_sts0[0]) >> 8) & 0x3f)
#define BCMI_MADURA_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_SET(r,f) (r).txfir_sts0[0]=(((r).txfir_sts0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_GET(r) (((r).txfir_sts0[0]) & 0x1f)
#define BCMI_MADURA_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_SET(r,f) (r).txfir_sts0[0]=(((r).txfir_sts0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TXFIR_STS0.
 */
#define BCMI_MADURA_READ_TXFIR_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_STS0r,_r._txfir_sts0)
#define BCMI_MADURA_WRITE_TXFIR_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_STS0r,_r._txfir_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS0r BCMI_MADURA_TXFIR_STS0r
#define TXFIR_STS0r_SIZE BCMI_MADURA_TXFIR_STS0r_SIZE
typedef BCMI_MADURA_TXFIR_STS0r_t TXFIR_STS0r_t;
#define TXFIR_STS0r_CLR BCMI_MADURA_TXFIR_STS0r_CLR
#define TXFIR_STS0r_SET BCMI_MADURA_TXFIR_STS0r_SET
#define TXFIR_STS0r_GET BCMI_MADURA_TXFIR_STS0r_GET
#define TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_GET BCMI_MADURA_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_GET
#define TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_SET BCMI_MADURA_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_SET
#define TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_GET BCMI_MADURA_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_GET
#define TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_SET BCMI_MADURA_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_SET
#define READ_TXFIR_STS0r BCMI_MADURA_READ_TXFIR_STS0r
#define WRITE_TXFIR_STS0r BCMI_MADURA_WRITE_TXFIR_STS0r
#define MODIFY_TXFIR_STS0r BCMI_MADURA_MODIFY_TXFIR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_STS1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd134
 * DEVAD:    1
 * DESC:     TX FIR Status1 Register
 * RESETVAL: 0x50 (80)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_MAIN_AFTER_OVR tx fir main tap value after override mux. status
 */
#define BCMI_MADURA_TXFIR_STS1r (0x0001d134 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS1.
 */
typedef union BCMI_MADURA_TXFIR_STS1r_s {
	uint32_t v[1];
	uint32_t txfir_sts1[1];
	uint32_t _txfir_sts1;
} BCMI_MADURA_TXFIR_STS1r_t;

#define BCMI_MADURA_TXFIR_STS1r_CLR(r) (r).txfir_sts1[0] = 0
#define BCMI_MADURA_TXFIR_STS1r_SET(r,d) (r).txfir_sts1[0] = d
#define BCMI_MADURA_TXFIR_STS1r_GET(r) (r).txfir_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_GET(r) (((r).txfir_sts1[0]) & 0x7f)
#define BCMI_MADURA_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_SET(r,f) (r).txfir_sts1[0]=(((r).txfir_sts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_STS1.
 */
#define BCMI_MADURA_READ_TXFIR_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_STS1r,_r._txfir_sts1)
#define BCMI_MADURA_WRITE_TXFIR_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_STS1r,_r._txfir_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS1r BCMI_MADURA_TXFIR_STS1r
#define TXFIR_STS1r_SIZE BCMI_MADURA_TXFIR_STS1r_SIZE
typedef BCMI_MADURA_TXFIR_STS1r_t TXFIR_STS1r_t;
#define TXFIR_STS1r_CLR BCMI_MADURA_TXFIR_STS1r_CLR
#define TXFIR_STS1r_SET BCMI_MADURA_TXFIR_STS1r_SET
#define TXFIR_STS1r_GET BCMI_MADURA_TXFIR_STS1r_GET
#define TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_GET BCMI_MADURA_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_GET
#define TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_SET BCMI_MADURA_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_SET
#define READ_TXFIR_STS1r BCMI_MADURA_READ_TXFIR_STS1r
#define WRITE_TXFIR_STS1r BCMI_MADURA_WRITE_TXFIR_STS1r
#define MODIFY_TXFIR_STS1r BCMI_MADURA_MODIFY_TXFIR_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_STS2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd135
 * DEVAD:    1
 * DESC:     TX FIR Status2 Register
 * RESETVAL: 0x1808 (6152)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_PRE_ADJUSTED tx fir pre tap value after offset adjustment. status
 *     TXFIR_POST_ADJUSTED tx fir post tap value after offset adjustment. status
 */
#define BCMI_MADURA_TXFIR_STS2r (0x0001d135 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS2.
 */
typedef union BCMI_MADURA_TXFIR_STS2r_s {
	uint32_t v[1];
	uint32_t txfir_sts2[1];
	uint32_t _txfir_sts2;
} BCMI_MADURA_TXFIR_STS2r_t;

#define BCMI_MADURA_TXFIR_STS2r_CLR(r) (r).txfir_sts2[0] = 0
#define BCMI_MADURA_TXFIR_STS2r_SET(r,d) (r).txfir_sts2[0] = d
#define BCMI_MADURA_TXFIR_STS2r_GET(r) (r).txfir_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_GET(r) ((((r).txfir_sts2[0]) >> 8) & 0x3f)
#define BCMI_MADURA_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_SET(r,f) (r).txfir_sts2[0]=(((r).txfir_sts2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_GET(r) (((r).txfir_sts2[0]) & 0x1f)
#define BCMI_MADURA_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_SET(r,f) (r).txfir_sts2[0]=(((r).txfir_sts2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TXFIR_STS2.
 */
#define BCMI_MADURA_READ_TXFIR_STS2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_STS2r,_r._txfir_sts2)
#define BCMI_MADURA_WRITE_TXFIR_STS2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_STS2r,_r._txfir_sts2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS2r BCMI_MADURA_TXFIR_STS2r
#define TXFIR_STS2r_SIZE BCMI_MADURA_TXFIR_STS2r_SIZE
typedef BCMI_MADURA_TXFIR_STS2r_t TXFIR_STS2r_t;
#define TXFIR_STS2r_CLR BCMI_MADURA_TXFIR_STS2r_CLR
#define TXFIR_STS2r_SET BCMI_MADURA_TXFIR_STS2r_SET
#define TXFIR_STS2r_GET BCMI_MADURA_TXFIR_STS2r_GET
#define TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_GET BCMI_MADURA_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_GET
#define TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_SET BCMI_MADURA_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_SET
#define TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_GET BCMI_MADURA_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_GET
#define TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_SET BCMI_MADURA_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_SET
#define READ_TXFIR_STS2r BCMI_MADURA_READ_TXFIR_STS2r
#define WRITE_TXFIR_STS2r BCMI_MADURA_WRITE_TXFIR_STS2r
#define MODIFY_TXFIR_STS2r BCMI_MADURA_MODIFY_TXFIR_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_STS3
 * BLOCKS:   TX_FED
 * REGADDR:  0xd136
 * DEVAD:    1
 * DESC:     TX FIR Status3 Register
 * RESETVAL: 0x50 (80)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_MAIN_ADJUSTED tx fir main tap value after offset adjustment. status
 *     TXFIR_POST2_ADJUSTED tx fir post2 tap value after offset adjustment. statusThe value range is -16 ..+15 and it is in 2's complement formati.e. 0=0, 1=+1,..15=+15, 16=-16, 17=-15,..31=-1
 */
#define BCMI_MADURA_TXFIR_STS3r (0x0001d136 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS3.
 */
typedef union BCMI_MADURA_TXFIR_STS3r_s {
	uint32_t v[1];
	uint32_t txfir_sts3[1];
	uint32_t _txfir_sts3;
} BCMI_MADURA_TXFIR_STS3r_t;

#define BCMI_MADURA_TXFIR_STS3r_CLR(r) (r).txfir_sts3[0] = 0
#define BCMI_MADURA_TXFIR_STS3r_SET(r,d) (r).txfir_sts3[0] = d
#define BCMI_MADURA_TXFIR_STS3r_GET(r) (r).txfir_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_GET(r) ((((r).txfir_sts3[0]) >> 8) & 0x1f)
#define BCMI_MADURA_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_SET(r,f) (r).txfir_sts3[0]=(((r).txfir_sts3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_GET(r) (((r).txfir_sts3[0]) & 0x7f)
#define BCMI_MADURA_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_SET(r,f) (r).txfir_sts3[0]=(((r).txfir_sts3[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_STS3.
 */
#define BCMI_MADURA_READ_TXFIR_STS3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_STS3r,_r._txfir_sts3)
#define BCMI_MADURA_WRITE_TXFIR_STS3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_STS3r,_r._txfir_sts3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS3r BCMI_MADURA_TXFIR_STS3r
#define TXFIR_STS3r_SIZE BCMI_MADURA_TXFIR_STS3r_SIZE
typedef BCMI_MADURA_TXFIR_STS3r_t TXFIR_STS3r_t;
#define TXFIR_STS3r_CLR BCMI_MADURA_TXFIR_STS3r_CLR
#define TXFIR_STS3r_SET BCMI_MADURA_TXFIR_STS3r_SET
#define TXFIR_STS3r_GET BCMI_MADURA_TXFIR_STS3r_GET
#define TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_GET BCMI_MADURA_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_GET
#define TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_SET BCMI_MADURA_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_SET
#define TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_GET BCMI_MADURA_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_GET
#define TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_SET BCMI_MADURA_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_SET
#define READ_TXFIR_STS3r BCMI_MADURA_READ_TXFIR_STS3r
#define WRITE_TXFIR_STS3r BCMI_MADURA_WRITE_TXFIR_STS3r
#define MODIFY_TXFIR_STS3r BCMI_MADURA_MODIFY_TXFIR_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_STS4
 * BLOCKS:   TX_FED
 * REGADDR:  0xd137
 * DEVAD:    1
 * DESC:     TX FIR Status4 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_POST3_ADJUSTED tx fir post3 tap value after offset adjustment. statusThe value range is -8 ..+7 and it is in 2's complement formati.e. 0=0, 1=+1,..7=+7, 8=-8, 9=-7,..15=-1
 */
#define BCMI_MADURA_TXFIR_STS4r (0x0001d137 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS4.
 */
typedef union BCMI_MADURA_TXFIR_STS4r_s {
	uint32_t v[1];
	uint32_t txfir_sts4[1];
	uint32_t _txfir_sts4;
} BCMI_MADURA_TXFIR_STS4r_t;

#define BCMI_MADURA_TXFIR_STS4r_CLR(r) (r).txfir_sts4[0] = 0
#define BCMI_MADURA_TXFIR_STS4r_SET(r,d) (r).txfir_sts4[0] = d
#define BCMI_MADURA_TXFIR_STS4r_GET(r) (r).txfir_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET(r) (((r).txfir_sts4[0]) & 0xf)
#define BCMI_MADURA_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET(r,f) (r).txfir_sts4[0]=(((r).txfir_sts4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXFIR_STS4.
 */
#define BCMI_MADURA_READ_TXFIR_STS4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_STS4r,_r._txfir_sts4)
#define BCMI_MADURA_WRITE_TXFIR_STS4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_STS4r,_r._txfir_sts4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS4r BCMI_MADURA_TXFIR_STS4r
#define TXFIR_STS4r_SIZE BCMI_MADURA_TXFIR_STS4r_SIZE
typedef BCMI_MADURA_TXFIR_STS4r_t TXFIR_STS4r_t;
#define TXFIR_STS4r_CLR BCMI_MADURA_TXFIR_STS4r_CLR
#define TXFIR_STS4r_SET BCMI_MADURA_TXFIR_STS4r_SET
#define TXFIR_STS4r_GET BCMI_MADURA_TXFIR_STS4r_GET
#define TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET BCMI_MADURA_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET
#define TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET BCMI_MADURA_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET
#define READ_TXFIR_STS4r BCMI_MADURA_READ_TXFIR_STS4r
#define WRITE_TXFIR_STS4r BCMI_MADURA_WRITE_TXFIR_STS4r
#define MODIFY_TXFIR_STS4r BCMI_MADURA_MODIFY_TXFIR_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_UC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13a
 * DEVAD:    1
 * DESC:     Micro Control 0 Register
 * RESETVAL: 0xc160 (49504)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_TX_DISABLE micro tx disableThis field is used by the Microcontroller for tx disable control during CL93N72 forced modePlease see Falcon PMD Internal Functional Specification for details
 *     TX_DISABLE_TRIGGER Tx disable triggerWhen this bit is set to 1, it triggers a TX disable with timer starting at 0.No matter where the TX disable state is, it start a new timer and apply TX disable.This bit is self clearing
 *     DP_RESET_TX_DISABLE_DIS Tx disable based on data path reset0 - Enable tx disable based on data path reset1 - Disable tx disable based on data path resetNeed to set this bit to 1 if tx_disable_output_sel = 2'b01 (send TX power down).
 *     PMD_TX_DISABLE_PKILL Tx disable using the pmd_tx_disable pin disable control0 - enable tx disable from pmd_tx_disable pin1 - disable tx disable from pmd_tx_disable pin
 *     TX_DISABLE_TIMER_CTRL tx_disable timer value controlstx_disable_timer_ctrl[5] (MSB) selects the timer units0 - 2us units1 - 1ms unitstx_disable_timer_ctrl[4:0] (LSB[4:0]) = controls the number of units perthe list below0                 0 units1                 1 units2                 2 units3                 3 units4                 4 units5                 5 units6                 6 units7                 7 units8                 8 units9                10 units10               12 units11               14 units12               16 units13               20 units14               24 units15               28 units16               32 units17               40 units18               48 units19               56 units20               64 units21               80 units22               96 units23              112 units24              128 units25              160 units26              192 units27              224 units28              256 units29              320 units30              384 units31              448 units
 *     TX_EEE_QUIET_EN  Tx eee quiet mode control1 - Enable eee quiet mode when pmd_tx_mode (input pins) == 2'b010 - Disable eee quiet mode
 *     TX_EEE_ALERT_EN  Tx eee alert mode control1 - Enable eee alert mode when pmd_tx_mode (input pins) == 2'b100 - Disable eee alert mode
 */
#define BCMI_MADURA_TXFIR_UC_CTL0r (0x0001d13a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_UC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_UC_CTL0.
 */
typedef union BCMI_MADURA_TXFIR_UC_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_uc_ctl0[1];
	uint32_t _txfir_uc_ctl0;
} BCMI_MADURA_TXFIR_UC_CTL0r_t;

#define BCMI_MADURA_TXFIR_UC_CTL0r_CLR(r) (r).txfir_uc_ctl0[0] = 0
#define BCMI_MADURA_TXFIR_UC_CTL0r_SET(r,d) (r).txfir_uc_ctl0[0] = d
#define BCMI_MADURA_TXFIR_UC_CTL0r_GET(r) (r).txfir_uc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 15) & 0x1)
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 14) & 0x1)
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 4) & 0x3f)
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4)) | (63 << (16 + 4))
#define BCMI_MADURA_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 3) & 0x1)
#define BCMI_MADURA_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET(r) (((r).txfir_uc_ctl0[0]) & 0x1)
#define BCMI_MADURA_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_UC_CTL0.
 */
#define BCMI_MADURA_READ_TXFIR_UC_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_UC_CTL0r,_r._txfir_uc_ctl0)
#define BCMI_MADURA_WRITE_TXFIR_UC_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_UC_CTL0r,_r._txfir_uc_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_UC_CTL0r BCMI_MADURA_TXFIR_UC_CTL0r
#define TXFIR_UC_CTL0r_SIZE BCMI_MADURA_TXFIR_UC_CTL0r_SIZE
typedef BCMI_MADURA_TXFIR_UC_CTL0r_t TXFIR_UC_CTL0r_t;
#define TXFIR_UC_CTL0r_CLR BCMI_MADURA_TXFIR_UC_CTL0r_CLR
#define TXFIR_UC_CTL0r_SET BCMI_MADURA_TXFIR_UC_CTL0r_SET
#define TXFIR_UC_CTL0r_GET BCMI_MADURA_TXFIR_UC_CTL0r_GET
#define TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET
#define TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET
#define TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET
#define TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET BCMI_MADURA_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET
#define TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET
#define TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET
#define TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET BCMI_MADURA_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET
#define TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET BCMI_MADURA_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET
#define TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET BCMI_MADURA_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET
#define TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET BCMI_MADURA_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET
#define TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET
#define TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET BCMI_MADURA_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET BCMI_MADURA_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET BCMI_MADURA_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET
#define READ_TXFIR_UC_CTL0r BCMI_MADURA_READ_TXFIR_UC_CTL0r
#define WRITE_TXFIR_UC_CTL0r BCMI_MADURA_WRITE_TXFIR_UC_CTL0r
#define MODIFY_TXFIR_UC_CTL0r BCMI_MADURA_MODIFY_TXFIR_UC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_UC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_MISC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13b
 * DEVAD:    1
 * DESC:     Misc Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SDK_TX_DISABLE   sdk tx disableThis tx disable control field is for SDK use during TX programmingPlease see Eagle & Merlin PMD Internal Functional Specification for details
 *     TX_DISABLE_OUTPUT_SEL These bits select tx disable output function2'b00 - send electrical idles2'b01 - send power down2'b10 - send ones2'b11 - send zeroes
 */
#define BCMI_MADURA_TXFIR_MISC_CTL0r (0x0001d13b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_MISC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_CTL0.
 */
typedef union BCMI_MADURA_TXFIR_MISC_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_misc_ctl0[1];
	uint32_t _txfir_misc_ctl0;
} BCMI_MADURA_TXFIR_MISC_CTL0r_t;

#define BCMI_MADURA_TXFIR_MISC_CTL0r_CLR(r) (r).txfir_misc_ctl0[0] = 0
#define BCMI_MADURA_TXFIR_MISC_CTL0r_SET(r,d) (r).txfir_misc_ctl0[0] = d
#define BCMI_MADURA_TXFIR_MISC_CTL0r_GET(r) (r).txfir_misc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET(r) ((((r).txfir_misc_ctl0[0]) >> 2) & 0x3)
#define BCMI_MADURA_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET(r,f) (r).txfir_misc_ctl0[0]=(((r).txfir_misc_ctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_MADURA_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET(r) (((r).txfir_misc_ctl0[0]) & 0x1)
#define BCMI_MADURA_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET(r,f) (r).txfir_misc_ctl0[0]=(((r).txfir_misc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_CTL0.
 */
#define BCMI_MADURA_READ_TXFIR_MISC_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_MISC_CTL0r,_r._txfir_misc_ctl0)
#define BCMI_MADURA_WRITE_TXFIR_MISC_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_MISC_CTL0r,_r._txfir_misc_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_CTL0r BCMI_MADURA_TXFIR_MISC_CTL0r
#define TXFIR_MISC_CTL0r_SIZE BCMI_MADURA_TXFIR_MISC_CTL0r_SIZE
typedef BCMI_MADURA_TXFIR_MISC_CTL0r_t TXFIR_MISC_CTL0r_t;
#define TXFIR_MISC_CTL0r_CLR BCMI_MADURA_TXFIR_MISC_CTL0r_CLR
#define TXFIR_MISC_CTL0r_SET BCMI_MADURA_TXFIR_MISC_CTL0r_SET
#define TXFIR_MISC_CTL0r_GET BCMI_MADURA_TXFIR_MISC_CTL0r_GET
#define TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET BCMI_MADURA_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET
#define TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET BCMI_MADURA_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET
#define TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET BCMI_MADURA_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET
#define TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET BCMI_MADURA_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET
#define READ_TXFIR_MISC_CTL0r BCMI_MADURA_READ_TXFIR_MISC_CTL0r
#define WRITE_TXFIR_MISC_CTL0r BCMI_MADURA_WRITE_TXFIR_MISC_CTL0r
#define MODIFY_TXFIR_MISC_CTL0r BCMI_MADURA_MODIFY_TXFIR_MISC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_MISC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXFIR_MISC_STS0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13c
 * DEVAD:    1
 * DESC:     Misc Status 0 Register
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_DISABLE_STATUS tx disable statusWhen this bit is set it indicates the tx_disable is active due to:1) pin at AN/PCS to PMD Interface OR2) dp_reset being asserted3) register bit dedicated to micro use4) register bit dedicated to SDK use5) tx disable timer that guarntees minimum assertion time has not expired
 *     TX_ELEC_IDLE_STATUS tx electrical idle statusWhen this bit is set it indicates the tx elecrticl idle active due to:1) tx disable being programmed to send electrical idles or2) An internal logic signal derived from PMD interface pins for EEE TX MODE
 */
#define BCMI_MADURA_TXFIR_MISC_STS0r (0x0001d13c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXFIR_MISC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_STS0.
 */
typedef union BCMI_MADURA_TXFIR_MISC_STS0r_s {
	uint32_t v[1];
	uint32_t txfir_misc_sts0[1];
	uint32_t _txfir_misc_sts0;
} BCMI_MADURA_TXFIR_MISC_STS0r_t;

#define BCMI_MADURA_TXFIR_MISC_STS0r_CLR(r) (r).txfir_misc_sts0[0] = 0
#define BCMI_MADURA_TXFIR_MISC_STS0r_SET(r,d) (r).txfir_misc_sts0[0] = d
#define BCMI_MADURA_TXFIR_MISC_STS0r_GET(r) (r).txfir_misc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET(r) ((((r).txfir_misc_sts0[0]) >> 1) & 0x1)
#define BCMI_MADURA_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET(r,f) (r).txfir_misc_sts0[0]=(((r).txfir_misc_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET(r) (((r).txfir_misc_sts0[0]) & 0x1)
#define BCMI_MADURA_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET(r,f) (r).txfir_misc_sts0[0]=(((r).txfir_misc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_STS0.
 */
#define BCMI_MADURA_READ_TXFIR_MISC_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXFIR_MISC_STS0r,_r._txfir_misc_sts0)
#define BCMI_MADURA_WRITE_TXFIR_MISC_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXFIR_MISC_STS0r,_r._txfir_misc_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_STS0r BCMI_MADURA_TXFIR_MISC_STS0r
#define TXFIR_MISC_STS0r_SIZE BCMI_MADURA_TXFIR_MISC_STS0r_SIZE
typedef BCMI_MADURA_TXFIR_MISC_STS0r_t TXFIR_MISC_STS0r_t;
#define TXFIR_MISC_STS0r_CLR BCMI_MADURA_TXFIR_MISC_STS0r_CLR
#define TXFIR_MISC_STS0r_SET BCMI_MADURA_TXFIR_MISC_STS0r_SET
#define TXFIR_MISC_STS0r_GET BCMI_MADURA_TXFIR_MISC_STS0r_GET
#define TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET BCMI_MADURA_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET
#define TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET BCMI_MADURA_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET
#define TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET BCMI_MADURA_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET
#define TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET BCMI_MADURA_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET
#define READ_TXFIR_MISC_STS0r BCMI_MADURA_READ_TXFIR_MISC_STS0r
#define WRITE_TXFIR_MISC_STS0r BCMI_MADURA_WRITE_TXFIR_MISC_STS0r
#define MODIFY_TXFIR_MISC_STS0r BCMI_MADURA_MODIFY_TXFIR_MISC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXFIR_MISC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd140
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 0.
 * RESETVAL: 0xc803 (51203)
 * ACCESS:   R/W
 * FIELDS:
 *     VCO_STEP_TIME    VCO time between iterations
 *     VCO_START_TIME   VCO powerup wait time
 */
#define BCMI_MADURA_PLL_CAL_CTL0r (0x0001d140 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL0.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl0[1];
	uint32_t _pll_cal_ctl0;
} BCMI_MADURA_PLL_CAL_CTL0r_t;

#define BCMI_MADURA_PLL_CAL_CTL0r_CLR(r) (r).pll_cal_ctl0[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL0r_SET(r,d) (r).pll_cal_ctl0[0] = d
#define BCMI_MADURA_PLL_CAL_CTL0r_GET(r) (r).pll_cal_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL0r_VCO_START_TIMEf_GET(r) ((((r).pll_cal_ctl0[0]) >> 8) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL0r_VCO_START_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET(r) (((r).pll_cal_ctl0[0]) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL0.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL0r,_r._pll_cal_ctl0)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL0r,_r._pll_cal_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL0r BCMI_MADURA_PLL_CAL_CTL0r
#define PLL_CAL_CTL0r_SIZE BCMI_MADURA_PLL_CAL_CTL0r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL0r_t PLL_CAL_CTL0r_t;
#define PLL_CAL_CTL0r_CLR BCMI_MADURA_PLL_CAL_CTL0r_CLR
#define PLL_CAL_CTL0r_SET BCMI_MADURA_PLL_CAL_CTL0r_SET
#define PLL_CAL_CTL0r_GET BCMI_MADURA_PLL_CAL_CTL0r_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_GET BCMI_MADURA_PLL_CAL_CTL0r_VCO_START_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_SET BCMI_MADURA_PLL_CAL_CTL0r_VCO_START_TIMEf_SET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET BCMI_MADURA_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET BCMI_MADURA_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET
#define READ_PLL_CAL_CTL0r BCMI_MADURA_READ_PLL_CAL_CTL0r
#define WRITE_PLL_CAL_CTL0r BCMI_MADURA_WRITE_PLL_CAL_CTL0r
#define MODIFY_PLL_CAL_CTL0r BCMI_MADURA_MODIFY_PLL_CAL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd141
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 1.
 * RESETVAL: 0xc8ff (51455)
 * ACCESS:   R/W
 * FIELDS:
 *     RETRY_TIME       retry wait time
 *     PRE_FREQ_DET_TIME wait time prior to freq det
 */
#define BCMI_MADURA_PLL_CAL_CTL1r (0x0001d141 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL1.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl1[1];
	uint32_t _pll_cal_ctl1;
} BCMI_MADURA_PLL_CAL_CTL1r_t;

#define BCMI_MADURA_PLL_CAL_CTL1r_CLR(r) (r).pll_cal_ctl1[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL1r_SET(r,d) (r).pll_cal_ctl1[0] = d
#define BCMI_MADURA_PLL_CAL_CTL1r_GET(r) (r).pll_cal_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET(r) ((((r).pll_cal_ctl1[0]) >> 8) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL1r_RETRY_TIMEf_GET(r) (((r).pll_cal_ctl1[0]) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL1r_RETRY_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL1.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL1r,_r._pll_cal_ctl1)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL1r,_r._pll_cal_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL1r BCMI_MADURA_PLL_CAL_CTL1r
#define PLL_CAL_CTL1r_SIZE BCMI_MADURA_PLL_CAL_CTL1r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL1r_t PLL_CAL_CTL1r_t;
#define PLL_CAL_CTL1r_CLR BCMI_MADURA_PLL_CAL_CTL1r_CLR
#define PLL_CAL_CTL1r_SET BCMI_MADURA_PLL_CAL_CTL1r_SET
#define PLL_CAL_CTL1r_GET BCMI_MADURA_PLL_CAL_CTL1r_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET BCMI_MADURA_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET BCMI_MADURA_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET
#define PLL_CAL_CTL1r_RETRY_TIMEf_GET BCMI_MADURA_PLL_CAL_CTL1r_RETRY_TIMEf_GET
#define PLL_CAL_CTL1r_RETRY_TIMEf_SET BCMI_MADURA_PLL_CAL_CTL1r_RETRY_TIMEf_SET
#define READ_PLL_CAL_CTL1r BCMI_MADURA_READ_PLL_CAL_CTL1r
#define WRITE_PLL_CAL_CTL1r BCMI_MADURA_WRITE_PLL_CAL_CTL1r
#define MODIFY_PLL_CAL_CTL1r BCMI_MADURA_MODIFY_PLL_CAL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL2
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd142
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 2.
 * RESETVAL: 0xff01 (65281)
 * ACCESS:   R/W
 * FIELDS:
 *     WIN_CAL_CNTR     freq. counter's 8-lsbits stoping value
 *     RES_CAL_CNTR     freq. counter's 8-msbits starting value
 */
#define BCMI_MADURA_PLL_CAL_CTL2r (0x0001d142 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL2.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL2r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl2[1];
	uint32_t _pll_cal_ctl2;
} BCMI_MADURA_PLL_CAL_CTL2r_t;

#define BCMI_MADURA_PLL_CAL_CTL2r_CLR(r) (r).pll_cal_ctl2[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL2r_SET(r,d) (r).pll_cal_ctl2[0] = d
#define BCMI_MADURA_PLL_CAL_CTL2r_GET(r) (r).pll_cal_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET(r) ((((r).pll_cal_ctl2[0]) >> 8) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET(r) (((r).pll_cal_ctl2[0]) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL2.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL2r,_r._pll_cal_ctl2)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL2r,_r._pll_cal_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL2r BCMI_MADURA_PLL_CAL_CTL2r
#define PLL_CAL_CTL2r_SIZE BCMI_MADURA_PLL_CAL_CTL2r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL2r_t PLL_CAL_CTL2r_t;
#define PLL_CAL_CTL2r_CLR BCMI_MADURA_PLL_CAL_CTL2r_CLR
#define PLL_CAL_CTL2r_SET BCMI_MADURA_PLL_CAL_CTL2r_SET
#define PLL_CAL_CTL2r_GET BCMI_MADURA_PLL_CAL_CTL2r_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_GET BCMI_MADURA_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_SET BCMI_MADURA_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET BCMI_MADURA_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET BCMI_MADURA_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET
#define READ_PLL_CAL_CTL2r BCMI_MADURA_READ_PLL_CAL_CTL2r
#define WRITE_PLL_CAL_CTL2r BCMI_MADURA_WRITE_PLL_CAL_CTL2r
#define MODIFY_PLL_CAL_CTL2r BCMI_MADURA_MODIFY_PLL_CAL_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL3
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd143
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 3.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FAST_SEARCH_MODE force cap sequencer using select_m value for fast searching
 *     CAP_CNT_MASK_EN  masks cap count to allow control of max value
 *     CAP_SEQ_CYA      cya bit to revert cap sequencer back to original hyper/xaui sequence
 *     CAP_RESTART      force cap sequencer to restart, set to high then low
 *     CAP_RETRY_EN     enable retry on cap search failure
 *     CAP_FORCE_SLOWDOWN slowdown force value
 *     CAP_FORCE_SLOWDOWN_EN slowdown force enable
 *     CAP_SELECT_M_EN  Manual vco cap value mode, force using pll_range force value
 *     CAP_SELECT_M     Manual vco cap value (i.e pll_range[7:0])
 */
#define BCMI_MADURA_PLL_CAL_CTL3r (0x0001d143 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL3.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL3r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl3[1];
	uint32_t _pll_cal_ctl3;
} BCMI_MADURA_PLL_CAL_CTL3r_t;

#define BCMI_MADURA_PLL_CAL_CTL3r_CLR(r) (r).pll_cal_ctl3[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL3r_SET(r,d) (r).pll_cal_ctl3[0] = d
#define BCMI_MADURA_PLL_CAL_CTL3r_GET(r) (r).pll_cal_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET(r) ((((r).pll_cal_ctl3[0]) >> 8) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 7) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 6) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET(r) ((((r).pll_cal_ctl3[0]) >> 5) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 4) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_RESTARTf_GET(r) ((((r).pll_cal_ctl3[0]) >> 3) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_RESTARTf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET(r) ((((r).pll_cal_ctl3[0]) >> 2) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 1) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET(r) (((r).pll_cal_ctl3[0]) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL3.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL3r,_r._pll_cal_ctl3)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL3r,_r._pll_cal_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL3r BCMI_MADURA_PLL_CAL_CTL3r
#define PLL_CAL_CTL3r_SIZE BCMI_MADURA_PLL_CAL_CTL3r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL3r_t PLL_CAL_CTL3r_t;
#define PLL_CAL_CTL3r_CLR BCMI_MADURA_PLL_CAL_CTL3r_CLR
#define PLL_CAL_CTL3r_SET BCMI_MADURA_PLL_CAL_CTL3r_SET
#define PLL_CAL_CTL3r_GET BCMI_MADURA_PLL_CAL_CTL3r_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET
#define PLL_CAL_CTL3r_CAP_RESTARTf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_RESTARTf_GET
#define PLL_CAL_CTL3r_CAP_RESTARTf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_RESTARTf_SET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET BCMI_MADURA_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET BCMI_MADURA_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET BCMI_MADURA_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET BCMI_MADURA_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET
#define READ_PLL_CAL_CTL3r BCMI_MADURA_READ_PLL_CAL_CTL3r
#define WRITE_PLL_CAL_CTL3r BCMI_MADURA_WRITE_PLL_CAL_CTL3r
#define MODIFY_PLL_CAL_CTL3r BCMI_MADURA_MODIFY_PLL_CAL_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL4
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd144
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 4.
 * RESETVAL: 0xa80d (43021)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_FRC_VAL force pll lock value
 *     PLL_LOCK_FRC     force pll lock
 *     PLL_FORCE_CAP_PASS force cappass
 *     PLL_FORCE_CAP_PASS_EN enable pllforcecappass
 *     PLL_FORCE_CAP_DONE force capdone
 *     PLL_FORCE_CAP_DONE_EN enable pllforcecapdone
 *     PLL_FORCE_FPASS  force freqpass
 *     PLL_FORCE_FDONE  force freqdone
 *     PLL_FORCE_FDONE_EN enable pllforcefdone & pllforcefpass into pllseq
 *     VCO_RST_EN       enable pll reset when state machine is in start state. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 *     SLOWDN_XOR       invert sense of the slowdn/pll_low input from AFE
 *     FREQ_MONITOR_EN  continuously monitor vco freq
 *     FREQ_DET_RESTART_EN enable restart when not freq locked
 *     FREQ_DET_RETRY_EN enable retry on freq det failure
 *     VCO_DONE_EN      enable vco_done status bit
 *     PLL_SEQ_START    start pll sequencer by writing to 1'b0 followed by writing to 1'b1. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 */
#define BCMI_MADURA_PLL_CAL_CTL4r (0x0001d144 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL4.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL4r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl4[1];
	uint32_t _pll_cal_ctl4;
} BCMI_MADURA_PLL_CAL_CTL4r_t;

#define BCMI_MADURA_PLL_CAL_CTL4r_CLR(r) (r).pll_cal_ctl4[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL4r_SET(r,d) (r).pll_cal_ctl4[0] = d
#define BCMI_MADURA_PLL_CAL_CTL4r_GET(r) (r).pll_cal_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET(r) ((((r).pll_cal_ctl4[0]) >> 15) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_PLL_CAL_CTL4r_VCO_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 14) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_VCO_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 13) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 12) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 11) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_PLL_CAL_CTL4r_SLOWDN_XORf_GET(r) ((((r).pll_cal_ctl4[0]) >> 10) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_SLOWDN_XORf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PLL_CAL_CTL4r_VCO_RST_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 9) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_VCO_RST_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 8) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 7) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 6) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 5) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 4) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 3) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 2) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET(r) ((((r).pll_cal_ctl4[0]) >> 1) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET(r) (((r).pll_cal_ctl4[0]) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL4.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL4r,_r._pll_cal_ctl4)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL4r,_r._pll_cal_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL4r BCMI_MADURA_PLL_CAL_CTL4r
#define PLL_CAL_CTL4r_SIZE BCMI_MADURA_PLL_CAL_CTL4r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL4r_t PLL_CAL_CTL4r_t;
#define PLL_CAL_CTL4r_CLR BCMI_MADURA_PLL_CAL_CTL4r_CLR
#define PLL_CAL_CTL4r_SET BCMI_MADURA_PLL_CAL_CTL4r_SET
#define PLL_CAL_CTL4r_GET BCMI_MADURA_PLL_CAL_CTL4r_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_VCO_DONE_ENf_GET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_VCO_DONE_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET
#define PLL_CAL_CTL4r_SLOWDN_XORf_GET BCMI_MADURA_PLL_CAL_CTL4r_SLOWDN_XORf_GET
#define PLL_CAL_CTL4r_SLOWDN_XORf_SET BCMI_MADURA_PLL_CAL_CTL4r_SLOWDN_XORf_SET
#define PLL_CAL_CTL4r_VCO_RST_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_VCO_RST_ENf_GET
#define PLL_CAL_CTL4r_VCO_RST_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_VCO_RST_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET BCMI_MADURA_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET
#define READ_PLL_CAL_CTL4r BCMI_MADURA_READ_PLL_CAL_CTL4r
#define WRITE_PLL_CAL_CTL4r BCMI_MADURA_WRITE_PLL_CAL_CTL4r
#define MODIFY_PLL_CAL_CTL4r BCMI_MADURA_MODIFY_PLL_CAL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL5
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd145
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 5.
 * RESETVAL: 0x27 (39)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_DIVCNT    Refclk Divider Count to generate a slower divided refclk enable pulse for the PLL calibration logic.Most of the PLL calibration logic including PLL calibration state machines uses this divided version of the refclk clock signal.PLL calibration time is proportional to this register value.
 */
#define BCMI_MADURA_PLL_CAL_CTL5r (0x0001d145 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL5.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL5r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl5[1];
	uint32_t _pll_cal_ctl5;
} BCMI_MADURA_PLL_CAL_CTL5r_t;

#define BCMI_MADURA_PLL_CAL_CTL5r_CLR(r) (r).pll_cal_ctl5[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL5r_SET(r,d) (r).pll_cal_ctl5[0] = d
#define BCMI_MADURA_PLL_CAL_CTL5r_GET(r) (r).pll_cal_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET(r) (((r).pll_cal_ctl5[0]) & 0x3fff)
#define BCMI_MADURA_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET(r,f) (r).pll_cal_ctl5[0]=(((r).pll_cal_ctl5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL5.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL5r,_r._pll_cal_ctl5)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL5r,_r._pll_cal_ctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL5r BCMI_MADURA_PLL_CAL_CTL5r
#define PLL_CAL_CTL5r_SIZE BCMI_MADURA_PLL_CAL_CTL5r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL5r_t PLL_CAL_CTL5r_t;
#define PLL_CAL_CTL5r_CLR BCMI_MADURA_PLL_CAL_CTL5r_CLR
#define PLL_CAL_CTL5r_SET BCMI_MADURA_PLL_CAL_CTL5r_SET
#define PLL_CAL_CTL5r_GET BCMI_MADURA_PLL_CAL_CTL5r_GET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET BCMI_MADURA_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET BCMI_MADURA_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET
#define READ_PLL_CAL_CTL5r BCMI_MADURA_READ_PLL_CAL_CTL5r
#define WRITE_PLL_CAL_CTL5r BCMI_MADURA_WRITE_PLL_CAL_CTL5r
#define MODIFY_PLL_CAL_CTL5r BCMI_MADURA_MODIFY_PLL_CAL_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL6
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd146
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 6.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_DIVCNT_SEL Refclk Divider Mode Select.Value 7: will select refclk_divcnt[13:0] as refclk divider value which has max value of 16383.Value 0 to 6 are reserved for future use and should not be selected.
 */
#define BCMI_MADURA_PLL_CAL_CTL6r (0x0001d146 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL6.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL6r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl6[1];
	uint32_t _pll_cal_ctl6;
} BCMI_MADURA_PLL_CAL_CTL6r_t;

#define BCMI_MADURA_PLL_CAL_CTL6r_CLR(r) (r).pll_cal_ctl6[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL6r_SET(r,d) (r).pll_cal_ctl6[0] = d
#define BCMI_MADURA_PLL_CAL_CTL6r_GET(r) (r).pll_cal_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET(r) (((r).pll_cal_ctl6[0]) & 0x7)
#define BCMI_MADURA_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET(r,f) (r).pll_cal_ctl6[0]=(((r).pll_cal_ctl6[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL6.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL6r,_r._pll_cal_ctl6)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL6r,_r._pll_cal_ctl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL6r BCMI_MADURA_PLL_CAL_CTL6r
#define PLL_CAL_CTL6r_SIZE BCMI_MADURA_PLL_CAL_CTL6r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL6r_t PLL_CAL_CTL6r_t;
#define PLL_CAL_CTL6r_CLR BCMI_MADURA_PLL_CAL_CTL6r_CLR
#define PLL_CAL_CTL6r_SET BCMI_MADURA_PLL_CAL_CTL6r_SET
#define PLL_CAL_CTL6r_GET BCMI_MADURA_PLL_CAL_CTL6r_GET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET BCMI_MADURA_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET BCMI_MADURA_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET
#define READ_PLL_CAL_CTL6r BCMI_MADURA_READ_PLL_CAL_CTL6r
#define WRITE_PLL_CAL_CTL6r BCMI_MADURA_WRITE_PLL_CAL_CTL6r
#define MODIFY_PLL_CAL_CTL6r BCMI_MADURA_MODIFY_PLL_CAL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL7
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd147
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 7.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_MODE         PLL Multiplier.00000  = 64;00001  = 66;00010  = 80;00011  = 128;00100  = 132;00101  = 140;00110  = 160;00111  = 165;01000  = 168;01001  = 170;01010  = 175;01011  = 180;01100  = 184;01101  = 200;01110  = 224;01111  = 264;10000  = 96;10001  = 120;10010  = 144;10011  = 198'
 *     RESCAL_FRC_VAL   rescal force value.
 *     RESCAL_FRC       rescal force to use rescal force value.
 *     VCO_RANGE_ADJUST signed 2's complement by firmware for current temperature
 */
#define BCMI_MADURA_PLL_CAL_CTL7r (0x0001d147 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL7.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL7r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl7[1];
	uint32_t _pll_cal_ctl7;
} BCMI_MADURA_PLL_CAL_CTL7r_t;

#define BCMI_MADURA_PLL_CAL_CTL7r_CLR(r) (r).pll_cal_ctl7[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL7r_SET(r,d) (r).pll_cal_ctl7[0] = d
#define BCMI_MADURA_PLL_CAL_CTL7r_GET(r) (r).pll_cal_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_GET(r) ((((r).pll_cal_ctl7[0]) >> 11) & 0x1f)
#define BCMI_MADURA_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRCf_GET(r) ((((r).pll_cal_ctl7[0]) >> 10) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRCf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET(r) ((((r).pll_cal_ctl7[0]) >> 6) & 0xf)
#define BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_MADURA_PLL_CAL_CTL7r_PLL_MODEf_GET(r) (((r).pll_cal_ctl7[0]) & 0x1f)
#define BCMI_MADURA_PLL_CAL_CTL7r_PLL_MODEf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PLL_CAL_CTL7.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL7r,_r._pll_cal_ctl7)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL7r,_r._pll_cal_ctl7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL7r BCMI_MADURA_PLL_CAL_CTL7r
#define PLL_CAL_CTL7r_SIZE BCMI_MADURA_PLL_CAL_CTL7r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL7r_t PLL_CAL_CTL7r_t;
#define PLL_CAL_CTL7r_CLR BCMI_MADURA_PLL_CAL_CTL7r_CLR
#define PLL_CAL_CTL7r_SET BCMI_MADURA_PLL_CAL_CTL7r_SET
#define PLL_CAL_CTL7r_GET BCMI_MADURA_PLL_CAL_CTL7r_GET
#define PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_GET BCMI_MADURA_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_GET
#define PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_SET BCMI_MADURA_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_SET
#define PLL_CAL_CTL7r_RESCAL_FRCf_GET BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRCf_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_SET BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRCf_SET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET BCMI_MADURA_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET
#define PLL_CAL_CTL7r_PLL_MODEf_GET BCMI_MADURA_PLL_CAL_CTL7r_PLL_MODEf_GET
#define PLL_CAL_CTL7r_PLL_MODEf_SET BCMI_MADURA_PLL_CAL_CTL7r_PLL_MODEf_SET
#define READ_PLL_CAL_CTL7r BCMI_MADURA_READ_PLL_CAL_CTL7r
#define WRITE_PLL_CAL_CTL7r BCMI_MADURA_WRITE_PLL_CAL_CTL7r
#define MODIFY_PLL_CAL_CTL7r BCMI_MADURA_MODIFY_PLL_CAL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL_STS0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd148
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * RESETVAL: 0x80 (128)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL_LOCK_LH_LL   indicates change on pll_lock status bit. It is clear on read status register
 *     PLL_SEQ_PASS_LH_LL indicates change on pll_seq_pass status bit. It is clear on read status register
 *     PLL_SEQ_DONE_LH_LL indicates change on pll_seq_done status bit. It is clear on read status register
 *     FREQ_PASS_SM_LH_LL indicates change on freq_pass_sm status bit. It is clear on read status register
 *     FREQ_DONE_SM_LH_LL indicates change on freq_done_sm status bit. It is clear on read status register
 *     CAP_PASS_LH_LL   indicates change on cap_pass status bit. It is clear on read status register
 *     CAP_DONE_LH_LL   indicates change on cap_done status bit. It is clear on read status register
 *     PLL_PWRDN_OR     pll_pwrdn after dft muxing
 *     PLL_LOCK         status bit indicating PLL is locked
 *     PLL_SEQ_PASS     status bit indicating pll sequencer finised successfully
 *     PLL_SEQ_DONE     status bit indicating pll sequencer is done
 *     FREQ_PASS_SM     status bit indicating frequency lock
 *     FREQ_DONE_SM     status bit indicating freq det is done
 *     CAP_PASS         status indicating cap value was found
 *     CAP_DONE         status indicating cap sequencer is done
 *     LOST_PLL_LOCK_SM status bit indicating pll_lock was lost, clear on read
 */
#define BCMI_MADURA_PLL_CAL_CTL_STS0r (0x0001d148 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL_STS0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS0.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL_STS0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts0[1];
	uint32_t _pll_cal_ctl_sts0;
} BCMI_MADURA_PLL_CAL_CTL_STS0r_t;

#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CLR(r) (r).pll_cal_ctl_sts0[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_SET(r,d) (r).pll_cal_ctl_sts0[0] = d
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_GET(r) (r).pll_cal_ctl_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 15) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 14) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 13) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 12) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 11) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 10) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 9) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 8) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_PWRDN_ORf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 7) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_PWRDN_ORf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 6) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 5) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 4) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 3) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 2) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 1) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET(r) (((r).pll_cal_ctl_sts0[0]) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS0.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL_STS0r,_r._pll_cal_ctl_sts0)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL_STS0r,_r._pll_cal_ctl_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS0r BCMI_MADURA_PLL_CAL_CTL_STS0r
#define PLL_CAL_CTL_STS0r_SIZE BCMI_MADURA_PLL_CAL_CTL_STS0r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL_STS0r_t PLL_CAL_CTL_STS0r_t;
#define PLL_CAL_CTL_STS0r_CLR BCMI_MADURA_PLL_CAL_CTL_STS0r_CLR
#define PLL_CAL_CTL_STS0r_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_SET
#define PLL_CAL_CTL_STS0r_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONEf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONEf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASSf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASSf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET
#define PLL_CAL_CTL_STS0r_PLL_PWRDN_ORf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_PWRDN_ORf_GET
#define PLL_CAL_CTL_STS0r_PLL_PWRDN_ORf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_PWRDN_ORf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET BCMI_MADURA_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET
#define READ_PLL_CAL_CTL_STS0r BCMI_MADURA_READ_PLL_CAL_CTL_STS0r
#define WRITE_PLL_CAL_CTL_STS0r BCMI_MADURA_WRITE_PLL_CAL_CTL_STS0r
#define MODIFY_PLL_CAL_CTL_STS0r BCMI_MADURA_MODIFY_PLL_CAL_CTL_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL_STS1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd149
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CAP_SELECT       status bit indicating the selected cap value (i.e. pll_range[7:0])
 *     RESCAL_IN        rescal input value
 */
#define BCMI_MADURA_PLL_CAL_CTL_STS1r (0x0001d149 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL_STS1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS1.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL_STS1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts1[1];
	uint32_t _pll_cal_ctl_sts1;
} BCMI_MADURA_PLL_CAL_CTL_STS1r_t;

#define BCMI_MADURA_PLL_CAL_CTL_STS1r_CLR(r) (r).pll_cal_ctl_sts1[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL_STS1r_SET(r,d) (r).pll_cal_ctl_sts1[0] = d
#define BCMI_MADURA_PLL_CAL_CTL_STS1r_GET(r) (r).pll_cal_ctl_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL_STS1r_RESCAL_INf_GET(r) ((((r).pll_cal_ctl_sts1[0]) >> 8) & 0xf)
#define BCMI_MADURA_PLL_CAL_CTL_STS1r_RESCAL_INf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET(r) (((r).pll_cal_ctl_sts1[0]) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS1.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL_STS1r,_r._pll_cal_ctl_sts1)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL_STS1r,_r._pll_cal_ctl_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS1r BCMI_MADURA_PLL_CAL_CTL_STS1r
#define PLL_CAL_CTL_STS1r_SIZE BCMI_MADURA_PLL_CAL_CTL_STS1r_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL_STS1r_t PLL_CAL_CTL_STS1r_t;
#define PLL_CAL_CTL_STS1r_CLR BCMI_MADURA_PLL_CAL_CTL_STS1r_CLR
#define PLL_CAL_CTL_STS1r_SET BCMI_MADURA_PLL_CAL_CTL_STS1r_SET
#define PLL_CAL_CTL_STS1r_GET BCMI_MADURA_PLL_CAL_CTL_STS1r_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_GET BCMI_MADURA_PLL_CAL_CTL_STS1r_RESCAL_INf_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_SET BCMI_MADURA_PLL_CAL_CTL_STS1r_RESCAL_INf_SET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_GET BCMI_MADURA_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_SET BCMI_MADURA_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET
#define READ_PLL_CAL_CTL_STS1r BCMI_MADURA_READ_PLL_CAL_CTL_STS1r
#define WRITE_PLL_CAL_CTL_STS1r BCMI_MADURA_WRITE_PLL_CAL_CTL_STS1r
#define MODIFY_PLL_CAL_CTL_STS1r BCMI_MADURA_MODIFY_PLL_CAL_CTL_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_CAL_CTL_STS_DBG
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd14a
 * DEVAD:    1
 * DESC:     PLL CAL debug status registers register.
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     DBG_SLOWDN       Indicates AFE pll_low/slowdn output signal status.
 *     DBG_SLOWDN_CHANGE Indicates change on AFE pll_low/slowdn output signal. It is clear on read status register
 *     DBG_FDBCK        Indicates change on AFE fdbck output signal. clear on read status register.Will be used to see if fdbck clock from AFE is toggling and alive
 *     DBG_CAP_STATE_ONE_HOT Indicates one hot encoded Cap Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State    dbg_cap_state_one_hot[x] where x is :==================================================Start          0WaitAmpL       1WaitSpeedL     2IncCapL        3Finish         4
 *     DBG_PLL_STATE_ONE_HOT Indicates one hot encoded PLL Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State   dbg_pll_state_one_hot[x] where x is :==============================================Start          0WaitVco        1VcoAdjust      2WaitFreq       3FreqDet        4Fail           5FreqMon        6Finish         7
 */
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr (0x0001d14a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS_DBG.
 */
typedef union BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts_dbg[1];
	uint32_t _pll_cal_ctl_sts_dbg;
} BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_t;

#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_CLR(r) (r).pll_cal_ctl_sts_dbg[0] = 0
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_SET(r,d) (r).pll_cal_ctl_sts_dbg[0] = d
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_GET(r) (r).pll_cal_ctl_sts_dbg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 8) & 0xff)
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 3) & 0x1f)
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 2) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 1) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET(r) (((r).pll_cal_ctl_sts_dbg[0]) & 0x1)
#define BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS_DBG.
 */
#define BCMI_MADURA_READ_PLL_CAL_CTL_STS_DBGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_CAL_CTL_STS_DBGr,_r._pll_cal_ctl_sts_dbg)
#define BCMI_MADURA_WRITE_PLL_CAL_CTL_STS_DBGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_CAL_CTL_STS_DBGr,_r._pll_cal_ctl_sts_dbg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS_DBGr BCMI_MADURA_PLL_CAL_CTL_STS_DBGr
#define PLL_CAL_CTL_STS_DBGr_SIZE BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_SIZE
typedef BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_t PLL_CAL_CTL_STS_DBGr_t;
#define PLL_CAL_CTL_STS_DBGr_CLR BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_CLR
#define PLL_CAL_CTL_STS_DBGr_SET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_SET
#define PLL_CAL_CTL_STS_DBGr_GET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET BCMI_MADURA_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET
#define READ_PLL_CAL_CTL_STS_DBGr BCMI_MADURA_READ_PLL_CAL_CTL_STS_DBGr
#define WRITE_PLL_CAL_CTL_STS_DBGr BCMI_MADURA_WRITE_PLL_CAL_CTL_STS_DBGr
#define MODIFY_PLL_CAL_CTL_STS_DBGr BCMI_MADURA_MODIFY_PLL_CAL_CTL_STS_DBGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_CAL_CTL_STS_DBGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXCOM_CTL0
 * BLOCKS:   TXCOM
 * REGADDR:  0xd150
 * DEVAD:    1
 * DESC:     TX common control 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_POST_TAP_ALERT_VAL txfir post tap value during EEE alert mode
 *     TXCOM_PRE_TAP_ALERT_VAL txfir pre tap value during EEE alert mode
 */
#define BCMI_MADURA_TXCOM_CTL0r (0x0001d150 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXCOM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL0.
 */
typedef union BCMI_MADURA_TXCOM_CTL0r_s {
	uint32_t v[1];
	uint32_t txcom_ctl0[1];
	uint32_t _txcom_ctl0;
} BCMI_MADURA_TXCOM_CTL0r_t;

#define BCMI_MADURA_TXCOM_CTL0r_CLR(r) (r).txcom_ctl0[0] = 0
#define BCMI_MADURA_TXCOM_CTL0r_SET(r,d) (r).txcom_ctl0[0] = d
#define BCMI_MADURA_TXCOM_CTL0r_GET(r) (r).txcom_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXCOM_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_GET(r) ((((r).txcom_ctl0[0]) >> 8) & 0x1f)
#define BCMI_MADURA_TXCOM_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_SET(r,f) (r).txcom_ctl0[0]=(((r).txcom_ctl0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_TXCOM_CTL0r_TXCOM_POST_TAP_ALERT_VALf_GET(r) (((r).txcom_ctl0[0]) & 0x3f)
#define BCMI_MADURA_TXCOM_CTL0r_TXCOM_POST_TAP_ALERT_VALf_SET(r,f) (r).txcom_ctl0[0]=(((r).txcom_ctl0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TXCOM_CTL0.
 */
#define BCMI_MADURA_READ_TXCOM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXCOM_CTL0r,_r._txcom_ctl0)
#define BCMI_MADURA_WRITE_TXCOM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXCOM_CTL0r,_r._txcom_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL0r BCMI_MADURA_TXCOM_CTL0r
#define TXCOM_CTL0r_SIZE BCMI_MADURA_TXCOM_CTL0r_SIZE
typedef BCMI_MADURA_TXCOM_CTL0r_t TXCOM_CTL0r_t;
#define TXCOM_CTL0r_CLR BCMI_MADURA_TXCOM_CTL0r_CLR
#define TXCOM_CTL0r_SET BCMI_MADURA_TXCOM_CTL0r_SET
#define TXCOM_CTL0r_GET BCMI_MADURA_TXCOM_CTL0r_GET
#define TXCOM_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_GET BCMI_MADURA_TXCOM_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_GET
#define TXCOM_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_SET BCMI_MADURA_TXCOM_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_SET
#define TXCOM_CTL0r_TXCOM_POST_TAP_ALERT_VALf_GET BCMI_MADURA_TXCOM_CTL0r_TXCOM_POST_TAP_ALERT_VALf_GET
#define TXCOM_CTL0r_TXCOM_POST_TAP_ALERT_VALf_SET BCMI_MADURA_TXCOM_CTL0r_TXCOM_POST_TAP_ALERT_VALf_SET
#define READ_TXCOM_CTL0r BCMI_MADURA_READ_TXCOM_CTL0r
#define WRITE_TXCOM_CTL0r BCMI_MADURA_WRITE_TXCOM_CTL0r
#define MODIFY_TXCOM_CTL0r BCMI_MADURA_MODIFY_TXCOM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXCOM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXCOM_CTL1
 * BLOCKS:   TXCOM
 * REGADDR:  0xd151
 * DEVAD:    1
 * DESC:     TX common control 1 register
 * RESETVAL: 0x70 (112)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_MAIN_TAP_ALERT_VAL txfir main tap value during EEE alert mode
 */
#define BCMI_MADURA_TXCOM_CTL1r (0x0001d151 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXCOM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL1.
 */
typedef union BCMI_MADURA_TXCOM_CTL1r_s {
	uint32_t v[1];
	uint32_t txcom_ctl1[1];
	uint32_t _txcom_ctl1;
} BCMI_MADURA_TXCOM_CTL1r_t;

#define BCMI_MADURA_TXCOM_CTL1r_CLR(r) (r).txcom_ctl1[0] = 0
#define BCMI_MADURA_TXCOM_CTL1r_SET(r,d) (r).txcom_ctl1[0] = d
#define BCMI_MADURA_TXCOM_CTL1r_GET(r) (r).txcom_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXCOM_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_GET(r) (((r).txcom_ctl1[0]) & 0x7f)
#define BCMI_MADURA_TXCOM_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_SET(r,f) (r).txcom_ctl1[0]=(((r).txcom_ctl1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXCOM_CTL1.
 */
#define BCMI_MADURA_READ_TXCOM_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXCOM_CTL1r,_r._txcom_ctl1)
#define BCMI_MADURA_WRITE_TXCOM_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXCOM_CTL1r,_r._txcom_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL1r BCMI_MADURA_TXCOM_CTL1r
#define TXCOM_CTL1r_SIZE BCMI_MADURA_TXCOM_CTL1r_SIZE
typedef BCMI_MADURA_TXCOM_CTL1r_t TXCOM_CTL1r_t;
#define TXCOM_CTL1r_CLR BCMI_MADURA_TXCOM_CTL1r_CLR
#define TXCOM_CTL1r_SET BCMI_MADURA_TXCOM_CTL1r_SET
#define TXCOM_CTL1r_GET BCMI_MADURA_TXCOM_CTL1r_GET
#define TXCOM_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_GET BCMI_MADURA_TXCOM_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_GET
#define TXCOM_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_SET BCMI_MADURA_TXCOM_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_SET
#define READ_TXCOM_CTL1r BCMI_MADURA_READ_TXCOM_CTL1r
#define WRITE_TXCOM_CTL1r BCMI_MADURA_WRITE_TXCOM_CTL1r
#define MODIFY_TXCOM_CTL1r BCMI_MADURA_MODIFY_TXCOM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXCOM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXCOM_CTL2
 * BLOCKS:   TXCOM
 * REGADDR:  0xd152
 * DEVAD:    1
 * DESC:     TX common control 2 register
 * RESETVAL: 0x1f4 (500)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD Maximum Training Time in msPeriod/range is 500 ms
 */
#define BCMI_MADURA_TXCOM_CTL2r (0x0001d152 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXCOM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL2.
 */
typedef union BCMI_MADURA_TXCOM_CTL2r_s {
	uint32_t v[1];
	uint32_t txcom_ctl2[1];
	uint32_t _txcom_ctl2;
} BCMI_MADURA_TXCOM_CTL2r_t;

#define BCMI_MADURA_TXCOM_CTL2r_CLR(r) (r).txcom_ctl2[0] = 0
#define BCMI_MADURA_TXCOM_CTL2r_SET(r,d) (r).txcom_ctl2[0] = d
#define BCMI_MADURA_TXCOM_CTL2r_GET(r) (r).txcom_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXCOM_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_GET(r) (((r).txcom_ctl2[0]) & 0xffff)
#define BCMI_MADURA_TXCOM_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_SET(r,f) (r).txcom_ctl2[0]=(((r).txcom_ctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TXCOM_CTL2.
 */
#define BCMI_MADURA_READ_TXCOM_CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXCOM_CTL2r,_r._txcom_ctl2)
#define BCMI_MADURA_WRITE_TXCOM_CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXCOM_CTL2r,_r._txcom_ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL2r BCMI_MADURA_TXCOM_CTL2r
#define TXCOM_CTL2r_SIZE BCMI_MADURA_TXCOM_CTL2r_SIZE
typedef BCMI_MADURA_TXCOM_CTL2r_t TXCOM_CTL2r_t;
#define TXCOM_CTL2r_CLR BCMI_MADURA_TXCOM_CTL2r_CLR
#define TXCOM_CTL2r_SET BCMI_MADURA_TXCOM_CTL2r_SET
#define TXCOM_CTL2r_GET BCMI_MADURA_TXCOM_CTL2r_GET
#define TXCOM_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_GET BCMI_MADURA_TXCOM_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_GET
#define TXCOM_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_SET BCMI_MADURA_TXCOM_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_SET
#define READ_TXCOM_CTL2r BCMI_MADURA_READ_TXCOM_CTL2r
#define WRITE_TXCOM_CTL2r BCMI_MADURA_WRITE_TXCOM_CTL2r
#define MODIFY_TXCOM_CTL2r BCMI_MADURA_MODIFY_TXCOM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXCOM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXCOM_CTL3
 * BLOCKS:   TXCOM
 * REGADDR:  0xd153
 * DEVAD:    1
 * DESC:     TX common control 3 register
 * RESETVAL: 0xc8 (200)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL93N72_WAIT_CNTR_LIMIT Period/range is 100-300 framesPeriod to keep transiming frames after the local device has completed trainingThe units are training pages.
 */
#define BCMI_MADURA_TXCOM_CTL3r (0x0001d153 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXCOM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL3.
 */
typedef union BCMI_MADURA_TXCOM_CTL3r_s {
	uint32_t v[1];
	uint32_t txcom_ctl3[1];
	uint32_t _txcom_ctl3;
} BCMI_MADURA_TXCOM_CTL3r_t;

#define BCMI_MADURA_TXCOM_CTL3r_CLR(r) (r).txcom_ctl3[0] = 0
#define BCMI_MADURA_TXCOM_CTL3r_SET(r,d) (r).txcom_ctl3[0] = d
#define BCMI_MADURA_TXCOM_CTL3r_GET(r) (r).txcom_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXCOM_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_GET(r) (((r).txcom_ctl3[0]) & 0x1ff)
#define BCMI_MADURA_TXCOM_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_SET(r,f) (r).txcom_ctl3[0]=(((r).txcom_ctl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXCOM_CTL3.
 */
#define BCMI_MADURA_READ_TXCOM_CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXCOM_CTL3r,_r._txcom_ctl3)
#define BCMI_MADURA_WRITE_TXCOM_CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXCOM_CTL3r,_r._txcom_ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL3r BCMI_MADURA_TXCOM_CTL3r
#define TXCOM_CTL3r_SIZE BCMI_MADURA_TXCOM_CTL3r_SIZE
typedef BCMI_MADURA_TXCOM_CTL3r_t TXCOM_CTL3r_t;
#define TXCOM_CTL3r_CLR BCMI_MADURA_TXCOM_CTL3r_CLR
#define TXCOM_CTL3r_SET BCMI_MADURA_TXCOM_CTL3r_SET
#define TXCOM_CTL3r_GET BCMI_MADURA_TXCOM_CTL3r_GET
#define TXCOM_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_GET BCMI_MADURA_TXCOM_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_GET
#define TXCOM_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_SET BCMI_MADURA_TXCOM_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_SET
#define READ_TXCOM_CTL3r BCMI_MADURA_READ_TXCOM_CTL3r
#define WRITE_TXCOM_CTL3r BCMI_MADURA_WRITE_TXCOM_CTL3r
#define MODIFY_TXCOM_CTL3r BCMI_MADURA_MODIFY_TXCOM_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXCOM_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXCOM_CTL4
 * BLOCKS:   TXCOM
 * REGADDR:  0xd154
 * DEVAD:    1
 * DESC:     TX common control 4 register
 * RESETVAL: 0x1f4 (500)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD_2NDSET Maximum Training Time in msPeriod/range is 500 msSecond copy to allow for different training times for 10G and 25G links
 */
#define BCMI_MADURA_TXCOM_CTL4r (0x0001d154 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXCOM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL4.
 */
typedef union BCMI_MADURA_TXCOM_CTL4r_s {
	uint32_t v[1];
	uint32_t txcom_ctl4[1];
	uint32_t _txcom_ctl4;
} BCMI_MADURA_TXCOM_CTL4r_t;

#define BCMI_MADURA_TXCOM_CTL4r_CLR(r) (r).txcom_ctl4[0] = 0
#define BCMI_MADURA_TXCOM_CTL4r_SET(r,d) (r).txcom_ctl4[0] = d
#define BCMI_MADURA_TXCOM_CTL4r_GET(r) (r).txcom_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXCOM_CTL4r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD_2NDSETf_GET(r) (((r).txcom_ctl4[0]) & 0xffff)
#define BCMI_MADURA_TXCOM_CTL4r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD_2NDSETf_SET(r,f) (r).txcom_ctl4[0]=(((r).txcom_ctl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TXCOM_CTL4.
 */
#define BCMI_MADURA_READ_TXCOM_CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXCOM_CTL4r,_r._txcom_ctl4)
#define BCMI_MADURA_WRITE_TXCOM_CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXCOM_CTL4r,_r._txcom_ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL4r BCMI_MADURA_TXCOM_CTL4r
#define TXCOM_CTL4r_SIZE BCMI_MADURA_TXCOM_CTL4r_SIZE
typedef BCMI_MADURA_TXCOM_CTL4r_t TXCOM_CTL4r_t;
#define TXCOM_CTL4r_CLR BCMI_MADURA_TXCOM_CTL4r_CLR
#define TXCOM_CTL4r_SET BCMI_MADURA_TXCOM_CTL4r_SET
#define TXCOM_CTL4r_GET BCMI_MADURA_TXCOM_CTL4r_GET
#define TXCOM_CTL4r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD_2NDSETf_GET BCMI_MADURA_TXCOM_CTL4r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD_2NDSETf_GET
#define TXCOM_CTL4r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD_2NDSETf_SET BCMI_MADURA_TXCOM_CTL4r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD_2NDSETf_SET
#define READ_TXCOM_CTL4r BCMI_MADURA_READ_TXCOM_CTL4r
#define WRITE_TXCOM_CTL4r BCMI_MADURA_WRITE_TXCOM_CTL4r
#define MODIFY_TXCOM_CTL4r BCMI_MADURA_MODIFY_TXCOM_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXCOM_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TXCOM_CTL5
 * BLOCKS:   TXCOM
 * REGADDR:  0xd155
 * DEVAD:    1
 * DESC:     TX common control 5 register
 * RESETVAL: 0xc8 (200)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL93N72_WAIT_CNTR_LIMIT_2NDSET Period/range is 100-300 framesPeriod to keep transmiting frames after the local device has completed trainingThe units are training pages. Second copy to allow for different training times for 10G and 25G links
 */
#define BCMI_MADURA_TXCOM_CTL5r (0x0001d155 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TXCOM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_CTL5.
 */
typedef union BCMI_MADURA_TXCOM_CTL5r_s {
	uint32_t v[1];
	uint32_t txcom_ctl5[1];
	uint32_t _txcom_ctl5;
} BCMI_MADURA_TXCOM_CTL5r_t;

#define BCMI_MADURA_TXCOM_CTL5r_CLR(r) (r).txcom_ctl5[0] = 0
#define BCMI_MADURA_TXCOM_CTL5r_SET(r,d) (r).txcom_ctl5[0] = d
#define BCMI_MADURA_TXCOM_CTL5r_GET(r) (r).txcom_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TXCOM_CTL5r_TXCOM_CL93N72_WAIT_CNTR_LIMIT_2NDSETf_GET(r) (((r).txcom_ctl5[0]) & 0x1ff)
#define BCMI_MADURA_TXCOM_CTL5r_TXCOM_CL93N72_WAIT_CNTR_LIMIT_2NDSETf_SET(r,f) (r).txcom_ctl5[0]=(((r).txcom_ctl5[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXCOM_CTL5.
 */
#define BCMI_MADURA_READ_TXCOM_CTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TXCOM_CTL5r,_r._txcom_ctl5)
#define BCMI_MADURA_WRITE_TXCOM_CTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TXCOM_CTL5r,_r._txcom_ctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_CTL5r BCMI_MADURA_TXCOM_CTL5r
#define TXCOM_CTL5r_SIZE BCMI_MADURA_TXCOM_CTL5r_SIZE
typedef BCMI_MADURA_TXCOM_CTL5r_t TXCOM_CTL5r_t;
#define TXCOM_CTL5r_CLR BCMI_MADURA_TXCOM_CTL5r_CLR
#define TXCOM_CTL5r_SET BCMI_MADURA_TXCOM_CTL5r_SET
#define TXCOM_CTL5r_GET BCMI_MADURA_TXCOM_CTL5r_GET
#define TXCOM_CTL5r_TXCOM_CL93N72_WAIT_CNTR_LIMIT_2NDSETf_GET BCMI_MADURA_TXCOM_CTL5r_TXCOM_CL93N72_WAIT_CNTR_LIMIT_2NDSETf_GET
#define TXCOM_CTL5r_TXCOM_CL93N72_WAIT_CNTR_LIMIT_2NDSETf_SET BCMI_MADURA_TXCOM_CTL5r_TXCOM_CL93N72_WAIT_CNTR_LIMIT_2NDSETf_SET
#define READ_TXCOM_CTL5r BCMI_MADURA_READ_TXCOM_CTL5r
#define WRITE_TXCOM_CTL5r BCMI_MADURA_WRITE_TXCOM_CTL5r
#define MODIFY_TXCOM_CTL5r BCMI_MADURA_MODIFY_TXCOM_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TXCOM_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_CHK_CNT_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd160
 * DEVAD:    1
 * DESC:     PRBS Checker Count Control
 * RESETVAL: 0x602 (1538)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_LOCK_CNT specifies the number of consecutive valid clock cycles without any bit errorfor PRBS checker to go into PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will lock as soon as it gets the first clock cycle with no bit error.likewise 31 indicates that PRBS will lock as soon as it gets the 32 consecutive clocks with no error.
 *     PRBS_CHK_OOL_CNT specifies the number of consecutive valid clock cycles with 1 or more bit errorsfor PRBS checker to go out of PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will go out of lock as soon as it gets the first clock cycle with 1 or more bit errors.likewise 31 indicates that PRBS will go out of lock as soon as it gets the 32 consecutive clocks with 1 or more errors.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr (0x0001d160 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CNT_CFG.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cnt_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cnt_cfg;
} BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_t;

#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cnt_cfg[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cnt_cfg[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_GET(r) (r).tlb_rx_prbs_chk_cnt_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 8) & 0x1f)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET(r) (((r).tlb_rx_prbs_chk_cnt_cfg[0]) & 0x1f)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CNT_CFG.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr,_r._tlb_rx_prbs_chk_cnt_cfg)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr,_r._tlb_rx_prbs_chk_cnt_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CNT_CFGr BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr
#define TLB_RX_PRBS_CHK_CNT_CFGr_SIZE BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_t TLB_RX_PRBS_CHK_CNT_CFGr_t;
#define TLB_RX_PRBS_CHK_CNT_CFGr_CLR BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_CLR
#define TLB_RX_PRBS_CHK_CNT_CFGr_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_MADURA_READ_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_MADURA_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_CHK_CNT_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_CHK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd161
 * DEVAD:    1
 * DESC:     PRBS Checker Control
 * RESETVAL: 0x12a (298)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN      PRBS checker enable.1 => enable  the PRBS checker.0 => disable the PRBS checker.
 *     PRBS_CHK_MODE_SEL PRBS checker mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_CHK_INV     PRBS Invert enable.1 => will invert all the data bits to the PRBS checker.0 => will send normal data to the PRBS checker.
 *     PRBS_CHK_MODE    PRBS LOCK state machine select.2'd0 -> Self-sync mode w/ hysteresis. PRBS seed register is continuously seeded with previous received bits.This mode results in faster locking, but bit errors are counted multiple times (often by 3x).2'd1 -> Initial seed mode w/ hysteresis. PRBS seed registers is seeded with previous received bits only till PRBS lock isacquired and then they run locally independently from the received data until the checker goes out of PRBS lock.2'd2 -> Initial seed mode w/o hysteresis. Similar to mode 1 above except once locked it stays locked until PRBS is disabled.2'd3 -> reserved for future use.
 *     PRBS_CHK_EN_AUTO_MODE PRBS Checker Enable Mode Control.1 => select (rx_dsc_lock & prbs_chk_en) as PRBS checker enable control.0 => select                prbs_chk_en  as PRBS checker enable control.
 *     PRBS_BURST_LEN_CHK_EN 0 => disbale, 1=> enable (default)
 *     PRBS_CHK_ERR_CNT_BURST_MODE PRBS Error Counter Mode.1 => Each busrt of error will be counted as 1 error in the error counter. Each error busrt must be separated by 1 error-free cycle of data which in worst case should be 39 bits.0 => Each bit error will be counted.
 *     TRNSUM_ERROR_COUNT_EN Training sum error counter Mode enable.1 => will make the PRBS error counter used as trnsum_error counter. PRBS checker can not be used during this mode.0 => PRBS checker mode.
 *     PRBS_CHK_CLK_EN_FRC_ON PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 *     PRBS_CHK_BURST_ERR_CNT_EN PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr (0x0001d161 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CFG.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cfg;
} BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_t;

#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cfg[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cfg[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_GET(r) (r).tlb_rx_prbs_chk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 15) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 11) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 10) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 9) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 8) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 7) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 5) & 0x3)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 4) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 1) & 0x7)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET(r) (((r).tlb_rx_prbs_chk_cfg[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CFG.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_CHK_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr,_r._tlb_rx_prbs_chk_cfg)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr,_r._tlb_rx_prbs_chk_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CFGr BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr
#define TLB_RX_PRBS_CHK_CFGr_SIZE BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_t TLB_RX_PRBS_CHK_CFGr_t;
#define TLB_RX_PRBS_CHK_CFGr_CLR BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_CLR
#define TLB_RX_PRBS_CHK_CFGr_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_SET
#define TLB_RX_PRBS_CHK_CFGr_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET
#define READ_TLB_RX_PRBS_CHK_CFGr BCMI_MADURA_READ_TLB_RX_PRBS_CHK_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CFGr BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CFGr BCMI_MADURA_MODIFY_TLB_RX_PRBS_CHK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_CHK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_DIG_LPBK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd162
 * DEVAD:    1
 * DESC:     Digital Loopback Control
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     DIG_LPBK_EN      TX to RX Parallel Loopback (Digital Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     DIG_LPBK_PD_MODE Digital Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     DIG_LPBK_PD_BIAS_EN 1'b1 will enable PD inc bias mode where there will be inc generated every 16th clock cycle..1'b0 will disable the PD bias mode so inc/dec will be generated based on the PD output.
 */
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr (0x0001d162 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_CFG.
 */
typedef union BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_cfg[1];
	uint32_t _tlb_rx_dig_lpbk_cfg;
} BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_t;

#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_CLR(r) (r).tlb_rx_dig_lpbk_cfg[0] = 0
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_SET(r,d) (r).tlb_rx_dig_lpbk_cfg[0] = d
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_GET(r) (r).tlb_rx_dig_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 3) & 0x1)
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET(r) (((r).tlb_rx_dig_lpbk_cfg[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_CFG.
 */
#define BCMI_MADURA_READ_TLB_RX_DIG_LPBK_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr,_r._tlb_rx_dig_lpbk_cfg)
#define BCMI_MADURA_WRITE_TLB_RX_DIG_LPBK_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr,_r._tlb_rx_dig_lpbk_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_CFGr BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr
#define TLB_RX_DIG_LPBK_CFGr_SIZE BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_SIZE
typedef BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_t TLB_RX_DIG_LPBK_CFGr_t;
#define TLB_RX_DIG_LPBK_CFGr_CLR BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_CLR
#define TLB_RX_DIG_LPBK_CFGr_SET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_SET
#define TLB_RX_DIG_LPBK_CFGr_GET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET
#define READ_TLB_RX_DIG_LPBK_CFGr BCMI_MADURA_READ_TLB_RX_DIG_LPBK_CFGr
#define WRITE_TLB_RX_DIG_LPBK_CFGr BCMI_MADURA_WRITE_TLB_RX_DIG_LPBK_CFGr
#define MODIFY_TLB_RX_DIG_LPBK_CFGr BCMI_MADURA_MODIFY_TLB_RX_DIG_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_DIG_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_TLB_RX_MISC_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd163
 * DEVAD:    1
 * DESC:     TLB RX Misc. Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PMD_DP_INVERT RX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     DBG_MASK_DIG_LPBK_EN Mask bit for dig_lpbk_en in the pmd_rx_lock equation. This is a debug register.1 => pmd_rx_lock will be forced to 1'b0 during digital loopback.0 => pmd_rx_lock will be forced to 1'b1 during digital loopback.
 *     TLB_RX_DIFF_DEC_EN 1'b1 will enable the Differential Decoder for pmd_rx_data. Only applicable to PCS RX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 */
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr (0x0001d163 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_TLB_RX_MISC_CFG.
 */
typedef union BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_tlb_rx_misc_cfg[1];
	uint32_t _tlb_rx_tlb_rx_misc_cfg;
} BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_t;

#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_CLR(r) (r).tlb_rx_tlb_rx_misc_cfg[0] = 0
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_SET(r,d) (r).tlb_rx_tlb_rx_misc_cfg[0] = d
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_GET(r) (r).tlb_rx_tlb_rx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET(r) (((r).tlb_rx_tlb_rx_misc_cfg[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_TLB_RX_MISC_CFG.
 */
#define BCMI_MADURA_READ_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr,_r._tlb_rx_tlb_rx_misc_cfg)
#define BCMI_MADURA_WRITE_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr,_r._tlb_rx_tlb_rx_misc_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_TLB_RX_MISC_CFGr BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr
#define TLB_RX_TLB_RX_MISC_CFGr_SIZE BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_SIZE
typedef BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_t TLB_RX_TLB_RX_MISC_CFGr_t;
#define TLB_RX_TLB_RX_MISC_CFGr_CLR BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_CLR
#define TLB_RX_TLB_RX_MISC_CFGr_SET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_SET
#define TLB_RX_TLB_RX_MISC_CFGr_GET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_GET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET
#define READ_TLB_RX_TLB_RX_MISC_CFGr BCMI_MADURA_READ_TLB_RX_TLB_RX_MISC_CFGr
#define WRITE_TLB_RX_TLB_RX_MISC_CFGr BCMI_MADURA_WRITE_TLB_RX_TLB_RX_MISC_CFGr
#define MODIFY_TLB_RX_TLB_RX_MISC_CFGr BCMI_MADURA_MODIFY_TLB_RX_TLB_RX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_TLB_RX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_CHK_EN_TMR_CTL
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd164
 * DEVAD:    1
 * DESC:     TLB RX PRBS Checker Enable Timer Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN_TIMER_MODE prbs_chk_en timer mode.2'b0x => prbs_chk_en timer is disabled and PRBS checker mode is enabled as per prbs_chk_en register.2'b10 => use heartbeat_toggle_1us for the timer.2'b11 => use heartbeat_toggle_1ms for the timer.
 *     PRBS_CHK_EN_TIMEOUT PRBS timer timeout value.Valid range 0 to 31 which maps to 0 to 448. Should be programmed before enabling the PRBS checker in timer mode.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr (0x0001d164 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_en_tmr_ctl[1];
	uint32_t _tlb_rx_prbs_chk_en_tmr_ctl;
} BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;

#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET(r,d) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET(r) ((((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) >> 8) & 0x1f)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET(r) (((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) & 0x3)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr,_r._tlb_rx_prbs_chk_en_tmr_ctl)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr,_r._tlb_rx_prbs_chk_en_tmr_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET
#define READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_MADURA_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_MADURA_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_CHK_EN_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd165
 * DEVAD:    1
 * DESC:     PRBS Checker Burst Error Counter Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_BURST_ERR_CNT PRBS Checker Burst Error Counter Status Register. It is a clear on read register. This register countsthe number of Burst in errors separated by atleast 1 clock cycle worth of data without any bit in error.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr (0x0001d165 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_burst_err_cnt_sts[1];
	uint32_t _tlb_rx_prbs_chk_burst_err_cnt_sts;
} BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;

#define BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET(r,d) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET(r) (((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]) & 0x3ff)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]=(((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,_r._tlb_rx_prbs_chk_burst_err_cnt_sts)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,_r._tlb_rx_prbs_chk_burst_err_cnt_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_MADURA_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_MADURA_MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_DBG_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd166
 * DEVAD:    1
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DBG_PMD_RX_LOCK  Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     DBG_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 */
#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr (0x0001d166 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DBG_PMD_RX_LOCK_STS.
 */
typedef union BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dbg_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_dbg_pmd_rx_lock_sts;
} BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_t;

#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = 0
#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = d
#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DBG_PMD_RX_LOCK_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr,_r._tlb_rx_dbg_pmd_rx_lock_sts)
#define BCMI_MADURA_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr,_r._tlb_rx_dbg_pmd_rx_lock_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_t TLB_RX_DBG_PMD_RX_LOCK_STSr_t;
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SET BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_GET BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET
#define READ_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_MADURA_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_MADURA_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_MADURA_MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_DBG_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_UC_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd167
 * DEVAD:    1
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UC_PMD_RX_LOCK   Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     UC_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 */
#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr (0x0001d167 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_UC_PMD_RX_LOCK_STS.
 */
typedef union BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_uc_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_uc_pmd_rx_lock_sts;
} BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_t;

#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = 0
#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = d
#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_uc_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_uc_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_UC_PMD_RX_LOCK_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr,_r._tlb_rx_uc_pmd_rx_lock_sts)
#define BCMI_MADURA_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr,_r._tlb_rx_uc_pmd_rx_lock_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_t TLB_RX_UC_PMD_RX_LOCK_STSr_t;
#define TLB_RX_UC_PMD_RX_LOCK_STSr_CLR BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SET BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_GET BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET
#define READ_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_MADURA_READ_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_MADURA_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_MADURA_MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_UC_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_DIG_LPBK_PD_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd168
 * DEVAD:    1
 * DESC:     Digital Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     DIG_LPBK_PD_LATE_IND 1 means dp_rclk20 is sampling data late so reduce the delay of the dp_rclk20 clock phase. This will result in RX PI phase step decrement.
 *     DIG_LPBK_PD_EARLY_IND 1 means dp_rclk20 is sampling data earlier so delay the dp_rclk20 clock phase. This will result in RX PI phase step increment.
 */
#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr (0x0001d168 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_PD_STS.
 */
typedef union BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_pd_sts[1];
	uint32_t _tlb_rx_dig_lpbk_pd_sts;
} BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_t;

#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_CLR(r) (r).tlb_rx_dig_lpbk_pd_sts[0] = 0
#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_SET(r,d) (r).tlb_rx_dig_lpbk_pd_sts[0] = d
#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_GET(r) (r).tlb_rx_dig_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_rx_dig_lpbk_pd_sts[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_PD_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr,_r._tlb_rx_dig_lpbk_pd_sts)
#define BCMI_MADURA_WRITE_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr,_r._tlb_rx_dig_lpbk_pd_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_PD_STSr BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr
#define TLB_RX_DIG_LPBK_PD_STSr_SIZE BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_t TLB_RX_DIG_LPBK_PD_STSr_t;
#define TLB_RX_DIG_LPBK_PD_STSr_CLR BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_CLR
#define TLB_RX_DIG_LPBK_PD_STSr_SET BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_SET
#define TLB_RX_DIG_LPBK_PD_STSr_GET BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET
#define READ_TLB_RX_DIG_LPBK_PD_STSr BCMI_MADURA_READ_TLB_RX_DIG_LPBK_PD_STSr
#define WRITE_TLB_RX_DIG_LPBK_PD_STSr BCMI_MADURA_WRITE_TLB_RX_DIG_LPBK_PD_STSr
#define MODIFY_TLB_RX_DIG_LPBK_PD_STSr BCMI_MADURA_MODIFY_TLB_RX_DIG_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_DIG_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_CHK_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd169
 * DEVAD:    1
 * DESC:     PRBS Checker LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_LOCK    PRBS Checker LOCK Indication. This is a live indication of the status of the PRBS Checker state machine.1 => PRBS Checker is in LOCKED state.0 => PRBS Checker is out of LOCK state and state machine is searching for a LOCK.
 *     PRBS_CHK_ERR_CNT_NO_CLR PRBS Checker Error Counter which does not get cleared upon read.MSB bit 14 is OR of the MSB bits [30:14] of the internal error counter.LSB bits [13:0] are assigned to LSB bits [13:0] of the internal error counter.It can be cleared by reading the status register prbs_chk_err_cnt_msb.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr (0x0001d169 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_LOCK_STS.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_lock_sts[1];
	uint32_t _tlb_rx_prbs_chk_lock_sts;
} BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_t;

#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_CLR(r) (r).tlb_rx_prbs_chk_lock_sts[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_SET(r,d) (r).tlb_rx_prbs_chk_lock_sts[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_GET(r) (r).tlb_rx_prbs_chk_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET(r) ((((r).tlb_rx_prbs_chk_lock_sts[0]) >> 1) & 0x7fff)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1)) | (32767 << (16 + 1))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET(r) (((r).tlb_rx_prbs_chk_lock_sts[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_LOCK_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr,_r._tlb_rx_prbs_chk_lock_sts)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr,_r._tlb_rx_prbs_chk_lock_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_LOCK_STSr BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr
#define TLB_RX_PRBS_CHK_LOCK_STSr_SIZE BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_t TLB_RX_PRBS_CHK_LOCK_STSr_t;
#define TLB_RX_PRBS_CHK_LOCK_STSr_CLR BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_CLR
#define TLB_RX_PRBS_CHK_LOCK_STSr_SET BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_GET BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET
#define READ_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_MADURA_READ_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITE_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr
#define MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_MADURA_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_CHK_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16a
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter MSB Status
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_MSB 15 bits MSB portion of PRBS Checker Error Counter Status Register. It is a clear on read register.Once MSB bits [30:16] of the counter are read then LSB bits [15:0] of the error counter is loadedinto a holding register and internal PRBS error counter's all bits are cleared to 0s(or if there are any error in that particular clock cycle then that will be loaded).MSB portion must be read first before reading the LSB portion of the error counter.
 *     PRBS_CHK_LOCK_LOST_LH PRBS Checker LOCK_LOST Latch High Indication. This register captures the 1->0 transition on theprbs_chk_lock live status register and keep it latched until read. This is a clear on read status registers.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr (0x0001d16a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_msb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_msb_sts;
} BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;

#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET(r) ((((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) >> 15) & 0x1)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) & 0x7fff)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,_r._tlb_rx_prbs_chk_err_cnt_msb_sts)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,_r._tlb_rx_prbs_chk_err_cnt_msb_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_MADURA_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_MADURA_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16b
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter LSB Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_LSB 16 bits LSB portion of PRBS Checker Error Counter Status Register. This register indicatesthe value in the holding register when MSB portion [30:16] of the error counter are read.MSB portion must be read first before reading the LSB portion of the error counter.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr (0x0001d16b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_lsb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_lsb_sts;
} BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;

#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]) & 0xffff)
#define BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,_r._tlb_rx_prbs_chk_err_cnt_lsb_sts)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,_r._tlb_rx_prbs_chk_err_cnt_lsb_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_MADURA_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_MADURA_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_MADURA_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16c
 * DEVAD:    1
 * DESC:     PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_RX_LOCK      PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read.
 */
#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr (0x0001d16c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PMD_RX_LOCK_STS.
 */
typedef union BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_pmd_rx_lock_sts;
} BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_t;

#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_pmd_rx_lock_sts[0] = 0
#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_pmd_rx_lock_sts[0] = d
#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PMD_RX_LOCK_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr,_r._tlb_rx_pmd_rx_lock_sts)
#define BCMI_MADURA_WRITE_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr,_r._tlb_rx_pmd_rx_lock_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PMD_RX_LOCK_STSr BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr
#define TLB_RX_PMD_RX_LOCK_STSr_SIZE BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_t TLB_RX_PMD_RX_LOCK_STSr_t;
#define TLB_RX_PMD_RX_LOCK_STSr_CLR BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_PMD_RX_LOCK_STSr_SET BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_SET
#define TLB_RX_PMD_RX_LOCK_STSr_GET BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET
#define READ_TLB_RX_PMD_RX_LOCK_STSr BCMI_MADURA_READ_TLB_RX_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_PMD_RX_LOCK_STSr BCMI_MADURA_WRITE_TLB_RX_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_PMD_RX_LOCK_STSr BCMI_MADURA_MODIFY_TLB_RX_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16d
 * DEVAD:    1
 * DESC:     PRBS Burst Error Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error length count. This the live indication of the live status of the PRBS burst error length and max at 6'd63. This register is cleared upon read.This register is only supported for OSR modes OS1, OS2 and OS4.
 */
#define BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr (0x0001d16d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_prbs_burst_err_len_sts;
} BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_prbs_burst_err_len_sts[0] = 0
#define BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_prbs_burst_err_len_sts[0] = d
#define BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_prbs_burst_err_len_sts[0]=(((r).tlb_rx_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr,_r._tlb_rx_prbs_burst_err_len_sts)
#define BCMI_MADURA_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr,_r._tlb_rx_prbs_burst_err_len_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16e
 * DEVAD:    1
 * DESC:     PRBS Burst Error Maximum Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MAX_PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error max length count. This the status of the PRBS burst error max length and max at 6'd63. This register is cleared upon read.This register is only supported for OSR modes OS1, OS2 and OS4.
 */
#define BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr (0x0001d16e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_max_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_max_prbs_burst_err_len_sts;
} BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = 0
#define BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = d
#define BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_max_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_max_prbs_burst_err_len_sts[0]=(((r).tlb_rx_max_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_MADURA_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,_r._tlb_rx_max_prbs_burst_err_len_sts)
#define BCMI_MADURA_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,_r._tlb_rx_max_prbs_burst_err_len_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_MADURA_MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_TX_PATGEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd170
 * DEVAD:    1
 * DESC:     Pattern Generator Control
 * RESETVAL: 0xb000 (45056)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_EN      Fixed pattern generator enable.1 => enable  the fixed pattern generator.0 => disable the fixed pattern generator.
 *     PATT_GEN_STOP_POS Valid values are 11 to 0. Defines the stop  position of the pattern in 20 bit chunks.This register value should be less than or equal to rg_patt_gen_start_pos.11 means stop at bit  220,10 means stop at bit  200, ...,0 means stop at bit    0so stop  bit is (rg_patt_gen_stop_pos*20).
 *     PATT_GEN_START_POS Valid values are 11 to 0. Defines the start position of the pattern in 20 bit chunks.11 means start at bit 239,10 means start at bit 219, ...,0 means start at bit  19so start bit is (rg_patt_gen_start_pos*20 + 19).
 */
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr (0x0001d170 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PATGEN_CFG.
 */
typedef union BCMI_MADURA_TLB_TX_PATGEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_patgen_cfg[1];
	uint32_t _tlb_tx_patgen_cfg;
} BCMI_MADURA_TLB_TX_PATGEN_CFGr_t;

#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_CLR(r) (r).tlb_tx_patgen_cfg[0] = 0
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_SET(r,d) (r).tlb_tx_patgen_cfg[0] = d
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_GET(r) (r).tlb_tx_patgen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 12) & 0xf)
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 8) & 0xf)
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET(r) (((r).tlb_tx_patgen_cfg[0]) & 0x1)
#define BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PATGEN_CFG.
 */
#define BCMI_MADURA_READ_TLB_TX_PATGEN_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_TX_PATGEN_CFGr,_r._tlb_tx_patgen_cfg)
#define BCMI_MADURA_WRITE_TLB_TX_PATGEN_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_TX_PATGEN_CFGr,_r._tlb_tx_patgen_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PATGEN_CFGr BCMI_MADURA_TLB_TX_PATGEN_CFGr
#define TLB_TX_PATGEN_CFGr_SIZE BCMI_MADURA_TLB_TX_PATGEN_CFGr_SIZE
typedef BCMI_MADURA_TLB_TX_PATGEN_CFGr_t TLB_TX_PATGEN_CFGr_t;
#define TLB_TX_PATGEN_CFGr_CLR BCMI_MADURA_TLB_TX_PATGEN_CFGr_CLR
#define TLB_TX_PATGEN_CFGr_SET BCMI_MADURA_TLB_TX_PATGEN_CFGr_SET
#define TLB_TX_PATGEN_CFGr_GET BCMI_MADURA_TLB_TX_PATGEN_CFGr_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET BCMI_MADURA_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET
#define READ_TLB_TX_PATGEN_CFGr BCMI_MADURA_READ_TLB_TX_PATGEN_CFGr
#define WRITE_TLB_TX_PATGEN_CFGr BCMI_MADURA_WRITE_TLB_TX_PATGEN_CFGr
#define MODIFY_TLB_TX_PATGEN_CFGr BCMI_MADURA_MODIFY_TLB_TX_PATGEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_TX_PATGEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_TX_PRBS_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd171
 * DEVAD:    1
 * DESC:     PRBS Generator Control
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_GEN_EN      PRBS generator enable.1 => enable  the PRBS generator.0 => disable the PRBS generator.
 *     PRBS_GEN_MODE_SEL PRBS generator mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_GEN_INV     PRBS Invert enable.1 => will invert all the data bits from the PRBS generator.0 => will send normal data from the PRBS generator.
 *     PRBS_GEN_ERR_INS PRBS Error Insert.0 to 1 transition on this signal will insert single bit error in the MSB bit of the data bus.
 */
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr (0x0001d171 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PRBS_GEN_CFG.
 */
typedef union BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_prbs_gen_cfg[1];
	uint32_t _tlb_tx_prbs_gen_cfg;
} BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_t;

#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_CLR(r) (r).tlb_tx_prbs_gen_cfg[0] = 0
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_SET(r,d) (r).tlb_tx_prbs_gen_cfg[0] = d
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_GET(r) (r).tlb_tx_prbs_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 5) & 0x1)
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 4) & 0x1)
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 1) & 0x7)
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET(r) (((r).tlb_tx_prbs_gen_cfg[0]) & 0x1)
#define BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PRBS_GEN_CFG.
 */
#define BCMI_MADURA_READ_TLB_TX_PRBS_GEN_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr,_r._tlb_tx_prbs_gen_cfg)
#define BCMI_MADURA_WRITE_TLB_TX_PRBS_GEN_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr,_r._tlb_tx_prbs_gen_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PRBS_GEN_CFGr BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr
#define TLB_TX_PRBS_GEN_CFGr_SIZE BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_SIZE
typedef BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_t TLB_TX_PRBS_GEN_CFGr_t;
#define TLB_TX_PRBS_GEN_CFGr_CLR BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_CLR
#define TLB_TX_PRBS_GEN_CFGr_SET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_SET
#define TLB_TX_PRBS_GEN_CFGr_GET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET
#define READ_TLB_TX_PRBS_GEN_CFGr BCMI_MADURA_READ_TLB_TX_PRBS_GEN_CFGr
#define WRITE_TLB_TX_PRBS_GEN_CFGr BCMI_MADURA_WRITE_TLB_TX_PRBS_GEN_CFGr
#define MODIFY_TLB_TX_PRBS_GEN_CFGr BCMI_MADURA_MODIFY_TLB_TX_PRBS_GEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_TX_PRBS_GEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_TX_RMT_LPBK_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd172
 * DEVAD:    1
 * DESC:     Remote Loopback Control
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     RMT_LPBK_EN      RX to TX Parallel Loopback (Remote Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     RMT_LPBK_PD_MODE Remote Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     RMT_LPBK_PD_FRC_ON Remote loopback PD enable by force irrespective of rg_rmt_lpbk_en.1'b1 - enable the phase detector without the remote loopback enable. Can be used to lock RX and TXclock phases when there is a remote loopback outside PMD
 */
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr (0x0001d172 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_CFG.
 */
typedef union BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_cfg[1];
	uint32_t _tlb_tx_rmt_lpbk_cfg;
} BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_t;

#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_CLR(r) (r).tlb_tx_rmt_lpbk_cfg[0] = 0
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_SET(r,d) (r).tlb_tx_rmt_lpbk_cfg[0] = d
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_GET(r) (r).tlb_tx_rmt_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET(r) (((r).tlb_tx_rmt_lpbk_cfg[0]) & 0x1)
#define BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_CFG.
 */
#define BCMI_MADURA_READ_TLB_TX_RMT_LPBK_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr,_r._tlb_tx_rmt_lpbk_cfg)
#define BCMI_MADURA_WRITE_TLB_TX_RMT_LPBK_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr,_r._tlb_tx_rmt_lpbk_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_CFGr BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr
#define TLB_TX_RMT_LPBK_CFGr_SIZE BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_SIZE
typedef BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_t TLB_TX_RMT_LPBK_CFGr_t;
#define TLB_TX_RMT_LPBK_CFGr_CLR BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_CLR
#define TLB_TX_RMT_LPBK_CFGr_SET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_SET
#define TLB_TX_RMT_LPBK_CFGr_GET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET
#define READ_TLB_TX_RMT_LPBK_CFGr BCMI_MADURA_READ_TLB_TX_RMT_LPBK_CFGr
#define WRITE_TLB_TX_RMT_LPBK_CFGr BCMI_MADURA_WRITE_TLB_TX_RMT_LPBK_CFGr
#define MODIFY_TLB_TX_RMT_LPBK_CFGr BCMI_MADURA_MODIFY_TLB_TX_RMT_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_TX_RMT_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_TX_TLB_TX_MISC_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd173
 * DEVAD:    1
 * DESC:     TLB TX Misc. Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PMD_DP_INVERT TX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     TX_PCS_NATIVE_ANA_FRMT_EN TX PCS Interface Native Analog Format Enable.1 => TX PCS Interface is enabled in the Native Analog Format mode. TX PCS sends the over-sampled data in this mode which is sent directly to AFE.0 => Raw Data Mode where for every data request TX PCS will send 20 bits of valid data.
 *     TX_MUX_SEL_ORDER TX Data MUX Select Priority Order. When 1'b1 then priority of Pattern and PRBS generators are swapped w.r.t. CL72.0 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, patt_gen, cl72_tx, prbs_gen, tx_pcs}.1 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, prbs_gen, cl72_tx, patt_gen, tx_pcs}.
 *     TLB_TX_DIFF_ENC_EN 1'b1 will enable the Differential Encoder for pmd_tx_data. Only applicable to PCS TX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 */
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr (0x0001d173 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_MISC_CFG.
 */
typedef union BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_misc_cfg[1];
	uint32_t _tlb_tx_tlb_tx_misc_cfg;
} BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_t;

#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_CLR(r) (r).tlb_tx_tlb_tx_misc_cfg[0] = 0
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_SET(r,d) (r).tlb_tx_tlb_tx_misc_cfg[0] = d
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_GET(r) (r).tlb_tx_tlb_tx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET(r) (((r).tlb_tx_tlb_tx_misc_cfg[0]) & 0x1)
#define BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_MISC_CFG.
 */
#define BCMI_MADURA_READ_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr,_r._tlb_tx_tlb_tx_misc_cfg)
#define BCMI_MADURA_WRITE_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr,_r._tlb_tx_tlb_tx_misc_cfg)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_MISC_CFGr BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr
#define TLB_TX_TLB_TX_MISC_CFGr_SIZE BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_SIZE
typedef BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_t TLB_TX_TLB_TX_MISC_CFGr_t;
#define TLB_TX_TLB_TX_MISC_CFGr_CLR BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_CLR
#define TLB_TX_TLB_TX_MISC_CFGr_SET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_SET
#define TLB_TX_TLB_TX_MISC_CFGr_GET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET
#define READ_TLB_TX_TLB_TX_MISC_CFGr BCMI_MADURA_READ_TLB_TX_TLB_TX_MISC_CFGr
#define WRITE_TLB_TX_TLB_TX_MISC_CFGr BCMI_MADURA_WRITE_TLB_TX_TLB_TX_MISC_CFGr
#define MODIFY_TLB_TX_TLB_TX_MISC_CFGr BCMI_MADURA_MODIFY_TLB_TX_TLB_TX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_TX_TLB_TX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TLB_TX_RMT_LPBK_PD_STS
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd178
 * DEVAD:    1
 * DESC:     Remote Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     RMT_LPBK_PD_LATE_IND 1 means dp_tclk20 is sampling data late so reduce the delay of the dp_tclk20 clock phase. This will result in TX PI phase step decrement.
 *     RMT_LPBK_PD_EARLY_IND 1 means dp_tclk20 is sampling data earlier so delay the dp_tclk20 clock phase. This will result in TX PI phase step increment.
 */
#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr (0x0001d178 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_PD_STS.
 */
typedef union BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_pd_sts[1];
	uint32_t _tlb_tx_rmt_lpbk_pd_sts;
} BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_t;

#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_CLR(r) (r).tlb_tx_rmt_lpbk_pd_sts[0] = 0
#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_SET(r,d) (r).tlb_tx_rmt_lpbk_pd_sts[0] = d
#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_GET(r) (r).tlb_tx_rmt_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_tx_rmt_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_tx_rmt_lpbk_pd_sts[0]) & 0x1)
#define BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_PD_STS.
 */
#define BCMI_MADURA_READ_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr,_r._tlb_tx_rmt_lpbk_pd_sts)
#define BCMI_MADURA_WRITE_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr,_r._tlb_tx_rmt_lpbk_pd_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_PD_STSr BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr
#define TLB_TX_RMT_LPBK_PD_STSr_SIZE BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_SIZE
typedef BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_t TLB_TX_RMT_LPBK_PD_STSr_t;
#define TLB_TX_RMT_LPBK_PD_STSr_CLR BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_CLR
#define TLB_TX_RMT_LPBK_PD_STSr_SET BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_SET
#define TLB_TX_RMT_LPBK_PD_STSr_GET BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET
#define READ_TLB_TX_RMT_LPBK_PD_STSr BCMI_MADURA_READ_TLB_TX_RMT_LPBK_PD_STSr
#define WRITE_TLB_TX_RMT_LPBK_PD_STSr BCMI_MADURA_WRITE_TLB_TX_RMT_LPBK_PD_STSr
#define MODIFY_TLB_TX_RMT_LPBK_PD_STSr BCMI_MADURA_MODIFY_TLB_TX_RMT_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TLB_TX_RMT_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CORE_PLL_RST_CTL_PLL_DP
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd182
 * DEVAD:    1
 * DESC:     RESET_CONTROL_PLL_DP
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_CORE_DP_H_RSTB_PKILL 1'b1 will disable the pmd_core_dp_h_rstb pin.
 *     VCOCLK4PCS_S_COMCLK_SEL Mux control for selection of comclk for pmd_vcoclk4pcs clock.If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk4pcs clock.It is recommended for user to force pmd_vcoclk4pcs_vld to 1'b0 while vcoclk4pcs_s_comclk_sel is asserted to 1'b1by using pmd_vcoclk4pcs_vld_frc/frc_val registers.
 *     VCOCLK4PCS_S_COMCLK_FRC_ON Mux control for selection of comclk for pmd_vcoclk4pcs by force.If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk4pcs clock. This is a debug bit and should be only used if vcoclk4pcs from AFE is dead for unforeseen reasons.It is recommended for user to force pmd_vcoclk4pcs_vld to 1'b0 while vcoclk4pcs_s_comclk_frc_on is asserted to 1'b1by using pmd_vcoclk4pcs_vld_frc/frc_val registers.
 *     PMD_VCOCLK4PCS_VLD_FRC pmd_vcoclk4pcs_vld pin force.
 *     PMD_VCOCLK4PCS_VLD_FRC_VAL pmd_vcoclk4pcs_vld pin force value.
 *     AFE_S_PLL_RESET_FRC_VAL Active High PLL Reset force value control.
 *     AFE_S_PLL_RESET_FRC Active High PLL Reset force control.
 */
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr (0x0001d182 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_RST_CTL_PLL_DP.
 */
typedef union BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_s {
	uint32_t v[1];
	uint32_t core_pll_rst_ctl_pll_dp[1];
	uint32_t _core_pll_rst_ctl_pll_dp;
} BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_t;

#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_CLR(r) (r).core_pll_rst_ctl_pll_dp[0] = 0
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_SET(r,d) (r).core_pll_rst_ctl_pll_dp[0] = d
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_GET(r) (r).core_pll_rst_ctl_pll_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 13) & 0x1)
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 12) & 0x1)
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 10) & 0x1)
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 9) & 0x1)
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 8) & 0x1)
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 7) & 0x1)
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET(r) ((((r).core_pll_rst_ctl_pll_dp[0]) >> 1) & 0x1)
#define BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET(r,f) (r).core_pll_rst_ctl_pll_dp[0]=(((r).core_pll_rst_ctl_pll_dp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access CORE_PLL_RST_CTL_PLL_DP.
 */
#define BCMI_MADURA_READ_CORE_PLL_RST_CTL_PLL_DPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr,_r._core_pll_rst_ctl_pll_dp)
#define BCMI_MADURA_WRITE_CORE_PLL_RST_CTL_PLL_DPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr,_r._core_pll_rst_ctl_pll_dp)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_RST_CTL_PLL_DPr BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr
#define CORE_PLL_RST_CTL_PLL_DPr_SIZE BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_SIZE
typedef BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_t CORE_PLL_RST_CTL_PLL_DPr_t;
#define CORE_PLL_RST_CTL_PLL_DPr_CLR BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_CLR
#define CORE_PLL_RST_CTL_PLL_DPr_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_SET
#define CORE_PLL_RST_CTL_PLL_DPr_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_GET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRCf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_AFE_S_PLL_RESET_FRC_VALf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRC_VALf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_VCOCLK4PCS_VLD_FRCf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_FRC_ONf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_VCOCLK4PCS_S_COMCLK_SELf_SET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET
#define CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET
#define READ_CORE_PLL_RST_CTL_PLL_DPr BCMI_MADURA_READ_CORE_PLL_RST_CTL_PLL_DPr
#define WRITE_CORE_PLL_RST_CTL_PLL_DPr BCMI_MADURA_WRITE_CORE_PLL_RST_CTL_PLL_DPr
#define MODIFY_CORE_PLL_RST_CTL_PLL_DPr BCMI_MADURA_MODIFY_CORE_PLL_RST_CTL_PLL_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CORE_PLL_RST_CTL_PLL_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CORE_PLL_TOP_USER_CTL
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd184
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_DP_S_RSTB   Active Low Core Level Datapath Soft Reset. If asserted by writingto 1'b0 will reset datapath logic of all the lanes. This soft resetis equivalent to the hard reset input pin core_dp_h_rstb. Assertion of this
 *     AFE_S_PLL_PWRDN  Active High PLL Power Down control.
 */
#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr (0x0001d184 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_TOP_USER_CTL.
 */
typedef union BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_s {
	uint32_t v[1];
	uint32_t core_pll_top_user_ctl[1];
	uint32_t _core_pll_top_user_ctl;
} BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_t;

#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_CLR(r) (r).core_pll_top_user_ctl[0] = 0
#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_SET(r,d) (r).core_pll_top_user_ctl[0] = d
#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_GET(r) (r).core_pll_top_user_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 14) & 0x1)
#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 13) & 0x1)
#define BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access CORE_PLL_TOP_USER_CTL.
 */
#define BCMI_MADURA_READ_CORE_PLL_TOP_USER_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CORE_PLL_TOP_USER_CTLr,_r._core_pll_top_user_ctl)
#define BCMI_MADURA_WRITE_CORE_PLL_TOP_USER_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CORE_PLL_TOP_USER_CTLr,_r._core_pll_top_user_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_TOP_USER_CTLr BCMI_MADURA_CORE_PLL_TOP_USER_CTLr
#define CORE_PLL_TOP_USER_CTLr_SIZE BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_SIZE
typedef BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_t CORE_PLL_TOP_USER_CTLr_t;
#define CORE_PLL_TOP_USER_CTLr_CLR BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_CLR
#define CORE_PLL_TOP_USER_CTLr_SET BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_SET
#define CORE_PLL_TOP_USER_CTLr_GET BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_GET
#define CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET
#define CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET
#define CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET
#define CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET BCMI_MADURA_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET
#define READ_CORE_PLL_TOP_USER_CTLr BCMI_MADURA_READ_CORE_PLL_TOP_USER_CTLr
#define WRITE_CORE_PLL_TOP_USER_CTLr BCMI_MADURA_WRITE_CORE_PLL_TOP_USER_CTLr
#define MODIFY_CORE_PLL_TOP_USER_CTLr BCMI_MADURA_MODIFY_CORE_PLL_TOP_USER_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CORE_PLL_TOP_USER_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CORE_PLL_UC_ACK_CORE_CTL
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd185
 * DEVAD:    1
 * DESC:     UC_ACK_CORE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_CORE_CFG_DONE uC will write this to 1 to indicate it's configuration of the core is complete. Writing to 1'b1 willshould release internal hold on core_dp_reset, only if core_dp_reset_state is 3'b001.
 *     UC_ACK_CORE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "core_dp_reset_coccured".
 */
#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr (0x0001d185 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_UC_ACK_CORE_CTL.
 */
typedef union BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_s {
	uint32_t v[1];
	uint32_t core_pll_uc_ack_core_ctl[1];
	uint32_t _core_pll_uc_ack_core_ctl;
} BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_t;

#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_CLR(r) (r).core_pll_uc_ack_core_ctl[0] = 0
#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_SET(r,d) (r).core_pll_uc_ack_core_ctl[0] = d
#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_GET(r) (r).core_pll_uc_ack_core_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET(r) ((((r).core_pll_uc_ack_core_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET(r,f) (r).core_pll_uc_ack_core_ctl[0]=(((r).core_pll_uc_ack_core_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET(r) (((r).core_pll_uc_ack_core_ctl[0]) & 0x1)
#define BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET(r,f) (r).core_pll_uc_ack_core_ctl[0]=(((r).core_pll_uc_ack_core_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CORE_PLL_UC_ACK_CORE_CTL.
 */
#define BCMI_MADURA_READ_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr,_r._core_pll_uc_ack_core_ctl)
#define BCMI_MADURA_WRITE_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr,_r._core_pll_uc_ack_core_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_UC_ACK_CORE_CTLr BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr
#define CORE_PLL_UC_ACK_CORE_CTLr_SIZE BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_SIZE
typedef BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_t CORE_PLL_UC_ACK_CORE_CTLr_t;
#define CORE_PLL_UC_ACK_CORE_CTLr_CLR BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_CLR
#define CORE_PLL_UC_ACK_CORE_CTLr_SET BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_SET
#define CORE_PLL_UC_ACK_CORE_CTLr_GET BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET
#define READ_CORE_PLL_UC_ACK_CORE_CTLr BCMI_MADURA_READ_CORE_PLL_UC_ACK_CORE_CTLr
#define WRITE_CORE_PLL_UC_ACK_CORE_CTLr BCMI_MADURA_WRITE_CORE_PLL_UC_ACK_CORE_CTLr
#define MODIFY_CORE_PLL_UC_ACK_CORE_CTLr BCMI_MADURA_MODIFY_CORE_PLL_UC_ACK_CORE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CORE_PLL_UC_ACK_CORE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CORE_PLL_PLL_DP_RST_ST_STS
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd188
 * DEVAD:    1
 * DESC:     PLL_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     CORE_DP_RESET_STATE Bit 2: core_dp_reset_active   : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls.Bit 1: core_dp_reset_occurred : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: core_dp_reset_held     : Set to 1'b1 whenenver core_dp_reset is internally held. Cleared to 1'b0, only if core_dp_reset_state==001 and uc_ack_core_cfg_done == 1.
 */
#define BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr (0x0001d188 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PLL_DP_RST_ST_STS.
 */
typedef union BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t core_pll_pll_dp_rst_st_sts[1];
	uint32_t _core_pll_pll_dp_rst_st_sts;
} BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_t;

#define BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_CLR(r) (r).core_pll_pll_dp_rst_st_sts[0] = 0
#define BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_SET(r,d) (r).core_pll_pll_dp_rst_st_sts[0] = d
#define BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_GET(r) (r).core_pll_pll_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET(r) (((r).core_pll_pll_dp_rst_st_sts[0]) & 0x7)
#define BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET(r,f) (r).core_pll_pll_dp_rst_st_sts[0]=(((r).core_pll_pll_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access CORE_PLL_PLL_DP_RST_ST_STS.
 */
#define BCMI_MADURA_READ_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr,_r._core_pll_pll_dp_rst_st_sts)
#define BCMI_MADURA_WRITE_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr,_r._core_pll_pll_dp_rst_st_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PLL_DP_RST_ST_STSr BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr
#define CORE_PLL_PLL_DP_RST_ST_STSr_SIZE BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_SIZE
typedef BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_t CORE_PLL_PLL_DP_RST_ST_STSr_t;
#define CORE_PLL_PLL_DP_RST_ST_STSr_CLR BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_CLR
#define CORE_PLL_PLL_DP_RST_ST_STSr_SET BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_SET
#define CORE_PLL_PLL_DP_RST_ST_STSr_GET BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_GET
#define CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET
#define CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET
#define READ_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_MADURA_READ_CORE_PLL_PLL_DP_RST_ST_STSr
#define WRITE_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_MADURA_WRITE_CORE_PLL_PLL_DP_RST_ST_STSr
#define MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_MADURA_MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CORE_PLL_PLL_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_ADDR0
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd190
 * DEVAD:    1
 * DESC:     LANE_ADDR_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_0   Determines the logical address associated with the PMD RX lane with physical index  "_0" at the PCS interface.rx_lane_addr_0 is the logical address of the lane with pins at the PCS interface labeled "_0".
 *     TX_LANE_ADDR_0   Determines the logical address associated with the PMD TX lane with physical index  "_0" at the PCS interface.tx_lane_addr_0 is the logical address of the TX lane with pins at the PCS interface labeled "_0".
 */
#define BCMI_MADURA_LN_ADDR0r (0x0001d190 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_ADDR0r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR0.
 */
typedef union BCMI_MADURA_LN_ADDR0r_s {
	uint32_t v[1];
	uint32_t ln_addr0[1];
	uint32_t _ln_addr0;
} BCMI_MADURA_LN_ADDR0r_t;

#define BCMI_MADURA_LN_ADDR0r_CLR(r) (r).ln_addr0[0] = 0
#define BCMI_MADURA_LN_ADDR0r_SET(r,d) (r).ln_addr0[0] = d
#define BCMI_MADURA_LN_ADDR0r_GET(r) (r).ln_addr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_ADDR0r_TX_LANE_ADDR_0f_GET(r) ((((r).ln_addr0[0]) >> 8) & 0x1f)
#define BCMI_MADURA_LN_ADDR0r_TX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_LN_ADDR0r_RX_LANE_ADDR_0f_GET(r) (((r).ln_addr0[0]) & 0x1f)
#define BCMI_MADURA_LN_ADDR0r_RX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR0.
 */
#define BCMI_MADURA_READ_LN_ADDR0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_ADDR0r,_r._ln_addr0)
#define BCMI_MADURA_WRITE_LN_ADDR0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_ADDR0r,_r._ln_addr0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR0r BCMI_MADURA_LN_ADDR0r
#define LN_ADDR0r_SIZE BCMI_MADURA_LN_ADDR0r_SIZE
typedef BCMI_MADURA_LN_ADDR0r_t LN_ADDR0r_t;
#define LN_ADDR0r_CLR BCMI_MADURA_LN_ADDR0r_CLR
#define LN_ADDR0r_SET BCMI_MADURA_LN_ADDR0r_SET
#define LN_ADDR0r_GET BCMI_MADURA_LN_ADDR0r_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_GET BCMI_MADURA_LN_ADDR0r_TX_LANE_ADDR_0f_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_SET BCMI_MADURA_LN_ADDR0r_TX_LANE_ADDR_0f_SET
#define LN_ADDR0r_RX_LANE_ADDR_0f_GET BCMI_MADURA_LN_ADDR0r_RX_LANE_ADDR_0f_GET
#define LN_ADDR0r_RX_LANE_ADDR_0f_SET BCMI_MADURA_LN_ADDR0r_RX_LANE_ADDR_0f_SET
#define READ_LN_ADDR0r BCMI_MADURA_READ_LN_ADDR0r
#define WRITE_LN_ADDR0r BCMI_MADURA_WRITE_LN_ADDR0r
#define MODIFY_LN_ADDR0r BCMI_MADURA_MODIFY_LN_ADDR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_ADDR0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_ADDR1
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd191
 * DEVAD:    1
 * DESC:     LANE_ADDR_1
 * RESETVAL: 0x101 (257)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_1   Determines the logical address associated with the PMD RX lane with physical index  "_1" at the PCS interface.rx_lane_addr_1 is the logical address of the lane with pins at the PCS interface labeled "_1".
 *     TX_LANE_ADDR_1   Determines the logical address associated with the PMD TX lane with physical index  "_1" at the PCS interface.tx_lane_addr_1 is the logical address of the TX lane with pins at the PCS interface labeled "_1".
 */
#define BCMI_MADURA_LN_ADDR1r (0x0001d191 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_ADDR1r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR1.
 */
typedef union BCMI_MADURA_LN_ADDR1r_s {
	uint32_t v[1];
	uint32_t ln_addr1[1];
	uint32_t _ln_addr1;
} BCMI_MADURA_LN_ADDR1r_t;

#define BCMI_MADURA_LN_ADDR1r_CLR(r) (r).ln_addr1[0] = 0
#define BCMI_MADURA_LN_ADDR1r_SET(r,d) (r).ln_addr1[0] = d
#define BCMI_MADURA_LN_ADDR1r_GET(r) (r).ln_addr1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_ADDR1r_TX_LANE_ADDR_1f_GET(r) ((((r).ln_addr1[0]) >> 8) & 0x1f)
#define BCMI_MADURA_LN_ADDR1r_TX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_LN_ADDR1r_RX_LANE_ADDR_1f_GET(r) (((r).ln_addr1[0]) & 0x1f)
#define BCMI_MADURA_LN_ADDR1r_RX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR1.
 */
#define BCMI_MADURA_READ_LN_ADDR1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_ADDR1r,_r._ln_addr1)
#define BCMI_MADURA_WRITE_LN_ADDR1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_ADDR1r,_r._ln_addr1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR1r BCMI_MADURA_LN_ADDR1r
#define LN_ADDR1r_SIZE BCMI_MADURA_LN_ADDR1r_SIZE
typedef BCMI_MADURA_LN_ADDR1r_t LN_ADDR1r_t;
#define LN_ADDR1r_CLR BCMI_MADURA_LN_ADDR1r_CLR
#define LN_ADDR1r_SET BCMI_MADURA_LN_ADDR1r_SET
#define LN_ADDR1r_GET BCMI_MADURA_LN_ADDR1r_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_GET BCMI_MADURA_LN_ADDR1r_TX_LANE_ADDR_1f_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_SET BCMI_MADURA_LN_ADDR1r_TX_LANE_ADDR_1f_SET
#define LN_ADDR1r_RX_LANE_ADDR_1f_GET BCMI_MADURA_LN_ADDR1r_RX_LANE_ADDR_1f_GET
#define LN_ADDR1r_RX_LANE_ADDR_1f_SET BCMI_MADURA_LN_ADDR1r_RX_LANE_ADDR_1f_SET
#define READ_LN_ADDR1r BCMI_MADURA_READ_LN_ADDR1r
#define WRITE_LN_ADDR1r BCMI_MADURA_WRITE_LN_ADDR1r
#define MODIFY_LN_ADDR1r BCMI_MADURA_MODIFY_LN_ADDR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_ADDR1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_ADDR2
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd192
 * DEVAD:    1
 * DESC:     LANE_ADDR_2
 * RESETVAL: 0x202 (514)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_2   Determines the logical address associated with the PMD RX lane with physical index  "_2" at the PCS interface.rx_lane_addr_2 is the logical address of the lane with pins at the PCS interface labeled "_2".
 *     TX_LANE_ADDR_2   Determines the logical address associated with the PMD TX lane with physical index  "_2" at the PCS interface.tx_lane_addr_2 is the logical address of the TX lane with pins at the PCS interface labeled "_2".
 */
#define BCMI_MADURA_LN_ADDR2r (0x0001d192 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_ADDR2r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR2.
 */
typedef union BCMI_MADURA_LN_ADDR2r_s {
	uint32_t v[1];
	uint32_t ln_addr2[1];
	uint32_t _ln_addr2;
} BCMI_MADURA_LN_ADDR2r_t;

#define BCMI_MADURA_LN_ADDR2r_CLR(r) (r).ln_addr2[0] = 0
#define BCMI_MADURA_LN_ADDR2r_SET(r,d) (r).ln_addr2[0] = d
#define BCMI_MADURA_LN_ADDR2r_GET(r) (r).ln_addr2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_ADDR2r_TX_LANE_ADDR_2f_GET(r) ((((r).ln_addr2[0]) >> 8) & 0x1f)
#define BCMI_MADURA_LN_ADDR2r_TX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_LN_ADDR2r_RX_LANE_ADDR_2f_GET(r) (((r).ln_addr2[0]) & 0x1f)
#define BCMI_MADURA_LN_ADDR2r_RX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR2.
 */
#define BCMI_MADURA_READ_LN_ADDR2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_ADDR2r,_r._ln_addr2)
#define BCMI_MADURA_WRITE_LN_ADDR2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_ADDR2r,_r._ln_addr2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR2r BCMI_MADURA_LN_ADDR2r
#define LN_ADDR2r_SIZE BCMI_MADURA_LN_ADDR2r_SIZE
typedef BCMI_MADURA_LN_ADDR2r_t LN_ADDR2r_t;
#define LN_ADDR2r_CLR BCMI_MADURA_LN_ADDR2r_CLR
#define LN_ADDR2r_SET BCMI_MADURA_LN_ADDR2r_SET
#define LN_ADDR2r_GET BCMI_MADURA_LN_ADDR2r_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_GET BCMI_MADURA_LN_ADDR2r_TX_LANE_ADDR_2f_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_SET BCMI_MADURA_LN_ADDR2r_TX_LANE_ADDR_2f_SET
#define LN_ADDR2r_RX_LANE_ADDR_2f_GET BCMI_MADURA_LN_ADDR2r_RX_LANE_ADDR_2f_GET
#define LN_ADDR2r_RX_LANE_ADDR_2f_SET BCMI_MADURA_LN_ADDR2r_RX_LANE_ADDR_2f_SET
#define READ_LN_ADDR2r BCMI_MADURA_READ_LN_ADDR2r
#define WRITE_LN_ADDR2r BCMI_MADURA_WRITE_LN_ADDR2r
#define MODIFY_LN_ADDR2r BCMI_MADURA_MODIFY_LN_ADDR2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_ADDR2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_ADDR3
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd193
 * DEVAD:    1
 * DESC:     LANE_ADDR_3
 * RESETVAL: 0x303 (771)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_3   Determines the logical address associated with the PMD RX lane with physical index  "_3" at the PCS interface.rx_lane_addr_3 is the logical address of the lane with pins at the PCS interface labeled "_3".
 *     TX_LANE_ADDR_3   Determines the logical address associated with the PMD TX lane with physical index  "_3" at the PCS interface.tx_lane_addr_3 is the logical address of the TX lane with pins at the PCS interface labeled "_3".
 */
#define BCMI_MADURA_LN_ADDR3r (0x0001d193 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_ADDR3r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR3.
 */
typedef union BCMI_MADURA_LN_ADDR3r_s {
	uint32_t v[1];
	uint32_t ln_addr3[1];
	uint32_t _ln_addr3;
} BCMI_MADURA_LN_ADDR3r_t;

#define BCMI_MADURA_LN_ADDR3r_CLR(r) (r).ln_addr3[0] = 0
#define BCMI_MADURA_LN_ADDR3r_SET(r,d) (r).ln_addr3[0] = d
#define BCMI_MADURA_LN_ADDR3r_GET(r) (r).ln_addr3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_ADDR3r_TX_LANE_ADDR_3f_GET(r) ((((r).ln_addr3[0]) >> 8) & 0x1f)
#define BCMI_MADURA_LN_ADDR3r_TX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_MADURA_LN_ADDR3r_RX_LANE_ADDR_3f_GET(r) (((r).ln_addr3[0]) & 0x1f)
#define BCMI_MADURA_LN_ADDR3r_RX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR3.
 */
#define BCMI_MADURA_READ_LN_ADDR3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_ADDR3r,_r._ln_addr3)
#define BCMI_MADURA_WRITE_LN_ADDR3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_ADDR3r,_r._ln_addr3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR3r BCMI_MADURA_LN_ADDR3r
#define LN_ADDR3r_SIZE BCMI_MADURA_LN_ADDR3r_SIZE
typedef BCMI_MADURA_LN_ADDR3r_t LN_ADDR3r_t;
#define LN_ADDR3r_CLR BCMI_MADURA_LN_ADDR3r_CLR
#define LN_ADDR3r_SET BCMI_MADURA_LN_ADDR3r_SET
#define LN_ADDR3r_GET BCMI_MADURA_LN_ADDR3r_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_GET BCMI_MADURA_LN_ADDR3r_TX_LANE_ADDR_3f_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_SET BCMI_MADURA_LN_ADDR3r_TX_LANE_ADDR_3f_SET
#define LN_ADDR3r_RX_LANE_ADDR_3f_GET BCMI_MADURA_LN_ADDR3r_RX_LANE_ADDR_3f_GET
#define LN_ADDR3r_RX_LANE_ADDR_3f_SET BCMI_MADURA_LN_ADDR3r_RX_LANE_ADDR_3f_SET
#define READ_LN_ADDR3r BCMI_MADURA_READ_LN_ADDR3r
#define WRITE_LN_ADDR3r BCMI_MADURA_WRITE_LN_ADDR3r
#define MODIFY_LN_ADDR3r BCMI_MADURA_MODIFY_LN_ADDR3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_ADDR3r'
 */


/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_CLK_RST_N_PWRDWN_CTL_RX
 * BLOCKS:   RX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1a1
 * DEVAD:    1
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_PWRDN    Active High Power Down control for RX Lane.If asserted by writing to 1'b1 will power down the RX Lane.
 *     AFE_SIGDET_PWRDN Power Down for Signal Detect. 1=power down
 */
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr (0x0001d1a1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_SIZE 4

/*
 * This structure should be used to declare and program LN_CLK_RST_N_PWRDWN_CTL_RX.
 */
typedef union BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_s {
	uint32_t v[1];
	uint32_t ln_clk_rst_n_pwrdwn_ctl_rx[1];
	uint32_t _ln_clk_rst_n_pwrdwn_ctl_rx;
} BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_t;

#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_CLR(r) (r).ln_clk_rst_n_pwrdwn_ctl_rx[0] = 0
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_SET(r,d) (r).ln_clk_rst_n_pwrdwn_ctl_rx[0] = d
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_GET(r) (r).ln_clk_rst_n_pwrdwn_ctl_rx[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_AFE_SIGDET_PWRDNf_GET(r) ((((r).ln_clk_rst_n_pwrdwn_ctl_rx[0]) >> 1) & 0x1)
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_AFE_SIGDET_PWRDNf_SET(r,f) (r).ln_clk_rst_n_pwrdwn_ctl_rx[0]=(((r).ln_clk_rst_n_pwrdwn_ctl_rx[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_LN_RX_S_PWRDNf_GET(r) (((r).ln_clk_rst_n_pwrdwn_ctl_rx[0]) & 0x1)
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_LN_RX_S_PWRDNf_SET(r,f) (r).ln_clk_rst_n_pwrdwn_ctl_rx[0]=(((r).ln_clk_rst_n_pwrdwn_ctl_rx[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_CLK_RST_N_PWRDWN_CTL_RX.
 */
#define BCMI_MADURA_READ_LN_CLK_RST_N_PWRDWN_CTL_RXr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr,_r._ln_clk_rst_n_pwrdwn_ctl_rx)
#define BCMI_MADURA_WRITE_LN_CLK_RST_N_PWRDWN_CTL_RXr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr,_r._ln_clk_rst_n_pwrdwn_ctl_rx)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_CLK_RST_N_PWRDWN_CTL_RXr BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_SIZE BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_SIZE
typedef BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_t LN_CLK_RST_N_PWRDWN_CTL_RXr_t;
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_CLR BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_CLR
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_SET
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_GET
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_AFE_SIGDET_PWRDNf_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_AFE_SIGDET_PWRDNf_GET
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_AFE_SIGDET_PWRDNf_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_AFE_SIGDET_PWRDNf_SET
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_LN_RX_S_PWRDNf_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_LN_RX_S_PWRDNf_GET
#define LN_CLK_RST_N_PWRDWN_CTL_RXr_LN_RX_S_PWRDNf_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr_LN_RX_S_PWRDNf_SET
#define READ_LN_CLK_RST_N_PWRDWN_CTL_RXr BCMI_MADURA_READ_LN_CLK_RST_N_PWRDWN_CTL_RXr
#define WRITE_LN_CLK_RST_N_PWRDWN_CTL_RXr BCMI_MADURA_WRITE_LN_CLK_RST_N_PWRDWN_CTL_RXr
#define MODIFY_LN_CLK_RST_N_PWRDWN_CTL_RXr BCMI_MADURA_MODIFY_LN_CLK_RST_N_PWRDWN_CTL_RXr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_RXr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AFE_RST_PWRDN_OSR_MODE_PIN_STS_RX
 * BLOCKS:   RX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1ac
 * DEVAD:    1
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_RX_PWRDN     Indicates the status of the afe_rx_pwrdn signal to the AFE after frc/frc_val mux.
 *     AFE_RX_RESET     Indicates the status of the afe_rx_reset signal to the AFE after frc/frc_val mux.
 *     AFE_RX_RCLK20_PWRDN Indicates the status of the afe_rx_rclk20_pwrdn signal to the AFE after frc/frc_val mux.
 */
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr (0x0001d1ac | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_SIZE 4

/*
 * This structure should be used to declare and program AFE_RST_PWRDN_OSR_MODE_PIN_STS_RX.
 */
typedef union BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_s {
	uint32_t v[1];
	uint32_t afe_rst_pwrdn_osr_mode_pin_sts_rx[1];
	uint32_t _afe_rst_pwrdn_osr_mode_pin_sts_rx;
} BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_t;

#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_CLR(r) (r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0] = 0
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_SET(r,d) (r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0] = d
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_GET(r) (r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RCLK20_PWRDNf_GET(r) ((((r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0]) >> 2) & 0x1)
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RCLK20_PWRDNf_SET(r,f) (r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0]=(((r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RESETf_GET(r) ((((r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0]) >> 1) & 0x1)
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RESETf_SET(r,f) (r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0]=(((r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_PWRDNf_GET(r) (((r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0]) & 0x1)
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_PWRDNf_SET(r,f) (r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0]=(((r).afe_rst_pwrdn_osr_mode_pin_sts_rx[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AFE_RST_PWRDN_OSR_MODE_PIN_STS_RX.
 */
#define BCMI_MADURA_READ_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr,_r._afe_rst_pwrdn_osr_mode_pin_sts_rx)
#define BCMI_MADURA_WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr,_r._afe_rst_pwrdn_osr_mode_pin_sts_rx)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_SIZE BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_SIZE
typedef BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_t AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_t;
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_CLR BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_CLR
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_SET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RCLK20_PWRDNf_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RCLK20_PWRDNf_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RCLK20_PWRDNf_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RCLK20_PWRDNf_SET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RESETf_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RESETf_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RESETf_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_RESETf_SET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_PWRDNf_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_PWRDNf_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_PWRDNf_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr_AFE_RX_PWRDNf_SET
#define READ_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr BCMI_MADURA_READ_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr
#define WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr BCMI_MADURA_WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr
#define MODIFY_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr BCMI_MADURA_MODIFY_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_RXr'
 */





/*******************************************************************************
 * CHIP:  BCMI_MADURA


EGISTER:  LN_AFE_RST_PWRDWN_CTL_CTL_RX
 * BLOCKS:   RX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1a2
 * DEVAD:    1
 * DESC:     LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_RX_PWRDN_FRC AFE RX Lane powerdown force.
 *     AFE_RX_PWRDN_FRC_VAL AFE RX Lane powerdown force value.
 *     AFE_RX_RESET_FRC AFE RX Lane reset force.
 *     AFE_RX_RESET_FRC_VAL AFE RX Lane reset force value.
 *     AFE_RX_RCLK20_PWRDN_FRC AFE RX Lane rx_rclk20_pwrdwn force.
 *     AFE_RX_RCLK20_PWRDN_FRC_VAL AFE RX Lane rx_rclk20_pwrdwn force value.
 */
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr (0x0001d1a2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_SIZE 4

/*
 * This structure should be used to declare and program LN_AFE_RST_PWRDWN_CTL_CTL_RX.
 */
typedef union BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_s {
        uint32_t v[1];
        uint32_t ln_afe_rst_pwrdwn_ctl_ctl_rx[1];
        uint32_t _ln_afe_rst_pwrdwn_ctl_ctl_rx;
} BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_t;

#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_CLR(r) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] = 0
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_SET(r,d) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] = d
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_GET(r) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]) >> 5) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRCf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]) >> 4) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRCf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRC_VALf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]) >> 3) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRC_VALf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRCf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]) >> 2) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRCf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRC_VALf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]) >> 1) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRC_VALf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRCf_GET(r) (((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRCf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_rx[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_AFE_RST_PWRDWN_CTL_CTL_RX.
 */
#define BCMI_MADURA_READ_LN_AFE_RST_PWRDWN_CTL_CTL_RXr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr,_r._ln_afe_rst_pwrdwn_ctl_ctl_rx)
#define BCMI_MADURA_WRITE_LN_AFE_RST_PWRDWN_CTL_CTL_RXr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr,_r._ln_afe_rst_pwrdwn_ctl_ctl_rx)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_SIZE BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_SIZE
typedef BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_t LN_AFE_RST_PWRDWN_CTL_CTL_RXr_t;
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_CLR BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_CLR
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRCf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRCf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRCf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RCLK20_PWRDN_FRCf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRC_VALf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRC_VALf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRC_VALf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRC_VALf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRCf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRCf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRCf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_RESET_FRCf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRC_VALf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRC_VALf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRC_VALf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRC_VALf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRCf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRCf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRCf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr_AFE_RX_PWRDN_FRCf_SET
#define READ_LN_AFE_RST_PWRDWN_CTL_CTL_RXr BCMI_MADURA_READ_LN_AFE_RST_PWRDWN_CTL_CTL_RXr
#define WRITE_LN_AFE_RST_PWRDWN_CTL_CTL_RXr BCMI_MADURA_WRITE_LN_AFE_RST_PWRDWN_CTL_CTL_RXr
#define MODIFY_LN_AFE_RST_PWRDWN_CTL_CTL_RXr BCMI_MADURA_MODIFY_LN_AFE_RST_PWRDWN_CTL_CTL_RXr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_RXr'
 */

/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_CLK_RST_N_PWRDWN_CTL_TX
 * BLOCKS:   TX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1b1
 * DEVAD:    1
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_PWRDN    Active High Power Down control for TX Lane.If asserted by writing to 1'b1 will power down the TX Lane.
 *     AFE_TX_RESET_DEASSERT AFE TX Lane reset control. This register will be reset upon POR reg/pin or lane reset reg/pin. Lower priority than the afe_tx_reset_frc/frc_val option.1 - AFE TX Lane tx_reset pin will be forcefully de-asserted irrespective of core/lane datapath pin/reg resets asserted.This bit must be set to 1'b1 for TX_Disable all 1s/0s mode to allow TX AFE to transmit the all 1s/0s data.0 - AFE TX Lane tx_reset pin will be asserted if core/lane pin/reg resets are asserted.
 */
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr (0x0001d1b1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_SIZE 4

/*
 * This structure should be used to declare and program LN_CLK_RST_N_PWRDWN_CTL_TX.
 */
typedef union BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_s {
	uint32_t v[1];
	uint32_t ln_clk_rst_n_pwrdwn_ctl_tx[1];
	uint32_t _ln_clk_rst_n_pwrdwn_ctl_tx;
} BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_t;

#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_CLR(r) (r).ln_clk_rst_n_pwrdwn_ctl_tx[0] = 0
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_SET(r,d) (r).ln_clk_rst_n_pwrdwn_ctl_tx[0] = d
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_GET(r) (r).ln_clk_rst_n_pwrdwn_ctl_tx[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_AFE_TX_RESET_DEASSERTf_GET(r) ((((r).ln_clk_rst_n_pwrdwn_ctl_tx[0]) >> 15) & 0x1)
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_AFE_TX_RESET_DEASSERTf_SET(r,f) (r).ln_clk_rst_n_pwrdwn_ctl_tx[0]=(((r).ln_clk_rst_n_pwrdwn_ctl_tx[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_LN_TX_S_PWRDNf_GET(r) (((r).ln_clk_rst_n_pwrdwn_ctl_tx[0]) & 0x1)
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_LN_TX_S_PWRDNf_SET(r,f) (r).ln_clk_rst_n_pwrdwn_ctl_tx[0]=(((r).ln_clk_rst_n_pwrdwn_ctl_tx[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_CLK_RST_N_PWRDWN_CTL_TX.
 */
#define BCMI_MADURA_READ_LN_CLK_RST_N_PWRDWN_CTL_TXr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr,_r._ln_clk_rst_n_pwrdwn_ctl_tx)
#define BCMI_MADURA_WRITE_LN_CLK_RST_N_PWRDWN_CTL_TXr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr,_r._ln_clk_rst_n_pwrdwn_ctl_tx)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_CLK_RST_N_PWRDWN_CTL_TXr BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_SIZE BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_SIZE
typedef BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_t LN_CLK_RST_N_PWRDWN_CTL_TXr_t;
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_CLR BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_CLR
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_SET
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_GET
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_AFE_TX_RESET_DEASSERTf_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_AFE_TX_RESET_DEASSERTf_GET
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_AFE_TX_RESET_DEASSERTf_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_AFE_TX_RESET_DEASSERTf_SET
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_LN_TX_S_PWRDNf_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_LN_TX_S_PWRDNf_GET
#define LN_CLK_RST_N_PWRDWN_CTL_TXr_LN_TX_S_PWRDNf_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr_LN_TX_S_PWRDNf_SET
#define READ_LN_CLK_RST_N_PWRDWN_CTL_TXr BCMI_MADURA_READ_LN_CLK_RST_N_PWRDWN_CTL_TXr
#define WRITE_LN_CLK_RST_N_PWRDWN_CTL_TXr BCMI_MADURA_WRITE_LN_CLK_RST_N_PWRDWN_CTL_TXr
#define MODIFY_LN_CLK_RST_N_PWRDWN_CTL_TXr BCMI_MADURA_MODIFY_LN_CLK_RST_N_PWRDWN_CTL_TXr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTL_TXr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_AFE_RST_PWRDWN_CTL_CTL_TX
 * BLOCKS:   TX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1b2
 * DEVAD:    1
 * DESC:     LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_TX_PWRDN_FRC AFE TX Lane powerdown force.
 *     AFE_TX_PWRDN_FRC_VAL AFE TX Lane powerdown force value.
 *     AFE_TX_RESET_FRC AFE TX Lane reset force.
 *     AFE_TX_RESET_FRC_VAL AFE TX Lane reset force value.
 */
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr (0x0001d1b2 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_SIZE 4

/*
 * This structure should be used to declare and program LN_AFE_RST_PWRDWN_CTL_CTL_TX.
 */
typedef union BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_s {
        uint32_t v[1];
        uint32_t ln_afe_rst_pwrdwn_ctl_ctl_tx[1];
        uint32_t _ln_afe_rst_pwrdwn_ctl_ctl_tx;
} BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_t;

#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_CLR(r) (r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0] = 0
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_SET(r,d) (r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0] = d
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_GET(r) (r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRC_VALf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]) >> 3) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRC_VALf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRCf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]) >> 2) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRCf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRC_VALf_GET(r) ((((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]) >> 1) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRC_VALf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRCf_GET(r) (((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]) & 0x1)
#define BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRCf_SET(r,f) (r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0]=(((r).ln_afe_rst_pwrdwn_ctl_ctl_tx[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_AFE_RST_PWRDWN_CTL_CTL_TX.
 */
#define BCMI_MADURA_READ_LN_AFE_RST_PWRDWN_CTL_CTL_TXr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr,_r._ln_afe_rst_pwrdwn_ctl_ctl_tx)
#define BCMI_MADURA_WRITE_LN_AFE_RST_PWRDWN_CTL_CTL_TXr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr,_r._ln_afe_rst_pwrdwn_ctl_ctl_tx)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_SIZE BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_SIZE
typedef BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_t LN_AFE_RST_PWRDWN_CTL_CTL_TXr_t;
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_CLR BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_CLR
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRC_VALf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRC_VALf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRC_VALf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRC_VALf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRCf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRCf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRCf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_RESET_FRCf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRC_VALf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRC_VALf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRC_VALf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRC_VALf_SET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRCf_GET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRCf_GET
#define LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRCf_SET BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr_AFE_TX_PWRDN_FRCf_SET
#define READ_LN_AFE_RST_PWRDWN_CTL_CTL_TXr BCMI_MADURA_READ_LN_AFE_RST_PWRDWN_CTL_CTL_TXr
#define WRITE_LN_AFE_RST_PWRDWN_CTL_CTL_TXr BCMI_MADURA_WRITE_LN_AFE_RST_PWRDWN_CTL_CTL_TXr
#define MODIFY_LN_AFE_RST_PWRDWN_CTL_CTL_TXr BCMI_MADURA_MODIFY_LN_AFE_RST_PWRDWN_CTL_CTL_TXr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_AFE_RST_PWRDWN_CTL_CTL_TXr'
 */


/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_DBG_RST_CTL
 * BLOCKS:   TX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1b4
 * DEVAD:    1
 * DESC:     LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_RSTB     Active Low Lane Soft Reset for TX datapath and registers. If asserted by writing to 1'b0 will reset the TX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_TX_DP_S_RSTB  Active Low Lane Soft Reset for TX datapath. If asserted by writing to 1'b0 will reset the TX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 */
#define BCMI_MADURA_LN_DBG_RST_CTLr (0x0001d1b4 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LN_DBG_RST_CTL.
 */
typedef union BCMI_MADURA_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t ln_dbg_rst_ctl[1];
	uint32_t _ln_dbg_rst_ctl;
} BCMI_MADURA_LN_DBG_RST_CTLr_t;

#define BCMI_MADURA_LN_DBG_RST_CTLr_CLR(r) (r).ln_dbg_rst_ctl[0] = 0
#define BCMI_MADURA_LN_DBG_RST_CTLr_SET(r,d) (r).ln_dbg_rst_ctl[0] = d
#define BCMI_MADURA_LN_DBG_RST_CTLr_GET(r) (r).ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET(r) ((((r).ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET(r,f) (r).ln_dbg_rst_ctl[0]=(((r).ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET(r) (((r).ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET(r,f) (r).ln_dbg_rst_ctl[0]=(((r).ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_DBG_RST_CTL.
 */
#define BCMI_MADURA_READ_LN_DBG_RST_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_DBG_RST_CTLr,_r._ln_dbg_rst_ctl)
#define BCMI_MADURA_WRITE_LN_DBG_RST_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_DBG_RST_CTLr,_r._ln_dbg_rst_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_DBG_RST_CTLr BCMI_MADURA_LN_DBG_RST_CTLr
#define LN_DBG_RST_CTLr_SIZE BCMI_MADURA_LN_DBG_RST_CTLr_SIZE
typedef BCMI_MADURA_LN_DBG_RST_CTLr_t LN_DBG_RST_CTLr_t;
#define LN_DBG_RST_CTLr_CLR BCMI_MADURA_LN_DBG_RST_CTLr_CLR
#define LN_DBG_RST_CTLr_SET BCMI_MADURA_LN_DBG_RST_CTLr_SET
#define LN_DBG_RST_CTLr_GET BCMI_MADURA_LN_DBG_RST_CTLr_GET
#define LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET
#define LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET
#define LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET
#define LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET BCMI_MADURA_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET
#define READ_LN_DBG_RST_CTLr BCMI_MADURA_READ_LN_DBG_RST_CTLr
#define WRITE_LN_DBG_RST_CTLr BCMI_MADURA_WRITE_LN_DBG_RST_CTLr
#define MODIFY_LN_DBG_RST_CTLr BCMI_MADURA_MODIFY_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_DBG_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CLK_N_RST_DBG_CTL
 * BLOCKS:   TX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1b7
 * DEVAD:    1
 * DESC:     CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_CLKGATE_FRC_ON TX Active High Lane clock gator enable. If 1'1b1 then tx lane clock will be gated off. It does not affect the tclk goingto RMIC block so tx lane based registers can still be readable but not writable.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_clkgate_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_SEL Mux control for selection of comclk for TX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_sel is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_FRC_ON Mux control for selection of comclk for TX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the TX lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     PMD_TX_CLK_VLD_FRC pmd_tx_clk_vld core output pin force.
 *     PMD_TX_CLK_VLD_FRC_VAL pmd_tx_clk_vld core output pin force value.
 *     LN_TCLK20_S_CLKGATE_FRC_ON Active High Lane clock gate control for TX tclk20 clock gator.
 */
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr (0x0001d1b7 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CLK_N_RST_DBG_CTL.
 */
typedef union BCMI_MADURA_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t clk_n_rst_dbg_ctl[1];
	uint32_t _clk_n_rst_dbg_ctl;
} BCMI_MADURA_CLK_N_RST_DBG_CTLr_t;

#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_CLR(r) (r).clk_n_rst_dbg_ctl[0] = 0
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_SET(r,d) (r).clk_n_rst_dbg_ctl[0] = d
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_GET(r) (r).clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TCLK20_S_CLKGATE_FRC_ONf_GET(r) ((((r).clk_n_rst_dbg_ctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TCLK20_S_CLKGATE_FRC_ONf_SET(r,f) (r).clk_n_rst_dbg_ctl[0]=(((r).clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET(r) ((((r).clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET(r,f) (r).clk_n_rst_dbg_ctl[0]=(((r).clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET(r) ((((r).clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET(r,f) (r).clk_n_rst_dbg_ctl[0]=(((r).clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET(r) ((((r).clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET(r,f) (r).clk_n_rst_dbg_ctl[0]=(((r).clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET(r) ((((r).clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET(r,f) (r).clk_n_rst_dbg_ctl[0]=(((r).clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET(r) (((r).clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET(r,f) (r).clk_n_rst_dbg_ctl[0]=(((r).clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CLK_N_RST_DBG_CTL.
 */
#define BCMI_MADURA_READ_CLK_N_RST_DBG_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CLK_N_RST_DBG_CTLr,_r._clk_n_rst_dbg_ctl)
#define BCMI_MADURA_WRITE_CLK_N_RST_DBG_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CLK_N_RST_DBG_CTLr,_r._clk_n_rst_dbg_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CLK_N_RST_DBG_CTLr BCMI_MADURA_CLK_N_RST_DBG_CTLr
#define CLK_N_RST_DBG_CTLr_SIZE BCMI_MADURA_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_MADURA_CLK_N_RST_DBG_CTLr_t CLK_N_RST_DBG_CTLr_t;
#define CLK_N_RST_DBG_CTLr_CLR BCMI_MADURA_CLK_N_RST_DBG_CTLr_CLR
#define CLK_N_RST_DBG_CTLr_SET BCMI_MADURA_CLK_N_RST_DBG_CTLr_SET
#define CLK_N_RST_DBG_CTLr_GET BCMI_MADURA_CLK_N_RST_DBG_CTLr_GET
#define CLK_N_RST_DBG_CTLr_LN_TCLK20_S_CLKGATE_FRC_ONf_GET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TCLK20_S_CLKGATE_FRC_ONf_GET
#define CLK_N_RST_DBG_CTLr_LN_TCLK20_S_CLKGATE_FRC_ONf_SET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TCLK20_S_CLKGATE_FRC_ONf_SET
#define CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET
#define CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET
#define CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET
#define CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET BCMI_MADURA_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET
#define CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET
#define CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET
#define CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET
#define CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET
#define CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET
#define CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET BCMI_MADURA_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET
#define READ_CLK_N_RST_DBG_CTLr BCMI_MADURA_READ_CLK_N_RST_DBG_CTLr
#define WRITE_CLK_N_RST_DBG_CTLr BCMI_MADURA_WRITE_CLK_N_RST_DBG_CTLr
#define MODIFY_CLK_N_RST_DBG_CTLr BCMI_MADURA_MODIFY_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CLK_N_RST_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PMD_LN_MODE_STS
 * BLOCKS:   TX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1b8
 * DEVAD:    1
 * DESC:     PMD_LANE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_TX_LANE_MODE This indicates the status of the core input pin pmd_rx_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_MADURA_PMD_LN_MODE_STSr (0x0001d1b8 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_LN_MODE_STS.
 */
typedef union BCMI_MADURA_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t pmd_ln_mode_sts[1];
	uint32_t _pmd_ln_mode_sts;
} BCMI_MADURA_PMD_LN_MODE_STSr_t;

#define BCMI_MADURA_PMD_LN_MODE_STSr_CLR(r) (r).pmd_ln_mode_sts[0] = 0
#define BCMI_MADURA_PMD_LN_MODE_STSr_SET(r,d) (r).pmd_ln_mode_sts[0] = d
#define BCMI_MADURA_PMD_LN_MODE_STSr_GET(r) (r).pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET(r) (((r).pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_MADURA_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET(r,f) (r).pmd_ln_mode_sts[0]=(((r).pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_LN_MODE_STS.
 */
#define BCMI_MADURA_READ_PMD_LN_MODE_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PMD_LN_MODE_STSr,_r._pmd_ln_mode_sts)
#define BCMI_MADURA_WRITE_PMD_LN_MODE_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PMD_LN_MODE_STSr,_r._pmd_ln_mode_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_LN_MODE_STSr BCMI_MADURA_PMD_LN_MODE_STSr
#define PMD_LN_MODE_STSr_SIZE BCMI_MADURA_PMD_LN_MODE_STSr_SIZE
typedef BCMI_MADURA_PMD_LN_MODE_STSr_t PMD_LN_MODE_STSr_t;
#define PMD_LN_MODE_STSr_CLR BCMI_MADURA_PMD_LN_MODE_STSr_CLR
#define PMD_LN_MODE_STSr_SET BCMI_MADURA_PMD_LN_MODE_STSr_SET
#define PMD_LN_MODE_STSr_GET BCMI_MADURA_PMD_LN_MODE_STSr_GET
#define PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET BCMI_MADURA_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET
#define PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET BCMI_MADURA_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET
#define READ_PMD_LN_MODE_STSr BCMI_MADURA_READ_PMD_LN_MODE_STSr
#define WRITE_PMD_LN_MODE_STSr BCMI_MADURA_WRITE_PMD_LN_MODE_STSr
#define MODIFY_PMD_LN_MODE_STSr BCMI_MADURA_MODIFY_PMD_LN_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PMD_LN_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AFE_RST_PWRDN_OSR_MODE_PIN_STS_TX
 * BLOCKS:   TX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1bc
 * DEVAD:    1
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     AFE_TX_PWRDN     Indicates the status of the afe_tx_pwrdn signal to the AFE after frc/frc_val mux.
 *     AFE_TX_RESET     Indicates the status of the afe_tx_reset signal to the AFE after frc/frc_val mux.
 */
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr (0x0001d1bc | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_SIZE 4

/*
 * This structure should be used to declare and program AFE_RST_PWRDN_OSR_MODE_PIN_STS_TX.
 */
typedef union BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_s {
	uint32_t v[1];
	uint32_t afe_rst_pwrdn_osr_mode_pin_sts_tx[1];
	uint32_t _afe_rst_pwrdn_osr_mode_pin_sts_tx;
} BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_t;

#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_CLR(r) (r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0] = 0
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_SET(r,d) (r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0] = d
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_GET(r) (r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_RESETf_GET(r) ((((r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0]) >> 1) & 0x1)
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_RESETf_SET(r,f) (r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0]=(((r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_PWRDNf_GET(r) (((r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0]) & 0x1)
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_PWRDNf_SET(r,f) (r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0]=(((r).afe_rst_pwrdn_osr_mode_pin_sts_tx[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AFE_RST_PWRDN_OSR_MODE_PIN_STS_TX.
 */
#define BCMI_MADURA_READ_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr,_r._afe_rst_pwrdn_osr_mode_pin_sts_tx)
#define BCMI_MADURA_WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr,_r._afe_rst_pwrdn_osr_mode_pin_sts_tx)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_SIZE BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_SIZE
typedef BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_t AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_t;
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_CLR BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_CLR
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_SET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_RESETf_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_RESETf_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_RESETf_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_RESETf_SET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_PWRDNf_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_PWRDNf_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_PWRDNf_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr_AFE_TX_PWRDNf_SET
#define READ_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr BCMI_MADURA_READ_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr
#define WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr BCMI_MADURA_WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr
#define MODIFY_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr BCMI_MADURA_MODIFY_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STS_TXr'
 */



/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CLK_N_RST_MISC_CTL
 * BLOCKS:   TX_CKRST_CTRL_MADURA
 * REGADDR:  0xd1bd
 * DEVAD:    1
 * DESC:     CLOCK_N_RESET_MISC_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_LOOP_FILTER_STABLE This register bit is ANDed with pmd_tx_clk_vld before frc/frc_val mux. This register will be controlled by the firmware when TX_PI is enabled.When TX_PI is enabled then this register will be written to 1'b0 while TX_PI is acquiring the lock with the source clock and will be written to 1'b1 by firmwareto indicate that clocks are locked. It indicates to chip level via pmd_tx_clk_vld to reset any datapath FIFOs and come out of reset when TX clock is stable.
 */
#define BCMI_MADURA_CLK_N_RST_MISC_CTLr (0x0001d1bd | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CLK_N_RST_MISC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CLK_N_RST_MISC_CTL.
 */
typedef union BCMI_MADURA_CLK_N_RST_MISC_CTLr_s {
	uint32_t v[1];
	uint32_t clk_n_rst_misc_ctl[1];
	uint32_t _clk_n_rst_misc_ctl;
} BCMI_MADURA_CLK_N_RST_MISC_CTLr_t;

#define BCMI_MADURA_CLK_N_RST_MISC_CTLr_CLR(r) (r).clk_n_rst_misc_ctl[0] = 0
#define BCMI_MADURA_CLK_N_RST_MISC_CTLr_SET(r,d) (r).clk_n_rst_misc_ctl[0] = d
#define BCMI_MADURA_CLK_N_RST_MISC_CTLr_GET(r) (r).clk_n_rst_misc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET(r) (((r).clk_n_rst_misc_ctl[0]) & 0x1)
#define BCMI_MADURA_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET(r,f) (r).clk_n_rst_misc_ctl[0]=(((r).clk_n_rst_misc_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CLK_N_RST_MISC_CTL.
 */
#define BCMI_MADURA_READ_CLK_N_RST_MISC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CLK_N_RST_MISC_CTLr,_r._clk_n_rst_misc_ctl)
#define BCMI_MADURA_WRITE_CLK_N_RST_MISC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CLK_N_RST_MISC_CTLr,_r._clk_n_rst_misc_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CLK_N_RST_MISC_CTLr BCMI_MADURA_CLK_N_RST_MISC_CTLr
#define CLK_N_RST_MISC_CTLr_SIZE BCMI_MADURA_CLK_N_RST_MISC_CTLr_SIZE
typedef BCMI_MADURA_CLK_N_RST_MISC_CTLr_t CLK_N_RST_MISC_CTLr_t;
#define CLK_N_RST_MISC_CTLr_CLR BCMI_MADURA_CLK_N_RST_MISC_CTLr_CLR
#define CLK_N_RST_MISC_CTLr_SET BCMI_MADURA_CLK_N_RST_MISC_CTLr_SET
#define CLK_N_RST_MISC_CTLr_GET BCMI_MADURA_CLK_N_RST_MISC_CTLr_GET
#define CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET BCMI_MADURA_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET
#define CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET BCMI_MADURA_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET
#define READ_CLK_N_RST_MISC_CTLr BCMI_MADURA_READ_CLK_N_RST_MISC_CTLr
#define WRITE_CLK_N_RST_MISC_CTLr BCMI_MADURA_WRITE_CLK_N_RST_MISC_CTLr
#define MODIFY_CLK_N_RST_MISC_CTLr BCMI_MADURA_MODIFY_CLK_N_RST_MISC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CLK_N_RST_MISC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  RX_LN_S_RSTB_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1ce
 * DEVAD:    1
 * DESC:     LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 */
#define BCMI_MADURA_RX_LN_S_RSTB_CTLr (0x0001d1ce | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_RX_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_S_RSTB_CTL.
 */
typedef union BCMI_MADURA_RX_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_s_rstb_ctl[1];
	uint32_t _rx_ln_s_rstb_ctl;
} BCMI_MADURA_RX_LN_S_RSTB_CTLr_t;

#define BCMI_MADURA_RX_LN_S_RSTB_CTLr_CLR(r) (r).rx_ln_s_rstb_ctl[0] = 0
#define BCMI_MADURA_RX_LN_S_RSTB_CTLr_SET(r,d) (r).rx_ln_s_rstb_ctl[0] = d
#define BCMI_MADURA_RX_LN_S_RSTB_CTLr_GET(r) (r).rx_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_RX_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET(r) (((r).rx_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_MADURA_RX_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET(r,f) (r).rx_ln_s_rstb_ctl[0]=(((r).rx_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_S_RSTB_CTL.
 */
#define BCMI_MADURA_READ_RX_LN_S_RSTB_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_RX_LN_S_RSTB_CTLr,_r._rx_ln_s_rstb_ctl)
#define BCMI_MADURA_WRITE_RX_LN_S_RSTB_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_RX_LN_S_RSTB_CTLr,_r._rx_ln_s_rstb_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_S_RSTB_CTLr BCMI_MADURA_RX_LN_S_RSTB_CTLr
#define RX_LN_S_RSTB_CTLr_SIZE BCMI_MADURA_RX_LN_S_RSTB_CTLr_SIZE
typedef BCMI_MADURA_RX_LN_S_RSTB_CTLr_t RX_LN_S_RSTB_CTLr_t;
#define RX_LN_S_RSTB_CTLr_CLR BCMI_MADURA_RX_LN_S_RSTB_CTLr_CLR
#define RX_LN_S_RSTB_CTLr_SET BCMI_MADURA_RX_LN_S_RSTB_CTLr_SET
#define RX_LN_S_RSTB_CTLr_GET BCMI_MADURA_RX_LN_S_RSTB_CTLr_GET
#define RX_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET BCMI_MADURA_RX_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET
#define RX_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET BCMI_MADURA_RX_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET
#define READ_RX_LN_S_RSTB_CTLr BCMI_MADURA_READ_RX_LN_S_RSTB_CTLr
#define WRITE_RX_LN_S_RSTB_CTLr BCMI_MADURA_WRITE_RX_LN_S_RSTB_CTLr
#define MODIFY_RX_LN_S_RSTB_CTLr BCMI_MADURA_MODIFY_RX_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_RX_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OSR_MODE_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1d0
 * DEVAD:    1
 * DESC:     OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_OSR_MODE_FRC_VAL oversample (OS) mode Decoding of this register is as follows.OSX1          4'd0OSX2          4'd1OSX4          4'd2OSX16P5       4'd8OSX20P625     4'd12OSX8          4'd5OSX16         4'd9OSX32         4'd13
 *     TX_OSR_MODE_FRC  oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_MADURA_OSR_MODE_CTLr (0x0001d1d0 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program OSR_MODE_CTL.
 */
typedef union BCMI_MADURA_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t osr_mode_ctl[1];
	uint32_t _osr_mode_ctl;
} BCMI_MADURA_OSR_MODE_CTLr_t;

#define BCMI_MADURA_OSR_MODE_CTLr_CLR(r) (r).osr_mode_ctl[0] = 0
#define BCMI_MADURA_OSR_MODE_CTLr_SET(r,d) (r).osr_mode_ctl[0] = d
#define BCMI_MADURA_OSR_MODE_CTLr_GET(r) (r).osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET(r) ((((r).osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET(r,f) (r).osr_mode_ctl[0]=(((r).osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET(r) (((r).osr_mode_ctl[0]) & 0xf)
#define BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET(r,f) (r).osr_mode_ctl[0]=(((r).osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access OSR_MODE_CTL.
 */
#define BCMI_MADURA_READ_OSR_MODE_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OSR_MODE_CTLr,_r._osr_mode_ctl)
#define BCMI_MADURA_WRITE_OSR_MODE_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OSR_MODE_CTLr,_r._osr_mode_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OSR_MODE_CTLr BCMI_MADURA_OSR_MODE_CTLr
#define OSR_MODE_CTLr_SIZE BCMI_MADURA_OSR_MODE_CTLr_SIZE
typedef BCMI_MADURA_OSR_MODE_CTLr_t OSR_MODE_CTLr_t;
#define OSR_MODE_CTLr_CLR BCMI_MADURA_OSR_MODE_CTLr_CLR
#define OSR_MODE_CTLr_SET BCMI_MADURA_OSR_MODE_CTLr_SET
#define OSR_MODE_CTLr_GET BCMI_MADURA_OSR_MODE_CTLr_GET
#define OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET
#define OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET
#define OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET
#define OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET BCMI_MADURA_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET
#define READ_OSR_MODE_CTLr BCMI_MADURA_READ_OSR_MODE_CTLr
#define WRITE_OSR_MODE_CTLr BCMI_MADURA_WRITE_OSR_MODE_CTLr
#define MODIFY_OSR_MODE_CTLr BCMI_MADURA_MODIFY_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1d1
 * DEVAD:    1
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_DP_S_RSTB  Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 */
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1d1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _ln_clk_rst_n_pwrdwn_ctl;
} BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET(r) (((r).ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET(r,f) (r).ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_MADURA_READ_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr,_r._ln_clk_rst_n_pwrdwn_ctl)
#define BCMI_MADURA_WRITE_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr,_r._ln_clk_rst_n_pwrdwn_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_CLK_RST_N_PWRDWN_CTLr BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr
#define LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_t LN_CLK_RST_N_PWRDWN_CTLr_t;
#define LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET
#define LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET
#define READ_LN_CLK_RST_N_PWRDWN_CTLr BCMI_MADURA_READ_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_LN_CLK_RST_N_PWRDWN_CTLr BCMI_MADURA_WRITE_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_LN_CLK_RST_N_PWRDWN_CTLr BCMI_MADURA_MODIFY_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1d3
 * DEVAD:    1
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_TX_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_TX_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 */
#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1d3 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET(r) ((((r).ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET(r,f) (r).ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET(r) (((r).ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET(r,f) (r).ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_MADURA_READ_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr,_r._ln_rst_n_pwrdn_pin_kill_ctl)
#define BCMI_MADURA_WRITE_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr,_r._ln_rst_n_pwrdn_pin_kill_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_t LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET
#define LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET
#define READ_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_MADURA_READ_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_MADURA_WRITE_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_MADURA_MODIFY_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_ACK_LN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1d5
 * DEVAD:    1
 * DESC:     UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     TX_UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_MADURA_UC_ACK_LN_CTLr (0x0001d1d5 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program UC_ACK_LN_CTL.
 */
typedef union BCMI_MADURA_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t uc_ack_ln_ctl[1];
	uint32_t _uc_ack_ln_ctl;
} BCMI_MADURA_UC_ACK_LN_CTLr_t;

#define BCMI_MADURA_UC_ACK_LN_CTLr_CLR(r) (r).uc_ack_ln_ctl[0] = 0
#define BCMI_MADURA_UC_ACK_LN_CTLr_SET(r,d) (r).uc_ack_ln_ctl[0] = d
#define BCMI_MADURA_UC_ACK_LN_CTLr_GET(r) (r).uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).uc_ack_ln_ctl[0]=(((r).uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).uc_ack_ln_ctl[0]=(((r).uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_ACK_LN_CTL.
 */
#define BCMI_MADURA_READ_UC_ACK_LN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_ACK_LN_CTLr,_r._uc_ack_ln_ctl)
#define BCMI_MADURA_WRITE_UC_ACK_LN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_ACK_LN_CTLr,_r._uc_ack_ln_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_ACK_LN_CTLr BCMI_MADURA_UC_ACK_LN_CTLr
#define UC_ACK_LN_CTLr_SIZE BCMI_MADURA_UC_ACK_LN_CTLr_SIZE
typedef BCMI_MADURA_UC_ACK_LN_CTLr_t UC_ACK_LN_CTLr_t;
#define UC_ACK_LN_CTLr_CLR BCMI_MADURA_UC_ACK_LN_CTLr_CLR
#define UC_ACK_LN_CTLr_SET BCMI_MADURA_UC_ACK_LN_CTLr_SET
#define UC_ACK_LN_CTLr_GET BCMI_MADURA_UC_ACK_LN_CTLr_GET
#define UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET
#define UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET
#define UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET
#define UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET BCMI_MADURA_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET
#define READ_UC_ACK_LN_CTLr BCMI_MADURA_READ_UC_ACK_LN_CTLr
#define WRITE_UC_ACK_LN_CTLr BCMI_MADURA_WRITE_UC_ACK_LN_CTLr
#define MODIFY_UC_ACK_LN_CTLr BCMI_MADURA_MODIFY_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_RST_OCC_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1d6
 * DEVAD:    1
 * DESC:     LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_MADURA_LN_RST_OCC_CTLr (0x0001d1d6 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LN_RST_OCC_CTL.
 */
typedef union BCMI_MADURA_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t ln_rst_occ_ctl[1];
	uint32_t _ln_rst_occ_ctl;
} BCMI_MADURA_LN_RST_OCC_CTLr_t;

#define BCMI_MADURA_LN_RST_OCC_CTLr_CLR(r) (r).ln_rst_occ_ctl[0] = 0
#define BCMI_MADURA_LN_RST_OCC_CTLr_SET(r,d) (r).ln_rst_occ_ctl[0] = d
#define BCMI_MADURA_LN_RST_OCC_CTLr_GET(r) (r).ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET(r) (((r).ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_MADURA_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).ln_rst_occ_ctl[0]=(((r).ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LN_RST_OCC_CTL.
 */
#define BCMI_MADURA_READ_LN_RST_OCC_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_RST_OCC_CTLr,_r._ln_rst_occ_ctl)
#define BCMI_MADURA_WRITE_LN_RST_OCC_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_RST_OCC_CTLr,_r._ln_rst_occ_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_RST_OCC_CTLr BCMI_MADURA_LN_RST_OCC_CTLr
#define LN_RST_OCC_CTLr_SIZE BCMI_MADURA_LN_RST_OCC_CTLr_SIZE
typedef BCMI_MADURA_LN_RST_OCC_CTLr_t LN_RST_OCC_CTLr_t;
#define LN_RST_OCC_CTLr_CLR BCMI_MADURA_LN_RST_OCC_CTLr_CLR
#define LN_RST_OCC_CTLr_SET BCMI_MADURA_LN_RST_OCC_CTLr_SET
#define LN_RST_OCC_CTLr_GET BCMI_MADURA_LN_RST_OCC_CTLr_GET
#define LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET BCMI_MADURA_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET
#define LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET BCMI_MADURA_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET
#define READ_LN_RST_OCC_CTLr BCMI_MADURA_READ_LN_RST_OCC_CTLr
#define WRITE_LN_RST_OCC_CTLr BCMI_MADURA_WRITE_LN_RST_OCC_CTLr
#define MODIFY_LN_RST_OCC_CTLr BCMI_MADURA_MODIFY_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  PLL_SEL_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1d7
 * DEVAD:    1
 * DESC:     PLL_SELECT_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PLL_SELECT    This register controls the selection of the PLL0 or PLL1 as clock source for the tx_ lane. This register will be only reset upon POR hard or POR soft reset.This register is expected to be changed only when tx_ lane datapath is in reset.0 - Select PLL0 as clock for tx_ lane.1 - Select PLL1 as clock for tx_ lane.This register bit also drive the AFE tx_ctrl[0] pin.
 */
#define BCMI_MADURA_PLL_SEL_CTLr (0x0001d1d7 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_PLL_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PLL_SEL_CTL.
 */
typedef union BCMI_MADURA_PLL_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t pll_sel_ctl[1];
	uint32_t _pll_sel_ctl;
} BCMI_MADURA_PLL_SEL_CTLr_t;

#define BCMI_MADURA_PLL_SEL_CTLr_CLR(r) (r).pll_sel_ctl[0] = 0
#define BCMI_MADURA_PLL_SEL_CTLr_SET(r,d) (r).pll_sel_ctl[0] = d
#define BCMI_MADURA_PLL_SEL_CTLr_GET(r) (r).pll_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_PLL_SEL_CTLr_TX_PLL_SELECTf_GET(r) (((r).pll_sel_ctl[0]) & 0x1)
#define BCMI_MADURA_PLL_SEL_CTLr_TX_PLL_SELECTf_SET(r,f) (r).pll_sel_ctl[0]=(((r).pll_sel_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_SEL_CTL.
 */
#define BCMI_MADURA_READ_PLL_SEL_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_PLL_SEL_CTLr,_r._pll_sel_ctl)
#define BCMI_MADURA_WRITE_PLL_SEL_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_PLL_SEL_CTLr,_r._pll_sel_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_SEL_CTLr BCMI_MADURA_PLL_SEL_CTLr
#define PLL_SEL_CTLr_SIZE BCMI_MADURA_PLL_SEL_CTLr_SIZE
typedef BCMI_MADURA_PLL_SEL_CTLr_t PLL_SEL_CTLr_t;
#define PLL_SEL_CTLr_CLR BCMI_MADURA_PLL_SEL_CTLr_CLR
#define PLL_SEL_CTLr_SET BCMI_MADURA_PLL_SEL_CTLr_SET
#define PLL_SEL_CTLr_GET BCMI_MADURA_PLL_SEL_CTLr_GET
#define PLL_SEL_CTLr_TX_PLL_SELECTf_GET BCMI_MADURA_PLL_SEL_CTLr_TX_PLL_SELECTf_GET
#define PLL_SEL_CTLr_TX_PLL_SELECTf_SET BCMI_MADURA_PLL_SEL_CTLr_TX_PLL_SELECTf_SET
#define READ_PLL_SEL_CTLr BCMI_MADURA_READ_PLL_SEL_CTLr
#define WRITE_PLL_SEL_CTLr BCMI_MADURA_WRITE_PLL_SEL_CTLr
#define MODIFY_PLL_SEL_CTLr BCMI_MADURA_MODIFY_PLL_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_PLL_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  LN_DP_RST_ST_STS
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1d9
 * DEVAD:    1
 * DESC:     LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_MADURA_LN_DP_RST_ST_STSr (0x0001d1d9 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program LN_DP_RST_ST_STS.
 */
typedef union BCMI_MADURA_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t ln_dp_rst_st_sts[1];
	uint32_t _ln_dp_rst_st_sts;
} BCMI_MADURA_LN_DP_RST_ST_STSr_t;

#define BCMI_MADURA_LN_DP_RST_ST_STSr_CLR(r) (r).ln_dp_rst_st_sts[0] = 0
#define BCMI_MADURA_LN_DP_RST_ST_STSr_SET(r,d) (r).ln_dp_rst_st_sts[0] = d
#define BCMI_MADURA_LN_DP_RST_ST_STSr_GET(r) (r).ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET(r) (((r).ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_MADURA_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET(r,f) (r).ln_dp_rst_st_sts[0]=(((r).ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access LN_DP_RST_ST_STS.
 */
#define BCMI_MADURA_READ_LN_DP_RST_ST_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_LN_DP_RST_ST_STSr,_r._ln_dp_rst_st_sts)
#define BCMI_MADURA_WRITE_LN_DP_RST_ST_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_LN_DP_RST_ST_STSr,_r._ln_dp_rst_st_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_DP_RST_ST_STSr BCMI_MADURA_LN_DP_RST_ST_STSr
#define LN_DP_RST_ST_STSr_SIZE BCMI_MADURA_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_MADURA_LN_DP_RST_ST_STSr_t LN_DP_RST_ST_STSr_t;
#define LN_DP_RST_ST_STSr_CLR BCMI_MADURA_LN_DP_RST_ST_STSr_CLR
#define LN_DP_RST_ST_STSr_SET BCMI_MADURA_LN_DP_RST_ST_STSr_SET
#define LN_DP_RST_ST_STSr_GET BCMI_MADURA_LN_DP_RST_ST_STSr_GET
#define LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET BCMI_MADURA_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET
#define LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET BCMI_MADURA_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET
#define READ_LN_DP_RST_ST_STSr BCMI_MADURA_READ_LN_DP_RST_ST_STSr
#define WRITE_LN_DP_RST_ST_STSr BCMI_MADURA_WRITE_LN_DP_RST_ST_STSr
#define MODIFY_LN_DP_RST_ST_STSr BCMI_MADURA_MODIFY_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MCST_MASK_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1da
 * DEVAD:    1
 * DESC:     MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_MADURA_MCST_MASK_CTLr (0x0001d1da | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MCST_MASK_CTL.
 */
typedef union BCMI_MADURA_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t mcst_mask_ctl[1];
	uint32_t _mcst_mask_ctl;
} BCMI_MADURA_MCST_MASK_CTLr_t;

#define BCMI_MADURA_MCST_MASK_CTLr_CLR(r) (r).mcst_mask_ctl[0] = 0
#define BCMI_MADURA_MCST_MASK_CTLr_SET(r,d) (r).mcst_mask_ctl[0] = d
#define BCMI_MADURA_MCST_MASK_CTLr_GET(r) (r).mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET(r) (((r).mcst_mask_ctl[0]) & 0x1)
#define BCMI_MADURA_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET(r,f) (r).mcst_mask_ctl[0]=(((r).mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MCST_MASK_CTL.
 */
#define BCMI_MADURA_READ_MCST_MASK_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MCST_MASK_CTLr,_r._mcst_mask_ctl)
#define BCMI_MADURA_WRITE_MCST_MASK_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MCST_MASK_CTLr,_r._mcst_mask_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MCST_MASK_CTLr BCMI_MADURA_MCST_MASK_CTLr
#define MCST_MASK_CTLr_SIZE BCMI_MADURA_MCST_MASK_CTLr_SIZE
typedef BCMI_MADURA_MCST_MASK_CTLr_t MCST_MASK_CTLr_t;
#define MCST_MASK_CTLr_CLR BCMI_MADURA_MCST_MASK_CTLr_CLR
#define MCST_MASK_CTLr_SET BCMI_MADURA_MCST_MASK_CTLr_SET
#define MCST_MASK_CTLr_GET BCMI_MADURA_MCST_MASK_CTLr_GET
#define MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET BCMI_MADURA_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET
#define MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET BCMI_MADURA_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET
#define READ_MCST_MASK_CTLr BCMI_MADURA_READ_MCST_MASK_CTLr
#define WRITE_MCST_MASK_CTLr BCMI_MADURA_WRITE_MCST_MASK_CTLr
#define MODIFY_MCST_MASK_CTLr BCMI_MADURA_MODIFY_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  OSR_MODE_STS_MC_MASK
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1db
 * DEVAD:    1
 * DESC:     OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_OSR_MODE      OSR Mode status after the mux.OSR Mode status after the osr_mode_frc/frc_val mux.OSX1          4'd0OSX2          4'd1OSX4          4'd2OSX16P5       4'd8OSX20P625     4'd12OSX8          4'd5OSX16         4'd9OSX32         4'd13
 *     TX_MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 */
#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr (0x0001d1db | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program OSR_MODE_STS_MC_MASK.
 */
typedef union BCMI_MADURA_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t osr_mode_sts_mc_mask[1];
	uint32_t _osr_mode_sts_mc_mask;
} BCMI_MADURA_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_CLR(r) (r).osr_mode_sts_mc_mask[0] = 0
#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).osr_mode_sts_mc_mask[0] = d
#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_GET(r) (r).osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).osr_mode_sts_mc_mask[0]) >> 4) & 0x1)
#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).osr_mode_sts_mc_mask[0]=(((r).osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET(r) (((r).osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET(r,f) (r).osr_mode_sts_mc_mask[0]=(((r).osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access OSR_MODE_STS_MC_MASK.
 */
#define BCMI_MADURA_READ_OSR_MODE_STS_MC_MASKr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_OSR_MODE_STS_MC_MASKr,_r._osr_mode_sts_mc_mask)
#define BCMI_MADURA_WRITE_OSR_MODE_STS_MC_MASKr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_OSR_MODE_STS_MC_MASKr,_r._osr_mode_sts_mc_mask)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define OSR_MODE_STS_MC_MASKr BCMI_MADURA_OSR_MODE_STS_MC_MASKr
#define OSR_MODE_STS_MC_MASKr_SIZE BCMI_MADURA_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_MADURA_OSR_MODE_STS_MC_MASKr_t OSR_MODE_STS_MC_MASKr_t;
#define OSR_MODE_STS_MC_MASKr_CLR BCMI_MADURA_OSR_MODE_STS_MC_MASKr_CLR
#define OSR_MODE_STS_MC_MASKr_SET BCMI_MADURA_OSR_MODE_STS_MC_MASKr_SET
#define OSR_MODE_STS_MC_MASKr_GET BCMI_MADURA_OSR_MODE_STS_MC_MASKr_GET
#define OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET
#define OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET
#define OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET
#define OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET BCMI_MADURA_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET
#define READ_OSR_MODE_STS_MC_MASKr BCMI_MADURA_READ_OSR_MODE_STS_MC_MASKr
#define WRITE_OSR_MODE_STS_MC_MASKr BCMI_MADURA_WRITE_OSR_MODE_STS_MC_MASKr
#define MODIFY_OSR_MODE_STS_MC_MASKr BCMI_MADURA_MODIFY_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_OSR_MODE_STS_MC_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AFE_RST_PWRDN_OSR_MODE_PIN_STS
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1dc
 * DEVAD:    1
 * DESC:     AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_OSR_MODE_PIN  Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0OSX2          4'd1OSX4          4'd2OSX16P5       4'd8OSX20P625     4'd12OSX8          4'd5OSX16         4'd9OSX32         4'd13
 */
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr (0x0001d1dc | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
typedef union BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t afe_rst_pwrdn_osr_mode_pin_sts[1];
	uint32_t _afe_rst_pwrdn_osr_mode_pin_sts;
} BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;

#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR(r) (r).afe_rst_pwrdn_osr_mode_pin_sts[0] = 0
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET(r,d) (r).afe_rst_pwrdn_osr_mode_pin_sts[0] = d
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET(r) (r).afe_rst_pwrdn_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET(r) (((r).afe_rst_pwrdn_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET(r,f) (r).afe_rst_pwrdn_osr_mode_pin_sts[0]=(((r).afe_rst_pwrdn_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AFE_RST_PWRDN_OSR_MODE_PIN_STS.
 */
#define BCMI_MADURA_READ_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,_r._afe_rst_pwrdn_osr_mode_pin_sts)
#define BCMI_MADURA_WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr,_r._afe_rst_pwrdn_osr_mode_pin_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t AFE_RST_PWRDN_OSR_MODE_PIN_STSr_t;
#define AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_CLR
#define AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_SET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_GET
#define AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr_TX_OSR_MODE_PINf_SET
#define READ_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_MADURA_READ_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_MADURA_WRITE_AFE_RST_PWRDN_OSR_MODE_PIN_STSr
#define MODIFY_AFE_RST_PWRDN_OSR_MODE_PIN_STSr BCMI_MADURA_MODIFY_AFE_RST_PWRDN_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AFE_RST_PWRDN_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  TX_LN_S_RSTB_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_MADURA
 * REGADDR:  0xd1de
 * DEVAD:    1
 * DESC:     LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 */
#define BCMI_MADURA_TX_LN_S_RSTB_CTLr (0x0001d1de | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_TX_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_S_RSTB_CTL.
 */
typedef union BCMI_MADURA_TX_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_s_rstb_ctl[1];
	uint32_t _tx_ln_s_rstb_ctl;
} BCMI_MADURA_TX_LN_S_RSTB_CTLr_t;

#define BCMI_MADURA_TX_LN_S_RSTB_CTLr_CLR(r) (r).tx_ln_s_rstb_ctl[0] = 0
#define BCMI_MADURA_TX_LN_S_RSTB_CTLr_SET(r,d) (r).tx_ln_s_rstb_ctl[0] = d
#define BCMI_MADURA_TX_LN_S_RSTB_CTLr_GET(r) (r).tx_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_TX_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET(r) (((r).tx_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_MADURA_TX_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET(r,f) (r).tx_ln_s_rstb_ctl[0]=(((r).tx_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_S_RSTB_CTL.
 */
#define BCMI_MADURA_READ_TX_LN_S_RSTB_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_TX_LN_S_RSTB_CTLr,_r._tx_ln_s_rstb_ctl)
#define BCMI_MADURA_WRITE_TX_LN_S_RSTB_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_TX_LN_S_RSTB_CTLr,_r._tx_ln_s_rstb_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_S_RSTB_CTLr BCMI_MADURA_TX_LN_S_RSTB_CTLr
#define TX_LN_S_RSTB_CTLr_SIZE BCMI_MADURA_TX_LN_S_RSTB_CTLr_SIZE
typedef BCMI_MADURA_TX_LN_S_RSTB_CTLr_t TX_LN_S_RSTB_CTLr_t;
#define TX_LN_S_RSTB_CTLr_CLR BCMI_MADURA_TX_LN_S_RSTB_CTLr_CLR
#define TX_LN_S_RSTB_CTLr_SET BCMI_MADURA_TX_LN_S_RSTB_CTLr_SET
#define TX_LN_S_RSTB_CTLr_GET BCMI_MADURA_TX_LN_S_RSTB_CTLr_GET
#define TX_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET BCMI_MADURA_TX_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET
#define TX_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET BCMI_MADURA_TX_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET
#define READ_TX_LN_S_RSTB_CTLr BCMI_MADURA_READ_TX_LN_S_RSTB_CTLr
#define WRITE_TX_LN_S_RSTB_CTLr BCMI_MADURA_WRITE_TX_LN_S_RSTB_CTLr
#define MODIFY_TX_LN_S_RSTB_CTLr BCMI_MADURA_MODIFY_TX_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_TX_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_CLK_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd200
 * DEVAD:    1
 * DESC:     Clock control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_CLK_EN master clock enable:By default the clock to micro sub-system is disabled andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 enable the master clock0 - disabled1 - enables
 *     MICRO_CORE_CLK_EN micro core clock enable (m0):While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted0 - disabled1 - enables
 */
#define BCMI_MADURA_UC_CLK_CTL0r (0x0001d200 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_CLK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CLK_CTL0.
 */
typedef union BCMI_MADURA_UC_CLK_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_clk_ctl0[1];
	uint32_t _uc_clk_ctl0;
} BCMI_MADURA_UC_CLK_CTL0r_t;

#define BCMI_MADURA_UC_CLK_CTL0r_CLR(r) (r).uc_clk_ctl0[0] = 0
#define BCMI_MADURA_UC_CLK_CTL0r_SET(r,d) (r).uc_clk_ctl0[0] = d
#define BCMI_MADURA_UC_CLK_CTL0r_GET(r) (r).uc_clk_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET(r) ((((r).uc_clk_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET(r) (((r).uc_clk_ctl0[0]) & 0x1)
#define BCMI_MADURA_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CLK_CTL0.
 */
#define BCMI_MADURA_READ_UC_CLK_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_CLK_CTL0r,_r._uc_clk_ctl0)
#define BCMI_MADURA_WRITE_UC_CLK_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_CLK_CTL0r,_r._uc_clk_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CLK_CTL0r BCMI_MADURA_UC_CLK_CTL0r
#define UC_CLK_CTL0r_SIZE BCMI_MADURA_UC_CLK_CTL0r_SIZE
typedef BCMI_MADURA_UC_CLK_CTL0r_t UC_CLK_CTL0r_t;
#define UC_CLK_CTL0r_CLR BCMI_MADURA_UC_CLK_CTL0r_CLR
#define UC_CLK_CTL0r_SET BCMI_MADURA_UC_CLK_CTL0r_SET
#define UC_CLK_CTL0r_GET BCMI_MADURA_UC_CLK_CTL0r_GET
#define UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET BCMI_MADURA_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET BCMI_MADURA_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET BCMI_MADURA_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET BCMI_MADURA_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET
#define READ_UC_CLK_CTL0r BCMI_MADURA_READ_UC_CLK_CTL0r
#define WRITE_UC_CLK_CTL0r BCMI_MADURA_WRITE_UC_CLK_CTL0r
#define MODIFY_UC_CLK_CTL0r BCMI_MADURA_MODIFY_UC_CLK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_CLK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RST_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd201
 * DEVAD:    1
 * DESC:     Reset control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_RSTB master reset :By default a reset to micro controller sub-system is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the micro-subsystem0 - asserted1 - de-asserted
 *     MICRO_CORE_RSTB  micro core reset (m0):While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted.Setting this field to 1'b1 de-asserts a reset to the micro.0 - disabled1 - enables
 *     MICRO_PRAM_IF_RSTB PRAM interface reset :By default a reset to the PRAM interface is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the PRAM interface0 - asserted1 - de-asserted
 */
#define BCMI_MADURA_UC_RST_CTL0r (0x0001d201 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RST_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RST_CTL0.
 */
typedef union BCMI_MADURA_UC_RST_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rst_ctl0[1];
	uint32_t _uc_rst_ctl0;
} BCMI_MADURA_UC_RST_CTL0r_t;

#define BCMI_MADURA_UC_RST_CTL0r_CLR(r) (r).uc_rst_ctl0[0] = 0
#define BCMI_MADURA_UC_RST_CTL0r_SET(r,d) (r).uc_rst_ctl0[0] = d
#define BCMI_MADURA_UC_RST_CTL0r_GET(r) (r).uc_rst_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 3) & 0x1)
#define BCMI_MADURA_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_UC_RST_CTL0r_MICRO_CORE_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_RST_CTL0r_MICRO_CORE_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET(r) (((r).uc_rst_ctl0[0]) & 0x1)
#define BCMI_MADURA_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RST_CTL0.
 */
#define BCMI_MADURA_READ_UC_RST_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RST_CTL0r,_r._uc_rst_ctl0)
#define BCMI_MADURA_WRITE_UC_RST_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RST_CTL0r,_r._uc_rst_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RST_CTL0r BCMI_MADURA_UC_RST_CTL0r
#define UC_RST_CTL0r_SIZE BCMI_MADURA_UC_RST_CTL0r_SIZE
typedef BCMI_MADURA_UC_RST_CTL0r_t UC_RST_CTL0r_t;
#define UC_RST_CTL0r_CLR BCMI_MADURA_UC_RST_CTL0r_CLR
#define UC_RST_CTL0r_SET BCMI_MADURA_UC_RST_CTL0r_SET
#define UC_RST_CTL0r_GET BCMI_MADURA_UC_RST_CTL0r_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET BCMI_MADURA_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET BCMI_MADURA_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET
#define UC_RST_CTL0r_MICRO_CORE_RSTBf_GET BCMI_MADURA_UC_RST_CTL0r_MICRO_CORE_RSTBf_GET
#define UC_RST_CTL0r_MICRO_CORE_RSTBf_SET BCMI_MADURA_UC_RST_CTL0r_MICRO_CORE_RSTBf_SET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET BCMI_MADURA_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET BCMI_MADURA_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET
#define READ_UC_RST_CTL0r BCMI_MADURA_READ_UC_RST_CTL0r
#define WRITE_UC_RST_CTL0r BCMI_MADURA_WRITE_UC_RST_CTL0r
#define MODIFY_UC_RST_CTL0r BCMI_MADURA_MODIFY_UC_RST_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RST_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd202
 * DEVAD:    1
 * DESC:     rmi to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATASIZE write data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_RDDATASIZE read data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_INIT    Intialize code/data RAM2'b01: initailize code RAM - write zeroes to all locations2'b10: initialize data RAM - write zeroes to all loactions2'b00, 2'b11: ignored
 *     MICRO_AUTOINC_WRADDR_EN Automatic increment write address enable0 - disabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the constant addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.1 - enabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the start addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.the address automatically increments based on the micro_ra_wrdatasize field afterthe write has been performed
 *     MICRO_AUTOINC_RDADDR_EN Automatic increment read address enable0 - disabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the constant addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw fileds1 - enabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the start addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw filedsthe address automatically increments based on the micro_ra_rddatasize field afterthe read has been performed
 */
#define BCMI_MADURA_UC_AHB_CTL0r (0x0001d202 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_CTL0.
 */
typedef union BCMI_MADURA_UC_AHB_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_ctl0[1];
	uint32_t _uc_ahb_ctl0;
} BCMI_MADURA_UC_AHB_CTL0r_t;

#define BCMI_MADURA_UC_AHB_CTL0r_CLR(r) (r).uc_ahb_ctl0[0] = 0
#define BCMI_MADURA_UC_AHB_CTL0r_SET(r,d) (r).uc_ahb_ctl0[0] = d
#define BCMI_MADURA_UC_AHB_CTL0r_GET(r) (r).uc_ahb_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 13) & 0x1)
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 12) & 0x1)
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_INITf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 8) & 0x3)
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_INITf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 4) & 0x3)
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET(r) (((r).uc_ahb_ctl0[0]) & 0x3)
#define BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access UC_AHB_CTL0.
 */
#define BCMI_MADURA_READ_UC_AHB_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_CTL0r,_r._uc_ahb_ctl0)
#define BCMI_MADURA_WRITE_UC_AHB_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_CTL0r,_r._uc_ahb_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_CTL0r BCMI_MADURA_UC_AHB_CTL0r
#define UC_AHB_CTL0r_SIZE BCMI_MADURA_UC_AHB_CTL0r_SIZE
typedef BCMI_MADURA_UC_AHB_CTL0r_t UC_AHB_CTL0r_t;
#define UC_AHB_CTL0r_CLR BCMI_MADURA_UC_AHB_CTL0r_CLR
#define UC_AHB_CTL0r_SET BCMI_MADURA_UC_AHB_CTL0r_SET
#define UC_AHB_CTL0r_GET BCMI_MADURA_UC_AHB_CTL0r_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET BCMI_MADURA_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_RA_INITf_GET BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_INITf_GET
#define UC_AHB_CTL0r_MICRO_RA_INITf_SET BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_INITf_SET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET BCMI_MADURA_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET
#define READ_UC_AHB_CTL0r BCMI_MADURA_READ_UC_AHB_CTL0r
#define WRITE_UC_AHB_CTL0r BCMI_MADURA_WRITE_UC_AHB_CTL0r
#define MODIFY_UC_AHB_CTL0r BCMI_MADURA_MODIFY_UC_AHB_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_STS0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd203
 * DEVAD:    1
 * DESC:     rmi to ahb status registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_INITDONE When this bit is set, it indicate that code/data RAM initialization process is completeThis reamins set until
 */
#define BCMI_MADURA_UC_AHB_STS0r (0x0001d203 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_STS0.
 */
typedef union BCMI_MADURA_UC_AHB_STS0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_sts0[1];
	uint32_t _uc_ahb_sts0;
} BCMI_MADURA_UC_AHB_STS0r_t;

#define BCMI_MADURA_UC_AHB_STS0r_CLR(r) (r).uc_ahb_sts0[0] = 0
#define BCMI_MADURA_UC_AHB_STS0r_SET(r,d) (r).uc_ahb_sts0[0] = d
#define BCMI_MADURA_UC_AHB_STS0r_GET(r) (r).uc_ahb_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET(r) (((r).uc_ahb_sts0[0]) & 0x1)
#define BCMI_MADURA_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET(r,f) (r).uc_ahb_sts0[0]=(((r).uc_ahb_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_AHB_STS0.
 */
#define BCMI_MADURA_READ_UC_AHB_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_STS0r,_r._uc_ahb_sts0)
#define BCMI_MADURA_WRITE_UC_AHB_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_STS0r,_r._uc_ahb_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_STS0r BCMI_MADURA_UC_AHB_STS0r
#define UC_AHB_STS0r_SIZE BCMI_MADURA_UC_AHB_STS0r_SIZE
typedef BCMI_MADURA_UC_AHB_STS0r_t UC_AHB_STS0r_t;
#define UC_AHB_STS0r_CLR BCMI_MADURA_UC_AHB_STS0r_CLR
#define UC_AHB_STS0r_SET BCMI_MADURA_UC_AHB_STS0r_SET
#define UC_AHB_STS0r_GET BCMI_MADURA_UC_AHB_STS0r_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_GET BCMI_MADURA_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_SET BCMI_MADURA_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET
#define READ_UC_AHB_STS0r BCMI_MADURA_READ_UC_AHB_STS0r
#define WRITE_UC_AHB_STS0r BCMI_MADURA_WRITE_UC_AHB_STS0r
#define MODIFY_UC_AHB_STS0r BCMI_MADURA_MODIFY_UC_AHB_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd204
 * DEVAD:    1
 * DESC:     rmi to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during write transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactions
 */
#define BCMI_MADURA_UC_AHB_WRADDR_LSWr (0x0001d204 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_LSW.
 */
typedef union BCMI_MADURA_UC_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_lsw[1];
	uint32_t _uc_ahb_wraddr_lsw;
} BCMI_MADURA_UC_AHB_WRADDR_LSWr_t;

#define BCMI_MADURA_UC_AHB_WRADDR_LSWr_CLR(r) (r).uc_ahb_wraddr_lsw[0] = 0
#define BCMI_MADURA_UC_AHB_WRADDR_LSWr_SET(r,d) (r).uc_ahb_wraddr_lsw[0] = d
#define BCMI_MADURA_UC_AHB_WRADDR_LSWr_GET(r) (r).uc_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET(r) (((r).uc_ahb_wraddr_lsw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET(r,f) (r).uc_ahb_wraddr_lsw[0]=(((r).uc_ahb_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_LSW.
 */
#define BCMI_MADURA_READ_UC_AHB_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_WRADDR_LSWr,_r._uc_ahb_wraddr_lsw)
#define BCMI_MADURA_WRITE_UC_AHB_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_WRADDR_LSWr,_r._uc_ahb_wraddr_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_LSWr BCMI_MADURA_UC_AHB_WRADDR_LSWr
#define UC_AHB_WRADDR_LSWr_SIZE BCMI_MADURA_UC_AHB_WRADDR_LSWr_SIZE
typedef BCMI_MADURA_UC_AHB_WRADDR_LSWr_t UC_AHB_WRADDR_LSWr_t;
#define UC_AHB_WRADDR_LSWr_CLR BCMI_MADURA_UC_AHB_WRADDR_LSWr_CLR
#define UC_AHB_WRADDR_LSWr_SET BCMI_MADURA_UC_AHB_WRADDR_LSWr_SET
#define UC_AHB_WRADDR_LSWr_GET BCMI_MADURA_UC_AHB_WRADDR_LSWr_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET BCMI_MADURA_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET BCMI_MADURA_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET
#define READ_UC_AHB_WRADDR_LSWr BCMI_MADURA_READ_UC_AHB_WRADDR_LSWr
#define WRITE_UC_AHB_WRADDR_LSWr BCMI_MADURA_WRITE_UC_AHB_WRADDR_LSWr
#define MODIFY_UC_AHB_WRADDR_LSWr BCMI_MADURA_MODIFY_UC_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd205
 * DEVAD:    1
 * DESC:     rmi to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during write transactions
 */
#define BCMI_MADURA_UC_AHB_WRADDR_MSWr (0x0001d205 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_MSW.
 */
typedef union BCMI_MADURA_UC_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_msw[1];
	uint32_t _uc_ahb_wraddr_msw;
} BCMI_MADURA_UC_AHB_WRADDR_MSWr_t;

#define BCMI_MADURA_UC_AHB_WRADDR_MSWr_CLR(r) (r).uc_ahb_wraddr_msw[0] = 0
#define BCMI_MADURA_UC_AHB_WRADDR_MSWr_SET(r,d) (r).uc_ahb_wraddr_msw[0] = d
#define BCMI_MADURA_UC_AHB_WRADDR_MSWr_GET(r) (r).uc_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET(r) (((r).uc_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET(r,f) (r).uc_ahb_wraddr_msw[0]=(((r).uc_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_MSW.
 */
#define BCMI_MADURA_READ_UC_AHB_WRADDR_MSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_WRADDR_MSWr,_r._uc_ahb_wraddr_msw)
#define BCMI_MADURA_WRITE_UC_AHB_WRADDR_MSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_WRADDR_MSWr,_r._uc_ahb_wraddr_msw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_MSWr BCMI_MADURA_UC_AHB_WRADDR_MSWr
#define UC_AHB_WRADDR_MSWr_SIZE BCMI_MADURA_UC_AHB_WRADDR_MSWr_SIZE
typedef BCMI_MADURA_UC_AHB_WRADDR_MSWr_t UC_AHB_WRADDR_MSWr_t;
#define UC_AHB_WRADDR_MSWr_CLR BCMI_MADURA_UC_AHB_WRADDR_MSWr_CLR
#define UC_AHB_WRADDR_MSWr_SET BCMI_MADURA_UC_AHB_WRADDR_MSWr_SET
#define UC_AHB_WRADDR_MSWr_GET BCMI_MADURA_UC_AHB_WRADDR_MSWr_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET BCMI_MADURA_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET BCMI_MADURA_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET
#define READ_UC_AHB_WRADDR_MSWr BCMI_MADURA_READ_UC_AHB_WRADDR_MSWr
#define WRITE_UC_AHB_WRADDR_MSWr BCMI_MADURA_WRITE_UC_AHB_WRADDR_MSWr
#define MODIFY_UC_AHB_WRADDR_MSWr BCMI_MADURA_MODIFY_UC_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_WRDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd206
 * DEVAD:    1
 * DESC:     rmi to ahb write data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_LSW These bits are used to generate the lower 16-bits of the data on the AHB-Lite bus during write transactionsWrite transaction on the AHB-Lite is initiated when this register is written
 */
#define BCMI_MADURA_UC_AHB_WRDATA_LSWr (0x0001d206 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_WRDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_LSW.
 */
typedef union BCMI_MADURA_UC_AHB_WRDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_lsw[1];
	uint32_t _uc_ahb_wrdata_lsw;
} BCMI_MADURA_UC_AHB_WRDATA_LSWr_t;

#define BCMI_MADURA_UC_AHB_WRDATA_LSWr_CLR(r) (r).uc_ahb_wrdata_lsw[0] = 0
#define BCMI_MADURA_UC_AHB_WRDATA_LSWr_SET(r,d) (r).uc_ahb_wrdata_lsw[0] = d
#define BCMI_MADURA_UC_AHB_WRDATA_LSWr_GET(r) (r).uc_ahb_wrdata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET(r) (((r).uc_ahb_wrdata_lsw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET(r,f) (r).uc_ahb_wrdata_lsw[0]=(((r).uc_ahb_wrdata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_LSW.
 */
#define BCMI_MADURA_READ_UC_AHB_WRDATA_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_WRDATA_LSWr,_r._uc_ahb_wrdata_lsw)
#define BCMI_MADURA_WRITE_UC_AHB_WRDATA_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_WRDATA_LSWr,_r._uc_ahb_wrdata_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_LSWr BCMI_MADURA_UC_AHB_WRDATA_LSWr
#define UC_AHB_WRDATA_LSWr_SIZE BCMI_MADURA_UC_AHB_WRDATA_LSWr_SIZE
typedef BCMI_MADURA_UC_AHB_WRDATA_LSWr_t UC_AHB_WRDATA_LSWr_t;
#define UC_AHB_WRDATA_LSWr_CLR BCMI_MADURA_UC_AHB_WRDATA_LSWr_CLR
#define UC_AHB_WRDATA_LSWr_SET BCMI_MADURA_UC_AHB_WRDATA_LSWr_SET
#define UC_AHB_WRDATA_LSWr_GET BCMI_MADURA_UC_AHB_WRDATA_LSWr_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET BCMI_MADURA_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET BCMI_MADURA_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET
#define READ_UC_AHB_WRDATA_LSWr BCMI_MADURA_READ_UC_AHB_WRDATA_LSWr
#define WRITE_UC_AHB_WRDATA_LSWr BCMI_MADURA_WRITE_UC_AHB_WRDATA_LSWr
#define MODIFY_UC_AHB_WRDATA_LSWr BCMI_MADURA_MODIFY_UC_AHB_WRDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_WRDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_WRDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd207
 * DEVAD:    1
 * DESC:     rmi to ahb write data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_MSW These bits are used  to generate the upper 16-bits of the data on the AHB-Lite bus during write transactions
 */
#define BCMI_MADURA_UC_AHB_WRDATA_MSWr (0x0001d207 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_WRDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_MSW.
 */
typedef union BCMI_MADURA_UC_AHB_WRDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_msw[1];
	uint32_t _uc_ahb_wrdata_msw;
} BCMI_MADURA_UC_AHB_WRDATA_MSWr_t;

#define BCMI_MADURA_UC_AHB_WRDATA_MSWr_CLR(r) (r).uc_ahb_wrdata_msw[0] = 0
#define BCMI_MADURA_UC_AHB_WRDATA_MSWr_SET(r,d) (r).uc_ahb_wrdata_msw[0] = d
#define BCMI_MADURA_UC_AHB_WRDATA_MSWr_GET(r) (r).uc_ahb_wrdata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET(r) (((r).uc_ahb_wrdata_msw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET(r,f) (r).uc_ahb_wrdata_msw[0]=(((r).uc_ahb_wrdata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_MSW.
 */
#define BCMI_MADURA_READ_UC_AHB_WRDATA_MSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_WRDATA_MSWr,_r._uc_ahb_wrdata_msw)
#define BCMI_MADURA_WRITE_UC_AHB_WRDATA_MSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_WRDATA_MSWr,_r._uc_ahb_wrdata_msw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_MSWr BCMI_MADURA_UC_AHB_WRDATA_MSWr
#define UC_AHB_WRDATA_MSWr_SIZE BCMI_MADURA_UC_AHB_WRDATA_MSWr_SIZE
typedef BCMI_MADURA_UC_AHB_WRDATA_MSWr_t UC_AHB_WRDATA_MSWr_t;
#define UC_AHB_WRDATA_MSWr_CLR BCMI_MADURA_UC_AHB_WRDATA_MSWr_CLR
#define UC_AHB_WRDATA_MSWr_SET BCMI_MADURA_UC_AHB_WRDATA_MSWr_SET
#define UC_AHB_WRDATA_MSWr_GET BCMI_MADURA_UC_AHB_WRDATA_MSWr_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET BCMI_MADURA_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET BCMI_MADURA_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET
#define READ_UC_AHB_WRDATA_MSWr BCMI_MADURA_READ_UC_AHB_WRDATA_MSWr
#define WRITE_UC_AHB_WRDATA_MSWr BCMI_MADURA_WRITE_UC_AHB_WRDATA_MSWr
#define MODIFY_UC_AHB_WRDATA_MSWr BCMI_MADURA_MODIFY_UC_AHB_WRDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_WRDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_RDADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd208
 * DEVAD:    1
 * DESC:     rmi to ahb read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during read transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactionsRead transaction is initiated on the AHB-Lite when this register is written
 */
#define BCMI_MADURA_UC_AHB_RDADDR_LSWr (0x0001d208 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_LSW.
 */
typedef union BCMI_MADURA_UC_AHB_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_lsw[1];
	uint32_t _uc_ahb_rdaddr_lsw;
} BCMI_MADURA_UC_AHB_RDADDR_LSWr_t;

#define BCMI_MADURA_UC_AHB_RDADDR_LSWr_CLR(r) (r).uc_ahb_rdaddr_lsw[0] = 0
#define BCMI_MADURA_UC_AHB_RDADDR_LSWr_SET(r,d) (r).uc_ahb_rdaddr_lsw[0] = d
#define BCMI_MADURA_UC_AHB_RDADDR_LSWr_GET(r) (r).uc_ahb_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET(r) (((r).uc_ahb_rdaddr_lsw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET(r,f) (r).uc_ahb_rdaddr_lsw[0]=(((r).uc_ahb_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_LSW.
 */
#define BCMI_MADURA_READ_UC_AHB_RDADDR_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_RDADDR_LSWr,_r._uc_ahb_rdaddr_lsw)
#define BCMI_MADURA_WRITE_UC_AHB_RDADDR_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_RDADDR_LSWr,_r._uc_ahb_rdaddr_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_LSWr BCMI_MADURA_UC_AHB_RDADDR_LSWr
#define UC_AHB_RDADDR_LSWr_SIZE BCMI_MADURA_UC_AHB_RDADDR_LSWr_SIZE
typedef BCMI_MADURA_UC_AHB_RDADDR_LSWr_t UC_AHB_RDADDR_LSWr_t;
#define UC_AHB_RDADDR_LSWr_CLR BCMI_MADURA_UC_AHB_RDADDR_LSWr_CLR
#define UC_AHB_RDADDR_LSWr_SET BCMI_MADURA_UC_AHB_RDADDR_LSWr_SET
#define UC_AHB_RDADDR_LSWr_GET BCMI_MADURA_UC_AHB_RDADDR_LSWr_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET BCMI_MADURA_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET BCMI_MADURA_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET
#define READ_UC_AHB_RDADDR_LSWr BCMI_MADURA_READ_UC_AHB_RDADDR_LSWr
#define WRITE_UC_AHB_RDADDR_LSWr BCMI_MADURA_WRITE_UC_AHB_RDADDR_LSWr
#define MODIFY_UC_AHB_RDADDR_LSWr BCMI_MADURA_MODIFY_UC_AHB_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_RDADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd209
 * DEVAD:    1
 * DESC:     rmi to ahb read address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_MSW These bits are used by to generate the upper 16-bits of the address on the AHB-Lite bus during read transactions
 */
#define BCMI_MADURA_UC_AHB_RDADDR_MSWr (0x0001d209 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_RDADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_MSW.
 */
typedef union BCMI_MADURA_UC_AHB_RDADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_msw[1];
	uint32_t _uc_ahb_rdaddr_msw;
} BCMI_MADURA_UC_AHB_RDADDR_MSWr_t;

#define BCMI_MADURA_UC_AHB_RDADDR_MSWr_CLR(r) (r).uc_ahb_rdaddr_msw[0] = 0
#define BCMI_MADURA_UC_AHB_RDADDR_MSWr_SET(r,d) (r).uc_ahb_rdaddr_msw[0] = d
#define BCMI_MADURA_UC_AHB_RDADDR_MSWr_GET(r) (r).uc_ahb_rdaddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET(r) (((r).uc_ahb_rdaddr_msw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET(r,f) (r).uc_ahb_rdaddr_msw[0]=(((r).uc_ahb_rdaddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_MSW.
 */
#define BCMI_MADURA_READ_UC_AHB_RDADDR_MSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_RDADDR_MSWr,_r._uc_ahb_rdaddr_msw)
#define BCMI_MADURA_WRITE_UC_AHB_RDADDR_MSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_RDADDR_MSWr,_r._uc_ahb_rdaddr_msw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_MSWr BCMI_MADURA_UC_AHB_RDADDR_MSWr
#define UC_AHB_RDADDR_MSWr_SIZE BCMI_MADURA_UC_AHB_RDADDR_MSWr_SIZE
typedef BCMI_MADURA_UC_AHB_RDADDR_MSWr_t UC_AHB_RDADDR_MSWr_t;
#define UC_AHB_RDADDR_MSWr_CLR BCMI_MADURA_UC_AHB_RDADDR_MSWr_CLR
#define UC_AHB_RDADDR_MSWr_SET BCMI_MADURA_UC_AHB_RDADDR_MSWr_SET
#define UC_AHB_RDADDR_MSWr_GET BCMI_MADURA_UC_AHB_RDADDR_MSWr_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET BCMI_MADURA_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET BCMI_MADURA_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET
#define READ_UC_AHB_RDADDR_MSWr BCMI_MADURA_READ_UC_AHB_RDADDR_MSWr
#define WRITE_UC_AHB_RDADDR_MSWr BCMI_MADURA_WRITE_UC_AHB_RDADDR_MSWr
#define MODIFY_UC_AHB_RDADDR_MSWr BCMI_MADURA_MODIFY_UC_AHB_RDADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_RDADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_RDDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20a
 * DEVAD:    1
 * DESC:     rmi to ahb read data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_LSW These are the lower 16-bits of the read data from the AHB-Lite slave deviceRead transaction is initiated on the AHB-Lite when this register is read
 */
#define BCMI_MADURA_UC_AHB_RDDATA_LSWr (0x0001d20a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_RDDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_LSW.
 */
typedef union BCMI_MADURA_UC_AHB_RDDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_lsw[1];
	uint32_t _uc_ahb_rddata_lsw;
} BCMI_MADURA_UC_AHB_RDDATA_LSWr_t;

#define BCMI_MADURA_UC_AHB_RDDATA_LSWr_CLR(r) (r).uc_ahb_rddata_lsw[0] = 0
#define BCMI_MADURA_UC_AHB_RDDATA_LSWr_SET(r,d) (r).uc_ahb_rddata_lsw[0] = d
#define BCMI_MADURA_UC_AHB_RDDATA_LSWr_GET(r) (r).uc_ahb_rddata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET(r) (((r).uc_ahb_rddata_lsw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET(r,f) (r).uc_ahb_rddata_lsw[0]=(((r).uc_ahb_rddata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_LSW.
 */
#define BCMI_MADURA_READ_UC_AHB_RDDATA_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_RDDATA_LSWr,_r._uc_ahb_rddata_lsw)
#define BCMI_MADURA_WRITE_UC_AHB_RDDATA_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_RDDATA_LSWr,_r._uc_ahb_rddata_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_LSWr BCMI_MADURA_UC_AHB_RDDATA_LSWr
#define UC_AHB_RDDATA_LSWr_SIZE BCMI_MADURA_UC_AHB_RDDATA_LSWr_SIZE
typedef BCMI_MADURA_UC_AHB_RDDATA_LSWr_t UC_AHB_RDDATA_LSWr_t;
#define UC_AHB_RDDATA_LSWr_CLR BCMI_MADURA_UC_AHB_RDDATA_LSWr_CLR
#define UC_AHB_RDDATA_LSWr_SET BCMI_MADURA_UC_AHB_RDDATA_LSWr_SET
#define UC_AHB_RDDATA_LSWr_GET BCMI_MADURA_UC_AHB_RDDATA_LSWr_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET BCMI_MADURA_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET BCMI_MADURA_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET
#define READ_UC_AHB_RDDATA_LSWr BCMI_MADURA_READ_UC_AHB_RDDATA_LSWr
#define WRITE_UC_AHB_RDDATA_LSWr BCMI_MADURA_WRITE_UC_AHB_RDDATA_LSWr
#define MODIFY_UC_AHB_RDDATA_LSWr BCMI_MADURA_MODIFY_UC_AHB_RDDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_RDDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_AHB_RDDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20b
 * DEVAD:    1
 * DESC:     rmi to ahb read data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_MSW These are the upper 16-bits of the read data from the AHB-Lite slave device
 */
#define BCMI_MADURA_UC_AHB_RDDATA_MSWr (0x0001d20b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_AHB_RDDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_MSW.
 */
typedef union BCMI_MADURA_UC_AHB_RDDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_msw[1];
	uint32_t _uc_ahb_rddata_msw;
} BCMI_MADURA_UC_AHB_RDDATA_MSWr_t;

#define BCMI_MADURA_UC_AHB_RDDATA_MSWr_CLR(r) (r).uc_ahb_rddata_msw[0] = 0
#define BCMI_MADURA_UC_AHB_RDDATA_MSWr_SET(r,d) (r).uc_ahb_rddata_msw[0] = d
#define BCMI_MADURA_UC_AHB_RDDATA_MSWr_GET(r) (r).uc_ahb_rddata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET(r) (((r).uc_ahb_rddata_msw[0]) & 0xffff)
#define BCMI_MADURA_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET(r,f) (r).uc_ahb_rddata_msw[0]=(((r).uc_ahb_rddata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_MSW.
 */
#define BCMI_MADURA_READ_UC_AHB_RDDATA_MSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_AHB_RDDATA_MSWr,_r._uc_ahb_rddata_msw)
#define BCMI_MADURA_WRITE_UC_AHB_RDDATA_MSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_AHB_RDDATA_MSWr,_r._uc_ahb_rddata_msw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_MSWr BCMI_MADURA_UC_AHB_RDDATA_MSWr
#define UC_AHB_RDDATA_MSWr_SIZE BCMI_MADURA_UC_AHB_RDDATA_MSWr_SIZE
typedef BCMI_MADURA_UC_AHB_RDDATA_MSWr_t UC_AHB_RDDATA_MSWr_t;
#define UC_AHB_RDDATA_MSWr_CLR BCMI_MADURA_UC_AHB_RDDATA_MSWr_CLR
#define UC_AHB_RDDATA_MSWr_SET BCMI_MADURA_UC_AHB_RDDATA_MSWr_SET
#define UC_AHB_RDDATA_MSWr_GET BCMI_MADURA_UC_AHB_RDDATA_MSWr_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET BCMI_MADURA_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET BCMI_MADURA_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET
#define READ_UC_AHB_RDDATA_MSWr BCMI_MADURA_READ_UC_AHB_RDDATA_MSWr
#define WRITE_UC_AHB_RDDATA_MSWr BCMI_MADURA_WRITE_UC_AHB_RDDATA_MSWr
#define MODIFY_UC_AHB_RDDATA_MSWr BCMI_MADURA_MODIFY_UC_AHB_RDDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_AHB_RDDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_PRAMIF_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20c
 * DEVAD:    1
 * DESC:     pram i/f to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_EN  When this bit is set, pram if interface can generate write transactions on theAHB-Lite bus, the start address of the transaction is specifieldin the pramif_ahb_wraddr_lsw and pramif_ahb_wraddr_msw fields
 */
#define BCMI_MADURA_UC_PRAMIF_CTL0r (0x0001d20c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_PRAMIF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_CTL0.
 */
typedef union BCMI_MADURA_UC_PRAMIF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_pramif_ctl0[1];
	uint32_t _uc_pramif_ctl0;
} BCMI_MADURA_UC_PRAMIF_CTL0r_t;

#define BCMI_MADURA_UC_PRAMIF_CTL0r_CLR(r) (r).uc_pramif_ctl0[0] = 0
#define BCMI_MADURA_UC_PRAMIF_CTL0r_SET(r,d) (r).uc_pramif_ctl0[0] = d
#define BCMI_MADURA_UC_PRAMIF_CTL0r_GET(r) (r).uc_pramif_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET(r) (((r).uc_pramif_ctl0[0]) & 0x1)
#define BCMI_MADURA_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET(r,f) (r).uc_pramif_ctl0[0]=(((r).uc_pramif_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_PRAMIF_CTL0.
 */
#define BCMI_MADURA_READ_UC_PRAMIF_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_PRAMIF_CTL0r,_r._uc_pramif_ctl0)
#define BCMI_MADURA_WRITE_UC_PRAMIF_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_PRAMIF_CTL0r,_r._uc_pramif_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_CTL0r BCMI_MADURA_UC_PRAMIF_CTL0r
#define UC_PRAMIF_CTL0r_SIZE BCMI_MADURA_UC_PRAMIF_CTL0r_SIZE
typedef BCMI_MADURA_UC_PRAMIF_CTL0r_t UC_PRAMIF_CTL0r_t;
#define UC_PRAMIF_CTL0r_CLR BCMI_MADURA_UC_PRAMIF_CTL0r_CLR
#define UC_PRAMIF_CTL0r_SET BCMI_MADURA_UC_PRAMIF_CTL0r_SET
#define UC_PRAMIF_CTL0r_GET BCMI_MADURA_UC_PRAMIF_CTL0r_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET BCMI_MADURA_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET BCMI_MADURA_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET
#define READ_UC_PRAMIF_CTL0r BCMI_MADURA_READ_UC_PRAMIF_CTL0r
#define WRITE_UC_PRAMIF_CTL0r BCMI_MADURA_WRITE_UC_PRAMIF_CTL0r
#define MODIFY_UC_PRAMIF_CTL0r BCMI_MADURA_MODIFY_UC_PRAMIF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_PRAMIF_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20d
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_LSW These bits are used to generate the lower 14-bits of the address on the AHB-Lite bus during pram interface write transactionsbits[1:0] are not used for 32 transactions
 */
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr (0x0001d20d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_LSW.
 */
typedef union BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_lsw[1];
	uint32_t _uc_pramif_ahb_wraddr_lsw;
} BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_t;

#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_CLR(r) (r).uc_pramif_ahb_wraddr_lsw[0] = 0
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_lsw[0] = d
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_GET(r) (r).uc_pramif_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET(r) ((((r).uc_pramif_ahb_wraddr_lsw[0]) >> 2) & 0x3fff)
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_lsw[0]=(((r).uc_pramif_ahb_wraddr_lsw[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_LSW.
 */
#define BCMI_MADURA_READ_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr,_r._uc_pramif_ahb_wraddr_lsw)
#define BCMI_MADURA_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr,_r._uc_pramif_ahb_wraddr_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_LSWr BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr
#define UC_PRAMIF_AHB_WRADDR_LSWr_SIZE BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE
typedef BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_t UC_PRAMIF_AHB_WRADDR_LSWr_t;
#define UC_PRAMIF_AHB_WRADDR_LSWr_CLR BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_LSWr_SET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_SET
#define UC_PRAMIF_AHB_WRADDR_LSWr_GET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_MADURA_READ_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_MADURA_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_MADURA_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20e
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during pram interface write transactions
 */
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr (0x0001d20e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_MSW.
 */
typedef union BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_msw[1];
	uint32_t _uc_pramif_ahb_wraddr_msw;
} BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_t;

#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_CLR(r) (r).uc_pramif_ahb_wraddr_msw[0] = 0
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_msw[0] = d
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_GET(r) (r).uc_pramif_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET(r) (((r).uc_pramif_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_msw[0]=(((r).uc_pramif_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_MSW.
 */
#define BCMI_MADURA_READ_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr,_r._uc_pramif_ahb_wraddr_msw)
#define BCMI_MADURA_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr,_r._uc_pramif_ahb_wraddr_msw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_MSWr BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr
#define UC_PRAMIF_AHB_WRADDR_MSWr_SIZE BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE
typedef BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_t UC_PRAMIF_AHB_WRADDR_MSWr_t;
#define UC_PRAMIF_AHB_WRADDR_MSWr_CLR BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_MSWr_SET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_SET
#define UC_PRAMIF_AHB_WRADDR_MSWr_GET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_MADURA_READ_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_MADURA_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_MADURA_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_PRAMIF_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_PVT_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd210
 * DEVAD:    1
 * DESC:     pvt temperature status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_RMI temperature data{6'd0,tempearture_data[9:0]}reads the current value of the temperature data capatured
 */
#define BCMI_MADURA_UC_PVT_STS0r (0x0001d210 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_PVT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PVT_STS0.
 */
typedef union BCMI_MADURA_UC_PVT_STS0r_s {
	uint32_t v[1];
	uint32_t uc_pvt_sts0[1];
	uint32_t _uc_pvt_sts0;
} BCMI_MADURA_UC_PVT_STS0r_t;

#define BCMI_MADURA_UC_PVT_STS0r_CLR(r) (r).uc_pvt_sts0[0] = 0
#define BCMI_MADURA_UC_PVT_STS0r_SET(r,d) (r).uc_pvt_sts0[0] = d
#define BCMI_MADURA_UC_PVT_STS0r_GET(r) (r).uc_pvt_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET(r) (((r).uc_pvt_sts0[0]) & 0x3ff)
#define BCMI_MADURA_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET(r,f) (r).uc_pvt_sts0[0]=(((r).uc_pvt_sts0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_PVT_STS0.
 */
#define BCMI_MADURA_READ_UC_PVT_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_PVT_STS0r,_r._uc_pvt_sts0)
#define BCMI_MADURA_WRITE_UC_PVT_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_PVT_STS0r,_r._uc_pvt_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PVT_STS0r BCMI_MADURA_UC_PVT_STS0r
#define UC_PVT_STS0r_SIZE BCMI_MADURA_UC_PVT_STS0r_SIZE
typedef BCMI_MADURA_UC_PVT_STS0r_t UC_PVT_STS0r_t;
#define UC_PVT_STS0r_CLR BCMI_MADURA_UC_PVT_STS0r_CLR
#define UC_PVT_STS0r_SET BCMI_MADURA_UC_PVT_STS0r_SET
#define UC_PVT_STS0r_GET BCMI_MADURA_UC_PVT_STS0r_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET BCMI_MADURA_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET BCMI_MADURA_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET
#define READ_UC_PVT_STS0r BCMI_MADURA_READ_UC_PVT_STS0r
#define WRITE_UC_PVT_STS0r BCMI_MADURA_WRITE_UC_PVT_STS0r
#define MODIFY_UC_PVT_STS0r BCMI_MADURA_MODIFY_UC_PVT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_PVT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_TO_UC_MBOX0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd211
 * DEVAD:    1
 * DESC:     rmi to micro mailbox register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_TO_MICRO_MBOX0 There bits represents bits [15:0] of the message from rmi to microWrite to this registers can optionaly generate an interrupt to the micro
 */
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX0r (0x0001d211 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_TO_UC_MBOX0.
 */
typedef union BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_to_uc_mbox0[1];
	uint32_t _uc_rmi_to_uc_mbox0;
} BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_t;

#define BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_CLR(r) (r).uc_rmi_to_uc_mbox0[0] = 0
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_SET(r,d) (r).uc_rmi_to_uc_mbox0[0] = d
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_GET(r) (r).uc_rmi_to_uc_mbox0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET(r) (((r).uc_rmi_to_uc_mbox0[0]) & 0xffff)
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET(r,f) (r).uc_rmi_to_uc_mbox0[0]=(((r).uc_rmi_to_uc_mbox0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_TO_UC_MBOX0.
 */
#define BCMI_MADURA_READ_UC_RMI_TO_UC_MBOX0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_TO_UC_MBOX0r,_r._uc_rmi_to_uc_mbox0)
#define BCMI_MADURA_WRITE_UC_RMI_TO_UC_MBOX0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_TO_UC_MBOX0r,_r._uc_rmi_to_uc_mbox0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_TO_UC_MBOX0r BCMI_MADURA_UC_RMI_TO_UC_MBOX0r
#define UC_RMI_TO_UC_MBOX0r_SIZE BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_SIZE
typedef BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_t UC_RMI_TO_UC_MBOX0r_t;
#define UC_RMI_TO_UC_MBOX0r_CLR BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_CLR
#define UC_RMI_TO_UC_MBOX0r_SET BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_SET
#define UC_RMI_TO_UC_MBOX0r_GET BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_GET
#define UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET
#define UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET BCMI_MADURA_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET
#define READ_UC_RMI_TO_UC_MBOX0r BCMI_MADURA_READ_UC_RMI_TO_UC_MBOX0r
#define WRITE_UC_RMI_TO_UC_MBOX0r BCMI_MADURA_WRITE_UC_RMI_TO_UC_MBOX0r
#define MODIFY_UC_RMI_TO_UC_MBOX0r BCMI_MADURA_MODIFY_UC_RMI_TO_UC_MBOX0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_TO_UC_MBOX0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_TO_UC_MBOX1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd212
 * DEVAD:    1
 * DESC:     rmi to micro mailbox register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_TO_MICRO_MBOX1 There bits represents bits [31:16] of the message from rmi to micro
 */
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX1r (0x0001d212 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_TO_UC_MBOX1.
 */
typedef union BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_to_uc_mbox1[1];
	uint32_t _uc_rmi_to_uc_mbox1;
} BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_t;

#define BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_CLR(r) (r).uc_rmi_to_uc_mbox1[0] = 0
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_SET(r,d) (r).uc_rmi_to_uc_mbox1[0] = d
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_GET(r) (r).uc_rmi_to_uc_mbox1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET(r) (((r).uc_rmi_to_uc_mbox1[0]) & 0xffff)
#define BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET(r,f) (r).uc_rmi_to_uc_mbox1[0]=(((r).uc_rmi_to_uc_mbox1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_TO_UC_MBOX1.
 */
#define BCMI_MADURA_READ_UC_RMI_TO_UC_MBOX1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_TO_UC_MBOX1r,_r._uc_rmi_to_uc_mbox1)
#define BCMI_MADURA_WRITE_UC_RMI_TO_UC_MBOX1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_TO_UC_MBOX1r,_r._uc_rmi_to_uc_mbox1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_TO_UC_MBOX1r BCMI_MADURA_UC_RMI_TO_UC_MBOX1r
#define UC_RMI_TO_UC_MBOX1r_SIZE BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_SIZE
typedef BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_t UC_RMI_TO_UC_MBOX1r_t;
#define UC_RMI_TO_UC_MBOX1r_CLR BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_CLR
#define UC_RMI_TO_UC_MBOX1r_SET BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_SET
#define UC_RMI_TO_UC_MBOX1r_GET BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_GET
#define UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET
#define UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET BCMI_MADURA_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET
#define READ_UC_RMI_TO_UC_MBOX1r BCMI_MADURA_READ_UC_RMI_TO_UC_MBOX1r
#define WRITE_UC_RMI_TO_UC_MBOX1r BCMI_MADURA_WRITE_UC_RMI_TO_UC_MBOX1r
#define MODIFY_UC_RMI_TO_UC_MBOX1r BCMI_MADURA_MODIFY_UC_RMI_TO_UC_MBOX1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_TO_UC_MBOX1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_UC_TO_RMI_MBOX0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd213
 * DEVAD:    1
 * DESC:     micro to rmi mailbox register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_TO_RMI_MBOX0 There bits represents bits [15:0] of the message from rmi to micro
 */
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX0r (0x0001d213 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_TO_RMI_MBOX0.
 */
typedef union BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_s {
	uint32_t v[1];
	uint32_t uc_uc_to_rmi_mbox0[1];
	uint32_t _uc_uc_to_rmi_mbox0;
} BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_t;

#define BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_CLR(r) (r).uc_uc_to_rmi_mbox0[0] = 0
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_SET(r,d) (r).uc_uc_to_rmi_mbox0[0] = d
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_GET(r) (r).uc_uc_to_rmi_mbox0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET(r) (((r).uc_uc_to_rmi_mbox0[0]) & 0xffff)
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET(r,f) (r).uc_uc_to_rmi_mbox0[0]=(((r).uc_uc_to_rmi_mbox0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_TO_RMI_MBOX0.
 */
#define BCMI_MADURA_READ_UC_UC_TO_RMI_MBOX0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_UC_TO_RMI_MBOX0r,_r._uc_uc_to_rmi_mbox0)
#define BCMI_MADURA_WRITE_UC_UC_TO_RMI_MBOX0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_UC_TO_RMI_MBOX0r,_r._uc_uc_to_rmi_mbox0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_TO_RMI_MBOX0r BCMI_MADURA_UC_UC_TO_RMI_MBOX0r
#define UC_UC_TO_RMI_MBOX0r_SIZE BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_SIZE
typedef BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_t UC_UC_TO_RMI_MBOX0r_t;
#define UC_UC_TO_RMI_MBOX0r_CLR BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_CLR
#define UC_UC_TO_RMI_MBOX0r_SET BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_SET
#define UC_UC_TO_RMI_MBOX0r_GET BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_GET
#define UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET
#define UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET BCMI_MADURA_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET
#define READ_UC_UC_TO_RMI_MBOX0r BCMI_MADURA_READ_UC_UC_TO_RMI_MBOX0r
#define WRITE_UC_UC_TO_RMI_MBOX0r BCMI_MADURA_WRITE_UC_UC_TO_RMI_MBOX0r
#define MODIFY_UC_UC_TO_RMI_MBOX0r BCMI_MADURA_MODIFY_UC_UC_TO_RMI_MBOX0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_UC_TO_RMI_MBOX0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_UC_TO_RMI_MBOX1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd214
 * DEVAD:    1
 * DESC:     micro to rmi mailbox register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_TO_RMI_MBOX1 There bits represents bits [31:16] of the message from rmi to micro
 */
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX1r (0x0001d214 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_TO_RMI_MBOX1.
 */
typedef union BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_s {
	uint32_t v[1];
	uint32_t uc_uc_to_rmi_mbox1[1];
	uint32_t _uc_uc_to_rmi_mbox1;
} BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_t;

#define BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_CLR(r) (r).uc_uc_to_rmi_mbox1[0] = 0
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_SET(r,d) (r).uc_uc_to_rmi_mbox1[0] = d
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_GET(r) (r).uc_uc_to_rmi_mbox1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET(r) (((r).uc_uc_to_rmi_mbox1[0]) & 0xffff)
#define BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET(r,f) (r).uc_uc_to_rmi_mbox1[0]=(((r).uc_uc_to_rmi_mbox1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_TO_RMI_MBOX1.
 */
#define BCMI_MADURA_READ_UC_UC_TO_RMI_MBOX1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_UC_TO_RMI_MBOX1r,_r._uc_uc_to_rmi_mbox1)
#define BCMI_MADURA_WRITE_UC_UC_TO_RMI_MBOX1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_UC_TO_RMI_MBOX1r,_r._uc_uc_to_rmi_mbox1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_TO_RMI_MBOX1r BCMI_MADURA_UC_UC_TO_RMI_MBOX1r
#define UC_UC_TO_RMI_MBOX1r_SIZE BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_SIZE
typedef BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_t UC_UC_TO_RMI_MBOX1r_t;
#define UC_UC_TO_RMI_MBOX1r_CLR BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_CLR
#define UC_UC_TO_RMI_MBOX1r_SET BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_SET
#define UC_UC_TO_RMI_MBOX1r_GET BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_GET
#define UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET
#define UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET BCMI_MADURA_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET
#define READ_UC_UC_TO_RMI_MBOX1r BCMI_MADURA_READ_UC_UC_TO_RMI_MBOX1r
#define WRITE_UC_UC_TO_RMI_MBOX1r BCMI_MADURA_WRITE_UC_UC_TO_RMI_MBOX1r
#define MODIFY_UC_UC_TO_RMI_MBOX1r BCMI_MADURA_MODIFY_UC_UC_TO_RMI_MBOX1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_UC_TO_RMI_MBOX1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_MBOX_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd215
 * DEVAD:    1
 * DESC:     rmi mailbox control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_MBOX_SEND_MSGIN Send message in (to the micro)This field is set by the RMIC to indicate to the Micro that the message in thermi_to_micro_mbox1, and rmi_to_micro_mbox0 regiters is valid.
 *     MICRO_GEN_INTR_RMI_MBOX0WR Generate interrupt when micro_rmi_to_micro_mbox0 field is written0 - disabled1 - enbled
 *     MICRO_GEN_INTR_RMI_MBOX1WR Generate interrupt when micro_rmi_to_micro_mbox1 field is written0 - disabled1 - enbled
 */
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r (0x0001d215 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_MBOX_CTL0.
 */
typedef union BCMI_MADURA_UC_RMI_MBOX_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_mbox_ctl0[1];
	uint32_t _uc_rmi_mbox_ctl0;
} BCMI_MADURA_UC_RMI_MBOX_CTL0r_t;

#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_CLR(r) (r).uc_rmi_mbox_ctl0[0] = 0
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_SET(r,d) (r).uc_rmi_mbox_ctl0[0] = d
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_GET(r) (r).uc_rmi_mbox_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET(r) ((((r).uc_rmi_mbox_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET(r) ((((r).uc_rmi_mbox_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET(r) (((r).uc_rmi_mbox_ctl0[0]) & 0x1)
#define BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_MBOX_CTL0.
 */
#define BCMI_MADURA_READ_UC_RMI_MBOX_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_MBOX_CTL0r,_r._uc_rmi_mbox_ctl0)
#define BCMI_MADURA_WRITE_UC_RMI_MBOX_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_MBOX_CTL0r,_r._uc_rmi_mbox_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_MBOX_CTL0r BCMI_MADURA_UC_RMI_MBOX_CTL0r
#define UC_RMI_MBOX_CTL0r_SIZE BCMI_MADURA_UC_RMI_MBOX_CTL0r_SIZE
typedef BCMI_MADURA_UC_RMI_MBOX_CTL0r_t UC_RMI_MBOX_CTL0r_t;
#define UC_RMI_MBOX_CTL0r_CLR BCMI_MADURA_UC_RMI_MBOX_CTL0r_CLR
#define UC_RMI_MBOX_CTL0r_SET BCMI_MADURA_UC_RMI_MBOX_CTL0r_SET
#define UC_RMI_MBOX_CTL0r_GET BCMI_MADURA_UC_RMI_MBOX_CTL0r_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET
#define UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET BCMI_MADURA_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET
#define READ_UC_RMI_MBOX_CTL0r BCMI_MADURA_READ_UC_RMI_MBOX_CTL0r
#define WRITE_UC_RMI_MBOX_CTL0r BCMI_MADURA_WRITE_UC_RMI_MBOX_CTL0r
#define MODIFY_UC_RMI_MBOX_CTL0r BCMI_MADURA_MODIFY_UC_RMI_MBOX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_MBOX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_AHB_CTL1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd216
 * DEVAD:    1
 * DESC:     ahb control register 1
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_M0_HRESP_EN m0 response error signaling enable0 - disabled1 - enabled
 *     MICRO_SW_PMI_HP_RSTB Software reset pmi_hp interface logicThis bit is to initialize the pmi_hp block0 - reset asserted1 - reset de-asserted
 *     MICRO_SW_PMI_HP_EXT_RSTB Software reset pmi_hp_ext interface logicThis bit is to initialize the pmi_hp_ext block0 - reset asserted1 - reset de-asserted
 *     MICRO_PMI_HP_ACK_TIMEOUT_DIS pmi_hp_ack_* timeout disableWhen micro initates a read/write transctions on the pmi_hp busit allows upto 256 clock cycles for pmi_hp_ack_mc/pmi_hp_ack_uc to be assertedIf pmi_hp_ack_* is not received within this time, then it1. terminates the current transactions on the pmi_hp bus2. set the pmi_hp_ack_timeout_status field of the ahbcommon_pmi_hp_status0 register.3. performs the response error signaling on the micro AHB bus when micro_m0_hresp_en field is set to 1'b1This timeout period/error reporting/reponse error signaling can be disabled by setting this field i.e.0: enabled1: disabled
 *     MICRO_PMI_HP_EXT_ACK_TIMEOUT_DIS pmi_hp_ext_ack_* timeout disableWhen micro initates a read/write transctions on the pmi_hp_ext busit allows upto 256 clock cycles for pmi_hp_ext_ack_mc/pmi_hp_ext_ack_uc to be assertedIf pmi_hp_ext_ack_* is not received within this time, then it1. terminates the current transactions on the pmi_hp_ext bus2. set the pmi_hp_ext_ack_timeout_status field of the ahbcommon_pmi_hp_status0 register.3. performs the response error signaling on the micro AHB bus if micro_m0_hresp_en field is set to 1'b1This timeout period/error reporting/reponse error signaling can be disabled by setting this field i.e.0: enabled1: disabled
 */
#define BCMI_MADURA_UC_RMI_AHB_CTL1r (0x0001d216 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_AHB_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_CTL1.
 */
typedef union BCMI_MADURA_UC_RMI_AHB_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_ctl1[1];
	uint32_t _uc_rmi_ahb_ctl1;
} BCMI_MADURA_UC_RMI_AHB_CTL1r_t;

#define BCMI_MADURA_UC_RMI_AHB_CTL1r_CLR(r) (r).uc_rmi_ahb_ctl1[0] = 0
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_SET(r,d) (r).uc_rmi_ahb_ctl1[0] = d
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_GET(r) (r).uc_rmi_ahb_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 4) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 3) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 2) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET(r) (((r).uc_rmi_ahb_ctl1[0]) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_CTL1.
 */
#define BCMI_MADURA_READ_UC_RMI_AHB_CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_AHB_CTL1r,_r._uc_rmi_ahb_ctl1)
#define BCMI_MADURA_WRITE_UC_RMI_AHB_CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_AHB_CTL1r,_r._uc_rmi_ahb_ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_CTL1r BCMI_MADURA_UC_RMI_AHB_CTL1r
#define UC_RMI_AHB_CTL1r_SIZE BCMI_MADURA_UC_RMI_AHB_CTL1r_SIZE
typedef BCMI_MADURA_UC_RMI_AHB_CTL1r_t UC_RMI_AHB_CTL1r_t;
#define UC_RMI_AHB_CTL1r_CLR BCMI_MADURA_UC_RMI_AHB_CTL1r_CLR
#define UC_RMI_AHB_CTL1r_SET BCMI_MADURA_UC_RMI_AHB_CTL1r_SET
#define UC_RMI_AHB_CTL1r_GET BCMI_MADURA_UC_RMI_AHB_CTL1r_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_GET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_SET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_EXT_ACK_TIMEOUT_DISf_SET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET
#define UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET
#define UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET BCMI_MADURA_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET
#define READ_UC_RMI_AHB_CTL1r BCMI_MADURA_READ_UC_RMI_AHB_CTL1r
#define WRITE_UC_RMI_AHB_CTL1r BCMI_MADURA_WRITE_UC_RMI_AHB_CTL1r
#define MODIFY_UC_RMI_AHB_CTL1r BCMI_MADURA_MODIFY_UC_RMI_AHB_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_AHB_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_AHB_STS1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd217
 * DEVAD:    1
 * DESC:     ahb status register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_M0_DEFAULT_SLAVE_ERROR m0 default slave error detected. M0 attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_RMI_DEFAULT_SLAVE_ERROR register interface default slave error detected. Register interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_PR_DEFAULT_SLAVE_ERROR PRAM interface default slave error detected. PRAM interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 */
#define BCMI_MADURA_UC_RMI_AHB_STS1r (0x0001d217 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_AHB_STS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_STS1.
 */
typedef union BCMI_MADURA_UC_RMI_AHB_STS1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_sts1[1];
	uint32_t _uc_rmi_ahb_sts1;
} BCMI_MADURA_UC_RMI_AHB_STS1r_t;

#define BCMI_MADURA_UC_RMI_AHB_STS1r_CLR(r) (r).uc_rmi_ahb_sts1[0] = 0
#define BCMI_MADURA_UC_RMI_AHB_STS1r_SET(r,d) (r).uc_rmi_ahb_sts1[0] = d
#define BCMI_MADURA_UC_RMI_AHB_STS1r_GET(r) (r).uc_rmi_ahb_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 2) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET(r) (((r).uc_rmi_ahb_sts1[0]) & 0x1)
#define BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_STS1.
 */
#define BCMI_MADURA_READ_UC_RMI_AHB_STS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_AHB_STS1r,_r._uc_rmi_ahb_sts1)
#define BCMI_MADURA_WRITE_UC_RMI_AHB_STS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_AHB_STS1r,_r._uc_rmi_ahb_sts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_STS1r BCMI_MADURA_UC_RMI_AHB_STS1r
#define UC_RMI_AHB_STS1r_SIZE BCMI_MADURA_UC_RMI_AHB_STS1r_SIZE
typedef BCMI_MADURA_UC_RMI_AHB_STS1r_t UC_RMI_AHB_STS1r_t;
#define UC_RMI_AHB_STS1r_CLR BCMI_MADURA_UC_RMI_AHB_STS1r_CLR
#define UC_RMI_AHB_STS1r_SET BCMI_MADURA_UC_RMI_AHB_STS1r_SET
#define UC_RMI_AHB_STS1r_GET BCMI_MADURA_UC_RMI_AHB_STS1r_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET BCMI_MADURA_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET
#define READ_UC_RMI_AHB_STS1r BCMI_MADURA_READ_UC_RMI_AHB_STS1r
#define WRITE_UC_RMI_AHB_STS1r BCMI_MADURA_WRITE_UC_RMI_AHB_STS1r
#define MODIFY_UC_RMI_AHB_STS1r BCMI_MADURA_MODIFY_UC_RMI_AHB_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_AHB_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_RA_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd218
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_WRADDR_LSW When the micro_autoinc_wraddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr (0x0001d218 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_wraddr_lsw;
} BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_MADURA_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,_r._uc_rmi_ra_ainc_nxt_wraddr_lsw)
#define BCMI_MADURA_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,_r._uc_rmi_ra_ainc_nxt_wraddr_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_MADURA_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_MADURA_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_MADURA_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_RA_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_RA_AINC_NXT_RDADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd219
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_RDADDR_LSW When the micro_autoinc_rdaddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next read transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr (0x0001d219 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
typedef union BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_rdaddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_rdaddr_lsw;
} BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;

#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = 0
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = d
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]) & 0xffff)
#define BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
#define BCMI_MADURA_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw)
#define BCMI_MADURA_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE
typedef BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_MADURA_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_MADURA_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_MADURA_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_RA_AINC_NXT_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_PR_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21a
 * DEVAD:    1
 * DESC:     pram i/f to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PR_AUTOINC_NXT_WRADDR_LSW When pram interface is used to write to the code/data RAMthen these bits indicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking
 */
#define BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr (0x0001d21a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_pr_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_pr_ainc_nxt_wraddr_lsw;
} BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_MADURA_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,_r._uc_rmi_pr_ainc_nxt_wraddr_lsw)
#define BCMI_MADURA_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,_r._uc_rmi_pr_ainc_nxt_wraddr_lsw)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_MADURA_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_MADURA_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_MADURA_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_PR_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_PVT_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21b
 * DEVAD:    1
 * DESC:     rmi pvt temperature control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_FRCVAL temperature data force valueWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 *     MICRO_PVT_TEMPDATA_FRC temperature dat force enableWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 */
#define BCMI_MADURA_UC_RMI_PVT_CTL0r (0x0001d21b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_PVT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PVT_CTL0.
 */
typedef union BCMI_MADURA_UC_RMI_PVT_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pvt_ctl0[1];
	uint32_t _uc_rmi_pvt_ctl0;
} BCMI_MADURA_UC_RMI_PVT_CTL0r_t;

#define BCMI_MADURA_UC_RMI_PVT_CTL0r_CLR(r) (r).uc_rmi_pvt_ctl0[0] = 0
#define BCMI_MADURA_UC_RMI_PVT_CTL0r_SET(r,d) (r).uc_rmi_pvt_ctl0[0] = d
#define BCMI_MADURA_UC_RMI_PVT_CTL0r_GET(r) (r).uc_rmi_pvt_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET(r) ((((r).uc_rmi_pvt_ctl0[0]) >> 12) & 0x1)
#define BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET(r) (((r).uc_rmi_pvt_ctl0[0]) & 0x3ff)
#define BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_RMI_PVT_CTL0.
 */
#define BCMI_MADURA_READ_UC_RMI_PVT_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_PVT_CTL0r,_r._uc_rmi_pvt_ctl0)
#define BCMI_MADURA_WRITE_UC_RMI_PVT_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_PVT_CTL0r,_r._uc_rmi_pvt_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PVT_CTL0r BCMI_MADURA_UC_RMI_PVT_CTL0r
#define UC_RMI_PVT_CTL0r_SIZE BCMI_MADURA_UC_RMI_PVT_CTL0r_SIZE
typedef BCMI_MADURA_UC_RMI_PVT_CTL0r_t UC_RMI_PVT_CTL0r_t;
#define UC_RMI_PVT_CTL0r_CLR BCMI_MADURA_UC_RMI_PVT_CTL0r_CLR
#define UC_RMI_PVT_CTL0r_SET BCMI_MADURA_UC_RMI_PVT_CTL0r_SET
#define UC_RMI_PVT_CTL0r_GET BCMI_MADURA_UC_RMI_PVT_CTL0r_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET BCMI_MADURA_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET
#define READ_UC_RMI_PVT_CTL0r BCMI_MADURA_READ_UC_RMI_PVT_CTL0r
#define WRITE_UC_RMI_PVT_CTL0r BCMI_MADURA_WRITE_UC_RMI_PVT_CTL0r
#define MODIFY_UC_RMI_PVT_CTL0r BCMI_MADURA_MODIFY_UC_RMI_PVT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_PVT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_CODE_RAM_ECCCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd220
 * DEVAD:    1
 * DESC:     code ram ecc control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_ECCG_MODE  ecc code generation mode0: Hardware mode - ECC code generated by hardware, ECC error checking enabled1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAMECC error checking disabled. This mode is only supportedwhen register interface is used
 *     MICRO_ECC_FRC_DISABLE ecc force disable0: ECC Enabled  - ECC error code generation determine by the micro_eccg_mode fieldECC error checking enabled in hardware mode only1: ECC Disabled - ECC error codes values written into the RAM set to zeroECC error checking disabled
 *     MICRO_ECC_CORRUPT This field allows the ecc codes to be corrupted for testing.2'b00 - normal mode2'b01 - corrupt the ECC code written into the code/data RAM2'b10 - corrupt data - add 1 bit data error on the RX side2'b11 - corrupt data - add 2 bit data error on the RA side
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r (0x0001d220 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCCTL0.
 */
typedef union BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccctl0[1];
	uint32_t _uc_code_ram_eccctl0;
} BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_t;

#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_CLR(r) (r).uc_code_ram_eccctl0[0] = 0
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_SET(r,d) (r).uc_code_ram_eccctl0[0] = d
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_GET(r) (r).uc_code_ram_eccctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET(r) ((((r).uc_code_ram_eccctl0[0]) >> 4) & 0x3)
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET(r) ((((r).uc_code_ram_eccctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET(r) (((r).uc_code_ram_eccctl0[0]) & 0x1)
#define BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCCTL0.
 */
#define BCMI_MADURA_READ_UC_CODE_RAM_ECCCTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_CODE_RAM_ECCCTL0r,_r._uc_code_ram_eccctl0)
#define BCMI_MADURA_WRITE_UC_CODE_RAM_ECCCTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_CODE_RAM_ECCCTL0r,_r._uc_code_ram_eccctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCCTL0r BCMI_MADURA_UC_CODE_RAM_ECCCTL0r
#define UC_CODE_RAM_ECCCTL0r_SIZE BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_SIZE
typedef BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_t UC_CODE_RAM_ECCCTL0r_t;
#define UC_CODE_RAM_ECCCTL0r_CLR BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_CLR
#define UC_CODE_RAM_ECCCTL0r_SET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_SET
#define UC_CODE_RAM_ECCCTL0r_GET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET BCMI_MADURA_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET
#define READ_UC_CODE_RAM_ECCCTL0r BCMI_MADURA_READ_UC_CODE_RAM_ECCCTL0r
#define WRITE_UC_CODE_RAM_ECCCTL0r BCMI_MADURA_WRITE_UC_CODE_RAM_ECCCTL0r
#define MODIFY_UC_CODE_RAM_ECCCTL0r BCMI_MADURA_MODIFY_UC_CODE_RAM_ECCCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_CODE_RAM_ECCCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_CODE_RAM_ECCCONTRO1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd221
 * DEVAD:    1
 * DESC:     code ram ecc control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_ECC_WRDATA This foield is used to write the ECC codes into the code/data when ECC software modes is enabled
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r (0x0001d221 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCCONTRO1.
 */
typedef union BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_ecccontro1[1];
	uint32_t _uc_code_ram_ecccontro1;
} BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_t;

#define BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_CLR(r) (r).uc_code_ram_ecccontro1[0] = 0
#define BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_SET(r,d) (r).uc_code_ram_ecccontro1[0] = d
#define BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_GET(r) (r).uc_code_ram_ecccontro1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET(r) (((r).uc_code_ram_ecccontro1[0]) & 0x7f)
#define BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET(r,f) (r).uc_code_ram_ecccontro1[0]=(((r).uc_code_ram_ecccontro1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCCONTRO1.
 */
#define BCMI_MADURA_READ_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r,_r._uc_code_ram_ecccontro1)
#define BCMI_MADURA_WRITE_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r,_r._uc_code_ram_ecccontro1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCCONTRO1r BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r
#define UC_CODE_RAM_ECCCONTRO1r_SIZE BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_SIZE
typedef BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_t UC_CODE_RAM_ECCCONTRO1r_t;
#define UC_CODE_RAM_ECCCONTRO1r_CLR BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_CLR
#define UC_CODE_RAM_ECCCONTRO1r_SET BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_SET
#define UC_CODE_RAM_ECCCONTRO1r_GET BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_GET
#define UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET
#define UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET
#define READ_UC_CODE_RAM_ECCCONTRO1r BCMI_MADURA_READ_UC_CODE_RAM_ECCCONTRO1r
#define WRITE_UC_CODE_RAM_ECCCONTRO1r BCMI_MADURA_WRITE_UC_CODE_RAM_ECCCONTRO1r
#define MODIFY_UC_CODE_RAM_ECCCONTRO1r BCMI_MADURA_MODIFY_UC_CODE_RAM_ECCCONTRO1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_CODE_RAM_ECCCONTRO1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_CODE_RAM_ECCSTS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd222
 * DEVAD:    1
 * DESC:     code ram ecc status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_CODE_RAM_ECC_ADDRESS First ecc error address
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS0r (0x0001d222 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCSTS0.
 */
typedef union BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccsts0[1];
	uint32_t _uc_code_ram_eccsts0;
} BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_t;

#define BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_CLR(r) (r).uc_code_ram_eccsts0[0] = 0
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_SET(r,d) (r).uc_code_ram_eccsts0[0] = d
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_GET(r) (r).uc_code_ram_eccsts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET(r) (((r).uc_code_ram_eccsts0[0]) & 0x7fff)
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET(r,f) (r).uc_code_ram_eccsts0[0]=(((r).uc_code_ram_eccsts0[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCSTS0.
 */
#define BCMI_MADURA_READ_UC_CODE_RAM_ECCSTS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_CODE_RAM_ECCSTS0r,_r._uc_code_ram_eccsts0)
#define BCMI_MADURA_WRITE_UC_CODE_RAM_ECCSTS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_CODE_RAM_ECCSTS0r,_r._uc_code_ram_eccsts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCSTS0r BCMI_MADURA_UC_CODE_RAM_ECCSTS0r
#define UC_CODE_RAM_ECCSTS0r_SIZE BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_SIZE
typedef BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_t UC_CODE_RAM_ECCSTS0r_t;
#define UC_CODE_RAM_ECCSTS0r_CLR BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_CLR
#define UC_CODE_RAM_ECCSTS0r_SET BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_SET
#define UC_CODE_RAM_ECCSTS0r_GET BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_GET
#define UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET
#define UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET BCMI_MADURA_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET
#define READ_UC_CODE_RAM_ECCSTS0r BCMI_MADURA_READ_UC_CODE_RAM_ECCSTS0r
#define WRITE_UC_CODE_RAM_ECCSTS0r BCMI_MADURA_WRITE_UC_CODE_RAM_ECCSTS0r
#define MODIFY_UC_CODE_RAM_ECCSTS0r BCMI_MADURA_MODIFY_UC_CODE_RAM_ECCSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_CODE_RAM_ECCSTS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_CODE_RAM_ECCSTS1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd223
 * DEVAD:    1
 * DESC:     code ram ecc status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_ECC_RDDATA When the register interface is used to read code/data RAM, then this field can be usedread the ECC codes currently stored in the code/data RAM
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS1r (0x0001d223 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCSTS1.
 */
typedef union BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccsts1[1];
	uint32_t _uc_code_ram_eccsts1;
} BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_t;

#define BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_CLR(r) (r).uc_code_ram_eccsts1[0] = 0
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_SET(r,d) (r).uc_code_ram_eccsts1[0] = d
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_GET(r) (r).uc_code_ram_eccsts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET(r) (((r).uc_code_ram_eccsts1[0]) & 0x7f)
#define BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET(r,f) (r).uc_code_ram_eccsts1[0]=(((r).uc_code_ram_eccsts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCSTS1.
 */
#define BCMI_MADURA_READ_UC_CODE_RAM_ECCSTS1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_CODE_RAM_ECCSTS1r,_r._uc_code_ram_eccsts1)
#define BCMI_MADURA_WRITE_UC_CODE_RAM_ECCSTS1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_CODE_RAM_ECCSTS1r,_r._uc_code_ram_eccsts1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCSTS1r BCMI_MADURA_UC_CODE_RAM_ECCSTS1r
#define UC_CODE_RAM_ECCSTS1r_SIZE BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_SIZE
typedef BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_t UC_CODE_RAM_ECCSTS1r_t;
#define UC_CODE_RAM_ECCSTS1r_CLR BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_CLR
#define UC_CODE_RAM_ECCSTS1r_SET BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_SET
#define UC_CODE_RAM_ECCSTS1r_GET BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_GET
#define UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET
#define UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET BCMI_MADURA_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET
#define READ_UC_CODE_RAM_ECCSTS1r BCMI_MADURA_READ_UC_CODE_RAM_ECCSTS1r
#define WRITE_UC_CODE_RAM_ECCSTS1r BCMI_MADURA_WRITE_UC_CODE_RAM_ECCSTS1r
#define MODIFY_UC_CODE_RAM_ECCSTS1r BCMI_MADURA_MODIFY_UC_CODE_RAM_ECCSTS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_CODE_RAM_ECCSTS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_CODE_RAM_TESTIFCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd224
 * DEVAD:    1
 * DESC:     code ram test interface control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CODE_RAM_TM Test Mode.These pins are used to put the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<?:0>='d0. It ishighly recommended that the user has control over all thetm<?:0> inputs. All tm<?:0> inputs are asynchronous. Seethe Test Modes section of the on line M16SP WebSpecification for further details.
 */
#define BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r (0x0001d224 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_TESTIFCTL0.
 */
typedef union BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_testifctl0[1];
	uint32_t _uc_code_ram_testifctl0;
} BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_t;

#define BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_CLR(r) (r).uc_code_ram_testifctl0[0] = 0
#define BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_SET(r,d) (r).uc_code_ram_testifctl0[0] = d
#define BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_GET(r) (r).uc_code_ram_testifctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET(r) (((r).uc_code_ram_testifctl0[0]) & 0x7f)
#define BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET(r,f) (r).uc_code_ram_testifctl0[0]=(((r).uc_code_ram_testifctl0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_TESTIFCTL0.
 */
#define BCMI_MADURA_READ_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r,_r._uc_code_ram_testifctl0)
#define BCMI_MADURA_WRITE_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r,_r._uc_code_ram_testifctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_TESTIFCTL0r BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r
#define UC_CODE_RAM_TESTIFCTL0r_SIZE BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_SIZE
typedef BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_t UC_CODE_RAM_TESTIFCTL0r_t;
#define UC_CODE_RAM_TESTIFCTL0r_CLR BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_CLR
#define UC_CODE_RAM_TESTIFCTL0r_SET BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_SET
#define UC_CODE_RAM_TESTIFCTL0r_GET BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_GET
#define UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET
#define UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET
#define READ_UC_CODE_RAM_TESTIFCTL0r BCMI_MADURA_READ_UC_CODE_RAM_TESTIFCTL0r
#define WRITE_UC_CODE_RAM_TESTIFCTL0r BCMI_MADURA_WRITE_UC_CODE_RAM_TESTIFCTL0r
#define MODIFY_UC_CODE_RAM_TESTIFCTL0r BCMI_MADURA_MODIFY_UC_CODE_RAM_TESTIFCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_CODE_RAM_TESTIFCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RAM_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd225
 * DEVAD:    1
 * DESC:     ram configuration register 0
 * RESETVAL: 0x8801 (34817)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_DR_LOOKTAB_EN Data RAM lookup table enable1 - Data RAM mapped in the data region by hardwarestarting at address 0x2000_0000 (for software compatibilty)0 - Data RAM not mapped by hardwareFirmware defines code/data regiions
 *     MICRO_PROTECT_FWCODE protect firmware code during micro master reset1 - RAM address, data, chip select and write enable are set to inactive stateto prevent timing violations from corrupting the contents of the RAMIf this field is used then the software has to clear this filed before re-starting the micro0 - RAM address, data, chip select and write enable are set to inactive stateby using micro_master_rstb register field to prevent timing violations from corrupting the contents of the RAM
 *     MICRO_DR_SIZE    Data/Code RAM allocation when the micro_dr_looktab_en field is set to 1'b1The RAM_SIZE=48KB and this field can be used to allocate data/code RAM on a 1KB granualarity6'd0  : Data RAM = 0KB,  Code RAM = RAM_SIZE - Data RAM6'd1  : Data RAM = 1KB,  Code RAM = RAM_SIZE - Data RAM6'd2  : Data RAM = 2KB,  Code RAM = RAM_SIZE - Data RAM...   : Data RAM = .. ,  Code RAM = .....   : Data RAM = .. ,  Code RAM = ..6'd47 : Data RAM = 47KB, Code RAM = RAM_SIZE - Data RAM6'd48 : Data RAM = 48KB, Code RAM = RAM_SIZE - Data RAMPLEASE NOTE: the micro in the PMD core does not have any additional RAM to store Code/Datatherfore a value of 0 and RAM_SIZE=48KB should not be used
 *     MICRO_RAMCLK_NONINV Code/Data RAM clock non-inverted0 - inverted1 - non-invertedWhen non-inverted clock to RAM is used, then a wait state to be inserted during read access.However, it eliminates the use of both edges of the clock (duty cycle) and makes the timing closer easier
 *     MICRO_IGNORE_M0_CODE_WRITES Ignore Micro writes to the code portion of the RAM0 - Allow writes1 - Ignore writes
 */
#define BCMI_MADURA_UC_RAM_CTL0r (0x0001d225 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RAM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL0.
 */
typedef union BCMI_MADURA_UC_RAM_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl0[1];
	uint32_t _uc_ram_ctl0;
} BCMI_MADURA_UC_RAM_CTL0r_t;

#define BCMI_MADURA_UC_RAM_CTL0r_CLR(r) (r).uc_ram_ctl0[0] = 0
#define BCMI_MADURA_UC_RAM_CTL0r_SET(r,d) (r).uc_ram_ctl0[0] = d
#define BCMI_MADURA_UC_RAM_CTL0r_GET(r) (r).uc_ram_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_GET(r) ((((r).uc_ram_ctl0[0]) >> 15) & 0x1)
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_GET(r) ((((r).uc_ram_ctl0[0]) >> 14) & 0x1)
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_SIZEf_GET(r) ((((r).uc_ram_ctl0[0]) >> 8) & 0x3f)
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_SIZEf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_GET(r) ((((r).uc_ram_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET(r) (((r).uc_ram_ctl0[0]) & 0x1)
#define BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RAM_CTL0.
 */
#define BCMI_MADURA_READ_UC_RAM_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RAM_CTL0r,_r._uc_ram_ctl0)
#define BCMI_MADURA_WRITE_UC_RAM_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RAM_CTL0r,_r._uc_ram_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL0r BCMI_MADURA_UC_RAM_CTL0r
#define UC_RAM_CTL0r_SIZE BCMI_MADURA_UC_RAM_CTL0r_SIZE
typedef BCMI_MADURA_UC_RAM_CTL0r_t UC_RAM_CTL0r_t;
#define UC_RAM_CTL0r_CLR BCMI_MADURA_UC_RAM_CTL0r_CLR
#define UC_RAM_CTL0r_SET BCMI_MADURA_UC_RAM_CTL0r_SET
#define UC_RAM_CTL0r_GET BCMI_MADURA_UC_RAM_CTL0r_GET
#define UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_GET BCMI_MADURA_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_GET
#define UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_SET BCMI_MADURA_UC_RAM_CTL0r_MICRO_IGNORE_M0_CODE_WRITESf_SET
#define UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_GET BCMI_MADURA_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_GET
#define UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_SET BCMI_MADURA_UC_RAM_CTL0r_MICRO_RAMCLK_NONINVf_SET
#define UC_RAM_CTL0r_MICRO_DR_SIZEf_GET BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_SIZEf_GET
#define UC_RAM_CTL0r_MICRO_DR_SIZEf_SET BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_SIZEf_SET
#define UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_GET BCMI_MADURA_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_GET
#define UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_SET BCMI_MADURA_UC_RAM_CTL0r_MICRO_PROTECT_FWCODEf_SET
#define UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET
#define UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET BCMI_MADURA_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET
#define READ_UC_RAM_CTL0r BCMI_MADURA_READ_UC_RAM_CTL0r
#define WRITE_UC_RAM_CTL0r BCMI_MADURA_WRITE_UC_RAM_CTL0r
#define MODIFY_UC_RAM_CTL0r BCMI_MADURA_MODIFY_UC_RAM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RAM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_EXT_INTR_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd226
 * DEVAD:    1
 * DESC:     rmi external interrupt control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_MBOX_MSGOUT_INTR_EN Message out (from Micro) interrupt enableWhen this field is set to 1'b1 then the micro_rmi_mbox_msgout_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_CORR_ERR_INTR_EN ECC 1 bit correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_UNCORR_ERR_INTR_EN ECC 2 bit un-correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_MULTIROW_ERR_INTR_EN ECC error on multiple row detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0_LOCKUP_INTR_EN M0 lockup interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_lockup_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0_SYSTEMRESETREQ_INTR_EN M0 systemresetreq interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_systemresetreq_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 */
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r (0x0001d226 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_CTL0.
 */
typedef union BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_ctl0[1];
	uint32_t _uc_rmi_ext_intr_ctl0;
} BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_t;

#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_CLR(r) (r).uc_rmi_ext_intr_ctl0[0] = 0
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_SET(r,d) (r).uc_rmi_ext_intr_ctl0[0] = d
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_GET(r) (r).uc_rmi_ext_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 6) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 5) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 4) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET(r) (((r).uc_rmi_ext_intr_ctl0[0]) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_CTL0.
 */
#define BCMI_MADURA_READ_UC_RMI_EXT_INTR_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r,_r._uc_rmi_ext_intr_ctl0)
#define BCMI_MADURA_WRITE_UC_RMI_EXT_INTR_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r,_r._uc_rmi_ext_intr_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_CTL0r BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r
#define UC_RMI_EXT_INTR_CTL0r_SIZE BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_SIZE
typedef BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_t UC_RMI_EXT_INTR_CTL0r_t;
#define UC_RMI_EXT_INTR_CTL0r_CLR BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_CLR
#define UC_RMI_EXT_INTR_CTL0r_SET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_SET
#define UC_RMI_EXT_INTR_CTL0r_GET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET
#define READ_UC_RMI_EXT_INTR_CTL0r BCMI_MADURA_READ_UC_RMI_EXT_INTR_CTL0r
#define WRITE_UC_RMI_EXT_INTR_CTL0r BCMI_MADURA_WRITE_UC_RMI_EXT_INTR_CTL0r
#define MODIFY_UC_RMI_EXT_INTR_CTL0r BCMI_MADURA_MODIFY_UC_RMI_EXT_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_EXT_INTR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_EXT_INTR_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd227
 * DEVAD:    1
 * DESC:     rmi external interrupt status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_MBOX_MSGOUT_STATUS Message out (from Micro) statusThis field is set to 1'b1 when the RMIC receives a message from the Micro.It indicates to the RMIC that the message on the micro_to_rmi_mbox3,micro_to_rmi_mbox2, micro_to_rmi_mbox1 and micro_to_rmi_mbox0 registers is validThis bits remain remains set until this register is read
 *     MICRO_RMI_ECC_CORR_ERR_STATUS ECC 1 bit correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_ECC_UNCORR_ERR_STATUS ECC 2 bit un-correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit un-correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_ECC_MULTIROW_ERR_STATUS ECC error on multiple row detected  statusThis field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows.This bits remain remains set until this register is read
 *     MICRO_RMI_M0_LOCKUP_STATUS M0 lockup statusThis field indicates the status of the M0 "lockup" signal
 *     MICRO_RMI_M0_SYSTEMRESETREQ_STATUS M0 systemresetreq statusThis field indicates the status of the M0 "systemresetreq" signal
 */
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r (0x0001d227 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_STS0.
 */
typedef union BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_sts0[1];
	uint32_t _uc_rmi_ext_intr_sts0;
} BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_t;

#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_CLR(r) (r).uc_rmi_ext_intr_sts0[0] = 0
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_SET(r,d) (r).uc_rmi_ext_intr_sts0[0] = d
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_GET(r) (r).uc_rmi_ext_intr_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 9) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 8) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 6) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 5) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 4) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET(r) (((r).uc_rmi_ext_intr_sts0[0]) & 0x1)
#define BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_STS0.
 */
#define BCMI_MADURA_READ_UC_RMI_EXT_INTR_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_EXT_INTR_STS0r,_r._uc_rmi_ext_intr_sts0)
#define BCMI_MADURA_WRITE_UC_RMI_EXT_INTR_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_EXT_INTR_STS0r,_r._uc_rmi_ext_intr_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_STS0r BCMI_MADURA_UC_RMI_EXT_INTR_STS0r
#define UC_RMI_EXT_INTR_STS0r_SIZE BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_SIZE
typedef BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_t UC_RMI_EXT_INTR_STS0r_t;
#define UC_RMI_EXT_INTR_STS0r_CLR BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_CLR
#define UC_RMI_EXT_INTR_STS0r_SET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_SET
#define UC_RMI_EXT_INTR_STS0r_GET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET BCMI_MADURA_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET
#define READ_UC_RMI_EXT_INTR_STS0r BCMI_MADURA_READ_UC_RMI_EXT_INTR_STS0r
#define WRITE_UC_RMI_EXT_INTR_STS0r BCMI_MADURA_WRITE_UC_RMI_EXT_INTR_STS0r
#define MODIFY_UC_RMI_EXT_INTR_STS0r BCMI_MADURA_MODIFY_UC_RMI_EXT_INTR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_EXT_INTR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_PMI_IF_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd228
 * DEVAD:    1
 * DESC:     pmi interface control register 0
 * RESETVAL: 0x101 (257)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_FAST_READ_EN pmi hp interface fast read enable1 - use pmi_hp_read_vld during read0 - use pmi_hp_ack during read
 *     MICRO_PMI_HP_FAST_DUAL_META_FF_EN pmi hp interface fast dual meta flops enable1 - use both the rising and falling edges of the clock for dual meta flops0 - use only the rising edges of the clock for dual meta flops
 *     MICRO_PMI_HP_FAST_BKTOBK_EN pmi hp interface fast back to back enable1 - skip over some of the states in the fsm during back to back transition0 - state transitions as in f28
 *     MICRO_PMI_HP_EXT_FAST_READ_EN pmi hp ext interface fast read enable1 - use pmi_hp_ext_read_vld during read0 - use pmi_hp_ext_ack during read
 *     MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_EN pmi_hp_ext interface fast dual meta flops enable1 - use both the rising and falling edges of the clock for dual meta flops0 - use only the rising edges of the clock for dual meta flops
 *     MICRO_PMI_HP_EXT_FAST_BKTOBK_EN pmi_hp_ext interface fast back to back enable1 - skip over some of the states in the fsm during back to back transition0 - state transitions as in f28
 */
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r (0x0001d228 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PMI_IF_CTL0.
 */
typedef union BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pmi_if_ctl0[1];
	uint32_t _uc_rmi_pmi_if_ctl0;
} BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_t;

#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_CLR(r) (r).uc_rmi_pmi_if_ctl0[0] = 0
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_SET(r,d) (r).uc_rmi_pmi_if_ctl0[0] = d
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_GET(r) (r).uc_rmi_pmi_if_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 10) & 0x1)
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 9) & 0x1)
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 8) & 0x1)
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 2) & 0x1)
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 1) & 0x1)
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET(r) (((r).uc_rmi_pmi_if_ctl0[0]) & 0x1)
#define BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_PMI_IF_CTL0.
 */
#define BCMI_MADURA_READ_UC_RMI_PMI_IF_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_PMI_IF_CTL0r,_r._uc_rmi_pmi_if_ctl0)
#define BCMI_MADURA_WRITE_UC_RMI_PMI_IF_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_PMI_IF_CTL0r,_r._uc_rmi_pmi_if_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PMI_IF_CTL0r BCMI_MADURA_UC_RMI_PMI_IF_CTL0r
#define UC_RMI_PMI_IF_CTL0r_SIZE BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_SIZE
typedef BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_t UC_RMI_PMI_IF_CTL0r_t;
#define UC_RMI_PMI_IF_CTL0r_CLR BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_CLR
#define UC_RMI_PMI_IF_CTL0r_SET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_SET
#define UC_RMI_PMI_IF_CTL0r_GET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_GET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_SET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_BKTOBK_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_GET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_SET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_DUAL_META_FF_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_GET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_SET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_EXT_FAST_READ_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_GET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_SET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_DUAL_META_FF_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET BCMI_MADURA_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET
#define READ_UC_RMI_PMI_IF_CTL0r BCMI_MADURA_READ_UC_RMI_PMI_IF_CTL0r
#define WRITE_UC_RMI_PMI_IF_CTL0r BCMI_MADURA_WRITE_UC_RMI_PMI_IF_CTL0r
#define MODIFY_UC_RMI_PMI_IF_CTL0r BCMI_MADURA_MODIFY_UC_RMI_PMI_IF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_PMI_IF_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_SILICON_DBG_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd229
 * DEVAD:    1
 * DESC:     Silicon debug control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUX_SEL This field is used to select the data to be muxed to rmi_silicon_debug_status0 registers0 - register interface - {5'd0, init_req,  wraddr_changed,  write_req,rdaddr_changed, read_req, ra_state[1:0],1'b0, ra_his_state[2:0]}1 - pram interface     - {2'b00, pif_state_status[1:0], pif_his_state_status[3:0],pr_hready, pr_cr_chipsel, pr_state[1:0], 1'b0,pr_his_state[2:0]};2 - pmi_hp interface   - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}3 - pmi_hp_ext interface   - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}
 */
#define BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r (0x0001d229 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_CTL0.
 */
typedef union BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_ctl0[1];
	uint32_t _uc_rmi_silicon_dbg_ctl0;
} BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_t;

#define BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_CLR(r) (r).uc_rmi_silicon_dbg_ctl0[0] = 0
#define BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_SET(r,d) (r).uc_rmi_silicon_dbg_ctl0[0] = d
#define BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_GET(r) (r).uc_rmi_silicon_dbg_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET(r) (((r).uc_rmi_silicon_dbg_ctl0[0]) & 0x3)
#define BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET(r,f) (r).uc_rmi_silicon_dbg_ctl0[0]=(((r).uc_rmi_silicon_dbg_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_CTL0.
 */
#define BCMI_MADURA_READ_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r,_r._uc_rmi_silicon_dbg_ctl0)
#define BCMI_MADURA_WRITE_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r,_r._uc_rmi_silicon_dbg_ctl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_CTL0r BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r
#define UC_RMI_SILICON_DBG_CTL0r_SIZE BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_SIZE
typedef BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_t UC_RMI_SILICON_DBG_CTL0r_t;
#define UC_RMI_SILICON_DBG_CTL0r_CLR BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_CLR
#define UC_RMI_SILICON_DBG_CTL0r_SET BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_SET
#define UC_RMI_SILICON_DBG_CTL0r_GET BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET
#define READ_UC_RMI_SILICON_DBG_CTL0r BCMI_MADURA_READ_UC_RMI_SILICON_DBG_CTL0r
#define WRITE_UC_RMI_SILICON_DBG_CTL0r BCMI_MADURA_WRITE_UC_RMI_SILICON_DBG_CTL0r
#define MODIFY_UC_RMI_SILICON_DBG_CTL0r BCMI_MADURA_MODIFY_UC_RMI_SILICON_DBG_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_SILICON_DBG_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  UC_RMI_SILICON_DBG_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22a
 * DEVAD:    1
 * DESC:     Silicon debug status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUXED_DATA Muxed status data is made avaialable on this field.micro_silicon_debug_status_mux_sel is used to select the data source
 */
#define BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r (0x0001d22a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_STS0.
 */
typedef union BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_sts0[1];
	uint32_t _uc_rmi_silicon_dbg_sts0;
} BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_t;

#define BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_CLR(r) (r).uc_rmi_silicon_dbg_sts0[0] = 0
#define BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_SET(r,d) (r).uc_rmi_silicon_dbg_sts0[0] = d
#define BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_GET(r) (r).uc_rmi_silicon_dbg_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET(r) (((r).uc_rmi_silicon_dbg_sts0[0]) & 0xffff)
#define BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET(r,f) (r).uc_rmi_silicon_dbg_sts0[0]=(((r).uc_rmi_silicon_dbg_sts0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_STS0.
 */
#define BCMI_MADURA_READ_UC_RMI_SILICON_DBG_STS0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r,_r._uc_rmi_silicon_dbg_sts0)
#define BCMI_MADURA_WRITE_UC_RMI_SILICON_DBG_STS0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r,_r._uc_rmi_silicon_dbg_sts0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_STS0r BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r
#define UC_RMI_SILICON_DBG_STS0r_SIZE BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_SIZE
typedef BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_t UC_RMI_SILICON_DBG_STS0r_t;
#define UC_RMI_SILICON_DBG_STS0r_CLR BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_CLR
#define UC_RMI_SILICON_DBG_STS0r_SET BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_SET
#define UC_RMI_SILICON_DBG_STS0r_GET BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET
#define READ_UC_RMI_SILICON_DBG_STS0r BCMI_MADURA_READ_UC_RMI_SILICON_DBG_STS0r
#define WRITE_UC_RMI_SILICON_DBG_STS0r BCMI_MADURA_WRITE_UC_RMI_SILICON_DBG_STS0r
#define MODIFY_UC_RMI_SILICON_DBG_STS0r BCMI_MADURA_MODIFY_UC_RMI_SILICON_DBG_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_UC_RMI_SILICON_DBG_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_BCST_PORT_ADDR
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdc
 * DEVAD:    1
 * DESC:     Broadcast Port Address
 * RESETVAL: 0x1f (31)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BRCST_PORT_ADDR Braodcast port address that can be used to broadcast mdio commandsto multiple controllers connected to the same mdio station manager
 */
#define BCMI_MADURA_MDIO_BCST_PORT_ADDRr (0x0001ffdc | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_BCST_PORT_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BCST_PORT_ADDR.
 */
typedef union BCMI_MADURA_MDIO_BCST_PORT_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_bcst_port_addr[1];
	uint32_t _mdio_bcst_port_addr;
} BCMI_MADURA_MDIO_BCST_PORT_ADDRr_t;

#define BCMI_MADURA_MDIO_BCST_PORT_ADDRr_CLR(r) (r).mdio_bcst_port_addr[0] = 0
#define BCMI_MADURA_MDIO_BCST_PORT_ADDRr_SET(r,d) (r).mdio_bcst_port_addr[0] = d
#define BCMI_MADURA_MDIO_BCST_PORT_ADDRr_GET(r) (r).mdio_bcst_port_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET(r) (((r).mdio_bcst_port_addr[0]) & 0x1f)
#define BCMI_MADURA_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access MDIO_BCST_PORT_ADDR.
 */
#define BCMI_MADURA_READ_MDIO_BCST_PORT_ADDRr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_BCST_PORT_ADDRr,_r._mdio_bcst_port_addr)
#define BCMI_MADURA_WRITE_MDIO_BCST_PORT_ADDRr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_BCST_PORT_ADDRr,_r._mdio_bcst_port_addr)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BCST_PORT_ADDRr BCMI_MADURA_MDIO_BCST_PORT_ADDRr
#define MDIO_BCST_PORT_ADDRr_SIZE BCMI_MADURA_MDIO_BCST_PORT_ADDRr_SIZE
typedef BCMI_MADURA_MDIO_BCST_PORT_ADDRr_t MDIO_BCST_PORT_ADDRr_t;
#define MDIO_BCST_PORT_ADDRr_CLR BCMI_MADURA_MDIO_BCST_PORT_ADDRr_CLR
#define MDIO_BCST_PORT_ADDRr_SET BCMI_MADURA_MDIO_BCST_PORT_ADDRr_SET
#define MDIO_BCST_PORT_ADDRr_GET BCMI_MADURA_MDIO_BCST_PORT_ADDRr_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET BCMI_MADURA_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET BCMI_MADURA_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET
#define READ_MDIO_BCST_PORT_ADDRr BCMI_MADURA_READ_MDIO_BCST_PORT_ADDRr
#define WRITE_MDIO_BCST_PORT_ADDRr BCMI_MADURA_WRITE_MDIO_BCST_PORT_ADDRr
#define MODIFY_MDIO_BCST_PORT_ADDRr BCMI_MADURA_MODIFY_MDIO_BCST_PORT_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_BCST_PORT_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_MMD_SEL
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdd
 * DEVAD:    1
 * DESC:     MMD Select
 * RESETVAL: 0x404d (16461)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DEV_CL22_EN When set and mdio_multi_mmds_en=1 then CL22 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PMD_EN  When set and mdio_multi_mmds_en=1 then the PMD device=1 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_AN_EN   When set and mdio_multi_mmds_en=1 then the AN device=7 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PHY_EN  When set and mdio_multi_mmds_en=1 then the PHY device=4 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_DTE_EN  When set and mdio_multi_mmds_en=1 then the DTE device=5 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PCS_EN  When set and mdio_multi_mmds_en=1 then the PCS device=3 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_MULTI_MMDS_EN When set enables the multiple MMD functionality.  MD_ST is ignored andeach device can be accessed directly with the appropriate CL22 or CL45protocol.
 *     MDIO_MULTI_PRTS_EN When set enables multiple prtad functionality.  Each of the lanes'mmds can be accessed with consecutive PRTADs.  Lane 0 is accessedwith PRTAD_STRAP, lane 1 with PRTAD_STRAP+1, lane 2 with PRTAD_STRAP+2and lane 3 with PRTAD_STRAP+3.
 */
#define BCMI_MADURA_MDIO_MMD_SELr (0x0001ffdd | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_MMD_SELr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MMD_SEL.
 */
typedef union BCMI_MADURA_MDIO_MMD_SELr_s {
	uint32_t v[1];
	uint32_t mdio_mmd_sel[1];
	uint32_t _mdio_mmd_sel;
} BCMI_MADURA_MDIO_MMD_SELr_t;

#define BCMI_MADURA_MDIO_MMD_SELr_CLR(r) (r).mdio_mmd_sel[0] = 0
#define BCMI_MADURA_MDIO_MMD_SELr_SET(r,d) (r).mdio_mmd_sel[0] = d
#define BCMI_MADURA_MDIO_MMD_SELr_GET(r) (r).mdio_mmd_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 15) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 14) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 6) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 5) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 4) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 3) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 2) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET(r) (((r).mdio_mmd_sel[0]) & 0x1)
#define BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_MMD_SEL.
 */
#define BCMI_MADURA_READ_MDIO_MMD_SELr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_MMD_SELr,_r._mdio_mmd_sel)
#define BCMI_MADURA_WRITE_MDIO_MMD_SELr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_MMD_SELr,_r._mdio_mmd_sel)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MMD_SELr BCMI_MADURA_MDIO_MMD_SELr
#define MDIO_MMD_SELr_SIZE BCMI_MADURA_MDIO_MMD_SELr_SIZE
typedef BCMI_MADURA_MDIO_MMD_SELr_t MDIO_MMD_SELr_t;
#define MDIO_MMD_SELr_CLR BCMI_MADURA_MDIO_MMD_SELr_CLR
#define MDIO_MMD_SELr_SET BCMI_MADURA_MDIO_MMD_SELr_SET
#define MDIO_MMD_SELr_GET BCMI_MADURA_MDIO_MMD_SELr_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET BCMI_MADURA_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET
#define READ_MDIO_MMD_SELr BCMI_MADURA_READ_MDIO_MMD_SELr
#define WRITE_MDIO_MMD_SELr BCMI_MADURA_WRITE_MDIO_MMD_SELr
#define MODIFY_MDIO_MMD_SELr BCMI_MADURA_MODIFY_MDIO_MMD_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_MMD_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  MDIO_AER
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffde
 * DEVAD:    1
 * DESC:     AER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_AER         Provides upper 16-bits of 32-bit address for mdio transactions
 */
#define BCMI_MADURA_MDIO_AERr (0x0001ffde | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_MDIO_AERr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_AER.
 */
typedef union BCMI_MADURA_MDIO_AERr_s {
	uint32_t v[1];
	uint32_t mdio_aer[1];
	uint32_t _mdio_aer;
} BCMI_MADURA_MDIO_AERr_t;

#define BCMI_MADURA_MDIO_AERr_CLR(r) (r).mdio_aer[0] = 0
#define BCMI_MADURA_MDIO_AERr_SET(r,d) (r).mdio_aer[0] = d
#define BCMI_MADURA_MDIO_AERr_GET(r) (r).mdio_aer[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_MDIO_AERr_MDIO_AERf_GET(r) (((r).mdio_aer[0]) & 0xffff)
#define BCMI_MADURA_MDIO_AERr_MDIO_AERf_SET(r,f) (r).mdio_aer[0]=(((r).mdio_aer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MDIO_AER.
 */
#define BCMI_MADURA_READ_MDIO_AERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_MDIO_AERr,_r._mdio_aer)
#define BCMI_MADURA_WRITE_MDIO_AERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_MDIO_AERr,_r._mdio_aer)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_AERr BCMI_MADURA_MDIO_AERr
#define MDIO_AERr_SIZE BCMI_MADURA_MDIO_AERr_SIZE
typedef BCMI_MADURA_MDIO_AERr_t MDIO_AERr_t;
#define MDIO_AERr_CLR BCMI_MADURA_MDIO_AERr_CLR
#define MDIO_AERr_SET BCMI_MADURA_MDIO_AERr_SET
#define MDIO_AERr_GET BCMI_MADURA_MDIO_AERr_GET
#define MDIO_AERr_MDIO_AERf_GET BCMI_MADURA_MDIO_AERr_MDIO_AERf_GET
#define MDIO_AERr_MDIO_AERf_SET BCMI_MADURA_MDIO_AERr_MDIO_AERf_SET
#define READ_MDIO_AERr BCMI_MADURA_READ_MDIO_AERr
#define WRITE_MDIO_AERr BCMI_MADURA_WRITE_MDIO_AERr
#define MODIFY_MDIO_AERr BCMI_MADURA_MODIFY_MDIO_AERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_MDIO_AERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_IT_BASE_R_PMD_CTL
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x0096
 * DEVAD:    2
 * DESC:     BASE-R PMD control register 150
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_IEEE_RESTART_TRAINING 1 = Restart 10GBASE-KR cl93n72 training0 = Normal operation(self clearing)
 *     CL93N72_IEEE_TRAINING_ENABLE 1 = Enable the 10GBASE-KR start-up protocol0 = Disable the 10GBASE-KR start-up protocol
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr (0x00020096 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_PMD_CTL.
 */
typedef union BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_pmd_ctl[1];
	uint32_t _cl93n72_it_base_r_pmd_ctl;
} BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_t;

#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CLR(r) (r).cl93n72_it_base_r_pmd_ctl[0] = 0
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_SET(r,d) (r).cl93n72_it_base_r_pmd_ctl[0] = d
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_GET(r) (r).cl93n72_it_base_r_pmd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_GET(r) ((((r).cl93n72_it_base_r_pmd_ctl[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_SET(r,f) (r).cl93n72_it_base_r_pmd_ctl[0]=(((r).cl93n72_it_base_r_pmd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_GET(r) (((r).cl93n72_it_base_r_pmd_ctl[0]) & 0x1)
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_SET(r,f) (r).cl93n72_it_base_r_pmd_ctl[0]=(((r).cl93n72_it_base_r_pmd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_PMD_CTL.
 */
#define BCMI_MADURA_READ_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr,_r._cl93n72_it_base_r_pmd_ctl)
#define BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr,_r._cl93n72_it_base_r_pmd_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_PMD_CTLr BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr
#define CL93N72_IT_BASE_R_PMD_CTLr_SIZE BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_SIZE
typedef BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_t CL93N72_IT_BASE_R_PMD_CTLr_t;
#define CL93N72_IT_BASE_R_PMD_CTLr_CLR BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CLR
#define CL93N72_IT_BASE_R_PMD_CTLr_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_SET
#define CL93N72_IT_BASE_R_PMD_CTLr_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_GET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_GET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_SET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_GET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_SET
#define READ_CL93N72_IT_BASE_R_PMD_CTLr BCMI_MADURA_READ_CL93N72_IT_BASE_R_PMD_CTLr
#define WRITE_CL93N72_IT_BASE_R_PMD_CTLr BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_PMD_CTLr
#define MODIFY_CL93N72_IT_BASE_R_PMD_CTLr BCMI_MADURA_MODIFY_CL93N72_IT_BASE_R_PMD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_IT_BASE_R_PMD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_IT_BASE_R_PMD_STS
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x0097
 * DEVAD:    2
 * DESC:     BASE-R PMD status register 151
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_RECEIVER_STATUS 1 = Receiver trained and ready to receive data0 = Receiver training
 *     CL93N72_IEEE_FRAME_LOCK 1 = Training frame delineation detected0 = Training frame delineation not detected
 *     CL93N72_IEEE_TRAINING_STATUS 1 = Start-up protocol in progress0 = Start-up protocol complete
 *     CL93N72_IEEE_TRAINING_FAILURE 1 = Training failure has been detected0 = Training failure has not been detected
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr (0x00020097 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_PMD_STS.
 */
typedef union BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_pmd_sts[1];
	uint32_t _cl93n72_it_base_r_pmd_sts;
} BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_t;

#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CLR(r) (r).cl93n72_it_base_r_pmd_sts[0] = 0
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_SET(r,d) (r).cl93n72_it_base_r_pmd_sts[0] = d
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_GET(r) (r).cl93n72_it_base_r_pmd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_GET(r) ((((r).cl93n72_it_base_r_pmd_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_GET(r) ((((r).cl93n72_it_base_r_pmd_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_GET(r) ((((r).cl93n72_it_base_r_pmd_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_GET(r) (((r).cl93n72_it_base_r_pmd_sts[0]) & 0x1)
#define BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_PMD_STS.
 */
#define BCMI_MADURA_READ_CL93N72_IT_BASE_R_PMD_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr,_r._cl93n72_it_base_r_pmd_sts)
#define BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_PMD_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr,_r._cl93n72_it_base_r_pmd_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_PMD_STSr BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr
#define CL93N72_IT_BASE_R_PMD_STSr_SIZE BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_SIZE
typedef BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_t CL93N72_IT_BASE_R_PMD_STSr_t;
#define CL93N72_IT_BASE_R_PMD_STSr_CLR BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CLR
#define CL93N72_IT_BASE_R_PMD_STSr_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_SET
#define CL93N72_IT_BASE_R_PMD_STSr_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_SET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_SET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_SET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_GET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_SET BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_SET
#define READ_CL93N72_IT_BASE_R_PMD_STSr BCMI_MADURA_READ_CL93N72_IT_BASE_R_PMD_STSr
#define WRITE_CL93N72_IT_BASE_R_PMD_STSr BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_PMD_STSr
#define MODIFY_CL93N72_IT_BASE_R_PMD_STSr BCMI_MADURA_MODIFY_CL93N72_IT_BASE_R_PMD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_IT_BASE_R_PMD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_IR_BASE_R_LP_COEFF_UPD
 * BLOCKS:   CL93N72_IEEE_RX
 * REGADDR:  0x0098
 * DEVAD:    2
 * DESC:     BASE-R LP coeff update register 152
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LP_COEFF_UPDATE This register reflects the first 16-bit Word of the training framemost recently recieived from the Link PartnerThis register is not writeable when cl93n72 training is disabled asindicated in the IEEE spec.15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr (0x00020098 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IR_BASE_R_LP_COEFF_UPD.
 */
typedef union BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl93n72_ir_base_r_lp_coeff_upd[1];
	uint32_t _cl93n72_ir_base_r_lp_coeff_upd;
} BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_t;

#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CLR(r) (r).cl93n72_ir_base_r_lp_coeff_upd[0] = 0
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SET(r,d) (r).cl93n72_ir_base_r_lp_coeff_upd[0] = d
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_GET(r) (r).cl93n72_ir_base_r_lp_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_GET(r) (((r).cl93n72_ir_base_r_lp_coeff_upd[0]) & 0xffff)
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_SET(r,f) (r).cl93n72_ir_base_r_lp_coeff_upd[0]=(((r).cl93n72_ir_base_r_lp_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IR_BASE_R_LP_COEFF_UPD.
 */
#define BCMI_MADURA_READ_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr,_r._cl93n72_ir_base_r_lp_coeff_upd)
#define BCMI_MADURA_WRITE_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr,_r._cl93n72_ir_base_r_lp_coeff_upd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_SIZE BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SIZE
typedef BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_t CL93N72_IR_BASE_R_LP_COEFF_UPDr_t;
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_CLR BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CLR
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_SET BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SET
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_GET BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_GET
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_GET BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_GET
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_SET BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_SET
#define READ_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_MADURA_READ_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define WRITE_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_MADURA_WRITE_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define MODIFY_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_MADURA_MODIFY_CL93N72_IR_BASE_R_LP_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_IR_BASE_R_LP_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_IR_BASE_R_LP_STS_REP
 * BLOCKS:   CL93N72_IEEE_RX
 * REGADDR:  0x0099
 * DEVAD:    2
 * DESC:     BASE-R LP status report register 153
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LP_STATUS_REPORT This register reflects the second 16-bit Word of the training framemost recently recieived from the Link Partner15   Receiver Ready1 =  The LP receiver has determined that training iscomplete and is prepared to receive data0 =  The LP receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 */
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr (0x00020099 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IR_BASE_R_LP_STS_REP.
 */
typedef union BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl93n72_ir_base_r_lp_sts_rep[1];
	uint32_t _cl93n72_ir_base_r_lp_sts_rep;
} BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_t;

#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_CLR(r) (r).cl93n72_ir_base_r_lp_sts_rep[0] = 0
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_SET(r,d) (r).cl93n72_ir_base_r_lp_sts_rep[0] = d
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_GET(r) (r).cl93n72_ir_base_r_lp_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_GET(r) (((r).cl93n72_ir_base_r_lp_sts_rep[0]) & 0xffff)
#define BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_SET(r,f) (r).cl93n72_ir_base_r_lp_sts_rep[0]=(((r).cl93n72_ir_base_r_lp_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IR_BASE_R_LP_STS_REP.
 */
#define BCMI_MADURA_READ_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr,_r._cl93n72_ir_base_r_lp_sts_rep)
#define BCMI_MADURA_WRITE_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr,_r._cl93n72_ir_base_r_lp_sts_rep)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IR_BASE_R_LP_STS_REPr BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr
#define CL93N72_IR_BASE_R_LP_STS_REPr_SIZE BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_SIZE
typedef BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_t CL93N72_IR_BASE_R_LP_STS_REPr_t;
#define CL93N72_IR_BASE_R_LP_STS_REPr_CLR BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_CLR
#define CL93N72_IR_BASE_R_LP_STS_REPr_SET BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_SET
#define CL93N72_IR_BASE_R_LP_STS_REPr_GET BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_GET
#define CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_GET BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_GET
#define CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_SET BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_SET
#define READ_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_MADURA_READ_CL93N72_IR_BASE_R_LP_STS_REPr
#define WRITE_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_MADURA_WRITE_CL93N72_IR_BASE_R_LP_STS_REPr
#define MODIFY_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_MADURA_MODIFY_CL93N72_IR_BASE_R_LP_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_IR_BASE_R_LP_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_IT_BASE_R_LD_COEFF_UPD
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x009a
 * DEVAD:    2
 * DESC:     BASE-R LD coeff update register 154
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LD_COEFF_UPDATE This register reflects the first 16-bit Word of the outgoing training framesent by the Local Device15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr (0x0002009a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_LD_COEFF_UPD.
 */
typedef union BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_ld_coeff_upd[1];
	uint32_t _cl93n72_it_base_r_ld_coeff_upd;
} BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_t;

#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CLR(r) (r).cl93n72_it_base_r_ld_coeff_upd[0] = 0
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SET(r,d) (r).cl93n72_it_base_r_ld_coeff_upd[0] = d
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_GET(r) (r).cl93n72_it_base_r_ld_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_GET(r) (((r).cl93n72_it_base_r_ld_coeff_upd[0]) & 0xffff)
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_SET(r,f) (r).cl93n72_it_base_r_ld_coeff_upd[0]=(((r).cl93n72_it_base_r_ld_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_LD_COEFF_UPD.
 */
#define BCMI_MADURA_READ_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr,_r._cl93n72_it_base_r_ld_coeff_upd)
#define BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr,_r._cl93n72_it_base_r_ld_coeff_upd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_SIZE BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SIZE
typedef BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_t CL93N72_IT_BASE_R_LD_COEFF_UPDr_t;
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_CLR BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CLR
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_SET BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SET
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_GET BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_GET
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_GET BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_GET
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_SET BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_SET
#define READ_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_MADURA_READ_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define WRITE_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define MODIFY_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_MADURA_MODIFY_CL93N72_IT_BASE_R_LD_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_IT_BASE_R_LD_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL93N72_IT_BASE_R_LD_STS_REP
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x009b
 * DEVAD:    2
 * DESC:     BASE-R LD status report register 155
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LD_STATUS_REPORT This register reflects the second 16-bit Word of the outgoing training framesent by the Local Device15   Receiver Ready1 =  The LD receiver has determined that training iscomplete and is prepared to receive data0 =  The LD receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr (0x0002009b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_LD_STS_REP.
 */
typedef union BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_ld_sts_rep[1];
	uint32_t _cl93n72_it_base_r_ld_sts_rep;
} BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_t;

#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_CLR(r) (r).cl93n72_it_base_r_ld_sts_rep[0] = 0
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_SET(r,d) (r).cl93n72_it_base_r_ld_sts_rep[0] = d
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_GET(r) (r).cl93n72_it_base_r_ld_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_GET(r) (((r).cl93n72_it_base_r_ld_sts_rep[0]) & 0xffff)
#define BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_SET(r,f) (r).cl93n72_it_base_r_ld_sts_rep[0]=(((r).cl93n72_it_base_r_ld_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_LD_STS_REP.
 */
#define BCMI_MADURA_READ_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr,_r._cl93n72_it_base_r_ld_sts_rep)
#define BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr,_r._cl93n72_it_base_r_ld_sts_rep)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_LD_STS_REPr BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr
#define CL93N72_IT_BASE_R_LD_STS_REPr_SIZE BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_SIZE
typedef BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_t CL93N72_IT_BASE_R_LD_STS_REPr_t;
#define CL93N72_IT_BASE_R_LD_STS_REPr_CLR BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_CLR
#define CL93N72_IT_BASE_R_LD_STS_REPr_SET BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_SET
#define CL93N72_IT_BASE_R_LD_STS_REPr_GET BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_GET
#define CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_GET BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_GET
#define CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_SET BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_SET
#define READ_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_MADURA_READ_CL93N72_IT_BASE_R_LD_STS_REPr
#define WRITE_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_MADURA_WRITE_CL93N72_IT_BASE_R_LD_STS_REPr
#define MODIFY_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_MADURA_MODIFY_CL93N72_IT_BASE_R_LD_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL93N72_IT_BASE_R_LD_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_CTL
 * BLOCKS:   IEEE_AN_BLK0
 * REGADDR:  0x0000
 * DEVAD:    7
 * DESC:     AN control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RESTART_AUTO_NEGOTIATION 1 = Restart Auto-Negotiation process0 = Auto-Negotiation in process,disabled, or not supported
 *     AUTO_NEGOTIATIONENABLE 1 = enable Auto-Negotiation process0 = disable Auto-Negotiation process
 *     AN_RESET         1 = AN reset0 = AN normal operation
 */
#define BCMI_MADURA_AN_CTLr (0x00070000 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_CTL.
 */
typedef union BCMI_MADURA_AN_CTLr_s {
	uint32_t v[1];
	uint32_t an_ctl[1];
	uint32_t _an_ctl;
} BCMI_MADURA_AN_CTLr_t;

#define BCMI_MADURA_AN_CTLr_CLR(r) (r).an_ctl[0] = 0
#define BCMI_MADURA_AN_CTLr_SET(r,d) (r).an_ctl[0] = d
#define BCMI_MADURA_AN_CTLr_GET(r) (r).an_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_CTLr_AN_RESETf_GET(r) ((((r).an_ctl[0]) >> 15) & 0x1)
#define BCMI_MADURA_AN_CTLr_AN_RESETf_SET(r,f) (r).an_ctl[0]=(((r).an_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AN_CTLr_AUTO_NEGOTIATIONENABLEf_GET(r) ((((r).an_ctl[0]) >> 12) & 0x1)
#define BCMI_MADURA_AN_CTLr_AUTO_NEGOTIATIONENABLEf_SET(r,f) (r).an_ctl[0]=(((r).an_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AN_CTLr_RESTART_AUTO_NEGOTIATIONf_GET(r) ((((r).an_ctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_AN_CTLr_RESTART_AUTO_NEGOTIATIONf_SET(r,f) (r).an_ctl[0]=(((r).an_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))

/*
 * These macros can be used to access AN_CTL.
 */
#define BCMI_MADURA_READ_AN_CTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_CTLr,_r._an_ctl)
#define BCMI_MADURA_WRITE_AN_CTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_CTLr,_r._an_ctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_CTLr BCMI_MADURA_AN_CTLr
#define AN_CTLr_SIZE BCMI_MADURA_AN_CTLr_SIZE
typedef BCMI_MADURA_AN_CTLr_t AN_CTLr_t;
#define AN_CTLr_CLR BCMI_MADURA_AN_CTLr_CLR
#define AN_CTLr_SET BCMI_MADURA_AN_CTLr_SET
#define AN_CTLr_GET BCMI_MADURA_AN_CTLr_GET
#define AN_CTLr_AN_RESETf_GET BCMI_MADURA_AN_CTLr_AN_RESETf_GET
#define AN_CTLr_AN_RESETf_SET BCMI_MADURA_AN_CTLr_AN_RESETf_SET
#define AN_CTLr_AUTO_NEGOTIATIONENABLEf_GET BCMI_MADURA_AN_CTLr_AUTO_NEGOTIATIONENABLEf_GET
#define AN_CTLr_AUTO_NEGOTIATIONENABLEf_SET BCMI_MADURA_AN_CTLr_AUTO_NEGOTIATIONENABLEf_SET
#define AN_CTLr_RESTART_AUTO_NEGOTIATIONf_GET BCMI_MADURA_AN_CTLr_RESTART_AUTO_NEGOTIATIONf_GET
#define AN_CTLr_RESTART_AUTO_NEGOTIATIONf_SET BCMI_MADURA_AN_CTLr_RESTART_AUTO_NEGOTIATIONf_SET
#define READ_AN_CTLr BCMI_MADURA_READ_AN_CTLr
#define WRITE_AN_CTLr BCMI_MADURA_WRITE_AN_CTLr
#define MODIFY_AN_CTLr BCMI_MADURA_MODIFY_AN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_STS
 * BLOCKS:   IEEE_AN_BLK0
 * REGADDR:  0x0001
 * DEVAD:    7
 * DESC:     AN status register
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_PARTNER_AUTO_NEGOTIATIONABILITY 1 = LP is able to perform Auto-Negotiation0 = LP is not able to perform Auto-Negotiation
 *     LINK_STATUS      1 = Link is up0 = Link is down
 *     AUTO_NEGOTIATIONABILITY 1 = PHY is able to performAuto-Negotiation0 = PHY is not able to performAuto-Negotiation
 *     REMOTE_FAULT     1 = remote fault condition detected0 = no remote fault conditiondetected
 *     AUTO_NEGOTIATIONCOMPLETE 1 = Auto-Negotiation processcompleted0 = Auto-Negotiation process notcompleted
 *     PAGE_RECEIVED    1 = A page has been received0 = A page has not been received
 *     EXTENDED_NEXT_PAGESTATUS 1 = Extended next page format isused0 = Extended next page is notallowed
 *     PARALLEL_DETECTION_FAULT 1 = A fault has been detected via theparallel detection function.0 = A fault has not been detected viathe parallel detection function.
 */
#define BCMI_MADURA_AN_STSr (0x00070001 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_STS.
 */
typedef union BCMI_MADURA_AN_STSr_s {
	uint32_t v[1];
	uint32_t an_sts[1];
	uint32_t _an_sts;
} BCMI_MADURA_AN_STSr_t;

#define BCMI_MADURA_AN_STSr_CLR(r) (r).an_sts[0] = 0
#define BCMI_MADURA_AN_STSr_SET(r,d) (r).an_sts[0] = d
#define BCMI_MADURA_AN_STSr_GET(r) (r).an_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_STSr_PARALLEL_DETECTION_FAULTf_GET(r) ((((r).an_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_AN_STSr_PARALLEL_DETECTION_FAULTf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AN_STSr_EXTENDED_NEXT_PAGESTATUSf_GET(r) ((((r).an_sts[0]) >> 7) & 0x1)
#define BCMI_MADURA_AN_STSr_EXTENDED_NEXT_PAGESTATUSf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AN_STSr_PAGE_RECEIVEDf_GET(r) ((((r).an_sts[0]) >> 6) & 0x1)
#define BCMI_MADURA_AN_STSr_PAGE_RECEIVEDf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONCOMPLETEf_GET(r) ((((r).an_sts[0]) >> 5) & 0x1)
#define BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONCOMPLETEf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AN_STSr_REMOTE_FAULTf_GET(r) ((((r).an_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_AN_STSr_REMOTE_FAULTf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONABILITYf_GET(r) ((((r).an_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONABILITYf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AN_STSr_LINK_STATUSf_GET(r) ((((r).an_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_AN_STSr_LINK_STATUSf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AN_STSr_LINK_PARTNER_AUTO_NEGOTIATIONABILITYf_GET(r) (((r).an_sts[0]) & 0x1)
#define BCMI_MADURA_AN_STSr_LINK_PARTNER_AUTO_NEGOTIATIONABILITYf_SET(r,f) (r).an_sts[0]=(((r).an_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_STS.
 */
#define BCMI_MADURA_READ_AN_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_STSr,_r._an_sts)
#define BCMI_MADURA_WRITE_AN_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_STSr,_r._an_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_STSr BCMI_MADURA_AN_STSr
#define AN_STSr_SIZE BCMI_MADURA_AN_STSr_SIZE
typedef BCMI_MADURA_AN_STSr_t AN_STSr_t;
#define AN_STSr_CLR BCMI_MADURA_AN_STSr_CLR
#define AN_STSr_SET BCMI_MADURA_AN_STSr_SET
#define AN_STSr_GET BCMI_MADURA_AN_STSr_GET
#define AN_STSr_PARALLEL_DETECTION_FAULTf_GET BCMI_MADURA_AN_STSr_PARALLEL_DETECTION_FAULTf_GET
#define AN_STSr_PARALLEL_DETECTION_FAULTf_SET BCMI_MADURA_AN_STSr_PARALLEL_DETECTION_FAULTf_SET
#define AN_STSr_EXTENDED_NEXT_PAGESTATUSf_GET BCMI_MADURA_AN_STSr_EXTENDED_NEXT_PAGESTATUSf_GET
#define AN_STSr_EXTENDED_NEXT_PAGESTATUSf_SET BCMI_MADURA_AN_STSr_EXTENDED_NEXT_PAGESTATUSf_SET
#define AN_STSr_PAGE_RECEIVEDf_GET BCMI_MADURA_AN_STSr_PAGE_RECEIVEDf_GET
#define AN_STSr_PAGE_RECEIVEDf_SET BCMI_MADURA_AN_STSr_PAGE_RECEIVEDf_SET
#define AN_STSr_AUTO_NEGOTIATIONCOMPLETEf_GET BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONCOMPLETEf_GET
#define AN_STSr_AUTO_NEGOTIATIONCOMPLETEf_SET BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONCOMPLETEf_SET
#define AN_STSr_REMOTE_FAULTf_GET BCMI_MADURA_AN_STSr_REMOTE_FAULTf_GET
#define AN_STSr_REMOTE_FAULTf_SET BCMI_MADURA_AN_STSr_REMOTE_FAULTf_SET
#define AN_STSr_AUTO_NEGOTIATIONABILITYf_GET BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONABILITYf_GET
#define AN_STSr_AUTO_NEGOTIATIONABILITYf_SET BCMI_MADURA_AN_STSr_AUTO_NEGOTIATIONABILITYf_SET
#define AN_STSr_LINK_STATUSf_GET BCMI_MADURA_AN_STSr_LINK_STATUSf_GET
#define AN_STSr_LINK_STATUSf_SET BCMI_MADURA_AN_STSr_LINK_STATUSf_SET
#define AN_STSr_LINK_PARTNER_AUTO_NEGOTIATIONABILITYf_GET BCMI_MADURA_AN_STSr_LINK_PARTNER_AUTO_NEGOTIATIONABILITYf_GET
#define AN_STSr_LINK_PARTNER_AUTO_NEGOTIATIONABILITYf_SET BCMI_MADURA_AN_STSr_LINK_PARTNER_AUTO_NEGOTIATIONABILITYf_SET
#define READ_AN_STSr BCMI_MADURA_READ_AN_STSr
#define WRITE_AN_STSr BCMI_MADURA_WRITE_AN_STSr
#define MODIFY_AN_STSr BCMI_MADURA_MODIFY_AN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_IDENTIFIER
 * BLOCKS:   IEEE_AN_BLK0
 * REGADDR:  0x0003
 * DEVAD:    7
 * DESC:     AN Identifier Register 1
 * RESETVAL: 0x52b0 (21168)
 * ACCESS:   R/W
 * FIELDS:
 *     DEVICE_ID_1      PHY ID LOW
 */
#define BCMI_MADURA_AN_IDENTIFIERr (0x00070003 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_IDENTIFIERr_SIZE 4

/*
 * This structure should be used to declare and program AN_IDENTIFIER.
 */
typedef union BCMI_MADURA_AN_IDENTIFIERr_s {
	uint32_t v[1];
	uint32_t an_identifier[1];
	uint32_t _an_identifier;
} BCMI_MADURA_AN_IDENTIFIERr_t;

#define BCMI_MADURA_AN_IDENTIFIERr_CLR(r) (r).an_identifier[0] = 0
#define BCMI_MADURA_AN_IDENTIFIERr_SET(r,d) (r).an_identifier[0] = d
#define BCMI_MADURA_AN_IDENTIFIERr_GET(r) (r).an_identifier[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_IDENTIFIERr_DEVICE_ID_1f_GET(r) (((r).an_identifier[0]) & 0xffff)
#define BCMI_MADURA_AN_IDENTIFIERr_DEVICE_ID_1f_SET(r,f) (r).an_identifier[0]=(((r).an_identifier[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_IDENTIFIER.
 */
#define BCMI_MADURA_READ_AN_IDENTIFIERr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_IDENTIFIERr,_r._an_identifier)
#define BCMI_MADURA_WRITE_AN_IDENTIFIERr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_IDENTIFIERr,_r._an_identifier)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_IDENTIFIERr BCMI_MADURA_AN_IDENTIFIERr
#define AN_IDENTIFIERr_SIZE BCMI_MADURA_AN_IDENTIFIERr_SIZE
typedef BCMI_MADURA_AN_IDENTIFIERr_t AN_IDENTIFIERr_t;
#define AN_IDENTIFIERr_CLR BCMI_MADURA_AN_IDENTIFIERr_CLR
#define AN_IDENTIFIERr_SET BCMI_MADURA_AN_IDENTIFIERr_SET
#define AN_IDENTIFIERr_GET BCMI_MADURA_AN_IDENTIFIERr_GET
#define AN_IDENTIFIERr_DEVICE_ID_1f_GET BCMI_MADURA_AN_IDENTIFIERr_DEVICE_ID_1f_GET
#define AN_IDENTIFIERr_DEVICE_ID_1f_SET BCMI_MADURA_AN_IDENTIFIERr_DEVICE_ID_1f_SET
#define READ_AN_IDENTIFIERr BCMI_MADURA_READ_AN_IDENTIFIERr
#define WRITE_AN_IDENTIFIERr BCMI_MADURA_WRITE_AN_IDENTIFIERr
#define MODIFY_AN_IDENTIFIERr BCMI_MADURA_MODIFY_AN_IDENTIFIERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_IDENTIFIERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_DEVS_IN_PACKAGE1
 * BLOCKS:   IEEE_AN_BLK0
 * REGADDR:  0x0005
 * DEVAD:    7
 * DESC:     ieee Device in Package 1 register
 * RESETVAL: 0x82 (130)
 * ACCESS:   R/W
 * FIELDS:
 *     CLAUSE_22REGISTERS_PRESENT 1 = Clause 22 registers present
 *     PMD_PMA_PRESENT  1 = PMD/PMA present in package
 *     WIS_PRESENT      1 = WIS present in package
 *     PCS_PRESENT      1 = PCS present in package
 *     PHY_XS_PRESENT   1 = PHY XS present in package
 *     DTE_XS_PRESENT   1 = DTE XS present in package
 *     TC_PRESENT       1 = TC present in package
 *     AN_PRESENT       1-Auto Neg present
 *     SEPERATE_PMA_1_PRESENT Seperate PMA 1  present
 *     SEPERATE_PMA_2_PRESENT Seperate PMA 2  present
 *     SEPERATE_PMA_3_PRESENT Seperate PMA 3  present
 *     SEPERATE_PMA_4_PRESENT Seperate PMA 4  present
 */
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r (0x00070005 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_DEVS_IN_PACKAGE1.
 */
typedef union BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_s {
	uint32_t v[1];
	uint32_t an_devs_in_package1[1];
	uint32_t _an_devs_in_package1;
} BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_t;

#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_CLR(r) (r).an_devs_in_package1[0] = 0
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SET(r,d) (r).an_devs_in_package1[0] = d
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_GET(r) (r).an_devs_in_package1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 11) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 10) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 9) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 8) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_AN_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 7) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_AN_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_TC_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 6) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_TC_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 5) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 4) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PCS_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 3) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PCS_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_WIS_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 2) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_WIS_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_GET(r) ((((r).an_devs_in_package1[0]) >> 1) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_GET(r) (((r).an_devs_in_package1[0]) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_SET(r,f) (r).an_devs_in_package1[0]=(((r).an_devs_in_package1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_DEVS_IN_PACKAGE1.
 */
#define BCMI_MADURA_READ_AN_DEVS_IN_PACKAGE1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_DEVS_IN_PACKAGE1r,_r._an_devs_in_package1)
#define BCMI_MADURA_WRITE_AN_DEVS_IN_PACKAGE1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_DEVS_IN_PACKAGE1r,_r._an_devs_in_package1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_DEVS_IN_PACKAGE1r BCMI_MADURA_AN_DEVS_IN_PACKAGE1r
#define AN_DEVS_IN_PACKAGE1r_SIZE BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SIZE
typedef BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_t AN_DEVS_IN_PACKAGE1r_t;
#define AN_DEVS_IN_PACKAGE1r_CLR BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_CLR
#define AN_DEVS_IN_PACKAGE1r_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SET
#define AN_DEVS_IN_PACKAGE1r_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_GET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_4_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_3_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_2_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_SEPERATE_PMA_1_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_AN_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_AN_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_AN_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_AN_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_TC_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_TC_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_TC_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_TC_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_DTE_XS_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PHY_XS_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_PCS_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PCS_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_PCS_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PCS_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_WIS_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_WIS_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_WIS_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_WIS_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_PMD_PMA_PRESENTf_SET
#define AN_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE1r_CLAUSE_22REGISTERS_PRESENTf_SET
#define READ_AN_DEVS_IN_PACKAGE1r BCMI_MADURA_READ_AN_DEVS_IN_PACKAGE1r
#define WRITE_AN_DEVS_IN_PACKAGE1r BCMI_MADURA_WRITE_AN_DEVS_IN_PACKAGE1r
#define MODIFY_AN_DEVS_IN_PACKAGE1r BCMI_MADURA_MODIFY_AN_DEVS_IN_PACKAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_DEVS_IN_PACKAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_DEVS_IN_PACKAGE2
 * BLOCKS:   IEEE_AN_BLK0
 * REGADDR:  0x0006
 * DEVAD:    7
 * DESC:     ieee Device in Package 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLAUSE_22EXTENSION_PRESENT 1 = Clause 22 extension present inpackage
 *     VENDOR_SPECIFICDEVICE_1_PRESENT 1 = Vendor specific device present inpackage
 *     VENDOR_SPECIFICDEVICE_2_PRESENT 1 = Vendor specific device present inpackage
 */
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE2r (0x00070006 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_DEVS_IN_PACKAGE2.
 */
typedef union BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_s {
	uint32_t v[1];
	uint32_t an_devs_in_package2[1];
	uint32_t _an_devs_in_package2;
} BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_t;

#define BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_CLR(r) (r).an_devs_in_package2[0] = 0
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_SET(r,d) (r).an_devs_in_package2[0] = d
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_GET(r) (r).an_devs_in_package2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_GET(r) ((((r).an_devs_in_package2[0]) >> 13) & 0x1)
#define BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_SET(r,f) (r).an_devs_in_package2[0]=(((r).an_devs_in_package2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access AN_DEVS_IN_PACKAGE2.
 */
#define BCMI_MADURA_READ_AN_DEVS_IN_PACKAGE2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_DEVS_IN_PACKAGE2r,_r._an_devs_in_package2)
#define BCMI_MADURA_WRITE_AN_DEVS_IN_PACKAGE2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_DEVS_IN_PACKAGE2r,_r._an_devs_in_package2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_DEVS_IN_PACKAGE2r BCMI_MADURA_AN_DEVS_IN_PACKAGE2r
#define AN_DEVS_IN_PACKAGE2r_SIZE BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_SIZE
typedef BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_t AN_DEVS_IN_PACKAGE2r_t;
#define AN_DEVS_IN_PACKAGE2r_CLR BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_CLR
#define AN_DEVS_IN_PACKAGE2r_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_SET
#define AN_DEVS_IN_PACKAGE2r_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_GET
#define AN_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_GET BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_GET
#define AN_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_SET BCMI_MADURA_AN_DEVS_IN_PACKAGE2r_CLAUSE_22EXTENSION_PRESENTf_SET
#define READ_AN_DEVS_IN_PACKAGE2r BCMI_MADURA_READ_AN_DEVS_IN_PACKAGE2r
#define WRITE_AN_DEVS_IN_PACKAGE2r BCMI_MADURA_WRITE_AN_DEVS_IN_PACKAGE2r
#define MODIFY_AN_DEVS_IN_PACKAGE2r BCMI_MADURA_MODIFY_AN_DEVS_IN_PACKAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_DEVS_IN_PACKAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_OUI_ID0
 * BLOCKS:   IEEE_AN_BLK0
 * REGADDR:  0x000e
 * DEVAD:    7
 * DESC:     AN OUI ID0 Register
 * RESETVAL: 0xae02 (44546)
 * ACCESS:   R/W
 * FIELDS:
 *     DEVICE_ID_0      PHY ID High
 */
#define BCMI_MADURA_AN_OUI_ID0r (0x0007000e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_OUI_ID0r_SIZE 4

/*
 * This structure should be used to declare and program AN_OUI_ID0.
 */
typedef union BCMI_MADURA_AN_OUI_ID0r_s {
	uint32_t v[1];
	uint32_t an_oui_id0[1];
	uint32_t _an_oui_id0;
} BCMI_MADURA_AN_OUI_ID0r_t;

#define BCMI_MADURA_AN_OUI_ID0r_CLR(r) (r).an_oui_id0[0] = 0
#define BCMI_MADURA_AN_OUI_ID0r_SET(r,d) (r).an_oui_id0[0] = d
#define BCMI_MADURA_AN_OUI_ID0r_GET(r) (r).an_oui_id0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_OUI_ID0r_DEVICE_ID_0f_GET(r) (((r).an_oui_id0[0]) & 0xffff)
#define BCMI_MADURA_AN_OUI_ID0r_DEVICE_ID_0f_SET(r,f) (r).an_oui_id0[0]=(((r).an_oui_id0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_OUI_ID0.
 */
#define BCMI_MADURA_READ_AN_OUI_ID0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_OUI_ID0r,_r._an_oui_id0)
#define BCMI_MADURA_WRITE_AN_OUI_ID0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_OUI_ID0r,_r._an_oui_id0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_OUI_ID0r BCMI_MADURA_AN_OUI_ID0r
#define AN_OUI_ID0r_SIZE BCMI_MADURA_AN_OUI_ID0r_SIZE
typedef BCMI_MADURA_AN_OUI_ID0r_t AN_OUI_ID0r_t;
#define AN_OUI_ID0r_CLR BCMI_MADURA_AN_OUI_ID0r_CLR
#define AN_OUI_ID0r_SET BCMI_MADURA_AN_OUI_ID0r_SET
#define AN_OUI_ID0r_GET BCMI_MADURA_AN_OUI_ID0r_GET
#define AN_OUI_ID0r_DEVICE_ID_0f_GET BCMI_MADURA_AN_OUI_ID0r_DEVICE_ID_0f_GET
#define AN_OUI_ID0r_DEVICE_ID_0f_SET BCMI_MADURA_AN_OUI_ID0r_DEVICE_ID_0f_SET
#define READ_AN_OUI_ID0r BCMI_MADURA_READ_AN_OUI_ID0r
#define WRITE_AN_OUI_ID0r BCMI_MADURA_WRITE_AN_OUI_ID0r
#define MODIFY_AN_OUI_ID0r BCMI_MADURA_MODIFY_AN_OUI_ID0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_OUI_ID0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_OUI_ID1
 * BLOCKS:   IEEE_AN_BLK0
 * REGADDR:  0x000f
 * DEVAD:    7
 * DESC:     AN OUI ID1 Reg
 * RESETVAL: 0x52b0 (21168)
 * ACCESS:   R/W
 * FIELDS:
 *     DEVICE_ID_1      PHY ID LOW
 */
#define BCMI_MADURA_AN_OUI_ID1r (0x0007000f | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_OUI_ID1r_SIZE 4

/*
 * This structure should be used to declare and program AN_OUI_ID1.
 */
typedef union BCMI_MADURA_AN_OUI_ID1r_s {
	uint32_t v[1];
	uint32_t an_oui_id1[1];
	uint32_t _an_oui_id1;
} BCMI_MADURA_AN_OUI_ID1r_t;

#define BCMI_MADURA_AN_OUI_ID1r_CLR(r) (r).an_oui_id1[0] = 0
#define BCMI_MADURA_AN_OUI_ID1r_SET(r,d) (r).an_oui_id1[0] = d
#define BCMI_MADURA_AN_OUI_ID1r_GET(r) (r).an_oui_id1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_OUI_ID1r_DEVICE_ID_1f_GET(r) (((r).an_oui_id1[0]) & 0xffff)
#define BCMI_MADURA_AN_OUI_ID1r_DEVICE_ID_1f_SET(r,f) (r).an_oui_id1[0]=(((r).an_oui_id1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_OUI_ID1.
 */
#define BCMI_MADURA_READ_AN_OUI_ID1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_OUI_ID1r,_r._an_oui_id1)
#define BCMI_MADURA_WRITE_AN_OUI_ID1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_OUI_ID1r,_r._an_oui_id1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_OUI_ID1r BCMI_MADURA_AN_OUI_ID1r
#define AN_OUI_ID1r_SIZE BCMI_MADURA_AN_OUI_ID1r_SIZE
typedef BCMI_MADURA_AN_OUI_ID1r_t AN_OUI_ID1r_t;
#define AN_OUI_ID1r_CLR BCMI_MADURA_AN_OUI_ID1r_CLR
#define AN_OUI_ID1r_SET BCMI_MADURA_AN_OUI_ID1r_SET
#define AN_OUI_ID1r_GET BCMI_MADURA_AN_OUI_ID1r_GET
#define AN_OUI_ID1r_DEVICE_ID_1f_GET BCMI_MADURA_AN_OUI_ID1r_DEVICE_ID_1f_GET
#define AN_OUI_ID1r_DEVICE_ID_1f_SET BCMI_MADURA_AN_OUI_ID1r_DEVICE_ID_1f_SET
#define READ_AN_OUI_ID1r BCMI_MADURA_READ_AN_OUI_ID1r
#define WRITE_AN_OUI_ID1r BCMI_MADURA_WRITE_AN_OUI_ID1r
#define MODIFY_AN_OUI_ID1r BCMI_MADURA_MODIFY_AN_OUI_ID1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_OUI_ID1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_ADVERTISEMENT1
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0010
 * DEVAD:    7
 * DESC:     AN Advertisement 1 Register
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     SELECTOR_FIELD   0 0 0 0 0 Reserved0 0 0 0 1 IEEE Std 802.30 0 0 1 0 IEEE Std 802.9 ISLAN-16T0 0 0 1 1 IEEE Std 802.50 0 1 0 0 IEEE Std 13940 0 1 0 1 Reserved0 0 1 1 X Reserved0 1 X X X Reserved1 X X X X Reserved
 *     ECHOED_NONCE     echoed nonce
 *     PAUSE            12 some PHY ability11 pause10 asm_dir
 *     REMOTE_FAULT     1 = the RF bit in thetransmitted base link codeword is setto logical one0 = the RF bit in thetransmitted base link codeword is setto logical zero
 *     ACKNOWLEDGE      Value always 0
 *     NEXT_PAGE        Engage the device in next pageexchange
 */
#define BCMI_MADURA_AN_ADVERTISEMENT1r (0x00070010 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_ADVERTISEMENT1r_SIZE 4

/*
 * This structure should be used to declare and program AN_ADVERTISEMENT1.
 */
typedef union BCMI_MADURA_AN_ADVERTISEMENT1r_s {
	uint32_t v[1];
	uint32_t an_advertisement1[1];
	uint32_t _an_advertisement1;
} BCMI_MADURA_AN_ADVERTISEMENT1r_t;

#define BCMI_MADURA_AN_ADVERTISEMENT1r_CLR(r) (r).an_advertisement1[0] = 0
#define BCMI_MADURA_AN_ADVERTISEMENT1r_SET(r,d) (r).an_advertisement1[0] = d
#define BCMI_MADURA_AN_ADVERTISEMENT1r_GET(r) (r).an_advertisement1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_ADVERTISEMENT1r_NEXT_PAGEf_GET(r) ((((r).an_advertisement1[0]) >> 15) & 0x1)
#define BCMI_MADURA_AN_ADVERTISEMENT1r_NEXT_PAGEf_SET(r,f) (r).an_advertisement1[0]=(((r).an_advertisement1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AN_ADVERTISEMENT1r_ACKNOWLEDGEf_GET(r) ((((r).an_advertisement1[0]) >> 14) & 0x1)
#define BCMI_MADURA_AN_ADVERTISEMENT1r_ACKNOWLEDGEf_SET(r,f) (r).an_advertisement1[0]=(((r).an_advertisement1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AN_ADVERTISEMENT1r_REMOTE_FAULTf_GET(r) ((((r).an_advertisement1[0]) >> 13) & 0x1)
#define BCMI_MADURA_AN_ADVERTISEMENT1r_REMOTE_FAULTf_SET(r,f) (r).an_advertisement1[0]=(((r).an_advertisement1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_AN_ADVERTISEMENT1r_PAUSEf_GET(r) ((((r).an_advertisement1[0]) >> 10) & 0x7)
#define BCMI_MADURA_AN_ADVERTISEMENT1r_PAUSEf_SET(r,f) (r).an_advertisement1[0]=(((r).an_advertisement1[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_MADURA_AN_ADVERTISEMENT1r_ECHOED_NONCEf_GET(r) ((((r).an_advertisement1[0]) >> 5) & 0x1f)
#define BCMI_MADURA_AN_ADVERTISEMENT1r_ECHOED_NONCEf_SET(r,f) (r).an_advertisement1[0]=(((r).an_advertisement1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_MADURA_AN_ADVERTISEMENT1r_SELECTOR_FIELDf_GET(r) (((r).an_advertisement1[0]) & 0x1f)
#define BCMI_MADURA_AN_ADVERTISEMENT1r_SELECTOR_FIELDf_SET(r,f) (r).an_advertisement1[0]=(((r).an_advertisement1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AN_ADVERTISEMENT1.
 */
#define BCMI_MADURA_READ_AN_ADVERTISEMENT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_ADVERTISEMENT1r,_r._an_advertisement1)
#define BCMI_MADURA_WRITE_AN_ADVERTISEMENT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_ADVERTISEMENT1r,_r._an_advertisement1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_ADVERTISEMENT1r BCMI_MADURA_AN_ADVERTISEMENT1r
#define AN_ADVERTISEMENT1r_SIZE BCMI_MADURA_AN_ADVERTISEMENT1r_SIZE
typedef BCMI_MADURA_AN_ADVERTISEMENT1r_t AN_ADVERTISEMENT1r_t;
#define AN_ADVERTISEMENT1r_CLR BCMI_MADURA_AN_ADVERTISEMENT1r_CLR
#define AN_ADVERTISEMENT1r_SET BCMI_MADURA_AN_ADVERTISEMENT1r_SET
#define AN_ADVERTISEMENT1r_GET BCMI_MADURA_AN_ADVERTISEMENT1r_GET
#define AN_ADVERTISEMENT1r_NEXT_PAGEf_GET BCMI_MADURA_AN_ADVERTISEMENT1r_NEXT_PAGEf_GET
#define AN_ADVERTISEMENT1r_NEXT_PAGEf_SET BCMI_MADURA_AN_ADVERTISEMENT1r_NEXT_PAGEf_SET
#define AN_ADVERTISEMENT1r_ACKNOWLEDGEf_GET BCMI_MADURA_AN_ADVERTISEMENT1r_ACKNOWLEDGEf_GET
#define AN_ADVERTISEMENT1r_ACKNOWLEDGEf_SET BCMI_MADURA_AN_ADVERTISEMENT1r_ACKNOWLEDGEf_SET
#define AN_ADVERTISEMENT1r_REMOTE_FAULTf_GET BCMI_MADURA_AN_ADVERTISEMENT1r_REMOTE_FAULTf_GET
#define AN_ADVERTISEMENT1r_REMOTE_FAULTf_SET BCMI_MADURA_AN_ADVERTISEMENT1r_REMOTE_FAULTf_SET
#define AN_ADVERTISEMENT1r_PAUSEf_GET BCMI_MADURA_AN_ADVERTISEMENT1r_PAUSEf_GET
#define AN_ADVERTISEMENT1r_PAUSEf_SET BCMI_MADURA_AN_ADVERTISEMENT1r_PAUSEf_SET
#define AN_ADVERTISEMENT1r_ECHOED_NONCEf_GET BCMI_MADURA_AN_ADVERTISEMENT1r_ECHOED_NONCEf_GET
#define AN_ADVERTISEMENT1r_ECHOED_NONCEf_SET BCMI_MADURA_AN_ADVERTISEMENT1r_ECHOED_NONCEf_SET
#define AN_ADVERTISEMENT1r_SELECTOR_FIELDf_GET BCMI_MADURA_AN_ADVERTISEMENT1r_SELECTOR_FIELDf_GET
#define AN_ADVERTISEMENT1r_SELECTOR_FIELDf_SET BCMI_MADURA_AN_ADVERTISEMENT1r_SELECTOR_FIELDf_SET
#define READ_AN_ADVERTISEMENT1r BCMI_MADURA_READ_AN_ADVERTISEMENT1r
#define WRITE_AN_ADVERTISEMENT1r BCMI_MADURA_WRITE_AN_ADVERTISEMENT1r
#define MODIFY_AN_ADVERTISEMENT1r BCMI_MADURA_MODIFY_AN_ADVERTISEMENT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_ADVERTISEMENT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_ADVERTISEMENT2
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0011
 * DEVAD:    7
 * DESC:     AN Advertisement 2 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRANSMITTED_NONCE transmitted nonce
 *     TECHABILITY      15:14 Reserved for future13 100G CR412 100G KR411 100G KP410 100G CR109 40G CR48 40G KR47 10G KR6 10G KX45  1G KX
 */
#define BCMI_MADURA_AN_ADVERTISEMENT2r (0x00070011 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_ADVERTISEMENT2r_SIZE 4

/*
 * This structure should be used to declare and program AN_ADVERTISEMENT2.
 */
typedef union BCMI_MADURA_AN_ADVERTISEMENT2r_s {
	uint32_t v[1];
	uint32_t an_advertisement2[1];
	uint32_t _an_advertisement2;
} BCMI_MADURA_AN_ADVERTISEMENT2r_t;

#define BCMI_MADURA_AN_ADVERTISEMENT2r_CLR(r) (r).an_advertisement2[0] = 0
#define BCMI_MADURA_AN_ADVERTISEMENT2r_SET(r,d) (r).an_advertisement2[0] = d
#define BCMI_MADURA_AN_ADVERTISEMENT2r_GET(r) (r).an_advertisement2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_ADVERTISEMENT2r_TECHABILITYf_GET(r) ((((r).an_advertisement2[0]) >> 5) & 0x7ff)
#define BCMI_MADURA_AN_ADVERTISEMENT2r_TECHABILITYf_SET(r,f) (r).an_advertisement2[0]=(((r).an_advertisement2[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_MADURA_AN_ADVERTISEMENT2r_TRANSMITTED_NONCEf_GET(r) (((r).an_advertisement2[0]) & 0x1f)
#define BCMI_MADURA_AN_ADVERTISEMENT2r_TRANSMITTED_NONCEf_SET(r,f) (r).an_advertisement2[0]=(((r).an_advertisement2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AN_ADVERTISEMENT2.
 */
#define BCMI_MADURA_READ_AN_ADVERTISEMENT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_ADVERTISEMENT2r,_r._an_advertisement2)
#define BCMI_MADURA_WRITE_AN_ADVERTISEMENT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_ADVERTISEMENT2r,_r._an_advertisement2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_ADVERTISEMENT2r BCMI_MADURA_AN_ADVERTISEMENT2r
#define AN_ADVERTISEMENT2r_SIZE BCMI_MADURA_AN_ADVERTISEMENT2r_SIZE
typedef BCMI_MADURA_AN_ADVERTISEMENT2r_t AN_ADVERTISEMENT2r_t;
#define AN_ADVERTISEMENT2r_CLR BCMI_MADURA_AN_ADVERTISEMENT2r_CLR
#define AN_ADVERTISEMENT2r_SET BCMI_MADURA_AN_ADVERTISEMENT2r_SET
#define AN_ADVERTISEMENT2r_GET BCMI_MADURA_AN_ADVERTISEMENT2r_GET
#define AN_ADVERTISEMENT2r_TECHABILITYf_GET BCMI_MADURA_AN_ADVERTISEMENT2r_TECHABILITYf_GET
#define AN_ADVERTISEMENT2r_TECHABILITYf_SET BCMI_MADURA_AN_ADVERTISEMENT2r_TECHABILITYf_SET
#define AN_ADVERTISEMENT2r_TRANSMITTED_NONCEf_GET BCMI_MADURA_AN_ADVERTISEMENT2r_TRANSMITTED_NONCEf_GET
#define AN_ADVERTISEMENT2r_TRANSMITTED_NONCEf_SET BCMI_MADURA_AN_ADVERTISEMENT2r_TRANSMITTED_NONCEf_SET
#define READ_AN_ADVERTISEMENT2r BCMI_MADURA_READ_AN_ADVERTISEMENT2r
#define WRITE_AN_ADVERTISEMENT2r BCMI_MADURA_WRITE_AN_ADVERTISEMENT2r
#define MODIFY_AN_ADVERTISEMENT2r BCMI_MADURA_MODIFY_AN_ADVERTISEMENT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_ADVERTISEMENT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_ADVERTISEMENT3
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0012
 * DEVAD:    7
 * DESC:     AN Advertisement 3 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_ADV_D45_D32   Advertised abilities D45:D32.
 *     FEC_REQUESTED    15 FEC requested14 FEC ability
 */
#define BCMI_MADURA_AN_ADVERTISEMENT3r (0x00070012 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_ADVERTISEMENT3r_SIZE 4

/*
 * This structure should be used to declare and program AN_ADVERTISEMENT3.
 */
typedef union BCMI_MADURA_AN_ADVERTISEMENT3r_s {
	uint32_t v[1];
	uint32_t an_advertisement3[1];
	uint32_t _an_advertisement3;
} BCMI_MADURA_AN_ADVERTISEMENT3r_t;

#define BCMI_MADURA_AN_ADVERTISEMENT3r_CLR(r) (r).an_advertisement3[0] = 0
#define BCMI_MADURA_AN_ADVERTISEMENT3r_SET(r,d) (r).an_advertisement3[0] = d
#define BCMI_MADURA_AN_ADVERTISEMENT3r_GET(r) (r).an_advertisement3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_ADVERTISEMENT3r_FEC_REQUESTEDf_GET(r) ((((r).an_advertisement3[0]) >> 14) & 0x3)
#define BCMI_MADURA_AN_ADVERTISEMENT3r_FEC_REQUESTEDf_SET(r,f) (r).an_advertisement3[0]=(((r).an_advertisement3[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_MADURA_AN_ADVERTISEMENT3r_AN_ADV_D45_D32f_GET(r) (((r).an_advertisement3[0]) & 0x3fff)
#define BCMI_MADURA_AN_ADVERTISEMENT3r_AN_ADV_D45_D32f_SET(r,f) (r).an_advertisement3[0]=(((r).an_advertisement3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access AN_ADVERTISEMENT3.
 */
#define BCMI_MADURA_READ_AN_ADVERTISEMENT3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_ADVERTISEMENT3r,_r._an_advertisement3)
#define BCMI_MADURA_WRITE_AN_ADVERTISEMENT3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_ADVERTISEMENT3r,_r._an_advertisement3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_ADVERTISEMENT3r BCMI_MADURA_AN_ADVERTISEMENT3r
#define AN_ADVERTISEMENT3r_SIZE BCMI_MADURA_AN_ADVERTISEMENT3r_SIZE
typedef BCMI_MADURA_AN_ADVERTISEMENT3r_t AN_ADVERTISEMENT3r_t;
#define AN_ADVERTISEMENT3r_CLR BCMI_MADURA_AN_ADVERTISEMENT3r_CLR
#define AN_ADVERTISEMENT3r_SET BCMI_MADURA_AN_ADVERTISEMENT3r_SET
#define AN_ADVERTISEMENT3r_GET BCMI_MADURA_AN_ADVERTISEMENT3r_GET
#define AN_ADVERTISEMENT3r_FEC_REQUESTEDf_GET BCMI_MADURA_AN_ADVERTISEMENT3r_FEC_REQUESTEDf_GET
#define AN_ADVERTISEMENT3r_FEC_REQUESTEDf_SET BCMI_MADURA_AN_ADVERTISEMENT3r_FEC_REQUESTEDf_SET
#define AN_ADVERTISEMENT3r_AN_ADV_D45_D32f_GET BCMI_MADURA_AN_ADVERTISEMENT3r_AN_ADV_D45_D32f_GET
#define AN_ADVERTISEMENT3r_AN_ADV_D45_D32f_SET BCMI_MADURA_AN_ADVERTISEMENT3r_AN_ADV_D45_D32f_SET
#define READ_AN_ADVERTISEMENT3r BCMI_MADURA_READ_AN_ADVERTISEMENT3r
#define WRITE_AN_ADVERTISEMENT3r BCMI_MADURA_WRITE_AN_ADVERTISEMENT3r
#define MODIFY_AN_ADVERTISEMENT3r BCMI_MADURA_MODIFY_AN_ADVERTISEMENT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_ADVERTISEMENT3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_LP_BASE_PAGE_ABIL_1
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0013
 * DEVAD:    7
 * DESC:     AN LP Base Page Ability 1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     D15_D0           Link codeword base page ability
 */
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r (0x00070013 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_SIZE 4

/*
 * This structure should be used to declare and program AN_LP_BASE_PAGE_ABIL_1.
 */
typedef union BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_s {
	uint32_t v[1];
	uint32_t an_lp_base_page_abil_1[1];
	uint32_t _an_lp_base_page_abil_1;
} BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_t;

#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_CLR(r) (r).an_lp_base_page_abil_1[0] = 0
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_SET(r,d) (r).an_lp_base_page_abil_1[0] = d
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_GET(r) (r).an_lp_base_page_abil_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_D15_D0f_GET(r) (((r).an_lp_base_page_abil_1[0]) & 0xffff)
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_D15_D0f_SET(r,f) (r).an_lp_base_page_abil_1[0]=(((r).an_lp_base_page_abil_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_LP_BASE_PAGE_ABIL_1.
 */
#define BCMI_MADURA_READ_AN_LP_BASE_PAGE_ABIL_1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r,_r._an_lp_base_page_abil_1)
#define BCMI_MADURA_WRITE_AN_LP_BASE_PAGE_ABIL_1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r,_r._an_lp_base_page_abil_1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_LP_BASE_PAGE_ABIL_1r BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r
#define AN_LP_BASE_PAGE_ABIL_1r_SIZE BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_SIZE
typedef BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_t AN_LP_BASE_PAGE_ABIL_1r_t;
#define AN_LP_BASE_PAGE_ABIL_1r_CLR BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_CLR
#define AN_LP_BASE_PAGE_ABIL_1r_SET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_SET
#define AN_LP_BASE_PAGE_ABIL_1r_GET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_GET
#define AN_LP_BASE_PAGE_ABIL_1r_D15_D0f_GET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_D15_D0f_GET
#define AN_LP_BASE_PAGE_ABIL_1r_D15_D0f_SET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r_D15_D0f_SET
#define READ_AN_LP_BASE_PAGE_ABIL_1r BCMI_MADURA_READ_AN_LP_BASE_PAGE_ABIL_1r
#define WRITE_AN_LP_BASE_PAGE_ABIL_1r BCMI_MADURA_WRITE_AN_LP_BASE_PAGE_ABIL_1r
#define MODIFY_AN_LP_BASE_PAGE_ABIL_1r BCMI_MADURA_MODIFY_AN_LP_BASE_PAGE_ABIL_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_LP_BASE_PAGE_ABIL_2
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0014
 * DEVAD:    7
 * DESC:     AN LP Base Page Ability 2 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     D31_16           Link codeword base page ability
 */
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r (0x00070014 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_SIZE 4

/*
 * This structure should be used to declare and program AN_LP_BASE_PAGE_ABIL_2.
 */
typedef union BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_s {
	uint32_t v[1];
	uint32_t an_lp_base_page_abil_2[1];
	uint32_t _an_lp_base_page_abil_2;
} BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_t;

#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_CLR(r) (r).an_lp_base_page_abil_2[0] = 0
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_SET(r,d) (r).an_lp_base_page_abil_2[0] = d
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_GET(r) (r).an_lp_base_page_abil_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_D31_16f_GET(r) (((r).an_lp_base_page_abil_2[0]) & 0xffff)
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_D31_16f_SET(r,f) (r).an_lp_base_page_abil_2[0]=(((r).an_lp_base_page_abil_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_LP_BASE_PAGE_ABIL_2.
 */
#define BCMI_MADURA_READ_AN_LP_BASE_PAGE_ABIL_2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r,_r._an_lp_base_page_abil_2)
#define BCMI_MADURA_WRITE_AN_LP_BASE_PAGE_ABIL_2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r,_r._an_lp_base_page_abil_2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_LP_BASE_PAGE_ABIL_2r BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r
#define AN_LP_BASE_PAGE_ABIL_2r_SIZE BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_SIZE
typedef BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_t AN_LP_BASE_PAGE_ABIL_2r_t;
#define AN_LP_BASE_PAGE_ABIL_2r_CLR BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_CLR
#define AN_LP_BASE_PAGE_ABIL_2r_SET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_SET
#define AN_LP_BASE_PAGE_ABIL_2r_GET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_GET
#define AN_LP_BASE_PAGE_ABIL_2r_D31_16f_GET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_D31_16f_GET
#define AN_LP_BASE_PAGE_ABIL_2r_D31_16f_SET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r_D31_16f_SET
#define READ_AN_LP_BASE_PAGE_ABIL_2r BCMI_MADURA_READ_AN_LP_BASE_PAGE_ABIL_2r
#define WRITE_AN_LP_BASE_PAGE_ABIL_2r BCMI_MADURA_WRITE_AN_LP_BASE_PAGE_ABIL_2r
#define MODIFY_AN_LP_BASE_PAGE_ABIL_2r BCMI_MADURA_MODIFY_AN_LP_BASE_PAGE_ABIL_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_LP_BASE_PAGE_ABIL_3
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0015
 * DEVAD:    7
 * DESC:     AN LP Base Page Ability 3 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     D47_32           Link codeword base page ability
 */
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r (0x00070015 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_SIZE 4

/*
 * This structure should be used to declare and program AN_LP_BASE_PAGE_ABIL_3.
 */
typedef union BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_s {
	uint32_t v[1];
	uint32_t an_lp_base_page_abil_3[1];
	uint32_t _an_lp_base_page_abil_3;
} BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_t;

#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_CLR(r) (r).an_lp_base_page_abil_3[0] = 0
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_SET(r,d) (r).an_lp_base_page_abil_3[0] = d
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_GET(r) (r).an_lp_base_page_abil_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_D47_32f_GET(r) (((r).an_lp_base_page_abil_3[0]) & 0xffff)
#define BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_D47_32f_SET(r,f) (r).an_lp_base_page_abil_3[0]=(((r).an_lp_base_page_abil_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_LP_BASE_PAGE_ABIL_3.
 */
#define BCMI_MADURA_READ_AN_LP_BASE_PAGE_ABIL_3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r,_r._an_lp_base_page_abil_3)
#define BCMI_MADURA_WRITE_AN_LP_BASE_PAGE_ABIL_3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r,_r._an_lp_base_page_abil_3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_LP_BASE_PAGE_ABIL_3r BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r
#define AN_LP_BASE_PAGE_ABIL_3r_SIZE BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_SIZE
typedef BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_t AN_LP_BASE_PAGE_ABIL_3r_t;
#define AN_LP_BASE_PAGE_ABIL_3r_CLR BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_CLR
#define AN_LP_BASE_PAGE_ABIL_3r_SET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_SET
#define AN_LP_BASE_PAGE_ABIL_3r_GET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_GET
#define AN_LP_BASE_PAGE_ABIL_3r_D47_32f_GET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_D47_32f_GET
#define AN_LP_BASE_PAGE_ABIL_3r_D47_32f_SET BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r_D47_32f_SET
#define READ_AN_LP_BASE_PAGE_ABIL_3r BCMI_MADURA_READ_AN_LP_BASE_PAGE_ABIL_3r
#define WRITE_AN_LP_BASE_PAGE_ABIL_3r BCMI_MADURA_WRITE_AN_LP_BASE_PAGE_ABIL_3r
#define MODIFY_AN_LP_BASE_PAGE_ABIL_3r BCMI_MADURA_MODIFY_AN_LP_BASE_PAGE_ABIL_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_LP_BASE_PAGE_ABIL_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_XNP_TRANSMIT1
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0016
 * DEVAD:    7
 * DESC:     AN XNP transmit 1 Register
 * RESETVAL: 0x2001 (8193)
 * ACCESS:   R/W
 * FIELDS:
 *     MESSAGE_UNFORMATEDCODE_FIELD 
 *     TOGGLE           T bit
 *     ACKNOWLEDGE_2    ACK2 bit
 *     MESSAGE_PAGE     1 = Message next page0 = Unformatted next page
 *     NEXT_PAGE        Engage the device in next pageexchange
 */
#define BCMI_MADURA_AN_XNP_TRANSMIT1r (0x00070016 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_XNP_TRANSMIT1r_SIZE 4

/*
 * This structure should be used to declare and program AN_XNP_TRANSMIT1.
 */
typedef union BCMI_MADURA_AN_XNP_TRANSMIT1r_s {
	uint32_t v[1];
	uint32_t an_xnp_transmit1[1];
	uint32_t _an_xnp_transmit1;
} BCMI_MADURA_AN_XNP_TRANSMIT1r_t;

#define BCMI_MADURA_AN_XNP_TRANSMIT1r_CLR(r) (r).an_xnp_transmit1[0] = 0
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_SET(r,d) (r).an_xnp_transmit1[0] = d
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_GET(r) (r).an_xnp_transmit1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_NEXT_PAGEf_GET(r) ((((r).an_xnp_transmit1[0]) >> 15) & 0x1)
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_NEXT_PAGEf_SET(r,f) (r).an_xnp_transmit1[0]=(((r).an_xnp_transmit1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_PAGEf_GET(r) ((((r).an_xnp_transmit1[0]) >> 13) & 0x1)
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_PAGEf_SET(r,f) (r).an_xnp_transmit1[0]=(((r).an_xnp_transmit1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_GET(r) ((((r).an_xnp_transmit1[0]) >> 12) & 0x1)
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_SET(r,f) (r).an_xnp_transmit1[0]=(((r).an_xnp_transmit1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_TOGGLEf_GET(r) ((((r).an_xnp_transmit1[0]) >> 11) & 0x1)
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_TOGGLEf_SET(r,f) (r).an_xnp_transmit1[0]=(((r).an_xnp_transmit1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_GET(r) (((r).an_xnp_transmit1[0]) & 0x7ff)
#define BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_SET(r,f) (r).an_xnp_transmit1[0]=(((r).an_xnp_transmit1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (0x7ff << 16)

/*
 * These macros can be used to access AN_XNP_TRANSMIT1.
 */
#define BCMI_MADURA_READ_AN_XNP_TRANSMIT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_XNP_TRANSMIT1r,_r._an_xnp_transmit1)
#define BCMI_MADURA_WRITE_AN_XNP_TRANSMIT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_XNP_TRANSMIT1r,_r._an_xnp_transmit1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_XNP_TRANSMIT1r BCMI_MADURA_AN_XNP_TRANSMIT1r
#define AN_XNP_TRANSMIT1r_SIZE BCMI_MADURA_AN_XNP_TRANSMIT1r_SIZE
typedef BCMI_MADURA_AN_XNP_TRANSMIT1r_t AN_XNP_TRANSMIT1r_t;
#define AN_XNP_TRANSMIT1r_CLR BCMI_MADURA_AN_XNP_TRANSMIT1r_CLR
#define AN_XNP_TRANSMIT1r_SET BCMI_MADURA_AN_XNP_TRANSMIT1r_SET
#define AN_XNP_TRANSMIT1r_GET BCMI_MADURA_AN_XNP_TRANSMIT1r_GET
#define AN_XNP_TRANSMIT1r_NEXT_PAGEf_GET BCMI_MADURA_AN_XNP_TRANSMIT1r_NEXT_PAGEf_GET
#define AN_XNP_TRANSMIT1r_NEXT_PAGEf_SET BCMI_MADURA_AN_XNP_TRANSMIT1r_NEXT_PAGEf_SET
#define AN_XNP_TRANSMIT1r_MESSAGE_PAGEf_GET BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_PAGEf_GET
#define AN_XNP_TRANSMIT1r_MESSAGE_PAGEf_SET BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_PAGEf_SET
#define AN_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_GET BCMI_MADURA_AN_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_GET
#define AN_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_SET BCMI_MADURA_AN_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_SET
#define AN_XNP_TRANSMIT1r_TOGGLEf_GET BCMI_MADURA_AN_XNP_TRANSMIT1r_TOGGLEf_GET
#define AN_XNP_TRANSMIT1r_TOGGLEf_SET BCMI_MADURA_AN_XNP_TRANSMIT1r_TOGGLEf_SET
#define AN_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_GET BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_GET
#define AN_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_SET BCMI_MADURA_AN_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_SET
#define READ_AN_XNP_TRANSMIT1r BCMI_MADURA_READ_AN_XNP_TRANSMIT1r
#define WRITE_AN_XNP_TRANSMIT1r BCMI_MADURA_WRITE_AN_XNP_TRANSMIT1r
#define MODIFY_AN_XNP_TRANSMIT1r BCMI_MADURA_MODIFY_AN_XNP_TRANSMIT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_XNP_TRANSMIT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_XNP_TRANSMIT2
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0017
 * DEVAD:    7
 * DESC:     AN XNP transmit 2 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNFORMATED_CODEFIELD_1 
 */
#define BCMI_MADURA_AN_XNP_TRANSMIT2r (0x00070017 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_XNP_TRANSMIT2r_SIZE 4

/*
 * This structure should be used to declare and program AN_XNP_TRANSMIT2.
 */
typedef union BCMI_MADURA_AN_XNP_TRANSMIT2r_s {
	uint32_t v[1];
	uint32_t an_xnp_transmit2[1];
	uint32_t _an_xnp_transmit2;
} BCMI_MADURA_AN_XNP_TRANSMIT2r_t;

#define BCMI_MADURA_AN_XNP_TRANSMIT2r_CLR(r) (r).an_xnp_transmit2[0] = 0
#define BCMI_MADURA_AN_XNP_TRANSMIT2r_SET(r,d) (r).an_xnp_transmit2[0] = d
#define BCMI_MADURA_AN_XNP_TRANSMIT2r_GET(r) (r).an_xnp_transmit2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_GET(r) (((r).an_xnp_transmit2[0]) & 0xffff)
#define BCMI_MADURA_AN_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_SET(r,f) (r).an_xnp_transmit2[0]=(((r).an_xnp_transmit2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_XNP_TRANSMIT2.
 */
#define BCMI_MADURA_READ_AN_XNP_TRANSMIT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_XNP_TRANSMIT2r,_r._an_xnp_transmit2)
#define BCMI_MADURA_WRITE_AN_XNP_TRANSMIT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_XNP_TRANSMIT2r,_r._an_xnp_transmit2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_XNP_TRANSMIT2r BCMI_MADURA_AN_XNP_TRANSMIT2r
#define AN_XNP_TRANSMIT2r_SIZE BCMI_MADURA_AN_XNP_TRANSMIT2r_SIZE
typedef BCMI_MADURA_AN_XNP_TRANSMIT2r_t AN_XNP_TRANSMIT2r_t;
#define AN_XNP_TRANSMIT2r_CLR BCMI_MADURA_AN_XNP_TRANSMIT2r_CLR
#define AN_XNP_TRANSMIT2r_SET BCMI_MADURA_AN_XNP_TRANSMIT2r_SET
#define AN_XNP_TRANSMIT2r_GET BCMI_MADURA_AN_XNP_TRANSMIT2r_GET
#define AN_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_GET BCMI_MADURA_AN_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_GET
#define AN_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_SET BCMI_MADURA_AN_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_SET
#define READ_AN_XNP_TRANSMIT2r BCMI_MADURA_READ_AN_XNP_TRANSMIT2r
#define WRITE_AN_XNP_TRANSMIT2r BCMI_MADURA_WRITE_AN_XNP_TRANSMIT2r
#define MODIFY_AN_XNP_TRANSMIT2r BCMI_MADURA_MODIFY_AN_XNP_TRANSMIT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_XNP_TRANSMIT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_XNP_TRANSMIT3
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0018
 * DEVAD:    7
 * DESC:     AN XNP transmit 3 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNFORMATED_CODEFIELD_3 
 */
#define BCMI_MADURA_AN_XNP_TRANSMIT3r (0x00070018 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_XNP_TRANSMIT3r_SIZE 4

/*
 * This structure should be used to declare and program AN_XNP_TRANSMIT3.
 */
typedef union BCMI_MADURA_AN_XNP_TRANSMIT3r_s {
	uint32_t v[1];
	uint32_t an_xnp_transmit3[1];
	uint32_t _an_xnp_transmit3;
} BCMI_MADURA_AN_XNP_TRANSMIT3r_t;

#define BCMI_MADURA_AN_XNP_TRANSMIT3r_CLR(r) (r).an_xnp_transmit3[0] = 0
#define BCMI_MADURA_AN_XNP_TRANSMIT3r_SET(r,d) (r).an_xnp_transmit3[0] = d
#define BCMI_MADURA_AN_XNP_TRANSMIT3r_GET(r) (r).an_xnp_transmit3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_GET(r) (((r).an_xnp_transmit3[0]) & 0xffff)
#define BCMI_MADURA_AN_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_SET(r,f) (r).an_xnp_transmit3[0]=(((r).an_xnp_transmit3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_XNP_TRANSMIT3.
 */
#define BCMI_MADURA_READ_AN_XNP_TRANSMIT3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_XNP_TRANSMIT3r,_r._an_xnp_transmit3)
#define BCMI_MADURA_WRITE_AN_XNP_TRANSMIT3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_XNP_TRANSMIT3r,_r._an_xnp_transmit3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_XNP_TRANSMIT3r BCMI_MADURA_AN_XNP_TRANSMIT3r
#define AN_XNP_TRANSMIT3r_SIZE BCMI_MADURA_AN_XNP_TRANSMIT3r_SIZE
typedef BCMI_MADURA_AN_XNP_TRANSMIT3r_t AN_XNP_TRANSMIT3r_t;
#define AN_XNP_TRANSMIT3r_CLR BCMI_MADURA_AN_XNP_TRANSMIT3r_CLR
#define AN_XNP_TRANSMIT3r_SET BCMI_MADURA_AN_XNP_TRANSMIT3r_SET
#define AN_XNP_TRANSMIT3r_GET BCMI_MADURA_AN_XNP_TRANSMIT3r_GET
#define AN_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_GET BCMI_MADURA_AN_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_GET
#define AN_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_SET BCMI_MADURA_AN_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_SET
#define READ_AN_XNP_TRANSMIT3r BCMI_MADURA_READ_AN_XNP_TRANSMIT3r
#define WRITE_AN_XNP_TRANSMIT3r BCMI_MADURA_WRITE_AN_XNP_TRANSMIT3r
#define MODIFY_AN_XNP_TRANSMIT3r BCMI_MADURA_MODIFY_AN_XNP_TRANSMIT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_XNP_TRANSMIT3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_LP_XNP_TRANSMIT1
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x0019
 * DEVAD:    7
 * DESC:     AN LP XNP transmit 1 Registe
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MESSAGE_UNFORMATEDCODE_FIELD 
 *     TOGGLE           T bit
 *     ACKNOWLEDGE_2    ACK2 bit
 *     MESSAGE_PAGE     1 = Message next page0 = Unformatted next page
 *     ACKNOWLEDGE      ACK bit
 *     NEXT_PAGE        
 */
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r (0x00070019 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_SIZE 4

/*
 * This structure should be used to declare and program AN_LP_XNP_TRANSMIT1.
 */
typedef union BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_s {
	uint32_t v[1];
	uint32_t an_lp_xnp_transmit1[1];
	uint32_t _an_lp_xnp_transmit1;
} BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_t;

#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_CLR(r) (r).an_lp_xnp_transmit1[0] = 0
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_SET(r,d) (r).an_lp_xnp_transmit1[0] = d
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_GET(r) (r).an_lp_xnp_transmit1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_NEXT_PAGEf_GET(r) ((((r).an_lp_xnp_transmit1[0]) >> 15) & 0x1)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_NEXT_PAGEf_SET(r,f) (r).an_lp_xnp_transmit1[0]=(((r).an_lp_xnp_transmit1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGEf_GET(r) ((((r).an_lp_xnp_transmit1[0]) >> 14) & 0x1)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGEf_SET(r,f) (r).an_lp_xnp_transmit1[0]=(((r).an_lp_xnp_transmit1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_PAGEf_GET(r) ((((r).an_lp_xnp_transmit1[0]) >> 13) & 0x1)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_PAGEf_SET(r,f) (r).an_lp_xnp_transmit1[0]=(((r).an_lp_xnp_transmit1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_GET(r) ((((r).an_lp_xnp_transmit1[0]) >> 12) & 0x1)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_SET(r,f) (r).an_lp_xnp_transmit1[0]=(((r).an_lp_xnp_transmit1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_TOGGLEf_GET(r) ((((r).an_lp_xnp_transmit1[0]) >> 11) & 0x1)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_TOGGLEf_SET(r,f) (r).an_lp_xnp_transmit1[0]=(((r).an_lp_xnp_transmit1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_GET(r) (((r).an_lp_xnp_transmit1[0]) & 0x7ff)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_SET(r,f) (r).an_lp_xnp_transmit1[0]=(((r).an_lp_xnp_transmit1[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (0x7ff << 16)

/*
 * These macros can be used to access AN_LP_XNP_TRANSMIT1.
 */
#define BCMI_MADURA_READ_AN_LP_XNP_TRANSMIT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_LP_XNP_TRANSMIT1r,_r._an_lp_xnp_transmit1)
#define BCMI_MADURA_WRITE_AN_LP_XNP_TRANSMIT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_LP_XNP_TRANSMIT1r,_r._an_lp_xnp_transmit1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_LP_XNP_TRANSMIT1r BCMI_MADURA_AN_LP_XNP_TRANSMIT1r
#define AN_LP_XNP_TRANSMIT1r_SIZE BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_SIZE
typedef BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_t AN_LP_XNP_TRANSMIT1r_t;
#define AN_LP_XNP_TRANSMIT1r_CLR BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_CLR
#define AN_LP_XNP_TRANSMIT1r_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_SET
#define AN_LP_XNP_TRANSMIT1r_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_GET
#define AN_LP_XNP_TRANSMIT1r_NEXT_PAGEf_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_NEXT_PAGEf_GET
#define AN_LP_XNP_TRANSMIT1r_NEXT_PAGEf_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_NEXT_PAGEf_SET
#define AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGEf_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGEf_GET
#define AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGEf_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGEf_SET
#define AN_LP_XNP_TRANSMIT1r_MESSAGE_PAGEf_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_PAGEf_GET
#define AN_LP_XNP_TRANSMIT1r_MESSAGE_PAGEf_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_PAGEf_SET
#define AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_GET
#define AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_ACKNOWLEDGE_2f_SET
#define AN_LP_XNP_TRANSMIT1r_TOGGLEf_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_TOGGLEf_GET
#define AN_LP_XNP_TRANSMIT1r_TOGGLEf_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_TOGGLEf_SET
#define AN_LP_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_GET
#define AN_LP_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT1r_MESSAGE_UNFORMATEDCODE_FIELDf_SET
#define READ_AN_LP_XNP_TRANSMIT1r BCMI_MADURA_READ_AN_LP_XNP_TRANSMIT1r
#define WRITE_AN_LP_XNP_TRANSMIT1r BCMI_MADURA_WRITE_AN_LP_XNP_TRANSMIT1r
#define MODIFY_AN_LP_XNP_TRANSMIT1r BCMI_MADURA_MODIFY_AN_LP_XNP_TRANSMIT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_LP_XNP_TRANSMIT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_LP_XNP_TRANSMIT2
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x001a
 * DEVAD:    7
 * DESC:     AN LP XNP transmit 2 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNFORMATED_CODEFIELD_1 
 */
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT2r (0x0007001a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_SIZE 4

/*
 * This structure should be used to declare and program AN_LP_XNP_TRANSMIT2.
 */
typedef union BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_s {
	uint32_t v[1];
	uint32_t an_lp_xnp_transmit2[1];
	uint32_t _an_lp_xnp_transmit2;
} BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_t;

#define BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_CLR(r) (r).an_lp_xnp_transmit2[0] = 0
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_SET(r,d) (r).an_lp_xnp_transmit2[0] = d
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_GET(r) (r).an_lp_xnp_transmit2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_GET(r) (((r).an_lp_xnp_transmit2[0]) & 0xffff)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_SET(r,f) (r).an_lp_xnp_transmit2[0]=(((r).an_lp_xnp_transmit2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_LP_XNP_TRANSMIT2.
 */
#define BCMI_MADURA_READ_AN_LP_XNP_TRANSMIT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_LP_XNP_TRANSMIT2r,_r._an_lp_xnp_transmit2)
#define BCMI_MADURA_WRITE_AN_LP_XNP_TRANSMIT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_LP_XNP_TRANSMIT2r,_r._an_lp_xnp_transmit2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_LP_XNP_TRANSMIT2r BCMI_MADURA_AN_LP_XNP_TRANSMIT2r
#define AN_LP_XNP_TRANSMIT2r_SIZE BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_SIZE
typedef BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_t AN_LP_XNP_TRANSMIT2r_t;
#define AN_LP_XNP_TRANSMIT2r_CLR BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_CLR
#define AN_LP_XNP_TRANSMIT2r_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_SET
#define AN_LP_XNP_TRANSMIT2r_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_GET
#define AN_LP_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_GET
#define AN_LP_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT2r_UNFORMATED_CODEFIELD_1f_SET
#define READ_AN_LP_XNP_TRANSMIT2r BCMI_MADURA_READ_AN_LP_XNP_TRANSMIT2r
#define WRITE_AN_LP_XNP_TRANSMIT2r BCMI_MADURA_WRITE_AN_LP_XNP_TRANSMIT2r
#define MODIFY_AN_LP_XNP_TRANSMIT2r BCMI_MADURA_MODIFY_AN_LP_XNP_TRANSMIT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_LP_XNP_TRANSMIT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_LP_XNP_TRANSMIT3
 * BLOCKS:   IEEE_AN_BLK1
 * REGADDR:  0x001b
 * DEVAD:    7
 * DESC:     AN LP XNP transmit 3 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNFORMATED_CODEFIELD_3 
 */
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT3r (0x0007001b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_SIZE 4

/*
 * This structure should be used to declare and program AN_LP_XNP_TRANSMIT3.
 */
typedef union BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_s {
	uint32_t v[1];
	uint32_t an_lp_xnp_transmit3[1];
	uint32_t _an_lp_xnp_transmit3;
} BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_t;

#define BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_CLR(r) (r).an_lp_xnp_transmit3[0] = 0
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_SET(r,d) (r).an_lp_xnp_transmit3[0] = d
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_GET(r) (r).an_lp_xnp_transmit3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_GET(r) (((r).an_lp_xnp_transmit3[0]) & 0xffff)
#define BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_SET(r,f) (r).an_lp_xnp_transmit3[0]=(((r).an_lp_xnp_transmit3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_LP_XNP_TRANSMIT3.
 */
#define BCMI_MADURA_READ_AN_LP_XNP_TRANSMIT3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_LP_XNP_TRANSMIT3r,_r._an_lp_xnp_transmit3)
#define BCMI_MADURA_WRITE_AN_LP_XNP_TRANSMIT3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_LP_XNP_TRANSMIT3r,_r._an_lp_xnp_transmit3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_LP_XNP_TRANSMIT3r BCMI_MADURA_AN_LP_XNP_TRANSMIT3r
#define AN_LP_XNP_TRANSMIT3r_SIZE BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_SIZE
typedef BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_t AN_LP_XNP_TRANSMIT3r_t;
#define AN_LP_XNP_TRANSMIT3r_CLR BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_CLR
#define AN_LP_XNP_TRANSMIT3r_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_SET
#define AN_LP_XNP_TRANSMIT3r_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_GET
#define AN_LP_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_GET BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_GET
#define AN_LP_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_SET BCMI_MADURA_AN_LP_XNP_TRANSMIT3r_UNFORMATED_CODEFIELD_3f_SET
#define READ_AN_LP_XNP_TRANSMIT3r BCMI_MADURA_READ_AN_LP_XNP_TRANSMIT3r
#define WRITE_AN_LP_XNP_TRANSMIT3r BCMI_MADURA_WRITE_AN_LP_XNP_TRANSMIT3r
#define MODIFY_AN_LP_XNP_TRANSMIT3r BCMI_MADURA_MODIFY_AN_LP_XNP_TRANSMIT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_LP_XNP_TRANSMIT3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  BACKPLN_ETHERNET_STS
 * BLOCKS:   IEEE_AN_BLK3
 * REGADDR:  0x0030
 * DEVAD:    7
 * DESC:     BPEther Status register
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     BP_AN_ABILITY    If a 1000BASE-KX, 10GBASE-KX4 or10GBASE-KRPHY type is implemented, this bit is setto 1
 *     GIGBASE_KX       1 = PMA/PMD is negotiated to perform1000BASE-KX0 = PMA/PMD is not negotiated toperform 1000BASE-KX
 *     TENGBASE_KX4     1 = PMA/PMD is negotiated to perform10GBASE-KX40 = PMA/PMD is not negotiated toperform 10GBASE-KX4
 *     TENGBASE_KR      1 = PMA/PMD is negotiated to perform10GBASE-KR0 = PMA/PMD is not negotiated toperform 10GBASE-KR
 *     FEC_NEGOTIATED   1 = PMA/PMD is negotiated to perform FEC0 = PMA/PMD is not negotiated to FEC
 *     FORTYGBASE_KR4   1 = PMA/PMD is negotiated to perform40GBASE-KR40 = PMA/PMD is not negotiated toperform 40GBASE-KR4
 *     FORTYGBASE_CR4   1 = PMA/PMD is negotiated to perform40GBASE-CR40 = PMA/PMD is not negotiated toperform 40GBASE-CR4
 *     ONEHUNDREDBASE_CR10 1 = PMA/PMD is negotiated to perform100GBASE-CR100 = PMA/PMD is not negotiated toperform 100GBASE-CR10
 *     ONEHUNDREDBASE_KP4 1 = PMA/PMD is negotiated to perform100GBASE-KP40 = PMA/PMD is not negotiated toperform 100GBASE-KP4
 *     ONEHUNDREDBASE_KR4 1 = PMA/PMD is negotiated to perform100GBASE-KR40 = PMA/PMD is not negotiated toperform 100GBASE-KR4
 *     ONEHUNDREDBASE_CR4 1 = PMA/PMD is negotiated to perform100GBASE-CR40 = PMA/PMD is not negotiated toperform 100GBASE-CR4
 */
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr (0x00070030 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_SIZE 4

/*
 * This structure should be used to declare and program BACKPLN_ETHERNET_STS.
 */
typedef union BCMI_MADURA_BACKPLN_ETHERNET_STSr_s {
	uint32_t v[1];
	uint32_t backpln_ethernet_sts[1];
	uint32_t _backpln_ethernet_sts;
} BCMI_MADURA_BACKPLN_ETHERNET_STSr_t;

#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_CLR(r) (r).backpln_ethernet_sts[0] = 0
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_SET(r,d) (r).backpln_ethernet_sts[0] = d
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_GET(r) (r).backpln_ethernet_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR4f_GET(r) ((((r).backpln_ethernet_sts[0]) >> 11) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR4f_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KR4f_GET(r) ((((r).backpln_ethernet_sts[0]) >> 10) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KR4f_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KP4f_GET(r) ((((r).backpln_ethernet_sts[0]) >> 9) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KP4f_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR10f_GET(r) ((((r).backpln_ethernet_sts[0]) >> 8) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR10f_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_CR4f_GET(r) ((((r).backpln_ethernet_sts[0]) >> 6) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_CR4f_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_KR4f_GET(r) ((((r).backpln_ethernet_sts[0]) >> 5) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_KR4f_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_FEC_NEGOTIATEDf_GET(r) ((((r).backpln_ethernet_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_FEC_NEGOTIATEDf_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KRf_GET(r) ((((r).backpln_ethernet_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KRf_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KX4f_GET(r) ((((r).backpln_ethernet_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KX4f_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_GIGBASE_KXf_GET(r) ((((r).backpln_ethernet_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_GIGBASE_KXf_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_BP_AN_ABILITYf_GET(r) (((r).backpln_ethernet_sts[0]) & 0x1)
#define BCMI_MADURA_BACKPLN_ETHERNET_STSr_BP_AN_ABILITYf_SET(r,f) (r).backpln_ethernet_sts[0]=(((r).backpln_ethernet_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access BACKPLN_ETHERNET_STS.
 */
#define BCMI_MADURA_READ_BACKPLN_ETHERNET_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_BACKPLN_ETHERNET_STSr,_r._backpln_ethernet_sts)
#define BCMI_MADURA_WRITE_BACKPLN_ETHERNET_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_BACKPLN_ETHERNET_STSr,_r._backpln_ethernet_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define BACKPLN_ETHERNET_STSr BCMI_MADURA_BACKPLN_ETHERNET_STSr
#define BACKPLN_ETHERNET_STSr_SIZE BCMI_MADURA_BACKPLN_ETHERNET_STSr_SIZE
typedef BCMI_MADURA_BACKPLN_ETHERNET_STSr_t BACKPLN_ETHERNET_STSr_t;
#define BACKPLN_ETHERNET_STSr_CLR BCMI_MADURA_BACKPLN_ETHERNET_STSr_CLR
#define BACKPLN_ETHERNET_STSr_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_SET
#define BACKPLN_ETHERNET_STSr_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_GET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR4f_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR4f_GET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR4f_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR4f_SET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KR4f_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KR4f_GET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KR4f_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KR4f_SET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KP4f_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KP4f_GET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KP4f_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_KP4f_SET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR10f_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR10f_GET
#define BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR10f_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_ONEHUNDREDBASE_CR10f_SET
#define BACKPLN_ETHERNET_STSr_FORTYGBASE_CR4f_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_CR4f_GET
#define BACKPLN_ETHERNET_STSr_FORTYGBASE_CR4f_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_CR4f_SET
#define BACKPLN_ETHERNET_STSr_FORTYGBASE_KR4f_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_KR4f_GET
#define BACKPLN_ETHERNET_STSr_FORTYGBASE_KR4f_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_FORTYGBASE_KR4f_SET
#define BACKPLN_ETHERNET_STSr_FEC_NEGOTIATEDf_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_FEC_NEGOTIATEDf_GET
#define BACKPLN_ETHERNET_STSr_FEC_NEGOTIATEDf_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_FEC_NEGOTIATEDf_SET
#define BACKPLN_ETHERNET_STSr_TENGBASE_KRf_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KRf_GET
#define BACKPLN_ETHERNET_STSr_TENGBASE_KRf_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KRf_SET
#define BACKPLN_ETHERNET_STSr_TENGBASE_KX4f_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KX4f_GET
#define BACKPLN_ETHERNET_STSr_TENGBASE_KX4f_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_TENGBASE_KX4f_SET
#define BACKPLN_ETHERNET_STSr_GIGBASE_KXf_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_GIGBASE_KXf_GET
#define BACKPLN_ETHERNET_STSr_GIGBASE_KXf_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_GIGBASE_KXf_SET
#define BACKPLN_ETHERNET_STSr_BP_AN_ABILITYf_GET BCMI_MADURA_BACKPLN_ETHERNET_STSr_BP_AN_ABILITYf_GET
#define BACKPLN_ETHERNET_STSr_BP_AN_ABILITYf_SET BCMI_MADURA_BACKPLN_ETHERNET_STSr_BP_AN_ABILITYf_SET
#define READ_BACKPLN_ETHERNET_STSr BCMI_MADURA_READ_BACKPLN_ETHERNET_STSr
#define WRITE_BACKPLN_ETHERNET_STSr BCMI_MADURA_WRITE_BACKPLN_ETHERNET_STSr
#define MODIFY_BACKPLN_ETHERNET_STSr BCMI_MADURA_MODIFY_BACKPLN_ETHERNET_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_BACKPLN_ETHERNET_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EEE_ADV
 * BLOCKS:   IEEE_AN_BLK3
 * REGADDR:  0x003c
 * DEVAD:    7
 * DESC:     anEEE ADV control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_1G_KX        1 = EEE is supported for 1000BASE-KX.0 = EEE is not supported for 1000BASE-KX.
 *     EEE_10G_KX4      1 = EEE is supported for 10GBASE-KX4.0 = EEE is not supported for 10GBASE-KX4.
 *     EEE_10G_KR       1 = EEE is supported for 10GBASE-KR.0 = EEE is not supported for 10GBASE-KR.
 */
#define BCMI_MADURA_EEE_ADVr (0x0007003c | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EEE_ADVr_SIZE 4

/*
 * This structure should be used to declare and program EEE_ADV.
 */
typedef union BCMI_MADURA_EEE_ADVr_s {
	uint32_t v[1];
	uint32_t eee_adv[1];
	uint32_t _eee_adv;
} BCMI_MADURA_EEE_ADVr_t;

#define BCMI_MADURA_EEE_ADVr_CLR(r) (r).eee_adv[0] = 0
#define BCMI_MADURA_EEE_ADVr_SET(r,d) (r).eee_adv[0] = d
#define BCMI_MADURA_EEE_ADVr_GET(r) (r).eee_adv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EEE_ADVr_EEE_10G_KRf_GET(r) ((((r).eee_adv[0]) >> 6) & 0x1)
#define BCMI_MADURA_EEE_ADVr_EEE_10G_KRf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_EEE_ADVr_EEE_10G_KX4f_GET(r) ((((r).eee_adv[0]) >> 5) & 0x1)
#define BCMI_MADURA_EEE_ADVr_EEE_10G_KX4f_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_EEE_ADVr_EEE_1G_KXf_GET(r) ((((r).eee_adv[0]) >> 4) & 0x1)
#define BCMI_MADURA_EEE_ADVr_EEE_1G_KXf_SET(r,f) (r).eee_adv[0]=(((r).eee_adv[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access EEE_ADV.
 */
#define BCMI_MADURA_READ_EEE_ADVr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EEE_ADVr,_r._eee_adv)
#define BCMI_MADURA_WRITE_EEE_ADVr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EEE_ADVr,_r._eee_adv)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EEE_ADVr BCMI_MADURA_EEE_ADVr
#define EEE_ADVr_SIZE BCMI_MADURA_EEE_ADVr_SIZE
typedef BCMI_MADURA_EEE_ADVr_t EEE_ADVr_t;
#define EEE_ADVr_CLR BCMI_MADURA_EEE_ADVr_CLR
#define EEE_ADVr_SET BCMI_MADURA_EEE_ADVr_SET
#define EEE_ADVr_GET BCMI_MADURA_EEE_ADVr_GET
#define EEE_ADVr_EEE_10G_KRf_GET BCMI_MADURA_EEE_ADVr_EEE_10G_KRf_GET
#define EEE_ADVr_EEE_10G_KRf_SET BCMI_MADURA_EEE_ADVr_EEE_10G_KRf_SET
#define EEE_ADVr_EEE_10G_KX4f_GET BCMI_MADURA_EEE_ADVr_EEE_10G_KX4f_GET
#define EEE_ADVr_EEE_10G_KX4f_SET BCMI_MADURA_EEE_ADVr_EEE_10G_KX4f_SET
#define EEE_ADVr_EEE_1G_KXf_GET BCMI_MADURA_EEE_ADVr_EEE_1G_KXf_GET
#define EEE_ADVr_EEE_1G_KXf_SET BCMI_MADURA_EEE_ADVr_EEE_1G_KXf_SET
#define READ_EEE_ADVr BCMI_MADURA_READ_EEE_ADVr
#define WRITE_EEE_ADVr BCMI_MADURA_WRITE_EEE_ADVr
#define MODIFY_EEE_ADVr BCMI_MADURA_MODIFY_EEE_ADVr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EEE_ADVr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  EEE_LP_ADV
 * BLOCKS:   IEEE_AN_BLK3
 * REGADDR:  0x003d
 * DEVAD:    7
 * DESC:     anEEE LP ADV Status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_1G_KX        1 = LP is able to support EEE for 1000BASE-KX.0 = LP is not able to support EEE  for 1000BASE-KX.
 *     EEE_10G_KX4      1 = LP is able to support EEE for 10GBASE-KX4.0 = LP is not able to support EEE  for 10GBASE-KX4.
 *     EEE_10G_KR       1 = LP is able to support EEE for 10GBASE-KR.0 = LP is not able to support EEE  for 10GBASE-KR.
 */
#define BCMI_MADURA_EEE_LP_ADVr (0x0007003d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_EEE_LP_ADVr_SIZE 4

/*
 * This structure should be used to declare and program EEE_LP_ADV.
 */
typedef union BCMI_MADURA_EEE_LP_ADVr_s {
	uint32_t v[1];
	uint32_t eee_lp_adv[1];
	uint32_t _eee_lp_adv;
} BCMI_MADURA_EEE_LP_ADVr_t;

#define BCMI_MADURA_EEE_LP_ADVr_CLR(r) (r).eee_lp_adv[0] = 0
#define BCMI_MADURA_EEE_LP_ADVr_SET(r,d) (r).eee_lp_adv[0] = d
#define BCMI_MADURA_EEE_LP_ADVr_GET(r) (r).eee_lp_adv[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KRf_GET(r) ((((r).eee_lp_adv[0]) >> 6) & 0x1)
#define BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KRf_SET(r,f) (r).eee_lp_adv[0]=(((r).eee_lp_adv[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KX4f_GET(r) ((((r).eee_lp_adv[0]) >> 5) & 0x1)
#define BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KX4f_SET(r,f) (r).eee_lp_adv[0]=(((r).eee_lp_adv[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_EEE_LP_ADVr_EEE_1G_KXf_GET(r) ((((r).eee_lp_adv[0]) >> 4) & 0x1)
#define BCMI_MADURA_EEE_LP_ADVr_EEE_1G_KXf_SET(r,f) (r).eee_lp_adv[0]=(((r).eee_lp_adv[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access EEE_LP_ADV.
 */
#define BCMI_MADURA_READ_EEE_LP_ADVr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_EEE_LP_ADVr,_r._eee_lp_adv)
#define BCMI_MADURA_WRITE_EEE_LP_ADVr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_EEE_LP_ADVr,_r._eee_lp_adv)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define EEE_LP_ADVr BCMI_MADURA_EEE_LP_ADVr
#define EEE_LP_ADVr_SIZE BCMI_MADURA_EEE_LP_ADVr_SIZE
typedef BCMI_MADURA_EEE_LP_ADVr_t EEE_LP_ADVr_t;
#define EEE_LP_ADVr_CLR BCMI_MADURA_EEE_LP_ADVr_CLR
#define EEE_LP_ADVr_SET BCMI_MADURA_EEE_LP_ADVr_SET
#define EEE_LP_ADVr_GET BCMI_MADURA_EEE_LP_ADVr_GET
#define EEE_LP_ADVr_EEE_10G_KRf_GET BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KRf_GET
#define EEE_LP_ADVr_EEE_10G_KRf_SET BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KRf_SET
#define EEE_LP_ADVr_EEE_10G_KX4f_GET BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KX4f_GET
#define EEE_LP_ADVr_EEE_10G_KX4f_SET BCMI_MADURA_EEE_LP_ADVr_EEE_10G_KX4f_SET
#define EEE_LP_ADVr_EEE_1G_KXf_GET BCMI_MADURA_EEE_LP_ADVr_EEE_1G_KXf_GET
#define EEE_LP_ADVr_EEE_1G_KXf_SET BCMI_MADURA_EEE_LP_ADVr_EEE_1G_KXf_SET
#define READ_EEE_LP_ADVr BCMI_MADURA_READ_EEE_LP_ADVr
#define WRITE_EEE_LP_ADVr BCMI_MADURA_WRITE_EEE_LP_ADVr
#define MODIFY_EEE_LP_ADVr BCMI_MADURA_MODIFY_EEE_LP_ADVr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_EEE_LP_ADVr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_SLICE
 * BLOCKS:   DEV7_SLICE
 * REGADDR:  0x8000
 * DEVAD:    7
 * DESC:     AN_SLICE_REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_SEL         Set unicast/multicast/broadcast by setting 1 for the corresponding lane(s)4'b0001 - Unicast lane 04'b0010 - Unicast lane 14'b0100 - Unicast lane 24'b1000 - Unicast lane 34'b0011 - Multicast lanes 0,14'b1100 - Multicast lanes 2,34'b1111 - Broadcast lanes 0,1,2,3
 *     PORT_SEL         Madura Port Select3'b000 - Port 03'b001 - Port 13'b010 - Port 23'b011 - Port 33'b100 - Port 43'b101 - Port 53'b110 - Port 63'b111 - Port 7NOTE1: For a port-based access, bits 11:8 and 3:0 of slice register should be set to zeroes. Please see NOTE2 for an exception to this ruleNOTE2: For an AN port-based access, bits 11:10 will have to be setto choose line/system side AN
 *     REG_TYPE_SEL     Register Type Select1'b0 - IEEE PMD (port based) OR Falcon/Falcon-IF/DP (lane based)1'b1 - AN (IEEE/Non-IEEE) (port based)
 *     SLICE_0_SEL      Slice 0 / Lower Slice Select1'b0 - Slice 0 / Lower 100g Slice (related to lanes 0-3) not selected1'b1 - Slice 0 /Lower 100g Slice (related to lanes 0-3) selected
 *     SLICE_1_SEL      Slice 1 / Upper Slice Select1'b0 - Slice 1 / Upper 100g Slice (related to lanes 4-7) not selected1'b1 - Slice 1 / Upper 100g Slice (related to lanes 4-7) selected
 *     SYS_SEL          System Side Side Select1'b0 - System Side not selected1'b1 - System Side selected
 *     LIN_SEL          Line Side Select1'b0 - Line Side not selected1'b1 - Line Side selected
 *     PLL_SEL          Core/PLL number.This is used to address the PLL and core registers associated with the PLLif there are multiple PLLs in this core. Registers that are not replicatedper core/PLL will not use these bits in their decode. Pll/falcon core select
 */
#define BCMI_MADURA_AN_SLICEr (0x00078000 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_SLICEr_SIZE 4

/*
 * This structure should be used to declare and program AN_SLICE.
 */
typedef union BCMI_MADURA_AN_SLICEr_s {
	uint32_t v[1];
	uint32_t an_slice[1];
	uint32_t _an_slice;
} BCMI_MADURA_AN_SLICEr_t;

#define BCMI_MADURA_AN_SLICEr_CLR(r) (r).an_slice[0] = 0
#define BCMI_MADURA_AN_SLICEr_SET(r,d) (r).an_slice[0] = d
#define BCMI_MADURA_AN_SLICEr_GET(r) (r).an_slice[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_SLICEr_PLL_SELf_GET(r) ((((r).an_slice[0]) >> 12) & 0x1)
#define BCMI_MADURA_AN_SLICEr_PLL_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_AN_SLICEr_LIN_SELf_GET(r) ((((r).an_slice[0]) >> 11) & 0x1)
#define BCMI_MADURA_AN_SLICEr_LIN_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_AN_SLICEr_SYS_SELf_GET(r) ((((r).an_slice[0]) >> 10) & 0x1)
#define BCMI_MADURA_AN_SLICEr_SYS_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_AN_SLICEr_SLICE_1_SELf_GET(r) ((((r).an_slice[0]) >> 9) & 0x1)
#define BCMI_MADURA_AN_SLICEr_SLICE_1_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_AN_SLICEr_SLICE_0_SELf_GET(r) ((((r).an_slice[0]) >> 8) & 0x1)
#define BCMI_MADURA_AN_SLICEr_SLICE_0_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_AN_SLICEr_REG_TYPE_SELf_GET(r) ((((r).an_slice[0]) >> 7) & 0x1)
#define BCMI_MADURA_AN_SLICEr_REG_TYPE_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_AN_SLICEr_PORT_SELf_GET(r) ((((r).an_slice[0]) >> 4) & 0x7)
#define BCMI_MADURA_AN_SLICEr_PORT_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_MADURA_AN_SLICEr_LANE_SELf_GET(r) (((r).an_slice[0]) & 0xf)
#define BCMI_MADURA_AN_SLICEr_LANE_SELf_SET(r,f) (r).an_slice[0]=(((r).an_slice[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AN_SLICE.
 */
#define BCMI_MADURA_READ_AN_SLICEr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_SLICEr,_r._an_slice)
#define BCMI_MADURA_WRITE_AN_SLICEr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_SLICEr,_r._an_slice)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_SLICEr BCMI_MADURA_AN_SLICEr
#define AN_SLICEr_SIZE BCMI_MADURA_AN_SLICEr_SIZE
typedef BCMI_MADURA_AN_SLICEr_t AN_SLICEr_t;
#define AN_SLICEr_CLR BCMI_MADURA_AN_SLICEr_CLR
#define AN_SLICEr_SET BCMI_MADURA_AN_SLICEr_SET
#define AN_SLICEr_GET BCMI_MADURA_AN_SLICEr_GET
#define AN_SLICEr_PLL_SELf_GET BCMI_MADURA_AN_SLICEr_PLL_SELf_GET
#define AN_SLICEr_PLL_SELf_SET BCMI_MADURA_AN_SLICEr_PLL_SELf_SET
#define AN_SLICEr_LIN_SELf_GET BCMI_MADURA_AN_SLICEr_LIN_SELf_GET
#define AN_SLICEr_LIN_SELf_SET BCMI_MADURA_AN_SLICEr_LIN_SELf_SET
#define AN_SLICEr_SYS_SELf_GET BCMI_MADURA_AN_SLICEr_SYS_SELf_GET
#define AN_SLICEr_SYS_SELf_SET BCMI_MADURA_AN_SLICEr_SYS_SELf_SET
#define AN_SLICEr_SLICE_1_SELf_GET BCMI_MADURA_AN_SLICEr_SLICE_1_SELf_GET
#define AN_SLICEr_SLICE_1_SELf_SET BCMI_MADURA_AN_SLICEr_SLICE_1_SELf_SET
#define AN_SLICEr_SLICE_0_SELf_GET BCMI_MADURA_AN_SLICEr_SLICE_0_SELf_GET
#define AN_SLICEr_SLICE_0_SELf_SET BCMI_MADURA_AN_SLICEr_SLICE_0_SELf_SET
#define AN_SLICEr_REG_TYPE_SELf_GET BCMI_MADURA_AN_SLICEr_REG_TYPE_SELf_GET
#define AN_SLICEr_REG_TYPE_SELf_SET BCMI_MADURA_AN_SLICEr_REG_TYPE_SELf_SET
#define AN_SLICEr_PORT_SELf_GET BCMI_MADURA_AN_SLICEr_PORT_SELf_GET
#define AN_SLICEr_PORT_SELf_SET BCMI_MADURA_AN_SLICEr_PORT_SELf_SET
#define AN_SLICEr_LANE_SELf_GET BCMI_MADURA_AN_SLICEr_LANE_SELf_GET
#define AN_SLICEr_LANE_SELf_SET BCMI_MADURA_AN_SLICEr_LANE_SELf_SET
#define READ_AN_SLICEr BCMI_MADURA_READ_AN_SLICEr
#define WRITE_AN_SLICEr BCMI_MADURA_WRITE_AN_SLICEr
#define MODIFY_AN_SLICEr BCMI_MADURA_MODIFY_AN_SLICEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_SLICEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANATXASTS
 * BLOCKS:   TX_ANA_REGS
 * REGADDR:  0xc080
 * DEVAD:    7
 * DESC:     TX ANA Status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_DP_TX_RST When this bit is set, indicates CL73 TX DME and 1G bit repeaters are under reset
 */
#define BCMI_MADURA_ANATXASTSr (0x0007c080 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANATXASTSr_SIZE 4

/*
 * This structure should be used to declare and program ANATXASTS.
 */
typedef union BCMI_MADURA_ANATXASTSr_s {
	uint32_t v[1];
	uint32_t anatxasts[1];
	uint32_t _anatxasts;
} BCMI_MADURA_ANATXASTSr_t;

#define BCMI_MADURA_ANATXASTSr_CLR(r) (r).anatxasts[0] = 0
#define BCMI_MADURA_ANATXASTSr_SET(r,d) (r).anatxasts[0] = d
#define BCMI_MADURA_ANATXASTSr_GET(r) (r).anatxasts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANATXASTSr_PMD_LN_DP_TX_RSTf_GET(r) ((((r).anatxasts[0]) >> 3) & 0x1)
#define BCMI_MADURA_ANATXASTSr_PMD_LN_DP_TX_RSTf_SET(r,f) (r).anatxasts[0]=(((r).anatxasts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))

/*
 * These macros can be used to access ANATXASTS.
 */
#define BCMI_MADURA_READ_ANATXASTSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANATXASTSr,_r._anatxasts)
#define BCMI_MADURA_WRITE_ANATXASTSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANATXASTSr,_r._anatxasts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANATXASTSr BCMI_MADURA_ANATXASTSr
#define ANATXASTSr_SIZE BCMI_MADURA_ANATXASTSr_SIZE
typedef BCMI_MADURA_ANATXASTSr_t ANATXASTSr_t;
#define ANATXASTSr_CLR BCMI_MADURA_ANATXASTSr_CLR
#define ANATXASTSr_SET BCMI_MADURA_ANATXASTSr_SET
#define ANATXASTSr_GET BCMI_MADURA_ANATXASTSr_GET
#define ANATXASTSr_PMD_LN_DP_TX_RSTf_GET BCMI_MADURA_ANATXASTSr_PMD_LN_DP_TX_RSTf_GET
#define ANATXASTSr_PMD_LN_DP_TX_RSTf_SET BCMI_MADURA_ANATXASTSr_PMD_LN_DP_TX_RSTf_SET
#define READ_ANATXASTSr BCMI_MADURA_READ_ANATXASTSr
#define WRITE_ANATXASTSr BCMI_MADURA_WRITE_ANATXASTSr
#define MODIFY_ANATXASTSr BCMI_MADURA_MODIFY_ANATXASTSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANATXASTSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANATXACTL0
 * BLOCKS:   TX_ANA_REGS
 * REGADDR:  0xc081
 * DEVAD:    7
 * DESC:     TX ANA Control 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCK_DME_EN_SM   Forces on Tx DME clock.
 *     RG_MODE_16P5     CL73 TX bit repetition control1 - 16p5 (for 40G)0 - 20p625 (for 100G)
 */
#define BCMI_MADURA_ANATXACTL0r (0x0007c081 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANATXACTL0r_SIZE 4

/*
 * This structure should be used to declare and program ANATXACTL0.
 */
typedef union BCMI_MADURA_ANATXACTL0r_s {
	uint32_t v[1];
	uint32_t anatxactl0[1];
	uint32_t _anatxactl0;
} BCMI_MADURA_ANATXACTL0r_t;

#define BCMI_MADURA_ANATXACTL0r_CLR(r) (r).anatxactl0[0] = 0
#define BCMI_MADURA_ANATXACTL0r_SET(r,d) (r).anatxactl0[0] = d
#define BCMI_MADURA_ANATXACTL0r_GET(r) (r).anatxactl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANATXACTL0r_RG_MODE_16P5f_GET(r) ((((r).anatxactl0[0]) >> 14) & 0x1)
#define BCMI_MADURA_ANATXACTL0r_RG_MODE_16P5f_SET(r,f) (r).anatxactl0[0]=(((r).anatxactl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_ANATXACTL0r_TXCK_DME_EN_SMf_GET(r) ((((r).anatxactl0[0]) >> 10) & 0x1)
#define BCMI_MADURA_ANATXACTL0r_TXCK_DME_EN_SMf_SET(r,f) (r).anatxactl0[0]=(((r).anatxactl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))

/*
 * These macros can be used to access ANATXACTL0.
 */
#define BCMI_MADURA_READ_ANATXACTL0r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANATXACTL0r,_r._anatxactl0)
#define BCMI_MADURA_WRITE_ANATXACTL0r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANATXACTL0r,_r._anatxactl0)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANATXACTL0r BCMI_MADURA_ANATXACTL0r
#define ANATXACTL0r_SIZE BCMI_MADURA_ANATXACTL0r_SIZE
typedef BCMI_MADURA_ANATXACTL0r_t ANATXACTL0r_t;
#define ANATXACTL0r_CLR BCMI_MADURA_ANATXACTL0r_CLR
#define ANATXACTL0r_SET BCMI_MADURA_ANATXACTL0r_SET
#define ANATXACTL0r_GET BCMI_MADURA_ANATXACTL0r_GET
#define ANATXACTL0r_RG_MODE_16P5f_GET BCMI_MADURA_ANATXACTL0r_RG_MODE_16P5f_GET
#define ANATXACTL0r_RG_MODE_16P5f_SET BCMI_MADURA_ANATXACTL0r_RG_MODE_16P5f_SET
#define ANATXACTL0r_TXCK_DME_EN_SMf_GET BCMI_MADURA_ANATXACTL0r_TXCK_DME_EN_SMf_GET
#define ANATXACTL0r_TXCK_DME_EN_SMf_SET BCMI_MADURA_ANATXACTL0r_TXCK_DME_EN_SMf_SET
#define READ_ANATXACTL0r BCMI_MADURA_READ_ANATXACTL0r
#define WRITE_ANATXACTL0r BCMI_MADURA_WRITE_ANATXACTL0r
#define MODIFY_ANATXACTL0r BCMI_MADURA_MODIFY_ANATXACTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANATXACTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANATXACTL6
 * BLOCKS:   TX_ANA_REGS
 * REGADDR:  0xc08a
 * DEVAD:    7
 * DESC:     TX Control 6 register (NOT USED)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASER_PATGEN_SEL When set selects the 10G Base-R Pattern Generator data output (to the analog serializer)
 *     IDLE_FAULT_SEL   Base-R Pattern Generator pattern select: 2'd0: IDLE; 2'd1: LF; 2'd2: RF; 2'd3: Idle w/ invalid SHB
 *     BASER_PATGEN_EN  When set enables clock and releases reset to the 10G Base-R Pattern Generator
 */
#define BCMI_MADURA_ANATXACTL6r (0x0007c08a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANATXACTL6r_SIZE 4

/*
 * This structure should be used to declare and program ANATXACTL6.
 */
typedef union BCMI_MADURA_ANATXACTL6r_s {
	uint32_t v[1];
	uint32_t anatxactl6[1];
	uint32_t _anatxactl6;
} BCMI_MADURA_ANATXACTL6r_t;

#define BCMI_MADURA_ANATXACTL6r_CLR(r) (r).anatxactl6[0] = 0
#define BCMI_MADURA_ANATXACTL6r_SET(r,d) (r).anatxactl6[0] = d
#define BCMI_MADURA_ANATXACTL6r_GET(r) (r).anatxactl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_ENf_GET(r) ((((r).anatxactl6[0]) >> 15) & 0x1)
#define BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_ENf_SET(r,f) (r).anatxactl6[0]=(((r).anatxactl6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_ANATXACTL6r_IDLE_FAULT_SELf_GET(r) ((((r).anatxactl6[0]) >> 13) & 0x3)
#define BCMI_MADURA_ANATXACTL6r_IDLE_FAULT_SELf_SET(r,f) (r).anatxactl6[0]=(((r).anatxactl6[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_SELf_GET(r) ((((r).anatxactl6[0]) >> 12) & 0x1)
#define BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_SELf_SET(r,f) (r).anatxactl6[0]=(((r).anatxactl6[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))

/*
 * These macros can be used to access ANATXACTL6.
 */
#define BCMI_MADURA_READ_ANATXACTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANATXACTL6r,_r._anatxactl6)
#define BCMI_MADURA_WRITE_ANATXACTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANATXACTL6r,_r._anatxactl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANATXACTL6r BCMI_MADURA_ANATXACTL6r
#define ANATXACTL6r_SIZE BCMI_MADURA_ANATXACTL6r_SIZE
typedef BCMI_MADURA_ANATXACTL6r_t ANATXACTL6r_t;
#define ANATXACTL6r_CLR BCMI_MADURA_ANATXACTL6r_CLR
#define ANATXACTL6r_SET BCMI_MADURA_ANATXACTL6r_SET
#define ANATXACTL6r_GET BCMI_MADURA_ANATXACTL6r_GET
#define ANATXACTL6r_BASER_PATGEN_ENf_GET BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_ENf_GET
#define ANATXACTL6r_BASER_PATGEN_ENf_SET BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_ENf_SET
#define ANATXACTL6r_IDLE_FAULT_SELf_GET BCMI_MADURA_ANATXACTL6r_IDLE_FAULT_SELf_GET
#define ANATXACTL6r_IDLE_FAULT_SELf_SET BCMI_MADURA_ANATXACTL6r_IDLE_FAULT_SELf_SET
#define ANATXACTL6r_BASER_PATGEN_SELf_GET BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_SELf_GET
#define ANATXACTL6r_BASER_PATGEN_SELf_SET BCMI_MADURA_ANATXACTL6r_BASER_PATGEN_SELf_SET
#define READ_ANATXACTL6r BCMI_MADURA_READ_ANATXACTL6r
#define WRITE_ANATXACTL6r BCMI_MADURA_WRITE_ANATXACTL6r
#define MODIFY_ANATXACTL6r BCMI_MADURA_MODIFY_ANATXACTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANATXACTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANATXACTL7
 * BLOCKS:   TX_ANA_REGS
 * REGADDR:  0xc08b
 * DEVAD:    7
 * DESC:     TX Control 7 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_SQUELCH_FORCE_VAL_SM When tx_squelch_force_en_SM is set the assertion oftx_squelch_force_val_SM squelches the Serdes Txoutput by forcing 'd0 at Serdes TX data_in.Active high.
 *     TX_SQUELCH_FORCE_EN_SM When set enables tx_squelch_force_val_SM.Active high.
 *     TX_DISABLE_FORCE_VAL_SM When tx_disable_force_en_SM is set the assertion oftx_disable_force_val_SM disables Serdes TXby asserting pmd_tx_disable.Active high.
 *     TX_DISABLE_FORCE_EN_SM When set enables tx_disable_force_val_SM.Active high.
 *     TX_DISABLE_AN_GOOD_SM When set determines the value ofpmd_tx_disable to serdes, when the Clause 73 fsm is ineither the AN_GOOD_CHECK or AN_GOOD states.Active high.
 *     PMD_LN_TX_H_PWRDN_ENB_SM PMA/PMD powerdown force enable.When set to 1'b0 the CL73 TX DME & 1G repeater resets and clock to CL73 TX DMEis controlled via pmd_ln_tx_h_pwrdn_val_SM.Active low.
 *     PMD_LN_TX_H_PWRDN_VAL_SM When pmd_ln_tx_h_pwrdn_enb_SM is set to 1'b0 the assertionof pmd_ln_tx_h_pwrdn_val_SM resets CL73 TX DMEand 1G bit repeaters and also gates the clock to CL73 TX DME"Active high.
 *     PMD_LN_DP_TX_RST_SM When set forces Tx DME Slice data path into reset.Does not affect mdio reg's or Serdes core resets.Active high.
 */
#define BCMI_MADURA_ANATXACTL7r (0x0007c08b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANATXACTL7r_SIZE 4

/*
 * This structure should be used to declare and program ANATXACTL7.
 */
typedef union BCMI_MADURA_ANATXACTL7r_s {
	uint32_t v[1];
	uint32_t anatxactl7[1];
	uint32_t _anatxactl7;
} BCMI_MADURA_ANATXACTL7r_t;

#define BCMI_MADURA_ANATXACTL7r_CLR(r) (r).anatxactl7[0] = 0
#define BCMI_MADURA_ANATXACTL7r_SET(r,d) (r).anatxactl7[0] = d
#define BCMI_MADURA_ANATXACTL7r_GET(r) (r).anatxactl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANATXACTL7r_PMD_LN_DP_TX_RST_SMf_GET(r) ((((r).anatxactl7[0]) >> 10) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_PMD_LN_DP_TX_RST_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_VAL_SMf_GET(r) ((((r).anatxactl7[0]) >> 9) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_VAL_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_ENB_SMf_GET(r) ((((r).anatxactl7[0]) >> 8) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_ENB_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_ANATXACTL7r_TX_DISABLE_AN_GOOD_SMf_GET(r) ((((r).anatxactl7[0]) >> 4) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_TX_DISABLE_AN_GOOD_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_EN_SMf_GET(r) ((((r).anatxactl7[0]) >> 3) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_EN_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_VAL_SMf_GET(r) ((((r).anatxactl7[0]) >> 2) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_VAL_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_EN_SMf_GET(r) ((((r).anatxactl7[0]) >> 1) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_EN_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_VAL_SMf_GET(r) (((r).anatxactl7[0]) & 0x1)
#define BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_VAL_SMf_SET(r,f) (r).anatxactl7[0]=(((r).anatxactl7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ANATXACTL7.
 */
#define BCMI_MADURA_READ_ANATXACTL7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANATXACTL7r,_r._anatxactl7)
#define BCMI_MADURA_WRITE_ANATXACTL7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANATXACTL7r,_r._anatxactl7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANATXACTL7r BCMI_MADURA_ANATXACTL7r
#define ANATXACTL7r_SIZE BCMI_MADURA_ANATXACTL7r_SIZE
typedef BCMI_MADURA_ANATXACTL7r_t ANATXACTL7r_t;
#define ANATXACTL7r_CLR BCMI_MADURA_ANATXACTL7r_CLR
#define ANATXACTL7r_SET BCMI_MADURA_ANATXACTL7r_SET
#define ANATXACTL7r_GET BCMI_MADURA_ANATXACTL7r_GET
#define ANATXACTL7r_PMD_LN_DP_TX_RST_SMf_GET BCMI_MADURA_ANATXACTL7r_PMD_LN_DP_TX_RST_SMf_GET
#define ANATXACTL7r_PMD_LN_DP_TX_RST_SMf_SET BCMI_MADURA_ANATXACTL7r_PMD_LN_DP_TX_RST_SMf_SET
#define ANATXACTL7r_PMD_LN_TX_H_PWRDN_VAL_SMf_GET BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_VAL_SMf_GET
#define ANATXACTL7r_PMD_LN_TX_H_PWRDN_VAL_SMf_SET BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_VAL_SMf_SET
#define ANATXACTL7r_PMD_LN_TX_H_PWRDN_ENB_SMf_GET BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_ENB_SMf_GET
#define ANATXACTL7r_PMD_LN_TX_H_PWRDN_ENB_SMf_SET BCMI_MADURA_ANATXACTL7r_PMD_LN_TX_H_PWRDN_ENB_SMf_SET
#define ANATXACTL7r_TX_DISABLE_AN_GOOD_SMf_GET BCMI_MADURA_ANATXACTL7r_TX_DISABLE_AN_GOOD_SMf_GET
#define ANATXACTL7r_TX_DISABLE_AN_GOOD_SMf_SET BCMI_MADURA_ANATXACTL7r_TX_DISABLE_AN_GOOD_SMf_SET
#define ANATXACTL7r_TX_DISABLE_FORCE_EN_SMf_GET BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_EN_SMf_GET
#define ANATXACTL7r_TX_DISABLE_FORCE_EN_SMf_SET BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_EN_SMf_SET
#define ANATXACTL7r_TX_DISABLE_FORCE_VAL_SMf_GET BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_VAL_SMf_GET
#define ANATXACTL7r_TX_DISABLE_FORCE_VAL_SMf_SET BCMI_MADURA_ANATXACTL7r_TX_DISABLE_FORCE_VAL_SMf_SET
#define ANATXACTL7r_TX_SQUELCH_FORCE_EN_SMf_GET BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_EN_SMf_GET
#define ANATXACTL7r_TX_SQUELCH_FORCE_EN_SMf_SET BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_EN_SMf_SET
#define ANATXACTL7r_TX_SQUELCH_FORCE_VAL_SMf_GET BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_VAL_SMf_GET
#define ANATXACTL7r_TX_SQUELCH_FORCE_VAL_SMf_SET BCMI_MADURA_ANATXACTL7r_TX_SQUELCH_FORCE_VAL_SMf_SET
#define READ_ANATXACTL7r BCMI_MADURA_READ_ANATXACTL7r
#define WRITE_ANATXACTL7r BCMI_MADURA_WRITE_ANATXACTL7r
#define MODIFY_ANATXACTL7r BCMI_MADURA_MODIFY_ANATXACTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANATXACTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANARXSTS
 * BLOCKS:   RX_ANA_REGS
 * REGADDR:  0xc0b0
 * DEVAD:    7
 * DESC:     Rx Status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXSTATUS         The Status type is selected via anaRxStatusSel_SM 2:0case anaRxStatusSel_SM == 0:b15: pmd_sigdet (real time signal detect, active high)b14:13: reservedb12: pmd_rx_pmd_lock (real time pmd lock, active high)b11: pmd_sigdet_ll (latching low sigdet)b10: pmd_rx_pmd_lock_ll (latching low pmd lock)b9: pmd_ln_rx_h_pwrdn (rx pmd power down, Falcon input, active high)b8: pmd_ln_dp_rx_rst (data path reset, active high)b7: pmd_rx_clk_vld (PMD rx clock valid, active high)b6: pmd_rx_clk_vld_ll (latching low PMD rx clock valid)b5: KR4_block_lock (real time KR4 block lock, active high)b4: KR4_block_lock_ll (latching low KR4 block lock)b3: KR_block_lock (real time KR block lock, active high)b2: KR_block_lock_ll (latching low KR block lock)b1: reservedb0: pcb_pmd_pwrdwn_rx (rx slice power down, rx slice input (before pwrdn over-ride), active high)case anaRxStatusSel_SM == 1:b15:13: reservedb12: rxSeqDone (real time rxSeqDone, active high)b11:8: cl73_spd_busb7:0:  cl73_rxtm_dme
 */
#define BCMI_MADURA_ANARXSTSr (0x0007c0b0 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANARXSTSr_SIZE 4

/*
 * This structure should be used to declare and program ANARXSTS.
 */
typedef union BCMI_MADURA_ANARXSTSr_s {
	uint32_t v[1];
	uint32_t anarxsts[1];
	uint32_t _anarxsts;
} BCMI_MADURA_ANARXSTSr_t;

#define BCMI_MADURA_ANARXSTSr_CLR(r) (r).anarxsts[0] = 0
#define BCMI_MADURA_ANARXSTSr_SET(r,d) (r).anarxsts[0] = d
#define BCMI_MADURA_ANARXSTSr_GET(r) (r).anarxsts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANARXSTSr_RXSTATUSf_GET(r) (((r).anarxsts[0]) & 0xffff)
#define BCMI_MADURA_ANARXSTSr_RXSTATUSf_SET(r,f) (r).anarxsts[0]=(((r).anarxsts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access ANARXSTS.
 */
#define BCMI_MADURA_READ_ANARXSTSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANARXSTSr,_r._anarxsts)
#define BCMI_MADURA_WRITE_ANARXSTSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANARXSTSr,_r._anarxsts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANARXSTSr BCMI_MADURA_ANARXSTSr
#define ANARXSTSr_SIZE BCMI_MADURA_ANARXSTSr_SIZE
typedef BCMI_MADURA_ANARXSTSr_t ANARXSTSr_t;
#define ANARXSTSr_CLR BCMI_MADURA_ANARXSTSr_CLR
#define ANARXSTSr_SET BCMI_MADURA_ANARXSTSr_SET
#define ANARXSTSr_GET BCMI_MADURA_ANARXSTSr_GET
#define ANARXSTSr_RXSTATUSf_GET BCMI_MADURA_ANARXSTSr_RXSTATUSf_GET
#define ANARXSTSr_RXSTATUSf_SET BCMI_MADURA_ANARXSTSr_RXSTATUSf_SET
#define READ_ANARXSTSr BCMI_MADURA_READ_ANARXSTSr
#define WRITE_ANARXSTSr BCMI_MADURA_WRITE_ANARXSTSr
#define MODIFY_ANARXSTSr BCMI_MADURA_MODIFY_ANARXSTSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANARXSTSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANARXCTL
 * BLOCKS:   RX_ANA_REGS
 * REGADDR:  0xc0b1
 * DEVAD:    7
 * DESC:     Rx Control1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     STATUS_SEL       Select Status Field in anaRxStatus Register:0x0  General Rx Slice Status0x1  DME/CL73
 *     FORCERXSEQDONE_VAL_SM When forceRxSeqDone_en_SM is set forceRxSeqDone_val_SMdetermines the value of output RxSeqDone.
 *     FORCERXSEQDONE_EN_SM When set selects forceRxSeqDone_val_SM (rxSeqdone over-ride)
 *     USE_CL73_AN_GOOD_SM When set causes the assertion of the outputRxSeqDone when cl73 fsm transitions toAN_GOOD.  RxSeqDone is used to tx disable system side.This bit should be used when the core isconfigured in multi-pmd mode.
 *     USE_CL73_AN_GOOD_KR4_SM When set causes the assertion of the outputRxSeqDone when cl73 fsm transitions toAN_GOOD.  RxSeqDone is used to tx disable system side.This bit should be used when the core isconfigured in single-pmd mode.
 *     FORCE_PMD_LOCK_VAL_SM When force_pmd_lock_SM is set force_pmd_lock_val_SMdetermines the value of internal pmd_rx_pmd_lock.Internal pmd_lock affects HCD link status and DME RX reset.
 *     FORCE_PMD_LOCK_SM When set selects force_pmd_lock_val_SM (pmd_rx_pmd_lock over-ride)
 *     PLL_LOCK_4_RSTB_CL73_SEL pll_lock from Falcon is used to assert rstb_cl73 which is a reset synchronized torefclk domain. This is used in many logic inside cl73_rx, alternatively in refclk & clk25 domainsThis bit can be used to select between tx_pll0_lock or tx_pll1_lock for rstb_cl73 reset assertions1 - Selects tx_pll1_lock0 - Selects tx_pll0_lock
 */
#define BCMI_MADURA_ANARXCTLr (0x0007c0b1 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANARXCTLr_SIZE 4

/*
 * This structure should be used to declare and program ANARXCTL.
 */
typedef union BCMI_MADURA_ANARXCTLr_s {
	uint32_t v[1];
	uint32_t anarxctl[1];
	uint32_t _anarxctl;
} BCMI_MADURA_ANARXCTLr_t;

#define BCMI_MADURA_ANARXCTLr_CLR(r) (r).anarxctl[0] = 0
#define BCMI_MADURA_ANARXCTLr_SET(r,d) (r).anarxctl[0] = d
#define BCMI_MADURA_ANARXCTLr_GET(r) (r).anarxctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANARXCTLr_PLL_LOCK_4_RSTB_CL73_SELf_GET(r) ((((r).anarxctl[0]) >> 12) & 0x1)
#define BCMI_MADURA_ANARXCTLr_PLL_LOCK_4_RSTB_CL73_SELf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_SMf_GET(r) ((((r).anarxctl[0]) >> 9) & 0x1)
#define BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_SMf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_VAL_SMf_GET(r) ((((r).anarxctl[0]) >> 8) & 0x1)
#define BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_VAL_SMf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_KR4_SMf_GET(r) ((((r).anarxctl[0]) >> 7) & 0x1)
#define BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_KR4_SMf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_SMf_GET(r) ((((r).anarxctl[0]) >> 6) & 0x1)
#define BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_SMf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_EN_SMf_GET(r) ((((r).anarxctl[0]) >> 5) & 0x1)
#define BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_EN_SMf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_VAL_SMf_GET(r) ((((r).anarxctl[0]) >> 4) & 0x1)
#define BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_VAL_SMf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ANARXCTLr_STATUS_SELf_GET(r) (((r).anarxctl[0]) & 0x7)
#define BCMI_MADURA_ANARXCTLr_STATUS_SELf_SET(r,f) (r).anarxctl[0]=(((r).anarxctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access ANARXCTL.
 */
#define BCMI_MADURA_READ_ANARXCTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANARXCTLr,_r._anarxctl)
#define BCMI_MADURA_WRITE_ANARXCTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANARXCTLr,_r._anarxctl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANARXCTLr BCMI_MADURA_ANARXCTLr
#define ANARXCTLr_SIZE BCMI_MADURA_ANARXCTLr_SIZE
typedef BCMI_MADURA_ANARXCTLr_t ANARXCTLr_t;
#define ANARXCTLr_CLR BCMI_MADURA_ANARXCTLr_CLR
#define ANARXCTLr_SET BCMI_MADURA_ANARXCTLr_SET
#define ANARXCTLr_GET BCMI_MADURA_ANARXCTLr_GET
#define ANARXCTLr_PLL_LOCK_4_RSTB_CL73_SELf_GET BCMI_MADURA_ANARXCTLr_PLL_LOCK_4_RSTB_CL73_SELf_GET
#define ANARXCTLr_PLL_LOCK_4_RSTB_CL73_SELf_SET BCMI_MADURA_ANARXCTLr_PLL_LOCK_4_RSTB_CL73_SELf_SET
#define ANARXCTLr_FORCE_PMD_LOCK_SMf_GET BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_SMf_GET
#define ANARXCTLr_FORCE_PMD_LOCK_SMf_SET BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_SMf_SET
#define ANARXCTLr_FORCE_PMD_LOCK_VAL_SMf_GET BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_VAL_SMf_GET
#define ANARXCTLr_FORCE_PMD_LOCK_VAL_SMf_SET BCMI_MADURA_ANARXCTLr_FORCE_PMD_LOCK_VAL_SMf_SET
#define ANARXCTLr_USE_CL73_AN_GOOD_KR4_SMf_GET BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_KR4_SMf_GET
#define ANARXCTLr_USE_CL73_AN_GOOD_KR4_SMf_SET BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_KR4_SMf_SET
#define ANARXCTLr_USE_CL73_AN_GOOD_SMf_GET BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_SMf_GET
#define ANARXCTLr_USE_CL73_AN_GOOD_SMf_SET BCMI_MADURA_ANARXCTLr_USE_CL73_AN_GOOD_SMf_SET
#define ANARXCTLr_FORCERXSEQDONE_EN_SMf_GET BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_EN_SMf_GET
#define ANARXCTLr_FORCERXSEQDONE_EN_SMf_SET BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_EN_SMf_SET
#define ANARXCTLr_FORCERXSEQDONE_VAL_SMf_GET BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_VAL_SMf_GET
#define ANARXCTLr_FORCERXSEQDONE_VAL_SMf_SET BCMI_MADURA_ANARXCTLr_FORCERXSEQDONE_VAL_SMf_SET
#define ANARXCTLr_STATUS_SELf_GET BCMI_MADURA_ANARXCTLr_STATUS_SELf_GET
#define ANARXCTLr_STATUS_SELf_SET BCMI_MADURA_ANARXCTLr_STATUS_SELf_SET
#define READ_ANARXCTLr BCMI_MADURA_READ_ANARXCTLr
#define WRITE_ANARXCTLr BCMI_MADURA_WRITE_ANARXCTLr
#define MODIFY_ANARXCTLr BCMI_MADURA_MODIFY_ANARXCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANARXCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANARXSIGDET
 * BLOCKS:   RX_ANA_REGS
 * REGADDR:  0xc0b4
 * DEVAD:    7
 * DESC:     Rx Sigdet control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_SIGDET_FORCE_R 1 = force rx_sigdet via bit40 = normal
 *     RX_SIGDET_R      1 = forced sigdet value of 10 = forced sigdet value of 0
 */
#define BCMI_MADURA_ANARXSIGDETr (0x0007c0b4 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANARXSIGDETr_SIZE 4

/*
 * This structure should be used to declare and program ANARXSIGDET.
 */
typedef union BCMI_MADURA_ANARXSIGDETr_s {
	uint32_t v[1];
	uint32_t anarxsigdet[1];
	uint32_t _anarxsigdet;
} BCMI_MADURA_ANARXSIGDETr_t;

#define BCMI_MADURA_ANARXSIGDETr_CLR(r) (r).anarxsigdet[0] = 0
#define BCMI_MADURA_ANARXSIGDETr_SET(r,d) (r).anarxsigdet[0] = d
#define BCMI_MADURA_ANARXSIGDETr_GET(r) (r).anarxsigdet[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_Rf_GET(r) ((((r).anarxsigdet[0]) >> 4) & 0x1)
#define BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_Rf_SET(r,f) (r).anarxsigdet[0]=(((r).anarxsigdet[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_FORCE_Rf_GET(r) ((((r).anarxsigdet[0]) >> 3) & 0x1)
#define BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_FORCE_Rf_SET(r,f) (r).anarxsigdet[0]=(((r).anarxsigdet[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))

/*
 * These macros can be used to access ANARXSIGDET.
 */
#define BCMI_MADURA_READ_ANARXSIGDETr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANARXSIGDETr,_r._anarxsigdet)
#define BCMI_MADURA_WRITE_ANARXSIGDETr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANARXSIGDETr,_r._anarxsigdet)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANARXSIGDETr BCMI_MADURA_ANARXSIGDETr
#define ANARXSIGDETr_SIZE BCMI_MADURA_ANARXSIGDETr_SIZE
typedef BCMI_MADURA_ANARXSIGDETr_t ANARXSIGDETr_t;
#define ANARXSIGDETr_CLR BCMI_MADURA_ANARXSIGDETr_CLR
#define ANARXSIGDETr_SET BCMI_MADURA_ANARXSIGDETr_SET
#define ANARXSIGDETr_GET BCMI_MADURA_ANARXSIGDETr_GET
#define ANARXSIGDETr_RX_SIGDET_Rf_GET BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_Rf_GET
#define ANARXSIGDETr_RX_SIGDET_Rf_SET BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_Rf_SET
#define ANARXSIGDETr_RX_SIGDET_FORCE_Rf_GET BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_FORCE_Rf_GET
#define ANARXSIGDETr_RX_SIGDET_FORCE_Rf_SET BCMI_MADURA_ANARXSIGDETr_RX_SIGDET_FORCE_Rf_SET
#define READ_ANARXSIGDETr BCMI_MADURA_READ_ANARXSIGDETr
#define WRITE_ANARXSIGDETr BCMI_MADURA_WRITE_ANARXSIGDETr
#define MODIFY_ANARXSIGDETr BCMI_MADURA_MODIFY_ANARXSIGDETr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANARXSIGDETr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANARXCTL2
 * BLOCKS:   RX_ANA_REGS
 * REGADDR:  0xc0b6
 * DEVAD:    7
 * DESC:     Rx Control2 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXTM_TSTSEL_SM   Test bus select
 *     PMD_LN_DP_RX_RST_SM When set to 1'b1 asserts the QSFI digital rx_slicereset.  It only affects CL73 RX DME and 1G DME i/f. Does not affect Falcon reset.Active high.
 *     PMD_LN_RX_H_PWRDN_SM When set to 1'b1 resets CL73 RX DME and 1G DME i/f.Active high.
 */
#define BCMI_MADURA_ANARXCTL2r (0x0007c0b6 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANARXCTL2r_SIZE 4

/*
 * This structure should be used to declare and program ANARXCTL2.
 */
typedef union BCMI_MADURA_ANARXCTL2r_s {
	uint32_t v[1];
	uint32_t anarxctl2[1];
	uint32_t _anarxctl2;
} BCMI_MADURA_ANARXCTL2r_t;

#define BCMI_MADURA_ANARXCTL2r_CLR(r) (r).anarxctl2[0] = 0
#define BCMI_MADURA_ANARXCTL2r_SET(r,d) (r).anarxctl2[0] = d
#define BCMI_MADURA_ANARXCTL2r_GET(r) (r).anarxctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANARXCTL2r_PMD_LN_RX_H_PWRDN_SMf_GET(r) ((((r).anarxctl2[0]) >> 9) & 0x1)
#define BCMI_MADURA_ANARXCTL2r_PMD_LN_RX_H_PWRDN_SMf_SET(r,f) (r).anarxctl2[0]=(((r).anarxctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_ANARXCTL2r_PMD_LN_DP_RX_RST_SMf_GET(r) ((((r).anarxctl2[0]) >> 8) & 0x1)
#define BCMI_MADURA_ANARXCTL2r_PMD_LN_DP_RX_RST_SMf_SET(r,f) (r).anarxctl2[0]=(((r).anarxctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_ANARXCTL2r_RXTM_TSTSEL_SMf_GET(r) (((r).anarxctl2[0]) & 0x3)
#define BCMI_MADURA_ANARXCTL2r_RXTM_TSTSEL_SMf_SET(r,f) (r).anarxctl2[0]=(((r).anarxctl2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access ANARXCTL2.
 */
#define BCMI_MADURA_READ_ANARXCTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANARXCTL2r,_r._anarxctl2)
#define BCMI_MADURA_WRITE_ANARXCTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANARXCTL2r,_r._anarxctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANARXCTL2r BCMI_MADURA_ANARXCTL2r
#define ANARXCTL2r_SIZE BCMI_MADURA_ANARXCTL2r_SIZE
typedef BCMI_MADURA_ANARXCTL2r_t ANARXCTL2r_t;
#define ANARXCTL2r_CLR BCMI_MADURA_ANARXCTL2r_CLR
#define ANARXCTL2r_SET BCMI_MADURA_ANARXCTL2r_SET
#define ANARXCTL2r_GET BCMI_MADURA_ANARXCTL2r_GET
#define ANARXCTL2r_PMD_LN_RX_H_PWRDN_SMf_GET BCMI_MADURA_ANARXCTL2r_PMD_LN_RX_H_PWRDN_SMf_GET
#define ANARXCTL2r_PMD_LN_RX_H_PWRDN_SMf_SET BCMI_MADURA_ANARXCTL2r_PMD_LN_RX_H_PWRDN_SMf_SET
#define ANARXCTL2r_PMD_LN_DP_RX_RST_SMf_GET BCMI_MADURA_ANARXCTL2r_PMD_LN_DP_RX_RST_SMf_GET
#define ANARXCTL2r_PMD_LN_DP_RX_RST_SMf_SET BCMI_MADURA_ANARXCTL2r_PMD_LN_DP_RX_RST_SMf_SET
#define ANARXCTL2r_RXTM_TSTSEL_SMf_GET BCMI_MADURA_ANARXCTL2r_RXTM_TSTSEL_SMf_GET
#define ANARXCTL2r_RXTM_TSTSEL_SMf_SET BCMI_MADURA_ANARXCTL2r_RXTM_TSTSEL_SMf_SET
#define READ_ANARXCTL2r BCMI_MADURA_READ_ANARXCTL2r
#define WRITE_ANARXCTL2r BCMI_MADURA_WRITE_ANARXCTL2r
#define MODIFY_ANARXCTL2r BCMI_MADURA_MODIFY_ANARXCTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANARXCTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  ANARXCTL3
 * BLOCKS:   RX_ANA_REGS
 * REGADDR:  0xc0ba
 * DEVAD:    7
 * DESC:     Rx Control3 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     USE_KR4_PMD_LOCK_SM When set selects appropriate 100GBase-KR4/CR4 or40GBase-KR4/CR4 PMD lock as the Clause 73 link criteria.
 *     LINK_EN_R        Allows mgmt control of link status (force value)
 *     LINK_EN_FORCE_SM Enables link_en_r (force value enable)
 *     USE_KR4_BLOCK_LOCK_SM When set selects appropriate 100GBase-KR4/CR4 or40GBase-KR4/CR4 block lock as the Clause 73 link criteria.
 *     USE_KR_BLOCK_LOCK_SM When set selects 10GBase-R link monitorblock lock as the Clause 73 link criteria.
 *     CL73_CLK25_EN_SM Force on 25MHz Clause 73 clock
 *     CL73_CLK25_RST_SM Force on 25MHz Clause 73 reset
 *     RST_DME_EN_R     Force on/off dme reset force value
 *     RST_DME_EN_FORCE Force on/off dme reset force enable
 *     RXCK_DME_EN_R    Force on/off dme clock force value
 *     RXCK_DME_EN_FORCE Force on/off dme clock force enable
 */
#define BCMI_MADURA_ANARXCTL3r (0x0007c0ba | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_ANARXCTL3r_SIZE 4

/*
 * This structure should be used to declare and program ANARXCTL3.
 */
typedef union BCMI_MADURA_ANARXCTL3r_s {
	uint32_t v[1];
	uint32_t anarxctl3[1];
	uint32_t _anarxctl3;
} BCMI_MADURA_ANARXCTL3r_t;

#define BCMI_MADURA_ANARXCTL3r_CLR(r) (r).anarxctl3[0] = 0
#define BCMI_MADURA_ANARXCTL3r_SET(r,d) (r).anarxctl3[0] = d
#define BCMI_MADURA_ANARXCTL3r_GET(r) (r).anarxctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_FORCEf_GET(r) ((((r).anarxctl3[0]) >> 15) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_FORCEf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_Rf_GET(r) ((((r).anarxctl3[0]) >> 14) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_Rf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_ANARXCTL3r_RST_DME_EN_FORCEf_GET(r) ((((r).anarxctl3[0]) >> 13) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_RST_DME_EN_FORCEf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_ANARXCTL3r_RST_DME_EN_Rf_GET(r) ((((r).anarxctl3[0]) >> 12) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_RST_DME_EN_Rf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_ANARXCTL3r_CL73_CLK25_RST_SMf_GET(r) ((((r).anarxctl3[0]) >> 11) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_CL73_CLK25_RST_SMf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_ANARXCTL3r_CL73_CLK25_EN_SMf_GET(r) ((((r).anarxctl3[0]) >> 10) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_CL73_CLK25_EN_SMf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_ANARXCTL3r_USE_KR_BLOCK_LOCK_SMf_GET(r) ((((r).anarxctl3[0]) >> 7) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_USE_KR_BLOCK_LOCK_SMf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_ANARXCTL3r_USE_KR4_BLOCK_LOCK_SMf_GET(r) ((((r).anarxctl3[0]) >> 6) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_USE_KR4_BLOCK_LOCK_SMf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_ANARXCTL3r_LINK_EN_FORCE_SMf_GET(r) ((((r).anarxctl3[0]) >> 5) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_LINK_EN_FORCE_SMf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_ANARXCTL3r_LINK_EN_Rf_GET(r) ((((r).anarxctl3[0]) >> 4) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_LINK_EN_Rf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_ANARXCTL3r_USE_KR4_PMD_LOCK_SMf_GET(r) ((((r).anarxctl3[0]) >> 3) & 0x1)
#define BCMI_MADURA_ANARXCTL3r_USE_KR4_PMD_LOCK_SMf_SET(r,f) (r).anarxctl3[0]=(((r).anarxctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))

/*
 * These macros can be used to access ANARXCTL3.
 */
#define BCMI_MADURA_READ_ANARXCTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_ANARXCTL3r,_r._anarxctl3)
#define BCMI_MADURA_WRITE_ANARXCTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_ANARXCTL3r,_r._anarxctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ANARXCTL3r BCMI_MADURA_ANARXCTL3r
#define ANARXCTL3r_SIZE BCMI_MADURA_ANARXCTL3r_SIZE
typedef BCMI_MADURA_ANARXCTL3r_t ANARXCTL3r_t;
#define ANARXCTL3r_CLR BCMI_MADURA_ANARXCTL3r_CLR
#define ANARXCTL3r_SET BCMI_MADURA_ANARXCTL3r_SET
#define ANARXCTL3r_GET BCMI_MADURA_ANARXCTL3r_GET
#define ANARXCTL3r_RXCK_DME_EN_FORCEf_GET BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_FORCEf_GET
#define ANARXCTL3r_RXCK_DME_EN_FORCEf_SET BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_FORCEf_SET
#define ANARXCTL3r_RXCK_DME_EN_Rf_GET BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_Rf_GET
#define ANARXCTL3r_RXCK_DME_EN_Rf_SET BCMI_MADURA_ANARXCTL3r_RXCK_DME_EN_Rf_SET
#define ANARXCTL3r_RST_DME_EN_FORCEf_GET BCMI_MADURA_ANARXCTL3r_RST_DME_EN_FORCEf_GET
#define ANARXCTL3r_RST_DME_EN_FORCEf_SET BCMI_MADURA_ANARXCTL3r_RST_DME_EN_FORCEf_SET
#define ANARXCTL3r_RST_DME_EN_Rf_GET BCMI_MADURA_ANARXCTL3r_RST_DME_EN_Rf_GET
#define ANARXCTL3r_RST_DME_EN_Rf_SET BCMI_MADURA_ANARXCTL3r_RST_DME_EN_Rf_SET
#define ANARXCTL3r_CL73_CLK25_RST_SMf_GET BCMI_MADURA_ANARXCTL3r_CL73_CLK25_RST_SMf_GET
#define ANARXCTL3r_CL73_CLK25_RST_SMf_SET BCMI_MADURA_ANARXCTL3r_CL73_CLK25_RST_SMf_SET
#define ANARXCTL3r_CL73_CLK25_EN_SMf_GET BCMI_MADURA_ANARXCTL3r_CL73_CLK25_EN_SMf_GET
#define ANARXCTL3r_CL73_CLK25_EN_SMf_SET BCMI_MADURA_ANARXCTL3r_CL73_CLK25_EN_SMf_SET
#define ANARXCTL3r_USE_KR_BLOCK_LOCK_SMf_GET BCMI_MADURA_ANARXCTL3r_USE_KR_BLOCK_LOCK_SMf_GET
#define ANARXCTL3r_USE_KR_BLOCK_LOCK_SMf_SET BCMI_MADURA_ANARXCTL3r_USE_KR_BLOCK_LOCK_SMf_SET
#define ANARXCTL3r_USE_KR4_BLOCK_LOCK_SMf_GET BCMI_MADURA_ANARXCTL3r_USE_KR4_BLOCK_LOCK_SMf_GET
#define ANARXCTL3r_USE_KR4_BLOCK_LOCK_SMf_SET BCMI_MADURA_ANARXCTL3r_USE_KR4_BLOCK_LOCK_SMf_SET
#define ANARXCTL3r_LINK_EN_FORCE_SMf_GET BCMI_MADURA_ANARXCTL3r_LINK_EN_FORCE_SMf_GET
#define ANARXCTL3r_LINK_EN_FORCE_SMf_SET BCMI_MADURA_ANARXCTL3r_LINK_EN_FORCE_SMf_SET
#define ANARXCTL3r_LINK_EN_Rf_GET BCMI_MADURA_ANARXCTL3r_LINK_EN_Rf_GET
#define ANARXCTL3r_LINK_EN_Rf_SET BCMI_MADURA_ANARXCTL3r_LINK_EN_Rf_SET
#define ANARXCTL3r_USE_KR4_PMD_LOCK_SMf_GET BCMI_MADURA_ANARXCTL3r_USE_KR4_PMD_LOCK_SMf_GET
#define ANARXCTL3r_USE_KR4_PMD_LOCK_SMf_SET BCMI_MADURA_ANARXCTL3r_USE_KR4_PMD_LOCK_SMf_SET
#define READ_ANARXCTL3r BCMI_MADURA_READ_ANARXCTL3r
#define WRITE_ANARXCTL3r BCMI_MADURA_WRITE_ANARXCTL3r
#define MODIFY_ANARXCTL3r BCMI_MADURA_MODIFY_ANARXCTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_ANARXCTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL1
 * BLOCKS:   AN_TIMER_CNTRL
 * REGADDR:  0xc135
 * DEVAD:    7
 * DESC:     Clause 73 auto-negotiation control register 1
 * RESETVAL: 0x52 (82)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_INTERNAL_10US_TIMER_VAL Represents the upper 8-bit of the 13-bit internal tiiimer clock at 25MHz (i.e. {cl73_internal_10us_timer_val[7:0], 5'd0}). This is the internal clock timer value for which all CL73 timers are derived from. The default is set to 100us clock period (or 10KHz); despite the name. This timer is clocked with a derived, approximated 25MHz internal clock, which is a timer based clock based on the ref_clock.
 */
#define BCMI_MADURA_CL73CTL1r (0x0007c135 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL1.
 */
typedef union BCMI_MADURA_CL73CTL1r_s {
	uint32_t v[1];
	uint32_t cl73ctl1[1];
	uint32_t _cl73ctl1;
} BCMI_MADURA_CL73CTL1r_t;

#define BCMI_MADURA_CL73CTL1r_CLR(r) (r).cl73ctl1[0] = 0
#define BCMI_MADURA_CL73CTL1r_SET(r,d) (r).cl73ctl1[0] = d
#define BCMI_MADURA_CL73CTL1r_GET(r) (r).cl73ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL1r_CL73_INTERNAL_10US_TIMER_VALf_GET(r) (((r).cl73ctl1[0]) & 0xff)
#define BCMI_MADURA_CL73CTL1r_CL73_INTERNAL_10US_TIMER_VALf_SET(r,f) (r).cl73ctl1[0]=(((r).cl73ctl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access CL73CTL1.
 */
#define BCMI_MADURA_READ_CL73CTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL1r,_r._cl73ctl1)
#define BCMI_MADURA_WRITE_CL73CTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL1r,_r._cl73ctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL1r BCMI_MADURA_CL73CTL1r
#define CL73CTL1r_SIZE BCMI_MADURA_CL73CTL1r_SIZE
typedef BCMI_MADURA_CL73CTL1r_t CL73CTL1r_t;
#define CL73CTL1r_CLR BCMI_MADURA_CL73CTL1r_CLR
#define CL73CTL1r_SET BCMI_MADURA_CL73CTL1r_SET
#define CL73CTL1r_GET BCMI_MADURA_CL73CTL1r_GET
#define CL73CTL1r_CL73_INTERNAL_10US_TIMER_VALf_GET BCMI_MADURA_CL73CTL1r_CL73_INTERNAL_10US_TIMER_VALf_GET
#define CL73CTL1r_CL73_INTERNAL_10US_TIMER_VALf_SET BCMI_MADURA_CL73CTL1r_CL73_INTERNAL_10US_TIMER_VALf_SET
#define READ_CL73CTL1r BCMI_MADURA_READ_CL73CTL1r
#define WRITE_CL73CTL1r BCMI_MADURA_WRITE_CL73CTL1r
#define MODIFY_CL73CTL1r BCMI_MADURA_MODIFY_CL73CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL2
 * BLOCKS:   AN_TIMER_CNTRL
 * REGADDR:  0xc136
 * DEVAD:    7
 * DESC:     Clause 73 auto-negotiation control register 2
 * RESETVAL: 0x1f0 (496)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_LINK_FAIL_INHIBIT_TIMER_VAL cl73_link_fail_inhibit_timer_val100us resolution0x1F0 = 49.6ms
 */
#define BCMI_MADURA_CL73CTL2r (0x0007c136 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL2.
 */
typedef union BCMI_MADURA_CL73CTL2r_s {
	uint32_t v[1];
	uint32_t cl73ctl2[1];
	uint32_t _cl73ctl2;
} BCMI_MADURA_CL73CTL2r_t;

#define BCMI_MADURA_CL73CTL2r_CLR(r) (r).cl73ctl2[0] = 0
#define BCMI_MADURA_CL73CTL2r_SET(r,d) (r).cl73ctl2[0] = d
#define BCMI_MADURA_CL73CTL2r_GET(r) (r).cl73ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL2r_CL73_LINK_FAIL_INHIBIT_TIMER_VALf_GET(r) (((r).cl73ctl2[0]) & 0x1fff)
#define BCMI_MADURA_CL73CTL2r_CL73_LINK_FAIL_INHIBIT_TIMER_VALf_SET(r,f) (r).cl73ctl2[0]=(((r).cl73ctl2[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access CL73CTL2.
 */
#define BCMI_MADURA_READ_CL73CTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL2r,_r._cl73ctl2)
#define BCMI_MADURA_WRITE_CL73CTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL2r,_r._cl73ctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL2r BCMI_MADURA_CL73CTL2r
#define CL73CTL2r_SIZE BCMI_MADURA_CL73CTL2r_SIZE
typedef BCMI_MADURA_CL73CTL2r_t CL73CTL2r_t;
#define CL73CTL2r_CLR BCMI_MADURA_CL73CTL2r_CLR
#define CL73CTL2r_SET BCMI_MADURA_CL73CTL2r_SET
#define CL73CTL2r_GET BCMI_MADURA_CL73CTL2r_GET
#define CL73CTL2r_CL73_LINK_FAIL_INHIBIT_TIMER_VALf_GET BCMI_MADURA_CL73CTL2r_CL73_LINK_FAIL_INHIBIT_TIMER_VALf_GET
#define CL73CTL2r_CL73_LINK_FAIL_INHIBIT_TIMER_VALf_SET BCMI_MADURA_CL73CTL2r_CL73_LINK_FAIL_INHIBIT_TIMER_VALf_SET
#define READ_CL73CTL2r BCMI_MADURA_READ_CL73CTL2r
#define WRITE_CL73CTL2r BCMI_MADURA_WRITE_CL73CTL2r
#define MODIFY_CL73CTL2r BCMI_MADURA_MODIFY_CL73CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL3
 * BLOCKS:   AN_TIMER_CNTRL
 * REGADDR:  0xc137
 * DEVAD:    7
 * DESC:     Clause 73 auto-negotiation control register 3
 * RESETVAL: 0x1f0 (496)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_AN_WAIT_TIMER_VAL cl73_an_wait_timer_val100us resolution0x1F0 = 49.6ms
 */
#define BCMI_MADURA_CL73CTL3r (0x0007c137 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL3r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL3.
 */
typedef union BCMI_MADURA_CL73CTL3r_s {
	uint32_t v[1];
	uint32_t cl73ctl3[1];
	uint32_t _cl73ctl3;
} BCMI_MADURA_CL73CTL3r_t;

#define BCMI_MADURA_CL73CTL3r_CLR(r) (r).cl73ctl3[0] = 0
#define BCMI_MADURA_CL73CTL3r_SET(r,d) (r).cl73ctl3[0] = d
#define BCMI_MADURA_CL73CTL3r_GET(r) (r).cl73ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL3r_CL73_AN_WAIT_TIMER_VALf_GET(r) (((r).cl73ctl3[0]) & 0x1fff)
#define BCMI_MADURA_CL73CTL3r_CL73_AN_WAIT_TIMER_VALf_SET(r,f) (r).cl73ctl3[0]=(((r).cl73ctl3[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access CL73CTL3.
 */
#define BCMI_MADURA_READ_CL73CTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL3r,_r._cl73ctl3)
#define BCMI_MADURA_WRITE_CL73CTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL3r,_r._cl73ctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL3r BCMI_MADURA_CL73CTL3r
#define CL73CTL3r_SIZE BCMI_MADURA_CL73CTL3r_SIZE
typedef BCMI_MADURA_CL73CTL3r_t CL73CTL3r_t;
#define CL73CTL3r_CLR BCMI_MADURA_CL73CTL3r_CLR
#define CL73CTL3r_SET BCMI_MADURA_CL73CTL3r_SET
#define CL73CTL3r_GET BCMI_MADURA_CL73CTL3r_GET
#define CL73CTL3r_CL73_AN_WAIT_TIMER_VALf_GET BCMI_MADURA_CL73CTL3r_CL73_AN_WAIT_TIMER_VALf_GET
#define CL73CTL3r_CL73_AN_WAIT_TIMER_VALf_SET BCMI_MADURA_CL73CTL3r_CL73_AN_WAIT_TIMER_VALf_SET
#define READ_CL73CTL3r BCMI_MADURA_READ_CL73CTL3r
#define WRITE_CL73CTL3r BCMI_MADURA_WRITE_CL73CTL3r
#define MODIFY_CL73CTL3r BCMI_MADURA_MODIFY_CL73CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL4
 * BLOCKS:   AN_TIMER_CNTRL
 * REGADDR:  0xc138
 * DEVAD:    7
 * DESC:     Clause 73 auto-negotiation control register 4
 * RESETVAL: 0x2b6 (694)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_BREAK_LINK_TIMER_VAL cl73_break_link_timer_val100us resolution0x1F0 = 69.4ms
 */
#define BCMI_MADURA_CL73CTL4r (0x0007c138 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL4r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL4.
 */
typedef union BCMI_MADURA_CL73CTL4r_s {
	uint32_t v[1];
	uint32_t cl73ctl4[1];
	uint32_t _cl73ctl4;
} BCMI_MADURA_CL73CTL4r_t;

#define BCMI_MADURA_CL73CTL4r_CLR(r) (r).cl73ctl4[0] = 0
#define BCMI_MADURA_CL73CTL4r_SET(r,d) (r).cl73ctl4[0] = d
#define BCMI_MADURA_CL73CTL4r_GET(r) (r).cl73ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL4r_CL73_BREAK_LINK_TIMER_VALf_GET(r) (((r).cl73ctl4[0]) & 0x1fff)
#define BCMI_MADURA_CL73CTL4r_CL73_BREAK_LINK_TIMER_VALf_SET(r,f) (r).cl73ctl4[0]=(((r).cl73ctl4[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access CL73CTL4.
 */
#define BCMI_MADURA_READ_CL73CTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL4r,_r._cl73ctl4)
#define BCMI_MADURA_WRITE_CL73CTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL4r,_r._cl73ctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL4r BCMI_MADURA_CL73CTL4r
#define CL73CTL4r_SIZE BCMI_MADURA_CL73CTL4r_SIZE
typedef BCMI_MADURA_CL73CTL4r_t CL73CTL4r_t;
#define CL73CTL4r_CLR BCMI_MADURA_CL73CTL4r_CLR
#define CL73CTL4r_SET BCMI_MADURA_CL73CTL4r_SET
#define CL73CTL4r_GET BCMI_MADURA_CL73CTL4r_GET
#define CL73CTL4r_CL73_BREAK_LINK_TIMER_VALf_GET BCMI_MADURA_CL73CTL4r_CL73_BREAK_LINK_TIMER_VALf_GET
#define CL73CTL4r_CL73_BREAK_LINK_TIMER_VALf_SET BCMI_MADURA_CL73CTL4r_CL73_BREAK_LINK_TIMER_VALf_SET
#define READ_CL73CTL4r BCMI_MADURA_READ_CL73CTL4r
#define WRITE_CL73CTL4r BCMI_MADURA_WRITE_CL73CTL4r
#define MODIFY_CL73CTL4r BCMI_MADURA_MODIFY_CL73CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL5
 * BLOCKS:   AN_TIMER_CNTRL
 * REGADDR:  0xc139
 * DEVAD:    7
 * DESC:     Clause 73 auto-negotiation control register 5
 * RESETVAL: 0x17a2 (6050)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_LINK_FAIL_INHIBIT_TIMER_BAM_VAL cl73_link_fail_inhibit_timer_bam_val100us resolution0x17A2 = 600ms
 */
#define BCMI_MADURA_CL73CTL5r (0x0007c139 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL5r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL5.
 */
typedef union BCMI_MADURA_CL73CTL5r_s {
	uint32_t v[1];
	uint32_t cl73ctl5[1];
	uint32_t _cl73ctl5;
} BCMI_MADURA_CL73CTL5r_t;

#define BCMI_MADURA_CL73CTL5r_CLR(r) (r).cl73ctl5[0] = 0
#define BCMI_MADURA_CL73CTL5r_SET(r,d) (r).cl73ctl5[0] = d
#define BCMI_MADURA_CL73CTL5r_GET(r) (r).cl73ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL5r_CL73_LINK_FAIL_INHIBIT_TIMER_BAM_VALf_GET(r) (((r).cl73ctl5[0]) & 0x1fff)
#define BCMI_MADURA_CL73CTL5r_CL73_LINK_FAIL_INHIBIT_TIMER_BAM_VALf_SET(r,f) (r).cl73ctl5[0]=(((r).cl73ctl5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access CL73CTL5.
 */
#define BCMI_MADURA_READ_CL73CTL5r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL5r,_r._cl73ctl5)
#define BCMI_MADURA_WRITE_CL73CTL5r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL5r,_r._cl73ctl5)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL5r BCMI_MADURA_CL73CTL5r
#define CL73CTL5r_SIZE BCMI_MADURA_CL73CTL5r_SIZE
typedef BCMI_MADURA_CL73CTL5r_t CL73CTL5r_t;
#define CL73CTL5r_CLR BCMI_MADURA_CL73CTL5r_CLR
#define CL73CTL5r_SET BCMI_MADURA_CL73CTL5r_SET
#define CL73CTL5r_GET BCMI_MADURA_CL73CTL5r_GET
#define CL73CTL5r_CL73_LINK_FAIL_INHIBIT_TIMER_BAM_VALf_GET BCMI_MADURA_CL73CTL5r_CL73_LINK_FAIL_INHIBIT_TIMER_BAM_VALf_GET
#define CL73CTL5r_CL73_LINK_FAIL_INHIBIT_TIMER_BAM_VALf_SET BCMI_MADURA_CL73CTL5r_CL73_LINK_FAIL_INHIBIT_TIMER_BAM_VALf_SET
#define READ_CL73CTL5r BCMI_MADURA_READ_CL73CTL5r
#define WRITE_CL73CTL5r BCMI_MADURA_WRITE_CL73CTL5r
#define MODIFY_CL73CTL5r BCMI_MADURA_MODIFY_CL73CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL6
 * BLOCKS:   AN_TIMER_CNTRL
 * REGADDR:  0xc13a
 * DEVAD:    7
 * DESC:     Clause 73 auto-negotiation control register 6
 * RESETVAL: 0x14 (20)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_IGNORE_LINK_TIMER_VAL cl73_ignore_link_timer_val[12:0]100us resolution0x14 = 2ms
 */
#define BCMI_MADURA_CL73CTL6r (0x0007c13a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL6r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL6.
 */
typedef union BCMI_MADURA_CL73CTL6r_s {
	uint32_t v[1];
	uint32_t cl73ctl6[1];
	uint32_t _cl73ctl6;
} BCMI_MADURA_CL73CTL6r_t;

#define BCMI_MADURA_CL73CTL6r_CLR(r) (r).cl73ctl6[0] = 0
#define BCMI_MADURA_CL73CTL6r_SET(r,d) (r).cl73ctl6[0] = d
#define BCMI_MADURA_CL73CTL6r_GET(r) (r).cl73ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL6r_CL73_IGNORE_LINK_TIMER_VALf_GET(r) (((r).cl73ctl6[0]) & 0x1fff)
#define BCMI_MADURA_CL73CTL6r_CL73_IGNORE_LINK_TIMER_VALf_SET(r,f) (r).cl73ctl6[0]=(((r).cl73ctl6[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access CL73CTL6.
 */
#define BCMI_MADURA_READ_CL73CTL6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL6r,_r._cl73ctl6)
#define BCMI_MADURA_WRITE_CL73CTL6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL6r,_r._cl73ctl6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL6r BCMI_MADURA_CL73CTL6r
#define CL73CTL6r_SIZE BCMI_MADURA_CL73CTL6r_SIZE
typedef BCMI_MADURA_CL73CTL6r_t CL73CTL6r_t;
#define CL73CTL6r_CLR BCMI_MADURA_CL73CTL6r_CLR
#define CL73CTL6r_SET BCMI_MADURA_CL73CTL6r_SET
#define CL73CTL6r_GET BCMI_MADURA_CL73CTL6r_GET
#define CL73CTL6r_CL73_IGNORE_LINK_TIMER_VALf_GET BCMI_MADURA_CL73CTL6r_CL73_IGNORE_LINK_TIMER_VALf_GET
#define CL73CTL6r_CL73_IGNORE_LINK_TIMER_VALf_SET BCMI_MADURA_CL73CTL6r_CL73_IGNORE_LINK_TIMER_VALf_SET
#define READ_CL73CTL6r BCMI_MADURA_READ_CL73CTL6r
#define WRITE_CL73CTL6r BCMI_MADURA_WRITE_CL73CTL6r
#define MODIFY_CL73CTL6r BCMI_MADURA_MODIFY_CL73CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_DMETMRS
 * BLOCKS:   AN_TIMER_CNTRL
 * REGADDR:  0xc13b
 * DEVAD:    7
 * DESC:     Clause 73 auto-negotiation DME Timers Register
 * RESETVAL: 0x594f (22863)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_DME_PAGE_TEST_MIN_CNT_VAL cl73_dme_page_test_in_cnt_val[7:0]
 *     CL73_DME_PAGE_TEST_MAX_CNT_VAL cl73_dme_page_test_max_cnt_val[7:0]
 */
#define BCMI_MADURA_CL73_DMETMRSr (0x0007c13b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_DMETMRSr_SIZE 4

/*
 * This structure should be used to declare and program CL73_DMETMRS.
 */
typedef union BCMI_MADURA_CL73_DMETMRSr_s {
	uint32_t v[1];
	uint32_t cl73_dmetmrs[1];
	uint32_t _cl73_dmetmrs;
} BCMI_MADURA_CL73_DMETMRSr_t;

#define BCMI_MADURA_CL73_DMETMRSr_CLR(r) (r).cl73_dmetmrs[0] = 0
#define BCMI_MADURA_CL73_DMETMRSr_SET(r,d) (r).cl73_dmetmrs[0] = d
#define BCMI_MADURA_CL73_DMETMRSr_GET(r) (r).cl73_dmetmrs[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MAX_CNT_VALf_GET(r) ((((r).cl73_dmetmrs[0]) >> 8) & 0xff)
#define BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MAX_CNT_VALf_SET(r,f) (r).cl73_dmetmrs[0]=(((r).cl73_dmetmrs[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MIN_CNT_VALf_GET(r) (((r).cl73_dmetmrs[0]) & 0xff)
#define BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MIN_CNT_VALf_SET(r,f) (r).cl73_dmetmrs[0]=(((r).cl73_dmetmrs[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access CL73_DMETMRS.
 */
#define BCMI_MADURA_READ_CL73_DMETMRSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_DMETMRSr,_r._cl73_dmetmrs)
#define BCMI_MADURA_WRITE_CL73_DMETMRSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_DMETMRSr,_r._cl73_dmetmrs)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_DMETMRSr BCMI_MADURA_CL73_DMETMRSr
#define CL73_DMETMRSr_SIZE BCMI_MADURA_CL73_DMETMRSr_SIZE
typedef BCMI_MADURA_CL73_DMETMRSr_t CL73_DMETMRSr_t;
#define CL73_DMETMRSr_CLR BCMI_MADURA_CL73_DMETMRSr_CLR
#define CL73_DMETMRSr_SET BCMI_MADURA_CL73_DMETMRSr_SET
#define CL73_DMETMRSr_GET BCMI_MADURA_CL73_DMETMRSr_GET
#define CL73_DMETMRSr_CL73_DME_PAGE_TEST_MAX_CNT_VALf_GET BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MAX_CNT_VALf_GET
#define CL73_DMETMRSr_CL73_DME_PAGE_TEST_MAX_CNT_VALf_SET BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MAX_CNT_VALf_SET
#define CL73_DMETMRSr_CL73_DME_PAGE_TEST_MIN_CNT_VALf_GET BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MIN_CNT_VALf_GET
#define CL73_DMETMRSr_CL73_DME_PAGE_TEST_MIN_CNT_VALf_SET BCMI_MADURA_CL73_DMETMRSr_CL73_DME_PAGE_TEST_MIN_CNT_VALf_SET
#define READ_CL73_DMETMRSr BCMI_MADURA_READ_CL73_DMETMRSr
#define WRITE_CL73_DMETMRSr BCMI_MADURA_WRITE_CL73_DMETMRSr
#define MODIFY_CL73_DMETMRSr BCMI_MADURA_MODIFY_CL73_DMETMRSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_DMETMRSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL8
 * BLOCKS:   XGXS_BLK8
 * REGADDR:  0xc161
 * DEVAD:    7
 * DESC:     CL73 Control 8 Register (NOT USED)
 * RESETVAL: 0x5200 (20992)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_REFCLK_161_OFFSET_CNT This counter is used to adjust the 100us base count value with 161.xxMz reference clock
 */
#define BCMI_MADURA_CL73CTL8r (0x0007c161 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL8r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL8.
 */
typedef union BCMI_MADURA_CL73CTL8r_s {
	uint32_t v[1];
	uint32_t cl73ctl8[1];
	uint32_t _cl73ctl8;
} BCMI_MADURA_CL73CTL8r_t;

#define BCMI_MADURA_CL73CTL8r_CLR(r) (r).cl73ctl8[0] = 0
#define BCMI_MADURA_CL73CTL8r_SET(r,d) (r).cl73ctl8[0] = d
#define BCMI_MADURA_CL73CTL8r_GET(r) (r).cl73ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL8r_CL73_REFCLK_161_OFFSET_CNTf_GET(r) ((((r).cl73ctl8[0]) >> 8) & 0xff)
#define BCMI_MADURA_CL73CTL8r_CL73_REFCLK_161_OFFSET_CNTf_SET(r,f) (r).cl73ctl8[0]=(((r).cl73ctl8[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access CL73CTL8.
 */
#define BCMI_MADURA_READ_CL73CTL8r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL8r,_r._cl73ctl8)
#define BCMI_MADURA_WRITE_CL73CTL8r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL8r,_r._cl73ctl8)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL8r BCMI_MADURA_CL73CTL8r
#define CL73CTL8r_SIZE BCMI_MADURA_CL73CTL8r_SIZE
typedef BCMI_MADURA_CL73CTL8r_t CL73CTL8r_t;
#define CL73CTL8r_CLR BCMI_MADURA_CL73CTL8r_CLR
#define CL73CTL8r_SET BCMI_MADURA_CL73CTL8r_SET
#define CL73CTL8r_GET BCMI_MADURA_CL73CTL8r_GET
#define CL73CTL8r_CL73_REFCLK_161_OFFSET_CNTf_GET BCMI_MADURA_CL73CTL8r_CL73_REFCLK_161_OFFSET_CNTf_GET
#define CL73CTL8r_CL73_REFCLK_161_OFFSET_CNTf_SET BCMI_MADURA_CL73CTL8r_CL73_REFCLK_161_OFFSET_CNTf_SET
#define READ_CL73CTL8r BCMI_MADURA_READ_CL73CTL8r
#define WRITE_CL73CTL8r BCMI_MADURA_WRITE_CL73CTL8r
#define MODIFY_CL73CTL8r BCMI_MADURA_MODIFY_CL73CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL9
 * BLOCKS:   XGXS_BLK8
 * REGADDR:  0xc162
 * DEVAD:    7
 * DESC:     CL73 Control 9 Register
 * RESETVAL: 0x13ba (5050)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_LINK_FAIL_INHIBIT_TIMER_KR_VAL 100us resolution.0x13BA = 505ms
 */
#define BCMI_MADURA_CL73CTL9r (0x0007c162 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL9r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL9.
 */
typedef union BCMI_MADURA_CL73CTL9r_s {
	uint32_t v[1];
	uint32_t cl73ctl9[1];
	uint32_t _cl73ctl9;
} BCMI_MADURA_CL73CTL9r_t;

#define BCMI_MADURA_CL73CTL9r_CLR(r) (r).cl73ctl9[0] = 0
#define BCMI_MADURA_CL73CTL9r_SET(r,d) (r).cl73ctl9[0] = d
#define BCMI_MADURA_CL73CTL9r_GET(r) (r).cl73ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL9r_CL73_LINK_FAIL_INHIBIT_TIMER_KR_VALf_GET(r) (((r).cl73ctl9[0]) & 0x3fff)
#define BCMI_MADURA_CL73CTL9r_CL73_LINK_FAIL_INHIBIT_TIMER_KR_VALf_SET(r,f) (r).cl73ctl9[0]=(((r).cl73ctl9[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access CL73CTL9.
 */
#define BCMI_MADURA_READ_CL73CTL9r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL9r,_r._cl73ctl9)
#define BCMI_MADURA_WRITE_CL73CTL9r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL9r,_r._cl73ctl9)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL9r BCMI_MADURA_CL73CTL9r
#define CL73CTL9r_SIZE BCMI_MADURA_CL73CTL9r_SIZE
typedef BCMI_MADURA_CL73CTL9r_t CL73CTL9r_t;
#define CL73CTL9r_CLR BCMI_MADURA_CL73CTL9r_CLR
#define CL73CTL9r_SET BCMI_MADURA_CL73CTL9r_SET
#define CL73CTL9r_GET BCMI_MADURA_CL73CTL9r_GET
#define CL73CTL9r_CL73_LINK_FAIL_INHIBIT_TIMER_KR_VALf_GET BCMI_MADURA_CL73CTL9r_CL73_LINK_FAIL_INHIBIT_TIMER_KR_VALf_GET
#define CL73CTL9r_CL73_LINK_FAIL_INHIBIT_TIMER_KR_VALf_SET BCMI_MADURA_CL73CTL9r_CL73_LINK_FAIL_INHIBIT_TIMER_KR_VALf_SET
#define READ_CL73CTL9r BCMI_MADURA_READ_CL73CTL9r
#define WRITE_CL73CTL9r BCMI_MADURA_WRITE_CL73CTL9r
#define MODIFY_CL73CTL9r BCMI_MADURA_MODIFY_CL73CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73CTL10
 * BLOCKS:   XGXS_BLK8
 * REGADDR:  0xc163
 * DEVAD:    7
 * DESC:     CL73 Control 10 Register (NOT USED)
 * RESETVAL: 0x1770 (6000)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_LINK_FAIL_INHIBIT_TIMER_CL72_VAL 100us resolution.0x1770 = 600ms
 */
#define BCMI_MADURA_CL73CTL10r (0x0007c163 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73CTL10r_SIZE 4

/*
 * This structure should be used to declare and program CL73CTL10.
 */
typedef union BCMI_MADURA_CL73CTL10r_s {
	uint32_t v[1];
	uint32_t cl73ctl10[1];
	uint32_t _cl73ctl10;
} BCMI_MADURA_CL73CTL10r_t;

#define BCMI_MADURA_CL73CTL10r_CLR(r) (r).cl73ctl10[0] = 0
#define BCMI_MADURA_CL73CTL10r_SET(r,d) (r).cl73ctl10[0] = d
#define BCMI_MADURA_CL73CTL10r_GET(r) (r).cl73ctl10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73CTL10r_CL73_LINK_FAIL_INHIBIT_TIMER_CL72_VALf_GET(r) (((r).cl73ctl10[0]) & 0x3fff)
#define BCMI_MADURA_CL73CTL10r_CL73_LINK_FAIL_INHIBIT_TIMER_CL72_VALf_SET(r,f) (r).cl73ctl10[0]=(((r).cl73ctl10[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access CL73CTL10.
 */
#define BCMI_MADURA_READ_CL73CTL10r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73CTL10r,_r._cl73ctl10)
#define BCMI_MADURA_WRITE_CL73CTL10r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73CTL10r,_r._cl73ctl10)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73CTL10r BCMI_MADURA_CL73CTL10r
#define CL73CTL10r_SIZE BCMI_MADURA_CL73CTL10r_SIZE
typedef BCMI_MADURA_CL73CTL10r_t CL73CTL10r_t;
#define CL73CTL10r_CLR BCMI_MADURA_CL73CTL10r_CLR
#define CL73CTL10r_SET BCMI_MADURA_CL73CTL10r_SET
#define CL73CTL10r_GET BCMI_MADURA_CL73CTL10r_GET
#define CL73CTL10r_CL73_LINK_FAIL_INHIBIT_TIMER_CL72_VALf_GET BCMI_MADURA_CL73CTL10r_CL73_LINK_FAIL_INHIBIT_TIMER_CL72_VALf_GET
#define CL73CTL10r_CL73_LINK_FAIL_INHIBIT_TIMER_CL72_VALf_SET BCMI_MADURA_CL73CTL10r_CL73_LINK_FAIL_INHIBIT_TIMER_CL72_VALf_SET
#define READ_CL73CTL10r BCMI_MADURA_READ_CL73CTL10r
#define WRITE_CL73CTL10r BCMI_MADURA_WRITE_CL73CTL10r
#define MODIFY_CL73CTL10r BCMI_MADURA_MODIFY_CL73CTL10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73CTL10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_MISC_CTL1_MISC1
 * BLOCKS:   AN_MISC_CNTRL1
 * REGADDR:  0xc308
 * DEVAD:    7
 * DESC:     Miscellaneous 1 control register (NOT USED)
 * RESETVAL: 0x6a05 (27141)
 * ACCESS:   R/W
 * FIELDS:
 *     FORCE_SPEED      Determines force_speed[4:0].force_speed[5] is mapped to Misc3B[7]force_speed[7:6] is mapped to Misc5B[7:6]When programming the pll clock divider andover-sample mode manually it is recommendedto program force_speed[7:0] == 0x4A (bypass mode),although this is not mandatory for QSFI.
 *     FORCE_PLL_MODE_AFE Determines pll clock multiplier factorof the VCO.Fvco is computed by multiplying the refclkfrequency by the selected clock multiplier.Value 0x9 specifies x64 multiplierValue 0xA specifies x66 multiplier
 *     REFCLK_SEL       Specifies refclk frequencyValue 0x3 specifies 156.25 MHz
 */
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r (0x0007c308 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_SIZE 4

/*
 * This structure should be used to declare and program AN_MISC_CTL1_MISC1.
 */
typedef union BCMI_MADURA_AN_MISC_CTL1_MISC1r_s {
	uint32_t v[1];
	uint32_t an_misc_ctl1_misc1[1];
	uint32_t _an_misc_ctl1_misc1;
} BCMI_MADURA_AN_MISC_CTL1_MISC1r_t;

#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_CLR(r) (r).an_misc_ctl1_misc1[0] = 0
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_SET(r,d) (r).an_misc_ctl1_misc1[0] = d
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_GET(r) (r).an_misc_ctl1_misc1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_REFCLK_SELf_GET(r) ((((r).an_misc_ctl1_misc1[0]) >> 13) & 0x7)
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_REFCLK_SELf_SET(r,f) (r).an_misc_ctl1_misc1[0]=(((r).an_misc_ctl1_misc1[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_PLL_MODE_AFEf_GET(r) ((((r).an_misc_ctl1_misc1[0]) >> 8) & 0xf)
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_PLL_MODE_AFEf_SET(r,f) (r).an_misc_ctl1_misc1[0]=(((r).an_misc_ctl1_misc1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_SPEEDf_GET(r) (((r).an_misc_ctl1_misc1[0]) & 0x1f)
#define BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_SPEEDf_SET(r,f) (r).an_misc_ctl1_misc1[0]=(((r).an_misc_ctl1_misc1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AN_MISC_CTL1_MISC1.
 */
#define BCMI_MADURA_READ_AN_MISC_CTL1_MISC1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_MISC_CTL1_MISC1r,_r._an_misc_ctl1_misc1)
#define BCMI_MADURA_WRITE_AN_MISC_CTL1_MISC1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_MISC_CTL1_MISC1r,_r._an_misc_ctl1_misc1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_MISC_CTL1_MISC1r BCMI_MADURA_AN_MISC_CTL1_MISC1r
#define AN_MISC_CTL1_MISC1r_SIZE BCMI_MADURA_AN_MISC_CTL1_MISC1r_SIZE
typedef BCMI_MADURA_AN_MISC_CTL1_MISC1r_t AN_MISC_CTL1_MISC1r_t;
#define AN_MISC_CTL1_MISC1r_CLR BCMI_MADURA_AN_MISC_CTL1_MISC1r_CLR
#define AN_MISC_CTL1_MISC1r_SET BCMI_MADURA_AN_MISC_CTL1_MISC1r_SET
#define AN_MISC_CTL1_MISC1r_GET BCMI_MADURA_AN_MISC_CTL1_MISC1r_GET
#define AN_MISC_CTL1_MISC1r_REFCLK_SELf_GET BCMI_MADURA_AN_MISC_CTL1_MISC1r_REFCLK_SELf_GET
#define AN_MISC_CTL1_MISC1r_REFCLK_SELf_SET BCMI_MADURA_AN_MISC_CTL1_MISC1r_REFCLK_SELf_SET
#define AN_MISC_CTL1_MISC1r_FORCE_PLL_MODE_AFEf_GET BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_PLL_MODE_AFEf_GET
#define AN_MISC_CTL1_MISC1r_FORCE_PLL_MODE_AFEf_SET BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_PLL_MODE_AFEf_SET
#define AN_MISC_CTL1_MISC1r_FORCE_SPEEDf_GET BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_SPEEDf_GET
#define AN_MISC_CTL1_MISC1r_FORCE_SPEEDf_SET BCMI_MADURA_AN_MISC_CTL1_MISC1r_FORCE_SPEEDf_SET
#define READ_AN_MISC_CTL1_MISC1r BCMI_MADURA_READ_AN_MISC_CTL1_MISC1r
#define WRITE_AN_MISC_CTL1_MISC1r BCMI_MADURA_WRITE_AN_MISC_CTL1_MISC1r
#define MODIFY_AN_MISC_CTL1_MISC1r BCMI_MADURA_MODIFY_AN_MISC_CTL1_MISC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_MISC_CTL1_MISC1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_MISC_CTL1_MISC2
 * BLOCKS:   AN_MISC_CNTRL1
 * REGADDR:  0xc309
 * DEVAD:    7
 * DESC:     Miscellaneous 2 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMA_PMD_ABLTY_WRITE_EN When set enables the ability to write to the IEEE PMA/PMD ability registers 1.4, 1.5, 1.6, 1.8, 1.11, and 1.13Falcon(line): per-lane.
 */
#define BCMI_MADURA_AN_MISC_CTL1_MISC2r (0x0007c309 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_MISC_CTL1_MISC2r_SIZE 4

/*
 * This structure should be used to declare and program AN_MISC_CTL1_MISC2.
 */
typedef union BCMI_MADURA_AN_MISC_CTL1_MISC2r_s {
	uint32_t v[1];
	uint32_t an_misc_ctl1_misc2[1];
	uint32_t _an_misc_ctl1_misc2;
} BCMI_MADURA_AN_MISC_CTL1_MISC2r_t;

#define BCMI_MADURA_AN_MISC_CTL1_MISC2r_CLR(r) (r).an_misc_ctl1_misc2[0] = 0
#define BCMI_MADURA_AN_MISC_CTL1_MISC2r_SET(r,d) (r).an_misc_ctl1_misc2[0] = d
#define BCMI_MADURA_AN_MISC_CTL1_MISC2r_GET(r) (r).an_misc_ctl1_misc2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_MISC_CTL1_MISC2r_PMA_PMD_ABLTY_WRITE_ENf_GET(r) (((r).an_misc_ctl1_misc2[0]) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL1_MISC2r_PMA_PMD_ABLTY_WRITE_ENf_SET(r,f) (r).an_misc_ctl1_misc2[0]=(((r).an_misc_ctl1_misc2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_MISC_CTL1_MISC2.
 */
#define BCMI_MADURA_READ_AN_MISC_CTL1_MISC2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_MISC_CTL1_MISC2r,_r._an_misc_ctl1_misc2)
#define BCMI_MADURA_WRITE_AN_MISC_CTL1_MISC2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_MISC_CTL1_MISC2r,_r._an_misc_ctl1_misc2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_MISC_CTL1_MISC2r BCMI_MADURA_AN_MISC_CTL1_MISC2r
#define AN_MISC_CTL1_MISC2r_SIZE BCMI_MADURA_AN_MISC_CTL1_MISC2r_SIZE
typedef BCMI_MADURA_AN_MISC_CTL1_MISC2r_t AN_MISC_CTL1_MISC2r_t;
#define AN_MISC_CTL1_MISC2r_CLR BCMI_MADURA_AN_MISC_CTL1_MISC2r_CLR
#define AN_MISC_CTL1_MISC2r_SET BCMI_MADURA_AN_MISC_CTL1_MISC2r_SET
#define AN_MISC_CTL1_MISC2r_GET BCMI_MADURA_AN_MISC_CTL1_MISC2r_GET
#define AN_MISC_CTL1_MISC2r_PMA_PMD_ABLTY_WRITE_ENf_GET BCMI_MADURA_AN_MISC_CTL1_MISC2r_PMA_PMD_ABLTY_WRITE_ENf_GET
#define AN_MISC_CTL1_MISC2r_PMA_PMD_ABLTY_WRITE_ENf_SET BCMI_MADURA_AN_MISC_CTL1_MISC2r_PMA_PMD_ABLTY_WRITE_ENf_SET
#define READ_AN_MISC_CTL1_MISC2r BCMI_MADURA_READ_AN_MISC_CTL1_MISC2r
#define WRITE_AN_MISC_CTL1_MISC2r BCMI_MADURA_WRITE_AN_MISC_CTL1_MISC2r
#define MODIFY_AN_MISC_CTL1_MISC2r BCMI_MADURA_MODIFY_AN_MISC_CTL1_MISC2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_MISC_CTL1_MISC2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_MISC_CTL3_MISC6
 * BLOCKS:   AN_MISC_CNTRL3
 * REGADDR:  0xc345
 * DEVAD:    7
 * DESC:     Misc6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_RESET_IND   When set puts lane data path into reset.Falcon(line): This is a per-lane reset.This applies ONLY to lanes in AN ports.Does not reset mdio regs.
 */
#define BCMI_MADURA_AN_MISC_CTL3_MISC6r (0x0007c345 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_MISC_CTL3_MISC6r_SIZE 4

/*
 * This structure should be used to declare and program AN_MISC_CTL3_MISC6.
 */
typedef union BCMI_MADURA_AN_MISC_CTL3_MISC6r_s {
	uint32_t v[1];
	uint32_t an_misc_ctl3_misc6[1];
	uint32_t _an_misc_ctl3_misc6;
} BCMI_MADURA_AN_MISC_CTL3_MISC6r_t;

#define BCMI_MADURA_AN_MISC_CTL3_MISC6r_CLR(r) (r).an_misc_ctl3_misc6[0] = 0
#define BCMI_MADURA_AN_MISC_CTL3_MISC6r_SET(r,d) (r).an_misc_ctl3_misc6[0] = d
#define BCMI_MADURA_AN_MISC_CTL3_MISC6r_GET(r) (r).an_misc_ctl3_misc6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_MISC_CTL3_MISC6r_LANE_RESET_INDf_GET(r) ((((r).an_misc_ctl3_misc6[0]) >> 15) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL3_MISC6r_LANE_RESET_INDf_SET(r,f) (r).an_misc_ctl3_misc6[0]=(((r).an_misc_ctl3_misc6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))

/*
 * These macros can be used to access AN_MISC_CTL3_MISC6.
 */
#define BCMI_MADURA_READ_AN_MISC_CTL3_MISC6r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_MISC_CTL3_MISC6r,_r._an_misc_ctl3_misc6)
#define BCMI_MADURA_WRITE_AN_MISC_CTL3_MISC6r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_MISC_CTL3_MISC6r,_r._an_misc_ctl3_misc6)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_MISC_CTL3_MISC6r BCMI_MADURA_AN_MISC_CTL3_MISC6r
#define AN_MISC_CTL3_MISC6r_SIZE BCMI_MADURA_AN_MISC_CTL3_MISC6r_SIZE
typedef BCMI_MADURA_AN_MISC_CTL3_MISC6r_t AN_MISC_CTL3_MISC6r_t;
#define AN_MISC_CTL3_MISC6r_CLR BCMI_MADURA_AN_MISC_CTL3_MISC6r_CLR
#define AN_MISC_CTL3_MISC6r_SET BCMI_MADURA_AN_MISC_CTL3_MISC6r_SET
#define AN_MISC_CTL3_MISC6r_GET BCMI_MADURA_AN_MISC_CTL3_MISC6r_GET
#define AN_MISC_CTL3_MISC6r_LANE_RESET_INDf_GET BCMI_MADURA_AN_MISC_CTL3_MISC6r_LANE_RESET_INDf_GET
#define AN_MISC_CTL3_MISC6r_LANE_RESET_INDf_SET BCMI_MADURA_AN_MISC_CTL3_MISC6r_LANE_RESET_INDf_SET
#define READ_AN_MISC_CTL3_MISC6r BCMI_MADURA_READ_AN_MISC_CTL3_MISC6r
#define WRITE_AN_MISC_CTL3_MISC6r BCMI_MADURA_WRITE_AN_MISC_CTL3_MISC6r
#define MODIFY_AN_MISC_CTL3_MISC6r BCMI_MADURA_MODIFY_AN_MISC_CTL3_MISC6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_MISC_CTL3_MISC6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_MISC_CTL3_MISC7
 * BLOCKS:   AN_MISC_CNTRL3
 * REGADDR:  0xc349
 * DEVAD:    7
 * DESC:     Misc7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAP_OSR_MODE     When set maps pmd_osr_mode to actual_speedstatus register bits [14:8]
 */
#define BCMI_MADURA_AN_MISC_CTL3_MISC7r (0x0007c349 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_MISC_CTL3_MISC7r_SIZE 4

/*
 * This structure should be used to declare and program AN_MISC_CTL3_MISC7.
 */
typedef union BCMI_MADURA_AN_MISC_CTL3_MISC7r_s {
	uint32_t v[1];
	uint32_t an_misc_ctl3_misc7[1];
	uint32_t _an_misc_ctl3_misc7;
} BCMI_MADURA_AN_MISC_CTL3_MISC7r_t;

#define BCMI_MADURA_AN_MISC_CTL3_MISC7r_CLR(r) (r).an_misc_ctl3_misc7[0] = 0
#define BCMI_MADURA_AN_MISC_CTL3_MISC7r_SET(r,d) (r).an_misc_ctl3_misc7[0] = d
#define BCMI_MADURA_AN_MISC_CTL3_MISC7r_GET(r) (r).an_misc_ctl3_misc7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_MISC_CTL3_MISC7r_MAP_OSR_MODEf_GET(r) ((((r).an_misc_ctl3_misc7[0]) >> 8) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL3_MISC7r_MAP_OSR_MODEf_SET(r,f) (r).an_misc_ctl3_misc7[0]=(((r).an_misc_ctl3_misc7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))

/*
 * These macros can be used to access AN_MISC_CTL3_MISC7.
 */
#define BCMI_MADURA_READ_AN_MISC_CTL3_MISC7r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_MISC_CTL3_MISC7r,_r._an_misc_ctl3_misc7)
#define BCMI_MADURA_WRITE_AN_MISC_CTL3_MISC7r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_MISC_CTL3_MISC7r,_r._an_misc_ctl3_misc7)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_MISC_CTL3_MISC7r BCMI_MADURA_AN_MISC_CTL3_MISC7r
#define AN_MISC_CTL3_MISC7r_SIZE BCMI_MADURA_AN_MISC_CTL3_MISC7r_SIZE
typedef BCMI_MADURA_AN_MISC_CTL3_MISC7r_t AN_MISC_CTL3_MISC7r_t;
#define AN_MISC_CTL3_MISC7r_CLR BCMI_MADURA_AN_MISC_CTL3_MISC7r_CLR
#define AN_MISC_CTL3_MISC7r_SET BCMI_MADURA_AN_MISC_CTL3_MISC7r_SET
#define AN_MISC_CTL3_MISC7r_GET BCMI_MADURA_AN_MISC_CTL3_MISC7r_GET
#define AN_MISC_CTL3_MISC7r_MAP_OSR_MODEf_GET BCMI_MADURA_AN_MISC_CTL3_MISC7r_MAP_OSR_MODEf_GET
#define AN_MISC_CTL3_MISC7r_MAP_OSR_MODEf_SET BCMI_MADURA_AN_MISC_CTL3_MISC7r_MAP_OSR_MODEf_SET
#define READ_AN_MISC_CTL3_MISC7r BCMI_MADURA_READ_AN_MISC_CTL3_MISC7r
#define WRITE_AN_MISC_CTL3_MISC7r BCMI_MADURA_WRITE_AN_MISC_CTL3_MISC7r
#define MODIFY_AN_MISC_CTL3_MISC7r BCMI_MADURA_MODIFY_AN_MISC_CTL3_MISC7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_MISC_CTL3_MISC7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_MISC_CTL3_LNK_STS
 * BLOCKS:   AN_MISC_CNTRL3
 * REGADDR:  0xc34d
 * DEVAD:    7
 * DESC:     link_status
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_AUTONEG_COMPLETE When set indicates Clause 73 link is completed.
 *     PMD_RX_PMD_LOCK  When set indicates the pmd is locked, for the lane in the AN port in which AN is happening.
 *     LINK_STATUS      When set indicates Clause 73 link is set.
 *     DUPLEX_STATUS    
 *     CL73_MR_LP_AUTONEG_ABLE When set indicates link partner supports Clause auto-neg.
 *     PAUSE_RESOLUTION This bit indicates the status of pause ability resolution asper IEEE CL Table 28B.3
 *     AN_SPEED         Auto-negotiated speed for lane 07'h0D       KX7'h0E       KX47'h0F       KR7'h27       KR47'h28       CR47'h29       CR107'h39       KR27'h3A       CR2For Lack of register bits, 8th bit of an_speed is NOT reported herean_speed[7:0]=80->100GKP4, 81->100G-KR4, 82->100G-CR4. SO7'h00      100G-KP4 - if cl73 is enabled.7'h01      100G-KR47'h02      100G-CR4
 */
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr (0x0007c34d | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_MISC_CTL3_LNK_STS.
 */
typedef union BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_s {
	uint32_t v[1];
	uint32_t an_misc_ctl3_lnk_sts[1];
	uint32_t _an_misc_ctl3_lnk_sts;
} BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_t;

#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CLR(r) (r).an_misc_ctl3_lnk_sts[0] = 0
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_SET(r,d) (r).an_misc_ctl3_lnk_sts[0] = d
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_GET(r) (r).an_misc_ctl3_lnk_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_AN_SPEEDf_GET(r) ((((r).an_misc_ctl3_lnk_sts[0]) >> 8) & 0x7f)
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_AN_SPEEDf_SET(r,f) (r).an_misc_ctl3_lnk_sts[0]=(((r).an_misc_ctl3_lnk_sts[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PAUSE_RESOLUTIONf_GET(r) ((((r).an_misc_ctl3_lnk_sts[0]) >> 6) & 0x3)
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PAUSE_RESOLUTIONf_SET(r,f) (r).an_misc_ctl3_lnk_sts[0]=(((r).an_misc_ctl3_lnk_sts[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_MR_LP_AUTONEG_ABLEf_GET(r) ((((r).an_misc_ctl3_lnk_sts[0]) >> 4) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_MR_LP_AUTONEG_ABLEf_SET(r,f) (r).an_misc_ctl3_lnk_sts[0]=(((r).an_misc_ctl3_lnk_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_DUPLEX_STATUSf_GET(r) ((((r).an_misc_ctl3_lnk_sts[0]) >> 3) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_DUPLEX_STATUSf_SET(r,f) (r).an_misc_ctl3_lnk_sts[0]=(((r).an_misc_ctl3_lnk_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_LINK_STATUSf_GET(r) ((((r).an_misc_ctl3_lnk_sts[0]) >> 2) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_LINK_STATUSf_SET(r,f) (r).an_misc_ctl3_lnk_sts[0]=(((r).an_misc_ctl3_lnk_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PMD_RX_PMD_LOCKf_GET(r) ((((r).an_misc_ctl3_lnk_sts[0]) >> 1) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PMD_RX_PMD_LOCKf_SET(r,f) (r).an_misc_ctl3_lnk_sts[0]=(((r).an_misc_ctl3_lnk_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_AUTONEG_COMPLETEf_GET(r) (((r).an_misc_ctl3_lnk_sts[0]) & 0x1)
#define BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_AUTONEG_COMPLETEf_SET(r,f) (r).an_misc_ctl3_lnk_sts[0]=(((r).an_misc_ctl3_lnk_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_MISC_CTL3_LNK_STS.
 */
#define BCMI_MADURA_READ_AN_MISC_CTL3_LNK_STSr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_MISC_CTL3_LNK_STSr,_r._an_misc_ctl3_lnk_sts)
#define BCMI_MADURA_WRITE_AN_MISC_CTL3_LNK_STSr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_MISC_CTL3_LNK_STSr,_r._an_misc_ctl3_lnk_sts)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_MISC_CTL3_LNK_STSr BCMI_MADURA_AN_MISC_CTL3_LNK_STSr
#define AN_MISC_CTL3_LNK_STSr_SIZE BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_SIZE
typedef BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_t AN_MISC_CTL3_LNK_STSr_t;
#define AN_MISC_CTL3_LNK_STSr_CLR BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CLR
#define AN_MISC_CTL3_LNK_STSr_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_SET
#define AN_MISC_CTL3_LNK_STSr_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_GET
#define AN_MISC_CTL3_LNK_STSr_AN_SPEEDf_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_AN_SPEEDf_GET
#define AN_MISC_CTL3_LNK_STSr_AN_SPEEDf_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_AN_SPEEDf_SET
#define AN_MISC_CTL3_LNK_STSr_PAUSE_RESOLUTIONf_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PAUSE_RESOLUTIONf_GET
#define AN_MISC_CTL3_LNK_STSr_PAUSE_RESOLUTIONf_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PAUSE_RESOLUTIONf_SET
#define AN_MISC_CTL3_LNK_STSr_CL73_MR_LP_AUTONEG_ABLEf_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_MR_LP_AUTONEG_ABLEf_GET
#define AN_MISC_CTL3_LNK_STSr_CL73_MR_LP_AUTONEG_ABLEf_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_MR_LP_AUTONEG_ABLEf_SET
#define AN_MISC_CTL3_LNK_STSr_DUPLEX_STATUSf_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_DUPLEX_STATUSf_GET
#define AN_MISC_CTL3_LNK_STSr_DUPLEX_STATUSf_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_DUPLEX_STATUSf_SET
#define AN_MISC_CTL3_LNK_STSr_LINK_STATUSf_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_LINK_STATUSf_GET
#define AN_MISC_CTL3_LNK_STSr_LINK_STATUSf_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_LINK_STATUSf_SET
#define AN_MISC_CTL3_LNK_STSr_PMD_RX_PMD_LOCKf_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PMD_RX_PMD_LOCKf_GET
#define AN_MISC_CTL3_LNK_STSr_PMD_RX_PMD_LOCKf_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_PMD_RX_PMD_LOCKf_SET
#define AN_MISC_CTL3_LNK_STSr_CL73_AUTONEG_COMPLETEf_GET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_AUTONEG_COMPLETEf_GET
#define AN_MISC_CTL3_LNK_STSr_CL73_AUTONEG_COMPLETEf_SET BCMI_MADURA_AN_MISC_CTL3_LNK_STSr_CL73_AUTONEG_COMPLETEf_SET
#define READ_AN_MISC_CTL3_LNK_STSr BCMI_MADURA_READ_AN_MISC_CTL3_LNK_STSr
#define WRITE_AN_MISC_CTL3_LNK_STSr BCMI_MADURA_WRITE_AN_MISC_CTL3_LNK_STSr
#define MODIFY_AN_MISC_CTL3_LNK_STSr BCMI_MADURA_MODIFY_AN_MISC_CTL3_LNK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_MISC_CTL3_LNK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  AN_MISC_CTL3_ACTUAL_SPD
 * BLOCKS:   AN_MISC_CNTRL3
 * REGADDR:  0xc34e
 * DEVAD:    7
 * DESC:     Actual Speed status
 * RESETVAL: 0xffff (65535)
 * ACCESS:   R/W
 * FIELDS:
 *     ACTUAL_SPEED_RX  Actual baud rate of the Rx lane.8'd0D    1.25 GBd8'd0F    10.3125 GBd8'h80    25.78125GBd8'dFF    Other
 *     ACTUAL_SPEED_TX  When control bit map_osr_mode is NOT set(1'b0)field reflects the baud rate of the Tx lane.8'h0D    1.25 GBd8'h0F    10.3125 GBd8'h80    25.78125GBd8'dFF    OtherWhen control bit map_osr_mode is set(1'b1) then thisthis field reflects the over-sample mode of the lane.4'd0    OSX14'd1    OSX24'd2    OSX44'd8    OSX16P5 or OSX8P254'd12   OSX20P625
 */
#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr (0x0007c34e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_SIZE 4

/*
 * This structure should be used to declare and program AN_MISC_CTL3_ACTUAL_SPD.
 */
typedef union BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_s {
	uint32_t v[1];
	uint32_t an_misc_ctl3_actual_spd[1];
	uint32_t _an_misc_ctl3_actual_spd;
} BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_t;

#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_CLR(r) (r).an_misc_ctl3_actual_spd[0] = 0
#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_SET(r,d) (r).an_misc_ctl3_actual_spd[0] = d
#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_GET(r) (r).an_misc_ctl3_actual_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_TXf_GET(r) ((((r).an_misc_ctl3_actual_spd[0]) >> 8) & 0xff)
#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_TXf_SET(r,f) (r).an_misc_ctl3_actual_spd[0]=(((r).an_misc_ctl3_actual_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_RXf_GET(r) (((r).an_misc_ctl3_actual_spd[0]) & 0xff)
#define BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_RXf_SET(r,f) (r).an_misc_ctl3_actual_spd[0]=(((r).an_misc_ctl3_actual_spd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_MISC_CTL3_ACTUAL_SPD.
 */
#define BCMI_MADURA_READ_AN_MISC_CTL3_ACTUAL_SPDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr,_r._an_misc_ctl3_actual_spd)
#define BCMI_MADURA_WRITE_AN_MISC_CTL3_ACTUAL_SPDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr,_r._an_misc_ctl3_actual_spd)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_MISC_CTL3_ACTUAL_SPDr BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr
#define AN_MISC_CTL3_ACTUAL_SPDr_SIZE BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_SIZE
typedef BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_t AN_MISC_CTL3_ACTUAL_SPDr_t;
#define AN_MISC_CTL3_ACTUAL_SPDr_CLR BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_CLR
#define AN_MISC_CTL3_ACTUAL_SPDr_SET BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_SET
#define AN_MISC_CTL3_ACTUAL_SPDr_GET BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_GET
#define AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_TXf_GET BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_TXf_GET
#define AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_TXf_SET BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_TXf_SET
#define AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_RXf_GET BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_RXf_GET
#define AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_RXf_SET BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr_ACTUAL_SPEED_RXf_SET
#define READ_AN_MISC_CTL3_ACTUAL_SPDr BCMI_MADURA_READ_AN_MISC_CTL3_ACTUAL_SPDr
#define WRITE_AN_MISC_CTL3_ACTUAL_SPDr BCMI_MADURA_WRITE_AN_MISC_CTL3_ACTUAL_SPDr
#define MODIFY_AN_MISC_CTL3_ACTUAL_SPDr BCMI_MADURA_MODIFY_AN_MISC_CTL3_ACTUAL_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_AN_MISC_CTL3_ACTUAL_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_UCTL1
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc370
 * DEVAD:    7
 * DESC:     Clause 73 user control
 * RESETVAL: 0xc (12)
 * ACCESS:   R/W
 * FIELDS:
 *     FORCE_CL73_TX_OMUX_EN Forces output of cl73 dme
 *     CL73_USTAT1_MUXSEL CL73 Status Select Control
 *     RSRVD_BITS       
 *     CL73_NONCE_MATCH_VAL Clause 73 nonce match value
 *     CL73_NONCE_MATCH_OVER Clause 73 nonce match over-ride
 *     LINKFAILTIMERQUAL_EN Qualifty link with Link Fail Inhibit Timer Enable
 *     LINKFAILTIMER_DIS Disable Link Fail Inhibit Timer Enable
 *     CL73_FAST_TIMERS Enable cl73 fast_timers, used for simulation only
 */
#define BCMI_MADURA_CL73_UCTL1r (0x0007c370 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_UCTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL73_UCTL1.
 */
typedef union BCMI_MADURA_CL73_UCTL1r_s {
	uint32_t v[1];
	uint32_t cl73_uctl1[1];
	uint32_t _cl73_uctl1;
} BCMI_MADURA_CL73_UCTL1r_t;

#define BCMI_MADURA_CL73_UCTL1r_CLR(r) (r).cl73_uctl1[0] = 0
#define BCMI_MADURA_CL73_UCTL1r_SET(r,d) (r).cl73_uctl1[0] = d
#define BCMI_MADURA_CL73_UCTL1r_GET(r) (r).cl73_uctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_UCTL1r_CL73_FAST_TIMERSf_GET(r) ((((r).cl73_uctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_UCTL1r_CL73_FAST_TIMERSf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMER_DISf_GET(r) ((((r).cl73_uctl1[0]) >> 8) & 0x1)
#define BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMER_DISf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).cl73_uctl1[0]) >> 7) & 0x1)
#define BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_OVERf_GET(r) ((((r).cl73_uctl1[0]) >> 6) & 0x1)
#define BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_OVERf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_VALf_GET(r) ((((r).cl73_uctl1[0]) >> 5) & 0x1)
#define BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_VALf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_MADURA_CL73_UCTL1r_RSRVD_BITSf_GET(r) ((((r).cl73_uctl1[0]) >> 2) & 0x7)
#define BCMI_MADURA_CL73_UCTL1r_RSRVD_BITSf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_MADURA_CL73_UCTL1r_CL73_USTAT1_MUXSELf_GET(r) ((((r).cl73_uctl1[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL73_UCTL1r_CL73_USTAT1_MUXSELf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL73_UCTL1r_FORCE_CL73_TX_OMUX_ENf_GET(r) (((r).cl73_uctl1[0]) & 0x1)
#define BCMI_MADURA_CL73_UCTL1r_FORCE_CL73_TX_OMUX_ENf_SET(r,f) (r).cl73_uctl1[0]=(((r).cl73_uctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL73_UCTL1.
 */
#define BCMI_MADURA_READ_CL73_UCTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_UCTL1r,_r._cl73_uctl1)
#define BCMI_MADURA_WRITE_CL73_UCTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_UCTL1r,_r._cl73_uctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_UCTL1r BCMI_MADURA_CL73_UCTL1r
#define CL73_UCTL1r_SIZE BCMI_MADURA_CL73_UCTL1r_SIZE
typedef BCMI_MADURA_CL73_UCTL1r_t CL73_UCTL1r_t;
#define CL73_UCTL1r_CLR BCMI_MADURA_CL73_UCTL1r_CLR
#define CL73_UCTL1r_SET BCMI_MADURA_CL73_UCTL1r_SET
#define CL73_UCTL1r_GET BCMI_MADURA_CL73_UCTL1r_GET
#define CL73_UCTL1r_CL73_FAST_TIMERSf_GET BCMI_MADURA_CL73_UCTL1r_CL73_FAST_TIMERSf_GET
#define CL73_UCTL1r_CL73_FAST_TIMERSf_SET BCMI_MADURA_CL73_UCTL1r_CL73_FAST_TIMERSf_SET
#define CL73_UCTL1r_LINKFAILTIMER_DISf_GET BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMER_DISf_GET
#define CL73_UCTL1r_LINKFAILTIMER_DISf_SET BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMER_DISf_SET
#define CL73_UCTL1r_LINKFAILTIMERQUAL_ENf_GET BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMERQUAL_ENf_GET
#define CL73_UCTL1r_LINKFAILTIMERQUAL_ENf_SET BCMI_MADURA_CL73_UCTL1r_LINKFAILTIMERQUAL_ENf_SET
#define CL73_UCTL1r_CL73_NONCE_MATCH_OVERf_GET BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_OVERf_GET
#define CL73_UCTL1r_CL73_NONCE_MATCH_OVERf_SET BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_OVERf_SET
#define CL73_UCTL1r_CL73_NONCE_MATCH_VALf_GET BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_VALf_GET
#define CL73_UCTL1r_CL73_NONCE_MATCH_VALf_SET BCMI_MADURA_CL73_UCTL1r_CL73_NONCE_MATCH_VALf_SET
#define CL73_UCTL1r_RSRVD_BITSf_GET BCMI_MADURA_CL73_UCTL1r_RSRVD_BITSf_GET
#define CL73_UCTL1r_RSRVD_BITSf_SET BCMI_MADURA_CL73_UCTL1r_RSRVD_BITSf_SET
#define CL73_UCTL1r_CL73_USTAT1_MUXSELf_GET BCMI_MADURA_CL73_UCTL1r_CL73_USTAT1_MUXSELf_GET
#define CL73_UCTL1r_CL73_USTAT1_MUXSELf_SET BCMI_MADURA_CL73_UCTL1r_CL73_USTAT1_MUXSELf_SET
#define CL73_UCTL1r_FORCE_CL73_TX_OMUX_ENf_GET BCMI_MADURA_CL73_UCTL1r_FORCE_CL73_TX_OMUX_ENf_GET
#define CL73_UCTL1r_FORCE_CL73_TX_OMUX_ENf_SET BCMI_MADURA_CL73_UCTL1r_FORCE_CL73_TX_OMUX_ENf_SET
#define READ_CL73_UCTL1r BCMI_MADURA_READ_CL73_UCTL1r
#define WRITE_CL73_UCTL1r BCMI_MADURA_WRITE_CL73_UCTL1r
#define MODIFY_CL73_UCTL1r BCMI_MADURA_MODIFY_CL73_UCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_UCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_USTAT1
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc371
 * DEVAD:    7
 * DESC:     Clause 73 user status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ARB_FSM          This field reports all the states ARB_FSM has enteredsince the last clear of this register field.Following table lists the bit fileds associated withARB_FSM stateThis is a read-to-update field
 *     LINK_FAIL_INHIBIT_TIMER_DON When set indicates that that the cl73 link fail inhibittimer has expired. This is a sticky bitthat will remain high until the underlying event is active,after which it will clear on read.
 *     SIGDET_TIMEOUT   When set indicates that that the cl73 signal detecttimer has expired. This is a sticky bitthat will remain high until the underlying event is active,after which it will clear on read.
 *     ACK_NONCE_MATCH  When set indicates that a nonce matchwas detected. This is a sticky bitthat will remain high until the underlying event is active,after which it will clear on read.
 *     INCOMPATIBLE_LINK When set indicates that auto-neg was unableto resolve to a compatible link. This is a sticky bitthat will remain high until the underlying event is active,after which it will clear on read.
 */
#define BCMI_MADURA_CL73_USTAT1r (0x0007c371 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_USTAT1r_SIZE 4

/*
 * This structure should be used to declare and program CL73_USTAT1.
 */
typedef union BCMI_MADURA_CL73_USTAT1r_s {
	uint32_t v[1];
	uint32_t cl73_ustat1[1];
	uint32_t _cl73_ustat1;
} BCMI_MADURA_CL73_USTAT1r_t;

#define BCMI_MADURA_CL73_USTAT1r_CLR(r) (r).cl73_ustat1[0] = 0
#define BCMI_MADURA_CL73_USTAT1r_SET(r,d) (r).cl73_ustat1[0] = d
#define BCMI_MADURA_CL73_USTAT1r_GET(r) (r).cl73_ustat1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_USTAT1r_INCOMPATIBLE_LINKf_GET(r) ((((r).cl73_ustat1[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_USTAT1r_INCOMPATIBLE_LINKf_SET(r,f) (r).cl73_ustat1[0]=(((r).cl73_ustat1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_USTAT1r_ACK_NONCE_MATCHf_GET(r) ((((r).cl73_ustat1[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL73_USTAT1r_ACK_NONCE_MATCHf_SET(r,f) (r).cl73_ustat1[0]=(((r).cl73_ustat1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL73_USTAT1r_SIGDET_TIMEOUTf_GET(r) ((((r).cl73_ustat1[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL73_USTAT1r_SIGDET_TIMEOUTf_SET(r,f) (r).cl73_ustat1[0]=(((r).cl73_ustat1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CL73_USTAT1r_LINK_FAIL_INHIBIT_TIMER_DONf_GET(r) ((((r).cl73_ustat1[0]) >> 12) & 0x1)
#define BCMI_MADURA_CL73_USTAT1r_LINK_FAIL_INHIBIT_TIMER_DONf_SET(r,f) (r).cl73_ustat1[0]=(((r).cl73_ustat1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CL73_USTAT1r_ARB_FSMf_GET(r) (((r).cl73_ustat1[0]) & 0xfff)
#define BCMI_MADURA_CL73_USTAT1r_ARB_FSMf_SET(r,f) (r).cl73_ustat1[0]=(((r).cl73_ustat1[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access CL73_USTAT1.
 */
#define BCMI_MADURA_READ_CL73_USTAT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_USTAT1r,_r._cl73_ustat1)
#define BCMI_MADURA_WRITE_CL73_USTAT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_USTAT1r,_r._cl73_ustat1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_USTAT1r BCMI_MADURA_CL73_USTAT1r
#define CL73_USTAT1r_SIZE BCMI_MADURA_CL73_USTAT1r_SIZE
typedef BCMI_MADURA_CL73_USTAT1r_t CL73_USTAT1r_t;
#define CL73_USTAT1r_CLR BCMI_MADURA_CL73_USTAT1r_CLR
#define CL73_USTAT1r_SET BCMI_MADURA_CL73_USTAT1r_SET
#define CL73_USTAT1r_GET BCMI_MADURA_CL73_USTAT1r_GET
#define CL73_USTAT1r_INCOMPATIBLE_LINKf_GET BCMI_MADURA_CL73_USTAT1r_INCOMPATIBLE_LINKf_GET
#define CL73_USTAT1r_INCOMPATIBLE_LINKf_SET BCMI_MADURA_CL73_USTAT1r_INCOMPATIBLE_LINKf_SET
#define CL73_USTAT1r_ACK_NONCE_MATCHf_GET BCMI_MADURA_CL73_USTAT1r_ACK_NONCE_MATCHf_GET
#define CL73_USTAT1r_ACK_NONCE_MATCHf_SET BCMI_MADURA_CL73_USTAT1r_ACK_NONCE_MATCHf_SET
#define CL73_USTAT1r_SIGDET_TIMEOUTf_GET BCMI_MADURA_CL73_USTAT1r_SIGDET_TIMEOUTf_GET
#define CL73_USTAT1r_SIGDET_TIMEOUTf_SET BCMI_MADURA_CL73_USTAT1r_SIGDET_TIMEOUTf_SET
#define CL73_USTAT1r_LINK_FAIL_INHIBIT_TIMER_DONf_GET BCMI_MADURA_CL73_USTAT1r_LINK_FAIL_INHIBIT_TIMER_DONf_GET
#define CL73_USTAT1r_LINK_FAIL_INHIBIT_TIMER_DONf_SET BCMI_MADURA_CL73_USTAT1r_LINK_FAIL_INHIBIT_TIMER_DONf_SET
#define CL73_USTAT1r_ARB_FSMf_GET BCMI_MADURA_CL73_USTAT1r_ARB_FSMf_GET
#define CL73_USTAT1r_ARB_FSMf_SET BCMI_MADURA_CL73_USTAT1r_ARB_FSMf_SET
#define READ_CL73_USTAT1r BCMI_MADURA_READ_CL73_USTAT1r
#define WRITE_CL73_USTAT1r BCMI_MADURA_WRITE_CL73_USTAT1r
#define MODIFY_CL73_USTAT1r BCMI_MADURA_MODIFY_CL73_USTAT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_USTAT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_BAMCTL1
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc372
 * DEVAD:    7
 * DESC:     Clause 73 BAM control 1 (NOT USED)
 * RESETVAL: 0x6000 (24576)
 * ACCESS:   R/W
 * FIELDS:
 *     UD_CODE_FIELD_41_32 BAM73's User-defined  Code Field bits [41:32], I.e. UD_code_field[41:32]
 *     CL73_HPEN        Enables third party proprietary mode
 *     CL73_BAM_TEST_MP5_HALT_STEP CL73_bam_test_MP5_halt_step
 *     CL73_BAM_TEST_MP5_HALT_EN CL73_bam_test_MP5_halt_en
 *     CL73_BAMNP_AFTER_BP_EN Enables STA to send BAM73 NPs immediately after BP; otherwise send BAM73 NPs following software NPs
 *     CL73_BAM_STATION_MNGR_EN BAM73 Station Manager enable
 *     CL73_BAMEN       Clause73 BAM73 AN enable
 */
#define BCMI_MADURA_CL73_BAMCTL1r (0x0007c372 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_BAMCTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAMCTL1.
 */
typedef union BCMI_MADURA_CL73_BAMCTL1r_s {
	uint32_t v[1];
	uint32_t cl73_bamctl1[1];
	uint32_t _cl73_bamctl1;
} BCMI_MADURA_CL73_BAMCTL1r_t;

#define BCMI_MADURA_CL73_BAMCTL1r_CLR(r) (r).cl73_bamctl1[0] = 0
#define BCMI_MADURA_CL73_BAMCTL1r_SET(r,d) (r).cl73_bamctl1[0] = d
#define BCMI_MADURA_CL73_BAMCTL1r_GET(r) (r).cl73_bamctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMENf_GET(r) ((((r).cl73_bamctl1[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMENf_SET(r,f) (r).cl73_bamctl1[0]=(((r).cl73_bamctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_STATION_MNGR_ENf_GET(r) ((((r).cl73_bamctl1[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_STATION_MNGR_ENf_SET(r,f) (r).cl73_bamctl1[0]=(((r).cl73_bamctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMNP_AFTER_BP_ENf_GET(r) ((((r).cl73_bamctl1[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMNP_AFTER_BP_ENf_SET(r,f) (r).cl73_bamctl1[0]=(((r).cl73_bamctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_ENf_GET(r) ((((r).cl73_bamctl1[0]) >> 12) & 0x1)
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_ENf_SET(r,f) (r).cl73_bamctl1[0]=(((r).cl73_bamctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_STEPf_GET(r) ((((r).cl73_bamctl1[0]) >> 11) & 0x1)
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_STEPf_SET(r,f) (r).cl73_bamctl1[0]=(((r).cl73_bamctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_HPENf_GET(r) ((((r).cl73_bamctl1[0]) >> 10) & 0x1)
#define BCMI_MADURA_CL73_BAMCTL1r_CL73_HPENf_SET(r,f) (r).cl73_bamctl1[0]=(((r).cl73_bamctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_MADURA_CL73_BAMCTL1r_UD_CODE_FIELD_41_32f_GET(r) (((r).cl73_bamctl1[0]) & 0x3ff)
#define BCMI_MADURA_CL73_BAMCTL1r_UD_CODE_FIELD_41_32f_SET(r,f) (r).cl73_bamctl1[0]=(((r).cl73_bamctl1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL73_BAMCTL1.
 */
#define BCMI_MADURA_READ_CL73_BAMCTL1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_BAMCTL1r,_r._cl73_bamctl1)
#define BCMI_MADURA_WRITE_CL73_BAMCTL1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_BAMCTL1r,_r._cl73_bamctl1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAMCTL1r BCMI_MADURA_CL73_BAMCTL1r
#define CL73_BAMCTL1r_SIZE BCMI_MADURA_CL73_BAMCTL1r_SIZE
typedef BCMI_MADURA_CL73_BAMCTL1r_t CL73_BAMCTL1r_t;
#define CL73_BAMCTL1r_CLR BCMI_MADURA_CL73_BAMCTL1r_CLR
#define CL73_BAMCTL1r_SET BCMI_MADURA_CL73_BAMCTL1r_SET
#define CL73_BAMCTL1r_GET BCMI_MADURA_CL73_BAMCTL1r_GET
#define CL73_BAMCTL1r_CL73_BAMENf_GET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMENf_GET
#define CL73_BAMCTL1r_CL73_BAMENf_SET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMENf_SET
#define CL73_BAMCTL1r_CL73_BAM_STATION_MNGR_ENf_GET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_STATION_MNGR_ENf_GET
#define CL73_BAMCTL1r_CL73_BAM_STATION_MNGR_ENf_SET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_STATION_MNGR_ENf_SET
#define CL73_BAMCTL1r_CL73_BAMNP_AFTER_BP_ENf_GET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMNP_AFTER_BP_ENf_GET
#define CL73_BAMCTL1r_CL73_BAMNP_AFTER_BP_ENf_SET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAMNP_AFTER_BP_ENf_SET
#define CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_ENf_GET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_ENf_GET
#define CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_ENf_SET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_ENf_SET
#define CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_STEPf_GET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_STEPf_GET
#define CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_STEPf_SET BCMI_MADURA_CL73_BAMCTL1r_CL73_BAM_TEST_MP5_HALT_STEPf_SET
#define CL73_BAMCTL1r_CL73_HPENf_GET BCMI_MADURA_CL73_BAMCTL1r_CL73_HPENf_GET
#define CL73_BAMCTL1r_CL73_HPENf_SET BCMI_MADURA_CL73_BAMCTL1r_CL73_HPENf_SET
#define CL73_BAMCTL1r_UD_CODE_FIELD_41_32f_GET BCMI_MADURA_CL73_BAMCTL1r_UD_CODE_FIELD_41_32f_GET
#define CL73_BAMCTL1r_UD_CODE_FIELD_41_32f_SET BCMI_MADURA_CL73_BAMCTL1r_UD_CODE_FIELD_41_32f_SET
#define READ_CL73_BAMCTL1r BCMI_MADURA_READ_CL73_BAMCTL1r
#define WRITE_CL73_BAMCTL1r BCMI_MADURA_WRITE_CL73_BAMCTL1r
#define MODIFY_CL73_BAMCTL1r BCMI_MADURA_MODIFY_CL73_BAMCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_BAMCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_BAMCTL2
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc373
 * DEVAD:    7
 * DESC:     Clause 73 BAM control 2 (NOT USED)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UD_CODE_FIELD    Local device user defined code field bits 31:16
 */
#define BCMI_MADURA_CL73_BAMCTL2r (0x0007c373 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_BAMCTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAMCTL2.
 */
typedef union BCMI_MADURA_CL73_BAMCTL2r_s {
	uint32_t v[1];
	uint32_t cl73_bamctl2[1];
	uint32_t _cl73_bamctl2;
} BCMI_MADURA_CL73_BAMCTL2r_t;

#define BCMI_MADURA_CL73_BAMCTL2r_CLR(r) (r).cl73_bamctl2[0] = 0
#define BCMI_MADURA_CL73_BAMCTL2r_SET(r,d) (r).cl73_bamctl2[0] = d
#define BCMI_MADURA_CL73_BAMCTL2r_GET(r) (r).cl73_bamctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_BAMCTL2r_UD_CODE_FIELDf_GET(r) (((r).cl73_bamctl2[0]) & 0xffff)
#define BCMI_MADURA_CL73_BAMCTL2r_UD_CODE_FIELDf_SET(r,f) (r).cl73_bamctl2[0]=(((r).cl73_bamctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL73_BAMCTL2.
 */
#define BCMI_MADURA_READ_CL73_BAMCTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_BAMCTL2r,_r._cl73_bamctl2)
#define BCMI_MADURA_WRITE_CL73_BAMCTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_BAMCTL2r,_r._cl73_bamctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAMCTL2r BCMI_MADURA_CL73_BAMCTL2r
#define CL73_BAMCTL2r_SIZE BCMI_MADURA_CL73_BAMCTL2r_SIZE
typedef BCMI_MADURA_CL73_BAMCTL2r_t CL73_BAMCTL2r_t;
#define CL73_BAMCTL2r_CLR BCMI_MADURA_CL73_BAMCTL2r_CLR
#define CL73_BAMCTL2r_SET BCMI_MADURA_CL73_BAMCTL2r_SET
#define CL73_BAMCTL2r_GET BCMI_MADURA_CL73_BAMCTL2r_GET
#define CL73_BAMCTL2r_UD_CODE_FIELDf_GET BCMI_MADURA_CL73_BAMCTL2r_UD_CODE_FIELDf_GET
#define CL73_BAMCTL2r_UD_CODE_FIELDf_SET BCMI_MADURA_CL73_BAMCTL2r_UD_CODE_FIELDf_SET
#define READ_CL73_BAMCTL2r BCMI_MADURA_READ_CL73_BAMCTL2r
#define WRITE_CL73_BAMCTL2r BCMI_MADURA_WRITE_CL73_BAMCTL2r
#define MODIFY_CL73_BAMCTL2r BCMI_MADURA_MODIFY_CL73_BAMCTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_BAMCTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_BAMCTL3
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc374
 * DEVAD:    7
 * DESC:     Clause 73 BAM control 3 (NOT USED)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UD_CODE_FIELD    Local device user defined code field bits 15:0
 */
#define BCMI_MADURA_CL73_BAMCTL3r (0x0007c374 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_BAMCTL3r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAMCTL3.
 */
typedef union BCMI_MADURA_CL73_BAMCTL3r_s {
	uint32_t v[1];
	uint32_t cl73_bamctl3[1];
	uint32_t _cl73_bamctl3;
} BCMI_MADURA_CL73_BAMCTL3r_t;

#define BCMI_MADURA_CL73_BAMCTL3r_CLR(r) (r).cl73_bamctl3[0] = 0
#define BCMI_MADURA_CL73_BAMCTL3r_SET(r,d) (r).cl73_bamctl3[0] = d
#define BCMI_MADURA_CL73_BAMCTL3r_GET(r) (r).cl73_bamctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_BAMCTL3r_UD_CODE_FIELDf_GET(r) (((r).cl73_bamctl3[0]) & 0xffff)
#define BCMI_MADURA_CL73_BAMCTL3r_UD_CODE_FIELDf_SET(r,f) (r).cl73_bamctl3[0]=(((r).cl73_bamctl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL73_BAMCTL3.
 */
#define BCMI_MADURA_READ_CL73_BAMCTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_BAMCTL3r,_r._cl73_bamctl3)
#define BCMI_MADURA_WRITE_CL73_BAMCTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_BAMCTL3r,_r._cl73_bamctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAMCTL3r BCMI_MADURA_CL73_BAMCTL3r
#define CL73_BAMCTL3r_SIZE BCMI_MADURA_CL73_BAMCTL3r_SIZE
typedef BCMI_MADURA_CL73_BAMCTL3r_t CL73_BAMCTL3r_t;
#define CL73_BAMCTL3r_CLR BCMI_MADURA_CL73_BAMCTL3r_CLR
#define CL73_BAMCTL3r_SET BCMI_MADURA_CL73_BAMCTL3r_SET
#define CL73_BAMCTL3r_GET BCMI_MADURA_CL73_BAMCTL3r_GET
#define CL73_BAMCTL3r_UD_CODE_FIELDf_GET BCMI_MADURA_CL73_BAMCTL3r_UD_CODE_FIELDf_GET
#define CL73_BAMCTL3r_UD_CODE_FIELDf_SET BCMI_MADURA_CL73_BAMCTL3r_UD_CODE_FIELDf_SET
#define READ_CL73_BAMCTL3r BCMI_MADURA_READ_CL73_BAMCTL3r
#define WRITE_CL73_BAMCTL3r BCMI_MADURA_WRITE_CL73_BAMCTL3r
#define MODIFY_CL73_BAMCTL3r BCMI_MADURA_MODIFY_CL73_BAMCTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_BAMCTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_BAMSTAT1
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc375
 * DEVAD:    7
 * DESC:     Clause 73 BAM status 1  (NOT USED)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LP_UD_CODE_FIELD Link Partner user defined code field bits 41:32
 */
#define BCMI_MADURA_CL73_BAMSTAT1r (0x0007c375 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_BAMSTAT1r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAMSTAT1.
 */
typedef union BCMI_MADURA_CL73_BAMSTAT1r_s {
	uint32_t v[1];
	uint32_t cl73_bamstat1[1];
	uint32_t _cl73_bamstat1;
} BCMI_MADURA_CL73_BAMSTAT1r_t;

#define BCMI_MADURA_CL73_BAMSTAT1r_CLR(r) (r).cl73_bamstat1[0] = 0
#define BCMI_MADURA_CL73_BAMSTAT1r_SET(r,d) (r).cl73_bamstat1[0] = d
#define BCMI_MADURA_CL73_BAMSTAT1r_GET(r) (r).cl73_bamstat1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_BAMSTAT1r_LP_UD_CODE_FIELDf_GET(r) (((r).cl73_bamstat1[0]) & 0x3ff)
#define BCMI_MADURA_CL73_BAMSTAT1r_LP_UD_CODE_FIELDf_SET(r,f) (r).cl73_bamstat1[0]=(((r).cl73_bamstat1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access CL73_BAMSTAT1.
 */
#define BCMI_MADURA_READ_CL73_BAMSTAT1r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_BAMSTAT1r,_r._cl73_bamstat1)
#define BCMI_MADURA_WRITE_CL73_BAMSTAT1r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_BAMSTAT1r,_r._cl73_bamstat1)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAMSTAT1r BCMI_MADURA_CL73_BAMSTAT1r
#define CL73_BAMSTAT1r_SIZE BCMI_MADURA_CL73_BAMSTAT1r_SIZE
typedef BCMI_MADURA_CL73_BAMSTAT1r_t CL73_BAMSTAT1r_t;
#define CL73_BAMSTAT1r_CLR BCMI_MADURA_CL73_BAMSTAT1r_CLR
#define CL73_BAMSTAT1r_SET BCMI_MADURA_CL73_BAMSTAT1r_SET
#define CL73_BAMSTAT1r_GET BCMI_MADURA_CL73_BAMSTAT1r_GET
#define CL73_BAMSTAT1r_LP_UD_CODE_FIELDf_GET BCMI_MADURA_CL73_BAMSTAT1r_LP_UD_CODE_FIELDf_GET
#define CL73_BAMSTAT1r_LP_UD_CODE_FIELDf_SET BCMI_MADURA_CL73_BAMSTAT1r_LP_UD_CODE_FIELDf_SET
#define READ_CL73_BAMSTAT1r BCMI_MADURA_READ_CL73_BAMSTAT1r
#define WRITE_CL73_BAMSTAT1r BCMI_MADURA_WRITE_CL73_BAMSTAT1r
#define MODIFY_CL73_BAMSTAT1r BCMI_MADURA_MODIFY_CL73_BAMSTAT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_BAMSTAT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_BAMSTAT2
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc376
 * DEVAD:    7
 * DESC:     Clause 73 BAM status 2  (NOT USED)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LP_UD_CODE_FIELD Link Partner user defined code field bits 31:16
 */
#define BCMI_MADURA_CL73_BAMSTAT2r (0x0007c376 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_BAMSTAT2r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAMSTAT2.
 */
typedef union BCMI_MADURA_CL73_BAMSTAT2r_s {
	uint32_t v[1];
	uint32_t cl73_bamstat2[1];
	uint32_t _cl73_bamstat2;
} BCMI_MADURA_CL73_BAMSTAT2r_t;

#define BCMI_MADURA_CL73_BAMSTAT2r_CLR(r) (r).cl73_bamstat2[0] = 0
#define BCMI_MADURA_CL73_BAMSTAT2r_SET(r,d) (r).cl73_bamstat2[0] = d
#define BCMI_MADURA_CL73_BAMSTAT2r_GET(r) (r).cl73_bamstat2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_BAMSTAT2r_LP_UD_CODE_FIELDf_GET(r) (((r).cl73_bamstat2[0]) & 0xffff)
#define BCMI_MADURA_CL73_BAMSTAT2r_LP_UD_CODE_FIELDf_SET(r,f) (r).cl73_bamstat2[0]=(((r).cl73_bamstat2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL73_BAMSTAT2.
 */
#define BCMI_MADURA_READ_CL73_BAMSTAT2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_BAMSTAT2r,_r._cl73_bamstat2)
#define BCMI_MADURA_WRITE_CL73_BAMSTAT2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_BAMSTAT2r,_r._cl73_bamstat2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAMSTAT2r BCMI_MADURA_CL73_BAMSTAT2r
#define CL73_BAMSTAT2r_SIZE BCMI_MADURA_CL73_BAMSTAT2r_SIZE
typedef BCMI_MADURA_CL73_BAMSTAT2r_t CL73_BAMSTAT2r_t;
#define CL73_BAMSTAT2r_CLR BCMI_MADURA_CL73_BAMSTAT2r_CLR
#define CL73_BAMSTAT2r_SET BCMI_MADURA_CL73_BAMSTAT2r_SET
#define CL73_BAMSTAT2r_GET BCMI_MADURA_CL73_BAMSTAT2r_GET
#define CL73_BAMSTAT2r_LP_UD_CODE_FIELDf_GET BCMI_MADURA_CL73_BAMSTAT2r_LP_UD_CODE_FIELDf_GET
#define CL73_BAMSTAT2r_LP_UD_CODE_FIELDf_SET BCMI_MADURA_CL73_BAMSTAT2r_LP_UD_CODE_FIELDf_SET
#define READ_CL73_BAMSTAT2r BCMI_MADURA_READ_CL73_BAMSTAT2r
#define WRITE_CL73_BAMSTAT2r BCMI_MADURA_WRITE_CL73_BAMSTAT2r
#define MODIFY_CL73_BAMSTAT2r BCMI_MADURA_MODIFY_CL73_BAMSTAT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_BAMSTAT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_BAMSTAT3
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc377
 * DEVAD:    7
 * DESC:     Clause 73 BAM status 3  (NOT USED)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LP_UD_CODE_FIELD Link Partner user defined code field bits 15:0
 */
#define BCMI_MADURA_CL73_BAMSTAT3r (0x0007c377 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_BAMSTAT3r_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAMSTAT3.
 */
typedef union BCMI_MADURA_CL73_BAMSTAT3r_s {
	uint32_t v[1];
	uint32_t cl73_bamstat3[1];
	uint32_t _cl73_bamstat3;
} BCMI_MADURA_CL73_BAMSTAT3r_t;

#define BCMI_MADURA_CL73_BAMSTAT3r_CLR(r) (r).cl73_bamstat3[0] = 0
#define BCMI_MADURA_CL73_BAMSTAT3r_SET(r,d) (r).cl73_bamstat3[0] = d
#define BCMI_MADURA_CL73_BAMSTAT3r_GET(r) (r).cl73_bamstat3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_BAMSTAT3r_LP_UD_CODE_FIELDf_GET(r) (((r).cl73_bamstat3[0]) & 0xffff)
#define BCMI_MADURA_CL73_BAMSTAT3r_LP_UD_CODE_FIELDf_SET(r,f) (r).cl73_bamstat3[0]=(((r).cl73_bamstat3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL73_BAMSTAT3.
 */
#define BCMI_MADURA_READ_CL73_BAMSTAT3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_BAMSTAT3r,_r._cl73_bamstat3)
#define BCMI_MADURA_WRITE_CL73_BAMSTAT3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_BAMSTAT3r,_r._cl73_bamstat3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAMSTAT3r BCMI_MADURA_CL73_BAMSTAT3r
#define CL73_BAMSTAT3r_SIZE BCMI_MADURA_CL73_BAMSTAT3r_SIZE
typedef BCMI_MADURA_CL73_BAMSTAT3r_t CL73_BAMSTAT3r_t;
#define CL73_BAMSTAT3r_CLR BCMI_MADURA_CL73_BAMSTAT3r_CLR
#define CL73_BAMSTAT3r_SET BCMI_MADURA_CL73_BAMSTAT3r_SET
#define CL73_BAMSTAT3r_GET BCMI_MADURA_CL73_BAMSTAT3r_GET
#define CL73_BAMSTAT3r_LP_UD_CODE_FIELDf_GET BCMI_MADURA_CL73_BAMSTAT3r_LP_UD_CODE_FIELDf_GET
#define CL73_BAMSTAT3r_LP_UD_CODE_FIELDf_SET BCMI_MADURA_CL73_BAMSTAT3r_LP_UD_CODE_FIELDf_SET
#define READ_CL73_BAMSTAT3r BCMI_MADURA_READ_CL73_BAMSTAT3r
#define WRITE_CL73_BAMSTAT3r BCMI_MADURA_WRITE_CL73_BAMSTAT3r
#define MODIFY_CL73_BAMSTAT3r BCMI_MADURA_MODIFY_CL73_BAMSTAT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_BAMSTAT3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_UCTL2
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc378
 * DEVAD:    7
 * DESC:     Clause 73 user control2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     HOLD_LP_ABILITY  When set causes the cl73 fsm to hold onto the linkpartner advertised abilities
 *     SIGDET_TIMER_DIS When set disables the cl73 signal detect timer.The signal detect timer causes a reset to thecl73 fsm when a signal is not detected at the WCRx input for approximately 1 sec.  It is recommendedto set this bit when BAM-73 is disabled
 *     RX_DME_STATUS_SEL Rx DME test bus select
 *     AN_GOOD_CHECKTRAP When set causes the cl73 fsm to hold state onceit enters the AN_GOOD_CHECK state
 *     AN_GOODTRAP      When set causes the cl73 fsm to hold state uponentry into the AN_GOOD state
 *     DME_RXSEQDONE_WAIT_DIS If set, this bit will disable RxSeqDone fromreseting CL73 FSM.
 *     AN_ABILITY_WRITE_EN If set, enables write access to the cl73device in package register.
 */
#define BCMI_MADURA_CL73_UCTL2r (0x0007c378 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_UCTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL73_UCTL2.
 */
typedef union BCMI_MADURA_CL73_UCTL2r_s {
	uint32_t v[1];
	uint32_t cl73_uctl2[1];
	uint32_t _cl73_uctl2;
} BCMI_MADURA_CL73_UCTL2r_t;

#define BCMI_MADURA_CL73_UCTL2r_CLR(r) (r).cl73_uctl2[0] = 0
#define BCMI_MADURA_CL73_UCTL2r_SET(r,d) (r).cl73_uctl2[0] = d
#define BCMI_MADURA_CL73_UCTL2r_GET(r) (r).cl73_uctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_UCTL2r_AN_ABILITY_WRITE_ENf_GET(r) ((((r).cl73_uctl2[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_UCTL2r_AN_ABILITY_WRITE_ENf_SET(r,f) (r).cl73_uctl2[0]=(((r).cl73_uctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_UCTL2r_DME_RXSEQDONE_WAIT_DISf_GET(r) ((((r).cl73_uctl2[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL73_UCTL2r_DME_RXSEQDONE_WAIT_DISf_SET(r,f) (r).cl73_uctl2[0]=(((r).cl73_uctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL73_UCTL2r_AN_GOODTRAPf_GET(r) ((((r).cl73_uctl2[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL73_UCTL2r_AN_GOODTRAPf_SET(r,f) (r).cl73_uctl2[0]=(((r).cl73_uctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_MADURA_CL73_UCTL2r_AN_GOOD_CHECKTRAPf_GET(r) ((((r).cl73_uctl2[0]) >> 12) & 0x1)
#define BCMI_MADURA_CL73_UCTL2r_AN_GOOD_CHECKTRAPf_SET(r,f) (r).cl73_uctl2[0]=(((r).cl73_uctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_MADURA_CL73_UCTL2r_RX_DME_STATUS_SELf_GET(r) ((((r).cl73_uctl2[0]) >> 9) & 0x3)
#define BCMI_MADURA_CL73_UCTL2r_RX_DME_STATUS_SELf_SET(r,f) (r).cl73_uctl2[0]=(((r).cl73_uctl2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_MADURA_CL73_UCTL2r_SIGDET_TIMER_DISf_GET(r) ((((r).cl73_uctl2[0]) >> 3) & 0x1)
#define BCMI_MADURA_CL73_UCTL2r_SIGDET_TIMER_DISf_SET(r,f) (r).cl73_uctl2[0]=(((r).cl73_uctl2[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_MADURA_CL73_UCTL2r_HOLD_LP_ABILITYf_GET(r) (((r).cl73_uctl2[0]) & 0x1)
#define BCMI_MADURA_CL73_UCTL2r_HOLD_LP_ABILITYf_SET(r,f) (r).cl73_uctl2[0]=(((r).cl73_uctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL73_UCTL2.
 */
#define BCMI_MADURA_READ_CL73_UCTL2r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_UCTL2r,_r._cl73_uctl2)
#define BCMI_MADURA_WRITE_CL73_UCTL2r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_UCTL2r,_r._cl73_uctl2)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_UCTL2r BCMI_MADURA_CL73_UCTL2r
#define CL73_UCTL2r_SIZE BCMI_MADURA_CL73_UCTL2r_SIZE
typedef BCMI_MADURA_CL73_UCTL2r_t CL73_UCTL2r_t;
#define CL73_UCTL2r_CLR BCMI_MADURA_CL73_UCTL2r_CLR
#define CL73_UCTL2r_SET BCMI_MADURA_CL73_UCTL2r_SET
#define CL73_UCTL2r_GET BCMI_MADURA_CL73_UCTL2r_GET
#define CL73_UCTL2r_AN_ABILITY_WRITE_ENf_GET BCMI_MADURA_CL73_UCTL2r_AN_ABILITY_WRITE_ENf_GET
#define CL73_UCTL2r_AN_ABILITY_WRITE_ENf_SET BCMI_MADURA_CL73_UCTL2r_AN_ABILITY_WRITE_ENf_SET
#define CL73_UCTL2r_DME_RXSEQDONE_WAIT_DISf_GET BCMI_MADURA_CL73_UCTL2r_DME_RXSEQDONE_WAIT_DISf_GET
#define CL73_UCTL2r_DME_RXSEQDONE_WAIT_DISf_SET BCMI_MADURA_CL73_UCTL2r_DME_RXSEQDONE_WAIT_DISf_SET
#define CL73_UCTL2r_AN_GOODTRAPf_GET BCMI_MADURA_CL73_UCTL2r_AN_GOODTRAPf_GET
#define CL73_UCTL2r_AN_GOODTRAPf_SET BCMI_MADURA_CL73_UCTL2r_AN_GOODTRAPf_SET
#define CL73_UCTL2r_AN_GOOD_CHECKTRAPf_GET BCMI_MADURA_CL73_UCTL2r_AN_GOOD_CHECKTRAPf_GET
#define CL73_UCTL2r_AN_GOOD_CHECKTRAPf_SET BCMI_MADURA_CL73_UCTL2r_AN_GOOD_CHECKTRAPf_SET
#define CL73_UCTL2r_RX_DME_STATUS_SELf_GET BCMI_MADURA_CL73_UCTL2r_RX_DME_STATUS_SELf_GET
#define CL73_UCTL2r_RX_DME_STATUS_SELf_SET BCMI_MADURA_CL73_UCTL2r_RX_DME_STATUS_SELf_SET
#define CL73_UCTL2r_SIGDET_TIMER_DISf_GET BCMI_MADURA_CL73_UCTL2r_SIGDET_TIMER_DISf_GET
#define CL73_UCTL2r_SIGDET_TIMER_DISf_SET BCMI_MADURA_CL73_UCTL2r_SIGDET_TIMER_DISf_SET
#define CL73_UCTL2r_HOLD_LP_ABILITYf_GET BCMI_MADURA_CL73_UCTL2r_HOLD_LP_ABILITYf_GET
#define CL73_UCTL2r_HOLD_LP_ABILITYf_SET BCMI_MADURA_CL73_UCTL2r_HOLD_LP_ABILITYf_SET
#define READ_CL73_UCTL2r BCMI_MADURA_READ_CL73_UCTL2r
#define WRITE_CL73_UCTL2r BCMI_MADURA_WRITE_CL73_UCTL2r
#define MODIFY_CL73_UCTL2r BCMI_MADURA_MODIFY_CL73_UCTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_UCTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_UCTL3
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc379
 * DEVAD:    7
 * DESC:     Clause 73 user control3
 * RESETVAL: 0x17a2 (6050)
 * ACCESS:   R/W
 * FIELDS:
 *     ANERR_MAX        
 */
#define BCMI_MADURA_CL73_UCTL3r (0x0007c379 | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_UCTL3r_SIZE 4

/*
 * This structure should be used to declare and program CL73_UCTL3.
 */
typedef union BCMI_MADURA_CL73_UCTL3r_s {
	uint32_t v[1];
	uint32_t cl73_uctl3[1];
	uint32_t _cl73_uctl3;
} BCMI_MADURA_CL73_UCTL3r_t;

#define BCMI_MADURA_CL73_UCTL3r_CLR(r) (r).cl73_uctl3[0] = 0
#define BCMI_MADURA_CL73_UCTL3r_SET(r,d) (r).cl73_uctl3[0] = d
#define BCMI_MADURA_CL73_UCTL3r_GET(r) (r).cl73_uctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_UCTL3r_ANERR_MAXf_GET(r) (((r).cl73_uctl3[0]) & 0xffff)
#define BCMI_MADURA_CL73_UCTL3r_ANERR_MAXf_SET(r,f) (r).cl73_uctl3[0]=(((r).cl73_uctl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL73_UCTL3.
 */
#define BCMI_MADURA_READ_CL73_UCTL3r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_UCTL3r,_r._cl73_uctl3)
#define BCMI_MADURA_WRITE_CL73_UCTL3r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_UCTL3r,_r._cl73_uctl3)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_UCTL3r BCMI_MADURA_CL73_UCTL3r
#define CL73_UCTL3r_SIZE BCMI_MADURA_CL73_UCTL3r_SIZE
typedef BCMI_MADURA_CL73_UCTL3r_t CL73_UCTL3r_t;
#define CL73_UCTL3r_CLR BCMI_MADURA_CL73_UCTL3r_CLR
#define CL73_UCTL3r_SET BCMI_MADURA_CL73_UCTL3r_SET
#define CL73_UCTL3r_GET BCMI_MADURA_CL73_UCTL3r_GET
#define CL73_UCTL3r_ANERR_MAXf_GET BCMI_MADURA_CL73_UCTL3r_ANERR_MAXf_GET
#define CL73_UCTL3r_ANERR_MAXf_SET BCMI_MADURA_CL73_UCTL3r_ANERR_MAXf_SET
#define READ_CL73_UCTL3r BCMI_MADURA_READ_CL73_UCTL3r
#define WRITE_CL73_UCTL3r BCMI_MADURA_WRITE_CL73_UCTL3r
#define MODIFY_CL73_UCTL3r BCMI_MADURA_MODIFY_CL73_UCTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_UCTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_UCTL4
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc37a
 * DEVAD:    7
 * DESC:     Clause 73 user control4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ANERR_TIMER_EN   
 *     CL73_ANERR_STATUS_SEL 
 *     DISABLE_SIGDET_TIMER 
 *     ANERR_TIMER_MASK 
 */
#define BCMI_MADURA_CL73_UCTL4r (0x0007c37a | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_UCTL4r_SIZE 4

/*
 * This structure should be used to declare and program CL73_UCTL4.
 */
typedef union BCMI_MADURA_CL73_UCTL4r_s {
	uint32_t v[1];
	uint32_t cl73_uctl4[1];
	uint32_t _cl73_uctl4;
} BCMI_MADURA_CL73_UCTL4r_t;

#define BCMI_MADURA_CL73_UCTL4r_CLR(r) (r).cl73_uctl4[0] = 0
#define BCMI_MADURA_CL73_UCTL4r_SET(r,d) (r).cl73_uctl4[0] = d
#define BCMI_MADURA_CL73_UCTL4r_GET(r) (r).cl73_uctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_MASKf_GET(r) ((((r).cl73_uctl4[0]) >> 3) & 0x3f)
#define BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_MASKf_SET(r,f) (r).cl73_uctl4[0]=(((r).cl73_uctl4[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3)) | (63 << (16 + 3))
#define BCMI_MADURA_CL73_UCTL4r_DISABLE_SIGDET_TIMERf_GET(r) ((((r).cl73_uctl4[0]) >> 2) & 0x1)
#define BCMI_MADURA_CL73_UCTL4r_DISABLE_SIGDET_TIMERf_SET(r,f) (r).cl73_uctl4[0]=(((r).cl73_uctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_MADURA_CL73_UCTL4r_CL73_ANERR_STATUS_SELf_GET(r) ((((r).cl73_uctl4[0]) >> 1) & 0x1)
#define BCMI_MADURA_CL73_UCTL4r_CL73_ANERR_STATUS_SELf_SET(r,f) (r).cl73_uctl4[0]=(((r).cl73_uctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_ENf_GET(r) (((r).cl73_uctl4[0]) & 0x1)
#define BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_ENf_SET(r,f) (r).cl73_uctl4[0]=(((r).cl73_uctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL73_UCTL4.
 */
#define BCMI_MADURA_READ_CL73_UCTL4r(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_UCTL4r,_r._cl73_uctl4)
#define BCMI_MADURA_WRITE_CL73_UCTL4r(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_UCTL4r,_r._cl73_uctl4)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_UCTL4r BCMI_MADURA_CL73_UCTL4r
#define CL73_UCTL4r_SIZE BCMI_MADURA_CL73_UCTL4r_SIZE
typedef BCMI_MADURA_CL73_UCTL4r_t CL73_UCTL4r_t;
#define CL73_UCTL4r_CLR BCMI_MADURA_CL73_UCTL4r_CLR
#define CL73_UCTL4r_SET BCMI_MADURA_CL73_UCTL4r_SET
#define CL73_UCTL4r_GET BCMI_MADURA_CL73_UCTL4r_GET
#define CL73_UCTL4r_ANERR_TIMER_MASKf_GET BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_MASKf_GET
#define CL73_UCTL4r_ANERR_TIMER_MASKf_SET BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_MASKf_SET
#define CL73_UCTL4r_DISABLE_SIGDET_TIMERf_GET BCMI_MADURA_CL73_UCTL4r_DISABLE_SIGDET_TIMERf_GET
#define CL73_UCTL4r_DISABLE_SIGDET_TIMERf_SET BCMI_MADURA_CL73_UCTL4r_DISABLE_SIGDET_TIMERf_SET
#define CL73_UCTL4r_CL73_ANERR_STATUS_SELf_GET BCMI_MADURA_CL73_UCTL4r_CL73_ANERR_STATUS_SELf_GET
#define CL73_UCTL4r_CL73_ANERR_STATUS_SELf_SET BCMI_MADURA_CL73_UCTL4r_CL73_ANERR_STATUS_SELf_SET
#define CL73_UCTL4r_ANERR_TIMER_ENf_GET BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_ENf_GET
#define CL73_UCTL4r_ANERR_TIMER_ENf_SET BCMI_MADURA_CL73_UCTL4r_ANERR_TIMER_ENf_SET
#define READ_CL73_UCTL4r BCMI_MADURA_READ_CL73_UCTL4r
#define WRITE_CL73_UCTL4r BCMI_MADURA_WRITE_CL73_UCTL4r
#define MODIFY_CL73_UCTL4r BCMI_MADURA_MODIFY_CL73_UCTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_UCTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_BAMCODEFLD
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc37b
 * DEVAD:    7
 * DESC:     Clause 73 BAM Code Field  (NOT USED)
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_FIELD        def controlled by cl73_hpEn_def, h157 for HP, h002 for BAM3
 *     NEXT_PAGE_STATUS Determines the value of extended next page status bit, 7.1.7,when Gallardo 40nm mode is disabled.
 */
#define BCMI_MADURA_CL73_BAMCODEFLDr (0x0007c37b | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_BAMCODEFLDr_SIZE 4

/*
 * This structure should be used to declare and program CL73_BAMCODEFLD.
 */
typedef union BCMI_MADURA_CL73_BAMCODEFLDr_s {
	uint32_t v[1];
	uint32_t cl73_bamcodefld[1];
	uint32_t _cl73_bamcodefld;
} BCMI_MADURA_CL73_BAMCODEFLDr_t;

#define BCMI_MADURA_CL73_BAMCODEFLDr_CLR(r) (r).cl73_bamcodefld[0] = 0
#define BCMI_MADURA_CL73_BAMCODEFLDr_SET(r,d) (r).cl73_bamcodefld[0] = d
#define BCMI_MADURA_CL73_BAMCODEFLDr_GET(r) (r).cl73_bamcodefld[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_BAMCODEFLDr_NEXT_PAGE_STATUSf_GET(r) ((((r).cl73_bamcodefld[0]) >> 9) & 0x1)
#define BCMI_MADURA_CL73_BAMCODEFLDr_NEXT_PAGE_STATUSf_SET(r,f) (r).cl73_bamcodefld[0]=(((r).cl73_bamcodefld[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_MADURA_CL73_BAMCODEFLDr_BAM_FIELDf_GET(r) (((r).cl73_bamcodefld[0]) & 0x1ff)
#define BCMI_MADURA_CL73_BAMCODEFLDr_BAM_FIELDf_SET(r,f) (r).cl73_bamcodefld[0]=(((r).cl73_bamcodefld[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access CL73_BAMCODEFLD.
 */
#define BCMI_MADURA_READ_CL73_BAMCODEFLDr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_BAMCODEFLDr,_r._cl73_bamcodefld)
#define BCMI_MADURA_WRITE_CL73_BAMCODEFLDr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_BAMCODEFLDr,_r._cl73_bamcodefld)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_BAMCODEFLDr BCMI_MADURA_CL73_BAMCODEFLDr
#define CL73_BAMCODEFLDr_SIZE BCMI_MADURA_CL73_BAMCODEFLDr_SIZE
typedef BCMI_MADURA_CL73_BAMCODEFLDr_t CL73_BAMCODEFLDr_t;
#define CL73_BAMCODEFLDr_CLR BCMI_MADURA_CL73_BAMCODEFLDr_CLR
#define CL73_BAMCODEFLDr_SET BCMI_MADURA_CL73_BAMCODEFLDr_SET
#define CL73_BAMCODEFLDr_GET BCMI_MADURA_CL73_BAMCODEFLDr_GET
#define CL73_BAMCODEFLDr_NEXT_PAGE_STATUSf_GET BCMI_MADURA_CL73_BAMCODEFLDr_NEXT_PAGE_STATUSf_GET
#define CL73_BAMCODEFLDr_NEXT_PAGE_STATUSf_SET BCMI_MADURA_CL73_BAMCODEFLDr_NEXT_PAGE_STATUSf_SET
#define CL73_BAMCODEFLDr_BAM_FIELDf_GET BCMI_MADURA_CL73_BAMCODEFLDr_BAM_FIELDf_GET
#define CL73_BAMCODEFLDr_BAM_FIELDf_SET BCMI_MADURA_CL73_BAMCODEFLDr_BAM_FIELDf_SET
#define READ_CL73_BAMCODEFLDr BCMI_MADURA_READ_CL73_BAMCODEFLDr
#define WRITE_CL73_BAMCODEFLDr BCMI_MADURA_WRITE_CL73_BAMCODEFLDr
#define MODIFY_CL73_BAMCODEFLDr BCMI_MADURA_MODIFY_CL73_BAMCODEFLDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_BAMCODEFLDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_MADURA
 * REGISTER:  CL73_EEECTL
 * BLOCKS:   CL73_USER_BLK0
 * REGADDR:  0xc37e
 * DEVAD:    7
 * DESC:     Clause 73 EEE control (NOT USED)
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/W
 * FIELDS:
 *     HOLD_EEE_LP_ABILITY Hold linp partner EEE ability
 *     CL73_EEENP_AFTER_BP_EN Enables STA to send EEE73 NPs immediately after BP; otherwise send EEE73 NPs following software NPs
 *     CL73_EEEEN       Clause73 EEE enable
 */
#define BCMI_MADURA_CL73_EEECTLr (0x0007c37e | PHYMOD_REG_ACC_RAW)

#define BCMI_MADURA_CL73_EEECTLr_SIZE 4

/*
 * This structure should be used to declare and program CL73_EEECTL.
 */
typedef union BCMI_MADURA_CL73_EEECTLr_s {
	uint32_t v[1];
	uint32_t cl73_eeectl[1];
	uint32_t _cl73_eeectl;
} BCMI_MADURA_CL73_EEECTLr_t;

#define BCMI_MADURA_CL73_EEECTLr_CLR(r) (r).cl73_eeectl[0] = 0
#define BCMI_MADURA_CL73_EEECTLr_SET(r,d) (r).cl73_eeectl[0] = d
#define BCMI_MADURA_CL73_EEECTLr_GET(r) (r).cl73_eeectl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_MADURA_CL73_EEECTLr_CL73_EEEENf_GET(r) ((((r).cl73_eeectl[0]) >> 15) & 0x1)
#define BCMI_MADURA_CL73_EEECTLr_CL73_EEEENf_SET(r,f) (r).cl73_eeectl[0]=(((r).cl73_eeectl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_MADURA_CL73_EEECTLr_CL73_EEENP_AFTER_BP_ENf_GET(r) ((((r).cl73_eeectl[0]) >> 14) & 0x1)
#define BCMI_MADURA_CL73_EEECTLr_CL73_EEENP_AFTER_BP_ENf_SET(r,f) (r).cl73_eeectl[0]=(((r).cl73_eeectl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_MADURA_CL73_EEECTLr_HOLD_EEE_LP_ABILITYf_GET(r) ((((r).cl73_eeectl[0]) >> 13) & 0x1)
#define BCMI_MADURA_CL73_EEECTLr_HOLD_EEE_LP_ABILITYf_SET(r,f) (r).cl73_eeectl[0]=(((r).cl73_eeectl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access CL73_EEECTL.
 */
#define BCMI_MADURA_READ_CL73_EEECTLr(_pc,_r) PHYMOD_BUS_READ(_pc,BCMI_MADURA_CL73_EEECTLr,_r._cl73_eeectl)
#define BCMI_MADURA_WRITE_CL73_EEECTLr(_pc,_r) PHYMOD_BUS_WRITE(_pc,BCMI_MADURA_CL73_EEECTLr,_r._cl73_eeectl)

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL73_EEECTLr BCMI_MADURA_CL73_EEECTLr
#define CL73_EEECTLr_SIZE BCMI_MADURA_CL73_EEECTLr_SIZE
typedef BCMI_MADURA_CL73_EEECTLr_t CL73_EEECTLr_t;
#define CL73_EEECTLr_CLR BCMI_MADURA_CL73_EEECTLr_CLR
#define CL73_EEECTLr_SET BCMI_MADURA_CL73_EEECTLr_SET
#define CL73_EEECTLr_GET BCMI_MADURA_CL73_EEECTLr_GET
#define CL73_EEECTLr_CL73_EEEENf_GET BCMI_MADURA_CL73_EEECTLr_CL73_EEEENf_GET
#define CL73_EEECTLr_CL73_EEEENf_SET BCMI_MADURA_CL73_EEECTLr_CL73_EEEENf_SET
#define CL73_EEECTLr_CL73_EEENP_AFTER_BP_ENf_GET BCMI_MADURA_CL73_EEECTLr_CL73_EEENP_AFTER_BP_ENf_GET
#define CL73_EEECTLr_CL73_EEENP_AFTER_BP_ENf_SET BCMI_MADURA_CL73_EEECTLr_CL73_EEENP_AFTER_BP_ENf_SET
#define CL73_EEECTLr_HOLD_EEE_LP_ABILITYf_GET BCMI_MADURA_CL73_EEECTLr_HOLD_EEE_LP_ABILITYf_GET
#define CL73_EEECTLr_HOLD_EEE_LP_ABILITYf_SET BCMI_MADURA_CL73_EEECTLr_HOLD_EEE_LP_ABILITYf_SET
#define READ_CL73_EEECTLr BCMI_MADURA_READ_CL73_EEECTLr
#define WRITE_CL73_EEECTLr BCMI_MADURA_WRITE_CL73_EEECTLr
#define MODIFY_CL73_EEECTLr BCMI_MADURA_MODIFY_CL73_EEECTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_MADURA_CL73_EEECTLr'
 */




#endif /* __BCMI_MADURA_DEFS_H__ */
