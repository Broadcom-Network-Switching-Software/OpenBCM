#ifndef __BCMI_TSCBH_FLEXE_XGXS_DEFS_H__
#define __BCMI_TSCBH_FLEXE_XGXS_DEFS_H__
/*******************************************************************************
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_TSCBH_FLEXE_XGXS.
 * This file provides all basic definitions required to program the BCMI_TSCBH_FLEXE_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 */

#ifndef _DV_TB_
#include <phymod/acc/phymod_tsc_iblk.h>
#endif /* _DV_TB_ */

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PHYID2
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0002
 * DESC:     IEEE phyID2 Register
 * RESETVAL: 0x600d (24589)
 * ACCESS:   R/O
 * FIELDS:
 *     REGID1           PHYID2 register
 */
#define BCMI_TSCBH_FLEXE_XGXS_PHYID2r (0x00000002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PHYID2r_SIZE 4

/*
 * This structure should be used to declare and program PHYID2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PHYID2r_s {
	uint32_t v[1];
	uint32_t phyid2[1];
	uint32_t _phyid2;
} BCMI_TSCBH_FLEXE_XGXS_PHYID2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PHYID2r_CLR(r) (r).phyid2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PHYID2r_SET(r,d) (r).phyid2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PHYID2r_GET(r) (r).phyid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PHYID2r_REGID1f_GET(r) (((r).phyid2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PHYID2r_REGID1f_SET(r,f) (r).phyid2[0]=(((r).phyid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PHYID2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PHYID2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PHYID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID2r,(_r._phyid2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PHYID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PHYID2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PHYID2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PHYID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHYID2r BCMI_TSCBH_FLEXE_XGXS_PHYID2r
#define PHYID2r_SIZE BCMI_TSCBH_FLEXE_XGXS_PHYID2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PHYID2r_t PHYID2r_t;
#define PHYID2r_CLR BCMI_TSCBH_FLEXE_XGXS_PHYID2r_CLR
#define PHYID2r_SET BCMI_TSCBH_FLEXE_XGXS_PHYID2r_SET
#define PHYID2r_GET BCMI_TSCBH_FLEXE_XGXS_PHYID2r_GET
#define PHYID2r_REGID1f_GET BCMI_TSCBH_FLEXE_XGXS_PHYID2r_REGID1f_GET
#define PHYID2r_REGID1f_SET BCMI_TSCBH_FLEXE_XGXS_PHYID2r_REGID1f_SET
#define READ_PHYID2r BCMI_TSCBH_FLEXE_XGXS_READ_PHYID2r
#define WRITE_PHYID2r BCMI_TSCBH_FLEXE_XGXS_WRITE_PHYID2r
#define MODIFY_PHYID2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PHYID2r
#define READLN_PHYID2r BCMI_TSCBH_FLEXE_XGXS_READLN_PHYID2r
#define WRITELN_PHYID2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PHYID2r
#define WRITEALL_PHYID2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PHYID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PHYID2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PHYID3
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0003
 * DESC:     IEEE phyID3 Register
 * RESETVAL: 0x8770 (34672)
 * ACCESS:   R/O
 * FIELDS:
 *     REGID2           PHYID3 register
 */
#define BCMI_TSCBH_FLEXE_XGXS_PHYID3r (0x00000003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PHYID3r_SIZE 4

/*
 * This structure should be used to declare and program PHYID3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PHYID3r_s {
	uint32_t v[1];
	uint32_t phyid3[1];
	uint32_t _phyid3;
} BCMI_TSCBH_FLEXE_XGXS_PHYID3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PHYID3r_CLR(r) (r).phyid3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PHYID3r_SET(r,d) (r).phyid3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PHYID3r_GET(r) (r).phyid3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PHYID3r_REGID2f_GET(r) (((r).phyid3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PHYID3r_REGID2f_SET(r,f) (r).phyid3[0]=(((r).phyid3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PHYID3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PHYID3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PHYID3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID3r,(_r._phyid3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PHYID3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PHYID3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PHYID3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PHYID3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHYID3r BCMI_TSCBH_FLEXE_XGXS_PHYID3r
#define PHYID3r_SIZE BCMI_TSCBH_FLEXE_XGXS_PHYID3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PHYID3r_t PHYID3r_t;
#define PHYID3r_CLR BCMI_TSCBH_FLEXE_XGXS_PHYID3r_CLR
#define PHYID3r_SET BCMI_TSCBH_FLEXE_XGXS_PHYID3r_SET
#define PHYID3r_GET BCMI_TSCBH_FLEXE_XGXS_PHYID3r_GET
#define PHYID3r_REGID2f_GET BCMI_TSCBH_FLEXE_XGXS_PHYID3r_REGID2f_GET
#define PHYID3r_REGID2f_SET BCMI_TSCBH_FLEXE_XGXS_PHYID3r_REGID2f_SET
#define READ_PHYID3r BCMI_TSCBH_FLEXE_XGXS_READ_PHYID3r
#define WRITE_PHYID3r BCMI_TSCBH_FLEXE_XGXS_WRITE_PHYID3r
#define MODIFY_PHYID3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PHYID3r
#define READLN_PHYID3r BCMI_TSCBH_FLEXE_XGXS_READLN_PHYID3r
#define WRITELN_PHYID3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PHYID3r
#define WRITEALL_PHYID3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PHYID3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PHYID3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_SETUP
 * BLOCKS:   MAIN0
 * REGADDR:  0x9000
 * DESC:     main control register
 * RESETVAL: 0x85 (133)
 * ACCESS:   R/W
 * FIELDS:
 *     LOW_LATENCY_TDM_MODE This field controls the tdm mode when the resolved_port_mode_control==100: Dual Port Mode for this MPP01: Single Port Mode for this MPP1x: Single Port Mode for the entire PM.
 *     FCLK_SEL         PLL Source for FCLK used for Time-stamping:0: FCLK sourced from PLL_0 (VCO0)1: FCLK sourced from PLL_1 (VCO1)
 *     RESOLVED_PORT_MODE_CONTROL Determines how the resolved_port_mode is formulated:0: Based on the port_mode_sel, and the num_lanes1: Based on the port_mode_sel only
 *     PORT_MODE_SEL    port configuration selectsTRI_1_PORT - lanes 2,3 aggregated and 0,1 as 3 portsTRI_2_PORT - lanes 1,0 aggregated and 3,2 as 3 ports
 *     REFCLK_SEL       THE VERSION OF THIS FIELD USED BY THE LOGIC RESIDES IN MPP0 ONLY.THE VERSION OF THIS FIELD IN MPP1 HAS NO EFFECT ON THE LOGIC.Specifies refclk frequency for tick generation only.0,3,4,5,6,7 = N/A
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr (0x00109000 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SETUP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_s {
	uint32_t v[1];
	uint32_t main0_setup[1];
	uint32_t _main0_setup;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_CLR(r) (r).main0_setup[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_SET(r,d) (r).main0_setup[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_GET(r) (r).main0_setup[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_REFCLK_SELf_GET(r) ((((r).main0_setup[0]) >> 7) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_REFCLK_SELf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_GET(r) ((((r).main0_setup[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_RESOLVED_PORT_MODE_CONTROLf_GET(r) ((((r).main0_setup[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_RESOLVED_PORT_MODE_CONTROLf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_FCLK_SELf_GET(r) ((((r).main0_setup[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_FCLK_SELf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_LOW_LATENCY_TDM_MODEf_GET(r) (((r).main0_setup[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_LOW_LATENCY_TDM_MODEf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_SETUP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_SETUPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr,(_r._main0_setup))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_SETUPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr,(_r._main0_setup)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_SETUPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr,(_r._main0_setup))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SETUPr BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr
#define MAIN0_SETUPr_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_t MAIN0_SETUPr_t;
#define MAIN0_SETUPr_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_CLR
#define MAIN0_SETUPr_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_SET
#define MAIN0_SETUPr_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_GET
#define MAIN0_SETUPr_REFCLK_SELf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_REFCLK_SELf_GET
#define MAIN0_SETUPr_REFCLK_SELf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_REFCLK_SELf_SET
#define MAIN0_SETUPr_PORT_MODE_SELf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_GET
#define MAIN0_SETUPr_PORT_MODE_SELf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_SET
#define MAIN0_SETUPr_RESOLVED_PORT_MODE_CONTROLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_RESOLVED_PORT_MODE_CONTROLf_GET
#define MAIN0_SETUPr_RESOLVED_PORT_MODE_CONTROLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_RESOLVED_PORT_MODE_CONTROLf_SET
#define MAIN0_SETUPr_FCLK_SELf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_FCLK_SELf_GET
#define MAIN0_SETUPr_FCLK_SELf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_FCLK_SELf_SET
#define MAIN0_SETUPr_LOW_LATENCY_TDM_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_LOW_LATENCY_TDM_MODEf_GET
#define MAIN0_SETUPr_LOW_LATENCY_TDM_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr_LOW_LATENCY_TDM_MODEf_SET
#define READ_MAIN0_SETUPr BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_SETUPr
#define WRITE_MAIN0_SETUPr BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_SETUPr
#define MODIFY_MAIN0_SETUPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_SETUPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_SETUPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_DEVINPKG5
 * BLOCKS:   MAIN0
 * REGADDR:  0x9002
 * DESC:     Devices in Package5
 * RESETVAL: 0x83 (131)
 * ACCESS:   R/O
 * FIELDS:
 *     CLAUSE22         1 = Clause 22 registers present in package0 = Clause 22 registers not present in package
 *     PMA_PMD          1 = PMA/PMD present in package0 = PMA/PMD not present in package
 *     WIS              1 = WIS present in package0 = WIS not present in package
 *     PCS_XS           1 = PCS present in package0 = PCS not present in package
 *     PHY_XS           1 = PHY XS present in package0 = PHY XS not present in package
 *     DTE_XS           1 = DTE XS present in package0 = DTE XS not present in package
 *     TC               1 = TC present in package0 = TC not present in package
 *     AN               1 = Auto-Negotiation present in package0 = Auto-Negotiation not present in package
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r (0x00109002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_DEVINPKG5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_s {
	uint32_t v[1];
	uint32_t main0_devinpkg5[1];
	uint32_t _main0_devinpkg5;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_CLR(r) (r).main0_devinpkg5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_SET(r,d) (r).main0_devinpkg5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_GET(r) (r).main0_devinpkg5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_ANf_GET(r) ((((r).main0_devinpkg5[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_ANf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_TCf_GET(r) ((((r).main0_devinpkg5[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_TCf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_WISf_GET(r) ((((r).main0_devinpkg5[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_WISf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_GET(r) ((((r).main0_devinpkg5[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_GET(r) (((r).main0_devinpkg5[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_DEVINPKG5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_DEVINPKG5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_DEVINPKG5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_DEVINPKG5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_DEVINPKG5r BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r
#define MAIN0_DEVINPKG5r_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_t MAIN0_DEVINPKG5r_t;
#define MAIN0_DEVINPKG5r_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_CLR
#define MAIN0_DEVINPKG5r_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_SET
#define MAIN0_DEVINPKG5r_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_GET
#define MAIN0_DEVINPKG5r_ANf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_ANf_GET
#define MAIN0_DEVINPKG5r_ANf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_ANf_SET
#define MAIN0_DEVINPKG5r_TCf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_TCf_GET
#define MAIN0_DEVINPKG5r_TCf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_TCf_SET
#define MAIN0_DEVINPKG5r_DTE_XSf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_GET
#define MAIN0_DEVINPKG5r_DTE_XSf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_SET
#define MAIN0_DEVINPKG5r_PHY_XSf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_GET
#define MAIN0_DEVINPKG5r_PHY_XSf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_SET
#define MAIN0_DEVINPKG5r_PCS_XSf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_GET
#define MAIN0_DEVINPKG5r_PCS_XSf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_SET
#define MAIN0_DEVINPKG5r_WISf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_WISf_GET
#define MAIN0_DEVINPKG5r_WISf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_WISf_SET
#define MAIN0_DEVINPKG5r_PMA_PMDf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_GET
#define MAIN0_DEVINPKG5r_PMA_PMDf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_SET
#define MAIN0_DEVINPKG5r_CLAUSE22f_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_GET
#define MAIN0_DEVINPKG5r_CLAUSE22f_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_SET
#define READ_MAIN0_DEVINPKG5r BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_DEVINPKG5r
#define WRITE_MAIN0_DEVINPKG5r BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_DEVINPKG5r
#define MODIFY_MAIN0_DEVINPKG5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_DEVINPKG5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_DEVINPKG5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_TICK_CTL1
 * BLOCKS:   MAIN0
 * REGADDR:  0x9003
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TICK_NUMERATOR_UPPER Bits [18:4] of the tick numerator.  Used when tick_override is trueTHE VERSION OF THIS FIELD USED BY THE LOGIC RESIDES IN MPP0 ONLYTHE VERSION OF THIS FIELD IN MPP1 HAS NO EFFECT ON THE LOGIC
 *     TICK_OVERRIDE    Enables override of tick counts instead of using refclk_selTHE VERSION OF THIS FIELD USED BY THE LOGIC RESIDES IN MPP0 ONLYTHE VERSION OF THIS FIELD IN MPP1 HAS NO EFFECT ON THE LOGIC
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r (0x00109003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TICK_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_s {
	uint32_t v[1];
	uint32_t main0_tick_ctl1[1];
	uint32_t _main0_tick_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_CLR(r) (r).main0_tick_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_SET(r,d) (r).main0_tick_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_GET(r) (r).main0_tick_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET(r) ((((r).main0_tick_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET(r,f) (r).main0_tick_ctl1[0]=(((r).main0_tick_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET(r) (((r).main0_tick_ctl1[0]) & 0x7fff)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET(r,f) (r).main0_tick_ctl1[0]=(((r).main0_tick_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access MAIN0_TICK_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_TICK_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_TICK_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_TICK_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TICK_CTL1r BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r
#define MAIN0_TICK_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_t MAIN0_TICK_CTL1r_t;
#define MAIN0_TICK_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_CLR
#define MAIN0_TICK_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_SET
#define MAIN0_TICK_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_GET
#define MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET
#define MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET
#define MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET
#define MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET
#define READ_MAIN0_TICK_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_TICK_CTL1r
#define WRITE_MAIN0_TICK_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_TICK_CTL1r
#define MODIFY_MAIN0_TICK_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_TICK_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_TICK_CTL0
 * BLOCKS:   MAIN0
 * REGADDR:  0x9004
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TICK_DENOMINATOR Tick denominator.  Used when tick_override is trueTHE VERSION OF THIS FIELD USED BY THE LOGIC RESIDES IN MPP0 ONLYTHE VERSION OF THIS FIELD IN MPP1 HAS NO EFFECT ON THE LOGIC
 *     TICK_NUMERATOR_LOWER Bits [3:0] of the tick numerator.  Used when tick_override is trueTHE VERSION OF THIS FIELD USED BY THE LOGIC RESIDES IN MPP0 ONLYTHE VERSION OF THIS FIELD IN MPP1 HAS NO EFFECT ON THE LOGIC
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r (0x00109004 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TICK_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_s {
	uint32_t v[1];
	uint32_t main0_tick_ctl0[1];
	uint32_t _main0_tick_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_CLR(r) (r).main0_tick_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_SET(r,d) (r).main0_tick_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_GET(r) (r).main0_tick_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET(r) ((((r).main0_tick_ctl0[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET(r,f) (r).main0_tick_ctl0[0]=(((r).main0_tick_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET(r) ((((r).main0_tick_ctl0[0]) >> 2) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET(r,f) (r).main0_tick_ctl0[0]=(((r).main0_tick_ctl0[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2)) | (1023 << (16 + 2))

/*
 * These macros can be used to access MAIN0_TICK_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_TICK_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_TICK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_TICK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TICK_CTL0r BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r
#define MAIN0_TICK_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_t MAIN0_TICK_CTL0r_t;
#define MAIN0_TICK_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_CLR
#define MAIN0_TICK_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_SET
#define MAIN0_TICK_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_GET
#define MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET
#define MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET
#define MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET
#define MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET
#define READ_MAIN0_TICK_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_TICK_CTL0r
#define WRITE_MAIN0_TICK_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_TICK_CTL0r
#define MODIFY_MAIN0_TICK_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_TICK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_TICK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_SERDESID
 * BLOCKS:   MAIN0
 * REGADDR:  0x9008
 * DESC:     Serdes ID Register
 * RESETVAL: 0x328 (808)
 * ACCESS:   R/O
 * FIELDS:
 *     MODEL_NUMBER     Same as phyID model number
 *     TECH_PROC        
 *     BONDING          
 *     REV_NUMBER       
 *     REV_LETTER       
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr (0x00109008 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SERDESID.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_s {
	uint32_t v[1];
	uint32_t main0_serdesid[1];
	uint32_t _main0_serdesid;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_CLR(r) (r).main0_serdesid[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_SET(r,d) (r).main0_serdesid[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_GET(r) (r).main0_serdesid[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_LETTERf_GET(r) ((((r).main0_serdesid[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_LETTERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_GET(r) ((((r).main0_serdesid[0]) >> 11) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_BONDINGf_GET(r) ((((r).main0_serdesid[0]) >> 9) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_BONDINGf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_TECH_PROCf_GET(r) ((((r).main0_serdesid[0]) >> 6) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_TECH_PROCf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_GET(r) (((r).main0_serdesid[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access MAIN0_SERDESID.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_SERDESIDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_SERDESIDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_SERDESIDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SERDESIDr BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr
#define MAIN0_SERDESIDr_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_t MAIN0_SERDESIDr_t;
#define MAIN0_SERDESIDr_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_CLR
#define MAIN0_SERDESIDr_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_SET
#define MAIN0_SERDESIDr_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_GET
#define MAIN0_SERDESIDr_REV_LETTERf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_LETTERf_GET
#define MAIN0_SERDESIDr_REV_LETTERf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_LETTERf_SET
#define MAIN0_SERDESIDr_REV_NUMBERf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_GET
#define MAIN0_SERDESIDr_REV_NUMBERf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_SET
#define MAIN0_SERDESIDr_BONDINGf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_BONDINGf_GET
#define MAIN0_SERDESIDr_BONDINGf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_BONDINGf_SET
#define MAIN0_SERDESIDr_TECH_PROCf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_TECH_PROCf_GET
#define MAIN0_SERDESIDr_TECH_PROCf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_TECH_PROCf_SET
#define MAIN0_SERDESIDr_MODEL_NUMBERf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_GET
#define MAIN0_SERDESIDr_MODEL_NUMBERf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_SET
#define READ_MAIN0_SERDESIDr BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_SERDESIDr
#define WRITE_MAIN0_SERDESIDr BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_SERDESIDr
#define MODIFY_MAIN0_SERDESIDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_SERDESIDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_SERDESIDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_ECC_DIS_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x9009
 * DESC:     ECC disable control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ECC_DISABLE_BASE_R_FEC When this bit is 1, ECC generation and checking are Disabled on all base_r_fec SRF instances.When this bit is 0, ECC generation and checking are Enabled  on all base_r_fec SRF instances.
 *     ECC_DISABLE_RSFEC_RBUF_MPP When this bit is 1, ECC generation and checking are Disabled on all rsfec_rbuf_mpp SRF instances.When this bit is 0, ECC generation and checking are Enabled  on all rsfec_rbuf_mpp SRF instances.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_DISABLE_RSFEC_RS400G_MPP When this bit is 1, ECC generation and checking are Disabled on all rsfec_rs400g_mpp SRF instances.When this bit is 0, ECC generation and checking are Enabled  on all rsfec_rs400g_mpp SRF instances.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_DISABLE_DESKEW When this bit is 1, ECC generation and checking are Disabled on all deskew SRF instances.When this bit is 0, ECC generation and checking are Enabled  on all deskew SRF instances.
 *     ECC_DISABLE_SPD_TBL When this bit is 1, ECC generation and checking are Disabled on spd_tbl SRF instance.When this bit is 0, ECC generation and checking are Enabled  on spd_tbl SRF instance.
 *     ECC_DISABLE_AM_TBL When this bit is 1, ECC generation and checking are Disabled on am_tbl SRF instance.When this bit is 0, ECC generation and checking are Enabled  on am_tbl SRF instance.
 *     ECC_DISABLE_UM_TBL When this bit is 1, ECC generation and checking are Disabled on um_tbl SRF instance.When this bit is 0, ECC generation and checking are Enabled  on um_tbl SRF instance.
 *     ECC_DISABLE_TX_1588_MPP When this bit is 1, ECC generation and checking are Disabled on tx_1588_mpp SRF instance.When this bit is 0, ECC generation and checking are Enabled  on tx_1588_mpp SRF instance.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_DISABLE_TX_1588_400G When this bit is 1, ECC generation and checking are Disabled on tx_1588_400g SRF instance.When this bit is 0, ECC generation and checking are Enabled  on tx_1588_400g SRF instance.
 *     ECC_DISABLE_RX_1588_MPP When this bit is 1, ECC generation and checking are Disabled on rx_1588_mpp SRF instance.When this bit is 0, ECC generation and checking are Enabled  on rx_1588_mpp SRF instance.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0NOTE: for rx 1588 only, the memories are divided into an even memory (for even address entries)and an odd memory (for odd address entries), instead of mpp0 and mpp1 memories.Thus, the rx 1588 ecc mpp0 registers are used for the even memory, and the mpp1 registers for the odd memory.
 *     ECC_DISABLE_RX_1588_400G When this bit is 1, ECC generation and checking are Disabled on rx_1588_400g SRF instance.When this bit is 0, ECC generation and checking are Enabled  on rx_1588_400g SRF instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr (0x00109009 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_ECC_DIS_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_s {
	uint32_t v[1];
	uint32_t main0_ecc_dis_ctl[1];
	uint32_t _main0_ecc_dis_ctl;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_CLR(r) (r).main0_ecc_dis_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_SET(r,d) (r).main0_ecc_dis_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_GET(r) (r).main0_ecc_dis_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_400Gf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_400Gf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_MPPf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_MPPf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_400Gf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_400Gf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_MPPf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_MPPf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_UM_TBLf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_UM_TBLf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_AM_TBLf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_AM_TBLf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_SPD_TBLf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_SPD_TBLf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_DESKEWf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_DESKEWf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RS400G_MPPf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RS400G_MPPf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RBUF_MPPf_GET(r) ((((r).main0_ecc_dis_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RBUF_MPPf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_BASE_R_FECf_GET(r) (((r).main0_ecc_dis_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_BASE_R_FECf_SET(r,f) (r).main0_ecc_dis_ctl[0]=(((r).main0_ecc_dis_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_ECC_DIS_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_DIS_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr,(_r._main0_ecc_dis_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_DIS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr,(_r._main0_ecc_dis_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_DIS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr,(_r._main0_ecc_dis_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_ECC_DIS_CTLr BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr
#define MAIN0_ECC_DIS_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_t MAIN0_ECC_DIS_CTLr_t;
#define MAIN0_ECC_DIS_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_CLR
#define MAIN0_ECC_DIS_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_SET
#define MAIN0_ECC_DIS_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_400Gf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_400Gf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_MPPf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RX_1588_MPPf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_400Gf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_400Gf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_MPPf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_TX_1588_MPPf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_UM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_UM_TBLf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_UM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_UM_TBLf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_AM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_AM_TBLf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_AM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_AM_TBLf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_SPD_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_SPD_TBLf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_SPD_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_SPD_TBLf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_DESKEWf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_DESKEWf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_DESKEWf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_DESKEWf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RS400G_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RS400G_MPPf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RS400G_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RS400G_MPPf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RBUF_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RBUF_MPPf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RBUF_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_RSFEC_RBUF_MPPf_SET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_BASE_R_FECf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_BASE_R_FECf_GET
#define MAIN0_ECC_DIS_CTLr_ECC_DISABLE_BASE_R_FECf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr_ECC_DISABLE_BASE_R_FECf_SET
#define READ_MAIN0_ECC_DIS_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_DIS_CTLr
#define WRITE_MAIN0_ECC_DIS_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_DIS_CTLr
#define MODIFY_MAIN0_ECC_DIS_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_DIS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_DIS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_ECC_1B_ERR_INTR_EN
 * BLOCKS:   MAIN0
 * REGADDR:  0x900a
 * DESC:     ECC 1bit error Interrupt control register
 * RESETVAL: 0x5beb (23531)
 * ACCESS:   R/W
 * FIELDS:
 *     ECC_1B_ERR_INTR_EN_BASE_R_FEC When this bit is 1, ECC 1bit correctable error on any base_r_fec SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on any base_r_fec SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_1B_ERR_INTR_EN_RSFEC_RBUF_MPP When this bit is 1, ECC 1bit correctable error on any rsfec_rbuf_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on any rsfec_rbuf_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_1B_ERR_INTR_EN_RSFEC_RS400G_MPP When this bit is 1, ECC 1bit correctable error on any rsfec_rs400g_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on any rsfec_rs400g_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_1B_ERR_INTR_EN_DESKEW When this bit is 1, ECC 1bit correctable error on any deskew SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on any deskew SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_1B_ERR_INTR_EN_SPD_TBL When this bit is 1, ECC 1bit correctable error on spd_tbl SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on spd_tbl SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_1B_ERR_INTR_EN_AM_TBL When this bit is 1, ECC 1bit correctable error on am_tbl SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on am_tbl SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_1B_ERR_INTR_EN_UM_TBL When this bit is 1, ECC 1bit correctable error on um_tbl SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on um_tbl SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_1B_ERR_INTR_EN_TX_1588_MPP When this bit is 1, ECC 1bit correctable error on tx_1588_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on tx_1588_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_1B_ERR_INTR_EN_TX_1588_400G When this bit is 1, ECC 1bit correctable error on tx_1588_400g SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on tx_1588_400g SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_1B_ERR_INTR_EN_RX_1588_MPP When this bit is 1, ECC 1bit correctable error on rx_1588_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on rx_1588_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0NOTE: for rx 1588 only, the memories are divided into an even memory (for even address entries)and an odd memory (for odd address entries), instead of mpp0 and mpp1 memories.Thus, the rx 1588 ecc mpp0 registers are used for the even memory, and the mpp1 registers for the odd memory.
 *     ECC_1B_ERR_INTR_EN_RX_1588_400G When this bit is 1, ECC 1bit correctable error on rx_1588_400g SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 1bit correctable error on rx_1588_400g SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr (0x0010900a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_ECC_1B_ERR_INTR_EN.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_s {
	uint32_t v[1];
	uint32_t main0_ecc_1b_err_intr_en[1];
	uint32_t _main0_ecc_1b_err_intr_en;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_CLR(r) (r).main0_ecc_1b_err_intr_en[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_SET(r,d) (r).main0_ecc_1b_err_intr_en[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_GET(r) (r).main0_ecc_1b_err_intr_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_400Gf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_400Gf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_MPPf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_MPPf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_400Gf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_400Gf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_MPPf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_MPPf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_UM_TBLf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_UM_TBLf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_AM_TBLf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_AM_TBLf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_SPD_TBLf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_SPD_TBLf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_DESKEWf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_DESKEWf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RS400G_MPPf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RS400G_MPPf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RBUF_MPPf_GET(r) ((((r).main0_ecc_1b_err_intr_en[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RBUF_MPPf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_BASE_R_FECf_GET(r) (((r).main0_ecc_1b_err_intr_en[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_BASE_R_FECf_SET(r,f) (r).main0_ecc_1b_err_intr_en[0]=(((r).main0_ecc_1b_err_intr_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_ECC_1B_ERR_INTR_EN.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_1B_ERR_INTR_ENr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr,(_r._main0_ecc_1b_err_intr_en))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_1B_ERR_INTR_ENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr,(_r._main0_ecc_1b_err_intr_en)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_1B_ERR_INTR_ENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr,(_r._main0_ecc_1b_err_intr_en))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_ECC_1B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr
#define MAIN0_ECC_1B_ERR_INTR_ENr_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_t MAIN0_ECC_1B_ERR_INTR_ENr_t;
#define MAIN0_ECC_1B_ERR_INTR_ENr_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_CLR
#define MAIN0_ECC_1B_ERR_INTR_ENr_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_400Gf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_400Gf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_MPPf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RX_1588_MPPf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_400Gf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_400Gf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_MPPf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_TX_1588_MPPf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_UM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_UM_TBLf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_UM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_UM_TBLf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_AM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_AM_TBLf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_AM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_AM_TBLf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_SPD_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_SPD_TBLf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_SPD_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_SPD_TBLf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_DESKEWf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_DESKEWf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_DESKEWf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_DESKEWf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RS400G_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RS400G_MPPf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RS400G_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RS400G_MPPf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RBUF_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RBUF_MPPf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RBUF_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_RSFEC_RBUF_MPPf_SET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_BASE_R_FECf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_BASE_R_FECf_GET
#define MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_BASE_R_FECf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr_ECC_1B_ERR_INTR_EN_BASE_R_FECf_SET
#define READ_MAIN0_ECC_1B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_1B_ERR_INTR_ENr
#define WRITE_MAIN0_ECC_1B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_1B_ERR_INTR_ENr
#define MODIFY_MAIN0_ECC_1B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_1B_ERR_INTR_ENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_1B_ERR_INTR_ENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_ECC_2B_ERR_INTR_EN
 * BLOCKS:   MAIN0
 * REGADDR:  0x900b
 * DESC:     ECC 2bit error Interrupt control register
 * RESETVAL: 0x5beb (23531)
 * ACCESS:   R/W
 * FIELDS:
 *     ECC_2B_ERR_INTR_EN_BASE_R_FEC When this bit is 1, ECC 2bit uncorrectable error on any base_r_fec SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on any base_r_fec SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_2B_ERR_INTR_EN_RSFEC_RBUF_MPP When this bit is 1, ECC 2bit uncorrectable error on any rsfec_rbuf_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on any rsfec_rbuf_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_2B_ERR_INTR_EN_RSFEC_RS400G_MPP When this bit is 1, ECC 2bit uncorrectable error on any rsfec_rs400g_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on any rsfec_rs400g_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_2B_ERR_INTR_EN_DESKEW When this bit is 1, ECC 2bit uncorrectable error on any deskew SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on any deskew SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_2B_ERR_INTR_EN_SPD_TBL When this bit is 1, ECC 2bit uncorrectable error on spd_tbl SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on spd_tbl SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_2B_ERR_INTR_EN_AM_TBL When this bit is 1, ECC 2bit uncorrectable error on am_tbl SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on am_tbl SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_2B_ERR_INTR_EN_UM_TBL When this bit is 1, ECC 2bit uncorrectable error on um_tbl SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on um_tbl SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_2B_ERR_INTR_EN_TX_1588_MPP When this bit is 1, ECC 2bit uncorrectable error on tx_1588_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on tx_1588_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_2B_ERR_INTR_EN_TX_1588_400G When this bit is 1, ECC 2bit uncorrectable error on tx_1588_400g SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on tx_1588_400g SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 *     ECC_2B_ERR_INTR_EN_RX_1588_MPP When this bit is 1, ECC 2bit uncorrectable error on rx_1588_mpp SRF instance will set PCS output u[0/1]_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit uncorrectable error on rx_1588_mpp SRF instance will NOT affect PCS output u[0/1]_pcs_ecc_error_interruptFields marked _mpp will use per-MPP register, else the copy resides only in MPP0NOTE: for rx 1588 only, the memories are divided into an even memory (for even address entries)and an odd memory (for odd address entries), instead of mpp0 and mpp1 memories.Thus, the rx 1588 ecc mpp0 registers are used for the even memory, and the mpp1 registers for the odd memory.
 *     ECC_2B_ERR_INTR_EN_RX_1588_400G When this bit is 1, ECC 2bit correctable error on rx_1588_400g SRF instance will set PCS output u0_pcs_ecc_error_interrupt to 1When this bit is 0, ECC 2bit correctable error on rx_1588_400g SRF instance will NOT affect PCS output u0_pcs_ecc_error_interrupt
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr (0x0010900b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_ECC_2B_ERR_INTR_EN.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_s {
	uint32_t v[1];
	uint32_t main0_ecc_2b_err_intr_en[1];
	uint32_t _main0_ecc_2b_err_intr_en;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_CLR(r) (r).main0_ecc_2b_err_intr_en[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_SET(r,d) (r).main0_ecc_2b_err_intr_en[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_GET(r) (r).main0_ecc_2b_err_intr_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_400Gf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_400Gf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_MPPf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_MPPf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_400Gf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_400Gf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_MPPf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_MPPf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_UM_TBLf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_UM_TBLf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_AM_TBLf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_AM_TBLf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_SPD_TBLf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_SPD_TBLf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_DESKEWf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_DESKEWf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RS400G_MPPf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RS400G_MPPf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RBUF_MPPf_GET(r) ((((r).main0_ecc_2b_err_intr_en[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RBUF_MPPf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_BASE_R_FECf_GET(r) (((r).main0_ecc_2b_err_intr_en[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_BASE_R_FECf_SET(r,f) (r).main0_ecc_2b_err_intr_en[0]=(((r).main0_ecc_2b_err_intr_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_ECC_2B_ERR_INTR_EN.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_2B_ERR_INTR_ENr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr,(_r._main0_ecc_2b_err_intr_en))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_2B_ERR_INTR_ENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr,(_r._main0_ecc_2b_err_intr_en)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_2B_ERR_INTR_ENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr,(_r._main0_ecc_2b_err_intr_en))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_ECC_2B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr
#define MAIN0_ECC_2B_ERR_INTR_ENr_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_t MAIN0_ECC_2B_ERR_INTR_ENr_t;
#define MAIN0_ECC_2B_ERR_INTR_ENr_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_CLR
#define MAIN0_ECC_2B_ERR_INTR_ENr_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_400Gf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_400Gf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_MPPf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RX_1588_MPPf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_400Gf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_400Gf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_MPPf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_TX_1588_MPPf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_UM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_UM_TBLf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_UM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_UM_TBLf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_AM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_AM_TBLf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_AM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_AM_TBLf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_SPD_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_SPD_TBLf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_SPD_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_SPD_TBLf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_DESKEWf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_DESKEWf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_DESKEWf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_DESKEWf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RS400G_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RS400G_MPPf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RS400G_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RS400G_MPPf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RBUF_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RBUF_MPPf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RBUF_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_RSFEC_RBUF_MPPf_SET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_BASE_R_FECf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_BASE_R_FECf_GET
#define MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_BASE_R_FECf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr_ECC_2B_ERR_INTR_EN_BASE_R_FECf_SET
#define READ_MAIN0_ECC_2B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_2B_ERR_INTR_ENr
#define WRITE_MAIN0_ECC_2B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_2B_ERR_INTR_ENr
#define MODIFY_MAIN0_ECC_2B_ERR_INTR_ENr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_2B_ERR_INTR_ENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_2B_ERR_INTR_ENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_ECC_CORRUPT_CTL0
 * BLOCKS:   MAIN0
 * REGADDR:  0x900c
 * DESC:     ECC Error Injection control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ECC_CORRUPT_BASE_R_FEC ECC Error Injection for all base_r_fec SRF instances.
 *     ECC_CORRUPT_RSFEC_RBUF_MPP ECC Error Injection for all rsfec_rbuf_mpp SRF instances.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_CORRUPT_RSFEC_RS400G_MPP ECC Error Injection for all rsfec_s400gf_mpp SRF instances.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_CORRUPT_DESKEW ECC Error Injection for all deskew SRF instances.
 *     ECC_CORRUPT_SPD_TBL ECC Error Injection for spd_tbl SRF instance.
 *     ECC_CORRUPT_AM_TBL ECC Error Injection for am_tbl SRF instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r (0x0010900c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_ECC_CORRUPT_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_s {
	uint32_t v[1];
	uint32_t main0_ecc_corrupt_ctl0[1];
	uint32_t _main0_ecc_corrupt_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_CLR(r) (r).main0_ecc_corrupt_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_SET(r,d) (r).main0_ecc_corrupt_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_GET(r) (r).main0_ecc_corrupt_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_AM_TBLf_GET(r) ((((r).main0_ecc_corrupt_ctl0[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_AM_TBLf_SET(r,f) (r).main0_ecc_corrupt_ctl0[0]=(((r).main0_ecc_corrupt_ctl0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_SPD_TBLf_GET(r) ((((r).main0_ecc_corrupt_ctl0[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_SPD_TBLf_SET(r,f) (r).main0_ecc_corrupt_ctl0[0]=(((r).main0_ecc_corrupt_ctl0[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_DESKEWf_GET(r) ((((r).main0_ecc_corrupt_ctl0[0]) >> 10) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_DESKEWf_SET(r,f) (r).main0_ecc_corrupt_ctl0[0]=(((r).main0_ecc_corrupt_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RS400G_MPPf_GET(r) ((((r).main0_ecc_corrupt_ctl0[0]) >> 6) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RS400G_MPPf_SET(r,f) (r).main0_ecc_corrupt_ctl0[0]=(((r).main0_ecc_corrupt_ctl0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RBUF_MPPf_GET(r) ((((r).main0_ecc_corrupt_ctl0[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RBUF_MPPf_SET(r,f) (r).main0_ecc_corrupt_ctl0[0]=(((r).main0_ecc_corrupt_ctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_BASE_R_FECf_GET(r) (((r).main0_ecc_corrupt_ctl0[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_BASE_R_FECf_SET(r,f) (r).main0_ecc_corrupt_ctl0[0]=(((r).main0_ecc_corrupt_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_ECC_CORRUPT_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_CORRUPT_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r,(_r._main0_ecc_corrupt_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_CORRUPT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r,(_r._main0_ecc_corrupt_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_CORRUPT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r,(_r._main0_ecc_corrupt_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_ECC_CORRUPT_CTL0r BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r
#define MAIN0_ECC_CORRUPT_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_t MAIN0_ECC_CORRUPT_CTL0r_t;
#define MAIN0_ECC_CORRUPT_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_CLR
#define MAIN0_ECC_CORRUPT_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_SET
#define MAIN0_ECC_CORRUPT_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_GET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_AM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_AM_TBLf_GET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_AM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_AM_TBLf_SET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_SPD_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_SPD_TBLf_GET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_SPD_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_SPD_TBLf_SET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_DESKEWf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_DESKEWf_GET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_DESKEWf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_DESKEWf_SET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RS400G_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RS400G_MPPf_GET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RS400G_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RS400G_MPPf_SET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RBUF_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RBUF_MPPf_GET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RBUF_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_RSFEC_RBUF_MPPf_SET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_BASE_R_FECf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_BASE_R_FECf_GET
#define MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_BASE_R_FECf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r_ECC_CORRUPT_BASE_R_FECf_SET
#define READ_MAIN0_ECC_CORRUPT_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_CORRUPT_CTL0r
#define WRITE_MAIN0_ECC_CORRUPT_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_CORRUPT_CTL0r
#define MODIFY_MAIN0_ECC_CORRUPT_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_CORRUPT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_ECC_CORRUPT_CTL1
 * BLOCKS:   MAIN0
 * REGADDR:  0x900d
 * DESC:     ECC Error Injection control register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ECC_CORRUPT_UM_TBL ECC Error Injection for um_tbl SRF instance.
 *     ECC_CORRUPT_TX_1588_MPP ECC Error Injection for tx_1588_mpp SRF instance.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0
 *     ECC_CORRUPT_TX_1588_400G ECC Error Injection for tx_1588_400g SRF instance.
 *     ECC_CORRUPT_RX_1588_MPP ECC Error Injection for rx_1588_mpp SRF instance.Fields marked _mpp will use per-MPP register, else the copy resides only in MPP0NOTE: for rx 1588 only, the memories are divided into an even memory (for even address entries)and an odd memory (for odd address entries), instead of mpp0 and mpp1 memories.Thus, the rx 1588 ecc mpp0 registers are used for the even memory, and the mpp1 registers for the odd memory.
 *     ECC_CORRUPT_RX_1588_400G ECC Error Injection for rx_1588_400g SRF instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r (0x0010900d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_ECC_CORRUPT_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_s {
	uint32_t v[1];
	uint32_t main0_ecc_corrupt_ctl1[1];
	uint32_t _main0_ecc_corrupt_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_CLR(r) (r).main0_ecc_corrupt_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_SET(r,d) (r).main0_ecc_corrupt_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_GET(r) (r).main0_ecc_corrupt_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_400Gf_GET(r) ((((r).main0_ecc_corrupt_ctl1[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_400Gf_SET(r,f) (r).main0_ecc_corrupt_ctl1[0]=(((r).main0_ecc_corrupt_ctl1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_MPPf_GET(r) ((((r).main0_ecc_corrupt_ctl1[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_MPPf_SET(r,f) (r).main0_ecc_corrupt_ctl1[0]=(((r).main0_ecc_corrupt_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_400Gf_GET(r) ((((r).main0_ecc_corrupt_ctl1[0]) >> 6) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_400Gf_SET(r,f) (r).main0_ecc_corrupt_ctl1[0]=(((r).main0_ecc_corrupt_ctl1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_MPPf_GET(r) ((((r).main0_ecc_corrupt_ctl1[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_MPPf_SET(r,f) (r).main0_ecc_corrupt_ctl1[0]=(((r).main0_ecc_corrupt_ctl1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_UM_TBLf_GET(r) (((r).main0_ecc_corrupt_ctl1[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_UM_TBLf_SET(r,f) (r).main0_ecc_corrupt_ctl1[0]=(((r).main0_ecc_corrupt_ctl1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_ECC_CORRUPT_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_CORRUPT_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r,(_r._main0_ecc_corrupt_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_CORRUPT_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r,(_r._main0_ecc_corrupt_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_CORRUPT_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r,(_r._main0_ecc_corrupt_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_ECC_CORRUPT_CTL1r BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r
#define MAIN0_ECC_CORRUPT_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_t MAIN0_ECC_CORRUPT_CTL1r_t;
#define MAIN0_ECC_CORRUPT_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_CLR
#define MAIN0_ECC_CORRUPT_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_SET
#define MAIN0_ECC_CORRUPT_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_GET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_400Gf_GET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_400Gf_SET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_MPPf_GET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_RX_1588_MPPf_SET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_400Gf_GET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_400Gf_SET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_MPPf_GET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_TX_1588_MPPf_SET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_UM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_UM_TBLf_GET
#define MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_UM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r_ECC_CORRUPT_UM_TBLf_SET
#define READ_MAIN0_ECC_CORRUPT_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_ECC_CORRUPT_CTL1r
#define WRITE_MAIN0_ECC_CORRUPT_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_ECC_CORRUPT_CTL1r
#define MODIFY_MAIN0_ECC_CORRUPT_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_ECC_CORRUPT_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_ECC_CORRUPT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MAIN0_TM_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x900e
 * DESC:     TM control bits for all SRF instances in TSCBH PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SRF_MEM_TM       TM control bits for all SRF instances in TSCBH PCS
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr (0x0010900e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TM_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_s {
	uint32_t v[1];
	uint32_t main0_tm_ctl[1];
	uint32_t _main0_tm_ctl;
} BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_CLR(r) (r).main0_tm_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SET(r,d) (r).main0_tm_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_GET(r) (r).main0_tm_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SRF_MEM_TMf_GET(r) (((r).main0_tm_ctl[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SRF_MEM_TMf_SET(r,f) (r).main0_tm_ctl[0]=(((r).main0_tm_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MAIN0_TM_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_TM_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr,(_r._main0_tm_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_TM_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr,(_r._main0_tm_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_TM_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr,(_r._main0_tm_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TM_CTLr BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr
#define MAIN0_TM_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_t MAIN0_TM_CTLr_t;
#define MAIN0_TM_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_CLR
#define MAIN0_TM_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SET
#define MAIN0_TM_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_GET
#define MAIN0_TM_CTLr_SRF_MEM_TMf_GET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SRF_MEM_TMf_GET
#define MAIN0_TM_CTLr_SRF_MEM_TMf_SET BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr_SRF_MEM_TMf_SET
#define READ_MAIN0_TM_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_MAIN0_TM_CTLr
#define WRITE_MAIN0_TM_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_MAIN0_TM_CTLr
#define MODIFY_MAIN0_TM_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MAIN0_TM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MAIN0_TM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X1_CTL
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9010
 * DESC:     Global PMD reset controls
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_DP_H_RSTB_OEN Override enable for PMD Core data path reset
 *     CORE_DP_H_RSTB   PMD Core data path reset override valueDefault is zero to keep PMD in reset till enabled
 *     POR_H_RSTB       PMD Core power on resetDefault is zero to keep PMD in reset till enabled
 *     CORE_MODE_SPEED_ID PMD core mode speed_id field.
 *     CORE_MODE_SPARE  PMD core mode bits whose use is currently tbd.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr (0x00109010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x1_ctl[1];
	uint32_t _pmd_x1_ctl;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CLR(r) (r).pmd_x1_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_SET(r,d) (r).pmd_x1_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_GET(r) (r).pmd_x1_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPAREf_GET(r) ((((r).pmd_x1_ctl[0]) >> 9) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPAREf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPEED_IDf_GET(r) ((((r).pmd_x1_ctl[0]) >> 3) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPEED_IDf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3)) | (63 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET(r) ((((r).pmd_x1_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET(r) ((((r).pmd_x1_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTB_OENf_GET(r) (((r).pmd_x1_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X1_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X1_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X1_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_CTLr BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr
#define PMD_X1_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_t PMD_X1_CTLr_t;
#define PMD_X1_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CLR
#define PMD_X1_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_SET
#define PMD_X1_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_GET
#define PMD_X1_CTLr_CORE_MODE_SPAREf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPAREf_GET
#define PMD_X1_CTLr_CORE_MODE_SPAREf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPAREf_SET
#define PMD_X1_CTLr_CORE_MODE_SPEED_IDf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPEED_IDf_GET
#define PMD_X1_CTLr_CORE_MODE_SPEED_IDf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_MODE_SPEED_IDf_SET
#define PMD_X1_CTLr_POR_H_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET
#define PMD_X1_CTLr_POR_H_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET
#define PMD_X1_CTLr_CORE_DP_H_RSTB_OENf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTB_OENf_GET
#define PMD_X1_CTLr_CORE_DP_H_RSTB_OENf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTB_OENf_SET
#define READ_PMD_X1_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X1_CTLr
#define WRITE_PMD_X1_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X1_CTLr
#define MODIFY_PMD_X1_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X1_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X1_PM_TMR_OFFS
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9011
 * DESC:     PM TIMER OFFSET CONTROL REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PM_OFFSET_SUB_NS Unsigned offset in sub nanoseconds to add to 52bit timestamp at PCS level to account for top level device staging registers. Used by TX only.
 *     PM_OFFSET_IN_NS  Unsigned offset in nanoseconds to add to 52bit timestamp at PCS level to account for top level device staging registers. Used by TX only.Reset value represents 0ns.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr (0x00109011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_PM_TMR_OFFS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_s {
	uint32_t v[1];
	uint32_t pmd_x1_pm_tmr_offs[1];
	uint32_t _pmd_x1_pm_tmr_offs;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_CLR(r) (r).pmd_x1_pm_tmr_offs[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_SET(r,d) (r).pmd_x1_pm_tmr_offs[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_GET(r) (r).pmd_x1_pm_tmr_offs[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_IN_NSf_GET(r) ((((r).pmd_x1_pm_tmr_offs[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_IN_NSf_SET(r,f) (r).pmd_x1_pm_tmr_offs[0]=(((r).pmd_x1_pm_tmr_offs[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_SUB_NSf_GET(r) (((r).pmd_x1_pm_tmr_offs[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_SUB_NSf_SET(r,f) (r).pmd_x1_pm_tmr_offs[0]=(((r).pmd_x1_pm_tmr_offs[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PMD_X1_PM_TMR_OFFS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X1_PM_TMR_OFFSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr,(_r._pmd_x1_pm_tmr_offs))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X1_PM_TMR_OFFSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr,(_r._pmd_x1_pm_tmr_offs)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X1_PM_TMR_OFFSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr,(_r._pmd_x1_pm_tmr_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_PM_TMR_OFFSr BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr
#define PMD_X1_PM_TMR_OFFSr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_t PMD_X1_PM_TMR_OFFSr_t;
#define PMD_X1_PM_TMR_OFFSr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_CLR
#define PMD_X1_PM_TMR_OFFSr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_SET
#define PMD_X1_PM_TMR_OFFSr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_GET
#define PMD_X1_PM_TMR_OFFSr_PM_OFFSET_IN_NSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_IN_NSf_GET
#define PMD_X1_PM_TMR_OFFSr_PM_OFFSET_IN_NSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_IN_NSf_SET
#define PMD_X1_PM_TMR_OFFSr_PM_OFFSET_SUB_NSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_SUB_NSf_GET
#define PMD_X1_PM_TMR_OFFSr_PM_OFFSET_SUB_NSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr_PM_OFFSET_SUB_NSf_SET
#define READ_PMD_X1_PM_TMR_OFFSr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X1_PM_TMR_OFFSr
#define WRITE_PMD_X1_PM_TMR_OFFSr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X1_PM_TMR_OFFSr
#define MODIFY_PMD_X1_PM_TMR_OFFSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X1_PM_TMR_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X1_PM_TMR_OFFSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X1_FCLK_PERIOD
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9012
 * DESC:     GLAS Fast_clk_period
 * RESETVAL: 0x634c (25420)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_FRAC_NS     Fractional nanoseconds equal to 1 FCLK period (PMD output clock afe_pll1_clk4sync)For VCO=20.625   GHz, and afe_pll1_clk4sync=VCOdiv8, use 0x634CFor VCO=20.625   GHz, and afe_pll1_clk4sync=VCOdiv6, use 0x4A79For VCO=25.78125 GHz, and afe_pll1_clk4sync=VCOdiv8, use 0x4F70For VCO=26.5625  GHz, and afe_pll1_clk4sync=VCOdiv8, use 0x4D19
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr (0x00109012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_FCLK_PERIOD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_s {
	uint32_t v[1];
	uint32_t pmd_x1_fclk_period[1];
	uint32_t _pmd_x1_fclk_period;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_CLR(r) (r).pmd_x1_fclk_period[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_SET(r,d) (r).pmd_x1_fclk_period[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_GET(r) (r).pmd_x1_fclk_period[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_FCLK_FRAC_NSf_GET(r) (((r).pmd_x1_fclk_period[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_FCLK_FRAC_NSf_SET(r,f) (r).pmd_x1_fclk_period[0]=(((r).pmd_x1_fclk_period[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X1_FCLK_PERIOD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X1_FCLK_PERIODr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr,(_r._pmd_x1_fclk_period))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X1_FCLK_PERIODr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr,(_r._pmd_x1_fclk_period)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X1_FCLK_PERIODr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr,(_r._pmd_x1_fclk_period))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_FCLK_PERIODr BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr
#define PMD_X1_FCLK_PERIODr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_t PMD_X1_FCLK_PERIODr_t;
#define PMD_X1_FCLK_PERIODr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_CLR
#define PMD_X1_FCLK_PERIODr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_SET
#define PMD_X1_FCLK_PERIODr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_GET
#define PMD_X1_FCLK_PERIODr_FCLK_FRAC_NSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_FCLK_FRAC_NSf_GET
#define PMD_X1_FCLK_PERIODr_FCLK_FRAC_NSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr_FCLK_FRAC_NSf_SET
#define READ_PMD_X1_FCLK_PERIODr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X1_FCLK_PERIODr
#define WRITE_PMD_X1_FCLK_PERIODr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X1_FCLK_PERIODr
#define MODIFY_PMD_X1_FCLK_PERIODr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X1_FCLK_PERIODr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X1_FCLK_PERIODr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_CTL1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9030
 * DESC:     Packet Gen Control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_TEST_PORT_SEL Port for which Packet generator or PRTP generator should be enabledPacket generator and PRTP generator are shared across all port, so only one port can have either of them enabledThis register is not used
 *     PRTP_DATA_PATTERN_SEL 0: Local Fault Pattern, 1: Zeros Data PatternPer lane control
 *     RX_PORT_SEL      Port for which Packet checker or PRTP checker should be enabledPacket checker and PRTP checker are shared across all port, so only one port can have either of them enabled
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r (0x00109030 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_s {
	uint32_t v[1];
	uint32_t pktgen_ctl1[1];
	uint32_t _pktgen_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_CLR(r) (r).pktgen_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_SET(r,d) (r).pktgen_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_GET(r) (r).pktgen_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_GET(r) ((((r).pktgen_ctl1[0]) >> 7) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET(r) ((((r).pktgen_ctl1[0]) >> 3) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_GET(r) (((r).pktgen_ctl1[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PKTGEN_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_CTL1r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r
#define PKTGEN_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_t PKTGEN_CTL1r_t;
#define PKTGEN_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_CLR
#define PKTGEN_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_SET
#define PKTGEN_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_GET
#define PKTGEN_CTL1r_RX_PORT_SELf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_GET
#define PKTGEN_CTL1r_RX_PORT_SELf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_RX_PORT_SELf_SET
#define PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET
#define PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET
#define PKTGEN_CTL1r_TX_TEST_PORT_SELf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_GET
#define PKTGEN_CTL1r_TX_TEST_PORT_SELf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r_TX_TEST_PORT_SELf_SET
#define READ_PKTGEN_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_CTL1r
#define WRITE_PKTGEN_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_CTL1r
#define MODIFY_PKTGEN_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PRTPCTL
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9033
 * DESC:     PRTP CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PRTP_EN       Enable Pseudo Random Test Pattern(PRTP) checker
 *     TX_PRTP_EN       Enable Pseudo Random Test Pattern(PRTP) Generator
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr (0x00109033 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PRTPCTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_s {
	uint32_t v[1];
	uint32_t pktgen_prtpctl[1];
	uint32_t _pktgen_prtpctl;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_CLR(r) (r).pktgen_prtpctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_SET(r,d) (r).pktgen_prtpctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_GET(r) (r).pktgen_prtpctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_GET(r) ((((r).pktgen_prtpctl[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_SET(r,f) (r).pktgen_prtpctl[0]=(((r).pktgen_prtpctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET(r) ((((r).pktgen_prtpctl[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET(r,f) (r).pktgen_prtpctl[0]=(((r).pktgen_prtpctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))

/*
 * These macros can be used to access PKTGEN_PRTPCTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PRTPCTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PRTPCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PRTPCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PRTPCTLr BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr
#define PKTGEN_PRTPCTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_t PKTGEN_PRTPCTLr_t;
#define PKTGEN_PRTPCTLr_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_CLR
#define PKTGEN_PRTPCTLr_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_SET
#define PKTGEN_PRTPCTLr_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_GET
#define PKTGEN_PRTPCTLr_TX_PRTP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_GET
#define PKTGEN_PRTPCTLr_TX_PRTP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_SET
#define PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET
#define PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET
#define READ_PKTGEN_PRTPCTLr BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PRTPCTLr
#define WRITE_PKTGEN_PRTPCTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PRTPCTLr
#define MODIFY_PKTGEN_PRTPCTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PRTPCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PRTPCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9037
 * DESC:     10GBASE-R PCS 0022 test pattern seed A word bits 15:00
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA0           10GBASE-R PCS test pattern seed A bits 0-15, seedA0[15:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r (0x00109037 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda0[1];
	uint32_t _pktgen_pcs_seeda0;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_CLR(r) (r).pktgen_pcs_seeda0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SET(r,d) (r).pktgen_pcs_seeda0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_GET(r) (r).pktgen_pcs_seeda0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_GET(r) (((r).pktgen_pcs_seeda0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_SET(r,f) (r).pktgen_pcs_seeda0[0]=(((r).pktgen_pcs_seeda0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA0r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r
#define PKTGEN_PCS_SEEDA0r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_t PKTGEN_PCS_SEEDA0r_t;
#define PKTGEN_PCS_SEEDA0r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_CLR
#define PKTGEN_PCS_SEEDA0r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SET
#define PKTGEN_PCS_SEEDA0r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_GET
#define PKTGEN_PCS_SEEDA0r_SEEDA0f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_GET
#define PKTGEN_PCS_SEEDA0r_SEEDA0f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_SET
#define READ_PKTGEN_PCS_SEEDA0r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA0r
#define WRITE_PKTGEN_PCS_SEEDA0r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA0r
#define MODIFY_PKTGEN_PCS_SEEDA0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9038
 * DESC:     10GBASE-R PCS 0023 test pattern seed A word bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA1           10GBASE-R PCS test pattern seed A bits 16-31, seedA1[15:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r (0x00109038 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda1[1];
	uint32_t _pktgen_pcs_seeda1;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_CLR(r) (r).pktgen_pcs_seeda1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SET(r,d) (r).pktgen_pcs_seeda1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_GET(r) (r).pktgen_pcs_seeda1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_GET(r) (((r).pktgen_pcs_seeda1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_SET(r,f) (r).pktgen_pcs_seeda1[0]=(((r).pktgen_pcs_seeda1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA1r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r
#define PKTGEN_PCS_SEEDA1r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_t PKTGEN_PCS_SEEDA1r_t;
#define PKTGEN_PCS_SEEDA1r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_CLR
#define PKTGEN_PCS_SEEDA1r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SET
#define PKTGEN_PCS_SEEDA1r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_GET
#define PKTGEN_PCS_SEEDA1r_SEEDA1f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_GET
#define PKTGEN_PCS_SEEDA1r_SEEDA1f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_SET
#define READ_PKTGEN_PCS_SEEDA1r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA1r
#define WRITE_PKTGEN_PCS_SEEDA1r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA1r
#define MODIFY_PKTGEN_PCS_SEEDA1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9039
 * DESC:     10GBASE-R PCS 0024 test pattern seed A word bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA2           10GBASE-R PCS test pattern seed A bits 32-47, seedA2[15:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r (0x00109039 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda2[1];
	uint32_t _pktgen_pcs_seeda2;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_CLR(r) (r).pktgen_pcs_seeda2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SET(r,d) (r).pktgen_pcs_seeda2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_GET(r) (r).pktgen_pcs_seeda2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_GET(r) (((r).pktgen_pcs_seeda2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_SET(r,f) (r).pktgen_pcs_seeda2[0]=(((r).pktgen_pcs_seeda2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA2r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r
#define PKTGEN_PCS_SEEDA2r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_t PKTGEN_PCS_SEEDA2r_t;
#define PKTGEN_PCS_SEEDA2r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_CLR
#define PKTGEN_PCS_SEEDA2r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SET
#define PKTGEN_PCS_SEEDA2r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_GET
#define PKTGEN_PCS_SEEDA2r_SEEDA2f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_GET
#define PKTGEN_PCS_SEEDA2r_SEEDA2f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_SET
#define READ_PKTGEN_PCS_SEEDA2r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA2r
#define WRITE_PKTGEN_PCS_SEEDA2r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA2r
#define MODIFY_PKTGEN_PCS_SEEDA2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903a
 * DESC:     10GBASE-R PCS 0025 test pattern seed A word bits 57:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA3           10GBASE-R PCS test pattern seed A bits 48-57, seedA3[9:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r (0x0010903a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda3[1];
	uint32_t _pktgen_pcs_seeda3;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_CLR(r) (r).pktgen_pcs_seeda3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SET(r,d) (r).pktgen_pcs_seeda3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_GET(r) (r).pktgen_pcs_seeda3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_GET(r) (((r).pktgen_pcs_seeda3[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_SET(r,f) (r).pktgen_pcs_seeda3[0]=(((r).pktgen_pcs_seeda3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA3r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r
#define PKTGEN_PCS_SEEDA3r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_t PKTGEN_PCS_SEEDA3r_t;
#define PKTGEN_PCS_SEEDA3r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_CLR
#define PKTGEN_PCS_SEEDA3r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SET
#define PKTGEN_PCS_SEEDA3r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_GET
#define PKTGEN_PCS_SEEDA3r_SEEDA3f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_GET
#define PKTGEN_PCS_SEEDA3r_SEEDA3f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_SET
#define READ_PKTGEN_PCS_SEEDA3r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDA3r
#define WRITE_PKTGEN_PCS_SEEDA3r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDA3r
#define MODIFY_PKTGEN_PCS_SEEDA3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDA3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDA3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903b
 * DESC:     10GBASE-R PCS 0026 test pattern seed B word bits 15:00
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB0           10GBASE-R PCS test pattern seed B bits 0-15, seedB0[15:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r (0x0010903b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb0[1];
	uint32_t _pktgen_pcs_seedb0;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_CLR(r) (r).pktgen_pcs_seedb0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SET(r,d) (r).pktgen_pcs_seedb0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_GET(r) (r).pktgen_pcs_seedb0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_GET(r) (((r).pktgen_pcs_seedb0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_SET(r,f) (r).pktgen_pcs_seedb0[0]=(((r).pktgen_pcs_seedb0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB0r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r
#define PKTGEN_PCS_SEEDB0r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_t PKTGEN_PCS_SEEDB0r_t;
#define PKTGEN_PCS_SEEDB0r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_CLR
#define PKTGEN_PCS_SEEDB0r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SET
#define PKTGEN_PCS_SEEDB0r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_GET
#define PKTGEN_PCS_SEEDB0r_SEEDB0f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_GET
#define PKTGEN_PCS_SEEDB0r_SEEDB0f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_SET
#define READ_PKTGEN_PCS_SEEDB0r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB0r
#define WRITE_PKTGEN_PCS_SEEDB0r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB0r
#define MODIFY_PKTGEN_PCS_SEEDB0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903c
 * DESC:     10GBASE-R PCS 0027 test pattern seed B word bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB1           10GBASE-R PCS test pattern seed B bits 16-31, seedB1[15:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r (0x0010903c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb1[1];
	uint32_t _pktgen_pcs_seedb1;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_CLR(r) (r).pktgen_pcs_seedb1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SET(r,d) (r).pktgen_pcs_seedb1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_GET(r) (r).pktgen_pcs_seedb1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_GET(r) (((r).pktgen_pcs_seedb1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_SET(r,f) (r).pktgen_pcs_seedb1[0]=(((r).pktgen_pcs_seedb1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB1r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r
#define PKTGEN_PCS_SEEDB1r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_t PKTGEN_PCS_SEEDB1r_t;
#define PKTGEN_PCS_SEEDB1r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_CLR
#define PKTGEN_PCS_SEEDB1r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SET
#define PKTGEN_PCS_SEEDB1r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_GET
#define PKTGEN_PCS_SEEDB1r_SEEDB1f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_GET
#define PKTGEN_PCS_SEEDB1r_SEEDB1f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_SET
#define READ_PKTGEN_PCS_SEEDB1r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB1r
#define WRITE_PKTGEN_PCS_SEEDB1r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB1r
#define MODIFY_PKTGEN_PCS_SEEDB1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903d
 * DESC:     10GBASE-R PCS 0028 test pattern seed B word bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB2           10GBASE-R PCS test pattern seed B bits 32-47, seedB2[15:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r (0x0010903d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb2[1];
	uint32_t _pktgen_pcs_seedb2;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_CLR(r) (r).pktgen_pcs_seedb2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SET(r,d) (r).pktgen_pcs_seedb2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_GET(r) (r).pktgen_pcs_seedb2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_GET(r) (((r).pktgen_pcs_seedb2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_SET(r,f) (r).pktgen_pcs_seedb2[0]=(((r).pktgen_pcs_seedb2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB2r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r
#define PKTGEN_PCS_SEEDB2r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_t PKTGEN_PCS_SEEDB2r_t;
#define PKTGEN_PCS_SEEDB2r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_CLR
#define PKTGEN_PCS_SEEDB2r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SET
#define PKTGEN_PCS_SEEDB2r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_GET
#define PKTGEN_PCS_SEEDB2r_SEEDB2f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_GET
#define PKTGEN_PCS_SEEDB2r_SEEDB2f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_SET
#define READ_PKTGEN_PCS_SEEDB2r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB2r
#define WRITE_PKTGEN_PCS_SEEDB2r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB2r
#define MODIFY_PKTGEN_PCS_SEEDB2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903e
 * DESC:     10GBASE-R PCS 0029 test pattern seed B word bits 57:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB3           10GBASE-R PCS test pattern seed B bits 48-57, seedB3[9:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r (0x0010903e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb3[1];
	uint32_t _pktgen_pcs_seedb3;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_CLR(r) (r).pktgen_pcs_seedb3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SET(r,d) (r).pktgen_pcs_seedb3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_GET(r) (r).pktgen_pcs_seedb3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_GET(r) (((r).pktgen_pcs_seedb3[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_SET(r,f) (r).pktgen_pcs_seedb3[0]=(((r).pktgen_pcs_seedb3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB3r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r
#define PKTGEN_PCS_SEEDB3r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_t PKTGEN_PCS_SEEDB3r_t;
#define PKTGEN_PCS_SEEDB3r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_CLR
#define PKTGEN_PCS_SEEDB3r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SET
#define PKTGEN_PCS_SEEDB3r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_GET
#define PKTGEN_PCS_SEEDB3r_SEEDB3f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_GET
#define PKTGEN_PCS_SEEDB3r_SEEDB3f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_SET
#define READ_PKTGEN_PCS_SEEDB3r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_PCS_SEEDB3r
#define WRITE_PKTGEN_PCS_SEEDB3r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_PCS_SEEDB3r
#define MODIFY_PKTGEN_PCS_SEEDB3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_PCS_SEEDB3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_PCS_SEEDB3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_ERRMASK4
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9040
 * DESC:     Error mask bits 79:64
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_79_64 Error Mask used to generate errors
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r (0x00109040 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask4[1];
	uint32_t _pktgen_errmask4;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_CLR(r) (r).pktgen_errmask4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_SET(r,d) (r).pktgen_errmask4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_GET(r) (r).pktgen_errmask4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_GET(r) (((r).pktgen_errmask4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_SET(r,f) (r).pktgen_errmask4[0]=(((r).pktgen_errmask4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK4r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r
#define PKTGEN_ERRMASK4r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_t PKTGEN_ERRMASK4r_t;
#define PKTGEN_ERRMASK4r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_CLR
#define PKTGEN_ERRMASK4r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_SET
#define PKTGEN_ERRMASK4r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_GET
#define PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_GET
#define PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_79_64f_SET
#define READ_PKTGEN_ERRMASK4r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK4r
#define WRITE_PKTGEN_ERRMASK4r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK4r
#define MODIFY_PKTGEN_ERRMASK4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_ERRMASK3
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9041
 * DESC:     Error mask bits 63:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_63_48 Error Mask used to generate errors
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r (0x00109041 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask3[1];
	uint32_t _pktgen_errmask3;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_CLR(r) (r).pktgen_errmask3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_SET(r,d) (r).pktgen_errmask3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_GET(r) (r).pktgen_errmask3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET(r) (((r).pktgen_errmask3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET(r,f) (r).pktgen_errmask3[0]=(((r).pktgen_errmask3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK3r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r
#define PKTGEN_ERRMASK3r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_t PKTGEN_ERRMASK3r_t;
#define PKTGEN_ERRMASK3r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_CLR
#define PKTGEN_ERRMASK3r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_SET
#define PKTGEN_ERRMASK3r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_GET
#define PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET
#define PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET
#define READ_PKTGEN_ERRMASK3r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK3r
#define WRITE_PKTGEN_ERRMASK3r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK3r
#define MODIFY_PKTGEN_ERRMASK3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_ERRMASK2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9042
 * DESC:     Error mask bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_47_32 Error Mask used to generate errors
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r (0x00109042 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask2[1];
	uint32_t _pktgen_errmask2;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_CLR(r) (r).pktgen_errmask2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_SET(r,d) (r).pktgen_errmask2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_GET(r) (r).pktgen_errmask2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET(r) (((r).pktgen_errmask2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET(r,f) (r).pktgen_errmask2[0]=(((r).pktgen_errmask2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK2r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r
#define PKTGEN_ERRMASK2r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_t PKTGEN_ERRMASK2r_t;
#define PKTGEN_ERRMASK2r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_CLR
#define PKTGEN_ERRMASK2r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_SET
#define PKTGEN_ERRMASK2r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_GET
#define PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET
#define PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET
#define READ_PKTGEN_ERRMASK2r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK2r
#define WRITE_PKTGEN_ERRMASK2r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK2r
#define MODIFY_PKTGEN_ERRMASK2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_ERRMASK1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9043
 * DESC:     Error mask bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_31_16 Error Mask used to generate errors
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r (0x00109043 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask1[1];
	uint32_t _pktgen_errmask1;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_CLR(r) (r).pktgen_errmask1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_SET(r,d) (r).pktgen_errmask1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_GET(r) (r).pktgen_errmask1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET(r) (((r).pktgen_errmask1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET(r,f) (r).pktgen_errmask1[0]=(((r).pktgen_errmask1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK1r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r
#define PKTGEN_ERRMASK1r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_t PKTGEN_ERRMASK1r_t;
#define PKTGEN_ERRMASK1r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_CLR
#define PKTGEN_ERRMASK1r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_SET
#define PKTGEN_ERRMASK1r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_GET
#define PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET
#define PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET
#define READ_PKTGEN_ERRMASK1r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK1r
#define WRITE_PKTGEN_ERRMASK1r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK1r
#define MODIFY_PKTGEN_ERRMASK1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_ERRMASK0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9044
 * DESC:     Error mask bits 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_15_0  Error Mask used to generate errors
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r (0x00109044 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask0[1];
	uint32_t _pktgen_errmask0;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_CLR(r) (r).pktgen_errmask0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_SET(r,d) (r).pktgen_errmask0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_GET(r) (r).pktgen_errmask0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET(r) (((r).pktgen_errmask0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET(r,f) (r).pktgen_errmask0[0]=(((r).pktgen_errmask0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK0r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r
#define PKTGEN_ERRMASK0r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_t PKTGEN_ERRMASK0r_t;
#define PKTGEN_ERRMASK0r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_CLR
#define PKTGEN_ERRMASK0r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_SET
#define PKTGEN_ERRMASK0r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_GET
#define PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET
#define PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET
#define READ_PKTGEN_ERRMASK0r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_ERRMASK0r
#define WRITE_PKTGEN_ERRMASK0r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_ERRMASK0r
#define MODIFY_PKTGEN_ERRMASK0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_ERRMASK0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_ERRMASK0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_CTL
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9045
 * DESC:     GLAS Test Control
 * RESETVAL: 0x7c (124)
 * ACCESS:   R/W
 * FIELDS:
 *     GLASTEST_EN      1=Enable Test Mode for all GLAS instances. 0=Enable Functional Mode for all GLAS instances.When this bit is set to 1, 1588 timestamping function is not supported.
 *     GLASTEST_ONESHOT When SW writes a 1 to this bit, HW will issue OneShot test for all GLAS instances.Self-clearing after 32 tsc_clk periods.This should be enabled only when normal traffic is not ON".
 *     GLASTEST_ID      GLAS instance selector for Expected and Actual. 0..7=RX_TS. 8=TX_TS. 9..16=TX_PMAIf GlasTest_ID values of 17-31 are selected the GlasTest_exp andGlasTest_ActData register reads will always provide zeroesS/W is expected to write a value of 31, whenever the GlasTest mode operation is complete.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr (0x00109045 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_ctl[1];
	uint32_t _pktgen_glastest_ctl;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_CLR(r) (r).pktgen_glastest_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_SET(r,d) (r).pktgen_glastest_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GET(r) (r).pktgen_glastest_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_GET(r) ((((r).pktgen_glastest_ctl[0]) >> 2) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_SET(r,f) (r).pktgen_glastest_ctl[0]=(((r).pktgen_glastest_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2)) | (31 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_GET(r) ((((r).pktgen_glastest_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_SET(r,f) (r).pktgen_glastest_ctl[0]=(((r).pktgen_glastest_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_GET(r) (((r).pktgen_glastest_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_SET(r,f) (r).pktgen_glastest_ctl[0]=(((r).pktgen_glastest_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr,(_r._pktgen_glastest_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr,(_r._pktgen_glastest_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr,(_r._pktgen_glastest_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_CTLr BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr
#define PKTGEN_GLASTEST_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_t PKTGEN_GLASTEST_CTLr_t;
#define PKTGEN_GLASTEST_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_CLR
#define PKTGEN_GLASTEST_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_SET
#define PKTGEN_GLASTEST_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_SET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_SET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_SET
#define READ_PKTGEN_GLASTEST_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_CTLr
#define WRITE_PKTGEN_GLASTEST_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_CTLr
#define MODIFY_PKTGEN_GLASTEST_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_EXP0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9046
 * DESC:     GLAS Test Expected Data 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_EXP_15_0 Expected Data output of GLAS. Bits 15:0For 8x RX TS GLAS instances, all bits are validFor 8x TX PMA GLAS instances, only bits 11:0 are validFor 1x TX TS GLAS instances, all bits are valid
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r (0x00109046 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_EXP0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_exp0[1];
	uint32_t _pktgen_glastest_exp0;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_CLR(r) (r).pktgen_glastest_exp0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_SET(r,d) (r).pktgen_glastest_exp0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_GET(r) (r).pktgen_glastest_exp0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_GET(r) (((r).pktgen_glastest_exp0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_SET(r,f) (r).pktgen_glastest_exp0[0]=(((r).pktgen_glastest_exp0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_EXP0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_EXP0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r,(_r._pktgen_glastest_exp0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_EXP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r,(_r._pktgen_glastest_exp0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_EXP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r,(_r._pktgen_glastest_exp0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_EXP0r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r
#define PKTGEN_GLASTEST_EXP0r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_t PKTGEN_GLASTEST_EXP0r_t;
#define PKTGEN_GLASTEST_EXP0r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_CLR
#define PKTGEN_GLASTEST_EXP0r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_SET
#define PKTGEN_GLASTEST_EXP0r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_GET
#define PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_GET
#define PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_SET
#define READ_PKTGEN_GLASTEST_EXP0r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_EXP0r
#define WRITE_PKTGEN_GLASTEST_EXP0r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_EXP0r
#define MODIFY_PKTGEN_GLASTEST_EXP0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_EXP0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_EXP1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9047
 * DESC:     GLAS Test Expected Data 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_EXP_31_16 Expected Data output of GLAS. Bits 31:16Used only for 1x TX TS GLAS instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r (0x00109047 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_EXP1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_exp1[1];
	uint32_t _pktgen_glastest_exp1;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_CLR(r) (r).pktgen_glastest_exp1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_SET(r,d) (r).pktgen_glastest_exp1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_GET(r) (r).pktgen_glastest_exp1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_GET(r) (((r).pktgen_glastest_exp1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_SET(r,f) (r).pktgen_glastest_exp1[0]=(((r).pktgen_glastest_exp1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_EXP1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_EXP1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r,(_r._pktgen_glastest_exp1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_EXP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r,(_r._pktgen_glastest_exp1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_EXP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r,(_r._pktgen_glastest_exp1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_EXP1r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r
#define PKTGEN_GLASTEST_EXP1r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_t PKTGEN_GLASTEST_EXP1r_t;
#define PKTGEN_GLASTEST_EXP1r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_CLR
#define PKTGEN_GLASTEST_EXP1r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_SET
#define PKTGEN_GLASTEST_EXP1r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_GET
#define PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_GET
#define PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_SET
#define READ_PKTGEN_GLASTEST_EXP1r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_EXP1r
#define WRITE_PKTGEN_GLASTEST_EXP1r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_EXP1r
#define MODIFY_PKTGEN_GLASTEST_EXP1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_EXP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_EXP2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9048
 * DESC:     GLAS Test Expected Data 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_EXP_47_32 Expected Data output of GLAS. Bits 47:32Used only for 1x TX TS GLAS instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r (0x00109048 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_EXP2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_exp2[1];
	uint32_t _pktgen_glastest_exp2;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_CLR(r) (r).pktgen_glastest_exp2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_SET(r,d) (r).pktgen_glastest_exp2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_GET(r) (r).pktgen_glastest_exp2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_GET(r) (((r).pktgen_glastest_exp2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_SET(r,f) (r).pktgen_glastest_exp2[0]=(((r).pktgen_glastest_exp2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_EXP2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_EXP2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r,(_r._pktgen_glastest_exp2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_EXP2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r,(_r._pktgen_glastest_exp2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_EXP2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r,(_r._pktgen_glastest_exp2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_EXP2r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r
#define PKTGEN_GLASTEST_EXP2r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_t PKTGEN_GLASTEST_EXP2r_t;
#define PKTGEN_GLASTEST_EXP2r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_CLR
#define PKTGEN_GLASTEST_EXP2r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_SET
#define PKTGEN_GLASTEST_EXP2r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_GET
#define PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_GET
#define PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_SET
#define READ_PKTGEN_GLASTEST_EXP2r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_EXP2r
#define WRITE_PKTGEN_GLASTEST_EXP2r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_EXP2r
#define MODIFY_PKTGEN_GLASTEST_EXP2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_EXP2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_EXP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTDATA0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9049
 * DESC:     GLAS Test Status Actual Data output 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_DAT_15_0 Actual Data output of GLAS. Bits 15:0For 8x RX TS  GLAS instances, all bits are validFor 8x TX PMA GLAS instances, only bits 11:0 are validFor 1x TX TS  GLAS instances, all bits are valid.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r (0x00109049 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTDATA0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actdata0[1];
	uint32_t _pktgen_glastest_actdata0;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_CLR(r) (r).pktgen_glastest_actdata0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SET(r,d) (r).pktgen_glastest_actdata0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GET(r) (r).pktgen_glastest_actdata0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_GET(r) (((r).pktgen_glastest_actdata0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_SET(r,f) (r).pktgen_glastest_actdata0[0]=(((r).pktgen_glastest_actdata0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTDATA0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTDATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r,(_r._pktgen_glastest_actdata0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r,(_r._pktgen_glastest_actdata0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r,(_r._pktgen_glastest_actdata0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r
#define PKTGEN_GLASTEST_ACTDATA0r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_t PKTGEN_GLASTEST_ACTDATA0r_t;
#define PKTGEN_GLASTEST_ACTDATA0r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_CLR
#define PKTGEN_GLASTEST_ACTDATA0r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SET
#define PKTGEN_GLASTEST_ACTDATA0r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GET
#define PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_GET
#define PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_SET
#define READ_PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTDATA0r
#define WRITE_PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA0r
#define MODIFY_PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTDATA1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904a
 * DESC:     GLAS Test Status Actual Data output 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_DAT_31_16 Actual Data output of GLAS. Bits 31:16Used only for 1x TX TS GLAS instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r (0x0010904a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTDATA1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actdata1[1];
	uint32_t _pktgen_glastest_actdata1;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_CLR(r) (r).pktgen_glastest_actdata1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SET(r,d) (r).pktgen_glastest_actdata1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GET(r) (r).pktgen_glastest_actdata1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_GET(r) (((r).pktgen_glastest_actdata1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_SET(r,f) (r).pktgen_glastest_actdata1[0]=(((r).pktgen_glastest_actdata1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTDATA1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTDATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r,(_r._pktgen_glastest_actdata1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r,(_r._pktgen_glastest_actdata1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r,(_r._pktgen_glastest_actdata1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r
#define PKTGEN_GLASTEST_ACTDATA1r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_t PKTGEN_GLASTEST_ACTDATA1r_t;
#define PKTGEN_GLASTEST_ACTDATA1r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_CLR
#define PKTGEN_GLASTEST_ACTDATA1r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SET
#define PKTGEN_GLASTEST_ACTDATA1r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GET
#define PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_GET
#define PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_SET
#define READ_PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTDATA1r
#define WRITE_PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA1r
#define MODIFY_PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTDATA2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904b
 * DESC:     GLAS Test Status Actual Data output 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_DAT_47_32 Actual Data output of GLAS. Bits 47:32Used only for 1x TX TS GLAS instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r (0x0010904b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTDATA2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actdata2[1];
	uint32_t _pktgen_glastest_actdata2;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_CLR(r) (r).pktgen_glastest_actdata2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SET(r,d) (r).pktgen_glastest_actdata2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GET(r) (r).pktgen_glastest_actdata2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_GET(r) (((r).pktgen_glastest_actdata2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_SET(r,f) (r).pktgen_glastest_actdata2[0]=(((r).pktgen_glastest_actdata2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTDATA2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTDATA2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r,(_r._pktgen_glastest_actdata2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r,(_r._pktgen_glastest_actdata2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r,(_r._pktgen_glastest_actdata2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r
#define PKTGEN_GLASTEST_ACTDATA2r_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_t PKTGEN_GLASTEST_ACTDATA2r_t;
#define PKTGEN_GLASTEST_ACTDATA2r_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_CLR
#define PKTGEN_GLASTEST_ACTDATA2r_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SET
#define PKTGEN_GLASTEST_ACTDATA2r_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GET
#define PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_GET
#define PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_SET
#define READ_PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTDATA2r
#define WRITE_PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA2r
#define MODIFY_PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTDATA2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTADJ
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904c
 * DESC:     GLAS Test Status Actual Adjust output AND upper 4 bits of Expected and Actual 52bit TS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_ADJ     Actual Adjust output of GLASFor 8x RX TS  GLAS instances, only bits 5:0 are validFor 8x TX PMA GLAS instances, only bits 6:0 are validFor 1x TX TS  GLAS instances, only bits 5:0 are valid.
 *     GLASTEST_EXP_51_48 Expected Data output of GLAS. Bits 51:48Used only for 1x TX TS GLAS instance.
 *     GLASTEST_DAT_51_48 Actual Data output of GLAS. Bits 51:48Used only for 1x TX TS GLAS instance.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr (0x0010904c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTADJ.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actadj[1];
	uint32_t _pktgen_glastest_actadj;
} BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_CLR(r) (r).pktgen_glastest_actadj[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_SET(r,d) (r).pktgen_glastest_actadj[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GET(r) (r).pktgen_glastest_actadj[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_GET(r) ((((r).pktgen_glastest_actadj[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_SET(r,f) (r).pktgen_glastest_actadj[0]=(((r).pktgen_glastest_actadj[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_GET(r) ((((r).pktgen_glastest_actadj[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_SET(r,f) (r).pktgen_glastest_actadj[0]=(((r).pktgen_glastest_actadj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_GET(r) (((r).pktgen_glastest_actadj[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_SET(r,f) (r).pktgen_glastest_actadj[0]=(((r).pktgen_glastest_actadj[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTADJ.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTADJr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr,(_r._pktgen_glastest_actadj))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTADJr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr,(_r._pktgen_glastest_actadj)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTADJr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr,(_r._pktgen_glastest_actadj))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTADJr BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr
#define PKTGEN_GLASTEST_ACTADJr_SIZE BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_t PKTGEN_GLASTEST_ACTADJr_t;
#define PKTGEN_GLASTEST_ACTADJr_CLR BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_CLR
#define PKTGEN_GLASTEST_ACTADJr_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_SET
#define PKTGEN_GLASTEST_ACTADJr_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_SET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_SET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_GET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_SET BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_SET
#define READ_PKTGEN_GLASTEST_ACTADJr BCMI_TSCBH_FLEXE_XGXS_READ_PKTGEN_GLASTEST_ACTADJr
#define WRITE_PKTGEN_GLASTEST_ACTADJr BCMI_TSCBH_FLEXE_XGXS_WRITE_PKTGEN_GLASTEST_ACTADJr
#define MODIFY_PKTGEN_GLASTEST_ACTADJr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PKTGEN_GLASTEST_ACTADJr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PKTGEN_GLASTEST_ACTADJr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_TX_LN_SWP
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9200
 * DESC:     TX lane swap register
 * RESETVAL: 0x688 (1672)
 * ACCESS:   R/W
 * FIELDS:
 *     LOGICAL_TO_PHYSICAL0_SEL This is a LOGICAL to PHYSICAL mapping.  It defines the LOGICAL LANE that forwards data to PHYSICAL LANE0, for this MPP.
 *     LOGICAL_TO_PHYSICAL1_SEL This is a LOGICAL to PHYSICAL mapping.  It defines the LOGICAL LANE that forwards data to PHYSICAL LANE1, for this MPP.
 *     LOGICAL_TO_PHYSICAL2_SEL This is a LOGICAL to PHYSICAL mapping.  It defines the LOGICAL LANE that forwards data to PHYSICAL LANE2, for this MPP.
 *     LOGICAL_TO_PHYSICAL3_SEL This is a LOGICAL to PHYSICAL mapping.  It defines the LOGICAL LANE that forwards data to PHYSICAL LANE3, for this MPP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr (0x00109200 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TX_LN_SWP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_s {
	uint32_t v[1];
	uint32_t tx_x1_tx_ln_swp[1];
	uint32_t _tx_x1_tx_ln_swp;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_CLR(r) (r).tx_x1_tx_ln_swp[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_SET(r,d) (r).tx_x1_tx_ln_swp[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_GET(r) (r).tx_x1_tx_ln_swp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL3_SELf_GET(r) ((((r).tx_x1_tx_ln_swp[0]) >> 9) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL3_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL2_SELf_GET(r) ((((r).tx_x1_tx_ln_swp[0]) >> 6) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL2_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL1_SELf_GET(r) ((((r).tx_x1_tx_ln_swp[0]) >> 3) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL1_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL0_SELf_GET(r) (((r).tx_x1_tx_ln_swp[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL0_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TX_X1_TX_LN_SWP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_TX_LN_SWPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr,(_r._tx_x1_tx_ln_swp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_TX_LN_SWPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr,(_r._tx_x1_tx_ln_swp)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_TX_LN_SWPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr,(_r._tx_x1_tx_ln_swp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr
#define TX_X1_TX_LN_SWPr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_t TX_X1_TX_LN_SWPr_t;
#define TX_X1_TX_LN_SWPr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_CLR
#define TX_X1_TX_LN_SWPr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_SET
#define TX_X1_TX_LN_SWPr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_GET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL3_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL3_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL3_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL3_SELf_SET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL2_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL2_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL2_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL2_SELf_SET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL1_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL1_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL1_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL1_SELf_SET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL0_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL0_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL0_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr_LOGICAL_TO_PHYSICAL0_SELf_SET
#define READ_TX_X1_TX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_TX_LN_SWPr
#define WRITE_TX_X1_TX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_TX_LN_SWPr
#define MODIFY_TX_X1_TX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_TX_LN_SWPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_TX_LN_SWPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_CTL
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9201
 * DESC:     T_PMA GLAS control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_EN Enable capturing data,adj values from tpma glas instances as defined by the maskRising edge required to trigger capture. SW must write 1 to trigger capture, then write 0 to end capture.
 *     GLAS_TPMA_CAPTURE_MASK 1bit enable per tpma glas.
 *     GLAS_TPMA_CAPTURE_LOGICAL If this bit is set to 1, the glas tpma capture will store logical lane values in indices 0 to 7If this bit is set to 0, the glas tpma capture will store physical lane values in indices 0 to 7
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr (0x00109201 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_ctl[1];
	uint32_t _tx_x1_glas_tpma_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_CLR(r) (r).tx_x1_glas_tpma_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_SET(r,d) (r).tx_x1_glas_tpma_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GET(r) (r).tx_x1_glas_tpma_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_LOGICALf_GET(r) ((((r).tx_x1_glas_tpma_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_LOGICALf_SET(r,f) (r).tx_x1_glas_tpma_ctl[0]=(((r).tx_x1_glas_tpma_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_GET(r) ((((r).tx_x1_glas_tpma_ctl[0]) >> 1) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_SET(r,f) (r).tx_x1_glas_tpma_ctl[0]=(((r).tx_x1_glas_tpma_ctl[0] & ~((uint32_t)0xff << 1)) | ((((uint32_t)f) & 0xff) << 1)) | (255 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_GET(r) (((r).tx_x1_glas_tpma_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_SET(r,f) (r).tx_x1_glas_tpma_ctl[0]=(((r).tx_x1_glas_tpma_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr,(_r._tx_x1_glas_tpma_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr,(_r._tx_x1_glas_tpma_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr,(_r._tx_x1_glas_tpma_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr
#define TX_X1_GLAS_TPMA_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_t TX_X1_GLAS_TPMA_CTLr_t;
#define TX_X1_GLAS_TPMA_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_CLR
#define TX_X1_GLAS_TPMA_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_SET
#define TX_X1_GLAS_TPMA_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_LOGICALf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_LOGICALf_GET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_LOGICALf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_LOGICALf_SET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_GET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_SET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_GET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_SET
#define READ_TX_X1_GLAS_TPMA_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_CTLr
#define WRITE_TX_X1_GLAS_TPMA_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_CTLr
#define MODIFY_TX_X1_GLAS_TPMA_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA0
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9202
 * DESC:     T_PMA 0 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_0 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r (0x00109202 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data0[1];
	uint32_t _tx_x1_glas_tpma_data0;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_CLR(r) (r).tx_x1_glas_tpma_data0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_SET(r,d) (r).tx_x1_glas_tpma_data0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_GET(r) (r).tx_x1_glas_tpma_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_GET(r) (((r).tx_x1_glas_tpma_data0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_SET(r,f) (r).tx_x1_glas_tpma_data0[0]=(((r).tx_x1_glas_tpma_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r,(_r._tx_x1_glas_tpma_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r,(_r._tx_x1_glas_tpma_data0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r,(_r._tx_x1_glas_tpma_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA0r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r
#define TX_X1_GLAS_TPMA_DATA0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_t TX_X1_GLAS_TPMA_DATA0r_t;
#define TX_X1_GLAS_TPMA_DATA0r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_CLR
#define TX_X1_GLAS_TPMA_DATA0r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_SET
#define TX_X1_GLAS_TPMA_DATA0r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_GET
#define TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_GET
#define TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_SET
#define READ_TX_X1_GLAS_TPMA_DATA0r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA0r
#define WRITE_TX_X1_GLAS_TPMA_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA0r
#define MODIFY_TX_X1_GLAS_TPMA_DATA0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA1
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9203
 * DESC:     T_PMA 1 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_1 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r (0x00109203 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data1[1];
	uint32_t _tx_x1_glas_tpma_data1;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_CLR(r) (r).tx_x1_glas_tpma_data1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_SET(r,d) (r).tx_x1_glas_tpma_data1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_GET(r) (r).tx_x1_glas_tpma_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_GET(r) (((r).tx_x1_glas_tpma_data1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_SET(r,f) (r).tx_x1_glas_tpma_data1[0]=(((r).tx_x1_glas_tpma_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r,(_r._tx_x1_glas_tpma_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r,(_r._tx_x1_glas_tpma_data1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r,(_r._tx_x1_glas_tpma_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA1r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r
#define TX_X1_GLAS_TPMA_DATA1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_t TX_X1_GLAS_TPMA_DATA1r_t;
#define TX_X1_GLAS_TPMA_DATA1r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_CLR
#define TX_X1_GLAS_TPMA_DATA1r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_SET
#define TX_X1_GLAS_TPMA_DATA1r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_GET
#define TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_GET
#define TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_SET
#define READ_TX_X1_GLAS_TPMA_DATA1r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA1r
#define WRITE_TX_X1_GLAS_TPMA_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA1r
#define MODIFY_TX_X1_GLAS_TPMA_DATA1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA2
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9204
 * DESC:     T_PMA 2 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_2 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r (0x00109204 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data2[1];
	uint32_t _tx_x1_glas_tpma_data2;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_CLR(r) (r).tx_x1_glas_tpma_data2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_SET(r,d) (r).tx_x1_glas_tpma_data2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_GET(r) (r).tx_x1_glas_tpma_data2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_GET(r) (((r).tx_x1_glas_tpma_data2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_SET(r,f) (r).tx_x1_glas_tpma_data2[0]=(((r).tx_x1_glas_tpma_data2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r,(_r._tx_x1_glas_tpma_data2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r,(_r._tx_x1_glas_tpma_data2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r,(_r._tx_x1_glas_tpma_data2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA2r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r
#define TX_X1_GLAS_TPMA_DATA2r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_t TX_X1_GLAS_TPMA_DATA2r_t;
#define TX_X1_GLAS_TPMA_DATA2r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_CLR
#define TX_X1_GLAS_TPMA_DATA2r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_SET
#define TX_X1_GLAS_TPMA_DATA2r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_GET
#define TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_GET
#define TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_SET
#define READ_TX_X1_GLAS_TPMA_DATA2r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA2r
#define WRITE_TX_X1_GLAS_TPMA_DATA2r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA2r
#define MODIFY_TX_X1_GLAS_TPMA_DATA2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA3
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9205
 * DESC:     T_PMA 3 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_3 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r (0x00109205 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data3[1];
	uint32_t _tx_x1_glas_tpma_data3;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_CLR(r) (r).tx_x1_glas_tpma_data3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_SET(r,d) (r).tx_x1_glas_tpma_data3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_GET(r) (r).tx_x1_glas_tpma_data3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_GET(r) (((r).tx_x1_glas_tpma_data3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_SET(r,f) (r).tx_x1_glas_tpma_data3[0]=(((r).tx_x1_glas_tpma_data3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r,(_r._tx_x1_glas_tpma_data3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r,(_r._tx_x1_glas_tpma_data3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r,(_r._tx_x1_glas_tpma_data3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA3r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r
#define TX_X1_GLAS_TPMA_DATA3r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_t TX_X1_GLAS_TPMA_DATA3r_t;
#define TX_X1_GLAS_TPMA_DATA3r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_CLR
#define TX_X1_GLAS_TPMA_DATA3r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_SET
#define TX_X1_GLAS_TPMA_DATA3r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_GET
#define TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_GET
#define TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_SET
#define READ_TX_X1_GLAS_TPMA_DATA3r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA3r
#define WRITE_TX_X1_GLAS_TPMA_DATA3r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA3r
#define MODIFY_TX_X1_GLAS_TPMA_DATA3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA4
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9206
 * DESC:     T_PMA 4 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_4 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r (0x00109206 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data4[1];
	uint32_t _tx_x1_glas_tpma_data4;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_CLR(r) (r).tx_x1_glas_tpma_data4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_SET(r,d) (r).tx_x1_glas_tpma_data4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_GET(r) (r).tx_x1_glas_tpma_data4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_GLAS_TPMA_CAPTURE_DATA_4f_GET(r) (((r).tx_x1_glas_tpma_data4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_GLAS_TPMA_CAPTURE_DATA_4f_SET(r,f) (r).tx_x1_glas_tpma_data4[0]=(((r).tx_x1_glas_tpma_data4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r,(_r._tx_x1_glas_tpma_data4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r,(_r._tx_x1_glas_tpma_data4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r,(_r._tx_x1_glas_tpma_data4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA4r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r
#define TX_X1_GLAS_TPMA_DATA4r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_t TX_X1_GLAS_TPMA_DATA4r_t;
#define TX_X1_GLAS_TPMA_DATA4r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_CLR
#define TX_X1_GLAS_TPMA_DATA4r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_SET
#define TX_X1_GLAS_TPMA_DATA4r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_GET
#define TX_X1_GLAS_TPMA_DATA4r_GLAS_TPMA_CAPTURE_DATA_4f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_GLAS_TPMA_CAPTURE_DATA_4f_GET
#define TX_X1_GLAS_TPMA_DATA4r_GLAS_TPMA_CAPTURE_DATA_4f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r_GLAS_TPMA_CAPTURE_DATA_4f_SET
#define READ_TX_X1_GLAS_TPMA_DATA4r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA4r
#define WRITE_TX_X1_GLAS_TPMA_DATA4r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA4r
#define MODIFY_TX_X1_GLAS_TPMA_DATA4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA5
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9207
 * DESC:     T_PMA 5 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_5 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r (0x00109207 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data5[1];
	uint32_t _tx_x1_glas_tpma_data5;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_CLR(r) (r).tx_x1_glas_tpma_data5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_SET(r,d) (r).tx_x1_glas_tpma_data5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_GET(r) (r).tx_x1_glas_tpma_data5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_GLAS_TPMA_CAPTURE_DATA_5f_GET(r) (((r).tx_x1_glas_tpma_data5[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_GLAS_TPMA_CAPTURE_DATA_5f_SET(r,f) (r).tx_x1_glas_tpma_data5[0]=(((r).tx_x1_glas_tpma_data5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r,(_r._tx_x1_glas_tpma_data5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r,(_r._tx_x1_glas_tpma_data5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r,(_r._tx_x1_glas_tpma_data5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA5r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r
#define TX_X1_GLAS_TPMA_DATA5r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_t TX_X1_GLAS_TPMA_DATA5r_t;
#define TX_X1_GLAS_TPMA_DATA5r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_CLR
#define TX_X1_GLAS_TPMA_DATA5r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_SET
#define TX_X1_GLAS_TPMA_DATA5r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_GET
#define TX_X1_GLAS_TPMA_DATA5r_GLAS_TPMA_CAPTURE_DATA_5f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_GLAS_TPMA_CAPTURE_DATA_5f_GET
#define TX_X1_GLAS_TPMA_DATA5r_GLAS_TPMA_CAPTURE_DATA_5f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r_GLAS_TPMA_CAPTURE_DATA_5f_SET
#define READ_TX_X1_GLAS_TPMA_DATA5r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA5r
#define WRITE_TX_X1_GLAS_TPMA_DATA5r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA5r
#define MODIFY_TX_X1_GLAS_TPMA_DATA5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA6
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9208
 * DESC:     T_PMA 6 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_6 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r (0x00109208 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA6.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data6[1];
	uint32_t _tx_x1_glas_tpma_data6;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_CLR(r) (r).tx_x1_glas_tpma_data6[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_SET(r,d) (r).tx_x1_glas_tpma_data6[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_GET(r) (r).tx_x1_glas_tpma_data6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_GLAS_TPMA_CAPTURE_DATA_6f_GET(r) (((r).tx_x1_glas_tpma_data6[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_GLAS_TPMA_CAPTURE_DATA_6f_SET(r,f) (r).tx_x1_glas_tpma_data6[0]=(((r).tx_x1_glas_tpma_data6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA6.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r,(_r._tx_x1_glas_tpma_data6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r,(_r._tx_x1_glas_tpma_data6)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r,(_r._tx_x1_glas_tpma_data6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA6r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r
#define TX_X1_GLAS_TPMA_DATA6r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_t TX_X1_GLAS_TPMA_DATA6r_t;
#define TX_X1_GLAS_TPMA_DATA6r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_CLR
#define TX_X1_GLAS_TPMA_DATA6r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_SET
#define TX_X1_GLAS_TPMA_DATA6r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_GET
#define TX_X1_GLAS_TPMA_DATA6r_GLAS_TPMA_CAPTURE_DATA_6f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_GLAS_TPMA_CAPTURE_DATA_6f_GET
#define TX_X1_GLAS_TPMA_DATA6r_GLAS_TPMA_CAPTURE_DATA_6f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r_GLAS_TPMA_CAPTURE_DATA_6f_SET
#define READ_TX_X1_GLAS_TPMA_DATA6r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA6r
#define WRITE_TX_X1_GLAS_TPMA_DATA6r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA6r
#define MODIFY_TX_X1_GLAS_TPMA_DATA6r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA7
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9209
 * DESC:     T_PMA 7 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_7 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r (0x00109209 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data7[1];
	uint32_t _tx_x1_glas_tpma_data7;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_CLR(r) (r).tx_x1_glas_tpma_data7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_SET(r,d) (r).tx_x1_glas_tpma_data7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_GET(r) (r).tx_x1_glas_tpma_data7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_GLAS_TPMA_CAPTURE_DATA_7f_GET(r) (((r).tx_x1_glas_tpma_data7[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_GLAS_TPMA_CAPTURE_DATA_7f_SET(r,f) (r).tx_x1_glas_tpma_data7[0]=(((r).tx_x1_glas_tpma_data7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r,(_r._tx_x1_glas_tpma_data7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r,(_r._tx_x1_glas_tpma_data7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r,(_r._tx_x1_glas_tpma_data7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA7r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r
#define TX_X1_GLAS_TPMA_DATA7r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_t TX_X1_GLAS_TPMA_DATA7r_t;
#define TX_X1_GLAS_TPMA_DATA7r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_CLR
#define TX_X1_GLAS_TPMA_DATA7r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_SET
#define TX_X1_GLAS_TPMA_DATA7r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_GET
#define TX_X1_GLAS_TPMA_DATA7r_GLAS_TPMA_CAPTURE_DATA_7f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_GLAS_TPMA_CAPTURE_DATA_7f_GET
#define TX_X1_GLAS_TPMA_DATA7r_GLAS_TPMA_CAPTURE_DATA_7f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r_GLAS_TPMA_CAPTURE_DATA_7f_SET
#define READ_TX_X1_GLAS_TPMA_DATA7r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_DATA7r
#define WRITE_TX_X1_GLAS_TPMA_DATA7r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA7r
#define MODIFY_TX_X1_GLAS_TPMA_DATA7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_DATA7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_ADJ_0_1
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x920a
 * DESC:     T_PMA 0,1 GLAS adjust capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_ADJ_0 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 *     GLAS_TPMA_CAPTURE_ADJ_1 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r (0x0010920a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_ADJ_0_1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_adj_0_1[1];
	uint32_t _tx_x1_glas_tpma_adj_0_1;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_CLR(r) (r).tx_x1_glas_tpma_adj_0_1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SET(r,d) (r).tx_x1_glas_tpma_adj_0_1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GET(r) (r).tx_x1_glas_tpma_adj_0_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_GET(r) ((((r).tx_x1_glas_tpma_adj_0_1[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_SET(r,f) (r).tx_x1_glas_tpma_adj_0_1[0]=(((r).tx_x1_glas_tpma_adj_0_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_GET(r) (((r).tx_x1_glas_tpma_adj_0_1[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_SET(r,f) (r).tx_x1_glas_tpma_adj_0_1[0]=(((r).tx_x1_glas_tpma_adj_0_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_ADJ_0_1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_0_1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r,(_r._tx_x1_glas_tpma_adj_0_1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_0_1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r,(_r._tx_x1_glas_tpma_adj_0_1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_0_1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r,(_r._tx_x1_glas_tpma_adj_0_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r
#define TX_X1_GLAS_TPMA_ADJ_0_1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_t TX_X1_GLAS_TPMA_ADJ_0_1r_t;
#define TX_X1_GLAS_TPMA_ADJ_0_1r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_CLR
#define TX_X1_GLAS_TPMA_ADJ_0_1r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_GET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_SET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_GET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_SET
#define READ_TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_0_1r
#define WRITE_TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_0_1r
#define MODIFY_TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_ADJ_2_3
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x920b
 * DESC:     T_PMA 2,3 GLAS adjust capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_ADJ_2 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 *     GLAS_TPMA_CAPTURE_ADJ_3 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r (0x0010920b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_ADJ_2_3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_adj_2_3[1];
	uint32_t _tx_x1_glas_tpma_adj_2_3;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_CLR(r) (r).tx_x1_glas_tpma_adj_2_3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SET(r,d) (r).tx_x1_glas_tpma_adj_2_3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GET(r) (r).tx_x1_glas_tpma_adj_2_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_GET(r) ((((r).tx_x1_glas_tpma_adj_2_3[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_SET(r,f) (r).tx_x1_glas_tpma_adj_2_3[0]=(((r).tx_x1_glas_tpma_adj_2_3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_GET(r) (((r).tx_x1_glas_tpma_adj_2_3[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_SET(r,f) (r).tx_x1_glas_tpma_adj_2_3[0]=(((r).tx_x1_glas_tpma_adj_2_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_ADJ_2_3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_2_3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r,(_r._tx_x1_glas_tpma_adj_2_3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_2_3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r,(_r._tx_x1_glas_tpma_adj_2_3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_2_3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r,(_r._tx_x1_glas_tpma_adj_2_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r
#define TX_X1_GLAS_TPMA_ADJ_2_3r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_t TX_X1_GLAS_TPMA_ADJ_2_3r_t;
#define TX_X1_GLAS_TPMA_ADJ_2_3r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_CLR
#define TX_X1_GLAS_TPMA_ADJ_2_3r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_GET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_SET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_GET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_SET
#define READ_TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_2_3r
#define WRITE_TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_2_3r
#define MODIFY_TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_2_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_ADJ_4_5
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x920c
 * DESC:     T_PMA 4,5 GLAS adjust capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_ADJ_4 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 *     GLAS_TPMA_CAPTURE_ADJ_5 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r (0x0010920c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_ADJ_4_5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_adj_4_5[1];
	uint32_t _tx_x1_glas_tpma_adj_4_5;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_CLR(r) (r).tx_x1_glas_tpma_adj_4_5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_SET(r,d) (r).tx_x1_glas_tpma_adj_4_5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GET(r) (r).tx_x1_glas_tpma_adj_4_5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_5f_GET(r) ((((r).tx_x1_glas_tpma_adj_4_5[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_5f_SET(r,f) (r).tx_x1_glas_tpma_adj_4_5[0]=(((r).tx_x1_glas_tpma_adj_4_5[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_4f_GET(r) (((r).tx_x1_glas_tpma_adj_4_5[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_4f_SET(r,f) (r).tx_x1_glas_tpma_adj_4_5[0]=(((r).tx_x1_glas_tpma_adj_4_5[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_ADJ_4_5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_4_5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r,(_r._tx_x1_glas_tpma_adj_4_5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_4_5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r,(_r._tx_x1_glas_tpma_adj_4_5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_4_5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r,(_r._tx_x1_glas_tpma_adj_4_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_ADJ_4_5r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r
#define TX_X1_GLAS_TPMA_ADJ_4_5r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_t TX_X1_GLAS_TPMA_ADJ_4_5r_t;
#define TX_X1_GLAS_TPMA_ADJ_4_5r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_CLR
#define TX_X1_GLAS_TPMA_ADJ_4_5r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_SET
#define TX_X1_GLAS_TPMA_ADJ_4_5r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GET
#define TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_5f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_5f_GET
#define TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_5f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_5f_SET
#define TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_4f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_4f_GET
#define TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_4f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r_GLAS_TPMA_CAPTURE_ADJ_4f_SET
#define READ_TX_X1_GLAS_TPMA_ADJ_4_5r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_4_5r
#define WRITE_TX_X1_GLAS_TPMA_ADJ_4_5r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_4_5r
#define MODIFY_TX_X1_GLAS_TPMA_ADJ_4_5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_4_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_4_5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_ADJ_6_7
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x920d
 * DESC:     T_PMA 6,7 GLAS adjust capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_ADJ_6 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 *     GLAS_TPMA_CAPTURE_ADJ_7 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r (0x0010920d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_ADJ_6_7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_adj_6_7[1];
	uint32_t _tx_x1_glas_tpma_adj_6_7;
} BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_CLR(r) (r).tx_x1_glas_tpma_adj_6_7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_SET(r,d) (r).tx_x1_glas_tpma_adj_6_7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GET(r) (r).tx_x1_glas_tpma_adj_6_7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_7f_GET(r) ((((r).tx_x1_glas_tpma_adj_6_7[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_7f_SET(r,f) (r).tx_x1_glas_tpma_adj_6_7[0]=(((r).tx_x1_glas_tpma_adj_6_7[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_6f_GET(r) (((r).tx_x1_glas_tpma_adj_6_7[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_6f_SET(r,f) (r).tx_x1_glas_tpma_adj_6_7[0]=(((r).tx_x1_glas_tpma_adj_6_7[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_ADJ_6_7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_6_7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r,(_r._tx_x1_glas_tpma_adj_6_7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_6_7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r,(_r._tx_x1_glas_tpma_adj_6_7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_6_7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r,(_r._tx_x1_glas_tpma_adj_6_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_ADJ_6_7r BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r
#define TX_X1_GLAS_TPMA_ADJ_6_7r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_t TX_X1_GLAS_TPMA_ADJ_6_7r_t;
#define TX_X1_GLAS_TPMA_ADJ_6_7r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_CLR
#define TX_X1_GLAS_TPMA_ADJ_6_7r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_SET
#define TX_X1_GLAS_TPMA_ADJ_6_7r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GET
#define TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_7f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_7f_GET
#define TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_7f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_7f_SET
#define TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_6f_GET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_6f_GET
#define TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_6f_SET BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r_GLAS_TPMA_CAPTURE_ADJ_6f_SET
#define READ_TX_X1_GLAS_TPMA_ADJ_6_7r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_6_7r
#define WRITE_TX_X1_GLAS_TPMA_ADJ_6_7r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_6_7r
#define MODIFY_TX_X1_GLAS_TPMA_ADJ_6_7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_6_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X1_GLAS_TPMA_ADJ_6_7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_RS_FEC_CFG
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9223
 * DESC:     RS_FEC configuration register
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_CW_TYPE   1'b0 - Both RS 528 and RS 544 frames are supported.  Latency supports RS 544 frames1'b1 - Only RS 528 or RS 272 Frames are supported.  Reduces latency slightly.
 *     RS_FEC_CORRECTION_ENABLE 1'b0 - FEC performs detection only.  This is the minimum latency mode.1'b1 - FEC performs detection and correction.  This is the max latency mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr (0x00109223 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_RS_FEC_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_s {
	uint32_t v[1];
	uint32_t rx_x1_rs_fec_cfg[1];
	uint32_t _rx_x1_rs_fec_cfg;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_CLR(r) (r).rx_x1_rs_fec_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_SET(r,d) (r).rx_x1_rs_fec_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_GET(r) (r).rx_x1_rs_fec_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CORRECTION_ENABLEf_GET(r) ((((r).rx_x1_rs_fec_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CORRECTION_ENABLEf_SET(r,f) (r).rx_x1_rs_fec_cfg[0]=(((r).rx_x1_rs_fec_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CW_TYPEf_GET(r) (((r).rx_x1_rs_fec_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CW_TYPEf_SET(r,f) (r).rx_x1_rs_fec_cfg[0]=(((r).rx_x1_rs_fec_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X1_RS_FEC_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_RS_FEC_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr,(_r._rx_x1_rs_fec_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_RS_FEC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr,(_r._rx_x1_rs_fec_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_RS_FEC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr,(_r._rx_x1_rs_fec_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_RS_FEC_CFGr BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr
#define RX_X1_RS_FEC_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_t RX_X1_RS_FEC_CFGr_t;
#define RX_X1_RS_FEC_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_CLR
#define RX_X1_RS_FEC_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_SET
#define RX_X1_RS_FEC_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_GET
#define RX_X1_RS_FEC_CFGr_RS_FEC_CORRECTION_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CORRECTION_ENABLEf_GET
#define RX_X1_RS_FEC_CFGr_RS_FEC_CORRECTION_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CORRECTION_ENABLEf_SET
#define RX_X1_RS_FEC_CFGr_RS_FEC_CW_TYPEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CW_TYPEf_GET
#define RX_X1_RS_FEC_CFGr_RS_FEC_CW_TYPEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr_RS_FEC_CW_TYPEf_SET
#define READ_RX_X1_RS_FEC_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_RS_FEC_CFGr
#define WRITE_RX_X1_RS_FEC_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_RS_FEC_CFGr
#define MODIFY_RX_X1_RS_FEC_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_RS_FEC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_RS_FEC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_RX_LN_SWP
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9225
 * DESC:     RX lane swap register
 * RESETVAL: 0x688 (1672)
 * ACCESS:   R/W
 * FIELDS:
 *     PHYSICAL0_TO_LOGICAL_SEL This is a PHYSICAL to LOGICAL mapping control. It indicates LOGICAL LANE mapping for data received on PHYSICAl LANE 0, for this MPP
 *     PHYSICAL1_TO_LOGICAL_SEL This is a PHYSICAL to LOGICAL mapping control. It indicates LOGICAL LANE mapping for data received on PHYSICAl LANE 1, for this MPP
 *     PHYSICAL2_TO_LOGICAL_SEL This is a PHYSICAL to LOGICAL mapping control. It indicates LOGICAL LANE mapping for data received on PHYSICAl LANE 2, for this MPP
 *     PHYSICAL3_TO_LOGICAL_SEL This is a PHYSICAL to LOGICAL mapping control. It indicates LOGICAL LANE mapping for data received on PHYSICAl LANE 3, for this MPP
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr (0x00109225 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_RX_LN_SWP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_s {
	uint32_t v[1];
	uint32_t rx_x1_rx_ln_swp[1];
	uint32_t _rx_x1_rx_ln_swp;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_CLR(r) (r).rx_x1_rx_ln_swp[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_SET(r,d) (r).rx_x1_rx_ln_swp[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_GET(r) (r).rx_x1_rx_ln_swp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL3_TO_LOGICAL_SELf_GET(r) ((((r).rx_x1_rx_ln_swp[0]) >> 9) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL3_TO_LOGICAL_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL2_TO_LOGICAL_SELf_GET(r) ((((r).rx_x1_rx_ln_swp[0]) >> 6) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL2_TO_LOGICAL_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL1_TO_LOGICAL_SELf_GET(r) ((((r).rx_x1_rx_ln_swp[0]) >> 3) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL1_TO_LOGICAL_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL0_TO_LOGICAL_SELf_GET(r) (((r).rx_x1_rx_ln_swp[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL0_TO_LOGICAL_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_X1_RX_LN_SWP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_RX_LN_SWPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr,(_r._rx_x1_rx_ln_swp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_RX_LN_SWPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr,(_r._rx_x1_rx_ln_swp)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_RX_LN_SWPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr,(_r._rx_x1_rx_ln_swp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_RX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr
#define RX_X1_RX_LN_SWPr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_t RX_X1_RX_LN_SWPr_t;
#define RX_X1_RX_LN_SWPr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_CLR
#define RX_X1_RX_LN_SWPr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_SET
#define RX_X1_RX_LN_SWPr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_GET
#define RX_X1_RX_LN_SWPr_PHYSICAL3_TO_LOGICAL_SELf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL3_TO_LOGICAL_SELf_GET
#define RX_X1_RX_LN_SWPr_PHYSICAL3_TO_LOGICAL_SELf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL3_TO_LOGICAL_SELf_SET
#define RX_X1_RX_LN_SWPr_PHYSICAL2_TO_LOGICAL_SELf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL2_TO_LOGICAL_SELf_GET
#define RX_X1_RX_LN_SWPr_PHYSICAL2_TO_LOGICAL_SELf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL2_TO_LOGICAL_SELf_SET
#define RX_X1_RX_LN_SWPr_PHYSICAL1_TO_LOGICAL_SELf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL1_TO_LOGICAL_SELf_GET
#define RX_X1_RX_LN_SWPr_PHYSICAL1_TO_LOGICAL_SELf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL1_TO_LOGICAL_SELf_SET
#define RX_X1_RX_LN_SWPr_PHYSICAL0_TO_LOGICAL_SELf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL0_TO_LOGICAL_SELf_GET
#define RX_X1_RX_LN_SWPr_PHYSICAL0_TO_LOGICAL_SELf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr_PHYSICAL0_TO_LOGICAL_SELf_SET
#define READ_RX_X1_RX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_RX_LN_SWPr
#define WRITE_RX_X1_RX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_RX_LN_SWPr
#define MODIFY_RX_X1_RX_LN_SWPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_RX_LN_SWPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_RX_LN_SWPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_BASE_R_FEC
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9230
 * DESC:     ECC status register for Base-R FEC memories
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ONE_BIT_ERR_EVENT_BASE_R_FEC 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_BASE_R_FEC 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr (0x00109230 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_BASE_R_FEC.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_base_r_fec[1];
	uint32_t _rx_x1_ecc_sts_base_r_fec;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_CLR(r) (r).rx_x1_ecc_sts_base_r_fec[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_SET(r,d) (r).rx_x1_ecc_sts_base_r_fec[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_GET(r) (r).rx_x1_ecc_sts_base_r_fec[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_TWO_BIT_ERR_EVENT_BASE_R_FECf_GET(r) ((((r).rx_x1_ecc_sts_base_r_fec[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_TWO_BIT_ERR_EVENT_BASE_R_FECf_SET(r,f) (r).rx_x1_ecc_sts_base_r_fec[0]=(((r).rx_x1_ecc_sts_base_r_fec[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_ONE_BIT_ERR_EVENT_BASE_R_FECf_GET(r) ((((r).rx_x1_ecc_sts_base_r_fec[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_ONE_BIT_ERR_EVENT_BASE_R_FECf_SET(r,f) (r).rx_x1_ecc_sts_base_r_fec[0]=(((r).rx_x1_ecc_sts_base_r_fec[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))

/*
 * These macros can be used to access RX_X1_ECC_STS_BASE_R_FEC.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_BASE_R_FECr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr,(_r._rx_x1_ecc_sts_base_r_fec))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_BASE_R_FECr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr,(_r._rx_x1_ecc_sts_base_r_fec)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_BASE_R_FECr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr,(_r._rx_x1_ecc_sts_base_r_fec))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_BASE_R_FECr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr
#define RX_X1_ECC_STS_BASE_R_FECr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_t RX_X1_ECC_STS_BASE_R_FECr_t;
#define RX_X1_ECC_STS_BASE_R_FECr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_CLR
#define RX_X1_ECC_STS_BASE_R_FECr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_SET
#define RX_X1_ECC_STS_BASE_R_FECr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_GET
#define RX_X1_ECC_STS_BASE_R_FECr_TWO_BIT_ERR_EVENT_BASE_R_FECf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_TWO_BIT_ERR_EVENT_BASE_R_FECf_GET
#define RX_X1_ECC_STS_BASE_R_FECr_TWO_BIT_ERR_EVENT_BASE_R_FECf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_TWO_BIT_ERR_EVENT_BASE_R_FECf_SET
#define RX_X1_ECC_STS_BASE_R_FECr_ONE_BIT_ERR_EVENT_BASE_R_FECf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_ONE_BIT_ERR_EVENT_BASE_R_FECf_GET
#define RX_X1_ECC_STS_BASE_R_FECr_ONE_BIT_ERR_EVENT_BASE_R_FECf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr_ONE_BIT_ERR_EVENT_BASE_R_FECf_SET
#define READ_RX_X1_ECC_STS_BASE_R_FECr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_BASE_R_FECr
#define WRITE_RX_X1_ECC_STS_BASE_R_FECr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_BASE_R_FECr
#define MODIFY_RX_X1_ECC_STS_BASE_R_FECr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_BASE_R_FECr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_BASE_R_FECr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_RSFEC_RBUF_MPP
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9231
 * DESC:     ECC status register for RSFEC RBUF memories in mpp_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ONE_BIT_ERR_EVENT_RSFEC_RBUF_MPP 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_RSFEC_RBUF_MPP 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr (0x00109231 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_RSFEC_RBUF_MPP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_rsfec_rbuf_mpp[1];
	uint32_t _rx_x1_ecc_sts_rsfec_rbuf_mpp;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_CLR(r) (r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_SET(r,d) (r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_GET(r) (r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_GET(r) ((((r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_SET(r,f) (r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0]=(((r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_GET(r) ((((r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_SET(r,f) (r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0]=(((r).rx_x1_ecc_sts_rsfec_rbuf_mpp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))

/*
 * These macros can be used to access RX_X1_ECC_STS_RSFEC_RBUF_MPP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RSFEC_RBUF_MPPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr,(_r._rx_x1_ecc_sts_rsfec_rbuf_mpp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RSFEC_RBUF_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr,(_r._rx_x1_ecc_sts_rsfec_rbuf_mpp)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RSFEC_RBUF_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr,(_r._rx_x1_ecc_sts_rsfec_rbuf_mpp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_t RX_X1_ECC_STS_RSFEC_RBUF_MPPr_t;
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_CLR
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_SET
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_GET
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_GET
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_SET
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_GET
#define RX_X1_ECC_STS_RSFEC_RBUF_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RBUF_MPPf_SET
#define READ_RX_X1_ECC_STS_RSFEC_RBUF_MPPr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RSFEC_RBUF_MPPr
#define WRITE_RX_X1_ECC_STS_RSFEC_RBUF_MPPr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RSFEC_RBUF_MPPr
#define MODIFY_RX_X1_ECC_STS_RSFEC_RBUF_MPPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RSFEC_RBUF_MPPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RBUF_MPPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_RSFEC_RS400G_MPP
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9233
 * DESC:     ECC status register for rsfec_rs400g_ecc_mpp
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ONE_BIT_ERR_EVENT_RSFEC_RS400G_MPP 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_RSFEC_RS400G_MPP 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr (0x00109233 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_RSFEC_RS400G_MPP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_rsfec_rs400g_mpp[1];
	uint32_t _rx_x1_ecc_sts_rsfec_rs400g_mpp;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_CLR(r) (r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_SET(r,d) (r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_GET(r) (r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_GET(r) ((((r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_SET(r,f) (r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0]=(((r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_GET(r) ((((r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_SET(r,f) (r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0]=(((r).rx_x1_ecc_sts_rsfec_rs400g_mpp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))

/*
 * These macros can be used to access RX_X1_ECC_STS_RSFEC_RS400G_MPP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RSFEC_RS400G_MPPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr,(_r._rx_x1_ecc_sts_rsfec_rs400g_mpp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RSFEC_RS400G_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr,(_r._rx_x1_ecc_sts_rsfec_rs400g_mpp)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RSFEC_RS400G_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr,(_r._rx_x1_ecc_sts_rsfec_rs400g_mpp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_t RX_X1_ECC_STS_RSFEC_RS400G_MPPr_t;
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_CLR
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_SET
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_GET
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_GET
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_TWO_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_SET
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_GET
#define RX_X1_ECC_STS_RSFEC_RS400G_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr_ONE_BIT_ERR_EVENT_RSFEC_RS400G_MPPf_SET
#define READ_RX_X1_ECC_STS_RSFEC_RS400G_MPPr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RSFEC_RS400G_MPPr
#define WRITE_RX_X1_ECC_STS_RSFEC_RS400G_MPPr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RSFEC_RS400G_MPPr
#define MODIFY_RX_X1_ECC_STS_RSFEC_RS400G_MPPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RSFEC_RS400G_MPPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RSFEC_RS400G_MPPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_DESKEW
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9235
 * DESC:     ECC status register for deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ONE_BIT_ERR_EVENT_DESKEW 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_DESKEW 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr (0x00109235 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_DESKEW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_deskew[1];
	uint32_t _rx_x1_ecc_sts_deskew;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_CLR(r) (r).rx_x1_ecc_sts_deskew[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_SET(r,d) (r).rx_x1_ecc_sts_deskew[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_GET(r) (r).rx_x1_ecc_sts_deskew[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_TWO_BIT_ERR_EVENT_DESKEWf_GET(r) ((((r).rx_x1_ecc_sts_deskew[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_TWO_BIT_ERR_EVENT_DESKEWf_SET(r,f) (r).rx_x1_ecc_sts_deskew[0]=(((r).rx_x1_ecc_sts_deskew[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_ONE_BIT_ERR_EVENT_DESKEWf_GET(r) ((((r).rx_x1_ecc_sts_deskew[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_ONE_BIT_ERR_EVENT_DESKEWf_SET(r,f) (r).rx_x1_ecc_sts_deskew[0]=(((r).rx_x1_ecc_sts_deskew[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))

/*
 * These macros can be used to access RX_X1_ECC_STS_DESKEW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_DESKEWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr,(_r._rx_x1_ecc_sts_deskew))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_DESKEWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr,(_r._rx_x1_ecc_sts_deskew)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_DESKEWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr,(_r._rx_x1_ecc_sts_deskew))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_DESKEWr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr
#define RX_X1_ECC_STS_DESKEWr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_t RX_X1_ECC_STS_DESKEWr_t;
#define RX_X1_ECC_STS_DESKEWr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_CLR
#define RX_X1_ECC_STS_DESKEWr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_SET
#define RX_X1_ECC_STS_DESKEWr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_GET
#define RX_X1_ECC_STS_DESKEWr_TWO_BIT_ERR_EVENT_DESKEWf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_TWO_BIT_ERR_EVENT_DESKEWf_GET
#define RX_X1_ECC_STS_DESKEWr_TWO_BIT_ERR_EVENT_DESKEWf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_TWO_BIT_ERR_EVENT_DESKEWf_SET
#define RX_X1_ECC_STS_DESKEWr_ONE_BIT_ERR_EVENT_DESKEWf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_ONE_BIT_ERR_EVENT_DESKEWf_GET
#define RX_X1_ECC_STS_DESKEWr_ONE_BIT_ERR_EVENT_DESKEWf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr_ONE_BIT_ERR_EVENT_DESKEWf_SET
#define READ_RX_X1_ECC_STS_DESKEWr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_DESKEWr
#define WRITE_RX_X1_ECC_STS_DESKEWr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_DESKEWr
#define MODIFY_RX_X1_ECC_STS_DESKEWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_DESKEWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_DESKEWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_SPD_TBL
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9236
 * DESC:     ECC status register for Speed table
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_SPD_TBL ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_SPD_TBL 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_SPD_TBL 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr (0x00109236 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_SPD_TBL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_spd_tbl[1];
	uint32_t _rx_x1_ecc_sts_spd_tbl;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_CLR(r) (r).rx_x1_ecc_sts_spd_tbl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_SET(r,d) (r).rx_x1_ecc_sts_spd_tbl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_GET(r) (r).rx_x1_ecc_sts_spd_tbl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_TWO_BIT_ERR_EVENT_SPD_TBLf_GET(r) ((((r).rx_x1_ecc_sts_spd_tbl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_TWO_BIT_ERR_EVENT_SPD_TBLf_SET(r,f) (r).rx_x1_ecc_sts_spd_tbl[0]=(((r).rx_x1_ecc_sts_spd_tbl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ONE_BIT_ERR_EVENT_SPD_TBLf_GET(r) ((((r).rx_x1_ecc_sts_spd_tbl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ONE_BIT_ERR_EVENT_SPD_TBLf_SET(r,f) (r).rx_x1_ecc_sts_spd_tbl[0]=(((r).rx_x1_ecc_sts_spd_tbl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ERR_EVENT_ADDRESS_SPD_TBLf_GET(r) (((r).rx_x1_ecc_sts_spd_tbl[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ERR_EVENT_ADDRESS_SPD_TBLf_SET(r,f) (r).rx_x1_ecc_sts_spd_tbl[0]=(((r).rx_x1_ecc_sts_spd_tbl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_SPD_TBL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_SPD_TBLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr,(_r._rx_x1_ecc_sts_spd_tbl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_SPD_TBLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr,(_r._rx_x1_ecc_sts_spd_tbl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_SPD_TBLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr,(_r._rx_x1_ecc_sts_spd_tbl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_SPD_TBLr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr
#define RX_X1_ECC_STS_SPD_TBLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_t RX_X1_ECC_STS_SPD_TBLr_t;
#define RX_X1_ECC_STS_SPD_TBLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_CLR
#define RX_X1_ECC_STS_SPD_TBLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_SET
#define RX_X1_ECC_STS_SPD_TBLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_GET
#define RX_X1_ECC_STS_SPD_TBLr_TWO_BIT_ERR_EVENT_SPD_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_TWO_BIT_ERR_EVENT_SPD_TBLf_GET
#define RX_X1_ECC_STS_SPD_TBLr_TWO_BIT_ERR_EVENT_SPD_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_TWO_BIT_ERR_EVENT_SPD_TBLf_SET
#define RX_X1_ECC_STS_SPD_TBLr_ONE_BIT_ERR_EVENT_SPD_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ONE_BIT_ERR_EVENT_SPD_TBLf_GET
#define RX_X1_ECC_STS_SPD_TBLr_ONE_BIT_ERR_EVENT_SPD_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ONE_BIT_ERR_EVENT_SPD_TBLf_SET
#define RX_X1_ECC_STS_SPD_TBLr_ERR_EVENT_ADDRESS_SPD_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ERR_EVENT_ADDRESS_SPD_TBLf_GET
#define RX_X1_ECC_STS_SPD_TBLr_ERR_EVENT_ADDRESS_SPD_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr_ERR_EVENT_ADDRESS_SPD_TBLf_SET
#define READ_RX_X1_ECC_STS_SPD_TBLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_SPD_TBLr
#define WRITE_RX_X1_ECC_STS_SPD_TBLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_SPD_TBLr
#define MODIFY_RX_X1_ECC_STS_SPD_TBLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_SPD_TBLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_SPD_TBLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_AM_TBL
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9237
 * DESC:     ECC status register for AM table
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_AM_TBL ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_AM_TBL 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_AM_TBL 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr (0x00109237 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_AM_TBL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_am_tbl[1];
	uint32_t _rx_x1_ecc_sts_am_tbl;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_CLR(r) (r).rx_x1_ecc_sts_am_tbl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_SET(r,d) (r).rx_x1_ecc_sts_am_tbl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_GET(r) (r).rx_x1_ecc_sts_am_tbl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_TWO_BIT_ERR_EVENT_AM_TBLf_GET(r) ((((r).rx_x1_ecc_sts_am_tbl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_TWO_BIT_ERR_EVENT_AM_TBLf_SET(r,f) (r).rx_x1_ecc_sts_am_tbl[0]=(((r).rx_x1_ecc_sts_am_tbl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ONE_BIT_ERR_EVENT_AM_TBLf_GET(r) ((((r).rx_x1_ecc_sts_am_tbl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ONE_BIT_ERR_EVENT_AM_TBLf_SET(r,f) (r).rx_x1_ecc_sts_am_tbl[0]=(((r).rx_x1_ecc_sts_am_tbl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ERR_EVENT_ADDRESS_AM_TBLf_GET(r) (((r).rx_x1_ecc_sts_am_tbl[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ERR_EVENT_ADDRESS_AM_TBLf_SET(r,f) (r).rx_x1_ecc_sts_am_tbl[0]=(((r).rx_x1_ecc_sts_am_tbl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_AM_TBL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_AM_TBLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr,(_r._rx_x1_ecc_sts_am_tbl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_AM_TBLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr,(_r._rx_x1_ecc_sts_am_tbl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_AM_TBLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr,(_r._rx_x1_ecc_sts_am_tbl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_AM_TBLr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr
#define RX_X1_ECC_STS_AM_TBLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_t RX_X1_ECC_STS_AM_TBLr_t;
#define RX_X1_ECC_STS_AM_TBLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_CLR
#define RX_X1_ECC_STS_AM_TBLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_SET
#define RX_X1_ECC_STS_AM_TBLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_GET
#define RX_X1_ECC_STS_AM_TBLr_TWO_BIT_ERR_EVENT_AM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_TWO_BIT_ERR_EVENT_AM_TBLf_GET
#define RX_X1_ECC_STS_AM_TBLr_TWO_BIT_ERR_EVENT_AM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_TWO_BIT_ERR_EVENT_AM_TBLf_SET
#define RX_X1_ECC_STS_AM_TBLr_ONE_BIT_ERR_EVENT_AM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ONE_BIT_ERR_EVENT_AM_TBLf_GET
#define RX_X1_ECC_STS_AM_TBLr_ONE_BIT_ERR_EVENT_AM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ONE_BIT_ERR_EVENT_AM_TBLf_SET
#define RX_X1_ECC_STS_AM_TBLr_ERR_EVENT_ADDRESS_AM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ERR_EVENT_ADDRESS_AM_TBLf_GET
#define RX_X1_ECC_STS_AM_TBLr_ERR_EVENT_ADDRESS_AM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr_ERR_EVENT_ADDRESS_AM_TBLf_SET
#define READ_RX_X1_ECC_STS_AM_TBLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_AM_TBLr
#define WRITE_RX_X1_ECC_STS_AM_TBLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_AM_TBLr
#define MODIFY_RX_X1_ECC_STS_AM_TBLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_AM_TBLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_AM_TBLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_UM_TBL
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9238
 * DESC:     ECC status register for UM table
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_UM_TBL ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_UM_TBL 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_UM_TBL 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr (0x00109238 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_UM_TBL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_um_tbl[1];
	uint32_t _rx_x1_ecc_sts_um_tbl;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_CLR(r) (r).rx_x1_ecc_sts_um_tbl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_SET(r,d) (r).rx_x1_ecc_sts_um_tbl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_GET(r) (r).rx_x1_ecc_sts_um_tbl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_TWO_BIT_ERR_EVENT_UM_TBLf_GET(r) ((((r).rx_x1_ecc_sts_um_tbl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_TWO_BIT_ERR_EVENT_UM_TBLf_SET(r,f) (r).rx_x1_ecc_sts_um_tbl[0]=(((r).rx_x1_ecc_sts_um_tbl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ONE_BIT_ERR_EVENT_UM_TBLf_GET(r) ((((r).rx_x1_ecc_sts_um_tbl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ONE_BIT_ERR_EVENT_UM_TBLf_SET(r,f) (r).rx_x1_ecc_sts_um_tbl[0]=(((r).rx_x1_ecc_sts_um_tbl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ERR_EVENT_ADDRESS_UM_TBLf_GET(r) (((r).rx_x1_ecc_sts_um_tbl[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ERR_EVENT_ADDRESS_UM_TBLf_SET(r,f) (r).rx_x1_ecc_sts_um_tbl[0]=(((r).rx_x1_ecc_sts_um_tbl[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_UM_TBL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_UM_TBLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr,(_r._rx_x1_ecc_sts_um_tbl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_UM_TBLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr,(_r._rx_x1_ecc_sts_um_tbl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_UM_TBLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr,(_r._rx_x1_ecc_sts_um_tbl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_UM_TBLr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr
#define RX_X1_ECC_STS_UM_TBLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_t RX_X1_ECC_STS_UM_TBLr_t;
#define RX_X1_ECC_STS_UM_TBLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_CLR
#define RX_X1_ECC_STS_UM_TBLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_SET
#define RX_X1_ECC_STS_UM_TBLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_GET
#define RX_X1_ECC_STS_UM_TBLr_TWO_BIT_ERR_EVENT_UM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_TWO_BIT_ERR_EVENT_UM_TBLf_GET
#define RX_X1_ECC_STS_UM_TBLr_TWO_BIT_ERR_EVENT_UM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_TWO_BIT_ERR_EVENT_UM_TBLf_SET
#define RX_X1_ECC_STS_UM_TBLr_ONE_BIT_ERR_EVENT_UM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ONE_BIT_ERR_EVENT_UM_TBLf_GET
#define RX_X1_ECC_STS_UM_TBLr_ONE_BIT_ERR_EVENT_UM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ONE_BIT_ERR_EVENT_UM_TBLf_SET
#define RX_X1_ECC_STS_UM_TBLr_ERR_EVENT_ADDRESS_UM_TBLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ERR_EVENT_ADDRESS_UM_TBLf_GET
#define RX_X1_ECC_STS_UM_TBLr_ERR_EVENT_ADDRESS_UM_TBLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr_ERR_EVENT_ADDRESS_UM_TBLf_SET
#define READ_RX_X1_ECC_STS_UM_TBLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_UM_TBLr
#define WRITE_RX_X1_ECC_STS_UM_TBLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_UM_TBLr
#define MODIFY_RX_X1_ECC_STS_UM_TBLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_UM_TBLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_UM_TBLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_TX_1588_MPP
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9239
 * DESC:     ECC status register for TX 1588 LOOKUP memory for mpp
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_TX_1588_MPP ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_TX_1588_MPP 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_TX_1588_MPP 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr (0x00109239 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_TX_1588_MPP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_tx_1588_mpp[1];
	uint32_t _rx_x1_ecc_sts_tx_1588_mpp;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_CLR(r) (r).rx_x1_ecc_sts_tx_1588_mpp[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_SET(r,d) (r).rx_x1_ecc_sts_tx_1588_mpp[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_GET(r) (r).rx_x1_ecc_sts_tx_1588_mpp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_TWO_BIT_ERR_EVENT_TX_1588_MPPf_GET(r) ((((r).rx_x1_ecc_sts_tx_1588_mpp[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_TWO_BIT_ERR_EVENT_TX_1588_MPPf_SET(r,f) (r).rx_x1_ecc_sts_tx_1588_mpp[0]=(((r).rx_x1_ecc_sts_tx_1588_mpp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ONE_BIT_ERR_EVENT_TX_1588_MPPf_GET(r) ((((r).rx_x1_ecc_sts_tx_1588_mpp[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ONE_BIT_ERR_EVENT_TX_1588_MPPf_SET(r,f) (r).rx_x1_ecc_sts_tx_1588_mpp[0]=(((r).rx_x1_ecc_sts_tx_1588_mpp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ERR_EVENT_ADDRESS_TX_1588_MPPf_GET(r) (((r).rx_x1_ecc_sts_tx_1588_mpp[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ERR_EVENT_ADDRESS_TX_1588_MPPf_SET(r,f) (r).rx_x1_ecc_sts_tx_1588_mpp[0]=(((r).rx_x1_ecc_sts_tx_1588_mpp[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_TX_1588_MPP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_TX_1588_MPPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr,(_r._rx_x1_ecc_sts_tx_1588_mpp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_TX_1588_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr,(_r._rx_x1_ecc_sts_tx_1588_mpp)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_TX_1588_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr,(_r._rx_x1_ecc_sts_tx_1588_mpp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_TX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr
#define RX_X1_ECC_STS_TX_1588_MPPr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_t RX_X1_ECC_STS_TX_1588_MPPr_t;
#define RX_X1_ECC_STS_TX_1588_MPPr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_CLR
#define RX_X1_ECC_STS_TX_1588_MPPr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_SET
#define RX_X1_ECC_STS_TX_1588_MPPr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_GET
#define RX_X1_ECC_STS_TX_1588_MPPr_TWO_BIT_ERR_EVENT_TX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_TWO_BIT_ERR_EVENT_TX_1588_MPPf_GET
#define RX_X1_ECC_STS_TX_1588_MPPr_TWO_BIT_ERR_EVENT_TX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_TWO_BIT_ERR_EVENT_TX_1588_MPPf_SET
#define RX_X1_ECC_STS_TX_1588_MPPr_ONE_BIT_ERR_EVENT_TX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ONE_BIT_ERR_EVENT_TX_1588_MPPf_GET
#define RX_X1_ECC_STS_TX_1588_MPPr_ONE_BIT_ERR_EVENT_TX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ONE_BIT_ERR_EVENT_TX_1588_MPPf_SET
#define RX_X1_ECC_STS_TX_1588_MPPr_ERR_EVENT_ADDRESS_TX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ERR_EVENT_ADDRESS_TX_1588_MPPf_GET
#define RX_X1_ECC_STS_TX_1588_MPPr_ERR_EVENT_ADDRESS_TX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr_ERR_EVENT_ADDRESS_TX_1588_MPPf_SET
#define READ_RX_X1_ECC_STS_TX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_TX_1588_MPPr
#define WRITE_RX_X1_ECC_STS_TX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_TX_1588_MPPr
#define MODIFY_RX_X1_ECC_STS_TX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_TX_1588_MPPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_MPPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_TX_1588_400G
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x923b
 * DESC:     ECC status register for TX 1588 LOOKUP memory for 400G
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_TX_1588_400G ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_TX_1588_400G 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_TX_1588_400G 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr (0x0010923b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_TX_1588_400G.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_tx_1588_400g[1];
	uint32_t _rx_x1_ecc_sts_tx_1588_400g;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_CLR(r) (r).rx_x1_ecc_sts_tx_1588_400g[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_SET(r,d) (r).rx_x1_ecc_sts_tx_1588_400g[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_GET(r) (r).rx_x1_ecc_sts_tx_1588_400g[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_TWO_BIT_ERR_EVENT_TX_1588_400Gf_GET(r) ((((r).rx_x1_ecc_sts_tx_1588_400g[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_TWO_BIT_ERR_EVENT_TX_1588_400Gf_SET(r,f) (r).rx_x1_ecc_sts_tx_1588_400g[0]=(((r).rx_x1_ecc_sts_tx_1588_400g[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ONE_BIT_ERR_EVENT_TX_1588_400Gf_GET(r) ((((r).rx_x1_ecc_sts_tx_1588_400g[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ONE_BIT_ERR_EVENT_TX_1588_400Gf_SET(r,f) (r).rx_x1_ecc_sts_tx_1588_400g[0]=(((r).rx_x1_ecc_sts_tx_1588_400g[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ERR_EVENT_ADDRESS_TX_1588_400Gf_GET(r) (((r).rx_x1_ecc_sts_tx_1588_400g[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ERR_EVENT_ADDRESS_TX_1588_400Gf_SET(r,f) (r).rx_x1_ecc_sts_tx_1588_400g[0]=(((r).rx_x1_ecc_sts_tx_1588_400g[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_TX_1588_400G.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_TX_1588_400Gr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr,(_r._rx_x1_ecc_sts_tx_1588_400g))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_TX_1588_400Gr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr,(_r._rx_x1_ecc_sts_tx_1588_400g)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_TX_1588_400Gr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr,(_r._rx_x1_ecc_sts_tx_1588_400g))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_TX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr
#define RX_X1_ECC_STS_TX_1588_400Gr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_t RX_X1_ECC_STS_TX_1588_400Gr_t;
#define RX_X1_ECC_STS_TX_1588_400Gr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_CLR
#define RX_X1_ECC_STS_TX_1588_400Gr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_SET
#define RX_X1_ECC_STS_TX_1588_400Gr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_GET
#define RX_X1_ECC_STS_TX_1588_400Gr_TWO_BIT_ERR_EVENT_TX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_TWO_BIT_ERR_EVENT_TX_1588_400Gf_GET
#define RX_X1_ECC_STS_TX_1588_400Gr_TWO_BIT_ERR_EVENT_TX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_TWO_BIT_ERR_EVENT_TX_1588_400Gf_SET
#define RX_X1_ECC_STS_TX_1588_400Gr_ONE_BIT_ERR_EVENT_TX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ONE_BIT_ERR_EVENT_TX_1588_400Gf_GET
#define RX_X1_ECC_STS_TX_1588_400Gr_ONE_BIT_ERR_EVENT_TX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ONE_BIT_ERR_EVENT_TX_1588_400Gf_SET
#define RX_X1_ECC_STS_TX_1588_400Gr_ERR_EVENT_ADDRESS_TX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ERR_EVENT_ADDRESS_TX_1588_400Gf_GET
#define RX_X1_ECC_STS_TX_1588_400Gr_ERR_EVENT_ADDRESS_TX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr_ERR_EVENT_ADDRESS_TX_1588_400Gf_SET
#define READ_RX_X1_ECC_STS_TX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_TX_1588_400Gr
#define WRITE_RX_X1_ECC_STS_TX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_TX_1588_400Gr
#define MODIFY_RX_X1_ECC_STS_TX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_TX_1588_400Gr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_TX_1588_400Gr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_RX_1588_MPP
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x923c
 * DESC:     ECC status register for RX 1588 LOOKUP memory for mpp (mpp0=even memory, mpp1=odd memory)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_RX_1588_MPP ECC error location, valid only if 1-bit or 2-bit error bit is setAddress is the native address within the physical even or odd memory,and not the same as address normally used for programming the tables.
 *     ONE_BIT_ERR_EVENT_RX_1588_MPP 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_RX_1588_MPP 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr (0x0010923c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_RX_1588_MPP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_rx_1588_mpp[1];
	uint32_t _rx_x1_ecc_sts_rx_1588_mpp;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_CLR(r) (r).rx_x1_ecc_sts_rx_1588_mpp[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_SET(r,d) (r).rx_x1_ecc_sts_rx_1588_mpp[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_GET(r) (r).rx_x1_ecc_sts_rx_1588_mpp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_TWO_BIT_ERR_EVENT_RX_1588_MPPf_GET(r) ((((r).rx_x1_ecc_sts_rx_1588_mpp[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_TWO_BIT_ERR_EVENT_RX_1588_MPPf_SET(r,f) (r).rx_x1_ecc_sts_rx_1588_mpp[0]=(((r).rx_x1_ecc_sts_rx_1588_mpp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ONE_BIT_ERR_EVENT_RX_1588_MPPf_GET(r) ((((r).rx_x1_ecc_sts_rx_1588_mpp[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ONE_BIT_ERR_EVENT_RX_1588_MPPf_SET(r,f) (r).rx_x1_ecc_sts_rx_1588_mpp[0]=(((r).rx_x1_ecc_sts_rx_1588_mpp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ERR_EVENT_ADDRESS_RX_1588_MPPf_GET(r) (((r).rx_x1_ecc_sts_rx_1588_mpp[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ERR_EVENT_ADDRESS_RX_1588_MPPf_SET(r,f) (r).rx_x1_ecc_sts_rx_1588_mpp[0]=(((r).rx_x1_ecc_sts_rx_1588_mpp[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_RX_1588_MPP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RX_1588_MPPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr,(_r._rx_x1_ecc_sts_rx_1588_mpp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RX_1588_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr,(_r._rx_x1_ecc_sts_rx_1588_mpp)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RX_1588_MPPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr,(_r._rx_x1_ecc_sts_rx_1588_mpp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_RX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr
#define RX_X1_ECC_STS_RX_1588_MPPr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_t RX_X1_ECC_STS_RX_1588_MPPr_t;
#define RX_X1_ECC_STS_RX_1588_MPPr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_CLR
#define RX_X1_ECC_STS_RX_1588_MPPr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_SET
#define RX_X1_ECC_STS_RX_1588_MPPr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_GET
#define RX_X1_ECC_STS_RX_1588_MPPr_TWO_BIT_ERR_EVENT_RX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_TWO_BIT_ERR_EVENT_RX_1588_MPPf_GET
#define RX_X1_ECC_STS_RX_1588_MPPr_TWO_BIT_ERR_EVENT_RX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_TWO_BIT_ERR_EVENT_RX_1588_MPPf_SET
#define RX_X1_ECC_STS_RX_1588_MPPr_ONE_BIT_ERR_EVENT_RX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ONE_BIT_ERR_EVENT_RX_1588_MPPf_GET
#define RX_X1_ECC_STS_RX_1588_MPPr_ONE_BIT_ERR_EVENT_RX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ONE_BIT_ERR_EVENT_RX_1588_MPPf_SET
#define RX_X1_ECC_STS_RX_1588_MPPr_ERR_EVENT_ADDRESS_RX_1588_MPPf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ERR_EVENT_ADDRESS_RX_1588_MPPf_GET
#define RX_X1_ECC_STS_RX_1588_MPPr_ERR_EVENT_ADDRESS_RX_1588_MPPf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr_ERR_EVENT_ADDRESS_RX_1588_MPPf_SET
#define READ_RX_X1_ECC_STS_RX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RX_1588_MPPr
#define WRITE_RX_X1_ECC_STS_RX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RX_1588_MPPr
#define MODIFY_RX_X1_ECC_STS_RX_1588_MPPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RX_1588_MPPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_MPPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X1_ECC_STS_RX_1588_400G
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x923e
 * DESC:     ECC status register for RX 1588 LOOKUP memory for 400G
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_RX_1588_400G ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_RX_1588_400G 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_RX_1588_400G 2-bit ECC error detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr (0x0010923e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_RX_1588_400G.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_rx_1588_400g[1];
	uint32_t _rx_x1_ecc_sts_rx_1588_400g;
} BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_CLR(r) (r).rx_x1_ecc_sts_rx_1588_400g[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_SET(r,d) (r).rx_x1_ecc_sts_rx_1588_400g[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_GET(r) (r).rx_x1_ecc_sts_rx_1588_400g[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_TWO_BIT_ERR_EVENT_RX_1588_400Gf_GET(r) ((((r).rx_x1_ecc_sts_rx_1588_400g[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_TWO_BIT_ERR_EVENT_RX_1588_400Gf_SET(r,f) (r).rx_x1_ecc_sts_rx_1588_400g[0]=(((r).rx_x1_ecc_sts_rx_1588_400g[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ONE_BIT_ERR_EVENT_RX_1588_400Gf_GET(r) ((((r).rx_x1_ecc_sts_rx_1588_400g[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ONE_BIT_ERR_EVENT_RX_1588_400Gf_SET(r,f) (r).rx_x1_ecc_sts_rx_1588_400g[0]=(((r).rx_x1_ecc_sts_rx_1588_400g[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ERR_EVENT_ADDRESS_RX_1588_400Gf_GET(r) (((r).rx_x1_ecc_sts_rx_1588_400g[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ERR_EVENT_ADDRESS_RX_1588_400Gf_SET(r,f) (r).rx_x1_ecc_sts_rx_1588_400g[0]=(((r).rx_x1_ecc_sts_rx_1588_400g[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_RX_1588_400G.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RX_1588_400Gr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr,(_r._rx_x1_ecc_sts_rx_1588_400g))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RX_1588_400Gr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr,(_r._rx_x1_ecc_sts_rx_1588_400g)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RX_1588_400Gr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr,(_r._rx_x1_ecc_sts_rx_1588_400g))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_RX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr
#define RX_X1_ECC_STS_RX_1588_400Gr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_t RX_X1_ECC_STS_RX_1588_400Gr_t;
#define RX_X1_ECC_STS_RX_1588_400Gr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_CLR
#define RX_X1_ECC_STS_RX_1588_400Gr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_SET
#define RX_X1_ECC_STS_RX_1588_400Gr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_GET
#define RX_X1_ECC_STS_RX_1588_400Gr_TWO_BIT_ERR_EVENT_RX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_TWO_BIT_ERR_EVENT_RX_1588_400Gf_GET
#define RX_X1_ECC_STS_RX_1588_400Gr_TWO_BIT_ERR_EVENT_RX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_TWO_BIT_ERR_EVENT_RX_1588_400Gf_SET
#define RX_X1_ECC_STS_RX_1588_400Gr_ONE_BIT_ERR_EVENT_RX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ONE_BIT_ERR_EVENT_RX_1588_400Gf_GET
#define RX_X1_ECC_STS_RX_1588_400Gr_ONE_BIT_ERR_EVENT_RX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ONE_BIT_ERR_EVENT_RX_1588_400Gf_SET
#define RX_X1_ECC_STS_RX_1588_400Gr_ERR_EVENT_ADDRESS_RX_1588_400Gf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ERR_EVENT_ADDRESS_RX_1588_400Gf_GET
#define RX_X1_ECC_STS_RX_1588_400Gr_ERR_EVENT_ADDRESS_RX_1588_400Gf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr_ERR_EVENT_ADDRESS_RX_1588_400Gf_SET
#define READ_RX_X1_ECC_STS_RX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X1_ECC_STS_RX_1588_400Gr
#define WRITE_RX_X1_ECC_STS_RX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X1_ECC_STS_RX_1588_400Gr
#define MODIFY_RX_X1_ECC_STS_RX_1588_400Gr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X1_ECC_STS_RX_1588_400Gr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X1_ECC_STS_RX_1588_400Gr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_OUI_UPR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9240
 * DESC:     OUI UPPER BITS REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OUI_UPPER_DATA   UPPER 8 BITS OF OUI FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr (0x00109240 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_OUI_UPR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_s {
	uint32_t v[1];
	uint32_t an_x1_oui_upr[1];
	uint32_t _an_x1_oui_upr;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_CLR(r) (r).an_x1_oui_upr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_SET(r,d) (r).an_x1_oui_upr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_GET(r) (r).an_x1_oui_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET(r) (((r).an_x1_oui_upr[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET(r,f) (r).an_x1_oui_upr[0]=(((r).an_x1_oui_upr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_X1_OUI_UPR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_OUI_UPRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_OUI_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_OUI_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_OUI_UPRr BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr
#define AN_X1_OUI_UPRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_t AN_X1_OUI_UPRr_t;
#define AN_X1_OUI_UPRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_CLR
#define AN_X1_OUI_UPRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_SET
#define AN_X1_OUI_UPRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_GET
#define AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET
#define AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET
#define READ_AN_X1_OUI_UPRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_OUI_UPRr
#define WRITE_AN_X1_OUI_UPRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_OUI_UPRr
#define MODIFY_AN_X1_OUI_UPRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_OUI_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_OUI_LWR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9241
 * DESC:     OUI LOWEr BITS REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OUI_LOWER_DATA   LOWER 16 BITS OF OUI FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr (0x00109241 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_OUI_LWR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_s {
	uint32_t v[1];
	uint32_t an_x1_oui_lwr[1];
	uint32_t _an_x1_oui_lwr;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_CLR(r) (r).an_x1_oui_lwr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_SET(r,d) (r).an_x1_oui_lwr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_GET(r) (r).an_x1_oui_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET(r) (((r).an_x1_oui_lwr[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET(r,f) (r).an_x1_oui_lwr[0]=(((r).an_x1_oui_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_OUI_LWR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_OUI_LWRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_OUI_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_OUI_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_OUI_LWRr BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr
#define AN_X1_OUI_LWRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_t AN_X1_OUI_LWRr_t;
#define AN_X1_OUI_LWRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_CLR
#define AN_X1_OUI_LWRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_SET
#define AN_X1_OUI_LWRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_GET
#define AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET
#define AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET
#define READ_AN_X1_OUI_LWRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_OUI_LWRr
#define WRITE_AN_X1_OUI_LWRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_OUI_LWRr
#define MODIFY_AN_X1_OUI_LWRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_OUI_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_OUI_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_CL73_BRK_LNK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9250
 * DESC:     CL73 AUTO-NEG BREAK-LINK TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_BREAK_TIMER_PERIOD Period/range is 60 toCL73 auto-neg break-link timer.  Timer for the amount of time to disable transmission in order to assure that the link parner enters a Link Fail state.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr (0x00109250 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_BRK_LNK.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_brk_lnk[1];
	uint32_t _an_x1_cl73_brk_lnk;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_CLR(r) (r).an_x1_cl73_brk_lnk[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_SET(r,d) (r).an_x1_cl73_brk_lnk[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_GET(r) (r).an_x1_cl73_brk_lnk[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_brk_lnk[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_brk_lnk[0]=(((r).an_x1_cl73_brk_lnk[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_BRK_LNK.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_BRK_LNKr BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr
#define AN_X1_CL73_BRK_LNKr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_t AN_X1_CL73_BRK_LNKr_t;
#define AN_X1_CL73_BRK_LNKr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_CLR
#define AN_X1_CL73_BRK_LNKr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_SET
#define AN_X1_CL73_BRK_LNKr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_GET
#define AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_GET
#define AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_BRK_LNKr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_CL73_BRK_LNKr
#define WRITE_AN_X1_CL73_BRK_LNKr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_CL73_BRK_LNKr
#define MODIFY_AN_X1_CL73_BRK_LNKr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_CL73_BRK_LNKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_BRK_LNKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_CL73_ERR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9251
 * DESC:     CL73 AUTO-NEG TIMEOUT-ERROR TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_ERROR_TIMER_PERIOD Period/range is 20.6 msCL73 auto-neg timeout-error timer Timer for the amount ot time to wait to receive a page from the link partner.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr (0x00109251 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_ERR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_err[1];
	uint32_t _an_x1_cl73_err;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_CLR(r) (r).an_x1_cl73_err[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_SET(r,d) (r).an_x1_cl73_err[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_GET(r) (r).an_x1_cl73_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_err[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_err[0]=(((r).an_x1_cl73_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_ERR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_CL73_ERRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_CL73_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_CL73_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_ERRr BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr
#define AN_X1_CL73_ERRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_t AN_X1_CL73_ERRr_t;
#define AN_X1_CL73_ERRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_CLR
#define AN_X1_CL73_ERRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_SET
#define AN_X1_CL73_ERRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_GET
#define AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET
#define AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_ERRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_CL73_ERRr
#define WRITE_AN_X1_CL73_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_CL73_ERRr
#define MODIFY_AN_X1_CL73_ERRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_CL73_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_CL73_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_IGNORE_LNK_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9254
 * DESC:     PERIOD TO IGNORE THE LINK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     IGNORE_LINK_TIMER_PERIOD Period is in ticksPeriod to ignore the link while CL73 and possibly CL72 are running
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr (0x00109254 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_IGNORE_LNK_TMR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_ignore_lnk_tmr[1];
	uint32_t _an_x1_ignore_lnk_tmr;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_CLR(r) (r).an_x1_ignore_lnk_tmr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_SET(r,d) (r).an_x1_ignore_lnk_tmr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_GET(r) (r).an_x1_ignore_lnk_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET(r) (((r).an_x1_ignore_lnk_tmr[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET(r,f) (r).an_x1_ignore_lnk_tmr[0]=(((r).an_x1_ignore_lnk_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_IGNORE_LNK_TMR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_IGNORE_LNK_TMRr BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr
#define AN_X1_IGNORE_LNK_TMRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_t AN_X1_IGNORE_LNK_TMRr_t;
#define AN_X1_IGNORE_LNK_TMRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_CLR
#define AN_X1_IGNORE_LNK_TMRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_SET
#define AN_X1_IGNORE_LNK_TMRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_GET
#define AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET
#define AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET
#define READ_AN_X1_IGNORE_LNK_TMRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_IGNORE_LNK_TMRr
#define WRITE_AN_X1_IGNORE_LNK_TMRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_IGNORE_LNK_TMRr
#define MODIFY_AN_X1_IGNORE_LNK_TMRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9255
 * DESC:     TIMER FOR QUALIFYING A LINK_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD Period/range is typically 500msTimer for qualifying a link_status==FAIL indication or a link_status==OK indication when a link is first being established and cl72 training is being run.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r (0x00109255 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_CL72.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_cl72[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_cl72;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_cl72[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0]=(((r).an_x1_lnk_fail_inhbt_tmr_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_CL72.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9256
 * DESC:     TIMER FOR QUALIFYING A LINK_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD Period/range is typically 40msTimer for qualifying a link_status==FAIL indication or a link_status==OK indication when a link is first being established and cl72 training is not being run.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r (0x00109256 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_not_cl72[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_not_cl72;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]=(((r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_DME_PAGE_TMR_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9257
 * DESC:     DME PAGE TIMERS
 * RESETVAL: 0x3b5f (15199)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_PAGE_TEST_MIN_TIMER Specifies the minimum length of a CL73 DME page.  Units are 8 samples.  Each sample represents 0.4 ns
 *     CL73_PAGE_TEST_MAX_TIMER Specifies the maximum length of a CL73 DME page.  Units are 8 samples.  Each sample represents 0.4 ns
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr (0x00109257 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_DME_PAGE_TMR_TYPE.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_s {
	uint32_t v[1];
	uint32_t an_x1_dme_page_tmr_type[1];
	uint32_t _an_x1_dme_page_tmr_type;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CLR(r) (r).an_x1_dme_page_tmr_type[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SET(r,d) (r).an_x1_dme_page_tmr_type[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_GET(r) (r).an_x1_dme_page_tmr_type[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_GET(r) ((((r).an_x1_dme_page_tmr_type[0]) >> 7) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_SET(r,f) (r).an_x1_dme_page_tmr_type[0]=(((r).an_x1_dme_page_tmr_type[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7)) | (127 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_GET(r) (((r).an_x1_dme_page_tmr_type[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_SET(r,f) (r).an_x1_dme_page_tmr_type[0]=(((r).an_x1_dme_page_tmr_type[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access AN_X1_DME_PAGE_TMR_TYPE.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_DME_PAGE_TMR_TYPEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr,(_r._an_x1_dme_page_tmr_type))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_DME_PAGE_TMR_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr,(_r._an_x1_dme_page_tmr_type)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_DME_PAGE_TMR_TYPEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr,(_r._an_x1_dme_page_tmr_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr
#define AN_X1_DME_PAGE_TMR_TYPEr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_t AN_X1_DME_PAGE_TMR_TYPEr_t;
#define AN_X1_DME_PAGE_TMR_TYPEr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CLR
#define AN_X1_DME_PAGE_TMR_TYPEr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SET
#define AN_X1_DME_PAGE_TMR_TYPEr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_GET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_GET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_SET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_GET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_SET
#define READ_AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_DME_PAGE_TMR_TYPEr
#define WRITE_AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_DME_PAGE_TMR_TYPEr
#define MODIFY_AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_DME_PAGE_TMR_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_DME_PAGE_TMR_TYPEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_IGNORE_LNK_TMR_PAM4
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9259
 * DESC:     PERIOD TO IGNORE THE LINK FOR PAM-4 LINKS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     IGNORE_LINK_TIMER_PERIOD_PAM4 Period to ignore the link while CL73 and possiblyCL72 are runningGRANULARITY OF 4 TICKs of 15us EACH FOR A MAX DURATION OF 3.9 SECONDS
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r (0x00109259 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_IGNORE_LNK_TMR_PAM4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_s {
	uint32_t v[1];
	uint32_t an_x1_ignore_lnk_tmr_pam4[1];
	uint32_t _an_x1_ignore_lnk_tmr_pam4;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_CLR(r) (r).an_x1_ignore_lnk_tmr_pam4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_SET(r,d) (r).an_x1_ignore_lnk_tmr_pam4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_GET(r) (r).an_x1_ignore_lnk_tmr_pam4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_IGNORE_LINK_TIMER_PERIOD_PAM4f_GET(r) (((r).an_x1_ignore_lnk_tmr_pam4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_IGNORE_LINK_TIMER_PERIOD_PAM4f_SET(r,f) (r).an_x1_ignore_lnk_tmr_pam4[0]=(((r).an_x1_ignore_lnk_tmr_pam4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_IGNORE_LNK_TMR_PAM4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_IGNORE_LNK_TMR_PAM4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r,(_r._an_x1_ignore_lnk_tmr_pam4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_IGNORE_LNK_TMR_PAM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r,(_r._an_x1_ignore_lnk_tmr_pam4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMR_PAM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r,(_r._an_x1_ignore_lnk_tmr_pam4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_IGNORE_LNK_TMR_PAM4r BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r
#define AN_X1_IGNORE_LNK_TMR_PAM4r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_t AN_X1_IGNORE_LNK_TMR_PAM4r_t;
#define AN_X1_IGNORE_LNK_TMR_PAM4r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_CLR
#define AN_X1_IGNORE_LNK_TMR_PAM4r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_SET
#define AN_X1_IGNORE_LNK_TMR_PAM4r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_GET
#define AN_X1_IGNORE_LNK_TMR_PAM4r_IGNORE_LINK_TIMER_PERIOD_PAM4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_IGNORE_LINK_TIMER_PERIOD_PAM4f_GET
#define AN_X1_IGNORE_LNK_TMR_PAM4r_IGNORE_LINK_TIMER_PERIOD_PAM4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r_IGNORE_LINK_TIMER_PERIOD_PAM4f_SET
#define READ_AN_X1_IGNORE_LNK_TMR_PAM4r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_IGNORE_LNK_TMR_PAM4r
#define WRITE_AN_X1_IGNORE_LNK_TMR_PAM4r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_IGNORE_LNK_TMR_PAM4r
#define MODIFY_AN_X1_IGNORE_LNK_TMR_PAM4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMR_PAM4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_IGNORE_LNK_TMR_PAM4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925a
 * DESC:     TIMER FOR QUALIFYING A LINK_STATUS FOR PAM-4 LINKS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD_PAM4 Timer for qualifying a link_status==FAIL indicationor a link_status==OK indication when a link is firstbeing established and cl72 training is being run.GRANULARITY OF 4 TICKs of 15us EACH FOR A MAX DURATION OF 3.9 SECONDS
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r (0x0010925a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_cl72_pam4[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_cl72_pam4;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72_pam4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_cl72_pam4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72_pam4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD_PAM4f_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_cl72_pam4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD_PAM4f_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_cl72_pam4[0]=(((r).an_x1_lnk_fail_inhbt_tmr_cl72_pam4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72_pam4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72_pam4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72_pam4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_t AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD_PAM4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD_PAM4f_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD_PAM4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD_PAM4f_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72_PAM4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x925b
 * DESC:     TIMER FOR QUALIFYING A LINK_STATUS FOR PAM-4 LINKS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD_PAM4 Timer for qualifying a link_status==FAIL indicationor a link_status==OK indication when a link is firstbeing established and cl72 training is not beingrun.GRANULARITY OF 4 TICKs of 15us EACH FOR A MAX DURATION OF 3.9 SECONDS
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r (0x0010925b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD_PAM4f_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD_PAM4f_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4[0]=(((r).an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72_pam4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_t AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD_PAM4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD_PAM4f_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD_PAM4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD_PAM4f_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72_PAM4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X1_PIPE_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9262
 * DESC:     Pipeline reset count
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     PIPELINE_RESET_COUNT period in clock cyclesCounter for amount of time to keep pipeline in resetduring speed change process
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr (0x00109262 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PIPE_RST_CNT.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_pipe_rst_cnt[1];
	uint32_t _sc_x1_pipe_rst_cnt;
} BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_CLR(r) (r).sc_x1_pipe_rst_cnt[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_SET(r,d) (r).sc_x1_pipe_rst_cnt[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_GET(r) (r).sc_x1_pipe_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET(r) (((r).sc_x1_pipe_rst_cnt[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET(r,f) (r).sc_x1_pipe_rst_cnt[0]=(((r).sc_x1_pipe_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_PIPE_RST_CNT.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PIPE_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr
#define SC_X1_PIPE_RST_CNTr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_t SC_X1_PIPE_RST_CNTr_t;
#define SC_X1_PIPE_RST_CNTr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_CLR
#define SC_X1_PIPE_RST_CNTr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_SET
#define SC_X1_PIPE_RST_CNTr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET
#define READ_SC_X1_PIPE_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X1_PIPE_RST_CNTr
#define WRITE_SC_X1_PIPE_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X1_PIPE_RST_CNTr
#define MODIFY_SC_X1_PIPE_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X1_PIPE_RST_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X1_TX_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9263
 * DESC:     TX pipeline reset count
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_RESET_COUNT   period in clock cyclesCounter for amount of time to keep txp in reset after pll is lockedduring speed change process
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr (0x00109263 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_TX_RST_CNT.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_tx_rst_cnt[1];
	uint32_t _sc_x1_tx_rst_cnt;
} BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_CLR(r) (r).sc_x1_tx_rst_cnt[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_SET(r,d) (r).sc_x1_tx_rst_cnt[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_GET(r) (r).sc_x1_tx_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET(r) (((r).sc_x1_tx_rst_cnt[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET(r,f) (r).sc_x1_tx_rst_cnt[0]=(((r).sc_x1_tx_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_TX_RST_CNT.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_TX_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr
#define SC_X1_TX_RST_CNTr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_t SC_X1_TX_RST_CNTr_t;
#define SC_X1_TX_RST_CNTr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_CLR
#define SC_X1_TX_RST_CNTr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_SET
#define SC_X1_TX_RST_CNTr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET
#define READ_SC_X1_TX_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X1_TX_RST_CNTr
#define WRITE_SC_X1_TX_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X1_TX_RST_CNTr
#define MODIFY_SC_X1_TX_RST_CNTr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X1_TX_RST_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X1_TX_RST_CNTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X1_STS
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9264
 * DESC:     Status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESOLVED_PORT_MODE resolved port mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr (0x00109264 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_s {
	uint32_t v[1];
	uint32_t sc_x1_sts[1];
	uint32_t _sc_x1_sts;
} BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_CLR(r) (r).sc_x1_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_SET(r,d) (r).sc_x1_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_GET(r) (r).sc_x1_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_GET(r) (((r).sc_x1_sts[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_SET(r,f) (r).sc_x1_sts[0]=(((r).sc_x1_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X1_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr,(_r._sc_x1_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X1_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr,(_r._sc_x1_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X1_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr,(_r._sc_x1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_STSr BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr
#define SC_X1_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_t SC_X1_STSr_t;
#define SC_X1_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_CLR
#define SC_X1_STSr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_SET
#define SC_X1_STSr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_GET
#define SC_X1_STSr_RESOLVED_PORT_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_GET
#define SC_X1_STSr_RESOLVED_PORT_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_SET
#define READ_SC_X1_STSr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X1_STSr
#define WRITE_SC_X1_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X1_STSr
#define MODIFY_SC_X1_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X1_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_GLB_INT
 * BLOCKS:   AN_X1_SW_MGMT
 * REGADDR:  0x92c0
 * DESC:     SW AN Global Interrupt
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     INT_PORT0        Interrupt indication from port 0 - OR of the all 3 events from port 0 S/W AN
 *     INT_PORT1        Interrupt indication from port 1 - OR of the all 3 events from port 1 S/W AN
 *     INT_PORT2        Interrupt indication from port 2 - OR of the all 3 events from port 2 S/W AN
 *     INT_PORT3        Interrupt indication from port 3 - OR of the all 3 events from port 3 S/W AN
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr (0x001092c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_GLB_INT.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_s {
	uint32_t v[1];
	uint32_t an_x1_glb_int[1];
	uint32_t _an_x1_glb_int;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_CLR(r) (r).an_x1_glb_int[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_SET(r,d) (r).an_x1_glb_int[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_GET(r) (r).an_x1_glb_int[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT3f_GET(r) ((((r).an_x1_glb_int[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT3f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT2f_GET(r) ((((r).an_x1_glb_int[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT2f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT1f_GET(r) ((((r).an_x1_glb_int[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT1f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT0f_GET(r) (((r).an_x1_glb_int[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT0f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X1_GLB_INT.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_GLB_INTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr,(_r._an_x1_glb_int))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_GLB_INTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr,(_r._an_x1_glb_int)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_GLB_INTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr,(_r._an_x1_glb_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_GLB_INTr BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr
#define AN_X1_GLB_INTr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_t AN_X1_GLB_INTr_t;
#define AN_X1_GLB_INTr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_CLR
#define AN_X1_GLB_INTr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_SET
#define AN_X1_GLB_INTr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_GET
#define AN_X1_GLB_INTr_INT_PORT3f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT3f_GET
#define AN_X1_GLB_INTr_INT_PORT3f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT3f_SET
#define AN_X1_GLB_INTr_INT_PORT2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT2f_GET
#define AN_X1_GLB_INTr_INT_PORT2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT2f_SET
#define AN_X1_GLB_INTr_INT_PORT1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT1f_GET
#define AN_X1_GLB_INTr_INT_PORT1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT1f_SET
#define AN_X1_GLB_INTr_INT_PORT0f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT0f_GET
#define AN_X1_GLB_INTr_INT_PORT0f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr_INT_PORT0f_SET
#define READ_AN_X1_GLB_INTr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_GLB_INTr
#define WRITE_AN_X1_GLB_INTr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_GLB_INTr
#define MODIFY_AN_X1_GLB_INTr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_GLB_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_INTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X1_GLB_MASK
 * BLOCKS:   AN_X1_SW_MGMT
 * REGADDR:  0x92c1
 * DESC:     SW AN Per Port Global Interrupt Enable Mask
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     INT_PORT0_MASK   Write 1 to enable interrupt indication from port 0
 *     INT_PORT1_MASK   Write 1 to enable interrupt indication from port 1
 *     INT_PORT2_MASK   Write 1 to enable interrupt indication from port 2
 *     INT_PORT3_MASK   Write 1 to enable interrupt indication from port 3
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr (0x001092c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_GLB_MASK.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_s {
	uint32_t v[1];
	uint32_t an_x1_glb_mask[1];
	uint32_t _an_x1_glb_mask;
} BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_CLR(r) (r).an_x1_glb_mask[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_SET(r,d) (r).an_x1_glb_mask[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_GET(r) (r).an_x1_glb_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_GET(r) ((((r).an_x1_glb_mask[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_GET(r) ((((r).an_x1_glb_mask[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_GET(r) ((((r).an_x1_glb_mask[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_GET(r) (((r).an_x1_glb_mask[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X1_GLB_MASK.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_GLB_MASKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr,(_r._an_x1_glb_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_GLB_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr,(_r._an_x1_glb_mask)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_GLB_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr,(_r._an_x1_glb_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_GLB_MASKr BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr
#define AN_X1_GLB_MASKr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_t AN_X1_GLB_MASKr_t;
#define AN_X1_GLB_MASKr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_CLR
#define AN_X1_GLB_MASKr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_SET
#define AN_X1_GLB_MASKr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_GET
#define AN_X1_GLB_MASKr_INT_PORT3_MASKf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT3_MASKf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_SET
#define AN_X1_GLB_MASKr_INT_PORT2_MASKf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT2_MASKf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_SET
#define AN_X1_GLB_MASKr_INT_PORT1_MASKf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT1_MASKf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_SET
#define AN_X1_GLB_MASKr_INT_PORT0_MASKf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT0_MASKf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_SET
#define READ_AN_X1_GLB_MASKr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X1_GLB_MASKr
#define WRITE_AN_X1_GLB_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X1_GLB_MASKr
#define MODIFY_AN_X1_GLB_MASKr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X1_GLB_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X1_GLB_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_CTL
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc010
 * DESC:     PMD lane reset controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_DP_H_RSTB     PMD lane datapath reset override value
 *     LN_H_RSTB        Reset all lane logic: data path and registers
 *     LN_TX_H_PWRDN    Lane power down, TX direction
 *     LN_RX_H_PWRDN    Lane power down, RX direction
 *     TX_DISABLE       Set to squelch the transmit signal for laneUsed in Reduced Lane Mode Reconfiguration Process.
 *     OSR_MODE         OSR mode.
 *     PAM4_MODE        pam4_mode.  Bypassed when osr_mode_oen is asserted.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr (0x0000c010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ctl[1];
	uint32_t _pmd_x4_ctl;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_CLR(r) (r).pmd_x4_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_SET(r,d) (r).pmd_x4_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_GET(r) (r).pmd_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_PAM4_MODEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 13) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_PAM4_MODEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_OSR_MODEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 9) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_OSR_MODEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9)) | (15 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_H_RSTBf_GET(r) ((((r).pmd_x4_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_GET(r) (((r).pmd_x4_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr
#define PMD_X4_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_t PMD_X4_CTLr_t;
#define PMD_X4_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_CLR
#define PMD_X4_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_SET
#define PMD_X4_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_GET
#define PMD_X4_CTLr_PAM4_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_PAM4_MODEf_GET
#define PMD_X4_CTLr_PAM4_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_PAM4_MODEf_SET
#define PMD_X4_CTLr_OSR_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_OSR_MODEf_GET
#define PMD_X4_CTLr_OSR_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_OSR_MODEf_SET
#define PMD_X4_CTLr_TX_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET
#define PMD_X4_CTLr_TX_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_H_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_H_RSTBf_GET
#define PMD_X4_CTLr_LN_H_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_H_RSTBf_SET
#define PMD_X4_CTLr_LN_DP_H_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_GET
#define PMD_X4_CTLr_LN_DP_H_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_SET
#define READ_PMD_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_CTLr
#define WRITE_PMD_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_CTLr
#define MODIFY_PMD_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_CTLr
#define READLN_PMD_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_CTLr
#define WRITELN_PMD_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_CTLr
#define WRITEALL_PMD_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_MODE
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc011
 * DESC:     PMD lane mode configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_MODE        Lane modeBits 15:11 - Reserved.Bit  10    - cl72_en.Bit   9    - scrambler_disabled.Bit   8    - eee_mode_en.Bits  7:0  - speed_id.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr (0x0000c011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_MODE.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_s {
	uint32_t v[1];
	uint32_t pmd_x4_mode[1];
	uint32_t _pmd_x4_mode;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_CLR(r) (r).pmd_x4_mode[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_SET(r,d) (r).pmd_x4_mode[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_GET(r) (r).pmd_x4_mode[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_LANE_MODEf_GET(r) (((r).pmd_x4_mode[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_LANE_MODEf_SET(r,f) (r).pmd_x4_mode[0]=(((r).pmd_x4_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X4_MODE.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_MODEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_MODEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_MODEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_MODEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_MODEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_MODEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_mode))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_MODEr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr
#define PMD_X4_MODEr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_t PMD_X4_MODEr_t;
#define PMD_X4_MODEr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_CLR
#define PMD_X4_MODEr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_SET
#define PMD_X4_MODEr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_GET
#define PMD_X4_MODEr_LANE_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_LANE_MODEf_GET
#define PMD_X4_MODEr_LANE_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr_LANE_MODEf_SET
#define READ_PMD_X4_MODEr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_MODEr
#define WRITE_PMD_X4_MODEr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_MODEr
#define MODIFY_PMD_X4_MODEr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_MODEr
#define READLN_PMD_X4_MODEr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_MODEr
#define WRITELN_PMD_X4_MODEr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_MODEr
#define WRITEALL_PMD_X4_MODEr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_MODEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_MODEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc012
 * DESC:     PMD lane status
 * RESETVAL: 0x10 (16)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_LOCK_STS      DSC RX lock indication from PMD
 *     SIGNAL_DETECT_STS Signal Detect indication from PMD
 *     RX_CLK_VLD_STS   rx_clk_vld indication from PMD
 *     TX_CLK_VLD_STS   tx_clk_vld indication from PMD
 *     TX_DISABLE_LIVE  Live status of tx_disable driven by PCS Transmit logic, before override is applied
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr (0x0000c012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_sts[1];
	uint32_t _pmd_x4_sts;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_CLR(r) (r).pmd_x4_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SET(r,d) (r).pmd_x4_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_GET(r) (r).pmd_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_DISABLE_LIVEf_GET(r) ((((r).pmd_x4_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_DISABLE_LIVEf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET(r) (((r).pmd_x4_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_STSr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr
#define PMD_X4_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_t PMD_X4_STSr_t;
#define PMD_X4_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_CLR
#define PMD_X4_STSr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SET
#define PMD_X4_STSr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_GET
#define PMD_X4_STSr_TX_DISABLE_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_DISABLE_LIVEf_GET
#define PMD_X4_STSr_TX_DISABLE_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_DISABLE_LIVEf_SET
#define PMD_X4_STSr_TX_CLK_VLD_STSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_GET
#define PMD_X4_STSr_TX_CLK_VLD_STSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_SET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET
#define PMD_X4_STSr_RX_LOCK_STSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET
#define PMD_X4_STSr_RX_LOCK_STSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET
#define READ_PMD_X4_STSr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_STSr
#define WRITE_PMD_X4_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_STSr
#define MODIFY_PMD_X4_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_STSr
#define READLN_PMD_X4_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_STSr
#define WRITELN_PMD_X4_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_STSr
#define WRITEALL_PMD_X4_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_LATCH_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc013
 * DESC:     PMD lane latched status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOCK_LL       DSC RX lock indication from PMD negedge detected
 *     RX_LOCK_LH       DSC RX lock indication from PMD posedge detected
 *     SIGNAL_DETECT_LL Signal Detect indication from PMD negedge detected
 *     SIGNAL_DETECT_LH Signal Detect indication from PMD posedge detected
 *     RX_CLK_VLD_LL    rx_clk_vld indication from PMD negedge detected
 *     RX_CLK_VLD_LH    rx_clk_vld indication from PMD posedge detected
 *     RX_LOCK_LIVE     DSC RX lock live indication from PMDSame as the pmd_x4_status register field.
 *     SIGNAL_DETECT_LIVE Signal Detect live indication from PMDSame as the pmd_x4_status register field.
 *     RX_CLK_VLD_LIVE  rx_clk_vld live indication from PMDSame as the pmd_x4_status register field.
 *     TX_DISABLE_LL    Negedge detected on tx_disable driven by PCS Transmit logic, before override is applied, Clear on Read
 *     TX_DISABLE_LH    Posedge detected on tx_disable driven by PCS Transmit logic, before override is applied, Clear on Read
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr (0x0000c013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_LATCH_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_latch_sts[1];
	uint32_t _pmd_x4_latch_sts;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_CLR(r) (r).pmd_x4_latch_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SET(r,d) (r).pmd_x4_latch_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_GET(r) (r).pmd_x4_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET(r) (((r).pmd_x4_latch_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_LATCH_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr
#define PMD_X4_LATCH_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_t PMD_X4_LATCH_STSr_t;
#define PMD_X4_LATCH_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_CLR
#define PMD_X4_LATCH_STSr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SET
#define PMD_X4_LATCH_STSr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_GET
#define PMD_X4_LATCH_STSr_TX_DISABLE_LHf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LHf_GET
#define PMD_X4_LATCH_STSr_TX_DISABLE_LHf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LHf_SET
#define PMD_X4_LATCH_STSr_TX_DISABLE_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LLf_GET
#define PMD_X4_LATCH_STSr_TX_DISABLE_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_TX_DISABLE_LLf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET
#define READ_PMD_X4_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_LATCH_STSr
#define WRITE_PMD_X4_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_LATCH_STSr
#define MODIFY_PMD_X4_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_LATCH_STSr
#define READLN_PMD_X4_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_LATCH_STSr
#define WRITELN_PMD_X4_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_LATCH_STSr
#define WRITEALL_PMD_X4_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_OVRR
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc014
 * DESC:     PMD lane override
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOCK_OVRD     Override for DSC RX lock indication from PMD
 *     SIGNAL_DETECT_OVRD Override for Signal Detect indication from PMD
 *     RX_CLK_VLD_OVRD  Override rx_clk_vld indication from PMD
 *     LANE_MODE_OEN    Lane mode override enable
 *     OSR_MODE_OEN     PAM4 mode and OSR mode  override
 *     TX_DISABLE_OEN   tx_disable override enableUsed in Reduced Lane Mode Reconfiguration process.
 *     LN_DP_H_RSTB_OEN PMD Lane Datapath reset override enable
 *     TX_CLK_VLD_OVRD  Override tx_clk_vld indication from PMD
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr (0x0000c014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_OVRR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ovrr[1];
	uint32_t _pmd_x4_ovrr;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_CLR(r) (r).pmd_x4_ovrr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SET(r,d) (r).pmd_x4_ovrr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_GET(r) (r).pmd_x4_ovrr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET(r) (((r).pmd_x4_ovrr[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_OVRR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_OVRRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_OVRRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_OVRRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_OVRRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_OVRRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_OVRRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_OVRRr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr
#define PMD_X4_OVRRr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_t PMD_X4_OVRRr_t;
#define PMD_X4_OVRRr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_CLR
#define PMD_X4_OVRRr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SET
#define PMD_X4_OVRRr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_GET
#define PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET
#define PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET
#define PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET
#define PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET
#define PMD_X4_OVRRr_OSR_MODE_OENf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_GET
#define PMD_X4_OVRRr_OSR_MODE_OENf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_SET
#define PMD_X4_OVRRr_LANE_MODE_OENf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET
#define PMD_X4_OVRRr_LANE_MODE_OENf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET
#define READ_PMD_X4_OVRRr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_OVRRr
#define WRITE_PMD_X4_OVRRr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_OVRRr
#define MODIFY_PMD_X4_OVRRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_OVRRr
#define READLN_PMD_X4_OVRRr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_OVRRr
#define WRITELN_PMD_X4_OVRRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_OVRRr
#define WRITEALL_PMD_X4_OVRRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_OVRRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_UI_VALUE_HI
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc015
 * DESC:     PMD lane bit-time in fractional nanoseconds, upper.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UI_FRAC_M1_TO_M16 PMD lane bit-time in fractional nanoseconds, upper bitsMost significant 16 bits. 2^ minus1 down to 2^ minus16bit 15 is 0.5, bit 14 is 0.25 and so on.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr (0x0000c015 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_UI_VALUE_HI.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ui_value_hi[1];
	uint32_t _pmd_x4_ui_value_hi;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_CLR(r) (r).pmd_x4_ui_value_hi[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_SET(r,d) (r).pmd_x4_ui_value_hi[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_GET(r) (r).pmd_x4_ui_value_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_GET(r) (((r).pmd_x4_ui_value_hi[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_SET(r,f) (r).pmd_x4_ui_value_hi[0]=(((r).pmd_x4_ui_value_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X4_UI_VALUE_HI.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr,(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr,(_r._pmd_x4_ui_value_hi)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr,(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_UI_VALUE_HIr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_UI_VALUE_HIr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ui_value_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_UI_VALUE_HIr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr
#define PMD_X4_UI_VALUE_HIr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_t PMD_X4_UI_VALUE_HIr_t;
#define PMD_X4_UI_VALUE_HIr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_CLR
#define PMD_X4_UI_VALUE_HIr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_SET
#define PMD_X4_UI_VALUE_HIr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_GET
#define PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_GET
#define PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_SET
#define READ_PMD_X4_UI_VALUE_HIr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_UI_VALUE_HIr
#define WRITE_PMD_X4_UI_VALUE_HIr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_UI_VALUE_HIr
#define MODIFY_PMD_X4_UI_VALUE_HIr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_UI_VALUE_HIr
#define READLN_PMD_X4_UI_VALUE_HIr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_UI_VALUE_HIr
#define WRITELN_PMD_X4_UI_VALUE_HIr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_UI_VALUE_HIr
#define WRITEALL_PMD_X4_UI_VALUE_HIr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_UI_VALUE_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_HIr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_UI_VALUE_LO
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc016
 * DESC:     PMD lane bit-time in fractional nanoseconds, lower.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UI_FRAC_M17_TO_M23 PMD lane bit-time in fractional nanoseconds, lower bitsLeast significant 7 bits.bit 15 is 2^ minus17, bit 9 is 2^ minus23.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr (0x0000c016 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_UI_VALUE_LO.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ui_value_lo[1];
	uint32_t _pmd_x4_ui_value_lo;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_CLR(r) (r).pmd_x4_ui_value_lo[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_SET(r,d) (r).pmd_x4_ui_value_lo[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_GET(r) (r).pmd_x4_ui_value_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M23f_GET(r) ((((r).pmd_x4_ui_value_lo[0]) >> 9) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M23f_SET(r,f) (r).pmd_x4_ui_value_lo[0]=(((r).pmd_x4_ui_value_lo[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9)) | (127 << (16 + 9))

/*
 * These macros can be used to access PMD_X4_UI_VALUE_LO.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr,(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr,(_r._pmd_x4_ui_value_lo)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr,(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_UI_VALUE_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_UI_VALUE_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ui_value_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_UI_VALUE_LOr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr
#define PMD_X4_UI_VALUE_LOr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_t PMD_X4_UI_VALUE_LOr_t;
#define PMD_X4_UI_VALUE_LOr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_CLR
#define PMD_X4_UI_VALUE_LOr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_SET
#define PMD_X4_UI_VALUE_LOr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_GET
#define PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M23f_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M23f_GET
#define PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M23f_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M23f_SET
#define READ_PMD_X4_UI_VALUE_LOr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_UI_VALUE_LOr
#define WRITE_PMD_X4_UI_VALUE_LOr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_UI_VALUE_LOr
#define MODIFY_PMD_X4_UI_VALUE_LOr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_UI_VALUE_LOr
#define READLN_PMD_X4_UI_VALUE_LOr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_UI_VALUE_LOr
#define WRITELN_PMD_X4_UI_VALUE_LOr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_UI_VALUE_LOr
#define WRITEALL_PMD_X4_UI_VALUE_LOr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_UI_VALUE_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_UI_VALUE_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PMD_X4_TX_FIXED_LATENCY
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc018
 * DESC:     PMD TX fixed latency
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PMD_LATENCY_IN_FRAC_NS PMD TX fixed latency in fractional nanoseconds. Signed 2s complement value as an extension of tx_pmd_latency_in_ns.This parameter is per logical lane.
 *     TX_PMD_LATENCY_IN_NS PMD TX fixed latency in nanoseconds. Signed 2s complement value. HW will sign-extend to 48 bits.This parameter is per logical lane.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr (0x0000c018 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_TX_FIXED_LATENCY.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_s {
	uint32_t v[1];
	uint32_t pmd_x4_tx_fixed_latency[1];
	uint32_t _pmd_x4_tx_fixed_latency;
} BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_t;

#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_CLR(r) (r).pmd_x4_tx_fixed_latency[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_SET(r,d) (r).pmd_x4_tx_fixed_latency[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_GET(r) (r).pmd_x4_tx_fixed_latency[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_NSf_GET(r) ((((r).pmd_x4_tx_fixed_latency[0]) >> 10) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_NSf_SET(r,f) (r).pmd_x4_tx_fixed_latency[0]=(((r).pmd_x4_tx_fixed_latency[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_FRAC_NSf_GET(r) (((r).pmd_x4_tx_fixed_latency[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_FRAC_NSf_SET(r,f) (r).pmd_x4_tx_fixed_latency[0]=(((r).pmd_x4_tx_fixed_latency[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PMD_X4_TX_FIXED_LATENCY.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_TX_FIXED_LATENCYr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr,(_r._pmd_x4_tx_fixed_latency))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_TX_FIXED_LATENCYr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr,(_r._pmd_x4_tx_fixed_latency)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_TX_FIXED_LATENCYr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr,(_r._pmd_x4_tx_fixed_latency))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_TX_FIXED_LATENCYr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_tx_fixed_latency))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_TX_FIXED_LATENCYr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_tx_fixed_latency))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_TX_FIXED_LATENCYr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_tx_fixed_latency))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_TX_FIXED_LATENCYr BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr
#define PMD_X4_TX_FIXED_LATENCYr_SIZE BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_t PMD_X4_TX_FIXED_LATENCYr_t;
#define PMD_X4_TX_FIXED_LATENCYr_CLR BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_CLR
#define PMD_X4_TX_FIXED_LATENCYr_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_SET
#define PMD_X4_TX_FIXED_LATENCYr_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_GET
#define PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_NSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_NSf_GET
#define PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_NSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_NSf_SET
#define PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_FRAC_NSf_GET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_FRAC_NSf_GET
#define PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_FRAC_NSf_SET BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr_TX_PMD_LATENCY_IN_FRAC_NSf_SET
#define READ_PMD_X4_TX_FIXED_LATENCYr BCMI_TSCBH_FLEXE_XGXS_READ_PMD_X4_TX_FIXED_LATENCYr
#define WRITE_PMD_X4_TX_FIXED_LATENCYr BCMI_TSCBH_FLEXE_XGXS_WRITE_PMD_X4_TX_FIXED_LATENCYr
#define MODIFY_PMD_X4_TX_FIXED_LATENCYr BCMI_TSCBH_FLEXE_XGXS_MODIFY_PMD_X4_TX_FIXED_LATENCYr
#define READLN_PMD_X4_TX_FIXED_LATENCYr BCMI_TSCBH_FLEXE_XGXS_READLN_PMD_X4_TX_FIXED_LATENCYr
#define WRITELN_PMD_X4_TX_FIXED_LATENCYr BCMI_TSCBH_FLEXE_XGXS_WRITELN_PMD_X4_TX_FIXED_LATENCYr
#define WRITEALL_PMD_X4_TX_FIXED_LATENCYr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PMD_X4_TX_FIXED_LATENCYr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PMD_X4_TX_FIXED_LATENCYr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X4_CTL
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc050
 * DESC:     SW speed change control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_SPEED_ID      
 *     SW_SPEED_CHANGE  Start SW speed change.HW will detect possedge of this field and start or restart the speed change logic.To restart speed change logic SW must write 0 to this bit and then write 1.
 *     SC_IGNORE_TX_DATA_VLD Do not wait for tx_data_vld indication from PMD before taking TX pipe out of reset
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr (0x0000c050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_s {
	uint32_t v[1];
	uint32_t sc_x4_ctl[1];
	uint32_t _sc_x4_ctl;
} BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_CLR(r) (r).sc_x4_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SET(r,d) (r).sc_x4_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_GET(r) (r).sc_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SC_IGNORE_TX_DATA_VLDf_GET(r) ((((r).sc_x4_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SC_IGNORE_TX_DATA_VLDf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET(r) ((((r).sc_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_IDf_GET(r) (((r).sc_x4_ctl[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_IDf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X4_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr
#define SC_X4_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_t SC_X4_CTLr_t;
#define SC_X4_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_CLR
#define SC_X4_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SET
#define SC_X4_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_GET
#define SC_X4_CTLr_SC_IGNORE_TX_DATA_VLDf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SC_IGNORE_TX_DATA_VLDf_GET
#define SC_X4_CTLr_SC_IGNORE_TX_DATA_VLDf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SC_IGNORE_TX_DATA_VLDf_SET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET
#define SC_X4_CTLr_SW_SPEED_IDf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_IDf_GET
#define SC_X4_CTLr_SW_SPEED_IDf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr_SW_SPEED_IDf_SET
#define READ_SC_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_CTLr
#define WRITE_SC_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_CTLr
#define MODIFY_SC_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_CTLr
#define READLN_SC_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_CTLr
#define WRITELN_SC_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_CTLr
#define WRITEALL_SC_X4_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X4_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X4_STS
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc051
 * DESC:     SW speed change status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_SPEED_CHANGE_DONE Read clear bit indicating that SW initiated speed change completed
 *     SW_SPEED_CONFIG_VLD Read clear bit indicating that resolved speed configuration in stutus registers can be read
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr (0x0000c051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_s {
	uint32_t v[1];
	uint32_t sc_x4_sts[1];
	uint32_t _sc_x4_sts;
} BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_CLR(r) (r).sc_x4_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SET(r,d) (r).sc_x4_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_GET(r) (r).sc_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET(r) ((((r).sc_x4_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET(r) (((r).sc_x4_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr,(_r._sc_x4_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_STSr BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr
#define SC_X4_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_t SC_X4_STSr_t;
#define SC_X4_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_CLR
#define SC_X4_STSr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SET
#define SC_X4_STSr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET
#define READ_SC_X4_STSr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_STSr
#define WRITE_SC_X4_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_STSr
#define MODIFY_SC_X4_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_STSr
#define READLN_SC_X4_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_STSr
#define WRITELN_SC_X4_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_STSr
#define WRITEALL_SC_X4_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X4_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X4_DBG
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc054
 * DESC:     Speed control debug information
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     SC_FSM_STATUS    Speed Control logic FSM debug information16'h8000 - START16'h4000 - RESET_PCS16'h2000 - RESET_PMD_LANE16'h1000 - undefined16'h0800 - APPLY_SPEED_CFG16'h0400 - WAIT_CFG_DONE16'h0200 - ACTIVATE_PMD16'h0100 - WAIT_TX_DATA_VLD16'h0080 - undefined16'h0040 - ACTIVATE_TX16'h0020 - WAIT_PMD_LOCK16'h0010 - ACTIVATE_RX16'h0008 - undefined16'h0004 - DONE16'h0002 - STOP16'h0001 - undefined
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr (0x0000c054 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_DBG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_s {
	uint32_t v[1];
	uint32_t sc_x4_dbg[1];
	uint32_t _sc_x4_dbg;
} BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_CLR(r) (r).sc_x4_dbg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SET(r,d) (r).sc_x4_dbg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_GET(r) (r).sc_x4_dbg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET(r) (((r).sc_x4_dbg[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET(r,f) (r).sc_x4_dbg[0]=(((r).sc_x4_dbg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X4_DBG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_DBGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_DBGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_DBGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_DBGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_DBGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_DBGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_dbg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_DBGr BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr
#define SC_X4_DBGr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_t SC_X4_DBGr_t;
#define SC_X4_DBGr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_CLR
#define SC_X4_DBGr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SET
#define SC_X4_DBGr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET
#define READ_SC_X4_DBGr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_DBGr
#define WRITE_SC_X4_DBGr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_DBGr
#define MODIFY_SC_X4_DBGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_DBGr
#define READLN_SC_X4_DBGr BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_DBGr
#define WRITELN_SC_X4_DBGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_DBGr
#define WRITEALL_SC_X4_DBGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_DBGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X4_DBGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X4_SPARE0
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc05d
 * DESC:     spare 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPARE0           Spare register
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r (0x0000c05d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_SPARE0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_s {
	uint32_t v[1];
	uint32_t sc_x4_spare0[1];
	uint32_t _sc_x4_spare0;
} BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_CLR(r) (r).sc_x4_spare0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SET(r,d) (r).sc_x4_spare0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_GET(r) (r).sc_x4_spare0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SPARE0f_GET(r) (((r).sc_x4_spare0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SPARE0f_SET(r,f) (r).sc_x4_spare0[0]=(((r).sc_x4_spare0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X4_SPARE0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_SPARE0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r,(_r._sc_x4_spare0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_SPARE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r,(_r._sc_x4_spare0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_SPARE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r,(_r._sc_x4_spare0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_SPARE0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_spare0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_SPARE0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_spare0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_SPARE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_spare0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_SPARE0r BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r
#define SC_X4_SPARE0r_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_t SC_X4_SPARE0r_t;
#define SC_X4_SPARE0r_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_CLR
#define SC_X4_SPARE0r_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SET
#define SC_X4_SPARE0r_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_GET
#define SC_X4_SPARE0r_SPARE0f_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SPARE0f_GET
#define SC_X4_SPARE0r_SPARE0f_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r_SPARE0f_SET
#define READ_SC_X4_SPARE0r BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_SPARE0r
#define WRITE_SC_X4_SPARE0r BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_SPARE0r
#define MODIFY_SC_X4_SPARE0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_SPARE0r
#define READLN_SC_X4_SPARE0r BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_SPARE0r
#define WRITELN_SC_X4_SPARE0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_SPARE0r
#define WRITEALL_SC_X4_SPARE0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_SPARE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X4_SPARE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X4_SW_SPARE1
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc05e
 * DESC:     Spare register for SW to use
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPARE1           Spare register for SW.spare 1 register.spare 1 register
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r (0x0000c05e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_SW_SPARE1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_s {
	uint32_t v[1];
	uint32_t sc_x4_sw_spare1[1];
	uint32_t _sc_x4_sw_spare1;
} BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_CLR(r) (r).sc_x4_sw_spare1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SET(r,d) (r).sc_x4_sw_spare1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_GET(r) (r).sc_x4_sw_spare1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SPARE1f_GET(r) (((r).sc_x4_sw_spare1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SPARE1f_SET(r,f) (r).sc_x4_sw_spare1[0]=(((r).sc_x4_sw_spare1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X4_SW_SPARE1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_SW_SPARE1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r,(_r._sc_x4_sw_spare1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_SW_SPARE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r,(_r._sc_x4_sw_spare1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_SW_SPARE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r,(_r._sc_x4_sw_spare1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_SW_SPARE1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sw_spare1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_SW_SPARE1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sw_spare1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_SW_SPARE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_sw_spare1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_SW_SPARE1r BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r
#define SC_X4_SW_SPARE1r_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_t SC_X4_SW_SPARE1r_t;
#define SC_X4_SW_SPARE1r_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_CLR
#define SC_X4_SW_SPARE1r_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SET
#define SC_X4_SW_SPARE1r_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_GET
#define SC_X4_SW_SPARE1r_SPARE1f_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SPARE1f_GET
#define SC_X4_SW_SPARE1r_SPARE1f_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r_SPARE1f_SET
#define READ_SC_X4_SW_SPARE1r BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_SW_SPARE1r
#define WRITE_SC_X4_SW_SPARE1r BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_SW_SPARE1r
#define MODIFY_SC_X4_SW_SPARE1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_SW_SPARE1r
#define READLN_SC_X4_SW_SPARE1r BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_SW_SPARE1r
#define WRITELN_SC_X4_SW_SPARE1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_SW_SPARE1r
#define WRITEALL_SC_X4_SW_SPARE1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_SW_SPARE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X4_SW_SPARE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X4_RSLVD_SPD
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc070
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SPEED            Actual speed set by SW
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr (0x0000c070 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD_SPD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd_spd[1];
	uint32_t _sc_x4_rslvd_spd;
} BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_CLR(r) (r).sc_x4_rslvd_spd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SET(r,d) (r).sc_x4_rslvd_spd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_GET(r) (r).sc_x4_rslvd_spd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_GET(r) ((((r).sc_x4_rslvd_spd[0]) >> 10) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))

/*
 * These macros can be used to access SC_X4_RSLVD_SPD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_RSLVD_SPDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd_spd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_RSLVD_SPDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd_spd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD_SPDr BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr
#define SC_X4_RSLVD_SPDr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_t SC_X4_RSLVD_SPDr_t;
#define SC_X4_RSLVD_SPDr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_CLR
#define SC_X4_RSLVD_SPDr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SET
#define SC_X4_RSLVD_SPDr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_GET
#define SC_X4_RSLVD_SPDr_SPEEDf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_GET
#define SC_X4_RSLVD_SPDr_SPEEDf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_SET
#define READ_SC_X4_RSLVD_SPDr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_RSLVD_SPDr
#define WRITE_SC_X4_RSLVD_SPDr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_RSLVD_SPDr
#define MODIFY_SC_X4_RSLVD_SPDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_RSLVD_SPDr
#define READLN_SC_X4_RSLVD_SPDr BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_RSLVD_SPDr
#define WRITELN_SC_X4_RSLVD_SPDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_RSLVD_SPDr
#define WRITEALL_SC_X4_RSLVD_SPDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_RSLVD_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X4_RSLVD_SPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SC_X4_FEC_STS
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc078
 * DESC:     Final speed configuration for FEC
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     R_FEC_ENABLE     Receive CL74 FEC enable status
 *     T_FEC_ENABLE     Transmit CL74 FEC enable status
 *     R_RS_FEC_FEC_MODE 
 *     T_RS_FEC_FEC_MODE 
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr (0x0000c078 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FEC_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_s {
	uint32_t v[1];
	uint32_t sc_x4_fec_sts[1];
	uint32_t _sc_x4_fec_sts;
} BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_CLR(r) (r).sc_x4_fec_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_SET(r,d) (r).sc_x4_fec_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_GET(r) (r).sc_x4_fec_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_RS_FEC_FEC_MODEf_GET(r) ((((r).sc_x4_fec_sts[0]) >> 5) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_RS_FEC_FEC_MODEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_RS_FEC_FEC_MODEf_GET(r) ((((r).sc_x4_fec_sts[0]) >> 2) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_RS_FEC_FEC_MODEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_GET(r) ((((r).sc_x4_fec_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_GET(r) (((r).sc_x4_fec_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_FEC_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_FEC_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr,(_r._sc_x4_fec_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_FEC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr,(_r._sc_x4_fec_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_FEC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr,(_r._sc_x4_fec_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_FEC_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fec_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_FEC_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fec_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_FEC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fec_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FEC_STSr BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr
#define SC_X4_FEC_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_t SC_X4_FEC_STSr_t;
#define SC_X4_FEC_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_CLR
#define SC_X4_FEC_STSr_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_SET
#define SC_X4_FEC_STSr_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_GET
#define SC_X4_FEC_STSr_T_RS_FEC_FEC_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_RS_FEC_FEC_MODEf_GET
#define SC_X4_FEC_STSr_T_RS_FEC_FEC_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_RS_FEC_FEC_MODEf_SET
#define SC_X4_FEC_STSr_R_RS_FEC_FEC_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_RS_FEC_FEC_MODEf_GET
#define SC_X4_FEC_STSr_R_RS_FEC_FEC_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_RS_FEC_FEC_MODEf_SET
#define SC_X4_FEC_STSr_T_FEC_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_GET
#define SC_X4_FEC_STSr_T_FEC_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_SET
#define SC_X4_FEC_STSr_R_FEC_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_GET
#define SC_X4_FEC_STSr_R_FEC_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_SET
#define READ_SC_X4_FEC_STSr BCMI_TSCBH_FLEXE_XGXS_READ_SC_X4_FEC_STSr
#define WRITE_SC_X4_FEC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_SC_X4_FEC_STSr
#define MODIFY_SC_X4_FEC_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_SC_X4_FEC_STSr
#define READLN_SC_X4_FEC_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_SC_X4_FEC_STSr
#define WRITELN_SC_X4_FEC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_SC_X4_FEC_STSr
#define WRITEALL_SC_X4_FEC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SC_X4_FEC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SC_X4_FEC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X4_RS_SYM
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc110
 * DESC:     Symbol Value register
 * RESETVAL: 0x2aa (682)
 * ACCESS:   R/W
 * FIELDS:
 *     SYMBOL_VALUE     contains the spare RS symbol used in certain RS FEC modes
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr (0x0000c110 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_RS_SYM.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_s {
	uint32_t v[1];
	uint32_t tx_x4_rs_sym[1];
	uint32_t _tx_x4_rs_sym;
} BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_CLR(r) (r).tx_x4_rs_sym[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SET(r,d) (r).tx_x4_rs_sym[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_GET(r) (r).tx_x4_rs_sym[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SYMBOL_VALUEf_GET(r) (((r).tx_x4_rs_sym[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SYMBOL_VALUEf_SET(r,f) (r).tx_x4_rs_sym[0]=(((r).tx_x4_rs_sym[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TX_X4_RS_SYM.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr,(_r._tx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr,(_r._tx_x4_rs_sym)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr,(_r._tx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_RS_SYMr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_RS_SYMr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_rs_sym))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr
#define TX_X4_RS_SYMr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_t TX_X4_RS_SYMr_t;
#define TX_X4_RS_SYMr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_CLR
#define TX_X4_RS_SYMr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SET
#define TX_X4_RS_SYMr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_GET
#define TX_X4_RS_SYMr_SYMBOL_VALUEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SYMBOL_VALUEf_GET
#define TX_X4_RS_SYMr_SYMBOL_VALUEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr_SYMBOL_VALUEf_SET
#define READ_TX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_RS_SYMr
#define WRITE_TX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_RS_SYMr
#define MODIFY_TX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_RS_SYMr
#define READLN_TX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_RS_SYMr
#define WRITELN_TX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_RS_SYMr
#define WRITEALL_TX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_RS_SYMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X4_RS_SYMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X4_MISC
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc111
 * DESC:     Misc register
 * RESETVAL: 0x1c (28)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_TX_LANE   Per lane enable to allow DVs from MAC to enter TXP
 *     RSTB_TX_LANE     Low active reset for txp lanes
 *     TX_LI_ENABLE     If this bit is a one, LIs (Link Interrupt) are passed thru to the RS LAYER.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the RS LAYER.
 *     TX_LF_ENABLE     If this bit is a one, LFs are passed from the RS LAYER to the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the PCS.
 *     TX_RF_ENABLE     If this bit is a one, RFs are passed from the RS LAYER to the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the PCS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr (0x0000c111 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_MISC.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_s {
	uint32_t v[1];
	uint32_t tx_x4_misc[1];
	uint32_t _tx_x4_misc;
} BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_CLR(r) (r).tx_x4_misc[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_SET(r,d) (r).tx_x4_misc[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_GET(r) (r).tx_x4_misc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_RF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_RF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LI_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LI_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET(r) ((((r).tx_x4_misc[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET(r) (((r).tx_x4_misc[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_MISC.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_MISCr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_MISCr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr,(_r._tx_x4_misc)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_MISCr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_MISCr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_misc))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_MISCr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_misc))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_MISCr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_misc))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_MISCr BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr
#define TX_X4_MISCr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_t TX_X4_MISCr_t;
#define TX_X4_MISCr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_CLR
#define TX_X4_MISCr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_SET
#define TX_X4_MISCr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_GET
#define TX_X4_MISCr_TX_RF_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_RF_ENABLEf_GET
#define TX_X4_MISCr_TX_RF_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_RF_ENABLEf_SET
#define TX_X4_MISCr_TX_LF_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LF_ENABLEf_GET
#define TX_X4_MISCr_TX_LF_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LF_ENABLEf_SET
#define TX_X4_MISCr_TX_LI_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LI_ENABLEf_GET
#define TX_X4_MISCr_TX_LI_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_TX_LI_ENABLEf_SET
#define TX_X4_MISCr_RSTB_TX_LANEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET
#define TX_X4_MISCr_RSTB_TX_LANEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET
#define TX_X4_MISCr_ENABLE_TX_LANEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET
#define TX_X4_MISCr_ENABLE_TX_LANEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET
#define READ_TX_X4_MISCr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_MISCr
#define WRITE_TX_X4_MISCr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_MISCr
#define MODIFY_TX_X4_MISCr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_MISCr
#define READLN_TX_X4_MISCr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_MISCr
#define WRITELN_TX_X4_MISCr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_MISCr
#define WRITEALL_TX_X4_MISCr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X4_MISCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X4_TX_TS_CTL
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc112
 * DESC:     TX TimeStamping Control register
 * RESETVAL: 0x3a (58)
 * ACCESS:   R/W
 * FIELDS:
 *     OSTS_PIPELINE_ENABLE Enables the 1588 One Step Processing Pipeline for this port.
 *     TX_SFD_TS_EN     RESERVED: No longer used. Keeping it as spare-bit for future use.
 *     TSTS_INTERRUPT_EN 1588 Two Step Time Stamping Interrupt enable.A value of one (1'b1) enables the interrupt.A value of zero (1'b0) clears the interrupt.
 *     TX_SOP_BYTE_OFFSET This field contains the offset in bytes from the SOP of the PREAMBLE up to and including the time-stamping point.0: indicates the time-stamping point is 0 bytes from the SOP. This is SOP time-stamping.3: indicates the time-stamping point is 3 bytes after the SOP. This is SFD time-stamping with reduced preamble mode.7: indicates the time-stamping point is 7 bytes after the SOP. This is SFD time-stamping with normal preamble mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr (0x0000c112 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_TS_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_ts_ctl[1];
	uint32_t _tx_x4_tx_ts_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_CLR(r) (r).tx_x4_tx_ts_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_SET(r,d) (r).tx_x4_tx_ts_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_GET(r) (r).tx_x4_tx_ts_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SOP_BYTE_OFFSETf_GET(r) ((((r).tx_x4_tx_ts_ctl[0]) >> 3) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SOP_BYTE_OFFSETf_SET(r,f) (r).tx_x4_tx_ts_ctl[0]=(((r).tx_x4_tx_ts_ctl[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TSTS_INTERRUPT_ENf_GET(r) ((((r).tx_x4_tx_ts_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TSTS_INTERRUPT_ENf_SET(r,f) (r).tx_x4_tx_ts_ctl[0]=(((r).tx_x4_tx_ts_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SFD_TS_ENf_GET(r) ((((r).tx_x4_tx_ts_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SFD_TS_ENf_SET(r,f) (r).tx_x4_tx_ts_ctl[0]=(((r).tx_x4_tx_ts_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_OSTS_PIPELINE_ENABLEf_GET(r) (((r).tx_x4_tx_ts_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_OSTS_PIPELINE_ENABLEf_SET(r,f) (r).tx_x4_tx_ts_ctl[0]=(((r).tx_x4_tx_ts_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_TX_TS_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_TX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr,(_r._tx_x4_tx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_TX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr,(_r._tx_x4_tx_ts_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_TX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr,(_r._tx_x4_tx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_TX_TS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_TX_TS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_TX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_ts_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr
#define TX_X4_TX_TS_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_t TX_X4_TX_TS_CTLr_t;
#define TX_X4_TX_TS_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_CLR
#define TX_X4_TX_TS_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_SET
#define TX_X4_TX_TS_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_GET
#define TX_X4_TX_TS_CTLr_TX_SOP_BYTE_OFFSETf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SOP_BYTE_OFFSETf_GET
#define TX_X4_TX_TS_CTLr_TX_SOP_BYTE_OFFSETf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SOP_BYTE_OFFSETf_SET
#define TX_X4_TX_TS_CTLr_TSTS_INTERRUPT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TSTS_INTERRUPT_ENf_GET
#define TX_X4_TX_TS_CTLr_TSTS_INTERRUPT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TSTS_INTERRUPT_ENf_SET
#define TX_X4_TX_TS_CTLr_TX_SFD_TS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SFD_TS_ENf_GET
#define TX_X4_TX_TS_CTLr_TX_SFD_TS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_TX_SFD_TS_ENf_SET
#define TX_X4_TX_TS_CTLr_OSTS_PIPELINE_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_OSTS_PIPELINE_ENABLEf_GET
#define TX_X4_TX_TS_CTLr_OSTS_PIPELINE_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr_OSTS_PIPELINE_ENABLEf_SET
#define READ_TX_X4_TX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_TX_TS_CTLr
#define WRITE_TX_X4_TX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_TX_TS_CTLr
#define MODIFY_TX_X4_TX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_TX_TS_CTLr
#define READLN_TX_X4_TX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_TX_TS_CTLr
#define WRITELN_TX_X4_TX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_TX_TS_CTLr
#define WRITEALL_TX_X4_TX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_TX_TS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_TS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X4_ERR_CTL
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc113
 * DESC:     TX Error injection Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PCS_LANE_ERROR_INJECT One bit per PCS lane to cause a single error to be injected.A rising edge on each bits results in an error injection on the next DV for that lane.The error is controlled by the following per MPP registers.{PktGen1_ErrorMask4[1:0] ,PktGen1_ErrorMask3,PktGen1_ErrorMask2,PktGen1_ErrorMask1,PktGen1_ErrorMask0						Error mask bits 15:0}The same mask is applied to all lanes that are enabled for a single error injectionNOTE:All of the bits (3:0) can all apply for Port 0.Only bit 1 can apply for Port 1Only bits 2:3 can all apply for Port 2Only bit 3 can apply for Port 3.
 *     RS_FEC_LANE_ERROR_INJECT One bit per 80 bit lane of RS FEC output to cause a single error to be injected.In 1XN mode, only bits 7:4 apply.In 2XN mode, bits 11:4 apply.The error is controlled by the following per MPP registers.{PktGen1_ErrorMask4,PktGen1_ErrorMask3,PktGen1_ErrorMask2,PktGen1_ErrorMask1,PktGen1_ErrorMask0						Error mask bits 15:0}The same mask is applied to all lanes that are enabled for a single error injection
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr (0x0000c113 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ERR_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_s {
	uint32_t v[1];
	uint32_t tx_x4_err_ctl[1];
	uint32_t _tx_x4_err_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_CLR(r) (r).tx_x4_err_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_SET(r,d) (r).tx_x4_err_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_GET(r) (r).tx_x4_err_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_RS_FEC_LANE_ERROR_INJECTf_GET(r) ((((r).tx_x4_err_ctl[0]) >> 4) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_RS_FEC_LANE_ERROR_INJECTf_SET(r,f) (r).tx_x4_err_ctl[0]=(((r).tx_x4_err_ctl[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_PCS_LANE_ERROR_INJECTf_GET(r) (((r).tx_x4_err_ctl[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_PCS_LANE_ERROR_INJECTf_SET(r,f) (r).tx_x4_err_ctl[0]=(((r).tx_x4_err_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_X4_ERR_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_ERR_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr,(_r._tx_x4_err_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_ERR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr,(_r._tx_x4_err_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_ERR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr,(_r._tx_x4_err_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_ERR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_err_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_ERR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_err_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_ERR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_err_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ERR_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr
#define TX_X4_ERR_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_t TX_X4_ERR_CTLr_t;
#define TX_X4_ERR_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_CLR
#define TX_X4_ERR_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_SET
#define TX_X4_ERR_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_GET
#define TX_X4_ERR_CTLr_RS_FEC_LANE_ERROR_INJECTf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_RS_FEC_LANE_ERROR_INJECTf_GET
#define TX_X4_ERR_CTLr_RS_FEC_LANE_ERROR_INJECTf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_RS_FEC_LANE_ERROR_INJECTf_SET
#define TX_X4_ERR_CTLr_PCS_LANE_ERROR_INJECTf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_PCS_LANE_ERROR_INJECTf_GET
#define TX_X4_ERR_CTLr_PCS_LANE_ERROR_INJECTf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr_PCS_LANE_ERROR_INJECTf_SET
#define READ_TX_X4_ERR_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_ERR_CTLr
#define WRITE_TX_X4_ERR_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_ERR_CTLr
#define MODIFY_TX_X4_ERR_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_ERR_CTLr
#define READLN_TX_X4_ERR_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_ERR_CTLr
#define WRITELN_TX_X4_ERR_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_ERR_CTLr
#define WRITEALL_TX_X4_ERR_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_ERR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X4_ERR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X4_ENC_STS1
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc121
 * DESC:     Encode Status 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_LTXSM_STATE Transmit SM - latched states - latched on entry
 *     CL49_TX_FAULT_DET A latched status bit indicating that the cl49 encoder has a local or remote fault block.
 *     LTXSM_STATE      CL82 Transmit SM - latched states - latched on entry
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r (0x0000c121 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENC_STS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_s {
	uint32_t v[1];
	uint32_t tx_x4_enc_sts1[1];
	uint32_t _tx_x4_enc_sts1;
} BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CLR(r) (r).tx_x4_enc_sts1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_SET(r,d) (r).tx_x4_enc_sts1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_GET(r) (r).tx_x4_enc_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_LTXSM_STATEf_GET(r) ((((r).tx_x4_enc_sts1[0]) >> 7) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_LTXSM_STATEf_SET(r,f) (r).tx_x4_enc_sts1[0]=(((r).tx_x4_enc_sts1[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_GET(r) ((((r).tx_x4_enc_sts1[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_SET(r,f) (r).tx_x4_enc_sts1[0]=(((r).tx_x4_enc_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_GET(r) (((r).tx_x4_enc_sts1[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_SET(r,f) (r).tx_x4_enc_sts1[0]=(((r).tx_x4_enc_sts1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_X4_ENC_STS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_ENC_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r,(_r._tx_x4_enc_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_ENC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r,(_r._tx_x4_enc_sts1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_ENC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r,(_r._tx_x4_enc_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_ENC_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_ENC_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_ENC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_enc_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENC_STS1r BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r
#define TX_X4_ENC_STS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_t TX_X4_ENC_STS1r_t;
#define TX_X4_ENC_STS1r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CLR
#define TX_X4_ENC_STS1r_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_SET
#define TX_X4_ENC_STS1r_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_GET
#define TX_X4_ENC_STS1r_LTXSM_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_LTXSM_STATEf_GET
#define TX_X4_ENC_STS1r_LTXSM_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_LTXSM_STATEf_SET
#define TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_GET
#define TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_SET
#define TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_GET
#define TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_SET
#define READ_TX_X4_ENC_STS1r BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_ENC_STS1r
#define WRITE_TX_X4_ENC_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_ENC_STS1r
#define MODIFY_TX_X4_ENC_STS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_ENC_STS1r
#define READLN_TX_X4_ENC_STS1r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_ENC_STS1r
#define WRITELN_TX_X4_ENC_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_ENC_STS1r
#define WRITEALL_TX_X4_ENC_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_ENC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X4_ENC_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X4_PCS_STS_LATCH
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc123
 * DESC:     Latched Status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LPI_RECEIVED_LH  PER PORT: Low Power Indicator (LPI) has transitioned high since last read.Clear on read
 *     REMOTE_FAULT_LH  PER PORT: Remote Fault (RF)  has transitioned high since last read.Clear on read
 *     LOCAL_FAULT_LH   PER PORT: Local Fault (LF) indicator has transitioned high since last read.Clear on read
 *     LINK_INTERRUPT_LH PER PORT: LI (LINK INTERRUPT) indicator has transitioned high since last read.Clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr (0x0000c123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_STS_LATCH.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_sts_latch[1];
	uint32_t _tx_x4_pcs_sts_latch;
} BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_CLR(r) (r).tx_x4_pcs_sts_latch[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_SET(r,d) (r).tx_x4_pcs_sts_latch[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_GET(r) (r).tx_x4_pcs_sts_latch[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_GET(r) ((((r).tx_x4_pcs_sts_latch[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_sts_latch[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_sts_latch[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_GET(r) (((r).tx_x4_pcs_sts_latch[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_PCS_STS_LATCH.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr,(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr,(_r._tx_x4_pcs_sts_latch)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr,(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_PCS_STS_LATCHr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_PCS_STS_LATCHr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_pcs_sts_latch))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_STS_LATCHr BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr
#define TX_X4_PCS_STS_LATCHr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_t TX_X4_PCS_STS_LATCHr_t;
#define TX_X4_PCS_STS_LATCHr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_CLR
#define TX_X4_PCS_STS_LATCHr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_SET
#define TX_X4_PCS_STS_LATCHr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_GET
#define TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_GET
#define TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_SET
#define TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_GET
#define TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_SET
#define TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_GET
#define TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_SET
#define TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_GET
#define TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_SET
#define READ_TX_X4_PCS_STS_LATCHr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_PCS_STS_LATCHr
#define WRITE_TX_X4_PCS_STS_LATCHr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_PCS_STS_LATCHr
#define MODIFY_TX_X4_PCS_STS_LATCHr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_PCS_STS_LATCHr
#define READLN_TX_X4_PCS_STS_LATCHr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_PCS_STS_LATCHr
#define WRITELN_TX_X4_PCS_STS_LATCHr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_PCS_STS_LATCHr
#define WRITEALL_TX_X4_PCS_STS_LATCHr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_PCS_STS_LATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X4_PCS_STS_LATCHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_X4_TX_1588_TIMESTAMP_STS
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc124
 * DESC:     Transmit 1588 Timestamp Status Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TSTS_INTERRUPT_STATUS Two Step Time Stamping interrupt statusWhen set, indicates the four entry two step FIFO is not empty.
 *     TS_ENTRY_VALID   valid two-step timestamp entry availablilty indicator
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr (0x0000c124 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_1588_TIMESTAMP_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_1588_timestamp_sts[1];
	uint32_t _tx_x4_tx_1588_timestamp_sts;
} BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_CLR(r) (r).tx_x4_tx_1588_timestamp_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SET(r,d) (r).tx_x4_tx_1588_timestamp_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_GET(r) (r).tx_x4_tx_1588_timestamp_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_GET(r) ((((r).tx_x4_tx_1588_timestamp_sts[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_SET(r,f) (r).tx_x4_tx_1588_timestamp_sts[0]=(((r).tx_x4_tx_1588_timestamp_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TSTS_INTERRUPT_STATUSf_GET(r) ((((r).tx_x4_tx_1588_timestamp_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TSTS_INTERRUPT_STATUSf_SET(r,f) (r).tx_x4_tx_1588_timestamp_sts[0]=(((r).tx_x4_tx_1588_timestamp_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access TX_X4_TX_1588_TIMESTAMP_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr,(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr,(_r._tx_x4_tx_1588_timestamp_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr,(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_1588_timestamp_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr
#define TX_X4_TX_1588_TIMESTAMP_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_t TX_X4_TX_1588_TIMESTAMP_STSr_t;
#define TX_X4_TX_1588_TIMESTAMP_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_CLR
#define TX_X4_TX_1588_TIMESTAMP_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SET
#define TX_X4_TX_1588_TIMESTAMP_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_GET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_GET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_SET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TSTS_INTERRUPT_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TSTS_INTERRUPT_STATUSf_GET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TSTS_INTERRUPT_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TSTS_INTERRUPT_STATUSf_SET
#define READ_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_STSr
#define WRITE_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_STSr
#define MODIFY_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_STSr
#define READLN_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_STSr
#define WRITELN_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_STSr
#define WRITEALL_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_TMR
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc130
 * DESC:     RS_FEC packet corruption duration timer period register
 * RESETVAL: 0xfa0 (4000)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPTION_PERIOD Increments in units of 15us ticks.The period should be programmed to between 60-75ms as per IEEE.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr (0x0000c130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_TMR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_tmr[1];
	uint32_t _rx_x4_rs_fec_tmr;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_CLR(r) (r).rx_x4_rs_fec_tmr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_SET(r,d) (r).rx_x4_rs_fec_tmr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_GET(r) (r).rx_x4_rs_fec_tmr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_CORRUPTION_PERIODf_GET(r) (((r).rx_x4_rs_fec_tmr[0]) & 0x1fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_CORRUPTION_PERIODf_SET(r,f) (r).rx_x4_rs_fec_tmr[0]=(((r).rx_x4_rs_fec_tmr[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_TMR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_TMRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr,(_r._rx_x4_rs_fec_tmr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_TMRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr,(_r._rx_x4_rs_fec_tmr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_TMRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr,(_r._rx_x4_rs_fec_tmr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_TMRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_tmr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_TMRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_tmr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_TMRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_TMRr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr
#define RX_X4_RS_FEC_TMRr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_t RX_X4_RS_FEC_TMRr_t;
#define RX_X4_RS_FEC_TMRr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_CLR
#define RX_X4_RS_FEC_TMRr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_SET
#define RX_X4_RS_FEC_TMRr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_GET
#define RX_X4_RS_FEC_TMRr_CORRUPTION_PERIODf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_CORRUPTION_PERIODf_GET
#define RX_X4_RS_FEC_TMRr_CORRUPTION_PERIODf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr_CORRUPTION_PERIODf_SET
#define READ_RX_X4_RS_FEC_TMRr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_TMRr
#define WRITE_RX_X4_RS_FEC_TMRr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_TMRr
#define MODIFY_RX_X4_RS_FEC_TMRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_TMRr
#define READLN_RX_X4_RS_FEC_TMRr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_TMRr
#define WRITELN_RX_X4_RS_FEC_TMRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_TMRr
#define WRITEALL_RX_X4_RS_FEC_TMRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_TMRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_RX_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc131
 * DESC:     RS_FEC control register
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     CW_BAD_ENABLE    This bit enables the RS FEC to indicate CW_bad, if the CW is not corrected.In Detect only mode, CWs are never corrected, so all CWs with errors will have CW_bad asserted, if CW_BAD_ENABLE == 1.In Detect and Correct mode, only CWs that can not be corrected by the FEC will have CW_bad asserted if CW_BAD_ENABLE == 1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r (0x0000c131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_RX_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_rx_ctl0[1];
	uint32_t _rx_x4_rs_fec_rx_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_CLR(r) (r).rx_x4_rs_fec_rx_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_SET(r,d) (r).rx_x4_rs_fec_rx_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_GET(r) (r).rx_x4_rs_fec_rx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_CW_BAD_ENABLEf_GET(r) ((((r).rx_x4_rs_fec_rx_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_CW_BAD_ENABLEf_SET(r,f) (r).rx_x4_rs_fec_rx_ctl0[0]=(((r).rx_x4_rs_fec_rx_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))

/*
 * These macros can be used to access RX_X4_RS_FEC_RX_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r,(_r._rx_x4_rs_fec_rx_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r,(_r._rx_x4_rs_fec_rx_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r,(_r._rx_x4_rs_fec_rx_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_RX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_rx_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_RX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_rx_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_RX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_rx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_RX_CTL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r
#define RX_X4_RS_FEC_RX_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_t RX_X4_RS_FEC_RX_CTL0r_t;
#define RX_X4_RS_FEC_RX_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_CLR
#define RX_X4_RS_FEC_RX_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_SET
#define RX_X4_RS_FEC_RX_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_GET
#define RX_X4_RS_FEC_RX_CTL0r_CW_BAD_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_CW_BAD_ENABLEf_GET
#define RX_X4_RS_FEC_RX_CTL0r_CW_BAD_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r_CW_BAD_ENABLEf_SET
#define READ_RX_X4_RS_FEC_RX_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_RX_CTL0r
#define WRITE_RX_X4_RS_FEC_RX_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_RX_CTL0r
#define MODIFY_RX_X4_RS_FEC_RX_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_RX_CTL0r
#define READLN_RX_X4_RS_FEC_RX_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_RX_CTL0r
#define WRITELN_RX_X4_RS_FEC_RX_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_RX_CTL0r
#define WRITEALL_RX_X4_RS_FEC_RX_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_RX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_DEC_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc132
 * DESC:     Decoder control 0 register
 * RESETVAL: 0xe (14)
 * ACCESS:   R/W
 * FIELDS:
 *     LPI_ENABLE       If off (0), LPIs are converted to IDLEs.
 *     RX_RF_ENABLE     If this bit is a one, RFs are passed to the RS layer from the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the RS layer.
 *     RX_LF_ENABLE     If this bit is a one, LFs are passed to the RS layer from the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the RS layer.
 *     RX_LI_ENABLE     If this bit is a one, LIs (Link Interrupt) are passed thru to the PCS.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the PCS.
 *     R_TEST_MODE_CFG  Test Mode enable for both CL49 and CL82
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r (0x0000c132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_ctl0[1];
	uint32_t _rx_x4_dec_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_CLR(r) (r).rx_x4_dec_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_SET(r,d) (r).rx_x4_dec_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_GET(r) (r).rx_x4_dec_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LI_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LI_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LF_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LF_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_RF_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_RF_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_LPI_ENABLEf_GET(r) (((r).rx_x4_dec_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_LPI_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_DEC_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_DEC_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_DEC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_DEC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_DEC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_DEC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_DEC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_CTL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r
#define RX_X4_DEC_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_t RX_X4_DEC_CTL0r_t;
#define RX_X4_DEC_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_CLR
#define RX_X4_DEC_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_SET
#define RX_X4_DEC_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_GET
#define RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET
#define RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET
#define RX_X4_DEC_CTL0r_RX_LI_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LI_ENABLEf_GET
#define RX_X4_DEC_CTL0r_RX_LI_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LI_ENABLEf_SET
#define RX_X4_DEC_CTL0r_RX_LF_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LF_ENABLEf_GET
#define RX_X4_DEC_CTL0r_RX_LF_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_LF_ENABLEf_SET
#define RX_X4_DEC_CTL0r_RX_RF_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_RF_ENABLEf_GET
#define RX_X4_DEC_CTL0r_RX_RF_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_RX_RF_ENABLEf_SET
#define RX_X4_DEC_CTL0r_LPI_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_LPI_ENABLEf_GET
#define RX_X4_DEC_CTL0r_LPI_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r_LPI_ENABLEf_SET
#define READ_RX_X4_DEC_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_DEC_CTL0r
#define WRITE_RX_X4_DEC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_DEC_CTL0r
#define MODIFY_RX_X4_DEC_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_DEC_CTL0r
#define READLN_RX_X4_DEC_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_DEC_CTL0r
#define WRITELN_RX_X4_DEC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_DEC_CTL0r
#define WRITEALL_RX_X4_DEC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_DEC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_PMA_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc133
 * DESC:     pma_control_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RSTB_LANE        Low activer per lane reset for RXP
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r (0x0000c133 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PMA_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pma_ctl0[1];
	uint32_t _rx_x4_pma_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_CLR(r) (r).rx_x4_pma_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_SET(r,d) (r).rx_x4_pma_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_GET(r) (r).rx_x4_pma_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_GET(r) (((r).rx_x4_pma_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_SET(r,f) (r).rx_x4_pma_ctl0[0]=(((r).rx_x4_pma_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PMA_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PMA_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PMA_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PMA_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PMA_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pma_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PMA_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pma_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PMA_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pma_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PMA_CTL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r
#define RX_X4_PMA_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_t RX_X4_PMA_CTL0r_t;
#define RX_X4_PMA_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_CLR
#define RX_X4_PMA_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_SET
#define RX_X4_PMA_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_GET
#define RX_X4_PMA_CTL0r_RSTB_LANEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_GET
#define RX_X4_PMA_CTL0r_RSTB_LANEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_SET
#define READ_RX_X4_PMA_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PMA_CTL0r
#define WRITE_RX_X4_PMA_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PMA_CTL0r
#define MODIFY_RX_X4_PMA_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PMA_CTL0r
#define READLN_RX_X4_PMA_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PMA_CTL0r
#define WRITELN_RX_X4_PMA_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PMA_CTL0r
#define WRITEALL_RX_X4_PMA_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PMA_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_PMA_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RX_TS_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc134
 * DESC:     RX TimeStamping Control register
 * RESETVAL: 0x39 (57)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_SFD_TS_EN     SFD enable.
 *     TS_UPDATE_ENABLE When set to 0, all time-stamps for this port from the PCS to the MAC will have a value of 0.When set to 1, the MPP will process all blocks from this port and provide updated time-stamps to the MAC.
 *     RECORD_DESKEW_TS_INFO A low to high transition results in HW recording the current statusof the per DSL time-stamp information for alignment markers.
 *     RX_SOP_BYTE_OFFSET This field contains the offset in bytes from the SOP of the PREAMBLE up to and including the time-stamping point.0: indicates the time-stamping point is 0 bytes from the SOP. This is SOP time-stamping.3: indicates the time-stamping point is 3 bytes after the SOP. This is SFD time-stamping with reduced preamble mode.7: indicates the time-stamping point is 7 bytes after the SOP. This is SFD time-stamping with normal preamble mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr (0x0000c134 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_TS_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_ts_ctl[1];
	uint32_t _rx_x4_rx_ts_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_CLR(r) (r).rx_x4_rx_ts_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_SET(r,d) (r).rx_x4_rx_ts_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_GET(r) (r).rx_x4_rx_ts_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SOP_BYTE_OFFSETf_GET(r) ((((r).rx_x4_rx_ts_ctl[0]) >> 3) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SOP_BYTE_OFFSETf_SET(r,f) (r).rx_x4_rx_ts_ctl[0]=(((r).rx_x4_rx_ts_ctl[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RECORD_DESKEW_TS_INFOf_GET(r) ((((r).rx_x4_rx_ts_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RECORD_DESKEW_TS_INFOf_SET(r,f) (r).rx_x4_rx_ts_ctl[0]=(((r).rx_x4_rx_ts_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_TS_UPDATE_ENABLEf_GET(r) ((((r).rx_x4_rx_ts_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_TS_UPDATE_ENABLEf_SET(r,f) (r).rx_x4_rx_ts_ctl[0]=(((r).rx_x4_rx_ts_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SFD_TS_ENf_GET(r) (((r).rx_x4_rx_ts_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SFD_TS_ENf_SET(r,f) (r).rx_x4_rx_ts_ctl[0]=(((r).rx_x4_rx_ts_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_RX_TS_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr,(_r._rx_x4_rx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr,(_r._rx_x4_rx_ts_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr,(_r._rx_x4_rx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RX_TS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RX_TS_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_ts_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RX_TS_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_ts_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr
#define RX_X4_RX_TS_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_t RX_X4_RX_TS_CTLr_t;
#define RX_X4_RX_TS_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_CLR
#define RX_X4_RX_TS_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_SET
#define RX_X4_RX_TS_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_GET
#define RX_X4_RX_TS_CTLr_RX_SOP_BYTE_OFFSETf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SOP_BYTE_OFFSETf_GET
#define RX_X4_RX_TS_CTLr_RX_SOP_BYTE_OFFSETf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SOP_BYTE_OFFSETf_SET
#define RX_X4_RX_TS_CTLr_RECORD_DESKEW_TS_INFOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RECORD_DESKEW_TS_INFOf_GET
#define RX_X4_RX_TS_CTLr_RECORD_DESKEW_TS_INFOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RECORD_DESKEW_TS_INFOf_SET
#define RX_X4_RX_TS_CTLr_TS_UPDATE_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_TS_UPDATE_ENABLEf_GET
#define RX_X4_RX_TS_CTLr_TS_UPDATE_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_TS_UPDATE_ENABLEf_SET
#define RX_X4_RX_TS_CTLr_RX_SFD_TS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SFD_TS_ENf_GET
#define RX_X4_RX_TS_CTLr_RX_SFD_TS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr_RX_SFD_TS_ENf_SET
#define READ_RX_X4_RX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RX_TS_CTLr
#define WRITE_RX_X4_RX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RX_TS_CTLr
#define MODIFY_RX_X4_RX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RX_TS_CTLr
#define READLN_RX_X4_RX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RX_TS_CTLr
#define WRITELN_RX_X4_RX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RX_TS_CTLr
#define WRITEALL_RX_X4_RX_TS_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RX_TS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_TS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC0
 * BLOCKS:   RX_X4_FEC_CONTROL
 * REGADDR:  0xc140
 * DESC:     User FEC Control 0 register
 * RESETVAL: 0x442c (17452)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERR_MODE     debug readout only for uncorrectable errors
 *     BURST_ERR_STATUS_MODE collect error info only for uncorrectable errors0 - update on correctable and uncorrectable events1 - update on uncorrectable events only
 *     DEC_MAX_PM       maximum correctable burst pattern size
 *     INVALID_PARITY_CNT number of bad locks before unlocking
 *     GOOD_PARITY_CNT  number of good blocks before locking
 *     DESKEW_CODE_WORD_SPACING_MODE Controls the spacing between code words into the RS FEC from deskew. The default value of 1'b0 indicates the spacing between codewords from deskew into the RS FEC for this port is no less than 19 clocks.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r (0x0000c140 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec0[1];
	uint32_t _rx_x4_fec0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_CLR(r) (r).rx_x4_fec0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_SET(r,d) (r).rx_x4_fec0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_GET(r) (r).rx_x4_fec0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DESKEW_CODE_WORD_SPACING_MODEf_GET(r) ((((r).rx_x4_fec0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DESKEW_CODE_WORD_SPACING_MODEf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_GET(r) ((((r).rx_x4_fec0[0]) >> 12) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_GET(r) ((((r).rx_x4_fec0[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_GET(r) ((((r).rx_x4_fec0[0]) >> 2) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_GET(r) ((((r).rx_x4_fec0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_GET(r) (((r).rx_x4_fec0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_FEC0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r
#define RX_X4_FEC0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_t RX_X4_FEC0r_t;
#define RX_X4_FEC0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_CLR
#define RX_X4_FEC0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_SET
#define RX_X4_FEC0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_GET
#define RX_X4_FEC0r_DESKEW_CODE_WORD_SPACING_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DESKEW_CODE_WORD_SPACING_MODEf_GET
#define RX_X4_FEC0r_DESKEW_CODE_WORD_SPACING_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DESKEW_CODE_WORD_SPACING_MODEf_SET
#define RX_X4_FEC0r_GOOD_PARITY_CNTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_GET
#define RX_X4_FEC0r_GOOD_PARITY_CNTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_SET
#define RX_X4_FEC0r_INVALID_PARITY_CNTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_GET
#define RX_X4_FEC0r_INVALID_PARITY_CNTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_SET
#define RX_X4_FEC0r_DEC_MAX_PMf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_GET
#define RX_X4_FEC0r_DEC_MAX_PMf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_SET
#define RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_GET
#define RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_SET
#define RX_X4_FEC0r_DBG_ERR_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_GET
#define RX_X4_FEC0r_DBG_ERR_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_SET
#define READ_RX_X4_FEC0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC0r
#define WRITE_RX_X4_FEC0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC0r
#define MODIFY_RX_X4_FEC0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC0r
#define READLN_RX_X4_FEC0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC0r
#define WRITELN_RX_X4_FEC0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC0r
#define WRITEALL_RX_X4_FEC0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC1
 * BLOCKS:   RX_X4_FEC_CONTROL
 * REGADDR:  0xc141
 * DESC:     User FEC Control 1 register
 * RESETVAL: 0x28 (40)
 * ACCESS:   R/W
 * FIELDS:
 *     DEC_GAP_COUNT_MODE Gap counting mode0 = Counting zero method1 = Counting gap method
 *     DEC_17B_BURST_GAP_COUNT Gaps allowed in 17-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_18B_BURST_GAP_COUNT Gaps allowed in 18-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_19B_BURST_GAP_COUNT Gaps allowed in 19-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_PM_MODE      Pattern Match Mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r (0x0000c141 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec1[1];
	uint32_t _rx_x4_fec1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_CLR(r) (r).rx_x4_fec1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_SET(r,d) (r).rx_x4_fec1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_GET(r) (r).rx_x4_fec1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_GET(r) ((((r).rx_x4_fec1[0]) >> 11) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 8) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 5) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 2) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_GET(r) ((((r).rx_x4_fec1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access RX_X4_FEC1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r
#define RX_X4_FEC1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_t RX_X4_FEC1r_t;
#define RX_X4_FEC1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_CLR
#define RX_X4_FEC1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_SET
#define RX_X4_FEC1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_GET
#define RX_X4_FEC1r_DEC_PM_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_GET
#define RX_X4_FEC1r_DEC_PM_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_SET
#define RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_GET
#define RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_SET
#define READ_RX_X4_FEC1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC1r
#define WRITE_RX_X4_FEC1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC1r
#define MODIFY_RX_X4_FEC1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC1r
#define READLN_RX_X4_FEC1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC1r
#define WRITELN_RX_X4_FEC1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC1r
#define WRITEALL_RX_X4_FEC1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC2
 * BLOCKS:   RX_X4_FEC_CONTROL
 * REGADDR:  0xc142
 * DESC:     User FEC Control 2 register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_ERROR_CODE_ALL report errors thru all sync headers
 *     DBG_ENABLE       FEC debug enable
 *     FEC_ERR_ENABLE   FEC error enable
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r (0x0000c142 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec2[1];
	uint32_t _rx_x4_fec2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_CLR(r) (r).rx_x4_fec2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_SET(r,d) (r).rx_x4_fec2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_GET(r) (r).rx_x4_fec2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLEf_GET(r) ((((r).rx_x4_fec2[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLEf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_DBG_ENABLEf_GET(r) ((((r).rx_x4_fec2[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_DBG_ENABLEf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALLf_GET(r) (((r).rx_x4_fec2[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALLf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_FEC2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r
#define RX_X4_FEC2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_t RX_X4_FEC2r_t;
#define RX_X4_FEC2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_CLR
#define RX_X4_FEC2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_SET
#define RX_X4_FEC2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_GET
#define RX_X4_FEC2r_FEC_ERR_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLEf_GET
#define RX_X4_FEC2r_FEC_ERR_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLEf_SET
#define RX_X4_FEC2r_DBG_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_DBG_ENABLEf_GET
#define RX_X4_FEC2r_DBG_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_DBG_ENABLEf_SET
#define RX_X4_FEC2r_FEC_ERROR_CODE_ALLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALLf_GET
#define RX_X4_FEC2r_FEC_ERROR_CODE_ALLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALLf_SET
#define READ_RX_X4_FEC2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC2r
#define WRITE_RX_X4_FEC2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC2r
#define MODIFY_RX_X4_FEC2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC2r
#define READLN_RX_X4_FEC2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC2r
#define WRITELN_RX_X4_FEC2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC2r
#define WRITEALL_RX_X4_FEC2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BLKSYNC_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc150
 * DESC:     block sync status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BS_STATUS        Block Lock: indicates that the lane has achieved block lock status.One bit per pseudo-logical (Bitmux output) lane.
 *     BS_PMD_LOCK      Indicates the pmd_lock value seen at the input to this lane.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr (0x0000c150 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_sts[1];
	uint32_t _rx_x4_blksync_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_CLR(r) (r).rx_x4_blksync_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_SET(r,d) (r).rx_x4_blksync_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_GET(r) (r).rx_x4_blksync_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_GET(r) ((((r).rx_x4_blksync_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_SET(r,f) (r).rx_x4_blksync_sts[0]=(((r).rx_x4_blksync_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_GET(r) (((r).rx_x4_blksync_sts[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_SET(r,f) (r).rx_x4_blksync_sts[0]=(((r).rx_x4_blksync_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr,(_r._rx_x4_blksync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr,(_r._rx_x4_blksync_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr,(_r._rx_x4_blksync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_STSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr
#define RX_X4_BLKSYNC_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_t RX_X4_BLKSYNC_STSr_t;
#define RX_X4_BLKSYNC_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_CLR
#define RX_X4_BLKSYNC_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_SET
#define RX_X4_BLKSYNC_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_GET
#define RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_GET
#define RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_SET
#define RX_X4_BLKSYNC_STSr_BS_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_GET
#define RX_X4_BLKSYNC_STSr_BS_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_SET
#define READ_RX_X4_BLKSYNC_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_STSr
#define WRITE_RX_X4_BLKSYNC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_STSr
#define MODIFY_RX_X4_BLKSYNC_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_STSr
#define READLN_RX_X4_BLKSYNC_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_STSr
#define WRITELN_RX_X4_BLKSYNC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_STSr
#define WRITEALL_RX_X4_BLKSYNC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BLKSYNC_DBG0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc151
 * DESC:     block sync state machine debug info
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE0_DEBUG_INFO Debug info for pseudo-logical lane 0 blocksync SM.
 *     LANE1_DEBUG_INFO Debug info for pseudo-logical lane 1 blocksync SM.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r (0x0000c151 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_DBG0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_dbg0[1];
	uint32_t _rx_x4_blksync_dbg0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_CLR(r) (r).rx_x4_blksync_dbg0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_SET(r,d) (r).rx_x4_blksync_dbg0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_GET(r) (r).rx_x4_blksync_dbg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_GET(r) ((((r).rx_x4_blksync_dbg0[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg0[0]=(((r).rx_x4_blksync_dbg0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_GET(r) (((r).rx_x4_blksync_dbg0[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg0[0]=(((r).rx_x4_blksync_dbg0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_DBG0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r,(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r,(_r._rx_x4_blksync_dbg0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r,(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_DBG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_DBG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_dbg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_DBG0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r
#define RX_X4_BLKSYNC_DBG0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_t RX_X4_BLKSYNC_DBG0r_t;
#define RX_X4_BLKSYNC_DBG0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_CLR
#define RX_X4_BLKSYNC_DBG0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_SET
#define RX_X4_BLKSYNC_DBG0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_GET
#define RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_SET
#define RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_SET
#define READ_RX_X4_BLKSYNC_DBG0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_DBG0r
#define WRITE_RX_X4_BLKSYNC_DBG0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_DBG0r
#define MODIFY_RX_X4_BLKSYNC_DBG0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_DBG0r
#define READLN_RX_X4_BLKSYNC_DBG0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_DBG0r
#define WRITELN_RX_X4_BLKSYNC_DBG0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_DBG0r
#define WRITEALL_RX_X4_BLKSYNC_DBG0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BLKSYNC_DBG1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc152
 * DESC:     block sync state machine debug info
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE2_DEBUG_INFO Debug info for pseudo-logical lane 2 blocksync SM.
 *     LANE3_DEBUG_INFO Debug info for pseudo-logical lane 3 blocksync SM.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r (0x0000c152 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_DBG1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_dbg1[1];
	uint32_t _rx_x4_blksync_dbg1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_CLR(r) (r).rx_x4_blksync_dbg1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_SET(r,d) (r).rx_x4_blksync_dbg1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_GET(r) (r).rx_x4_blksync_dbg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_GET(r) ((((r).rx_x4_blksync_dbg1[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg1[0]=(((r).rx_x4_blksync_dbg1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_GET(r) (((r).rx_x4_blksync_dbg1[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg1[0]=(((r).rx_x4_blksync_dbg1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_DBG1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r,(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r,(_r._rx_x4_blksync_dbg1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r,(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_DBG1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_DBG1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_dbg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_DBG1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r
#define RX_X4_BLKSYNC_DBG1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_t RX_X4_BLKSYNC_DBG1r_t;
#define RX_X4_BLKSYNC_DBG1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_CLR
#define RX_X4_BLKSYNC_DBG1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_SET
#define RX_X4_BLKSYNC_DBG1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_GET
#define RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_SET
#define RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_SET
#define READ_RX_X4_BLKSYNC_DBG1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_DBG1r
#define WRITE_RX_X4_BLKSYNC_DBG1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_DBG1r
#define MODIFY_RX_X4_BLKSYNC_DBG1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_DBG1r
#define READLN_RX_X4_BLKSYNC_DBG1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_DBG1r
#define WRITELN_RX_X4_BLKSYNC_DBG1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_DBG1r
#define WRITEALL_RX_X4_BLKSYNC_DBG1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BLKSYNC_DBG2
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc153
 * DESC:     block sync state machine debug info
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE4_DEBUG_INFO Debug info for pseudo-logical lane 4 blocksync SM.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r (0x0000c153 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_DBG2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_dbg2[1];
	uint32_t _rx_x4_blksync_dbg2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_CLR(r) (r).rx_x4_blksync_dbg2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_SET(r,d) (r).rx_x4_blksync_dbg2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_GET(r) (r).rx_x4_blksync_dbg2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_GET(r) (((r).rx_x4_blksync_dbg2[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg2[0]=(((r).rx_x4_blksync_dbg2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_DBG2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r,(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r,(_r._rx_x4_blksync_dbg2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r,(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_DBG2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_DBG2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_dbg2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_DBG2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r
#define RX_X4_BLKSYNC_DBG2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_t RX_X4_BLKSYNC_DBG2r_t;
#define RX_X4_BLKSYNC_DBG2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_CLR
#define RX_X4_BLKSYNC_DBG2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_SET
#define RX_X4_BLKSYNC_DBG2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_GET
#define RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_SET
#define READ_RX_X4_BLKSYNC_DBG2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLKSYNC_DBG2r
#define WRITE_RX_X4_BLKSYNC_DBG2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLKSYNC_DBG2r
#define MODIFY_RX_X4_BLKSYNC_DBG2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLKSYNC_DBG2r
#define READLN_RX_X4_BLKSYNC_DBG2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLKSYNC_DBG2r
#define WRITELN_RX_X4_BLKSYNC_DBG2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLKSYNC_DBG2r
#define WRITEALL_RX_X4_BLKSYNC_DBG2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLKSYNC_DBG2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BLK_LOCK_LATCH_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc154
 * DESC:     Latched status of PCS information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BLOCK_LOCK_LL_0  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 0).Clear on read
 *     BLOCK_LOCK_LH_0  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 0).Clear on read
 *     BLOCK_LOCK_LL_1  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 1).Clear on read
 *     BLOCK_LOCK_LH_1  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 1).Clear on read
 *     BLOCK_LOCK_LL_2  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 2).Clear on read
 *     BLOCK_LOCK_LH_2  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 2).Clear on read
 *     BLOCK_LOCK_LL_3  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 3).Clear on read
 *     BLOCK_LOCK_LH_3  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 3).Clear on read
 *     BLOCK_LOCK_LL_4  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 4).Clear on read
 *     BLOCK_LOCK_LH_4  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 4).Clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr (0x0000c154 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLK_LOCK_LATCH_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_blk_lock_latch_sts[1];
	uint32_t _rx_x4_blk_lock_latch_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_CLR(r) (r).rx_x4_blk_lock_latch_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SET(r,d) (r).rx_x4_blk_lock_latch_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_GET(r) (r).rx_x4_blk_lock_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_GET(r) (((r).rx_x4_blk_lock_latch_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_BLK_LOCK_LATCH_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr,(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr,(_r._rx_x4_blk_lock_latch_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr,(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blk_lock_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr
#define RX_X4_BLK_LOCK_LATCH_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_t RX_X4_BLK_LOCK_LATCH_STSr_t;
#define RX_X4_BLK_LOCK_LATCH_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_CLR
#define RX_X4_BLK_LOCK_LATCH_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_SET
#define READ_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BLK_LOCK_LATCH_STSr
#define WRITE_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BLK_LOCK_LATCH_STSr
#define MODIFY_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BLK_LOCK_LATCH_STSr
#define READLN_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BLK_LOCK_LATCH_STSr
#define WRITELN_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BLK_LOCK_LATCH_STSr
#define WRITEALL_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BLK_LOCK_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BLK_LOCK_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_AM_LOCK_LATCH_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc155
 * DESC:     Latched status of PCS information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_LL_0     AM Lock has transitioned low since last read (for Pseudo-logical lane 0).Clear on read
 *     AM_LOCK_LH_0     AM Lock has transitioned high since last read (for Pseudo-logical lane 0).Clear on read
 *     AM_LOCK_LL_1     AM Lock has transitioned low since last read (for Pseudo-logical lane 1).Clear on read
 *     AM_LOCK_LH_1     AM Lock has transitioned high since last read (for Pseudo-logical lane 1).Clear on read
 *     AM_LOCK_LL_2     AM Lock has transitioned low since last read (for Pseudo-logical lane 2).Clear on read
 *     AM_LOCK_LH_2     AM Lock has transitioned high since last read (for Pseudo-logical lane 2).Clear on read
 *     AM_LOCK_LL_3     AM Lock has transitioned low since last read (for Pseudo-logical lane 3).Clear on read
 *     AM_LOCK_LH_3     AM Lock has transitioned high since last read (for Pseudo-logical lane 3).Clear on read
 *     AM_LOCK_LL_4     AM Lock has transitioned low since last read (for Pseudo-logical lane 4).Clear on read
 *     AM_LOCK_LH_4     AM Lock has transitioned high since last read (for Pseudo-logical lane 4).Clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr (0x0000c155 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_AM_LOCK_LATCH_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_am_lock_latch_sts[1];
	uint32_t _rx_x4_am_lock_latch_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_CLR(r) (r).rx_x4_am_lock_latch_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SET(r,d) (r).rx_x4_am_lock_latch_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_GET(r) (r).rx_x4_am_lock_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_GET(r) (((r).rx_x4_am_lock_latch_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_AM_LOCK_LATCH_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr,(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr,(_r._rx_x4_am_lock_latch_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr,(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_am_lock_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr
#define RX_X4_AM_LOCK_LATCH_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_t RX_X4_AM_LOCK_LATCH_STSr_t;
#define RX_X4_AM_LOCK_LATCH_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_CLR
#define RX_X4_AM_LOCK_LATCH_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SET
#define RX_X4_AM_LOCK_LATCH_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_SET
#define READ_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_LOCK_LATCH_STSr
#define WRITE_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_LOCK_LATCH_STSr
#define MODIFY_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_LOCK_LATCH_STSr
#define READLN_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_LOCK_LATCH_STSr
#define WRITELN_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_LOCK_LATCH_STSr
#define WRITEALL_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_LOCK_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_LOCK_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BIPCNT0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc157
 * DESC:     BIP error count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERROR_COUNT_0 CL82 BIP error count for pseudo-logical lane 0.Saturates at 8'hFF. Clear on read.
 *     BIP_ERROR_COUNT_1 CL82 BIP error count for pseudo-logical lane 1.Saturates at 8'hFF. Clear on read.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r (0x0000c157 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BIPCNT0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_s {
	uint32_t v[1];
	uint32_t rx_x4_bipcnt0[1];
	uint32_t _rx_x4_bipcnt0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_CLR(r) (r).rx_x4_bipcnt0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_SET(r,d) (r).rx_x4_bipcnt0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_GET(r) (r).rx_x4_bipcnt0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_GET(r) ((((r).rx_x4_bipcnt0[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_SET(r,f) (r).rx_x4_bipcnt0[0]=(((r).rx_x4_bipcnt0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_GET(r) (((r).rx_x4_bipcnt0[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_SET(r,f) (r).rx_x4_bipcnt0[0]=(((r).rx_x4_bipcnt0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BIPCNT0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BIPCNT0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r,(_r._rx_x4_bipcnt0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BIPCNT0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r,(_r._rx_x4_bipcnt0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BIPCNT0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r,(_r._rx_x4_bipcnt0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BIPCNT0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BIPCNT0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BIPCNT0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_bipcnt0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BIPCNT0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r
#define RX_X4_BIPCNT0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_t RX_X4_BIPCNT0r_t;
#define RX_X4_BIPCNT0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_CLR
#define RX_X4_BIPCNT0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_SET
#define RX_X4_BIPCNT0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_GET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_GET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_SET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_GET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_SET
#define READ_RX_X4_BIPCNT0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BIPCNT0r
#define WRITE_RX_X4_BIPCNT0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BIPCNT0r
#define MODIFY_RX_X4_BIPCNT0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BIPCNT0r
#define READLN_RX_X4_BIPCNT0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BIPCNT0r
#define WRITELN_RX_X4_BIPCNT0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BIPCNT0r
#define WRITEALL_RX_X4_BIPCNT0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BIPCNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BIPCNT1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc158
 * DESC:     BIP error count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERROR_COUNT_2 CL82 BIP error count for pseudo-logical lane 2.Saturates at 8'hFF. Clear on read.
 *     BIP_ERROR_COUNT_3 CL82 BIP error count for pseudo-logical lane 3.Saturates at 8'hFF. Clear on read.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r (0x0000c158 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BIPCNT1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_s {
	uint32_t v[1];
	uint32_t rx_x4_bipcnt1[1];
	uint32_t _rx_x4_bipcnt1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_CLR(r) (r).rx_x4_bipcnt1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_SET(r,d) (r).rx_x4_bipcnt1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_GET(r) (r).rx_x4_bipcnt1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_GET(r) ((((r).rx_x4_bipcnt1[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_SET(r,f) (r).rx_x4_bipcnt1[0]=(((r).rx_x4_bipcnt1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_GET(r) (((r).rx_x4_bipcnt1[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_SET(r,f) (r).rx_x4_bipcnt1[0]=(((r).rx_x4_bipcnt1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BIPCNT1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BIPCNT1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r,(_r._rx_x4_bipcnt1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BIPCNT1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r,(_r._rx_x4_bipcnt1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BIPCNT1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r,(_r._rx_x4_bipcnt1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BIPCNT1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BIPCNT1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BIPCNT1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_bipcnt1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BIPCNT1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r
#define RX_X4_BIPCNT1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_t RX_X4_BIPCNT1r_t;
#define RX_X4_BIPCNT1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_CLR
#define RX_X4_BIPCNT1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_SET
#define RX_X4_BIPCNT1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_GET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_GET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_SET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_GET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_SET
#define READ_RX_X4_BIPCNT1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BIPCNT1r
#define WRITE_RX_X4_BIPCNT1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BIPCNT1r
#define MODIFY_RX_X4_BIPCNT1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BIPCNT1r
#define READLN_RX_X4_BIPCNT1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BIPCNT1r
#define WRITELN_RX_X4_BIPCNT1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BIPCNT1r
#define WRITEALL_RX_X4_BIPCNT1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BIPCNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BIPCNT2
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc159
 * DESC:     BIP error count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERROR_COUNT_4 CL82 BIP error count for pseudo-logical lane 4.Saturates at 8'hFF. Clear on read.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r (0x0000c159 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BIPCNT2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_s {
	uint32_t v[1];
	uint32_t rx_x4_bipcnt2[1];
	uint32_t _rx_x4_bipcnt2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_CLR(r) (r).rx_x4_bipcnt2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_SET(r,d) (r).rx_x4_bipcnt2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_GET(r) (r).rx_x4_bipcnt2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_GET(r) (((r).rx_x4_bipcnt2[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_SET(r,f) (r).rx_x4_bipcnt2[0]=(((r).rx_x4_bipcnt2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BIPCNT2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BIPCNT2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r,(_r._rx_x4_bipcnt2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BIPCNT2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r,(_r._rx_x4_bipcnt2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BIPCNT2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r,(_r._rx_x4_bipcnt2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BIPCNT2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BIPCNT2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BIPCNT2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_bipcnt2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BIPCNT2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r
#define RX_X4_BIPCNT2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_t RX_X4_BIPCNT2r_t;
#define RX_X4_BIPCNT2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_CLR
#define RX_X4_BIPCNT2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_SET
#define RX_X4_BIPCNT2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_GET
#define RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_GET
#define RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_SET
#define READ_RX_X4_BIPCNT2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BIPCNT2r
#define WRITE_RX_X4_BIPCNT2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BIPCNT2r
#define MODIFY_RX_X4_BIPCNT2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BIPCNT2r
#define READLN_RX_X4_BIPCNT2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BIPCNT2r
#define WRITELN_RX_X4_BIPCNT2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BIPCNT2r
#define WRITEALL_RX_X4_BIPCNT2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BIPCNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BIPCNT2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_PSLL_TO_VL_MAP0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15a
 * DESC:     Pseudo-logical lane to virtual lane mapping
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PSLL0_TO_VL_MAPPING Pseudo-logical lane 0 to virtual lane mapping.
 *     PSLL1_TO_VL_MAPPING Pseudo-logical lane 1 to virtual lane mapping.
 *     PSLL2_TO_VL_MAPPING Pseudo-logical lane 2 to virtual lane mapping.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r (0x0000c15a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PSLL_TO_VL_MAP0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_s {
	uint32_t v[1];
	uint32_t rx_x4_psll_to_vl_map0[1];
	uint32_t _rx_x4_psll_to_vl_map0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_CLR(r) (r).rx_x4_psll_to_vl_map0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SET(r,d) (r).rx_x4_psll_to_vl_map0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_GET(r) (r).rx_x4_psll_to_vl_map0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_GET(r) ((((r).rx_x4_psll_to_vl_map0[0]) >> 10) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map0[0]=(((r).rx_x4_psll_to_vl_map0[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_GET(r) ((((r).rx_x4_psll_to_vl_map0[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map0[0]=(((r).rx_x4_psll_to_vl_map0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_GET(r) (((r).rx_x4_psll_to_vl_map0[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map0[0]=(((r).rx_x4_psll_to_vl_map0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_PSLL_TO_VL_MAP0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r,(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r,(_r._rx_x4_psll_to_vl_map0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r,(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_psll_to_vl_map0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r
#define RX_X4_PSLL_TO_VL_MAP0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_t RX_X4_PSLL_TO_VL_MAP0r_t;
#define RX_X4_PSLL_TO_VL_MAP0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_CLR
#define RX_X4_PSLL_TO_VL_MAP0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SET
#define RX_X4_PSLL_TO_VL_MAP0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_SET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_SET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_SET
#define READ_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PSLL_TO_VL_MAP0r
#define WRITE_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP0r
#define MODIFY_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP0r
#define READLN_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP0r
#define WRITELN_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP0r
#define WRITEALL_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_PSLL_TO_VL_MAP1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15b
 * DESC:     Pseudo-logical lane to virtual lane mapping
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PSLL3_TO_VL_MAPPING Pseudo-logical lane 3 to virtual lane mapping.
 *     PSLL4_TO_VL_MAPPING Pseudo-logical lane 4 to virtual lane mapping.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r (0x0000c15b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PSLL_TO_VL_MAP1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_s {
	uint32_t v[1];
	uint32_t rx_x4_psll_to_vl_map1[1];
	uint32_t _rx_x4_psll_to_vl_map1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_CLR(r) (r).rx_x4_psll_to_vl_map1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SET(r,d) (r).rx_x4_psll_to_vl_map1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_GET(r) (r).rx_x4_psll_to_vl_map1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_GET(r) ((((r).rx_x4_psll_to_vl_map1[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map1[0]=(((r).rx_x4_psll_to_vl_map1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_GET(r) (((r).rx_x4_psll_to_vl_map1[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map1[0]=(((r).rx_x4_psll_to_vl_map1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_PSLL_TO_VL_MAP1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r,(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r,(_r._rx_x4_psll_to_vl_map1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r,(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_psll_to_vl_map1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r
#define RX_X4_PSLL_TO_VL_MAP1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_t RX_X4_PSLL_TO_VL_MAP1r_t;
#define RX_X4_PSLL_TO_VL_MAP1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_CLR
#define RX_X4_PSLL_TO_VL_MAP1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SET
#define RX_X4_PSLL_TO_VL_MAP1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_GET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_SET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_SET
#define READ_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PSLL_TO_VL_MAP1r
#define WRITE_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP1r
#define MODIFY_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP1r
#define READLN_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP1r
#define WRITELN_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP1r
#define WRITEALL_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_PSLL_TO_VL_MAP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_SYM
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15c
 * DESC:     Symbol Value register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SYMBOL_VALUE     contains the received spare RS symbol provided in certain RS FEC modes
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr (0x0000c15c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_SYM.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_sym[1];
	uint32_t _rx_x4_rs_sym;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_CLR(r) (r).rx_x4_rs_sym[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SET(r,d) (r).rx_x4_rs_sym[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_GET(r) (r).rx_x4_rs_sym[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SYMBOL_VALUEf_GET(r) (((r).rx_x4_rs_sym[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SYMBOL_VALUEf_SET(r,f) (r).rx_x4_rs_sym[0]=(((r).rx_x4_rs_sym[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_RS_SYM.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr,(_r._rx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr,(_r._rx_x4_rs_sym)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr,(_r._rx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_SYMr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_SYMr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_sym))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_SYMr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_sym))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr
#define RX_X4_RS_SYMr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_t RX_X4_RS_SYMr_t;
#define RX_X4_RS_SYMr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_CLR
#define RX_X4_RS_SYMr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SET
#define RX_X4_RS_SYMr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_GET
#define RX_X4_RS_SYMr_SYMBOL_VALUEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SYMBOL_VALUEf_GET
#define RX_X4_RS_SYMr_SYMBOL_VALUEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr_SYMBOL_VALUEf_SET
#define READ_RX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_SYMr
#define WRITE_RX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_SYMr
#define MODIFY_RX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_SYMr
#define READLN_RX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_SYMr
#define WRITELN_RX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_SYMr
#define WRITEALL_RX_X4_RS_SYMr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_SYMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_SYMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_PCS_LATCH_STS1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc160
 * DESC:     Latched status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DESKEW_STATUS_LL Deskew status has transitioned low since last read.Deskew achieved (1), Deskew not achieved (0)Clear on read
 *     DESKEW_STATUS_LH Deskew status has transitioned high since last read.Deskew achieved (1), Deskew not achieved (0)Clear on read
 *     LINK_STATUS_LL   PER PORT: Link Status indicator has transitioned low since last readClear on read
 *     LINK_STATUS_LH   PER PORT: Link Status indicator has transitioned high since last readClear on read
 *     HI_BER_LL        HI_BER has transitioned low since last read.Clear on read
 *     HI_BER_LH        HI_BER has transitioned high since last read.Clear on read
 *     LPI_RECEIVED_LH  PER PORT: Low Power Indicator (LPI) has transitioned high since last read.Clear on read
 *     LINK_INTERRUPT_LH PER PORT: Link Interrupt (LI)  has transitioned high since last read.Clear on read
 *     REMOTE_FAULT_LH  PER PORT: Remote Fault (RF)  has transitioned high since last read.Clear on read
 *     LOCAL_FAULT_LH   PER PORT: Local Fault (LF) indicator has transitioned high since last read.Clear on read
 *     PCS_LINK_STATUS_LIVE PER PORT: this indicates PCS live link status. Please Note it will also go down when we will switch to RLM modes.READ ONLY
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r (0x0000c160 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LATCH_STS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_latch_sts1[1];
	uint32_t _rx_x4_pcs_latch_sts1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_CLR(r) (r).rx_x4_pcs_latch_sts1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_SET(r,d) (r).rx_x4_pcs_latch_sts1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_GET(r) (r).rx_x4_pcs_latch_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_PCS_LINK_STATUS_LIVEf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_PCS_LINK_STATUS_LIVEf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_GET(r) (((r).rx_x4_pcs_latch_sts1[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PCS_LATCH_STS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PCS_LATCH_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PCS_LATCH_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_latch_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LATCH_STS1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r
#define RX_X4_PCS_LATCH_STS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_t RX_X4_PCS_LATCH_STS1r_t;
#define RX_X4_PCS_LATCH_STS1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_CLR
#define RX_X4_PCS_LATCH_STS1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_SET
#define RX_X4_PCS_LATCH_STS1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_GET
#define RX_X4_PCS_LATCH_STS1r_PCS_LINK_STATUS_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_PCS_LINK_STATUS_LIVEf_GET
#define RX_X4_PCS_LATCH_STS1r_PCS_LINK_STATUS_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_PCS_LINK_STATUS_LIVEf_SET
#define RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_GET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_SET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_GET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_SET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_GET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_SET
#define READ_RX_X4_PCS_LATCH_STS1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PCS_LATCH_STS1r
#define WRITE_RX_X4_PCS_LATCH_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PCS_LATCH_STS1r
#define MODIFY_RX_X4_PCS_LATCH_STS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PCS_LATCH_STS1r
#define READLN_RX_X4_PCS_LATCH_STS1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PCS_LATCH_STS1r
#define WRITELN_RX_X4_PCS_LATCH_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PCS_LATCH_STS1r
#define WRITEALL_RX_X4_PCS_LATCH_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_PCS_LATCH_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RL_MODE_HW_STS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc161
 * DESC:     Status of LI_in_RL_mode indication from MAC to PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     HW_LI_IN_RL_MODE Information captured by TX pipeline, Indicated by CDMAC on interface signals u0/u1_mac_msbus_tx_LI_in_RL_mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr (0x0000c161 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RL_MODE_HW_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_rl_mode_hw_sts[1];
	uint32_t _rx_x4_rl_mode_hw_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_CLR(r) (r).rx_x4_rl_mode_hw_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_SET(r,d) (r).rx_x4_rl_mode_hw_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_GET(r) (r).rx_x4_rl_mode_hw_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_HW_LI_IN_RL_MODEf_GET(r) (((r).rx_x4_rl_mode_hw_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_HW_LI_IN_RL_MODEf_SET(r,f) (r).rx_x4_rl_mode_hw_sts[0]=(((r).rx_x4_rl_mode_hw_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_RL_MODE_HW_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RL_MODE_HW_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr,(_r._rx_x4_rl_mode_hw_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RL_MODE_HW_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr,(_r._rx_x4_rl_mode_hw_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RL_MODE_HW_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr,(_r._rx_x4_rl_mode_hw_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RL_MODE_HW_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rl_mode_hw_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RL_MODE_HW_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rl_mode_hw_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RL_MODE_HW_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rl_mode_hw_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RL_MODE_HW_STSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr
#define RX_X4_RL_MODE_HW_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_t RX_X4_RL_MODE_HW_STSr_t;
#define RX_X4_RL_MODE_HW_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_CLR
#define RX_X4_RL_MODE_HW_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_SET
#define RX_X4_RL_MODE_HW_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_GET
#define RX_X4_RL_MODE_HW_STSr_HW_LI_IN_RL_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_HW_LI_IN_RL_MODEf_GET
#define RX_X4_RL_MODE_HW_STSr_HW_LI_IN_RL_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr_HW_LI_IN_RL_MODEf_SET
#define READ_RX_X4_RL_MODE_HW_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RL_MODE_HW_STSr
#define WRITE_RX_X4_RL_MODE_HW_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RL_MODE_HW_STSr
#define MODIFY_RX_X4_RL_MODE_HW_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RL_MODE_HW_STSr
#define READLN_RX_X4_RL_MODE_HW_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RL_MODE_HW_STSr
#define WRITELN_RX_X4_RL_MODE_HW_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RL_MODE_HW_STSr
#define WRITEALL_RX_X4_RL_MODE_HW_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RL_MODE_HW_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_HW_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RL_MODE_SW_CTL
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc162
 * DESC:     SW control of LI_in_RL_mode indication to PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_LI_IN_RL_MODE LI_in_RL_mode indication by SW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr (0x0000c162 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RL_MODE_SW_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x4_rl_mode_sw_ctl[1];
	uint32_t _rx_x4_rl_mode_sw_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_CLR(r) (r).rx_x4_rl_mode_sw_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SET(r,d) (r).rx_x4_rl_mode_sw_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_GET(r) (r).rx_x4_rl_mode_sw_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SW_LI_IN_RL_MODEf_GET(r) (((r).rx_x4_rl_mode_sw_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SW_LI_IN_RL_MODEf_SET(r,f) (r).rx_x4_rl_mode_sw_ctl[0]=(((r).rx_x4_rl_mode_sw_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_RL_MODE_SW_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RL_MODE_SW_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr,(_r._rx_x4_rl_mode_sw_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RL_MODE_SW_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr,(_r._rx_x4_rl_mode_sw_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RL_MODE_SW_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr,(_r._rx_x4_rl_mode_sw_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RL_MODE_SW_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rl_mode_sw_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RL_MODE_SW_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rl_mode_sw_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RL_MODE_SW_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rl_mode_sw_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RL_MODE_SW_CTLr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr
#define RX_X4_RL_MODE_SW_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_t RX_X4_RL_MODE_SW_CTLr_t;
#define RX_X4_RL_MODE_SW_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_CLR
#define RX_X4_RL_MODE_SW_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SET
#define RX_X4_RL_MODE_SW_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_GET
#define RX_X4_RL_MODE_SW_CTLr_SW_LI_IN_RL_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SW_LI_IN_RL_MODEf_GET
#define RX_X4_RL_MODE_SW_CTLr_SW_LI_IN_RL_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr_SW_LI_IN_RL_MODEf_SET
#define READ_RX_X4_RL_MODE_SW_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RL_MODE_SW_CTLr
#define WRITE_RX_X4_RL_MODE_SW_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RL_MODE_SW_CTLr
#define MODIFY_RX_X4_RL_MODE_SW_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RL_MODE_SW_CTLr
#define READLN_RX_X4_RL_MODE_SW_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RL_MODE_SW_CTLr
#define WRITELN_RX_X4_RL_MODE_SW_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RL_MODE_SW_CTLr
#define WRITEALL_RX_X4_RL_MODE_SW_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RL_MODE_SW_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RL_MODE_SW_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_DEC_STS1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc163
 * DESC:     decode status 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BERMON_HISTORY_STATE BER Monitor fsm - latched states - latched on entry
 *     CL49_RXSM_HISTORY_STATE Receive SM - latched states - latched on entry
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r (0x0000c163 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts1[1];
	uint32_t _rx_x4_dec_sts1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_CLR(r) (r).rx_x4_dec_sts1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_SET(r,d) (r).rx_x4_dec_sts1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_GET(r) (r).rx_x4_dec_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_GET(r) ((((r).rx_x4_dec_sts1[0]) >> 5) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_SET(r,f) (r).rx_x4_dec_sts1[0]=(((r).rx_x4_dec_sts1[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_GET(r) (((r).rx_x4_dec_sts1[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_SET(r,f) (r).rx_x4_dec_sts1[0]=(((r).rx_x4_dec_sts1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_DEC_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_DEC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_DEC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_DEC_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_DEC_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_DEC_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r
#define RX_X4_DEC_STS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_t RX_X4_DEC_STS1r_t;
#define RX_X4_DEC_STS1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_CLR
#define RX_X4_DEC_STS1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_SET
#define RX_X4_DEC_STS1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_GET
#define RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_GET
#define RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_SET
#define RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_GET
#define RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_SET
#define READ_RX_X4_DEC_STS1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_DEC_STS1r
#define WRITE_RX_X4_DEC_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_DEC_STS1r
#define MODIFY_RX_X4_DEC_STS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_DEC_STS1r
#define READLN_RX_X4_DEC_STS1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_DEC_STS1r
#define WRITELN_RX_X4_DEC_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_DEC_STS1r
#define WRITEALL_RX_X4_DEC_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_DEC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_DEC_STS3
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc165
 * DESC:     decode status 3 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     IEEE_ERRORED_BLOCKS Contains the count of the errored blocks decoded by the cl49/cl82 decoders.In cl82 mode, this field contains the lower 8 bits of the 22 bit value.The upper 14 bits are present in the RX_X4_CL82_errored_blocks_ho register.Reading this register will also clear the RX_X4_CL82_errored_blocks_ho register.The RX_X4_CL82_errored_blocks_ho should be read first, before reading this register,to obtain a consistent view of the fields that are combined across the two registers.
 *     CL49_BER_COUNT   For cl49 - This field is the 6 bit BER count.It is used to count the number of times BER_BAD_SH state is entered.The counter saturates at 6'h3F.Reading this register will also clear the RX_X4_CL82_errored_blocks_ho register.The RX_X4_CL82_errored_blocks_ho should be read first, before reading this registerto obtain a consistent view of the fields that are combined across the two registers.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r (0x0000c165 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts3[1];
	uint32_t _rx_x4_dec_sts3;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_CLR(r) (r).rx_x4_dec_sts3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_SET(r,d) (r).rx_x4_dec_sts3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_GET(r) (r).rx_x4_dec_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_GET(r) ((((r).rx_x4_dec_sts3[0]) >> 8) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_SET(r,f) (r).rx_x4_dec_sts3[0]=(((r).rx_x4_dec_sts3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_GET(r) (((r).rx_x4_dec_sts3[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_SET(r,f) (r).rx_x4_dec_sts3[0]=(((r).rx_x4_dec_sts3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_DEC_STS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_DEC_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_DEC_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_DEC_STS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_DEC_STS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_DEC_STS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS3r BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r
#define RX_X4_DEC_STS3r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_t RX_X4_DEC_STS3r_t;
#define RX_X4_DEC_STS3r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_CLR
#define RX_X4_DEC_STS3r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_SET
#define RX_X4_DEC_STS3r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_GET
#define RX_X4_DEC_STS3r_CL49_BER_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_GET
#define RX_X4_DEC_STS3r_CL49_BER_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_SET
#define RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_GET
#define RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_SET
#define READ_RX_X4_DEC_STS3r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_DEC_STS3r
#define WRITE_RX_X4_DEC_STS3r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_DEC_STS3r
#define MODIFY_RX_X4_DEC_STS3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_DEC_STS3r
#define READLN_RX_X4_DEC_STS3r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_DEC_STS3r
#define WRITELN_RX_X4_DEC_STS3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_DEC_STS3r
#define WRITEALL_RX_X4_DEC_STS3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_DEC_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_DEC_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RX_LATCH_STS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc167
 * DESC:     cl82 rx latched deskew and decoder status register
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     DESKEW_HIS_STATE Deskew history statesClear on read0x1:  bit [0] LOSS_OF_ALIGNMENT0x2:  bit [1] ALIGN_ACQUIRED0x4:  bit [2] TEST_CW0x8:  bit [3] CW_GOOD0x10: bit [4] CW_BAD0x20: bit [5] THREE_BAD
 *     HISTORY_RXSM_STATE Receive fsm - latched history stateFor 400G speed, only lane 0 will reflect the history. Other lanes will be 0.For other speeds, all lanes will reflect the history.Clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr (0x0000c167 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_LATCH_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_latch_sts[1];
	uint32_t _rx_x4_rx_latch_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_CLR(r) (r).rx_x4_rx_latch_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_SET(r,d) (r).rx_x4_rx_latch_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_GET(r) (r).rx_x4_rx_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_HISTORY_RXSM_STATEf_GET(r) ((((r).rx_x4_rx_latch_sts[0]) >> 6) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_HISTORY_RXSM_STATEf_SET(r,f) (r).rx_x4_rx_latch_sts[0]=(((r).rx_x4_rx_latch_sts[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_DESKEW_HIS_STATEf_GET(r) (((r).rx_x4_rx_latch_sts[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_DESKEW_HIS_STATEf_SET(r,f) (r).rx_x4_rx_latch_sts[0]=(((r).rx_x4_rx_latch_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access RX_X4_RX_LATCH_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RX_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr,(_r._rx_x4_rx_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RX_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr,(_r._rx_x4_rx_latch_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RX_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr,(_r._rx_x4_rx_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RX_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RX_LATCH_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_latch_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RX_LATCH_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr
#define RX_X4_RX_LATCH_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_t RX_X4_RX_LATCH_STSr_t;
#define RX_X4_RX_LATCH_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_CLR
#define RX_X4_RX_LATCH_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_SET
#define RX_X4_RX_LATCH_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_GET
#define RX_X4_RX_LATCH_STSr_HISTORY_RXSM_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_HISTORY_RXSM_STATEf_GET
#define RX_X4_RX_LATCH_STSr_HISTORY_RXSM_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_HISTORY_RXSM_STATEf_SET
#define RX_X4_RX_LATCH_STSr_DESKEW_HIS_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_DESKEW_HIS_STATEf_GET
#define RX_X4_RX_LATCH_STSr_DESKEW_HIS_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr_DESKEW_HIS_STATEf_SET
#define READ_RX_X4_RX_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RX_LATCH_STSr
#define WRITE_RX_X4_RX_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RX_LATCH_STSr
#define MODIFY_RX_X4_RX_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RX_LATCH_STSr
#define READLN_RX_X4_RX_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RX_LATCH_STSr
#define WRITELN_RX_X4_RX_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RX_LATCH_STSr
#define WRITEALL_RX_X4_RX_LATCH_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RX_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RX_LATCH_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BER_LO
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc168
 * DESC:     CL82 BER LOWER ORDER bits register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BER_LO           Lower 8 bits of CL82 BER count.It counts the number of times BER_BAD_SH state is entered.Reading this register will also clear the RX_X4_CL82_ber_ho register.The RX_X4_CL82_ber_ho should be read first, before reading this register,to obtain a consistent view of the fields that are combined across the two registers.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr (0x0000c168 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BER_LO.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_s {
	uint32_t v[1];
	uint32_t rx_x4_ber_lo[1];
	uint32_t _rx_x4_ber_lo;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_CLR(r) (r).rx_x4_ber_lo[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_SET(r,d) (r).rx_x4_ber_lo[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_GET(r) (r).rx_x4_ber_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_BER_LOf_GET(r) (((r).rx_x4_ber_lo[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_BER_LOf_SET(r,f) (r).rx_x4_ber_lo[0]=(((r).rx_x4_ber_lo[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BER_LO.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BER_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr,(_r._rx_x4_ber_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BER_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr,(_r._rx_x4_ber_lo)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BER_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr,(_r._rx_x4_ber_lo))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BER_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ber_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BER_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ber_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BER_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ber_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BER_LOr BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr
#define RX_X4_BER_LOr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_t RX_X4_BER_LOr_t;
#define RX_X4_BER_LOr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_CLR
#define RX_X4_BER_LOr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_SET
#define RX_X4_BER_LOr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_GET
#define RX_X4_BER_LOr_BER_LOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_BER_LOf_GET
#define RX_X4_BER_LOr_BER_LOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr_BER_LOf_SET
#define READ_RX_X4_BER_LOr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BER_LOr
#define WRITE_RX_X4_BER_LOr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BER_LOr
#define MODIFY_RX_X4_BER_LOr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BER_LOr
#define READLN_RX_X4_BER_LOr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BER_LOr
#define WRITELN_RX_X4_BER_LOr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BER_LOr
#define WRITEALL_RX_X4_BER_LOr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BER_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_BER_HO
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc169
 * DESC:     CL82 BER HIGH ORDER bits register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BER_HO           Upper 14 bits of CL82 BER count.It counts the number of times BER_BAD_SH state is entered.This register is cleared when the RX_X4_CL82_ber_lo is read.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr (0x0000c169 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BER_HO.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_s {
	uint32_t v[1];
	uint32_t rx_x4_ber_ho[1];
	uint32_t _rx_x4_ber_ho;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_CLR(r) (r).rx_x4_ber_ho[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_SET(r,d) (r).rx_x4_ber_ho[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_GET(r) (r).rx_x4_ber_ho[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_BER_HOf_GET(r) (((r).rx_x4_ber_ho[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_BER_HOf_SET(r,f) (r).rx_x4_ber_ho[0]=(((r).rx_x4_ber_ho[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_BER_HO.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BER_HOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr,(_r._rx_x4_ber_ho))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BER_HOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr,(_r._rx_x4_ber_ho)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BER_HOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr,(_r._rx_x4_ber_ho))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BER_HOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ber_ho))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BER_HOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ber_ho))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BER_HOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ber_ho))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BER_HOr BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr
#define RX_X4_BER_HOr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_t RX_X4_BER_HOr_t;
#define RX_X4_BER_HOr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_CLR
#define RX_X4_BER_HOr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_SET
#define RX_X4_BER_HOr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_GET
#define RX_X4_BER_HOr_BER_HOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_BER_HOf_GET
#define RX_X4_BER_HOr_BER_HOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr_BER_HOf_SET
#define READ_RX_X4_BER_HOr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_BER_HOr
#define WRITE_RX_X4_BER_HOr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_BER_HOr
#define MODIFY_RX_X4_BER_HOr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_BER_HOr
#define READLN_RX_X4_BER_HOr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_BER_HOr
#define WRITELN_RX_X4_BER_HOr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_BER_HOr
#define WRITEALL_RX_X4_BER_HOr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_BER_HOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_BER_HOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_ERRED_BLKS_HO
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc16a
 * DESC:     40G/100GBASE-R Errored blocks high order counter
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     ERRORED_BLOCKS_HO Error blocks counter high order bits for cl82 - CR/NRBits 21:8 of the Error blocks  counterThis register is cleared when the RX_X4_Status1_decode_status_3 is read.
 *     ERRORED_BLOCKS_HO_PRESENT Error blocks counter high order bits present - ROAlways reads as 1 if this registers is implementedThis register is cleared when the RX_X4_Status1_decode_status_3 is read.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr (0x0000c16a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ERRED_BLKS_HO.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_s {
	uint32_t v[1];
	uint32_t rx_x4_erred_blks_ho[1];
	uint32_t _rx_x4_erred_blks_ho;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_CLR(r) (r).rx_x4_erred_blks_ho[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_SET(r,d) (r).rx_x4_erred_blks_ho[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_GET(r) (r).rx_x4_erred_blks_ho[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET(r) ((((r).rx_x4_erred_blks_ho[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET(r,f) (r).rx_x4_erred_blks_ho[0]=(((r).rx_x4_erred_blks_ho[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET(r) (((r).rx_x4_erred_blks_ho[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET(r,f) (r).rx_x4_erred_blks_ho[0]=(((r).rx_x4_erred_blks_ho[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_ERRED_BLKS_HO.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_ERRED_BLKS_HOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr,(_r._rx_x4_erred_blks_ho))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_ERRED_BLKS_HOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr,(_r._rx_x4_erred_blks_ho)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_ERRED_BLKS_HOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr,(_r._rx_x4_erred_blks_ho))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_ERRED_BLKS_HOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_erred_blks_ho))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_ERRED_BLKS_HOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_erred_blks_ho))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_ERRED_BLKS_HOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_erred_blks_ho))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ERRED_BLKS_HOr BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr
#define RX_X4_ERRED_BLKS_HOr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_t RX_X4_ERRED_BLKS_HOr_t;
#define RX_X4_ERRED_BLKS_HOr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_CLR
#define RX_X4_ERRED_BLKS_HOr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_SET
#define RX_X4_ERRED_BLKS_HOr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_GET
#define RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET
#define RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET
#define RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET
#define RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET
#define READ_RX_X4_ERRED_BLKS_HOr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_ERRED_BLKS_HOr
#define WRITE_RX_X4_ERRED_BLKS_HOr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_ERRED_BLKS_HOr
#define MODIFY_RX_X4_ERRED_BLKS_HOr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_ERRED_BLKS_HOr
#define READLN_RX_X4_ERRED_BLKS_HOr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_ERRED_BLKS_HOr
#define WRITELN_RX_X4_ERRED_BLKS_HOr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_ERRED_BLKS_HOr
#define WRITEALL_RX_X4_ERRED_BLKS_HOr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_ERRED_BLKS_HOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_ERRED_BLKS_HOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_CL49_SCRIDLE_TEST_ERR
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc16b
 * DESC:     CL49 Scrambled IDLE test Error register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_SCRIDLE_TEST_ERR CL49 Scrambled IDLE Test Error counter
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr (0x0000c16b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL49_SCRIDLE_TEST_ERR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl49_scridle_test_err[1];
	uint32_t _rx_x4_cl49_scridle_test_err;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CLR(r) (r).rx_x4_cl49_scridle_test_err[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SET(r,d) (r).rx_x4_cl49_scridle_test_err[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_GET(r) (r).rx_x4_cl49_scridle_test_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_GET(r) (((r).rx_x4_cl49_scridle_test_err[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_SET(r,f) (r).rx_x4_cl49_scridle_test_err[0]=(((r).rx_x4_cl49_scridle_test_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL49_SCRIDLE_TEST_ERR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr,(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr,(_r._rx_x4_cl49_scridle_test_err)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr,(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl49_scridle_test_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_t RX_X4_CL49_SCRIDLE_TEST_ERRr_t;
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CLR
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SET
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_GET
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_GET
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_SET
#define READ_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define WRITE_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define MODIFY_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define READLN_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define WRITELN_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define WRITEALL_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL49_SCRIDLE_TEST_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL0
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc170
 * DESC:     AM FSM latched status for pseudo-logical lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_0 Alignment marker history states - per logical lane for psll 0clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0 align marker spacing error detected - per logical lane for psll 0clear on read
 *     COMMON_MRKR_SPACING_ERR_LATCH_FECL_0 align marker spacing error detected - per logical lane for fec lane 0
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r (0x0000c170 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll0[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_0f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_0f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll0[0]=(((r).rx_x4_cl82_am_latch_sts_psll0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll0[0]=(((r).rx_x4_cl82_am_latch_sts_psll0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll0[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll0[0]=(((r).rx_x4_cl82_am_latch_sts_psll0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r,(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r,(_r._rx_x4_cl82_am_latch_sts_psll0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r,(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_t RX_X4_CL82_AM_LATCH_STS_PSLL0r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_0f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_0f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL1
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc171
 * DESC:     AM FSM latched status for pseudo-logical lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_1 Alignment marker history states - per logical lane for psll 1clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1 align marker spacing error detected - per logical lane for psll 1clear on read
 *     COMMON_MRKR_SPACING_ERR_LATCH_FECL_1 align marker spacing error detected - per logical lane for fec lane 1
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r (0x0000c171 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll1[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_1f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll1[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_1f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll1[0]=(((r).rx_x4_cl82_am_latch_sts_psll1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll1[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll1[0]=(((r).rx_x4_cl82_am_latch_sts_psll1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll1[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll1[0]=(((r).rx_x4_cl82_am_latch_sts_psll1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r,(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r,(_r._rx_x4_cl82_am_latch_sts_psll1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r,(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_t RX_X4_CL82_AM_LATCH_STS_PSLL1r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_1f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_COMMON_MRKR_SPACING_ERR_LATCH_FECL_1f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL2
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc172
 * DESC:     AM FSM latched status for pseudo-logical lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_2 Alignment marker history states - per logical lane for psll 2clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2 align marker spacing error detected - per logical lane for psll 2clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r (0x0000c172 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll2[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll2[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll2[0]=(((r).rx_x4_cl82_am_latch_sts_psll2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll2[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll2[0]=(((r).rx_x4_cl82_am_latch_sts_psll2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r,(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r,(_r._rx_x4_cl82_am_latch_sts_psll2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r,(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_t RX_X4_CL82_AM_LATCH_STS_PSLL2r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL3
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc173
 * DESC:     AM FSM latched status for pseudo-logical lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_3 Alignment marker history states - per logical lane for psll 3clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3 align marker spacing error detected - per logical lane for psll 3clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r (0x0000c173 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll3[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll3;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll3[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll3[0]=(((r).rx_x4_cl82_am_latch_sts_psll3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll3[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll3[0]=(((r).rx_x4_cl82_am_latch_sts_psll3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r,(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r,(_r._rx_x4_cl82_am_latch_sts_psll3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r,(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_t RX_X4_CL82_AM_LATCH_STS_PSLL3r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL4
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc174
 * DESC:     AM FSM latched status for pseudo-logical lane 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_4 Alignment marker history states - per logical lane for psll 4clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4 align marker spacing error detected - per logical lane for psll 4clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r (0x0000c174 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll4[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll4;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll4[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll4[0]=(((r).rx_x4_cl82_am_latch_sts_psll4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll4[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll4[0]=(((r).rx_x4_cl82_am_latch_sts_psll4[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r,(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r,(_r._rx_x4_cl82_am_latch_sts_psll4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r,(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_t RX_X4_CL82_AM_LATCH_STS_PSLL4r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_SYNC_STS
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc17a
 * DESC:     RS_FEC RXP per lane statuses
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_AMPS_LOCK_LIVE_0 Boolean variable that is set when the receiver has detected thelocation of the alignment marker payload sequence for a given logical lane.
 *     RS_FEC_AMPS_LOCK_LL_0 Latched low version of RS_FEC_amps_lock_live.
 *     RS_FEC_AMPS_LOCK_LH_0 Latched high version of RS_FEC_amps_lock_live.
 *     RS_FEC_FEC_LANE_MAP_0 FEC lane ID for one FEC lane (zero) per logic lane
 *     RS_FEC_FEC_LANE_MAP_VALID_0 Indicates that the FEC lane ID for lane zero for the given logical lane is valid.
 *     RS_FEC_AMPS_LOCK_LIVE_1 Boolean variable that is set when the receiver has detected thelocation of the alignment marker payload sequence for a given logical lane.
 *     RS_FEC_AMPS_LOCK_LL_1 Latched low version of RS_FEC_amps_lock_live.
 *     RS_FEC_AMPS_LOCK_LH_1 Latched high version of RS_FEC_amps_lock_live.
 *     RS_FEC_FEC_LANE_MAP_1 FEC lane ID for one FEC lane (one) per logic lane
 *     RS_FEC_FEC_LANE_MAP_VALID_1 Indicates that the FEC lane ID for lane one for the given logical lane is valid.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr (0x0000c17a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_SYNC_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_sync_sts[1];
	uint32_t _rx_x4_rs_fec_sync_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_CLR(r) (r).rx_x4_rs_fec_sync_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_SET(r,d) (r).rx_x4_rs_fec_sync_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_GET(r) (r).rx_x4_rs_fec_sync_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_1f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_1f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_1f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 11) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_1f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_1f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_1f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_1f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_1f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_1f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_1f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_0f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_0f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_0f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 3) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_0f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_0f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_0f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_0f_GET(r) ((((r).rx_x4_rs_fec_sync_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_0f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_0f_GET(r) (((r).rx_x4_rs_fec_sync_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_0f_SET(r,f) (r).rx_x4_rs_fec_sync_sts[0]=(((r).rx_x4_rs_fec_sync_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_SYNC_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_SYNC_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr,(_r._rx_x4_rs_fec_sync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_SYNC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr,(_r._rx_x4_rs_fec_sync_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_SYNC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr,(_r._rx_x4_rs_fec_sync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_SYNC_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_sync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_SYNC_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_sync_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_SYNC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_sync_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_SYNC_STSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr
#define RX_X4_RS_FEC_SYNC_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_t RX_X4_RS_FEC_SYNC_STSr_t;
#define RX_X4_RS_FEC_SYNC_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_CLR
#define RX_X4_RS_FEC_SYNC_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_SET
#define RX_X4_RS_FEC_SYNC_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_1f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_1f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_1f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_1f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_1f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_1f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_1f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_1f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_1f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_1f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_0f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_VALID_0f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_0f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_FEC_LANE_MAP_0f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_0f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LH_0f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_0f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LL_0f_SET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_0f_GET
#define RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr_RS_FEC_AMPS_LOCK_LIVE_0f_SET
#define READ_RX_X4_RS_FEC_SYNC_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_SYNC_STSr
#define WRITE_RX_X4_RS_FEC_SYNC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_SYNC_STSr
#define MODIFY_RX_X4_RS_FEC_SYNC_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_SYNC_STSr
#define READLN_RX_X4_RS_FEC_SYNC_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_SYNC_STSr
#define WRITELN_RX_X4_RS_FEC_SYNC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_SYNC_STSr
#define WRITEALL_RX_X4_RS_FEC_SYNC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_SYNC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_SYNC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_SYNC_FSM_ST
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc17b
 * DESC:     block sync status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_LO FEC synchronization FSM latched stateEach bit represents a particular state. The bit positions for each state is shown belowThe register clears only when read. It is not cleared even on pipeline reset.
 *     RS_FEC_BM_COLLISION Indicates CWs are being received by the FEC faster than they can be processed.
 *     RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_HI FEC synchronization FSM latched stateEach bit represents a particular state. The bit positions for each state is shown belowThe register clears only when read. It is not cleared even on pipeline reset.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr (0x0000c17b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_SYNC_FSM_ST.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_sync_fsm_st[1];
	uint32_t _rx_x4_fec_sync_fsm_st;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_CLR(r) (r).rx_x4_fec_sync_fsm_st[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_SET(r,d) (r).rx_x4_fec_sync_fsm_st[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_GET(r) (r).rx_x4_fec_sync_fsm_st[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_HIf_GET(r) ((((r).rx_x4_fec_sync_fsm_st[0]) >> 9) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_HIf_SET(r,f) (r).rx_x4_fec_sync_fsm_st[0]=(((r).rx_x4_fec_sync_fsm_st[0] & ~((uint32_t)0x7f << 9)) | ((((uint32_t)f) & 0x7f) << 9)) | (127 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_BM_COLLISIONf_GET(r) ((((r).rx_x4_fec_sync_fsm_st[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_BM_COLLISIONf_SET(r,f) (r).rx_x4_fec_sync_fsm_st[0]=(((r).rx_x4_fec_sync_fsm_st[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_LOf_GET(r) ((((r).rx_x4_fec_sync_fsm_st[0]) >> 1) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_LOf_SET(r,f) (r).rx_x4_fec_sync_fsm_st[0]=(((r).rx_x4_fec_sync_fsm_st[0] & ~((uint32_t)0x7f << 1)) | ((((uint32_t)f) & 0x7f) << 1)) | (127 << (16 + 1))

/*
 * These macros can be used to access RX_X4_FEC_SYNC_FSM_ST.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr,(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr,(_r._rx_x4_fec_sync_fsm_st)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr,(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_SYNC_FSM_STr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_SYNC_FSM_STr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_sync_fsm_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_SYNC_FSM_STr BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr
#define RX_X4_FEC_SYNC_FSM_STr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_t RX_X4_FEC_SYNC_FSM_STr_t;
#define RX_X4_FEC_SYNC_FSM_STr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_CLR
#define RX_X4_FEC_SYNC_FSM_STr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_SET
#define RX_X4_FEC_SYNC_FSM_STr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_GET
#define RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_HIf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_HIf_GET
#define RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_HIf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_HIf_SET
#define RX_X4_FEC_SYNC_FSM_STr_RS_FEC_BM_COLLISIONf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_BM_COLLISIONf_GET
#define RX_X4_FEC_SYNC_FSM_STr_RS_FEC_BM_COLLISIONf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_BM_COLLISIONf_SET
#define RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_LOf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_LOf_GET
#define RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_LOf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr_RS_FEC_FEC_SYNC_FSM_LATCHED_STATE_LOf_SET
#define READ_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_SYNC_FSM_STr
#define WRITE_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_SYNC_FSM_STr
#define MODIFY_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_SYNC_FSM_STr
#define READLN_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_SYNC_FSM_STr
#define WRITELN_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_SYNC_FSM_STr
#define WRITEALL_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_SYNC_FSM_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_SYNC_FSM_STr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL0
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc180
 * DESC:     User FEC debug read data for stream 0[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL_STREAM0 16 LSB of the FEC debug data for stream 0, clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r (0x0000c180 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl0[1];
	uint32_t _rx_x4_fec_dbg_errl0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_CLR(r) (r).rx_x4_fec_dbg_errl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_SET(r,d) (r).rx_x4_fec_dbg_errl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_GET(r) (r).rx_x4_fec_dbg_errl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_GET(r) (((r).rx_x4_fec_dbg_errl0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_SET(r,f) (r).rx_x4_fec_dbg_errl0[0]=(((r).rx_x4_fec_dbg_errl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r,(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r,(_r._rx_x4_fec_dbg_errl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r,(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_DBG_ERRL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r
#define RX_X4_FEC_DBG_ERRL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_t RX_X4_FEC_DBG_ERRL0r_t;
#define RX_X4_FEC_DBG_ERRL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_CLR
#define RX_X4_FEC_DBG_ERRL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_SET
#define RX_X4_FEC_DBG_ERRL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_GET
#define RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_GET
#define RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_SET
#define READ_RX_X4_FEC_DBG_ERRL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_DBG_ERRL0r
#define WRITE_RX_X4_FEC_DBG_ERRL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_DBG_ERRL0r
#define MODIFY_RX_X4_FEC_DBG_ERRL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL0r
#define READLN_RX_X4_FEC_DBG_ERRL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_DBG_ERRL0r
#define WRITELN_RX_X4_FEC_DBG_ERRL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL0r
#define WRITEALL_RX_X4_FEC_DBG_ERRL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH0
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc185
 * DESC:     User FEC debug read data for stream 0[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH_STREAM0 16 MSB of the FEC debug data for stream 0, clear on readContents are latched upon read of Fecdbg_edataL
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r (0x0000c185 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah0[1];
	uint32_t _rx_x4_fec_dbg_errah0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_CLR(r) (r).rx_x4_fec_dbg_errah0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_SET(r,d) (r).rx_x4_fec_dbg_errah0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_GET(r) (r).rx_x4_fec_dbg_errah0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_GET(r) (((r).rx_x4_fec_dbg_errah0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_SET(r,f) (r).rx_x4_fec_dbg_errah0[0]=(((r).rx_x4_fec_dbg_errah0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r,(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r,(_r._rx_x4_fec_dbg_errah0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r,(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_DBG_ERRAH0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errah0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAH0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r
#define RX_X4_FEC_DBG_ERRAH0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_t RX_X4_FEC_DBG_ERRAH0r_t;
#define RX_X4_FEC_DBG_ERRAH0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_CLR
#define RX_X4_FEC_DBG_ERRAH0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_SET
#define RX_X4_FEC_DBG_ERRAH0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_GET
#define RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_GET
#define RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_SET
#define READ_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_DBG_ERRAH0r
#define WRITE_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH0r
#define MODIFY_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH0r
#define READLN_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_DBG_ERRAH0r
#define WRITELN_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH0r
#define WRITEALL_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_DBG_ERRAH0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSL0
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc18a
 * DESC:     fec burst error status lower 16 bits for stream 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL_STREAM0 16 LSB of the fec_burst_err_status for stream 0bits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r (0x0000c18a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsl0[1];
	uint32_t _rx_x4_fec_burst_err_stsl0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_CLR(r) (r).rx_x4_fec_burst_err_stsl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SET(r,d) (r).rx_x4_fec_burst_err_stsl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_GET(r) (r).rx_x4_fec_burst_err_stsl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_GET(r) (((r).rx_x4_fec_burst_err_stsl0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_SET(r,f) (r).rx_x4_fec_burst_err_stsl0[0]=(((r).rx_x4_fec_burst_err_stsl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r,(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r,(_r._rx_x4_fec_burst_err_stsl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r,(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r
#define RX_X4_FEC_BURST_ERR_STSL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_t RX_X4_FEC_BURST_ERR_STSL0r_t;
#define RX_X4_FEC_BURST_ERR_STSL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_CLR
#define RX_X4_FEC_BURST_ERR_STSL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SET
#define RX_X4_FEC_BURST_ERR_STSL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_GET
#define RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_GET
#define RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL0r
#define WRITE_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL0r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL0r
#define READLN_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL0r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL0r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSH0
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc190
 * DESC:     fec burst error status lower 16 bits for stream 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH_STREAM0 Note: This register is only valid in case of Correctable Error scenario.In case of uncorrectable error case, This register may contain invalid data information.16 MSB of the fec_burst_err_status for stream 0bits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r (0x0000c190 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSH0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsh0[1];
	uint32_t _rx_x4_fec_burst_err_stsh0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_CLR(r) (r).rx_x4_fec_burst_err_stsh0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SET(r,d) (r).rx_x4_fec_burst_err_stsh0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_GET(r) (r).rx_x4_fec_burst_err_stsh0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_GET(r) (((r).rx_x4_fec_burst_err_stsh0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_SET(r,f) (r).rx_x4_fec_burst_err_stsh0[0]=(((r).rx_x4_fec_burst_err_stsh0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSH0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r,(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r,(_r._rx_x4_fec_burst_err_stsh0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r,(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsh0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r
#define RX_X4_FEC_BURST_ERR_STSH0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_t RX_X4_FEC_BURST_ERR_STSH0r_t;
#define RX_X4_FEC_BURST_ERR_STSH0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_CLR
#define RX_X4_FEC_BURST_ERR_STSH0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SET
#define RX_X4_FEC_BURST_ERR_STSH0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_GET
#define RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_GET
#define RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH0r
#define WRITE_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH0r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH0r
#define READLN_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH0r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH0r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BURST_ERR_STSH0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSL0
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc191
 * DESC:     FEC corrected blocks counter for stream 0 [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL_STREAM0 16 LSB of the corrected blocks count for stream 0, clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r (0x0000c191 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksl0[1];
	uint32_t _rx_x4_fec_corrblksl0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_CLR(r) (r).rx_x4_fec_corrblksl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_SET(r,d) (r).rx_x4_fec_corrblksl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_GET(r) (r).rx_x4_fec_corrblksl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_GET(r) (((r).rx_x4_fec_corrblksl0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_SET(r,f) (r).rx_x4_fec_corrblksl0[0]=(((r).rx_x4_fec_corrblksl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r,(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r,(_r._rx_x4_fec_corrblksl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r,(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORRBLKSL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r
#define RX_X4_FEC_CORRBLKSL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_t RX_X4_FEC_CORRBLKSL0r_t;
#define RX_X4_FEC_CORRBLKSL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_CLR
#define RX_X4_FEC_CORRBLKSL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_SET
#define RX_X4_FEC_CORRBLKSL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_GET
#define RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_GET
#define RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_SET
#define READ_RX_X4_FEC_CORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORRBLKSL0r
#define WRITE_RX_X4_FEC_CORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORRBLKSL0r
#define MODIFY_RX_X4_FEC_CORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL0r
#define READLN_RX_X4_FEC_CORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORRBLKSL0r
#define WRITELN_RX_X4_FEC_CORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL0r
#define WRITEALL_RX_X4_FEC_CORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSH0
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc192
 * DESC:     FEC corrected blocks counter for stream 0 [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH_STREAM0 16 MSB of the corrected blocks count for stream 0, clear on readContents are latched upon read of corCountL
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r (0x0000c192 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSH0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksh0[1];
	uint32_t _rx_x4_fec_corrblksh0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_CLR(r) (r).rx_x4_fec_corrblksh0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_SET(r,d) (r).rx_x4_fec_corrblksh0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_GET(r) (r).rx_x4_fec_corrblksh0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_GET(r) (((r).rx_x4_fec_corrblksh0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_SET(r,f) (r).rx_x4_fec_corrblksh0[0]=(((r).rx_x4_fec_corrblksh0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSH0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r,(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r,(_r._rx_x4_fec_corrblksh0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r,(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORRBLKSH0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksh0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r
#define RX_X4_FEC_CORRBLKSH0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_t RX_X4_FEC_CORRBLKSH0r_t;
#define RX_X4_FEC_CORRBLKSH0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_CLR
#define RX_X4_FEC_CORRBLKSH0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_SET
#define RX_X4_FEC_CORRBLKSH0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_GET
#define RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_GET
#define RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_SET
#define READ_RX_X4_FEC_CORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORRBLKSH0r
#define WRITE_RX_X4_FEC_CORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORRBLKSH0r
#define MODIFY_RX_X4_FEC_CORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH0r
#define READLN_RX_X4_FEC_CORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORRBLKSH0r
#define WRITELN_RX_X4_FEC_CORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH0r
#define WRITEALL_RX_X4_FEC_CORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORRBLKSH0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_PRTPERRCTR
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc193
 * DESC:     PRTP Error Count Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRTP_ERR_COUNT   Pseudo Random Test Pattern block error count
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr (0x0000c193 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PRTPERRCTR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_s {
	uint32_t v[1];
	uint32_t rx_x4_prtperrctr[1];
	uint32_t _rx_x4_prtperrctr;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_CLR(r) (r).rx_x4_prtperrctr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_SET(r,d) (r).rx_x4_prtperrctr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_GET(r) (r).rx_x4_prtperrctr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_GET(r) (((r).rx_x4_prtperrctr[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_SET(r,f) (r).rx_x4_prtperrctr[0]=(((r).rx_x4_prtperrctr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_PRTPERRCTR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr,(_r._rx_x4_prtperrctr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr,(_r._rx_x4_prtperrctr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr,(_r._rx_x4_prtperrctr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PRTPERRCTRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtperrctr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PRTPERRCTRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtperrctr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_prtperrctr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PRTPERRCTRr BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr
#define RX_X4_PRTPERRCTRr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_t RX_X4_PRTPERRCTRr_t;
#define RX_X4_PRTPERRCTRr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_CLR
#define RX_X4_PRTPERRCTRr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_SET
#define RX_X4_PRTPERRCTRr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_GET
#define RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_GET
#define RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_SET
#define READ_RX_X4_PRTPERRCTRr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PRTPERRCTRr
#define WRITE_RX_X4_PRTPERRCTRr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PRTPERRCTRr
#define MODIFY_RX_X4_PRTPERRCTRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PRTPERRCTRr
#define READLN_RX_X4_PRTPERRCTRr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PRTPERRCTRr
#define WRITELN_RX_X4_PRTPERRCTRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PRTPERRCTRr
#define WRITEALL_RX_X4_PRTPERRCTRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PRTPERRCTRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPERRCTRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_PRTPSTS
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc194
 * DESC:     PRTP Status Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRTP_LOCK        Pseudo Random Test Pattern (PRTP) is locked
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr (0x0000c194 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PRTPSTS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_s {
	uint32_t v[1];
	uint32_t rx_x4_prtpsts[1];
	uint32_t _rx_x4_prtpsts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_CLR(r) (r).rx_x4_prtpsts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_SET(r,d) (r).rx_x4_prtpsts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_GET(r) (r).rx_x4_prtpsts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_GET(r) (((r).rx_x4_prtpsts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_SET(r,f) (r).rx_x4_prtpsts[0]=(((r).rx_x4_prtpsts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PRTPSTS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PRTPSTSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr,(_r._rx_x4_prtpsts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PRTPSTSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr,(_r._rx_x4_prtpsts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PRTPSTSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr,(_r._rx_x4_prtpsts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PRTPSTSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtpsts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PRTPSTSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtpsts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PRTPSTSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_prtpsts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PRTPSTSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr
#define RX_X4_PRTPSTSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_t RX_X4_PRTPSTSr_t;
#define RX_X4_PRTPSTSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_CLR
#define RX_X4_PRTPSTSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_SET
#define RX_X4_PRTPSTSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_GET
#define RX_X4_PRTPSTSr_PRTP_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_GET
#define RX_X4_PRTPSTSr_PRTP_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_SET
#define READ_RX_X4_PRTPSTSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_PRTPSTSr
#define WRITE_RX_X4_PRTPSTSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_PRTPSTSr
#define MODIFY_RX_X4_PRTPSTSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_PRTPSTSr
#define READLN_RX_X4_PRTPSTSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_PRTPSTSr
#define WRITELN_RX_X4_PRTPSTSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_PRTPSTSr
#define WRITEALL_RX_X4_PRTPSTSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_PRTPSTSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_PRTPSTSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSL0
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a0
 * DESC:     FEC uncorrected blocks counter for stream 0[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL_STREAM0 16 LSB of the uncorrected blocks count for stream 0, clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r (0x0000c1a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksl0[1];
	uint32_t _rx_x4_fec_uncorrblksl0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_CLR(r) (r).rx_x4_fec_uncorrblksl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SET(r,d) (r).rx_x4_fec_uncorrblksl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_GET(r) (r).rx_x4_fec_uncorrblksl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_GET(r) (((r).rx_x4_fec_uncorrblksl0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_SET(r,f) (r).rx_x4_fec_uncorrblksl0[0]=(((r).rx_x4_fec_uncorrblksl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r,(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r,(_r._rx_x4_fec_uncorrblksl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r,(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r
#define RX_X4_FEC_UNCORRBLKSL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_t RX_X4_FEC_UNCORRBLKSL0r_t;
#define RX_X4_FEC_UNCORRBLKSL0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_CLR
#define RX_X4_FEC_UNCORRBLKSL0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SET
#define RX_X4_FEC_UNCORRBLKSL0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_GET
#define RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_GET
#define RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_SET
#define READ_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORRBLKSL0r
#define WRITE_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL0r
#define MODIFY_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL0r
#define READLN_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL0r
#define WRITELN_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL0r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSH0
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a1
 * DESC:     FEC uncorrected blocks counter for stream 0[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH_STREAM0 16 MSB of the uncorrected blocks count for stream 0, clear on readContents are latched upon read of uncorCountL
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r (0x0000c1a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSH0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksh0[1];
	uint32_t _rx_x4_fec_uncorrblksh0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_CLR(r) (r).rx_x4_fec_uncorrblksh0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SET(r,d) (r).rx_x4_fec_uncorrblksh0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_GET(r) (r).rx_x4_fec_uncorrblksh0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_GET(r) (((r).rx_x4_fec_uncorrblksh0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_SET(r,f) (r).rx_x4_fec_uncorrblksh0[0]=(((r).rx_x4_fec_uncorrblksh0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSH0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r,(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r,(_r._rx_x4_fec_uncorrblksh0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r,(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksh0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r
#define RX_X4_FEC_UNCORRBLKSH0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_t RX_X4_FEC_UNCORRBLKSH0r_t;
#define RX_X4_FEC_UNCORRBLKSH0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_CLR
#define RX_X4_FEC_UNCORRBLKSH0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SET
#define RX_X4_FEC_UNCORRBLKSH0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_GET
#define RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_GET
#define RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_SET
#define READ_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORRBLKSH0r
#define WRITE_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH0r
#define MODIFY_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH0r
#define READLN_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH0r
#define WRITELN_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH0r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORRBLKSH0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_SKEW_OFFSS0
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a2
 * DESC:     Rx relative Lane Skew for Virtual lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_SLIP_COUNT_0  Offset in bits
 *     AM_TS_FCLK_ADJUST_VALUE_0 Offset in blocks (66b or 80b) within Deskew
 *     DESKEW_TS_INFO_VALID_0 Indicates that the aligment marker based time-stamp info is valid and ready to be accessed by SW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r (0x0000c1a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SKEW_OFFSS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_skew_offss0[1];
	uint32_t _rx_x4_skew_offss0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_CLR(r) (r).rx_x4_skew_offss0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_SET(r,d) (r).rx_x4_skew_offss0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_GET(r) (r).rx_x4_skew_offss0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_DESKEW_TS_INFO_VALID_0f_GET(r) ((((r).rx_x4_skew_offss0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_DESKEW_TS_INFO_VALID_0f_SET(r,f) (r).rx_x4_skew_offss0[0]=(((r).rx_x4_skew_offss0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_TS_FCLK_ADJUST_VALUE_0f_GET(r) ((((r).rx_x4_skew_offss0[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_TS_FCLK_ADJUST_VALUE_0f_SET(r,f) (r).rx_x4_skew_offss0[0]=(((r).rx_x4_skew_offss0[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_SLIP_COUNT_0f_GET(r) (((r).rx_x4_skew_offss0[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_SLIP_COUNT_0f_SET(r,f) (r).rx_x4_skew_offss0[0]=(((r).rx_x4_skew_offss0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_SKEW_OFFSS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r,(_r._rx_x4_skew_offss0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r,(_r._rx_x4_skew_offss0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r,(_r._rx_x4_skew_offss0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_skew_offss0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SKEW_OFFSS0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r
#define RX_X4_SKEW_OFFSS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_t RX_X4_SKEW_OFFSS0r_t;
#define RX_X4_SKEW_OFFSS0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_CLR
#define RX_X4_SKEW_OFFSS0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_SET
#define RX_X4_SKEW_OFFSS0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_GET
#define RX_X4_SKEW_OFFSS0r_DESKEW_TS_INFO_VALID_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_DESKEW_TS_INFO_VALID_0f_GET
#define RX_X4_SKEW_OFFSS0r_DESKEW_TS_INFO_VALID_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_DESKEW_TS_INFO_VALID_0f_SET
#define RX_X4_SKEW_OFFSS0r_AM_TS_FCLK_ADJUST_VALUE_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_TS_FCLK_ADJUST_VALUE_0f_GET
#define RX_X4_SKEW_OFFSS0r_AM_TS_FCLK_ADJUST_VALUE_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_TS_FCLK_ADJUST_VALUE_0f_SET
#define RX_X4_SKEW_OFFSS0r_AM_SLIP_COUNT_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_SLIP_COUNT_0f_GET
#define RX_X4_SKEW_OFFSS0r_AM_SLIP_COUNT_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r_AM_SLIP_COUNT_0f_SET
#define READ_RX_X4_SKEW_OFFSS0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS0r
#define WRITE_RX_X4_SKEW_OFFSS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS0r
#define MODIFY_RX_X4_SKEW_OFFSS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS0r
#define READLN_RX_X4_SKEW_OFFSS0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS0r
#define WRITELN_RX_X4_SKEW_OFFSS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS0r
#define WRITEALL_RX_X4_SKEW_OFFSS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_SKEW_OFFSS1
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a3
 * DESC:     Rx relative Lane Skew for Virtual lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_SLIP_COUNT_1  Offset in bits
 *     AM_TS_FCLK_ADJUST_VALUE_1 Offset in blocks (66b or 80b) within Deskew
 *     DESKEW_TS_INFO_VALID_1 Indicates that the aligment marker based time-stamp info is valid and ready to be accessed by SW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r (0x0000c1a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SKEW_OFFSS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_skew_offss1[1];
	uint32_t _rx_x4_skew_offss1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_CLR(r) (r).rx_x4_skew_offss1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_SET(r,d) (r).rx_x4_skew_offss1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_GET(r) (r).rx_x4_skew_offss1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_DESKEW_TS_INFO_VALID_1f_GET(r) ((((r).rx_x4_skew_offss1[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_DESKEW_TS_INFO_VALID_1f_SET(r,f) (r).rx_x4_skew_offss1[0]=(((r).rx_x4_skew_offss1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_TS_FCLK_ADJUST_VALUE_1f_GET(r) ((((r).rx_x4_skew_offss1[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_TS_FCLK_ADJUST_VALUE_1f_SET(r,f) (r).rx_x4_skew_offss1[0]=(((r).rx_x4_skew_offss1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_SLIP_COUNT_1f_GET(r) (((r).rx_x4_skew_offss1[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_SLIP_COUNT_1f_SET(r,f) (r).rx_x4_skew_offss1[0]=(((r).rx_x4_skew_offss1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_SKEW_OFFSS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r,(_r._rx_x4_skew_offss1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r,(_r._rx_x4_skew_offss1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r,(_r._rx_x4_skew_offss1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_skew_offss1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SKEW_OFFSS1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r
#define RX_X4_SKEW_OFFSS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_t RX_X4_SKEW_OFFSS1r_t;
#define RX_X4_SKEW_OFFSS1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_CLR
#define RX_X4_SKEW_OFFSS1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_SET
#define RX_X4_SKEW_OFFSS1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_GET
#define RX_X4_SKEW_OFFSS1r_DESKEW_TS_INFO_VALID_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_DESKEW_TS_INFO_VALID_1f_GET
#define RX_X4_SKEW_OFFSS1r_DESKEW_TS_INFO_VALID_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_DESKEW_TS_INFO_VALID_1f_SET
#define RX_X4_SKEW_OFFSS1r_AM_TS_FCLK_ADJUST_VALUE_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_TS_FCLK_ADJUST_VALUE_1f_GET
#define RX_X4_SKEW_OFFSS1r_AM_TS_FCLK_ADJUST_VALUE_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_TS_FCLK_ADJUST_VALUE_1f_SET
#define RX_X4_SKEW_OFFSS1r_AM_SLIP_COUNT_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_SLIP_COUNT_1f_GET
#define RX_X4_SKEW_OFFSS1r_AM_SLIP_COUNT_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r_AM_SLIP_COUNT_1f_SET
#define READ_RX_X4_SKEW_OFFSS1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS1r
#define WRITE_RX_X4_SKEW_OFFSS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS1r
#define MODIFY_RX_X4_SKEW_OFFSS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS1r
#define READLN_RX_X4_SKEW_OFFSS1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS1r
#define WRITELN_RX_X4_SKEW_OFFSS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS1r
#define WRITEALL_RX_X4_SKEW_OFFSS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_SKEW_OFFSS2
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a4
 * DESC:     Rx relative Lane Skew for Virtual lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_SLIP_COUNT_2  Offset in bits
 *     AM_TS_FCLK_ADJUST_VALUE_2 Offset in blocks (66b or 80b) within Deskew
 *     DESKEW_TS_INFO_VALID_2 Indicates that the aligment marker based time-stamp info is valid and ready to be accessed by SW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r (0x0000c1a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SKEW_OFFSS2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_s {
	uint32_t v[1];
	uint32_t rx_x4_skew_offss2[1];
	uint32_t _rx_x4_skew_offss2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_CLR(r) (r).rx_x4_skew_offss2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_SET(r,d) (r).rx_x4_skew_offss2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_GET(r) (r).rx_x4_skew_offss2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_DESKEW_TS_INFO_VALID_2f_GET(r) ((((r).rx_x4_skew_offss2[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_DESKEW_TS_INFO_VALID_2f_SET(r,f) (r).rx_x4_skew_offss2[0]=(((r).rx_x4_skew_offss2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_TS_FCLK_ADJUST_VALUE_2f_GET(r) ((((r).rx_x4_skew_offss2[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_TS_FCLK_ADJUST_VALUE_2f_SET(r,f) (r).rx_x4_skew_offss2[0]=(((r).rx_x4_skew_offss2[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_SLIP_COUNT_2f_GET(r) (((r).rx_x4_skew_offss2[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_SLIP_COUNT_2f_SET(r,f) (r).rx_x4_skew_offss2[0]=(((r).rx_x4_skew_offss2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_SKEW_OFFSS2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r,(_r._rx_x4_skew_offss2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r,(_r._rx_x4_skew_offss2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r,(_r._rx_x4_skew_offss2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_skew_offss2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SKEW_OFFSS2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r
#define RX_X4_SKEW_OFFSS2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_t RX_X4_SKEW_OFFSS2r_t;
#define RX_X4_SKEW_OFFSS2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_CLR
#define RX_X4_SKEW_OFFSS2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_SET
#define RX_X4_SKEW_OFFSS2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_GET
#define RX_X4_SKEW_OFFSS2r_DESKEW_TS_INFO_VALID_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_DESKEW_TS_INFO_VALID_2f_GET
#define RX_X4_SKEW_OFFSS2r_DESKEW_TS_INFO_VALID_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_DESKEW_TS_INFO_VALID_2f_SET
#define RX_X4_SKEW_OFFSS2r_AM_TS_FCLK_ADJUST_VALUE_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_TS_FCLK_ADJUST_VALUE_2f_GET
#define RX_X4_SKEW_OFFSS2r_AM_TS_FCLK_ADJUST_VALUE_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_TS_FCLK_ADJUST_VALUE_2f_SET
#define RX_X4_SKEW_OFFSS2r_AM_SLIP_COUNT_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_SLIP_COUNT_2f_GET
#define RX_X4_SKEW_OFFSS2r_AM_SLIP_COUNT_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r_AM_SLIP_COUNT_2f_SET
#define READ_RX_X4_SKEW_OFFSS2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS2r
#define WRITE_RX_X4_SKEW_OFFSS2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS2r
#define MODIFY_RX_X4_SKEW_OFFSS2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS2r
#define READLN_RX_X4_SKEW_OFFSS2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS2r
#define WRITELN_RX_X4_SKEW_OFFSS2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS2r
#define WRITEALL_RX_X4_SKEW_OFFSS2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_SKEW_OFFSS3
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a5
 * DESC:     Rx relative Lane Skew for Virtual lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_SLIP_COUNT_3  Offset in bits
 *     AM_TS_FCLK_ADJUST_VALUE_3 Offset in blocks (66b or 80b) within Deskew
 *     DESKEW_TS_INFO_VALID_3 Indicates that the aligment marker based time-stamp info is valid and ready to be accessed by SW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r (0x0000c1a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SKEW_OFFSS3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_s {
	uint32_t v[1];
	uint32_t rx_x4_skew_offss3[1];
	uint32_t _rx_x4_skew_offss3;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_CLR(r) (r).rx_x4_skew_offss3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_SET(r,d) (r).rx_x4_skew_offss3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_GET(r) (r).rx_x4_skew_offss3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_DESKEW_TS_INFO_VALID_3f_GET(r) ((((r).rx_x4_skew_offss3[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_DESKEW_TS_INFO_VALID_3f_SET(r,f) (r).rx_x4_skew_offss3[0]=(((r).rx_x4_skew_offss3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_TS_FCLK_ADJUST_VALUE_3f_GET(r) ((((r).rx_x4_skew_offss3[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_TS_FCLK_ADJUST_VALUE_3f_SET(r,f) (r).rx_x4_skew_offss3[0]=(((r).rx_x4_skew_offss3[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_SLIP_COUNT_3f_GET(r) (((r).rx_x4_skew_offss3[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_SLIP_COUNT_3f_SET(r,f) (r).rx_x4_skew_offss3[0]=(((r).rx_x4_skew_offss3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_SKEW_OFFSS3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r,(_r._rx_x4_skew_offss3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r,(_r._rx_x4_skew_offss3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r,(_r._rx_x4_skew_offss3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_skew_offss3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SKEW_OFFSS3r BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r
#define RX_X4_SKEW_OFFSS3r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_t RX_X4_SKEW_OFFSS3r_t;
#define RX_X4_SKEW_OFFSS3r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_CLR
#define RX_X4_SKEW_OFFSS3r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_SET
#define RX_X4_SKEW_OFFSS3r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_GET
#define RX_X4_SKEW_OFFSS3r_DESKEW_TS_INFO_VALID_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_DESKEW_TS_INFO_VALID_3f_GET
#define RX_X4_SKEW_OFFSS3r_DESKEW_TS_INFO_VALID_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_DESKEW_TS_INFO_VALID_3f_SET
#define RX_X4_SKEW_OFFSS3r_AM_TS_FCLK_ADJUST_VALUE_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_TS_FCLK_ADJUST_VALUE_3f_GET
#define RX_X4_SKEW_OFFSS3r_AM_TS_FCLK_ADJUST_VALUE_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_TS_FCLK_ADJUST_VALUE_3f_SET
#define RX_X4_SKEW_OFFSS3r_AM_SLIP_COUNT_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_SLIP_COUNT_3f_GET
#define RX_X4_SKEW_OFFSS3r_AM_SLIP_COUNT_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r_AM_SLIP_COUNT_3f_SET
#define READ_RX_X4_SKEW_OFFSS3r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS3r
#define WRITE_RX_X4_SKEW_OFFSS3r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS3r
#define MODIFY_RX_X4_SKEW_OFFSS3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS3r
#define READLN_RX_X4_SKEW_OFFSS3r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS3r
#define WRITELN_RX_X4_SKEW_OFFSS3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS3r
#define WRITEALL_RX_X4_SKEW_OFFSS3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_SKEW_OFFSS4
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a6
 * DESC:     Rx relative Lane Skew for Virtual lane 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_SLIP_COUNT_4  Offset in bits
 *     AM_TS_FCLK_ADJUST_VALUE_4 Offset in blocks (66b or 80b) within Deskew
 *     DESKEW_TS_INFO_VALID_4 Indicates that the aligment marker based time-stamp info is valid and ready to be accessed by SW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r (0x0000c1a6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SKEW_OFFSS4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_s {
	uint32_t v[1];
	uint32_t rx_x4_skew_offss4[1];
	uint32_t _rx_x4_skew_offss4;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_CLR(r) (r).rx_x4_skew_offss4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_SET(r,d) (r).rx_x4_skew_offss4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_GET(r) (r).rx_x4_skew_offss4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_DESKEW_TS_INFO_VALID_4f_GET(r) ((((r).rx_x4_skew_offss4[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_DESKEW_TS_INFO_VALID_4f_SET(r,f) (r).rx_x4_skew_offss4[0]=(((r).rx_x4_skew_offss4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_TS_FCLK_ADJUST_VALUE_4f_GET(r) ((((r).rx_x4_skew_offss4[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_TS_FCLK_ADJUST_VALUE_4f_SET(r,f) (r).rx_x4_skew_offss4[0]=(((r).rx_x4_skew_offss4[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_SLIP_COUNT_4f_GET(r) (((r).rx_x4_skew_offss4[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_SLIP_COUNT_4f_SET(r,f) (r).rx_x4_skew_offss4[0]=(((r).rx_x4_skew_offss4[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_SKEW_OFFSS4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r,(_r._rx_x4_skew_offss4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r,(_r._rx_x4_skew_offss4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r,(_r._rx_x4_skew_offss4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_skew_offss4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_skew_offss4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SKEW_OFFSS4r BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r
#define RX_X4_SKEW_OFFSS4r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_t RX_X4_SKEW_OFFSS4r_t;
#define RX_X4_SKEW_OFFSS4r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_CLR
#define RX_X4_SKEW_OFFSS4r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_SET
#define RX_X4_SKEW_OFFSS4r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_GET
#define RX_X4_SKEW_OFFSS4r_DESKEW_TS_INFO_VALID_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_DESKEW_TS_INFO_VALID_4f_GET
#define RX_X4_SKEW_OFFSS4r_DESKEW_TS_INFO_VALID_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_DESKEW_TS_INFO_VALID_4f_SET
#define RX_X4_SKEW_OFFSS4r_AM_TS_FCLK_ADJUST_VALUE_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_TS_FCLK_ADJUST_VALUE_4f_GET
#define RX_X4_SKEW_OFFSS4r_AM_TS_FCLK_ADJUST_VALUE_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_TS_FCLK_ADJUST_VALUE_4f_SET
#define RX_X4_SKEW_OFFSS4r_AM_SLIP_COUNT_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_SLIP_COUNT_4f_GET
#define RX_X4_SKEW_OFFSS4r_AM_SLIP_COUNT_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r_AM_SLIP_COUNT_4f_SET
#define READ_RX_X4_SKEW_OFFSS4r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_SKEW_OFFSS4r
#define WRITE_RX_X4_SKEW_OFFSS4r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_SKEW_OFFSS4r
#define MODIFY_RX_X4_SKEW_OFFSS4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_SKEW_OFFSS4r
#define READLN_RX_X4_SKEW_OFFSS4r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_SKEW_OFFSS4r
#define WRITELN_RX_X4_SKEW_OFFSS4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_SKEW_OFFSS4r
#define WRITEALL_RX_X4_SKEW_OFFSS4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_SKEW_OFFSS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_SKEW_OFFSS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_AM_TS_INFO0
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a7
 * DESC:     Rx relative Lane Skew for Virtual lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_0 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation
 *     BASE_TS_NS_0     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r (0x0000c1a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_AM_TS_INFO0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_s {
	uint32_t v[1];
	uint32_t rx_x4_am_ts_info0[1];
	uint32_t _rx_x4_am_ts_info0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_CLR(r) (r).rx_x4_am_ts_info0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_SET(r,d) (r).rx_x4_am_ts_info0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_GET(r) (r).rx_x4_am_ts_info0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_NS_0f_GET(r) ((((r).rx_x4_am_ts_info0[0]) >> 4) & 0xfff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_NS_0f_SET(r,f) (r).rx_x4_am_ts_info0[0]=(((r).rx_x4_am_ts_info0[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_SUB_NS_0f_GET(r) (((r).rx_x4_am_ts_info0[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_SUB_NS_0f_SET(r,f) (r).rx_x4_am_ts_info0[0]=(((r).rx_x4_am_ts_info0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_AM_TS_INFO0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r,(_r._rx_x4_am_ts_info0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r,(_r._rx_x4_am_ts_info0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r,(_r._rx_x4_am_ts_info0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_am_ts_info0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_AM_TS_INFO0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r
#define RX_X4_AM_TS_INFO0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_t RX_X4_AM_TS_INFO0r_t;
#define RX_X4_AM_TS_INFO0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_CLR
#define RX_X4_AM_TS_INFO0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_SET
#define RX_X4_AM_TS_INFO0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_GET
#define RX_X4_AM_TS_INFO0r_BASE_TS_NS_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_NS_0f_GET
#define RX_X4_AM_TS_INFO0r_BASE_TS_NS_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_NS_0f_SET
#define RX_X4_AM_TS_INFO0r_BASE_TS_SUB_NS_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_SUB_NS_0f_GET
#define RX_X4_AM_TS_INFO0r_BASE_TS_SUB_NS_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r_BASE_TS_SUB_NS_0f_SET
#define READ_RX_X4_AM_TS_INFO0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO0r
#define WRITE_RX_X4_AM_TS_INFO0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO0r
#define MODIFY_RX_X4_AM_TS_INFO0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO0r
#define READLN_RX_X4_AM_TS_INFO0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO0r
#define WRITELN_RX_X4_AM_TS_INFO0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO0r
#define WRITEALL_RX_X4_AM_TS_INFO0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_AM_TS_INFO1
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a8
 * DESC:     Rx relative Lane Skew for Virtual lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_1 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation
 *     BASE_TS_NS_1     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r (0x0000c1a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_AM_TS_INFO1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_s {
	uint32_t v[1];
	uint32_t rx_x4_am_ts_info1[1];
	uint32_t _rx_x4_am_ts_info1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_CLR(r) (r).rx_x4_am_ts_info1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_SET(r,d) (r).rx_x4_am_ts_info1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_GET(r) (r).rx_x4_am_ts_info1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_NS_1f_GET(r) ((((r).rx_x4_am_ts_info1[0]) >> 4) & 0xfff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_NS_1f_SET(r,f) (r).rx_x4_am_ts_info1[0]=(((r).rx_x4_am_ts_info1[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_SUB_NS_1f_GET(r) (((r).rx_x4_am_ts_info1[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_SUB_NS_1f_SET(r,f) (r).rx_x4_am_ts_info1[0]=(((r).rx_x4_am_ts_info1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_AM_TS_INFO1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r,(_r._rx_x4_am_ts_info1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r,(_r._rx_x4_am_ts_info1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r,(_r._rx_x4_am_ts_info1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_am_ts_info1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_AM_TS_INFO1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r
#define RX_X4_AM_TS_INFO1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_t RX_X4_AM_TS_INFO1r_t;
#define RX_X4_AM_TS_INFO1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_CLR
#define RX_X4_AM_TS_INFO1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_SET
#define RX_X4_AM_TS_INFO1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_GET
#define RX_X4_AM_TS_INFO1r_BASE_TS_NS_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_NS_1f_GET
#define RX_X4_AM_TS_INFO1r_BASE_TS_NS_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_NS_1f_SET
#define RX_X4_AM_TS_INFO1r_BASE_TS_SUB_NS_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_SUB_NS_1f_GET
#define RX_X4_AM_TS_INFO1r_BASE_TS_SUB_NS_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r_BASE_TS_SUB_NS_1f_SET
#define READ_RX_X4_AM_TS_INFO1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO1r
#define WRITE_RX_X4_AM_TS_INFO1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO1r
#define MODIFY_RX_X4_AM_TS_INFO1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO1r
#define READLN_RX_X4_AM_TS_INFO1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO1r
#define WRITELN_RX_X4_AM_TS_INFO1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO1r
#define WRITEALL_RX_X4_AM_TS_INFO1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_AM_TS_INFO2
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a9
 * DESC:     Rx relative Lane Skew for Virtual lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_2 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation
 *     BASE_TS_NS_2     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r (0x0000c1a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_AM_TS_INFO2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_s {
	uint32_t v[1];
	uint32_t rx_x4_am_ts_info2[1];
	uint32_t _rx_x4_am_ts_info2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_CLR(r) (r).rx_x4_am_ts_info2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_SET(r,d) (r).rx_x4_am_ts_info2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_GET(r) (r).rx_x4_am_ts_info2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_NS_2f_GET(r) ((((r).rx_x4_am_ts_info2[0]) >> 4) & 0xfff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_NS_2f_SET(r,f) (r).rx_x4_am_ts_info2[0]=(((r).rx_x4_am_ts_info2[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_SUB_NS_2f_GET(r) (((r).rx_x4_am_ts_info2[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_SUB_NS_2f_SET(r,f) (r).rx_x4_am_ts_info2[0]=(((r).rx_x4_am_ts_info2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_AM_TS_INFO2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r,(_r._rx_x4_am_ts_info2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r,(_r._rx_x4_am_ts_info2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r,(_r._rx_x4_am_ts_info2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_am_ts_info2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_AM_TS_INFO2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r
#define RX_X4_AM_TS_INFO2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_t RX_X4_AM_TS_INFO2r_t;
#define RX_X4_AM_TS_INFO2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_CLR
#define RX_X4_AM_TS_INFO2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_SET
#define RX_X4_AM_TS_INFO2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_GET
#define RX_X4_AM_TS_INFO2r_BASE_TS_NS_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_NS_2f_GET
#define RX_X4_AM_TS_INFO2r_BASE_TS_NS_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_NS_2f_SET
#define RX_X4_AM_TS_INFO2r_BASE_TS_SUB_NS_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_SUB_NS_2f_GET
#define RX_X4_AM_TS_INFO2r_BASE_TS_SUB_NS_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r_BASE_TS_SUB_NS_2f_SET
#define READ_RX_X4_AM_TS_INFO2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO2r
#define WRITE_RX_X4_AM_TS_INFO2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO2r
#define MODIFY_RX_X4_AM_TS_INFO2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO2r
#define READLN_RX_X4_AM_TS_INFO2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO2r
#define WRITELN_RX_X4_AM_TS_INFO2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO2r
#define WRITEALL_RX_X4_AM_TS_INFO2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_AM_TS_INFO3
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1aa
 * DESC:     Rx relative Lane Skew for Virtual lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_3 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation
 *     BASE_TS_NS_3     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r (0x0000c1aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_AM_TS_INFO3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_s {
	uint32_t v[1];
	uint32_t rx_x4_am_ts_info3[1];
	uint32_t _rx_x4_am_ts_info3;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_CLR(r) (r).rx_x4_am_ts_info3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_SET(r,d) (r).rx_x4_am_ts_info3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_GET(r) (r).rx_x4_am_ts_info3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_NS_3f_GET(r) ((((r).rx_x4_am_ts_info3[0]) >> 4) & 0xfff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_NS_3f_SET(r,f) (r).rx_x4_am_ts_info3[0]=(((r).rx_x4_am_ts_info3[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_SUB_NS_3f_GET(r) (((r).rx_x4_am_ts_info3[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_SUB_NS_3f_SET(r,f) (r).rx_x4_am_ts_info3[0]=(((r).rx_x4_am_ts_info3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_AM_TS_INFO3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r,(_r._rx_x4_am_ts_info3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r,(_r._rx_x4_am_ts_info3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r,(_r._rx_x4_am_ts_info3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_am_ts_info3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_AM_TS_INFO3r BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r
#define RX_X4_AM_TS_INFO3r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_t RX_X4_AM_TS_INFO3r_t;
#define RX_X4_AM_TS_INFO3r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_CLR
#define RX_X4_AM_TS_INFO3r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_SET
#define RX_X4_AM_TS_INFO3r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_GET
#define RX_X4_AM_TS_INFO3r_BASE_TS_NS_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_NS_3f_GET
#define RX_X4_AM_TS_INFO3r_BASE_TS_NS_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_NS_3f_SET
#define RX_X4_AM_TS_INFO3r_BASE_TS_SUB_NS_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_SUB_NS_3f_GET
#define RX_X4_AM_TS_INFO3r_BASE_TS_SUB_NS_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r_BASE_TS_SUB_NS_3f_SET
#define READ_RX_X4_AM_TS_INFO3r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO3r
#define WRITE_RX_X4_AM_TS_INFO3r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO3r
#define MODIFY_RX_X4_AM_TS_INFO3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO3r
#define READLN_RX_X4_AM_TS_INFO3r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO3r
#define WRITELN_RX_X4_AM_TS_INFO3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO3r
#define WRITEALL_RX_X4_AM_TS_INFO3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_AM_TS_INFO4
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1ab
 * DESC:     Rx relative Lane Skew for Virtual lane 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_4 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation
 *     BASE_TS_NS_4     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r (0x0000c1ab | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_AM_TS_INFO4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_s {
	uint32_t v[1];
	uint32_t rx_x4_am_ts_info4[1];
	uint32_t _rx_x4_am_ts_info4;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_CLR(r) (r).rx_x4_am_ts_info4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_SET(r,d) (r).rx_x4_am_ts_info4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_GET(r) (r).rx_x4_am_ts_info4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_NS_4f_GET(r) ((((r).rx_x4_am_ts_info4[0]) >> 4) & 0xfff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_NS_4f_SET(r,f) (r).rx_x4_am_ts_info4[0]=(((r).rx_x4_am_ts_info4[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_SUB_NS_4f_GET(r) (((r).rx_x4_am_ts_info4[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_SUB_NS_4f_SET(r,f) (r).rx_x4_am_ts_info4[0]=(((r).rx_x4_am_ts_info4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_AM_TS_INFO4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r,(_r._rx_x4_am_ts_info4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r,(_r._rx_x4_am_ts_info4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r,(_r._rx_x4_am_ts_info4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_ts_info4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_am_ts_info4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_AM_TS_INFO4r BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r
#define RX_X4_AM_TS_INFO4r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_t RX_X4_AM_TS_INFO4r_t;
#define RX_X4_AM_TS_INFO4r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_CLR
#define RX_X4_AM_TS_INFO4r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_SET
#define RX_X4_AM_TS_INFO4r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_GET
#define RX_X4_AM_TS_INFO4r_BASE_TS_NS_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_NS_4f_GET
#define RX_X4_AM_TS_INFO4r_BASE_TS_NS_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_NS_4f_SET
#define RX_X4_AM_TS_INFO4r_BASE_TS_SUB_NS_4f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_SUB_NS_4f_GET
#define RX_X4_AM_TS_INFO4r_BASE_TS_SUB_NS_4f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r_BASE_TS_SUB_NS_4f_SET
#define READ_RX_X4_AM_TS_INFO4r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_AM_TS_INFO4r
#define WRITE_RX_X4_AM_TS_INFO4r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_AM_TS_INFO4r
#define MODIFY_RX_X4_AM_TS_INFO4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_AM_TS_INFO4r
#define READLN_RX_X4_AM_TS_INFO4r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_AM_TS_INFO4r
#define WRITELN_RX_X4_AM_TS_INFO4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_AM_TS_INFO4r
#define WRITEALL_RX_X4_AM_TS_INFO4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_AM_TS_INFO4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_AM_TS_INFO4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERR
 * BLOCKS:   RX_X4_TEST_STATUS0
 * REGADDR:  0xc1b0
 * DESC:     CL82 Scrambled IDLE test Error register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_SCRIDLE_TEST_ERR CL82 Scrambled IDLE Test Error counter
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr (0x0000c1b0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_s {
	uint32_t v[1];
	uint32_t rx_x4_test_sts0_cl82_scridle_test_err[1];
	uint32_t _rx_x4_test_sts0_cl82_scridle_test_err;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CLR(r) (r).rx_x4_test_sts0_cl82_scridle_test_err[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_SET(r,d) (r).rx_x4_test_sts0_cl82_scridle_test_err[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_GET(r) (r).rx_x4_test_sts0_cl82_scridle_test_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_GET(r) (((r).rx_x4_test_sts0_cl82_scridle_test_err[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_SET(r,f) (r).rx_x4_test_sts0_cl82_scridle_test_err[0]=(((r).rx_x4_test_sts0_cl82_scridle_test_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr,(_r._rx_x4_test_sts0_cl82_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr,(_r._rx_x4_test_sts0_cl82_scridle_test_err)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr,(_r._rx_x4_test_sts0_cl82_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_test_sts0_cl82_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_test_sts0_cl82_scridle_test_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_test_sts0_cl82_scridle_test_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr
#define RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_t RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_t;
#define RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CLR
#define RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_SET
#define RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_GET
#define RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_GET
#define RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_SET
#define READ_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr
#define WRITE_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr
#define MODIFY_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr
#define READLN_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr
#define WRITELN_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr
#define WRITEALL_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_TEST_STS0_CL82_SCRIDLE_TEST_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_CL73_CFG
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c0
 * DESC:     CL73 Auto Neg Config Reg
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_AN_RESTART  CL73 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL73 AN
 *     CL73_NONCE_MATCH_VAL Clause 73 nonce match value
 *     CL73_NONCE_MATCH_OVER Clause 73 nonce match over-ride
 *     CL73_ENABLE      IEEE CL73 Auto-Negotiation Mode Enable
 *     MSA_FEC_MAPPING  Controls mapping of CL91_REQ_EN and CL74_REQ_EN bits onto the UP-1 page.The 25G/50G MSA places these fields in bits 42 (CL91_REQ_EN) and 43 (CL74_REQ_EN).The BAM mode places these fields in bits 43 (CL91_REQ_EN) and 44 (CL74_REQ_EN).When this bit is a one (1'b1), the MSA bit positions are used.When this bit is a zero (1'b0), the BAM bit positions are used.
 *     CL73_BAM_ENABLE  Broadcom CL73 Auto-Negotiation Mode Enable
 *     NUM_ADVERTISED_LANES Defines the number of lanes that are available via the advertised pagesSW must set this field before enabling AN0: one lane1: two lanes2: four lanes3: eight lanes
 *     DISABLE_REMOTE_FAULT Disable the Remote Fault Reporting
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr (0x0000c1c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_CL73_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_s {
	uint32_t v[1];
	uint32_t an_x4_cl73_cfg[1];
	uint32_t _an_x4_cl73_cfg;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CLR(r) (r).an_x4_cl73_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_SET(r,d) (r).an_x4_cl73_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_GET(r) (r).an_x4_cl73_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 11) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_MSA_FEC_MAPPINGf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_MSA_FEC_MAPPINGf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_GET(r) (((r).an_x4_cl73_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_CL73_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_CL73_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr,(_r._an_x4_cl73_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_CL73_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr,(_r._an_x4_cl73_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_CL73_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr,(_r._an_x4_cl73_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_CL73_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_CL73_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_CL73_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_cl73_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_CL73_CFGr BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr
#define AN_X4_CL73_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_t AN_X4_CL73_CFGr_t;
#define AN_X4_CL73_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CLR
#define AN_X4_CL73_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_SET
#define AN_X4_CL73_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_GET
#define AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_GET
#define AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_SET
#define AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_GET
#define AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_SET
#define AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_GET
#define AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_SET
#define AN_X4_CL73_CFGr_MSA_FEC_MAPPINGf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_MSA_FEC_MAPPINGf_GET
#define AN_X4_CL73_CFGr_MSA_FEC_MAPPINGf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_MSA_FEC_MAPPINGf_SET
#define AN_X4_CL73_CFGr_CL73_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_GET
#define AN_X4_CL73_CFGr_CL73_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_SET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_GET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_SET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_GET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_SET
#define AN_X4_CL73_CFGr_CL73_AN_RESTARTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_GET
#define AN_X4_CL73_CFGr_CL73_AN_RESTARTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_SET
#define READ_AN_X4_CL73_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_CL73_CFGr
#define WRITE_AN_X4_CL73_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_CL73_CFGr
#define MODIFY_AN_X4_CL73_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_CL73_CFGr
#define READLN_AN_X4_CL73_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_CL73_CFGr
#define WRITELN_AN_X4_CL73_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_CL73_CFGr
#define WRITEALL_AN_X4_CL73_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_CL73_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_UP1_ABIL0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c1
 * DESC:     Local Device UP1 ABILITIES REG 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_20G_KR2      UP1 Page Bit 16
 *     BAM_20G_CR2      UP1 Page Bit 17
 *     BAM_40G_KR2      UP1 Page Bit 22
 *     BAM_40G_CR2      UP1 Page Bit 23
 *     BAM_400G_BRCM_FEC_KR8_CR8 UP1 Page Bit 34
 *     BAM_400G_BRCM_NO_FEC_KR8_CR8 UP1 Page Bit 31
 *     BAM_50G_KR2      UP1 Page Bit 24
 *     BAM_50G_CR2      UP1 Page Bit 25
 *     BAM_50G_KR4      UP1 Page Bit 32
 *     BAM_50G_CR4      UP1 Page Bit 33
 *     BAM_50G_BRCM_FEC_528_CR1_KR1 UP1 Page bit 30
 *     BAM_50G_BRCM_NO_FEC_CR1_KR1 UP1 Page bit 29
 *     BAM_50G_BRCM_FEC_544_CR1_KR1 UP1 Page bit 28
 *     SPEED_SPARE_22_MSA_LF2 When used with the MSA OUI, this bit represents the LF2 bit. LF2 is the Low Latency (RS272) FEC Ability Indication, for the IEEE 100G CR2/KR2 PHY type.
 *     SPEED_SPARE_19   UP1 Page bit 27
 *     BAM_50G_BRCM_FEC_544_CR2_KR2 UP1 Page bit 26
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r (0x0000c1c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_UP1_ABIL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_up1_abil0[1];
	uint32_t _an_x4_ld_up1_abil0;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_CLR(r) (r).an_x4_ld_up1_abil0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SET(r,d) (r).an_x4_ld_up1_abil0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_GET(r) (r).an_x4_ld_up1_abil0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR2_KR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR2_KR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_19f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_19f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_22_MSA_LF2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_22_MSA_LF2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR1_KR1f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR1_KR1f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_NO_FEC_CR1_KR1f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_NO_FEC_CR1_KR1f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_528_CR1_KR1f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_528_CR1_KR1f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_NO_FEC_KR8_CR8f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_NO_FEC_KR8_CR8f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_FEC_KR8_CR8f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_FEC_KR8_CR8f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_GET(r) (((r).an_x4_ld_up1_abil0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_UP1_ABIL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r,(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r,(_r._an_x4_ld_up1_abil0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r,(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_UP1_ABIL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_UP1_ABIL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_up1_abil0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_UP1_ABIL0r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r
#define AN_X4_LD_UP1_ABIL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_t AN_X4_LD_UP1_ABIL0r_t;
#define AN_X4_LD_UP1_ABIL0r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_CLR
#define AN_X4_LD_UP1_ABIL0r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SET
#define AN_X4_LD_UP1_ABIL0r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR2_KR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR2_KR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR2_KR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR2_KR2f_SET
#define AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_19f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_19f_GET
#define AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_19f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_19f_SET
#define AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_22_MSA_LF2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_22_MSA_LF2f_GET
#define AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_22_MSA_LF2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_SPEED_SPARE_22_MSA_LF2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR1_KR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR1_KR1f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR1_KR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_544_CR1_KR1f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_NO_FEC_CR1_KR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_NO_FEC_CR1_KR1f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_NO_FEC_CR1_KR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_NO_FEC_CR1_KR1f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_528_CR1_KR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_528_CR1_KR1f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_528_CR1_KR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_BRCM_FEC_528_CR1_KR1f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_NO_FEC_KR8_CR8f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_NO_FEC_KR8_CR8f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_NO_FEC_KR8_CR8f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_NO_FEC_KR8_CR8f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_FEC_KR8_CR8f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_FEC_KR8_CR8f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_FEC_KR8_CR8f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_400G_BRCM_FEC_KR8_CR8f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_SET
#define READ_AN_X4_LD_UP1_ABIL0r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_UP1_ABIL0r
#define WRITE_AN_X4_LD_UP1_ABIL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_UP1_ABIL0r
#define MODIFY_AN_X4_LD_UP1_ABIL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_UP1_ABIL0r
#define READLN_AN_X4_LD_UP1_ABIL0r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_UP1_ABIL0r
#define WRITELN_AN_X4_LD_UP1_ABIL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_UP1_ABIL0r
#define WRITEALL_AN_X4_LD_UP1_ABIL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_UP1_ABIL1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c2
 * DESC:     Local Device UP1 ABILITIES REG 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_20G_KR1      UP1 Page Bit 18
 *     BAM_20G_CR1      UP1 Page Bit 19
 *     BAM_25G_KR1      UP1 Page Bit 20
 *     BAM_25G_CR1      UP1 Page Bit 21
 *     BAM_100G_BRCM_NO_FEC_X4 UP1 Page Bit 46
 *     BAM_100G_BRCM_NO_FEC_KR2_CR2 UP1 Page Bit 45
 *     BAM_100G_BRCM_FEC_528_KR2_CR2_LF3 UP1 Page Bit 39. When used with the MSA OUI, this bit represents the LF3 bit. LF3 is the Low Latency (RS272) FEC. Ability indication, for the IEEE 200G CR4/KR4 PHY type.
 *     BAM_100G_BRCM_KR4_CR4_MSA_LF1 UP1 Page Bit 37. When used with the MSA OUI, this bit represents the LF1 bit. LF1 is the Low Latency (RS272) FEC. Ability indication, for the IEEE 50G CR1/KR1 PHY type
 *     BAM_200G_BRCM_KR4_CR4 UP1 Page Bit 36
 *     BAM_200G_BRCM_NO_FEC_KR4_CR4 UP1 Page Bit 35
 *     MSA_LFR          When used with the MSA OUI, and when the MSA_Fec_Mapping control is set to 1'b1, meaning the MSA Mapping are used, this bit represents the LFR bit. LFR is the Low Latency (RS272) FEC request bit.
 *     RS_FEC_REQ       UP1 RS_FEC request and enable for 25/50G MSA upper bit is for request of RS_FEC and lower is to enable LD's RS_FEC
 *     CL74_REQ         UP1 CL74 request and enable for 25/50G MSA upper bit is for request of CL74 and lower is to enable LD's CL74
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r (0x0000c1c2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_UP1_ABIL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_up1_abil1[1];
	uint32_t _an_x4_ld_up1_abil1;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_CLR(r) (r).an_x4_ld_up1_abil1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_SET(r,d) (r).an_x4_ld_up1_abil1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_GET(r) (r).an_x4_ld_up1_abil1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_RS_FEC_REQf_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_RS_FEC_REQf_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_MSA_LFRf_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_MSA_LFRf_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_NO_FEC_KR4_CR4f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_NO_FEC_KR4_CR4f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_KR4_CR4f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_KR4_CR4f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_KR4_CR4_MSA_LF1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_KR4_CR4_MSA_LF1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_FEC_528_KR2_CR2_LF3f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_FEC_528_KR2_CR2_LF3f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_KR2_CR2f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_KR2_CR2f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_X4f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_X4f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access AN_X4_LD_UP1_ABIL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r,(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r,(_r._an_x4_ld_up1_abil1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r,(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_UP1_ABIL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_UP1_ABIL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_up1_abil1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_UP1_ABIL1r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r
#define AN_X4_LD_UP1_ABIL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_t AN_X4_LD_UP1_ABIL1r_t;
#define AN_X4_LD_UP1_ABIL1r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_CLR
#define AN_X4_LD_UP1_ABIL1r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_SET
#define AN_X4_LD_UP1_ABIL1r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_GET
#define AN_X4_LD_UP1_ABIL1r_CL74_REQf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_GET
#define AN_X4_LD_UP1_ABIL1r_CL74_REQf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_SET
#define AN_X4_LD_UP1_ABIL1r_RS_FEC_REQf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_RS_FEC_REQf_GET
#define AN_X4_LD_UP1_ABIL1r_RS_FEC_REQf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_RS_FEC_REQf_SET
#define AN_X4_LD_UP1_ABIL1r_MSA_LFRf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_MSA_LFRf_GET
#define AN_X4_LD_UP1_ABIL1r_MSA_LFRf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_MSA_LFRf_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_NO_FEC_KR4_CR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_NO_FEC_KR4_CR4f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_NO_FEC_KR4_CR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_NO_FEC_KR4_CR4f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_KR4_CR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_KR4_CR4f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_KR4_CR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_200G_BRCM_KR4_CR4f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_KR4_CR4_MSA_LF1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_KR4_CR4_MSA_LF1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_KR4_CR4_MSA_LF1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_KR4_CR4_MSA_LF1f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_FEC_528_KR2_CR2_LF3f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_FEC_528_KR2_CR2_LF3f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_FEC_528_KR2_CR2_LF3f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_FEC_528_KR2_CR2_LF3f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_KR2_CR2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_KR2_CR2f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_KR2_CR2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_KR2_CR2f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_X4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_X4f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_X4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_100G_BRCM_NO_FEC_X4f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_SET
#define READ_AN_X4_LD_UP1_ABIL1r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_UP1_ABIL1r
#define WRITE_AN_X4_LD_UP1_ABIL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_UP1_ABIL1r
#define MODIFY_AN_X4_LD_UP1_ABIL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_UP1_ABIL1r
#define READLN_AN_X4_LD_UP1_ABIL1r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_UP1_ABIL1r
#define WRITELN_AN_X4_LD_UP1_ABIL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_UP1_ABIL1r
#define WRITEALL_AN_X4_LD_UP1_ABIL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_UP1_ABIL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c3
 * DESC:     Local Device BASE ABILITIES REG 0
 * RESETVAL: 0x2a1 (673)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_BASE_SELECTOR IEEE Annex 28A Message SelectorSent in CL73 base page.
 *     TX_NONCE         First CL73 nonce to be transmitted.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r (0x0000c1c3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil0[1];
	uint32_t _an_x4_ld_base_abil0;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_CLR(r) (r).an_x4_ld_base_abil0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_SET(r,d) (r).an_x4_ld_base_abil0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_GET(r) (r).an_x4_ld_base_abil0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_GET(r) ((((r).an_x4_ld_base_abil0[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_SET(r,f) (r).an_x4_ld_base_abil0[0]=(((r).an_x4_ld_base_abil0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_GET(r) (((r).an_x4_ld_base_abil0[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_SET(r,f) (r).an_x4_ld_base_abil0[0]=(((r).an_x4_ld_base_abil0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r,(_r._an_x4_ld_base_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r,(_r._an_x4_ld_base_abil0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r,(_r._an_x4_ld_base_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL0r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r
#define AN_X4_LD_BASE_ABIL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_t AN_X4_LD_BASE_ABIL0r_t;
#define AN_X4_LD_BASE_ABIL0r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_CLR
#define AN_X4_LD_BASE_ABIL0r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_SET
#define AN_X4_LD_BASE_ABIL0r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_GET
#define AN_X4_LD_BASE_ABIL0r_TX_NONCEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_GET
#define AN_X4_LD_BASE_ABIL0r_TX_NONCEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_SET
#define AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_GET
#define AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_SET
#define READ_AN_X4_LD_BASE_ABIL0r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL0r
#define WRITE_AN_X4_LD_BASE_ABIL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL0r
#define MODIFY_AN_X4_LD_BASE_ABIL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL0r
#define READLN_AN_X4_LD_BASE_ABIL0r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL0r
#define WRITELN_AN_X4_LD_BASE_ABIL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL0r
#define WRITEALL_AN_X4_LD_BASE_ABIL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c4
 * DESC:     Local Device BASE ABILITIES REG 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_10G_KR1     Base Page Bit A2
 *     BASE_40G_KR4     Base page Bit A3
 *     BASE_40G_CR4     Base Page Bit A4
 *     BASE_100G_KR4    Base Page Bit A7
 *     BASE_100G_CR4    Base Page Bit A8
 *     CL73_PAUSE       Pause Ability[7:6]
 *     FEC_REQ          Forward Error CorrectionThese represent Base Page Bits F1:F0If neither device requests FEC, then FEC is not done.
 *     NEXT_PAGE        Next Page ability bit.
 *     CL73_REMOTE_FAULT CL73 AN Advertisement Register (7.16.13) Remote Fault field.Specifies whether the Remote Fault field should be set in the CL73 base pages that are transmitted.0 = no fault1 = fault
 *     BASE_25G_BASE_R_FEC_REQ Base Page Bit F3
 *     BASE_25G_RS_FEC_REQ Base Page Bit F2
 *     BASE_25G_CR_KR   Base Page Bit A10
 *     BASE_25G_CRS_KRS Base Page Bit A9
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r (0x0000c1c4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil1[1];
	uint32_t _an_x4_ld_base_abil1;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CLR(r) (r).an_x4_ld_base_abil1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_SET(r,d) (r).an_x4_ld_base_abil1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_GET(r) (r).an_x4_ld_base_abil1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CRS_KRSf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CRS_KRSf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CR_KRf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CR_KRf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_RS_FEC_REQf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_RS_FEC_REQf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_BASE_R_FEC_REQf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_BASE_R_FEC_REQf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 6) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_GET(r) (((r).an_x4_ld_base_abil1[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r,(_r._an_x4_ld_base_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r,(_r._an_x4_ld_base_abil1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r,(_r._an_x4_ld_base_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL1r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r
#define AN_X4_LD_BASE_ABIL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_t AN_X4_LD_BASE_ABIL1r_t;
#define AN_X4_LD_BASE_ABIL1r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CLR
#define AN_X4_LD_BASE_ABIL1r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_SET
#define AN_X4_LD_BASE_ABIL1r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_CRS_KRSf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CRS_KRSf_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_CRS_KRSf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CRS_KRSf_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_CR_KRf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CR_KRf_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_CR_KRf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_CR_KRf_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_RS_FEC_REQf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_RS_FEC_REQf_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_RS_FEC_REQf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_RS_FEC_REQf_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_BASE_R_FEC_REQf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_BASE_R_FEC_REQf_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_25G_BASE_R_FEC_REQf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_25G_BASE_R_FEC_REQf_SET
#define AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_GET
#define AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_SET
#define AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_GET
#define AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_SET
#define AN_X4_LD_BASE_ABIL1r_FEC_REQf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_GET
#define AN_X4_LD_BASE_ABIL1r_FEC_REQf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_SET
#define AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_GET
#define AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_SET
#define READ_AN_X4_LD_BASE_ABIL1r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL1r
#define WRITE_AN_X4_LD_BASE_ABIL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL1r
#define MODIFY_AN_X4_LD_BASE_ABIL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL1r
#define READLN_AN_X4_LD_BASE_ABIL1r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL1r
#define WRITELN_AN_X4_LD_BASE_ABIL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL1r
#define WRITEALL_AN_X4_LD_BASE_ABIL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c5
 * DESC:     Local Device BAM ABILITIES
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_BAM_CODE    BAM code
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr (0x0000c1c5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BAM_ABIL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_ld_bam_abil[1];
	uint32_t _an_x4_ld_bam_abil;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_CLR(r) (r).an_x4_ld_bam_abil[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_SET(r,d) (r).an_x4_ld_bam_abil[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_GET(r) (r).an_x4_ld_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_GET(r) (((r).an_x4_ld_bam_abil[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_SET(r,f) (r).an_x4_ld_bam_abil[0]=(((r).an_x4_ld_bam_abil[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access AN_X4_LD_BAM_ABIL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr,(_r._an_x4_ld_bam_abil))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr,(_r._an_x4_ld_bam_abil)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr,(_r._an_x4_ld_bam_abil))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BAM_ABILr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_bam_abil))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BAM_ABILr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_bam_abil))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_bam_abil))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BAM_ABILr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr
#define AN_X4_LD_BAM_ABILr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_t AN_X4_LD_BAM_ABILr_t;
#define AN_X4_LD_BAM_ABILr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_CLR
#define AN_X4_LD_BAM_ABILr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_SET
#define AN_X4_LD_BAM_ABILr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_GET
#define AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_GET
#define AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_SET
#define READ_AN_X4_LD_BAM_ABILr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BAM_ABILr
#define WRITE_AN_X4_LD_BAM_ABILr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BAM_ABILr
#define MODIFY_AN_X4_LD_BAM_ABILr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BAM_ABILr
#define READLN_AN_X4_LD_BAM_ABILr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BAM_ABILr
#define WRITELN_AN_X4_LD_BAM_ABILr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BAM_ABILr
#define WRITEALL_AN_X4_LD_BAM_ABILr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BAM_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BAM_ABILr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_CL73_CTLS
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c6
 * DESC:     CL73 AN MISC CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_GOOD_TRAP     Trap the TLA_SEQUENCER in its AN_GOOD state.
 *     AN_GOOD_CHECK_TRAP Trap the TLA_SEQUENCER in its AN_GOOD_CHECK state.
 *     LINKFAILTIMER_DIS Ignore link_fail_inhibit timer.
 *     LINKFAILTIMERQUAL_EN Wait for long enough to link_fail_inhibit_timer to expire.
 *     AN_FAIL_COUNT_LIMIT Number of times AN may retry after AN failureIt indicates the max value of an_fail_count register
 *     LINK_FAIL_INHIBIT_TIMER_MODE Controls the usage of Link Fail Inhibit Timer1'b0: Use Per IEEE CL73.In this mode, the Link Fail Inhibit Timer starts once the HCD is determined.1'b1: Use Per Broadcom proprietary mode.In this mode, the Link Fail Inhibit Timer is used in all stages of AN FSM.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr (0x0000c1c6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_CL73_CTLS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_s {
	uint32_t v[1];
	uint32_t an_x4_cl73_ctls[1];
	uint32_t _an_x4_cl73_ctls;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_CLR(r) (r).an_x4_cl73_ctls[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_SET(r,d) (r).an_x4_cl73_ctls[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_GET(r) (r).an_x4_cl73_ctls[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINK_FAIL_INHIBIT_TIMER_MODEf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINK_FAIL_INHIBIT_TIMER_MODEf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 6) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access AN_X4_CL73_CTLS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_CL73_CTLSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr,(_r._an_x4_cl73_ctls))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_CL73_CTLSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr,(_r._an_x4_cl73_ctls)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_CL73_CTLSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr,(_r._an_x4_cl73_ctls))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_CL73_CTLSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_ctls))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_CL73_CTLSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_ctls))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_CL73_CTLSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_cl73_ctls))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_CL73_CTLSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr
#define AN_X4_CL73_CTLSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_t AN_X4_CL73_CTLSr_t;
#define AN_X4_CL73_CTLSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_CLR
#define AN_X4_CL73_CTLSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_SET
#define AN_X4_CL73_CTLSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_GET
#define AN_X4_CL73_CTLSr_LINK_FAIL_INHIBIT_TIMER_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINK_FAIL_INHIBIT_TIMER_MODEf_GET
#define AN_X4_CL73_CTLSr_LINK_FAIL_INHIBIT_TIMER_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINK_FAIL_INHIBIT_TIMER_MODEf_SET
#define AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_GET
#define AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_SET
#define AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_GET
#define AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_SET
#define AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_GET
#define AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_SET
#define AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_GET
#define AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_SET
#define AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_GET
#define AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_SET
#define READ_AN_X4_CL73_CTLSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_CL73_CTLSr
#define WRITE_AN_X4_CL73_CTLSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_CL73_CTLSr
#define MODIFY_AN_X4_CL73_CTLSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_CL73_CTLSr
#define READLN_AN_X4_CL73_CTLSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_CL73_CTLSr
#define WRITELN_AN_X4_CL73_CTLSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_CL73_CTLSr
#define WRITEALL_AN_X4_CL73_CTLSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_CL73_CTLSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_CL73_CTLSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL2
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c7
 * DESC:     Local Device BASE ABILITIES REG 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_100G_KR2_CR2_EN Enable Base page 100G KR2/CR2 bit position
 *     BASE_100G_KR2_CR2_SEL Base page 100G KR2/CR2 bit position within the Abilities Field of the Base Page
 *     BASE_50G_KR_CR_EN Enable Base page 50G KR/CR bit position
 *     BASE_50G_KR_CR_SEL Base page 50G KR/CR bit position within the Abilities Field of the Base Page
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r (0x0000c1c7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil2[1];
	uint32_t _an_x4_ld_base_abil2;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_CLR(r) (r).an_x4_ld_base_abil2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_SET(r,d) (r).an_x4_ld_base_abil2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_GET(r) (r).an_x4_ld_base_abil2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_SELf_GET(r) ((((r).an_x4_ld_base_abil2[0]) >> 7) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_SELf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_ENf_GET(r) ((((r).an_x4_ld_base_abil2[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_ENf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_SELf_GET(r) ((((r).an_x4_ld_base_abil2[0]) >> 1) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_SELf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_ENf_GET(r) (((r).an_x4_ld_base_abil2[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_ENf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r,(_r._an_x4_ld_base_abil2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r,(_r._an_x4_ld_base_abil2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r,(_r._an_x4_ld_base_abil2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL2r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r
#define AN_X4_LD_BASE_ABIL2r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_t AN_X4_LD_BASE_ABIL2r_t;
#define AN_X4_LD_BASE_ABIL2r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_CLR
#define AN_X4_LD_BASE_ABIL2r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_SET
#define AN_X4_LD_BASE_ABIL2r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_SELf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_SELf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_SELf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_SELf_SET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_ENf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR_CR_ENf_SET
#define AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_SELf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_SELf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_SELf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_SELf_SET
#define AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_ENf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_100G_KR2_CR2_ENf_SET
#define READ_AN_X4_LD_BASE_ABIL2r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL2r
#define WRITE_AN_X4_LD_BASE_ABIL2r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL2r
#define MODIFY_AN_X4_LD_BASE_ABIL2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL2r
#define READLN_AN_X4_LD_BASE_ABIL2r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL2r
#define WRITELN_AN_X4_LD_BASE_ABIL2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL2r
#define WRITEALL_AN_X4_LD_BASE_ABIL2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL3
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c8
 * DESC:     Local Device BASE ABILITIES REG 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_200G_KR4_CR4_EN Enable Base page 200G KR4_CR4 bit position
 *     BASE_200G_KR4_CR4_SEL Base page 200G KR4_CR4 bit position within the Abilities Field of the Base Page
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r (0x0000c1c8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil3[1];
	uint32_t _an_x4_ld_base_abil3;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_CLR(r) (r).an_x4_ld_base_abil3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_SET(r,d) (r).an_x4_ld_base_abil3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_GET(r) (r).an_x4_ld_base_abil3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_SELf_GET(r) ((((r).an_x4_ld_base_abil3[0]) >> 1) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_SELf_SET(r,f) (r).an_x4_ld_base_abil3[0]=(((r).an_x4_ld_base_abil3[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_ENf_GET(r) (((r).an_x4_ld_base_abil3[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_ENf_SET(r,f) (r).an_x4_ld_base_abil3[0]=(((r).an_x4_ld_base_abil3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r,(_r._an_x4_ld_base_abil3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r,(_r._an_x4_ld_base_abil3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r,(_r._an_x4_ld_base_abil3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL3r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r
#define AN_X4_LD_BASE_ABIL3r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_t AN_X4_LD_BASE_ABIL3r_t;
#define AN_X4_LD_BASE_ABIL3r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_CLR
#define AN_X4_LD_BASE_ABIL3r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_SET
#define AN_X4_LD_BASE_ABIL3r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_SELf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_SELf_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_SELf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_SELf_SET
#define AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_ENf_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_200G_KR4_CR4_ENf_SET
#define READ_AN_X4_LD_BASE_ABIL3r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_BASE_ABIL3r
#define WRITE_AN_X4_LD_BASE_ABIL3r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_BASE_ABIL3r
#define MODIFY_AN_X4_LD_BASE_ABIL3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_BASE_ABIL3r
#define READLN_AN_X4_LD_BASE_ABIL3r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_BASE_ABIL3r
#define WRITELN_AN_X4_LD_BASE_ABIL3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_BASE_ABIL3r
#define WRITEALL_AN_X4_LD_BASE_ABIL3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_BASE_ABIL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_SW_AN_BASE_PAGE0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1cb
 * DESC:     SW AN Base Page 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_AN_BP_0       LOCAL DEVICE PAGE 2 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r (0x0000c1cb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_AN_BASE_PAGE0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_an_base_page0[1];
	uint32_t _an_x4_sw_an_base_page0;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_CLR(r) (r).an_x4_sw_an_base_page0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SET(r,d) (r).an_x4_sw_an_base_page0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_GET(r) (r).an_x4_sw_an_base_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_GET(r) (((r).an_x4_sw_an_base_page0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_SET(r,f) (r).an_x4_sw_an_base_page0[0]=(((r).an_x4_sw_an_base_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_SW_AN_BASE_PAGE0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r,(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r,(_r._an_x4_sw_an_base_page0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r,(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_an_base_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r
#define AN_X4_SW_AN_BASE_PAGE0r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_t AN_X4_SW_AN_BASE_PAGE0r_t;
#define AN_X4_SW_AN_BASE_PAGE0r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_CLR
#define AN_X4_SW_AN_BASE_PAGE0r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SET
#define AN_X4_SW_AN_BASE_PAGE0r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_GET
#define AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_GET
#define AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_SET
#define READ_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_AN_BASE_PAGE0r
#define WRITE_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE0r
#define MODIFY_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE0r
#define READLN_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE0r
#define WRITELN_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE0r
#define WRITEALL_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_SW_AN_BASE_PAGE1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1cc
 * DESC:     SW AN Base Page 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_AN_BP_1       LOCAL DEVICE PAGE 1 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r (0x0000c1cc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_AN_BASE_PAGE1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_an_base_page1[1];
	uint32_t _an_x4_sw_an_base_page1;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_CLR(r) (r).an_x4_sw_an_base_page1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SET(r,d) (r).an_x4_sw_an_base_page1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_GET(r) (r).an_x4_sw_an_base_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_GET(r) (((r).an_x4_sw_an_base_page1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_SET(r,f) (r).an_x4_sw_an_base_page1[0]=(((r).an_x4_sw_an_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_SW_AN_BASE_PAGE1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r,(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r,(_r._an_x4_sw_an_base_page1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r,(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_an_base_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r
#define AN_X4_SW_AN_BASE_PAGE1r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_t AN_X4_SW_AN_BASE_PAGE1r_t;
#define AN_X4_SW_AN_BASE_PAGE1r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_CLR
#define AN_X4_SW_AN_BASE_PAGE1r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SET
#define AN_X4_SW_AN_BASE_PAGE1r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_GET
#define AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_GET
#define AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_SET
#define READ_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_AN_BASE_PAGE1r
#define WRITE_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE1r
#define MODIFY_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE1r
#define READLN_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE1r
#define WRITELN_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE1r
#define WRITEALL_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_SW_AN_BASE_PAGE2
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1cd
 * DESC:     SW AN Base Page 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_AN_BP_2       LOCAL DEVICE PAGE 0 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r (0x0000c1cd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_AN_BASE_PAGE2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_an_base_page2[1];
	uint32_t _an_x4_sw_an_base_page2;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_CLR(r) (r).an_x4_sw_an_base_page2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SET(r,d) (r).an_x4_sw_an_base_page2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_GET(r) (r).an_x4_sw_an_base_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_GET(r) (((r).an_x4_sw_an_base_page2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_SET(r,f) (r).an_x4_sw_an_base_page2[0]=(((r).an_x4_sw_an_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_SW_AN_BASE_PAGE2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r,(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r,(_r._an_x4_sw_an_base_page2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r,(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_an_base_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r
#define AN_X4_SW_AN_BASE_PAGE2r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_t AN_X4_SW_AN_BASE_PAGE2r_t;
#define AN_X4_SW_AN_BASE_PAGE2r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_CLR
#define AN_X4_SW_AN_BASE_PAGE2r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SET
#define AN_X4_SW_AN_BASE_PAGE2r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_GET
#define AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_GET
#define AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_SET
#define READ_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_AN_BASE_PAGE2r
#define WRITE_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE2r
#define MODIFY_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE2r
#define READLN_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE2r
#define WRITELN_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE2r
#define WRITEALL_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_AN_BASE_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_R_CL73_STS
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d0
 * DESC:     R_CL73 Status 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DME_STATE        DME Receive State.
 *     DME_PAGE         Valid DME page received.
 *     DME_MV_PAIR      DME Delimiter detected.
 *     CLK_TRANS_MISS   Missing DME clock transition detected.
 *     PAGE_TOO_LONG    Too long DME page detected.
 *     PAGE_TOO_SHORT   Too short DME page detected.
 *     PULSE_TOO_LONG   Too long DME pulse detected.
 *     PULSE_TOO_MODERATE Too moderate DME pulse detected.
 *     PULSE_TOO_SHORT  Too short DME pulse detected.
 *     DME_LOCKED       Locked on DME signal.
 *     CL73_FIFO_FULL   CL73 Fifo Full.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr (0x0000c1d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_R_CL73_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_r_cl73_sts[1];
	uint32_t _an_x4_r_cl73_sts;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CLR(r) (r).an_x4_r_cl73_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_SET(r,d) (r).an_x4_r_cl73_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_GET(r) (r).an_x4_r_cl73_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_GET(r) (((r).an_x4_r_cl73_sts[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X4_R_CL73_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_R_CL73_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr,(_r._an_x4_r_cl73_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_R_CL73_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr,(_r._an_x4_r_cl73_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_R_CL73_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr,(_r._an_x4_r_cl73_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_R_CL73_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_r_cl73_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_R_CL73_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_r_cl73_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_R_CL73_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_r_cl73_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_R_CL73_STSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr
#define AN_X4_R_CL73_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_t AN_X4_R_CL73_STSr_t;
#define AN_X4_R_CL73_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CLR
#define AN_X4_R_CL73_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_SET
#define AN_X4_R_CL73_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_GET
#define AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_GET
#define AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_SET
#define AN_X4_R_CL73_STSr_DME_LOCKEDf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_GET
#define AN_X4_R_CL73_STSr_DME_LOCKEDf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_SET
#define AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_GET
#define AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_SET
#define AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_GET
#define AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_SET
#define AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_GET
#define AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_SET
#define AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_GET
#define AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_SET
#define AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_GET
#define AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_SET
#define AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_GET
#define AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_SET
#define AN_X4_R_CL73_STSr_DME_MV_PAIRf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_GET
#define AN_X4_R_CL73_STSr_DME_MV_PAIRf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_SET
#define AN_X4_R_CL73_STSr_DME_PAGEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_GET
#define AN_X4_R_CL73_STSr_DME_PAGEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_SET
#define AN_X4_R_CL73_STSr_DME_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_GET
#define AN_X4_R_CL73_STSr_DME_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_SET
#define READ_AN_X4_R_CL73_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_R_CL73_STSr
#define WRITE_AN_X4_R_CL73_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_R_CL73_STSr
#define MODIFY_AN_X4_R_CL73_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_R_CL73_STSr
#define READLN_AN_X4_R_CL73_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_R_CL73_STSr
#define WRITELN_AN_X4_R_CL73_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_R_CL73_STSr
#define WRITEALL_AN_X4_R_CL73_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_R_CL73_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_R_CL73_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_PXNG_STS
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d1
 * DESC:     CL73_PXNG Status 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CONSISTENCY_MISMATCH PXNG mismatch detected.
 *     COMPLETE_ACK     PXNG COMPLETE_ACKNOWLEDGE state.
 *     ACK_DETECT       PXNG ACKNOWLEDGE_DETECT state.
 *     ABILITY_DETECT   PXNG ABILITY_DETECT state.
 *     AN_ENABLE        PXNG AN_ENABLE state.
 *     ERROR_STATE      PXNG ERROR state.
 *     TRANSMIT_DISABLE PXNG TRANSMIT_DISABLE state
 *     NEXT_PAGE_WAIT   PXNG NEXT_PAGE_WAIT state.
 *     AN_GOOD_CHECK    PXNG AN_GOOD_CHECK state.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr (0x0000c1d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_PXNG_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_pxng_sts[1];
	uint32_t _an_x4_pxng_sts;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_CLR(r) (r).an_x4_pxng_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_SET(r,d) (r).an_x4_pxng_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_GET(r) (r).an_x4_pxng_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_GET(r) (((r).an_x4_pxng_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_PXNG_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_PXNG_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr,(_r._an_x4_pxng_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_PXNG_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr,(_r._an_x4_pxng_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_PXNG_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr,(_r._an_x4_pxng_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_PXNG_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pxng_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_PXNG_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pxng_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_PXNG_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_pxng_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_PXNG_STSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr
#define AN_X4_PXNG_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_t AN_X4_PXNG_STSr_t;
#define AN_X4_PXNG_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_CLR
#define AN_X4_PXNG_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_SET
#define AN_X4_PXNG_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_GET
#define AN_X4_PXNG_STSr_AN_GOOD_CHECKf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_GET
#define AN_X4_PXNG_STSr_AN_GOOD_CHECKf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_SET
#define AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_GET
#define AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_SET
#define AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_GET
#define AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_SET
#define AN_X4_PXNG_STSr_ERROR_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_GET
#define AN_X4_PXNG_STSr_ERROR_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_SET
#define AN_X4_PXNG_STSr_AN_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_GET
#define AN_X4_PXNG_STSr_AN_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_SET
#define AN_X4_PXNG_STSr_ABILITY_DETECTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_GET
#define AN_X4_PXNG_STSr_ABILITY_DETECTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_SET
#define AN_X4_PXNG_STSr_ACK_DETECTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_GET
#define AN_X4_PXNG_STSr_ACK_DETECTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_SET
#define AN_X4_PXNG_STSr_COMPLETE_ACKf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_GET
#define AN_X4_PXNG_STSr_COMPLETE_ACKf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_SET
#define AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_GET
#define AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_SET
#define READ_AN_X4_PXNG_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_PXNG_STSr
#define WRITE_AN_X4_PXNG_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_PXNG_STSr
#define MODIFY_AN_X4_PXNG_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_PXNG_STSr
#define READLN_AN_X4_PXNG_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_PXNG_STSr
#define WRITELN_AN_X4_PXNG_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_PXNG_STSr
#define WRITEALL_AN_X4_PXNG_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_PXNG_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_PXNG_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_PSEQ_STS
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d2
 * DESC:     CL73_PSEQ Status 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     HP_MODE          PSEQ Entered Hewlett-Packard mode.
 *     RX_BP            PSEQ Received base page.
 *     RX_NP            PSEQ Received next page.
 *     RX_MP_NULL       PSEQ Received message page 1.
 *     RX_MP_OUI        PSEQ Received message page 5.
 *     RX_MP_MISMATCH   PSEQ Received mismatching message page.
 *     RX_UP_OUI_MISMATCH PSEQ Received MPS-5 OUI mismatch.
 *     RX_UP_OUI_MATCH  PSEQ Received MPS-5 OUI match.
 *     RX_INVALID_SEQ   PSEQ Received invalid page sequence.
 *     RX_NP_TOGGLE_ERR PSEQ Received NP without T toggling.
 *     CL73_AN_COMPLETE PSEQ CL73 auto-neg is complete.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr (0x0000c1d2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_PSEQ_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_pseq_sts[1];
	uint32_t _an_x4_pseq_sts;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_CLR(r) (r).an_x4_pseq_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_SET(r,d) (r).an_x4_pseq_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_GET(r) (r).an_x4_pseq_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NPf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NPf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_BPf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_BPf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_GET(r) (((r).an_x4_pseq_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_PSEQ_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_PSEQ_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr,(_r._an_x4_pseq_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_PSEQ_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr,(_r._an_x4_pseq_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_PSEQ_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr,(_r._an_x4_pseq_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_PSEQ_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pseq_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_PSEQ_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pseq_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_PSEQ_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_pseq_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_PSEQ_STSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr
#define AN_X4_PSEQ_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_t AN_X4_PSEQ_STSr_t;
#define AN_X4_PSEQ_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_CLR
#define AN_X4_PSEQ_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_SET
#define AN_X4_PSEQ_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_GET
#define AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_GET
#define AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_SET
#define AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_GET
#define AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_SET
#define AN_X4_PSEQ_STSr_RX_INVALID_SEQf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_GET
#define AN_X4_PSEQ_STSr_RX_INVALID_SEQf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_SET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_GET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_SET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_GET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_SET
#define AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_GET
#define AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_SET
#define AN_X4_PSEQ_STSr_RX_MP_OUIf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_GET
#define AN_X4_PSEQ_STSr_RX_MP_OUIf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_SET
#define AN_X4_PSEQ_STSr_RX_MP_NULLf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_GET
#define AN_X4_PSEQ_STSr_RX_MP_NULLf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_SET
#define AN_X4_PSEQ_STSr_RX_NPf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NPf_GET
#define AN_X4_PSEQ_STSr_RX_NPf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_NPf_SET
#define AN_X4_PSEQ_STSr_RX_BPf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_BPf_GET
#define AN_X4_PSEQ_STSr_RX_BPf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_RX_BPf_SET
#define AN_X4_PSEQ_STSr_HP_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_GET
#define AN_X4_PSEQ_STSr_HP_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_SET
#define READ_AN_X4_PSEQ_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_PSEQ_STSr
#define WRITE_AN_X4_PSEQ_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_PSEQ_STSr
#define MODIFY_AN_X4_PSEQ_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_PSEQ_STSr
#define READLN_AN_X4_PSEQ_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_PSEQ_STSr
#define WRITELN_AN_X4_PSEQ_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_PSEQ_STSr
#define WRITEALL_AN_X4_PSEQ_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_PSEQ_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_PSEQ_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_BASE1
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d3
 * DESC:     PSEQ LP Base page 1 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE1         PSEQ LP Base page 1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r (0x0000c1d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base1[1];
	uint32_t _an_x4_lp_base1;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_CLR(r) (r).an_x4_lp_base1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_SET(r,d) (r).an_x4_lp_base1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_GET(r) (r).an_x4_lp_base1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_GET(r) (((r).an_x4_lp_base1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_SET(r,f) (r).an_x4_lp_base1[0]=(((r).an_x4_lp_base1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_BASE1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r,(_r._an_x4_lp_base1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_BASE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r,(_r._an_x4_lp_base1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_BASE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r,(_r._an_x4_lp_base1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_BASE1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_BASE1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_BASE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE1r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r
#define AN_X4_LP_BASE1r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_t AN_X4_LP_BASE1r_t;
#define AN_X4_LP_BASE1r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_CLR
#define AN_X4_LP_BASE1r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_SET
#define AN_X4_LP_BASE1r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_GET
#define AN_X4_LP_BASE1r_LP_BASE1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_GET
#define AN_X4_LP_BASE1r_LP_BASE1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_SET
#define READ_AN_X4_LP_BASE1r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_BASE1r
#define WRITE_AN_X4_LP_BASE1r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_BASE1r
#define MODIFY_AN_X4_LP_BASE1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_BASE1r
#define READLN_AN_X4_LP_BASE1r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_BASE1r
#define WRITELN_AN_X4_LP_BASE1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_BASE1r
#define WRITEALL_AN_X4_LP_BASE1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_BASE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_BASE2
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d4
 * DESC:     PSEQ LP Base page 2 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE2         PSEQ LP Base page 2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r (0x0000c1d4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base2[1];
	uint32_t _an_x4_lp_base2;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_CLR(r) (r).an_x4_lp_base2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_SET(r,d) (r).an_x4_lp_base2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_GET(r) (r).an_x4_lp_base2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_GET(r) (((r).an_x4_lp_base2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_SET(r,f) (r).an_x4_lp_base2[0]=(((r).an_x4_lp_base2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_BASE2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r,(_r._an_x4_lp_base2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_BASE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r,(_r._an_x4_lp_base2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_BASE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r,(_r._an_x4_lp_base2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_BASE2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_BASE2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_BASE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE2r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r
#define AN_X4_LP_BASE2r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_t AN_X4_LP_BASE2r_t;
#define AN_X4_LP_BASE2r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_CLR
#define AN_X4_LP_BASE2r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_SET
#define AN_X4_LP_BASE2r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_GET
#define AN_X4_LP_BASE2r_LP_BASE2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_GET
#define AN_X4_LP_BASE2r_LP_BASE2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_SET
#define READ_AN_X4_LP_BASE2r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_BASE2r
#define WRITE_AN_X4_LP_BASE2r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_BASE2r
#define MODIFY_AN_X4_LP_BASE2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_BASE2r
#define READLN_AN_X4_LP_BASE2r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_BASE2r
#define WRITELN_AN_X4_LP_BASE2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_BASE2r
#define WRITEALL_AN_X4_LP_BASE2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_BASE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_BASE3
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d5
 * DESC:     PSEQ LP Base page 3 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE3         PSEQ LP Base page 3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r (0x0000c1d5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base3[1];
	uint32_t _an_x4_lp_base3;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_CLR(r) (r).an_x4_lp_base3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_SET(r,d) (r).an_x4_lp_base3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_GET(r) (r).an_x4_lp_base3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_GET(r) (((r).an_x4_lp_base3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_SET(r,f) (r).an_x4_lp_base3[0]=(((r).an_x4_lp_base3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_BASE3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r,(_r._an_x4_lp_base3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_BASE3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r,(_r._an_x4_lp_base3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_BASE3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r,(_r._an_x4_lp_base3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_BASE3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_BASE3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_BASE3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE3r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r
#define AN_X4_LP_BASE3r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_t AN_X4_LP_BASE3r_t;
#define AN_X4_LP_BASE3r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_CLR
#define AN_X4_LP_BASE3r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_SET
#define AN_X4_LP_BASE3r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_GET
#define AN_X4_LP_BASE3r_LP_BASE3f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_GET
#define AN_X4_LP_BASE3r_LP_BASE3f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_SET
#define READ_AN_X4_LP_BASE3r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_BASE3r
#define WRITE_AN_X4_LP_BASE3r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_BASE3r
#define MODIFY_AN_X4_LP_BASE3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_BASE3r
#define READLN_AN_X4_LP_BASE3r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_BASE3r
#define WRITELN_AN_X4_LP_BASE3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_BASE3r
#define WRITEALL_AN_X4_LP_BASE3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_BASE3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_BASE3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_MP5_LWR
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d6
 * DESC:     PSEQ LP MP5 Lower 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MP5_15_0         PSEQ LP MP5 Lower 16 bits
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr (0x0000c1d6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP5_LWR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp5_lwr[1];
	uint32_t _an_x4_lp_mp5_lwr;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_CLR(r) (r).an_x4_lp_mp5_lwr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_SET(r,d) (r).an_x4_lp_mp5_lwr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_GET(r) (r).an_x4_lp_mp5_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_MP5_15_0f_GET(r) (((r).an_x4_lp_mp5_lwr[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_MP5_15_0f_SET(r,f) (r).an_x4_lp_mp5_lwr[0]=(((r).an_x4_lp_mp5_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP5_LWR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_MP5_LWRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr,(_r._an_x4_lp_mp5_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_MP5_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr,(_r._an_x4_lp_mp5_lwr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_MP5_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr,(_r._an_x4_lp_mp5_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_MP5_LWRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_MP5_LWRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_MP5_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp5_lwr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP5_LWRr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr
#define AN_X4_LP_MP5_LWRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_t AN_X4_LP_MP5_LWRr_t;
#define AN_X4_LP_MP5_LWRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_CLR
#define AN_X4_LP_MP5_LWRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_SET
#define AN_X4_LP_MP5_LWRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_GET
#define AN_X4_LP_MP5_LWRr_MP5_15_0f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_MP5_15_0f_GET
#define AN_X4_LP_MP5_LWRr_MP5_15_0f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr_MP5_15_0f_SET
#define READ_AN_X4_LP_MP5_LWRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_MP5_LWRr
#define WRITE_AN_X4_LP_MP5_LWRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_MP5_LWRr
#define MODIFY_AN_X4_LP_MP5_LWRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_MP5_LWRr
#define READLN_AN_X4_LP_MP5_LWRr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_MP5_LWRr
#define WRITELN_AN_X4_LP_MP5_LWRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_MP5_LWRr
#define WRITEALL_AN_X4_LP_MP5_LWRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_MP5_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_MP5_MIDDLE
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d7
 * DESC:     PSEQ LP MP5 Middle 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MP5_31_16        PSEQ LP MP5 Middle 16 bits
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr (0x0000c1d7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP5_MIDDLE.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp5_middle[1];
	uint32_t _an_x4_lp_mp5_middle;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_CLR(r) (r).an_x4_lp_mp5_middle[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_SET(r,d) (r).an_x4_lp_mp5_middle[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_GET(r) (r).an_x4_lp_mp5_middle[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_MP5_31_16f_GET(r) (((r).an_x4_lp_mp5_middle[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_MP5_31_16f_SET(r,f) (r).an_x4_lp_mp5_middle[0]=(((r).an_x4_lp_mp5_middle[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP5_MIDDLE.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_MP5_MIDDLEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr,(_r._an_x4_lp_mp5_middle))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_MP5_MIDDLEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr,(_r._an_x4_lp_mp5_middle)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_MP5_MIDDLEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr,(_r._an_x4_lp_mp5_middle))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_MP5_MIDDLEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_middle))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_MP5_MIDDLEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_middle))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_MP5_MIDDLEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp5_middle))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP5_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr
#define AN_X4_LP_MP5_MIDDLEr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_t AN_X4_LP_MP5_MIDDLEr_t;
#define AN_X4_LP_MP5_MIDDLEr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_CLR
#define AN_X4_LP_MP5_MIDDLEr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_SET
#define AN_X4_LP_MP5_MIDDLEr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_GET
#define AN_X4_LP_MP5_MIDDLEr_MP5_31_16f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_MP5_31_16f_GET
#define AN_X4_LP_MP5_MIDDLEr_MP5_31_16f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr_MP5_31_16f_SET
#define READ_AN_X4_LP_MP5_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_MP5_MIDDLEr
#define WRITE_AN_X4_LP_MP5_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_MP5_MIDDLEr
#define MODIFY_AN_X4_LP_MP5_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_MP5_MIDDLEr
#define READLN_AN_X4_LP_MP5_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_MP5_MIDDLEr
#define WRITELN_AN_X4_LP_MP5_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_MP5_MIDDLEr
#define WRITEALL_AN_X4_LP_MP5_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_MP5_MIDDLEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_MIDDLEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_MP5_UPR
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d8
 * DESC:     PSEQ LP MP5 Upper 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MP5_47_16        PSEQ LP MP5 Upper 16 bits
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr (0x0000c1d8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_MP5_UPR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_s {
	uint32_t v[1];
	uint32_t an_x4_lp_mp5_upr[1];
	uint32_t _an_x4_lp_mp5_upr;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_CLR(r) (r).an_x4_lp_mp5_upr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_SET(r,d) (r).an_x4_lp_mp5_upr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_GET(r) (r).an_x4_lp_mp5_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_MP5_47_16f_GET(r) (((r).an_x4_lp_mp5_upr[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_MP5_47_16f_SET(r,f) (r).an_x4_lp_mp5_upr[0]=(((r).an_x4_lp_mp5_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_MP5_UPR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_MP5_UPRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr,(_r._an_x4_lp_mp5_upr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_MP5_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr,(_r._an_x4_lp_mp5_upr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_MP5_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr,(_r._an_x4_lp_mp5_upr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_MP5_UPRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_upr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_MP5_UPRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_mp5_upr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_MP5_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_mp5_upr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_MP5_UPRr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr
#define AN_X4_LP_MP5_UPRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_t AN_X4_LP_MP5_UPRr_t;
#define AN_X4_LP_MP5_UPRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_CLR
#define AN_X4_LP_MP5_UPRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_SET
#define AN_X4_LP_MP5_UPRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_GET
#define AN_X4_LP_MP5_UPRr_MP5_47_16f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_MP5_47_16f_GET
#define AN_X4_LP_MP5_UPRr_MP5_47_16f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr_MP5_47_16f_SET
#define READ_AN_X4_LP_MP5_UPRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_MP5_UPRr
#define WRITE_AN_X4_LP_MP5_UPRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_MP5_UPRr
#define MODIFY_AN_X4_LP_MP5_UPRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_MP5_UPRr
#define READLN_AN_X4_LP_MP5_UPRr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_MP5_UPRr
#define WRITELN_AN_X4_LP_MP5_UPRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_MP5_UPRr
#define WRITEALL_AN_X4_LP_MP5_UPRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_MP5_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_MP5_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_UP_LWR
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d9
 * DESC:     PSEQ LP User Page Lower 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UP_15_0          PSEQ LP User Page Lower 16 bits
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr (0x0000c1d9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_UP_LWR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_s {
	uint32_t v[1];
	uint32_t an_x4_lp_up_lwr[1];
	uint32_t _an_x4_lp_up_lwr;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_CLR(r) (r).an_x4_lp_up_lwr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_SET(r,d) (r).an_x4_lp_up_lwr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_GET(r) (r).an_x4_lp_up_lwr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_UP_15_0f_GET(r) (((r).an_x4_lp_up_lwr[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_UP_15_0f_SET(r,f) (r).an_x4_lp_up_lwr[0]=(((r).an_x4_lp_up_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_UP_LWR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_UP_LWRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr,(_r._an_x4_lp_up_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_UP_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr,(_r._an_x4_lp_up_lwr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_UP_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr,(_r._an_x4_lp_up_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_UP_LWRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_up_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_UP_LWRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_up_lwr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_UP_LWRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_up_lwr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_UP_LWRr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr
#define AN_X4_LP_UP_LWRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_t AN_X4_LP_UP_LWRr_t;
#define AN_X4_LP_UP_LWRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_CLR
#define AN_X4_LP_UP_LWRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_SET
#define AN_X4_LP_UP_LWRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_GET
#define AN_X4_LP_UP_LWRr_UP_15_0f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_UP_15_0f_GET
#define AN_X4_LP_UP_LWRr_UP_15_0f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr_UP_15_0f_SET
#define READ_AN_X4_LP_UP_LWRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_UP_LWRr
#define WRITE_AN_X4_LP_UP_LWRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_UP_LWRr
#define MODIFY_AN_X4_LP_UP_LWRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_UP_LWRr
#define READLN_AN_X4_LP_UP_LWRr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_UP_LWRr
#define WRITELN_AN_X4_LP_UP_LWRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_UP_LWRr
#define WRITEALL_AN_X4_LP_UP_LWRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_UP_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_LWRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_UP_MIDDLE
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1da
 * DESC:     PSEQ LP User Page Middle 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UP_31_16         PSEQ LP User Page Middle 16 bits
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr (0x0000c1da | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_UP_MIDDLE.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_s {
	uint32_t v[1];
	uint32_t an_x4_lp_up_middle[1];
	uint32_t _an_x4_lp_up_middle;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_CLR(r) (r).an_x4_lp_up_middle[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_SET(r,d) (r).an_x4_lp_up_middle[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_GET(r) (r).an_x4_lp_up_middle[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_UP_31_16f_GET(r) (((r).an_x4_lp_up_middle[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_UP_31_16f_SET(r,f) (r).an_x4_lp_up_middle[0]=(((r).an_x4_lp_up_middle[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_UP_MIDDLE.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_UP_MIDDLEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr,(_r._an_x4_lp_up_middle))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_UP_MIDDLEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr,(_r._an_x4_lp_up_middle)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_UP_MIDDLEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr,(_r._an_x4_lp_up_middle))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_UP_MIDDLEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_up_middle))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_UP_MIDDLEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_up_middle))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_UP_MIDDLEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_up_middle))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_UP_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr
#define AN_X4_LP_UP_MIDDLEr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_t AN_X4_LP_UP_MIDDLEr_t;
#define AN_X4_LP_UP_MIDDLEr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_CLR
#define AN_X4_LP_UP_MIDDLEr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_SET
#define AN_X4_LP_UP_MIDDLEr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_GET
#define AN_X4_LP_UP_MIDDLEr_UP_31_16f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_UP_31_16f_GET
#define AN_X4_LP_UP_MIDDLEr_UP_31_16f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr_UP_31_16f_SET
#define READ_AN_X4_LP_UP_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_UP_MIDDLEr
#define WRITE_AN_X4_LP_UP_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_UP_MIDDLEr
#define MODIFY_AN_X4_LP_UP_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_UP_MIDDLEr
#define READLN_AN_X4_LP_UP_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_UP_MIDDLEr
#define WRITELN_AN_X4_LP_UP_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_UP_MIDDLEr
#define WRITEALL_AN_X4_LP_UP_MIDDLEr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_UP_MIDDLEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_MIDDLEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_UP_UPR
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1db
 * DESC:     PSEQ LP User Page Upper 16 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UP_47_32         PSEQ LP User Page Upper 16 bits
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr (0x0000c1db | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_UP_UPR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_s {
	uint32_t v[1];
	uint32_t an_x4_lp_up_upr[1];
	uint32_t _an_x4_lp_up_upr;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_CLR(r) (r).an_x4_lp_up_upr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_SET(r,d) (r).an_x4_lp_up_upr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_GET(r) (r).an_x4_lp_up_upr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_UP_47_32f_GET(r) (((r).an_x4_lp_up_upr[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_UP_47_32f_SET(r,f) (r).an_x4_lp_up_upr[0]=(((r).an_x4_lp_up_upr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_UP_UPR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_UP_UPRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr,(_r._an_x4_lp_up_upr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_UP_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr,(_r._an_x4_lp_up_upr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_UP_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr,(_r._an_x4_lp_up_upr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_UP_UPRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_up_upr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_UP_UPRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_up_upr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_UP_UPRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_up_upr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_UP_UPRr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr
#define AN_X4_LP_UP_UPRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_t AN_X4_LP_UP_UPRr_t;
#define AN_X4_LP_UP_UPRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_CLR
#define AN_X4_LP_UP_UPRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_SET
#define AN_X4_LP_UP_UPRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_GET
#define AN_X4_LP_UP_UPRr_UP_47_32f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_UP_47_32f_GET
#define AN_X4_LP_UP_UPRr_UP_47_32f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr_UP_47_32f_SET
#define READ_AN_X4_LP_UP_UPRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_UP_UPRr
#define WRITE_AN_X4_LP_UP_UPRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_UP_UPRr
#define MODIFY_AN_X4_LP_UP_UPRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_UP_UPRr
#define READLN_AN_X4_LP_UP_UPRr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_UP_UPRr
#define WRITELN_AN_X4_LP_UP_UPRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_UP_UPRr
#define WRITEALL_AN_X4_LP_UP_UPRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_UP_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_UP_UPRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_RES_ERR
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1dc
 * DESC:     RES ERR
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESOLUTION_ERROR RES No common speed/mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr (0x0000c1dc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_RES_ERR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_s {
	uint32_t v[1];
	uint32_t an_x4_res_err[1];
	uint32_t _an_x4_res_err;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_CLR(r) (r).an_x4_res_err[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_SET(r,d) (r).an_x4_res_err[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_GET(r) (r).an_x4_res_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_GET(r) (((r).an_x4_res_err[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_SET(r,f) (r).an_x4_res_err[0]=(((r).an_x4_res_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_RES_ERR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_RES_ERRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr,(_r._an_x4_res_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_RES_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr,(_r._an_x4_res_err)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_RES_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr,(_r._an_x4_res_err))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_RES_ERRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_res_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_RES_ERRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_res_err))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_RES_ERRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_res_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_RES_ERRr BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr
#define AN_X4_RES_ERRr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_t AN_X4_RES_ERRr_t;
#define AN_X4_RES_ERRr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_CLR
#define AN_X4_RES_ERRr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_SET
#define AN_X4_RES_ERRr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_GET
#define AN_X4_RES_ERRr_RESOLUTION_ERRORf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_GET
#define AN_X4_RES_ERRr_RESOLUTION_ERRORf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_SET
#define READ_AN_X4_RES_ERRr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_RES_ERRr
#define WRITE_AN_X4_RES_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_RES_ERRr
#define MODIFY_AN_X4_RES_ERRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_RES_ERRr
#define READLN_AN_X4_RES_ERRr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_RES_ERRr
#define WRITELN_AN_X4_RES_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_RES_ERRr
#define WRITEALL_AN_X4_RES_ERRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_RES_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_RES_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_PAGE2
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e0
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_2        LOCAL DEVICE PAGE 2 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r (0x0000c1e0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page2[1];
	uint32_t _an_x4_ld_page2;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_CLR(r) (r).an_x4_ld_page2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_SET(r,d) (r).an_x4_ld_page2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_GET(r) (r).an_x4_ld_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_GET(r) (((r).an_x4_ld_page2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_SET(r,f) (r).an_x4_ld_page2[0]=(((r).an_x4_ld_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_PAGE2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_PAGE2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_PAGE2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE2r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r
#define AN_X4_LD_PAGE2r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_t AN_X4_LD_PAGE2r_t;
#define AN_X4_LD_PAGE2r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_CLR
#define AN_X4_LD_PAGE2r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_SET
#define AN_X4_LD_PAGE2r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_GET
#define AN_X4_LD_PAGE2r_LD_PAGE_2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_GET
#define AN_X4_LD_PAGE2r_LD_PAGE_2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_SET
#define READ_AN_X4_LD_PAGE2r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_PAGE2r
#define WRITE_AN_X4_LD_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_PAGE2r
#define MODIFY_AN_X4_LD_PAGE2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_PAGE2r
#define READLN_AN_X4_LD_PAGE2r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_PAGE2r
#define WRITELN_AN_X4_LD_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_PAGE2r
#define WRITEALL_AN_X4_LD_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_PAGE1
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e1
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_1        LOCAL DEVICE PAGE 1 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r (0x0000c1e1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page1[1];
	uint32_t _an_x4_ld_page1;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_CLR(r) (r).an_x4_ld_page1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_SET(r,d) (r).an_x4_ld_page1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_GET(r) (r).an_x4_ld_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_GET(r) (((r).an_x4_ld_page1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_SET(r,f) (r).an_x4_ld_page1[0]=(((r).an_x4_ld_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_PAGE1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_PAGE1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_PAGE1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE1r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r
#define AN_X4_LD_PAGE1r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_t AN_X4_LD_PAGE1r_t;
#define AN_X4_LD_PAGE1r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_CLR
#define AN_X4_LD_PAGE1r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_SET
#define AN_X4_LD_PAGE1r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_GET
#define AN_X4_LD_PAGE1r_LD_PAGE_1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_GET
#define AN_X4_LD_PAGE1r_LD_PAGE_1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_SET
#define READ_AN_X4_LD_PAGE1r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_PAGE1r
#define WRITE_AN_X4_LD_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_PAGE1r
#define MODIFY_AN_X4_LD_PAGE1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_PAGE1r
#define READLN_AN_X4_LD_PAGE1r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_PAGE1r
#define WRITELN_AN_X4_LD_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_PAGE1r
#define WRITEALL_AN_X4_LD_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_PAGE0
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e2
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_0        LOCAL DEVICE PAGE 0 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r (0x0000c1e2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page0[1];
	uint32_t _an_x4_ld_page0;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_CLR(r) (r).an_x4_ld_page0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_SET(r,d) (r).an_x4_ld_page0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_GET(r) (r).an_x4_ld_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_GET(r) (((r).an_x4_ld_page0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_SET(r,f) (r).an_x4_ld_page0[0]=(((r).an_x4_ld_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_PAGE0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_PAGE0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_PAGE0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE0r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r
#define AN_X4_LD_PAGE0r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_t AN_X4_LD_PAGE0r_t;
#define AN_X4_LD_PAGE0r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_CLR
#define AN_X4_LD_PAGE0r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_SET
#define AN_X4_LD_PAGE0r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_GET
#define AN_X4_LD_PAGE0r_LD_PAGE_0f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_GET
#define AN_X4_LD_PAGE0r_LD_PAGE_0f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_SET
#define READ_AN_X4_LD_PAGE0r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_PAGE0r
#define WRITE_AN_X4_LD_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_PAGE0r
#define MODIFY_AN_X4_LD_PAGE0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_PAGE0r
#define READLN_AN_X4_LD_PAGE0r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_PAGE0r
#define WRITELN_AN_X4_LD_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_PAGE0r
#define WRITEALL_AN_X4_LD_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_PAGE2
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e3
 * DESC:     LINK PARNTER SW CONTROL PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_2        LINK PARTNER PAGE 2 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r (0x0000c1e3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page2[1];
	uint32_t _an_x4_lp_page2;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_CLR(r) (r).an_x4_lp_page2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_SET(r,d) (r).an_x4_lp_page2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_GET(r) (r).an_x4_lp_page2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_GET(r) (((r).an_x4_lp_page2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_SET(r,f) (r).an_x4_lp_page2[0]=(((r).an_x4_lp_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_PAGE2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_PAGE2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_PAGE2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_PAGE2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE2r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r
#define AN_X4_LP_PAGE2r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_t AN_X4_LP_PAGE2r_t;
#define AN_X4_LP_PAGE2r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_CLR
#define AN_X4_LP_PAGE2r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_SET
#define AN_X4_LP_PAGE2r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_GET
#define AN_X4_LP_PAGE2r_LP_PAGE_2f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_GET
#define AN_X4_LP_PAGE2r_LP_PAGE_2f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_SET
#define READ_AN_X4_LP_PAGE2r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_PAGE2r
#define WRITE_AN_X4_LP_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_PAGE2r
#define MODIFY_AN_X4_LP_PAGE2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_PAGE2r
#define READLN_AN_X4_LP_PAGE2r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_PAGE2r
#define WRITELN_AN_X4_LP_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_PAGE2r
#define WRITEALL_AN_X4_LP_PAGE2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_PAGE1
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e4
 * DESC:     LINK PARNTER SW CONTROL PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_1        LINK PARTNER PAGE 1 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r (0x0000c1e4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page1[1];
	uint32_t _an_x4_lp_page1;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_CLR(r) (r).an_x4_lp_page1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_SET(r,d) (r).an_x4_lp_page1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_GET(r) (r).an_x4_lp_page1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_GET(r) (((r).an_x4_lp_page1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_SET(r,f) (r).an_x4_lp_page1[0]=(((r).an_x4_lp_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_PAGE1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_PAGE1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_PAGE1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_PAGE1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE1r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r
#define AN_X4_LP_PAGE1r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_t AN_X4_LP_PAGE1r_t;
#define AN_X4_LP_PAGE1r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_CLR
#define AN_X4_LP_PAGE1r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_SET
#define AN_X4_LP_PAGE1r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_GET
#define AN_X4_LP_PAGE1r_LP_PAGE_1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_GET
#define AN_X4_LP_PAGE1r_LP_PAGE_1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_SET
#define READ_AN_X4_LP_PAGE1r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_PAGE1r
#define WRITE_AN_X4_LP_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_PAGE1r
#define MODIFY_AN_X4_LP_PAGE1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_PAGE1r
#define READLN_AN_X4_LP_PAGE1r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_PAGE1r
#define WRITELN_AN_X4_LP_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_PAGE1r
#define WRITEALL_AN_X4_LP_PAGE1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LP_PAGE0
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e5
 * DESC:     LINK PARNTER SW CONTROL PAGE 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_0        LINK PARTNER PAGE 0 FIELD
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r (0x0000c1e5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page0[1];
	uint32_t _an_x4_lp_page0;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_CLR(r) (r).an_x4_lp_page0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_SET(r,d) (r).an_x4_lp_page0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_GET(r) (r).an_x4_lp_page0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_GET(r) (((r).an_x4_lp_page0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_SET(r,f) (r).an_x4_lp_page0[0]=(((r).an_x4_lp_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_PAGE0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_PAGE0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_PAGE0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_PAGE0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE0r BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r
#define AN_X4_LP_PAGE0r_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_t AN_X4_LP_PAGE0r_t;
#define AN_X4_LP_PAGE0r_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_CLR
#define AN_X4_LP_PAGE0r_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_SET
#define AN_X4_LP_PAGE0r_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_GET
#define AN_X4_LP_PAGE0r_LP_PAGE_0f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_GET
#define AN_X4_LP_PAGE0r_LP_PAGE_0f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_SET
#define READ_AN_X4_LP_PAGE0r BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LP_PAGE0r
#define WRITE_AN_X4_LP_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LP_PAGE0r
#define MODIFY_AN_X4_LP_PAGE0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LP_PAGE0r
#define READLN_AN_X4_LP_PAGE0r BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LP_PAGE0r
#define WRITELN_AN_X4_LP_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LP_PAGE0r
#define WRITEALL_AN_X4_LP_PAGE0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LP_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LP_PAGE0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_SW_CTL_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e6
 * DESC:     SW CONTROL STATUS INFORMATION
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS1 TLA Lane sequencer fsm latched status cont.
 *     LD_SEQ_RESTART   Set by HW when the CL73 AN FSM enters the TX_DISABLE state.It indicates to SW that it has to restart the page sequence from the base page.Valid when ld_page_req is set.
 *     LP_PAGE_RDY      Set by HW, Clear on Read of lp_page_0
 *     LD_CONTROL_VALID Set by SW write to ld_page_0, Cleared when HW transfers the ld_page'sreflects internal status and used for debug
 *     AN_COMPLETED     All page exchanges have completed
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr (0x0000c1e6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_CTL_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_ctl_sts[1];
	uint32_t _an_x4_sw_ctl_sts;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_CLR(r) (r).an_x4_sw_ctl_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_SET(r,d) (r).an_x4_sw_ctl_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_GET(r) (r).an_x4_sw_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET(r) (((r).an_x4_sw_ctl_sts[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_X4_SW_CTL_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_CTL_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_CTL_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_ctl_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_CTL_STSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr
#define AN_X4_SW_CTL_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_t AN_X4_SW_CTL_STSr_t;
#define AN_X4_SW_CTL_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_CLR
#define AN_X4_SW_CTL_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_SET
#define AN_X4_SW_CTL_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_GET
#define AN_X4_SW_CTL_STSr_AN_COMPLETEDf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_GET
#define AN_X4_SW_CTL_STSr_AN_COMPLETEDf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_SET
#define AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET
#define AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET
#define AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_GET
#define AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_SET
#define AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_GET
#define AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_SET
#define AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET
#define AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET
#define READ_AN_X4_SW_CTL_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_SW_CTL_STSr
#define WRITE_AN_X4_SW_CTL_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_SW_CTL_STSr
#define MODIFY_AN_X4_SW_CTL_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_SW_CTL_STSr
#define READLN_AN_X4_SW_CTL_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_SW_CTL_STSr
#define WRITELN_AN_X4_SW_CTL_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_SW_CTL_STSr
#define WRITEALL_AN_X4_SW_CTL_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_SW_CTL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_SW_CTL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_LD_CTL
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e7
 * DESC:     LOCAL DEVICE CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_HCD_RES_DISABLE Indicates HW does not perform HCD
 *     AN_TYPE_SW       Indicates SW managed AN
 *     SW_AN_SPEED_ID   Speed ID used by SW for the resolved port speed determined fromthe SW AN process.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr (0x0000c1e7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_s {
	uint32_t v[1];
	uint32_t an_x4_ld_ctl[1];
	uint32_t _an_x4_ld_ctl;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_CLR(r) (r).an_x4_ld_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SET(r,d) (r).an_x4_ld_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_GET(r) (r).an_x4_ld_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SW_AN_SPEED_IDf_GET(r) ((((r).an_x4_ld_ctl[0]) >> 2) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SW_AN_SPEED_IDf_SET(r,f) (r).an_x4_ld_ctl[0]=(((r).an_x4_ld_ctl[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_GET(r) ((((r).an_x4_ld_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_SET(r,f) (r).an_x4_ld_ctl[0]=(((r).an_x4_ld_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_GET(r) (((r).an_x4_ld_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_SET(r,f) (r).an_x4_ld_ctl[0]=(((r).an_x4_ld_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_CTLr BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr
#define AN_X4_LD_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_t AN_X4_LD_CTLr_t;
#define AN_X4_LD_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_CLR
#define AN_X4_LD_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SET
#define AN_X4_LD_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_GET
#define AN_X4_LD_CTLr_SW_AN_SPEED_IDf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SW_AN_SPEED_IDf_GET
#define AN_X4_LD_CTLr_SW_AN_SPEED_IDf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_SW_AN_SPEED_IDf_SET
#define AN_X4_LD_CTLr_AN_TYPE_SWf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_GET
#define AN_X4_LD_CTLr_AN_TYPE_SWf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_SET
#define AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_GET
#define AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_SET
#define READ_AN_X4_LD_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_LD_CTLr
#define WRITE_AN_X4_LD_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_LD_CTLr
#define MODIFY_AN_X4_LD_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_LD_CTLr
#define READLN_AN_X4_LD_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_LD_CTLr
#define WRITELN_AN_X4_LD_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_LD_CTLr
#define WRITEALL_AN_X4_LD_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_LD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_LD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_AN_ABIL_RESOLUTION_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e8
 * DESC:     AN ABILITY RESOLUTION INFORMATION
 * RESETVAL: 0xb0 (176)
 * ACCESS:   R/O
 * FIELDS:
 *     AN_HCD_CL72      HCD training ability
 *     AN_HCD_FEC_ARCH  HCD forward-error correction ability
 *     AN_HCD_SPEED     HCD speed
 *     AN_HCD_PAUSE     HCD Pause Ability[11:10]00 - None01 - TX (from LD to LP)10 - RX (from LP to LD)11 - TX/RX (symmetrical)
 *     AN_HCD_DUPLEX    HCD full-duplex ability
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr (0x0000c1e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_ABIL_RESOLUTION_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_abil_resolution_sts[1];
	uint32_t _an_x4_an_abil_resolution_sts;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_CLR(r) (r).an_x4_an_abil_resolution_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SET(r,d) (r).an_x4_an_abil_resolution_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_GET(r) (r).an_x4_an_abil_resolution_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 4) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0xff << 4)) | ((((uint32_t)f) & 0xff) << 4)) | (255 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FEC_ARCHf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 1) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FEC_ARCHf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET(r) (((r).an_x4_an_abil_resolution_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_AN_ABIL_RESOLUTION_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_abil_resolution_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr
#define AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_t AN_X4_AN_ABIL_RESOLUTION_STSr_t;
#define AN_X4_AN_ABIL_RESOLUTION_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_CLR
#define AN_X4_AN_ABIL_RESOLUTION_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FEC_ARCHf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FEC_ARCHf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FEC_ARCHf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FEC_ARCHf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET
#define READ_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr
#define MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr
#define READLN_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_AN_MISC_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e9
 * DESC:     MISCILLANEOUS AN STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AN_FAIL_COUNT    Number of AN retries due to AN failureSaturate, Clear on Read
 *     AN_ACTIVE        Auto-neg in progress
 *     AN_RETRY_COUNT   Number of AN retried for any reason while performing HW-AN (NOT APPLICABLE FOR SW_AN)
 *     AN_COMPLETE      AN Sequencer has completed Auto Neg
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr (0x0000c1e9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_MISC_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_misc_sts[1];
	uint32_t _an_x4_an_misc_sts;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_CLR(r) (r).an_x4_an_misc_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_SET(r,d) (r).an_x4_an_misc_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_GET(r) (r).an_x4_an_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 9) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 2) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))

/*
 * These macros can be used to access AN_X4_AN_MISC_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_AN_MISC_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_misc_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_AN_MISC_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_misc_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_misc_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_MISC_STSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr
#define AN_X4_AN_MISC_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_t AN_X4_AN_MISC_STSr_t;
#define AN_X4_AN_MISC_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_CLR
#define AN_X4_AN_MISC_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_SET
#define AN_X4_AN_MISC_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_GET
#define AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET
#define AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET
#define AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET
#define AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET
#define AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET
#define AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET
#define AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET
#define AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET
#define READ_AN_X4_AN_MISC_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_AN_MISC_STSr
#define WRITE_AN_X4_AN_MISC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_AN_MISC_STSr
#define MODIFY_AN_X4_AN_MISC_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_AN_MISC_STSr
#define READLN_AN_X4_AN_MISC_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_AN_MISC_STSr
#define WRITELN_AN_X4_AN_MISC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_AN_MISC_STSr
#define WRITEALL_AN_X4_AN_MISC_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_AN_MISC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_AN_MISC_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_TLA_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1ea
 * DESC:     TLA SEQUENCER STATUS
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TLA_SEQ_FSM_STATUS TLA Lane sequencer fsm latched statusClear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr (0x0000c1ea | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_TLA_SEQUENCER_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_tla_sequencer_sts[1];
	uint32_t _an_x4_tla_sequencer_sts;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_CLR(r) (r).an_x4_tla_sequencer_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_SET(r,d) (r).an_x4_tla_sequencer_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_GET(r) (r).an_x4_tla_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_GET(r) (((r).an_x4_tla_sequencer_sts[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_SET(r,f) (r).an_x4_tla_sequencer_sts[0]=(((r).an_x4_tla_sequencer_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_TLA_SEQUENCER_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_TLA_SEQUENCER_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_TLA_SEQUENCER_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_tla_sequencer_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_TLA_SEQUENCER_STSr BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr
#define AN_X4_TLA_SEQUENCER_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_t AN_X4_TLA_SEQUENCER_STSr_t;
#define AN_X4_TLA_SEQUENCER_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_CLR
#define AN_X4_TLA_SEQUENCER_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_SET
#define AN_X4_TLA_SEQUENCER_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_GET
#define AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_GET
#define AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_SET
#define READ_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_TLA_SEQUENCER_STSr
#define WRITE_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_TLA_SEQUENCER_STSr
#define MODIFY_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_TLA_SEQUENCER_STSr
#define READLN_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_TLA_SEQUENCER_STSr
#define WRITELN_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_TLA_SEQUENCER_STSr
#define WRITEALL_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_TLA_SEQUENCER_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_TLA_SEQUENCER_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_INT
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1eb
 * DESC:     SW AN and retimer Interrupt
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LP_PAGE_RDY_INT  Link partner's page has been receivedClear on read
 *     AN_COMPLETED_SW_INT S/W AN page exchange completed indicationClear on read
 *     AN_GOOD_CHK_INT  Entry of port in AN Good check state.Clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr (0x0000c1eb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_INT.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_s {
	uint32_t v[1];
	uint32_t an_x4_int[1];
	uint32_t _an_x4_int;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_CLR(r) (r).an_x4_int[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_SET(r,d) (r).an_x4_int[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_GET(r) (r).an_x4_int[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_GET(r) ((((r).an_x4_int[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_SET(r,f) (r).an_x4_int[0]=(((r).an_x4_int[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_GET(r) ((((r).an_x4_int[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_SET(r,f) (r).an_x4_int[0]=(((r).an_x4_int[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_GET(r) (((r).an_x4_int[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_SET(r,f) (r).an_x4_int[0]=(((r).an_x4_int[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_INT.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_INTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr,(_r._an_x4_int))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_INTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr,(_r._an_x4_int)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_INTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr,(_r._an_x4_int))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_INTr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_INTr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_INTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_INTr BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr
#define AN_X4_INTr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_t AN_X4_INTr_t;
#define AN_X4_INTr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_CLR
#define AN_X4_INTr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_SET
#define AN_X4_INTr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_GET
#define AN_X4_INTr_AN_GOOD_CHK_INTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_GET
#define AN_X4_INTr_AN_GOOD_CHK_INTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_SET
#define AN_X4_INTr_AN_COMPLETED_SW_INTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_GET
#define AN_X4_INTr_AN_COMPLETED_SW_INTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_SET
#define AN_X4_INTr_LP_PAGE_RDY_INTf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_GET
#define AN_X4_INTr_LP_PAGE_RDY_INTf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_SET
#define READ_AN_X4_INTr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_INTr
#define WRITE_AN_X4_INTr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_INTr
#define MODIFY_AN_X4_INTr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_INTr
#define READLN_AN_X4_INTr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_INTr
#define WRITELN_AN_X4_INTr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_INTr
#define WRITEALL_AN_X4_INTr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_INTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_INT_EN
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1ec
 * DESC:     SW AN controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LP_PAGE_RDY_EN   Enable Link partner's page has been receivedWriting 1 will enable this interrupt and interrupt is disable by default.
 *     AN_COMPLETED_SW_EN Enable S/W AN page exchange completed indicationWriting 1 will enable this interrupt and interrupt is disable by default.
 *     AN_GOOD_CHK_EN   Enable interrupt when AN enters into AN Good check state.Writing 1 will enable this interrupt and interrupt is disable by default.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr (0x0000c1ec | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_INT_EN.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_s {
	uint32_t v[1];
	uint32_t an_x4_int_en[1];
	uint32_t _an_x4_int_en;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_CLR(r) (r).an_x4_int_en[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_SET(r,d) (r).an_x4_int_en[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_GET(r) (r).an_x4_int_en[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_GET(r) ((((r).an_x4_int_en[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_SET(r,f) (r).an_x4_int_en[0]=(((r).an_x4_int_en[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_GET(r) ((((r).an_x4_int_en[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_SET(r,f) (r).an_x4_int_en[0]=(((r).an_x4_int_en[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_GET(r) (((r).an_x4_int_en[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_SET(r,f) (r).an_x4_int_en[0]=(((r).an_x4_int_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_INT_EN.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_INT_ENr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr,(_r._an_x4_int_en))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_INT_ENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr,(_r._an_x4_int_en)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_INT_ENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr,(_r._an_x4_int_en))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_INT_ENr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int_en))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_INT_ENr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int_en))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_INT_ENr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_int_en))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_INT_ENr BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr
#define AN_X4_INT_ENr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_t AN_X4_INT_ENr_t;
#define AN_X4_INT_ENr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_CLR
#define AN_X4_INT_ENr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_SET
#define AN_X4_INT_ENr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_GET
#define AN_X4_INT_ENr_AN_GOOD_CHK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_GET
#define AN_X4_INT_ENr_AN_GOOD_CHK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_SET
#define AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_GET
#define AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_SET
#define AN_X4_INT_ENr_LP_PAGE_RDY_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_GET
#define AN_X4_INT_ENr_LP_PAGE_RDY_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_SET
#define READ_AN_X4_INT_ENr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_INT_ENr
#define WRITE_AN_X4_INT_ENr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_INT_ENr
#define MODIFY_AN_X4_INT_ENr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_INT_ENr
#define READLN_AN_X4_INT_ENr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_INT_ENr
#define WRITELN_AN_X4_INT_ENr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_INT_ENr
#define WRITEALL_AN_X4_INT_ENr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_INT_ENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_INT_ENr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AN_X4_WAIT_ACK_COMPLETE
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1ed
 * DESC:     Wait for ACK register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     WAIT_FOR_ACK_EN  If this bit is set, then FSM will wait for the send_ack bit to be set by SW.
 *     SEND_ACK         Indicates to HW to send the ACK for the last page. This is set by SW cleared by HW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr (0x0000c1ed | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_WAIT_ACK_COMPLETE.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_s {
	uint32_t v[1];
	uint32_t an_x4_wait_ack_complete[1];
	uint32_t _an_x4_wait_ack_complete;
} BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_CLR(r) (r).an_x4_wait_ack_complete[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SET(r,d) (r).an_x4_wait_ack_complete[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_GET(r) (r).an_x4_wait_ack_complete[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_GET(r) ((((r).an_x4_wait_ack_complete[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_SET(r,f) (r).an_x4_wait_ack_complete[0]=(((r).an_x4_wait_ack_complete[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_GET(r) (((r).an_x4_wait_ack_complete[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_SET(r,f) (r).an_x4_wait_ack_complete[0]=(((r).an_x4_wait_ack_complete[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_WAIT_ACK_COMPLETE.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr,(_r._an_x4_wait_ack_complete))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr,(_r._an_x4_wait_ack_complete)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr,(_r._an_x4_wait_ack_complete))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_WAIT_ACK_COMPLETEr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_wait_ack_complete))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_WAIT_ACK_COMPLETEr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_wait_ack_complete))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_wait_ack_complete))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr
#define AN_X4_WAIT_ACK_COMPLETEr_SIZE BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_t AN_X4_WAIT_ACK_COMPLETEr_t;
#define AN_X4_WAIT_ACK_COMPLETEr_CLR BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_CLR
#define AN_X4_WAIT_ACK_COMPLETEr_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SET
#define AN_X4_WAIT_ACK_COMPLETEr_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_GET
#define AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_GET
#define AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_SET
#define AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_GET
#define AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_SET
#define READ_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCBH_FLEXE_XGXS_READ_AN_X4_WAIT_ACK_COMPLETEr
#define WRITE_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCBH_FLEXE_XGXS_WRITE_AN_X4_WAIT_ACK_COMPLETEr
#define MODIFY_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AN_X4_WAIT_ACK_COMPLETEr
#define READLN_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCBH_FLEXE_XGXS_READLN_AN_X4_WAIT_ACK_COMPLETEr
#define WRITELN_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AN_X4_WAIT_ACK_COMPLETEr
#define WRITEALL_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AN_X4_WAIT_ACK_COMPLETEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AN_X4_WAIT_ACK_COMPLETEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  INTEGER_DIV
 * BLOCKS:   SYNCE_X4
 * REGADDR:  0xc211
 * DESC:     SyncE mode register
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_MODE_STAGE0 syncE stage0 mode control
 *     SYNCE_MODE_STAGE1 syncE stage1 mode control
 */
#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr (0x0000c211 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SIZE 4

/*
 * This structure should be used to declare and program INTEGER_DIV.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_s {
	uint32_t v[1];
	uint32_t integer_div[1];
	uint32_t _integer_div;
} BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_t;

#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_CLR(r) (r).integer_div[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SET(r,d) (r).integer_div[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_GET(r) (r).integer_div[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE1f_GET(r) ((((r).integer_div[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE1f_SET(r,f) (r).integer_div[0]=(((r).integer_div[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE0f_GET(r) (((r).integer_div[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE0f_SET(r,f) (r).integer_div[0]=(((r).integer_div[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access INTEGER_DIV.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_INTEGER_DIVr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr,(_r._integer_div))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_INTEGER_DIVr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr,(_r._integer_div)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_INTEGER_DIVr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr,(_r._integer_div))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_INTEGER_DIVr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._integer_div))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_INTEGER_DIVr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._integer_div))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_INTEGER_DIVr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._integer_div))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define INTEGER_DIVr BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr
#define INTEGER_DIVr_SIZE BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_t INTEGER_DIVr_t;
#define INTEGER_DIVr_CLR BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_CLR
#define INTEGER_DIVr_SET BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SET
#define INTEGER_DIVr_GET BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_GET
#define INTEGER_DIVr_SYNCE_MODE_STAGE1f_GET BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE1f_GET
#define INTEGER_DIVr_SYNCE_MODE_STAGE1f_SET BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE1f_SET
#define INTEGER_DIVr_SYNCE_MODE_STAGE0f_GET BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE0f_GET
#define INTEGER_DIVr_SYNCE_MODE_STAGE0f_SET BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr_SYNCE_MODE_STAGE0f_SET
#define READ_INTEGER_DIVr BCMI_TSCBH_FLEXE_XGXS_READ_INTEGER_DIVr
#define WRITE_INTEGER_DIVr BCMI_TSCBH_FLEXE_XGXS_WRITE_INTEGER_DIVr
#define MODIFY_INTEGER_DIVr BCMI_TSCBH_FLEXE_XGXS_MODIFY_INTEGER_DIVr
#define READLN_INTEGER_DIVr BCMI_TSCBH_FLEXE_XGXS_READLN_INTEGER_DIVr
#define WRITELN_INTEGER_DIVr BCMI_TSCBH_FLEXE_XGXS_WRITELN_INTEGER_DIVr
#define WRITEALL_INTEGER_DIVr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_INTEGER_DIVr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_INTEGER_DIVr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  FRACTIONAL_DIV
 * BLOCKS:   SYNCE_X4
 * REGADDR:  0xc212
 * DESC:     SyncE fractional divisor configuration
 * RESETVAL: 0x14a0 (5280)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_FRACTIONAL_DIVSOR_CFG 
 */
#define BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr (0x0000c212 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SIZE 4

/*
 * This structure should be used to declare and program FRACTIONAL_DIV.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_s {
	uint32_t v[1];
	uint32_t fractional_div[1];
	uint32_t _fractional_div;
} BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_t;

#define BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_CLR(r) (r).fractional_div[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SET(r,d) (r).fractional_div[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_GET(r) (r).fractional_div[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_GET(r) (((r).fractional_div[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_SET(r,f) (r).fractional_div[0]=(((r).fractional_div[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access FRACTIONAL_DIV.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_FRACTIONAL_DIVr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr,(_r._fractional_div))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_FRACTIONAL_DIVr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr,(_r._fractional_div)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_FRACTIONAL_DIVr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr,(_r._fractional_div))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_FRACTIONAL_DIVr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fractional_div))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_FRACTIONAL_DIVr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._fractional_div))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_FRACTIONAL_DIVr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._fractional_div))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define FRACTIONAL_DIVr BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr
#define FRACTIONAL_DIVr_SIZE BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_t FRACTIONAL_DIVr_t;
#define FRACTIONAL_DIVr_CLR BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_CLR
#define FRACTIONAL_DIVr_SET BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SET
#define FRACTIONAL_DIVr_GET BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_GET
#define FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_GET BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_GET
#define FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_SET BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_SET
#define READ_FRACTIONAL_DIVr BCMI_TSCBH_FLEXE_XGXS_READ_FRACTIONAL_DIVr
#define WRITE_FRACTIONAL_DIVr BCMI_TSCBH_FLEXE_XGXS_WRITE_FRACTIONAL_DIVr
#define MODIFY_FRACTIONAL_DIVr BCMI_TSCBH_FLEXE_XGXS_MODIFY_FRACTIONAL_DIVr
#define READLN_FRACTIONAL_DIVr BCMI_TSCBH_FLEXE_XGXS_READLN_FRACTIONAL_DIVr
#define WRITELN_FRACTIONAL_DIVr BCMI_TSCBH_FLEXE_XGXS_WRITELN_FRACTIONAL_DIVr
#define WRITEALL_FRACTIONAL_DIVr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_FRACTIONAL_DIVr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_FRACTIONAL_DIVr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_RXP_STS
 * BLOCKS:   RX_X4_RS_FEC_STATUS0
 * REGADDR:  0xc351
 * DESC:     RS_FEC rxp status indicators
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RESTART_LOCK_LIVE Set by the FEC alignment FSM in the deskew stage to reset the synchronization process on all FEC lanes
 *     RESTART_LOCK_LL  Latched low version of restart_lock_live
 *     RESTART_LOCK_LH  Latched high version of restart_lock_live
 *     FEC_ALIGN_STATUS_LIVE Set when deskew is achieved successfully.
 *     FEC_ALIGN_STATUS_LL Latched low version of fec_align_status_live
 *     FEC_ALIGN_STATUS_LH Latched high version of fec_align_status_live
 *     HI_SER_LIVE      When FEC_bypass_indication_enable is set, this bit is set to 1 if the number of RS-FEC symbol errors in a window of 8192 (or 128) codewords exceeds the threshold (K) and is set to 0 otherwise.
 *     HI_SER_LL        Latched low version of hi_ser_live
 *     HI_SER_LH        Latched high version of hi_ser_live
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr (0x0000c351 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_RXP_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_rxp_sts[1];
	uint32_t _rx_x4_rs_fec_rxp_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_CLR(r) (r).rx_x4_rs_fec_rxp_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_SET(r,d) (r).rx_x4_rs_fec_rxp_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_GET(r) (r).rx_x4_rs_fec_rxp_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LHf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LHf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LLf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LLf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LIVEf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LIVEf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LHf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LHf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LLf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LLf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LHf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LHf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LLf_GET(r) ((((r).rx_x4_rs_fec_rxp_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LLf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LIVEf_GET(r) (((r).rx_x4_rs_fec_rxp_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LIVEf_SET(r,f) (r).rx_x4_rs_fec_rxp_sts[0]=(((r).rx_x4_rs_fec_rxp_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_RXP_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_RXP_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr,(_r._rx_x4_rs_fec_rxp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_RXP_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr,(_r._rx_x4_rs_fec_rxp_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_RXP_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr,(_r._rx_x4_rs_fec_rxp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_RXP_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_rxp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_RXP_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_rxp_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_RXP_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_rxp_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_RXP_STSr BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr
#define RX_X4_RS_FEC_RXP_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_t RX_X4_RS_FEC_RXP_STSr_t;
#define RX_X4_RS_FEC_RXP_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_CLR
#define RX_X4_RS_FEC_RXP_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_SET
#define RX_X4_RS_FEC_RXP_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_GET
#define RX_X4_RS_FEC_RXP_STSr_HI_SER_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LHf_GET
#define RX_X4_RS_FEC_RXP_STSr_HI_SER_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LHf_SET
#define RX_X4_RS_FEC_RXP_STSr_HI_SER_LLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LLf_GET
#define RX_X4_RS_FEC_RXP_STSr_HI_SER_LLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LLf_SET
#define RX_X4_RS_FEC_RXP_STSr_HI_SER_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LIVEf_GET
#define RX_X4_RS_FEC_RXP_STSr_HI_SER_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_HI_SER_LIVEf_SET
#define RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LHf_GET
#define RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LHf_SET
#define RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LLf_GET
#define RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LLf_SET
#define RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_GET
#define RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_SET
#define RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LHf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LHf_GET
#define RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LHf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LHf_SET
#define RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LLf_GET
#define RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LLf_SET
#define RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LIVEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LIVEf_GET
#define RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LIVEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr_RESTART_LOCK_LIVEf_SET
#define READ_RX_X4_RS_FEC_RXP_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_RXP_STSr
#define WRITE_RX_X4_RS_FEC_RXP_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_RXP_STSr
#define MODIFY_RX_X4_RS_FEC_RXP_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_RXP_STSr
#define READLN_RX_X4_RS_FEC_RXP_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_RXP_STSr
#define WRITELN_RX_X4_RS_FEC_RXP_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_RXP_STSr
#define WRITEALL_RX_X4_RS_FEC_RXP_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_RXP_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_RXP_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_CORR_CTR0
 * BLOCKS:   RX_X4_RS_FEC_STATUS0
 * REGADDR:  0xc352
 * DESC:     Lower 16 bits of FEC corrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_FEC_CORR_CW_CNTR_LOWER Lower 16 bits of the RS_FEC FEC corrected code word counter.Counts once for each corrected FEC codeword processed when fec_align_status is true.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r (0x0000c352 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORR_CTR0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corr_ctr0[1];
	uint32_t _rx_x4_fec_corr_ctr0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_CLR(r) (r).rx_x4_fec_corr_ctr0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_SET(r,d) (r).rx_x4_fec_corr_ctr0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_GET(r) (r).rx_x4_fec_corr_ctr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_RS_FEC_FEC_CORR_CW_CNTR_LOWERf_GET(r) (((r).rx_x4_fec_corr_ctr0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_RS_FEC_FEC_CORR_CW_CNTR_LOWERf_SET(r,f) (r).rx_x4_fec_corr_ctr0[0]=(((r).rx_x4_fec_corr_ctr0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORR_CTR0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r,(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r,(_r._rx_x4_fec_corr_ctr0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r,(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORR_CTR0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORR_CTR0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corr_ctr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r
#define RX_X4_FEC_CORR_CTR0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_t RX_X4_FEC_CORR_CTR0r_t;
#define RX_X4_FEC_CORR_CTR0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_CLR
#define RX_X4_FEC_CORR_CTR0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_SET
#define RX_X4_FEC_CORR_CTR0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_GET
#define RX_X4_FEC_CORR_CTR0r_RS_FEC_FEC_CORR_CW_CNTR_LOWERf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_RS_FEC_FEC_CORR_CW_CNTR_LOWERf_GET
#define RX_X4_FEC_CORR_CTR0r_RS_FEC_FEC_CORR_CW_CNTR_LOWERf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r_RS_FEC_FEC_CORR_CW_CNTR_LOWERf_SET
#define READ_RX_X4_FEC_CORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORR_CTR0r
#define WRITE_RX_X4_FEC_CORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORR_CTR0r
#define MODIFY_RX_X4_FEC_CORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORR_CTR0r
#define READLN_RX_X4_FEC_CORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORR_CTR0r
#define WRITELN_RX_X4_FEC_CORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORR_CTR0r
#define WRITEALL_RX_X4_FEC_CORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_CORR_CTR1
 * BLOCKS:   RX_X4_RS_FEC_STATUS0
 * REGADDR:  0xc353
 * DESC:     Upper 16 bits of FEC corrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_FEC_CORR_CW_CNTR_UPPER Upper 16 bits of the RS_FEC FEC corrected code word counter.Read the lower 16 bits firstSaturates on overflow
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r (0x0000c353 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORR_CTR1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corr_ctr1[1];
	uint32_t _rx_x4_fec_corr_ctr1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_CLR(r) (r).rx_x4_fec_corr_ctr1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_SET(r,d) (r).rx_x4_fec_corr_ctr1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_GET(r) (r).rx_x4_fec_corr_ctr1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_RS_FEC_FEC_CORR_CW_CNTR_UPPERf_GET(r) (((r).rx_x4_fec_corr_ctr1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_RS_FEC_FEC_CORR_CW_CNTR_UPPERf_SET(r,f) (r).rx_x4_fec_corr_ctr1[0]=(((r).rx_x4_fec_corr_ctr1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORR_CTR1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r,(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r,(_r._rx_x4_fec_corr_ctr1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r,(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORR_CTR1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORR_CTR1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corr_ctr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r
#define RX_X4_FEC_CORR_CTR1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_t RX_X4_FEC_CORR_CTR1r_t;
#define RX_X4_FEC_CORR_CTR1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_CLR
#define RX_X4_FEC_CORR_CTR1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_SET
#define RX_X4_FEC_CORR_CTR1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_GET
#define RX_X4_FEC_CORR_CTR1r_RS_FEC_FEC_CORR_CW_CNTR_UPPERf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_RS_FEC_FEC_CORR_CW_CNTR_UPPERf_GET
#define RX_X4_FEC_CORR_CTR1r_RS_FEC_FEC_CORR_CW_CNTR_UPPERf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r_RS_FEC_FEC_CORR_CW_CNTR_UPPERf_SET
#define READ_RX_X4_FEC_CORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_CORR_CTR1r
#define WRITE_RX_X4_FEC_CORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_CORR_CTR1r
#define MODIFY_RX_X4_FEC_CORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_CORR_CTR1r
#define READLN_RX_X4_FEC_CORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_CORR_CTR1r
#define WRITELN_RX_X4_FEC_CORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_CORR_CTR1r
#define WRITEALL_RX_X4_FEC_CORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_CORR_CTR1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_UNCORR_CTR0
 * BLOCKS:   RX_X4_RS_FEC_STATUS0
 * REGADDR:  0xc354
 * DESC:     Lower 16 bits of FEC uncorrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_FEC_UNCORR_CW_CNTR_LOWER Lower 16 bits of the RS_FEC FEC uncorrected code word counter.Counts once for each uncorrected FEC codeword processed when fec_align_status is true.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r (0x0000c354 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORR_CTR0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorr_ctr0[1];
	uint32_t _rx_x4_fec_uncorr_ctr0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_CLR(r) (r).rx_x4_fec_uncorr_ctr0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_SET(r,d) (r).rx_x4_fec_uncorr_ctr0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_GET(r) (r).rx_x4_fec_uncorr_ctr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_RS_FEC_FEC_UNCORR_CW_CNTR_LOWERf_GET(r) (((r).rx_x4_fec_uncorr_ctr0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_RS_FEC_FEC_UNCORR_CW_CNTR_LOWERf_SET(r,f) (r).rx_x4_fec_uncorr_ctr0[0]=(((r).rx_x4_fec_uncorr_ctr0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORR_CTR0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r,(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r,(_r._rx_x4_fec_uncorr_ctr0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r,(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORR_CTR0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorr_ctr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r
#define RX_X4_FEC_UNCORR_CTR0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_t RX_X4_FEC_UNCORR_CTR0r_t;
#define RX_X4_FEC_UNCORR_CTR0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_CLR
#define RX_X4_FEC_UNCORR_CTR0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_SET
#define RX_X4_FEC_UNCORR_CTR0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_GET
#define RX_X4_FEC_UNCORR_CTR0r_RS_FEC_FEC_UNCORR_CW_CNTR_LOWERf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_RS_FEC_FEC_UNCORR_CW_CNTR_LOWERf_GET
#define RX_X4_FEC_UNCORR_CTR0r_RS_FEC_FEC_UNCORR_CW_CNTR_LOWERf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r_RS_FEC_FEC_UNCORR_CW_CNTR_LOWERf_SET
#define READ_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORR_CTR0r
#define WRITE_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR0r
#define MODIFY_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR0r
#define READLN_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORR_CTR0r
#define WRITELN_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR0r
#define WRITEALL_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_UNCORR_CTR1
 * BLOCKS:   RX_X4_RS_FEC_STATUS0
 * REGADDR:  0xc355
 * DESC:     Upper 16 bits of FEC uncorrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_FEC_UNCORR_CW_CNTR_UPPER Upper 16 bits of the RS_FEC FEC uncorrected code word counter.Read the lower 16 bits firstSaturates on overflow
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r (0x0000c355 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORR_CTR1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorr_ctr1[1];
	uint32_t _rx_x4_fec_uncorr_ctr1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_CLR(r) (r).rx_x4_fec_uncorr_ctr1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_SET(r,d) (r).rx_x4_fec_uncorr_ctr1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_GET(r) (r).rx_x4_fec_uncorr_ctr1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_RS_FEC_FEC_UNCORR_CW_CNTR_UPPERf_GET(r) (((r).rx_x4_fec_uncorr_ctr1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_RS_FEC_FEC_UNCORR_CW_CNTR_UPPERf_SET(r,f) (r).rx_x4_fec_uncorr_ctr1[0]=(((r).rx_x4_fec_uncorr_ctr1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORR_CTR1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r,(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r,(_r._rx_x4_fec_uncorr_ctr1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r,(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORR_CTR1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorr_ctr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r
#define RX_X4_FEC_UNCORR_CTR1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_t RX_X4_FEC_UNCORR_CTR1r_t;
#define RX_X4_FEC_UNCORR_CTR1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_CLR
#define RX_X4_FEC_UNCORR_CTR1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_SET
#define RX_X4_FEC_UNCORR_CTR1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_GET
#define RX_X4_FEC_UNCORR_CTR1r_RS_FEC_FEC_UNCORR_CW_CNTR_UPPERf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_RS_FEC_FEC_UNCORR_CW_CNTR_UPPERf_GET
#define RX_X4_FEC_UNCORR_CTR1r_RS_FEC_FEC_UNCORR_CW_CNTR_UPPERf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r_RS_FEC_FEC_UNCORR_CW_CNTR_UPPERf_SET
#define READ_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_UNCORR_CTR1r
#define WRITE_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR1r
#define MODIFY_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR1r
#define READLN_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_UNCORR_CTR1r
#define WRITELN_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR1r
#define WRITEALL_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_UNCORR_CTR1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_BIT_ERR_CTR0
 * BLOCKS:   RX_X4_RS_FEC_STATUS0
 * REGADDR:  0xc356
 * DESC:     Lower 16 bits of FEC bit error counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_FEC_CORR_BIT_CNTR_LOWER Counts corrected bits. Accurate only when no uncorrectable errors are present and doesnt count parity bits errors.  Lower 16 bits of the counter.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r (0x0000c356 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BIT_ERR_CTR0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_bit_err_ctr0[1];
	uint32_t _rx_x4_fec_bit_err_ctr0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CLR(r) (r).rx_x4_fec_bit_err_ctr0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SET(r,d) (r).rx_x4_fec_bit_err_ctr0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_GET(r) (r).rx_x4_fec_bit_err_ctr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_RS_FEC_FEC_CORR_BIT_CNTR_LOWERf_GET(r) (((r).rx_x4_fec_bit_err_ctr0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_RS_FEC_FEC_CORR_BIT_CNTR_LOWERf_SET(r,f) (r).rx_x4_fec_bit_err_ctr0[0]=(((r).rx_x4_fec_bit_err_ctr0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BIT_ERR_CTR0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r,(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r,(_r._rx_x4_fec_bit_err_ctr0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r,(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_bit_err_ctr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r
#define RX_X4_FEC_BIT_ERR_CTR0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_t RX_X4_FEC_BIT_ERR_CTR0r_t;
#define RX_X4_FEC_BIT_ERR_CTR0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CLR
#define RX_X4_FEC_BIT_ERR_CTR0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SET
#define RX_X4_FEC_BIT_ERR_CTR0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_GET
#define RX_X4_FEC_BIT_ERR_CTR0r_RS_FEC_FEC_CORR_BIT_CNTR_LOWERf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_RS_FEC_FEC_CORR_BIT_CNTR_LOWERf_GET
#define RX_X4_FEC_BIT_ERR_CTR0r_RS_FEC_FEC_CORR_BIT_CNTR_LOWERf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_RS_FEC_FEC_CORR_BIT_CNTR_LOWERf_SET
#define READ_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR0r
#define WRITE_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR0r
#define MODIFY_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR0r
#define READLN_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR0r
#define WRITELN_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR0r
#define WRITEALL_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_FEC_BIT_ERR_CTR1
 * BLOCKS:   RX_X4_RS_FEC_STATUS0
 * REGADDR:  0xc357
 * DESC:     Upper 16 bits of FEC bit error counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_FEC_CORR_BIT_CNTR_UPPER Upper 16 bits of the RS_FEC FEC error bit counter.Read the lower 16 bits firstSaturates on overflow
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r (0x0000c357 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BIT_ERR_CTR1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_bit_err_ctr1[1];
	uint32_t _rx_x4_fec_bit_err_ctr1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CLR(r) (r).rx_x4_fec_bit_err_ctr1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SET(r,d) (r).rx_x4_fec_bit_err_ctr1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_GET(r) (r).rx_x4_fec_bit_err_ctr1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_RS_FEC_FEC_CORR_BIT_CNTR_UPPERf_GET(r) (((r).rx_x4_fec_bit_err_ctr1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_RS_FEC_FEC_CORR_BIT_CNTR_UPPERf_SET(r,f) (r).rx_x4_fec_bit_err_ctr1[0]=(((r).rx_x4_fec_bit_err_ctr1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BIT_ERR_CTR1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r,(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r,(_r._rx_x4_fec_bit_err_ctr1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r,(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_bit_err_ctr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r
#define RX_X4_FEC_BIT_ERR_CTR1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_t RX_X4_FEC_BIT_ERR_CTR1r_t;
#define RX_X4_FEC_BIT_ERR_CTR1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CLR
#define RX_X4_FEC_BIT_ERR_CTR1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SET
#define RX_X4_FEC_BIT_ERR_CTR1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_GET
#define RX_X4_FEC_BIT_ERR_CTR1r_RS_FEC_FEC_CORR_BIT_CNTR_UPPERf_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_RS_FEC_FEC_CORR_BIT_CNTR_UPPERf_GET
#define RX_X4_FEC_BIT_ERR_CTR1r_RS_FEC_FEC_CORR_BIT_CNTR_UPPERf_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_RS_FEC_FEC_CORR_BIT_CNTR_UPPERf_SET
#define READ_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR1r
#define WRITE_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR1r
#define MODIFY_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR1r
#define READLN_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR1r
#define WRITELN_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR1r
#define WRITEALL_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_FEC_BIT_ERR_CTR1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc360
 * DESC:     RS_FEC FEC symbol error counter lower 16 bits of FEC lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_0 Lower 16 bits of the FEC symbol error counter for FEC lane 0.Counts once for each 10-bit symbol corrected.Per FEC lane counter.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r (0x0000c360 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_low0[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_low0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_low0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_low0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_low0[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_low0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc361
 * DESC:     RS_FEC FEC symbol error counter upper 16 bits of FEC lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_0 Upper 16 bits of the FEC symbol error counter for FEC lane 0.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r (0x0000c361 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_up0[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_up0;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_up0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_up0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_up0[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_up0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc362
 * DESC:     RS_FEC FEC symbol error counter lower 16 bits of FEC lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_1 Lower 16 bits of the FEC symbol error counter for FEC lane 1.Counts once for each 10-bit symbol corrected.Per FEC lane counter.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r (0x0000c362 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_low1[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_low1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_low1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_low1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_low1[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_low1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc363
 * DESC:     RS_FEC FEC symbol error counter upper 16 bits of FEC lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_1 Upper 16 bits of the FEC symbol error counter for FEC lane 1.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r (0x0000c363 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_up1[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_up1;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_up1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_up1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_up1[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc364
 * DESC:     RS_FEC FEC symbol error counter lower 16 bits of FEC lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_2 Lower 16 bits of the FEC symbol error counter for FEC lane 2.Counts once for each 10-bit symbol corrected.Per FEC lane counter.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r (0x0000c364 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_low2[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_low2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_low2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_low2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_low2[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_low2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc365
 * DESC:     RS_FEC FEC symbol error counter upper 16 bits of FEC lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_2 Upper 16 bits of the FEC symbol error counter for FEC lane 2.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r (0x0000c365 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_up2[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_up2;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_up2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_up2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_up2[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc366
 * DESC:     RS_FEC FEC symbol error counter lower 16 bits of FEC lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_3 Lower 16 bits of the FEC symbol error counter for FEC lane 3.Counts once for each 10-bit symbol corrected.Per FEC lane counter.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r (0x0000c366 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_low3[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_low3;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_low3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_low3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_low3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_low3[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_low3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_low3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_low3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_LOW3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3
 * BLOCKS:   RX_X4_RS_FEC_STATUS1
 * REGADDR:  0xc367
 * DESC:     RS_FEC FEC symbol error counter upper 16 bits of FEC lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_3 Upper 16 bits of the FEC symbol error counter for FEC lane 3.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r (0x0000c367 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_s {
	uint32_t v[1];
	uint32_t rx_x4_rs_fec_fec_sym_err_ctr_up3[1];
	uint32_t _rx_x4_rs_fec_fec_sym_err_ctr_up3;
} BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_CLR(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_SET(r,d) (r).rx_x4_rs_fec_fec_sym_err_ctr_up3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_GET(r) (r).rx_x4_rs_fec_fec_sym_err_ctr_up3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_GET(r) (((r).rx_x4_rs_fec_fec_sym_err_ctr_up3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_SET(r,f) (r).rx_x4_rs_fec_fec_sym_err_ctr_up3[0]=(((r).rx_x4_rs_fec_fec_sym_err_ctr_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rs_fec_fec_sym_err_ctr_up3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rs_fec_fec_sym_err_ctr_up3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_t RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_t;
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_CLR BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_CLR
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_SET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_GET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_GET
#define RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_SET BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_SET
#define READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r BCMI_TSCBH_FLEXE_XGXS_READ_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r
#define WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r
#define MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r
#define READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r BCMI_TSCBH_FLEXE_XGXS_READLN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r
#define WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r
#define WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_X4_RS_FEC_FEC_SYM_ERR_CTR_UP3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_PMD_CTL
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x0096
 * DEVAD:    1
 * DESC:     BASE-R PMD control register 150
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINKTRN_IEEE_RESTART_TRAINING 1 = Restart 10GBASE-KR linktrn training0 = Normal operation(self clearing)
 *     LINKTRN_IEEE_TRAINING_ENABLE 1 = Enable the 10GBASE-KR start-up protocol0 = Disable the 10GBASE-KR start-up protocol
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr (0x00010096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_PMD_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_pmd_ctl[1];
	uint32_t _lnktrnit_base_r_pmd_ctl;
} BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_CLR(r) (r).lnktrnit_base_r_pmd_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SET(r,d) (r).lnktrnit_base_r_pmd_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_GET(r) (r).lnktrnit_base_r_pmd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_GET(r) ((((r).lnktrnit_base_r_pmd_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_SET(r,f) (r).lnktrnit_base_r_pmd_ctl[0]=(((r).lnktrnit_base_r_pmd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_GET(r) (((r).lnktrnit_base_r_pmd_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_SET(r,f) (r).lnktrnit_base_r_pmd_ctl[0]=(((r).lnktrnit_base_r_pmd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_PMD_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr,(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr,(_r._lnktrnit_base_r_pmd_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr,(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_pmd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_PMD_CTLr BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr
#define LNKTRNIT_BASE_R_PMD_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_t LNKTRNIT_BASE_R_PMD_CTLr_t;
#define LNKTRNIT_BASE_R_PMD_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_CLR
#define LNKTRNIT_BASE_R_PMD_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_SET
#define LNKTRNIT_BASE_R_PMD_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_GET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_GET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_TRAINING_ENABLEf_SET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_GET
#define LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr_LINKTRN_IEEE_RESTART_TRAININGf_SET
#define READ_LNKTRNIT_BASE_R_PMD_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_PMD_CTLr
#define WRITE_LNKTRNIT_BASE_R_PMD_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_CTLr
#define MODIFY_LNKTRNIT_BASE_R_PMD_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_CTLr
#define READLN_LNKTRNIT_BASE_R_PMD_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_PMD_CTLr
#define WRITELN_LNKTRNIT_BASE_R_PMD_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_CTLr
#define WRITEALL_LNKTRNIT_BASE_R_PMD_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_PMD_STS
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x0097
 * DEVAD:    1
 * DESC:     BASE-R PMD status register 151
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_RECEIVER_STATUS 1 = Receiver trained and ready to receive data0 = Receiver training
 *     LINKTRN_IEEE_FRAME_LOCK 1 = Training frame delineation detected0 = Training frame delineation not detected
 *     LINKTRN_IEEE_TRAINING_STATUS 1 = Start-up protocol in progress0 = Start-up protocol complete
 *     LINKTRN_IEEE_TRAINING_FAILURE 1 = Training failure has been detected0 = Training failure has not been detected
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr (0x00010097 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_PMD_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_pmd_sts[1];
	uint32_t _lnktrnit_base_r_pmd_sts;
} BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_CLR(r) (r).lnktrnit_base_r_pmd_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SET(r,d) (r).lnktrnit_base_r_pmd_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_GET(r) (r).lnktrnit_base_r_pmd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_GET(r) ((((r).lnktrnit_base_r_pmd_sts[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_GET(r) ((((r).lnktrnit_base_r_pmd_sts[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_GET(r) ((((r).lnktrnit_base_r_pmd_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_GET(r) (((r).lnktrnit_base_r_pmd_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_SET(r,f) (r).lnktrnit_base_r_pmd_sts[0]=(((r).lnktrnit_base_r_pmd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_PMD_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr,(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr,(_r._lnktrnit_base_r_pmd_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr,(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_pmd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_pmd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_PMD_STSr BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr
#define LNKTRNIT_BASE_R_PMD_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_t LNKTRNIT_BASE_R_PMD_STSr_t;
#define LNKTRNIT_BASE_R_PMD_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_CLR
#define LNKTRNIT_BASE_R_PMD_STSr_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_SET
#define LNKTRNIT_BASE_R_PMD_STSr_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_FAILUREf_SET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_TRAINING_STATUSf_SET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_FRAME_LOCKf_SET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_GET
#define LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr_LINKTRN_IEEE_RECEIVER_STATUSf_SET
#define READ_LNKTRNIT_BASE_R_PMD_STSr BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_PMD_STSr
#define WRITE_LNKTRNIT_BASE_R_PMD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_PMD_STSr
#define MODIFY_LNKTRNIT_BASE_R_PMD_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_PMD_STSr
#define READLN_LNKTRNIT_BASE_R_PMD_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_PMD_STSr
#define WRITELN_LNKTRNIT_BASE_R_PMD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_PMD_STSr
#define WRITEALL_LNKTRNIT_BASE_R_PMD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_PMD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_PMD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LNKTRNIR_BASE_R_LP_COEFF_UPD
 * BLOCKS:   LINKTRN_IEEE_RX
 * REGADDR:  0x0098
 * DEVAD:    1
 * DESC:     BASE-R LP coeff update register 152
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LP_COEFF_UPDATE This register reflects the first 16-bit Word of the training framemost recently recieived from the Link PartnerThis register is not writeable when linktrn training is disabled asindicated in the IEEE standardlinktrn supports link training for IEEE/OIF/FC standardsPlease see the appropriate standards for register bit definitions.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr (0x00010098 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIR_BASE_R_LP_COEFF_UPD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t lnktrnir_base_r_lp_coeff_upd[1];
	uint32_t _lnktrnir_base_r_lp_coeff_upd;
} BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_CLR(r) (r).lnktrnir_base_r_lp_coeff_upd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SET(r,d) (r).lnktrnir_base_r_lp_coeff_upd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_GET(r) (r).lnktrnir_base_r_lp_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_GET(r) (((r).lnktrnir_base_r_lp_coeff_upd[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_SET(r,f) (r).lnktrnir_base_r_lp_coeff_upd[0]=(((r).lnktrnir_base_r_lp_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIR_BASE_R_LP_COEFF_UPD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr,(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr,(_r._lnktrnir_base_r_lp_coeff_upd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr,(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnir_base_r_lp_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_SIZE BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_t LNKTRNIR_BASE_R_LP_COEFF_UPDr_t;
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_CLR BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_CLR
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_SET
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_GET
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_GET
#define LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr_LINKTRN_IEEE_LP_COEFF_UPDATEf_SET
#define READ_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define WRITE_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define MODIFY_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define READLN_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define WRITELN_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_COEFF_UPDr
#define WRITEALL_LNKTRNIR_BASE_R_LP_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LNKTRNIR_BASE_R_LP_STS_REP
 * BLOCKS:   LINKTRN_IEEE_RX
 * REGADDR:  0x0099
 * DEVAD:    1
 * DESC:     BASE-R LP status report register 153
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LP_STATUS_REPORT This register reflects the second 16-bit Word of the training framemost recently recieived from the Link Partnerlinktrn supports link training for IEEE/OIF/FC standardsPlease see the appropriate standards for register bit definitions.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr (0x00010099 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIR_BASE_R_LP_STS_REP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_s {
	uint32_t v[1];
	uint32_t lnktrnir_base_r_lp_sts_rep[1];
	uint32_t _lnktrnir_base_r_lp_sts_rep;
} BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_CLR(r) (r).lnktrnir_base_r_lp_sts_rep[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SET(r,d) (r).lnktrnir_base_r_lp_sts_rep[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_GET(r) (r).lnktrnir_base_r_lp_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_GET(r) (((r).lnktrnir_base_r_lp_sts_rep[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_SET(r,f) (r).lnktrnir_base_r_lp_sts_rep[0]=(((r).lnktrnir_base_r_lp_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIR_BASE_R_LP_STS_REP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr,(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr,(_r._lnktrnir_base_r_lp_sts_rep)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr,(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnir_base_r_lp_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnir_base_r_lp_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIR_BASE_R_LP_STS_REPr BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr
#define LNKTRNIR_BASE_R_LP_STS_REPr_SIZE BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_t LNKTRNIR_BASE_R_LP_STS_REPr_t;
#define LNKTRNIR_BASE_R_LP_STS_REPr_CLR BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_CLR
#define LNKTRNIR_BASE_R_LP_STS_REPr_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_SET
#define LNKTRNIR_BASE_R_LP_STS_REPr_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_GET
#define LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_GET
#define LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr_LINKTRN_IEEE_LP_STATUS_REPORTf_SET
#define READ_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIR_BASE_R_LP_STS_REPr
#define WRITE_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIR_BASE_R_LP_STS_REPr
#define MODIFY_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIR_BASE_R_LP_STS_REPr
#define READLN_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIR_BASE_R_LP_STS_REPr
#define WRITELN_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIR_BASE_R_LP_STS_REPr
#define WRITEALL_LNKTRNIR_BASE_R_LP_STS_REPr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIR_BASE_R_LP_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LNKTRNIR_BASE_R_LP_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_LD_COEFF_UPD
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x009a
 * DEVAD:    1
 * DESC:     BASE-R LD coeff update register 154
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LD_COEFF_UPDATE This register reflects the first 16-bit Word of the outgoing training framesent by the Local DeviceThis register is not writeablelinktrn supports link training for IEEE/OIF/FC standardsPlease see the appropriate standards for register bit definitions.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr (0x0001009a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_LD_COEFF_UPD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_ld_coeff_upd[1];
	uint32_t _lnktrnit_base_r_ld_coeff_upd;
} BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_CLR(r) (r).lnktrnit_base_r_ld_coeff_upd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SET(r,d) (r).lnktrnit_base_r_ld_coeff_upd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_GET(r) (r).lnktrnit_base_r_ld_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_GET(r) (((r).lnktrnit_base_r_ld_coeff_upd[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_SET(r,f) (r).lnktrnit_base_r_ld_coeff_upd[0]=(((r).lnktrnit_base_r_ld_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_LD_COEFF_UPD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr,(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr,(_r._lnktrnit_base_r_ld_coeff_upd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr,(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_coeff_upd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_ld_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_SIZE BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_t LNKTRNIT_BASE_R_LD_COEFF_UPDr_t;
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_CLR BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_CLR
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_SET
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_GET
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_GET
#define LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr_LINKTRN_IEEE_LD_COEFF_UPDATEf_SET
#define READ_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define WRITE_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define MODIFY_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define READLN_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define WRITELN_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_COEFF_UPDr
#define WRITEALL_LNKTRNIT_BASE_R_LD_COEFF_UPDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LNKTRNIT_BASE_R_LD_STS_REP
 * BLOCKS:   LINKTRN_IEEE_TX
 * REGADDR:  0x009b
 * DEVAD:    1
 * DESC:     BASE-R LD status report register 155
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_IEEE_LD_STATUS_REPORT This register reflects the second 16-bit Word of the outgoing training framesent by the Local Devicelinktrn supports link training for IEEE/OIF/FC standardsPlease see the appropriate standards for register bit definitions.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr (0x0001009b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNIT_BASE_R_LD_STS_REP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_s {
	uint32_t v[1];
	uint32_t lnktrnit_base_r_ld_sts_rep[1];
	uint32_t _lnktrnit_base_r_ld_sts_rep;
} BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_CLR(r) (r).lnktrnit_base_r_ld_sts_rep[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SET(r,d) (r).lnktrnit_base_r_ld_sts_rep[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_GET(r) (r).lnktrnit_base_r_ld_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_GET(r) (((r).lnktrnit_base_r_ld_sts_rep[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_SET(r,f) (r).lnktrnit_base_r_ld_sts_rep[0]=(((r).lnktrnit_base_r_ld_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LNKTRNIT_BASE_R_LD_STS_REP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr,(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr,(_r._lnktrnit_base_r_ld_sts_rep)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr,(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnit_base_r_ld_sts_rep))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnit_base_r_ld_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNIT_BASE_R_LD_STS_REPr BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr
#define LNKTRNIT_BASE_R_LD_STS_REPr_SIZE BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_t LNKTRNIT_BASE_R_LD_STS_REPr_t;
#define LNKTRNIT_BASE_R_LD_STS_REPr_CLR BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_CLR
#define LNKTRNIT_BASE_R_LD_STS_REPr_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_SET
#define LNKTRNIT_BASE_R_LD_STS_REPr_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_GET
#define LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_GET
#define LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr_LINKTRN_IEEE_LD_STATUS_REPORTf_SET
#define READ_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNIT_BASE_R_LD_STS_REPr
#define WRITE_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNIT_BASE_R_LD_STS_REPr
#define MODIFY_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNIT_BASE_R_LD_STS_REPr
#define READLN_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNIT_BASE_R_LD_STS_REPr
#define WRITELN_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNIT_BASE_R_LD_STS_REPr
#define WRITEALL_LNKTRNIT_BASE_R_LD_STS_REPr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNIT_BASE_R_LD_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LNKTRNIT_BASE_R_LD_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP4_AB
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd013
 * DEVAD:    1
 * DESC:     rx_dfe_tap4_ab register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr (0x0001d013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP4_AB.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap4_ab[1];
	uint32_t _dsc_rx_dfe_tap4_ab;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_CLR(r) (r).dsc_rx_dfe_tap4_ab[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_SET(r,d) (r).dsc_rx_dfe_tap4_ab[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_GET(r) (r).dsc_rx_dfe_tap4_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_ab[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_ab[0]=(((r).dsc_rx_dfe_tap4_ab[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_GET(r) (((r).dsc_rx_dfe_tap4_ab[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_ab[0]=(((r).dsc_rx_dfe_tap4_ab[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP4_AB.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr,(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr,(_r._dsc_rx_dfe_tap4_ab)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr,(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP4_ABr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP4_ABr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_ab))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP4_ABr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap4_ab))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP4_ABr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr
#define DSC_RX_DFE_TAP4_ABr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_t DSC_RX_DFE_TAP4_ABr_t;
#define DSC_RX_DFE_TAP4_ABr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_CLR
#define DSC_RX_DFE_TAP4_ABr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_SET
#define DSC_RX_DFE_TAP4_ABr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_GET
#define DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXA_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr_RXB_DFE_TAP4f_SET
#define READ_DSC_RX_DFE_TAP4_ABr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP4_ABr
#define WRITE_DSC_RX_DFE_TAP4_ABr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP4_ABr
#define MODIFY_DSC_RX_DFE_TAP4_ABr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP4_ABr
#define READLN_DSC_RX_DFE_TAP4_ABr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP4_ABr
#define WRITELN_DSC_RX_DFE_TAP4_ABr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP4_ABr
#define WRITEALL_DSC_RX_DFE_TAP4_ABr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP4_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP4_CD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd014
 * DEVAD:    1
 * DESC:     rx_dfe_tap4_cd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP4     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr (0x0001d014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP4_CD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap4_cd[1];
	uint32_t _dsc_rx_dfe_tap4_cd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_CLR(r) (r).dsc_rx_dfe_tap4_cd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_SET(r,d) (r).dsc_rx_dfe_tap4_cd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_GET(r) (r).dsc_rx_dfe_tap4_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_cd[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_cd[0]=(((r).dsc_rx_dfe_tap4_cd[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_GET(r) (((r).dsc_rx_dfe_tap4_cd[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_cd[0]=(((r).dsc_rx_dfe_tap4_cd[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP4_CD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr,(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr,(_r._dsc_rx_dfe_tap4_cd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr,(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP4_CDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP4_CDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_cd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP4_CDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap4_cd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP4_CDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr
#define DSC_RX_DFE_TAP4_CDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_t DSC_RX_DFE_TAP4_CDr_t;
#define DSC_RX_DFE_TAP4_CDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_CLR
#define DSC_RX_DFE_TAP4_CDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_SET
#define DSC_RX_DFE_TAP4_CDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_GET
#define DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXC_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr_RXD_DFE_TAP4f_SET
#define READ_DSC_RX_DFE_TAP4_CDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP4_CDr
#define WRITE_DSC_RX_DFE_TAP4_CDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP4_CDr
#define MODIFY_DSC_RX_DFE_TAP4_CDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP4_CDr
#define READLN_DSC_RX_DFE_TAP4_CDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP4_CDr
#define WRITELN_DSC_RX_DFE_TAP4_CDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP4_CDr
#define WRITEALL_DSC_RX_DFE_TAP4_CDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP4_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP4_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP5_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd015
 * DEVAD:    1
 * DESC:     rx_dfe_tap5_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP5     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr (0x0001d015 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP5_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap5_abcd[1];
	uint32_t _dsc_rx_dfe_tap5_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_CLR(r) (r).dsc_rx_dfe_tap5_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap5_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_GET(r) (r).dsc_rx_dfe_tap5_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET(r) (((r).dsc_rx_dfe_tap5_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP5_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP5_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP5_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap5_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP5_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr
#define DSC_RX_DFE_TAP5_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_t DSC_RX_DFE_TAP5_ABCDr_t;
#define DSC_RX_DFE_TAP5_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_CLR
#define DSC_RX_DFE_TAP5_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_SET
#define DSC_RX_DFE_TAP5_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET
#define READ_DSC_RX_DFE_TAP5_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP5_ABCDr
#define WRITE_DSC_RX_DFE_TAP5_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP5_ABCDr
#define MODIFY_DSC_RX_DFE_TAP5_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP5_ABCDr
#define READLN_DSC_RX_DFE_TAP5_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP5_ABCDr
#define WRITELN_DSC_RX_DFE_TAP5_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP5_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP5_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP5_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP5_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP6_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd016
 * DEVAD:    1
 * DESC:     rx_dfe_tap6_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP6     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr (0x0001d016 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP6_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap6_abcd[1];
	uint32_t _dsc_rx_dfe_tap6_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_CLR(r) (r).dsc_rx_dfe_tap6_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap6_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_GET(r) (r).dsc_rx_dfe_tap6_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET(r) (((r).dsc_rx_dfe_tap6_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP6_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP6_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP6_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap6_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP6_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr
#define DSC_RX_DFE_TAP6_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_t DSC_RX_DFE_TAP6_ABCDr_t;
#define DSC_RX_DFE_TAP6_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_CLR
#define DSC_RX_DFE_TAP6_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_SET
#define DSC_RX_DFE_TAP6_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET
#define READ_DSC_RX_DFE_TAP6_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP6_ABCDr
#define WRITE_DSC_RX_DFE_TAP6_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP6_ABCDr
#define MODIFY_DSC_RX_DFE_TAP6_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP6_ABCDr
#define READLN_DSC_RX_DFE_TAP6_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP6_ABCDr
#define WRITELN_DSC_RX_DFE_TAP6_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP6_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP6_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP6_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP6_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP7_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd017
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP7     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr (0x0001d017 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET(r) (((r).dsc_rx_dfe_tap7_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP7_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP7_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap7_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr
#define DSC_RX_DFE_TAP7_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_t DSC_RX_DFE_TAP7_ABCDr_t;
#define DSC_RX_DFE_TAP7_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_CLR
#define DSC_RX_DFE_TAP7_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_SET
#define DSC_RX_DFE_TAP7_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET
#define READ_DSC_RX_DFE_TAP7_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP7_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP7_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP7_ABCDr
#define READLN_DSC_RX_DFE_TAP7_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP7_ABCDr
#define WRITELN_DSC_RX_DFE_TAP7_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP7_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP7_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP7_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP8_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd018
 * DEVAD:    1
 * DESC:     rx_dfe_tap8_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP8     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr (0x0001d018 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP8_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap8_abcd[1];
	uint32_t _dsc_rx_dfe_tap8_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_CLR(r) (r).dsc_rx_dfe_tap8_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap8_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_GET(r) (r).dsc_rx_dfe_tap8_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET(r) (((r).dsc_rx_dfe_tap8_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP8_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP8_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP8_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap8_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP8_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr
#define DSC_RX_DFE_TAP8_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_t DSC_RX_DFE_TAP8_ABCDr_t;
#define DSC_RX_DFE_TAP8_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_CLR
#define DSC_RX_DFE_TAP8_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_SET
#define DSC_RX_DFE_TAP8_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET
#define READ_DSC_RX_DFE_TAP8_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP8_ABCDr
#define WRITE_DSC_RX_DFE_TAP8_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP8_ABCDr
#define MODIFY_DSC_RX_DFE_TAP8_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP8_ABCDr
#define READLN_DSC_RX_DFE_TAP8_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP8_ABCDr
#define WRITELN_DSC_RX_DFE_TAP8_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP8_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP8_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP8_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP8_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP9_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd019
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP9     signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr (0x0001d019 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET(r) (((r).dsc_rx_dfe_tap9_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP9_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP9_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap9_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr
#define DSC_RX_DFE_TAP9_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_t DSC_RX_DFE_TAP9_ABCDr_t;
#define DSC_RX_DFE_TAP9_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_CLR
#define DSC_RX_DFE_TAP9_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_SET
#define DSC_RX_DFE_TAP9_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET
#define READ_DSC_RX_DFE_TAP9_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP9_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP9_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP9_ABCDr
#define READLN_DSC_RX_DFE_TAP9_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP9_ABCDr
#define WRITELN_DSC_RX_DFE_TAP9_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP9_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP9_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP9_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP10_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd020
 * DEVAD:    1
 * DESC:     rx_dfe_tap10_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP10    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr (0x0001d020 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP10_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap10_abcd[1];
	uint32_t _dsc_rx_dfe_tap10_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_CLR(r) (r).dsc_rx_dfe_tap10_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap10_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_GET(r) (r).dsc_rx_dfe_tap10_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET(r) (((r).dsc_rx_dfe_tap10_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP10_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP10_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP10_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap10_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP10_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr
#define DSC_RX_DFE_TAP10_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_t DSC_RX_DFE_TAP10_ABCDr_t;
#define DSC_RX_DFE_TAP10_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_CLR
#define DSC_RX_DFE_TAP10_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_SET
#define DSC_RX_DFE_TAP10_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET
#define READ_DSC_RX_DFE_TAP10_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP10_ABCDr
#define WRITE_DSC_RX_DFE_TAP10_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP10_ABCDr
#define MODIFY_DSC_RX_DFE_TAP10_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP10_ABCDr
#define READLN_DSC_RX_DFE_TAP10_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP10_ABCDr
#define WRITELN_DSC_RX_DFE_TAP10_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP10_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP10_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP10_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP10_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP11_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd021
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP11    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr (0x0001d021 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET(r) (((r).dsc_rx_dfe_tap11_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP11_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP11_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap11_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr
#define DSC_RX_DFE_TAP11_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_t DSC_RX_DFE_TAP11_ABCDr_t;
#define DSC_RX_DFE_TAP11_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_CLR
#define DSC_RX_DFE_TAP11_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_SET
#define DSC_RX_DFE_TAP11_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET
#define READ_DSC_RX_DFE_TAP11_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP11_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP11_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP11_ABCDr
#define READLN_DSC_RX_DFE_TAP11_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP11_ABCDr
#define WRITELN_DSC_RX_DFE_TAP11_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP11_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP11_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP11_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP12_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd022
 * DEVAD:    1
 * DESC:     rx_dfe_tap12_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP12    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr (0x0001d022 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP12_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap12_abcd[1];
	uint32_t _dsc_rx_dfe_tap12_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_CLR(r) (r).dsc_rx_dfe_tap12_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap12_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_GET(r) (r).dsc_rx_dfe_tap12_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET(r) (((r).dsc_rx_dfe_tap12_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP12_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP12_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP12_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap12_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP12_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr
#define DSC_RX_DFE_TAP12_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_t DSC_RX_DFE_TAP12_ABCDr_t;
#define DSC_RX_DFE_TAP12_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_CLR
#define DSC_RX_DFE_TAP12_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_SET
#define DSC_RX_DFE_TAP12_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET
#define READ_DSC_RX_DFE_TAP12_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP12_ABCDr
#define WRITE_DSC_RX_DFE_TAP12_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP12_ABCDr
#define MODIFY_DSC_RX_DFE_TAP12_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP12_ABCDr
#define READLN_DSC_RX_DFE_TAP12_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP12_ABCDr
#define WRITELN_DSC_RX_DFE_TAP12_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP12_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP12_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP12_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP12_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP13_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd023
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP13    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr (0x0001d023 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET(r) (((r).dsc_rx_dfe_tap13_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP13_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP13_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap13_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr
#define DSC_RX_DFE_TAP13_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_t DSC_RX_DFE_TAP13_ABCDr_t;
#define DSC_RX_DFE_TAP13_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_CLR
#define DSC_RX_DFE_TAP13_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_SET
#define DSC_RX_DFE_TAP13_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET
#define READ_DSC_RX_DFE_TAP13_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP13_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP13_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP13_ABCDr
#define READLN_DSC_RX_DFE_TAP13_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP13_ABCDr
#define WRITELN_DSC_RX_DFE_TAP13_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP13_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP13_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP13_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP14_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd024
 * DEVAD:    1
 * DESC:     rx_dfe_tap14_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP14    signed 2's complement +/-7, 1 LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr (0x0001d024 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP14_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap14_abcd[1];
	uint32_t _dsc_rx_dfe_tap14_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_CLR(r) (r).dsc_rx_dfe_tap14_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap14_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_GET(r) (r).dsc_rx_dfe_tap14_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET(r) (((r).dsc_rx_dfe_tap14_abcd[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP14_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP14_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP14_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap14_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP14_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr
#define DSC_RX_DFE_TAP14_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_t DSC_RX_DFE_TAP14_ABCDr_t;
#define DSC_RX_DFE_TAP14_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_CLR
#define DSC_RX_DFE_TAP14_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_SET
#define DSC_RX_DFE_TAP14_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET
#define READ_DSC_RX_DFE_TAP14_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP14_ABCDr
#define WRITE_DSC_RX_DFE_TAP14_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP14_ABCDr
#define MODIFY_DSC_RX_DFE_TAP14_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP14_ABCDr
#define READLN_DSC_RX_DFE_TAP14_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP14_ABCDr
#define WRITELN_DSC_RX_DFE_TAP14_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP14_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP14_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP14_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP14_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP7_8_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd025
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_8_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr (0x0001d025 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_8_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_8_mux_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET(r) (((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap7_8_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET
#define READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP9_10_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd026
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_10_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr (0x0001d026 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_10_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_10_mux_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET(r) (((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap9_10_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET
#define READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP11_12_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd027
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_12_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr (0x0001d027 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_12_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_12_mux_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET(r) (((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap11_12_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET
#define READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP13_14_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd028
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_14_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr (0x0001d028 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_14_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_14_mux_abcd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET(r) (((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap13_14_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET
#define READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_UC_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03d
 * DEVAD:    1
 * DESC:     DSC uC Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_GP_UC_REQ gp_uc request
 *     UC_DSC_ERROR_FOUND Error Found.
 *     UC_DSC_READY_FOR_CMD Ready for command.
 *     UC_DSC_SUPP_INFO Supplemental information.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr (0x0001d03d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_UC_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_uc_ctl[1];
	uint32_t _dsc_uc_ctl;
} BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_CLR(r) (r).dsc_uc_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_SET(r,d) (r).dsc_uc_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_GET(r) (r).dsc_uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET(r) ((((r).dsc_uc_ctl[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET(r) (((r).dsc_uc_ctl[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_UC_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_UC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_UC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_UC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_uc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_UC_CTLr BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr
#define DSC_UC_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_t DSC_UC_CTLr_t;
#define DSC_UC_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_CLR
#define DSC_UC_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_SET
#define DSC_UC_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET
#define READ_DSC_UC_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_UC_CTLr
#define WRITE_DSC_UC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_UC_CTLr
#define MODIFY_DSC_UC_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_UC_CTLr
#define READLN_DSC_UC_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_UC_CTLr
#define WRITELN_DSC_UC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_UC_CTLr
#define WRITEALL_DSC_UC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_UC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_UC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_SCRATCH
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03e
 * DEVAD:    1
 * DESC:     DSC uC Scratch
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_SCRATCH   DSC scratch register.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr (0x0001d03e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SCRATCH.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_s {
	uint32_t v[1];
	uint32_t dsc_scratch[1];
	uint32_t _dsc_scratch;
} BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_CLR(r) (r).dsc_scratch[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_SET(r,d) (r).dsc_scratch[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_GET(r) (r).dsc_scratch[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET(r) (((r).dsc_scratch[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET(r,f) (r).dsc_scratch[0]=(((r).dsc_scratch[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_SCRATCH.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr,(_r._dsc_scratch)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SCRATCHr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SCRATCHr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SCRATCHr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_scratch))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SCRATCHr BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr
#define DSC_SCRATCHr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_t DSC_SCRATCHr_t;
#define DSC_SCRATCHr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_CLR
#define DSC_SCRATCHr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_SET
#define DSC_SCRATCHr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET
#define READ_DSC_SCRATCHr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SCRATCHr
#define WRITE_DSC_SCRATCHr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SCRATCHr
#define MODIFY_DSC_SCRATCHr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SCRATCHr
#define READLN_DSC_SCRATCHr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SCRATCHr
#define WRITELN_DSC_SCRATCHr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SCRATCHr
#define WRITEALL_DSC_SCRATCHr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SCRATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_SCRATCHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_VGA_PHASE_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04a
 * DEVAD:    1
 * DESC:     phase1 and phase02 threshold status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PHASE02_STATUS Read out of the phase02 Slicer threshold in 2's complement signed format.
 *     RX_PHASE1_STATUS Read out of the phase1 Slicer threshold in 2's complement signed format.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr (0x0001d04a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_PHASE_THR_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_phase_thr_sts[1];
	uint32_t _dsc_vga_phase_thr_sts;
} BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_CLR(r) (r).dsc_vga_phase_thr_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_SET(r,d) (r).dsc_vga_phase_thr_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_GET(r) (r).dsc_vga_phase_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_GET(r) ((((r).dsc_vga_phase_thr_sts[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_SET(r,f) (r).dsc_vga_phase_thr_sts[0]=(((r).dsc_vga_phase_thr_sts[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_GET(r) (((r).dsc_vga_phase_thr_sts[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_SET(r,f) (r).dsc_vga_phase_thr_sts[0]=(((r).dsc_vga_phase_thr_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_VGA_PHASE_THR_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr,(_r._dsc_vga_phase_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr,(_r._dsc_vga_phase_thr_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr,(_r._dsc_vga_phase_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_VGA_PHASE_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_phase_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_VGA_PHASE_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_phase_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_VGA_PHASE_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_phase_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_PHASE_THR_STSr BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr
#define DSC_VGA_PHASE_THR_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_t DSC_VGA_PHASE_THR_STSr_t;
#define DSC_VGA_PHASE_THR_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_CLR
#define DSC_VGA_PHASE_THR_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_SET
#define DSC_VGA_PHASE_THR_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_GET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_GET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE1_STATUSf_SET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_GET
#define DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr_RX_PHASE02_STATUSf_SET
#define READ_DSC_VGA_PHASE_THR_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_VGA_PHASE_THR_STSr
#define WRITE_DSC_VGA_PHASE_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_VGA_PHASE_THR_STSr
#define MODIFY_DSC_VGA_PHASE_THR_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_VGA_PHASE_THR_STSr
#define READLN_DSC_VGA_PHASE_THR_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_VGA_PHASE_THR_STSr
#define WRITELN_DSC_VGA_PHASE_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_VGA_PHASE_THR_STSr
#define WRITEALL_DSC_VGA_PHASE_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_VGA_PHASE_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_PHASE_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_VGA_DATA_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04b
 * DEVAD:    1
 * DESC:     data14 and data05 threshold status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA05_STATUS Read out of the Data05 Slicer threshold in 2's complement signed format.
 *     RX_DATA14_STATUS Read out of the Data14 Slicer threshold in 2's complement signed format.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr (0x0001d04b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_DATA_THR_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_data_thr_sts[1];
	uint32_t _dsc_vga_data_thr_sts;
} BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_CLR(r) (r).dsc_vga_data_thr_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_SET(r,d) (r).dsc_vga_data_thr_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_GET(r) (r).dsc_vga_data_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_GET(r) ((((r).dsc_vga_data_thr_sts[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_SET(r,f) (r).dsc_vga_data_thr_sts[0]=(((r).dsc_vga_data_thr_sts[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_GET(r) (((r).dsc_vga_data_thr_sts[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_SET(r,f) (r).dsc_vga_data_thr_sts[0]=(((r).dsc_vga_data_thr_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_VGA_DATA_THR_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr,(_r._dsc_vga_data_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr,(_r._dsc_vga_data_thr_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr,(_r._dsc_vga_data_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_VGA_DATA_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_data_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_VGA_DATA_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_data_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_VGA_DATA_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_data_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_DATA_THR_STSr BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr
#define DSC_VGA_DATA_THR_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_t DSC_VGA_DATA_THR_STSr_t;
#define DSC_VGA_DATA_THR_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_CLR
#define DSC_VGA_DATA_THR_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_SET
#define DSC_VGA_DATA_THR_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_GET
#define DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_GET
#define DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA14_STATUSf_SET
#define DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_GET
#define DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr_RX_DATA05_STATUSf_SET
#define READ_DSC_VGA_DATA_THR_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_VGA_DATA_THR_STSr
#define WRITE_DSC_VGA_DATA_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_VGA_DATA_THR_STSr
#define MODIFY_DSC_VGA_DATA_THR_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_VGA_DATA_THR_STSr
#define READLN_DSC_VGA_DATA_THR_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_VGA_DATA_THR_STSr
#define WRITELN_DSC_VGA_DATA_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_VGA_DATA_THR_STSr
#define WRITEALL_DSC_VGA_DATA_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_VGA_DATA_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_DATA_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_DC_OFFS_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04c
 * DEVAD:    1
 * DESC:     dc offset status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DC_OFFSET_BIN    rx dc offset
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr (0x0001d04c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs_sts[1];
	uint32_t _dsc_dc_offs_sts;
} BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_CLR(r) (r).dsc_dc_offs_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_SET(r,d) (r).dsc_dc_offs_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_GET(r) (r).dsc_dc_offs_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET(r) (((r).dsc_dc_offs_sts[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET(r,f) (r).dsc_dc_offs_sts[0]=(((r).dsc_dc_offs_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_DC_OFFS_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_DC_OFFS_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_DC_OFFS_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_DC_OFFS_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dc_offs_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFS_STSr BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr
#define DSC_DC_OFFS_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_t DSC_DC_OFFS_STSr_t;
#define DSC_DC_OFFS_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_CLR
#define DSC_DC_OFFS_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_SET
#define DSC_DC_OFFS_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET
#define READ_DSC_DC_OFFS_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_DC_OFFS_STSr
#define WRITE_DSC_DC_OFFS_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_DC_OFFS_STSr
#define MODIFY_DSC_DC_OFFS_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_DC_OFFS_STSr
#define READLN_DSC_DC_OFFS_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_DC_OFFS_STSr
#define WRITELN_DSC_DC_OFFS_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_DC_OFFS_STSr
#define WRITEALL_DSC_DC_OFFS_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_DC_OFFS_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_DC_OFFS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_VGA_D_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04d
 * DEVAD:    1
 * DESC:     vga gain and data1 threshold status register.
 * RESETVAL: 0x2700 (9984)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA23_STATUS Read out of the Data23 Slicer threshold in 2's complement signed format.
 *     RX_VGA_STATUS    Read out of the VGA control.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr (0x0001d04d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_D_THR_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_d_thr_sts[1];
	uint32_t _dsc_vga_d_thr_sts;
} BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_CLR(r) (r).dsc_vga_d_thr_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_SET(r,d) (r).dsc_vga_d_thr_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_GET(r) (r).dsc_vga_d_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_GET(r) ((((r).dsc_vga_d_thr_sts[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_GET(r) (((r).dsc_vga_d_thr_sts[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_VGA_D_THR_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_VGA_D_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_d_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_VGA_D_THR_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_d_thr_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_d_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_D_THR_STSr BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr
#define DSC_VGA_D_THR_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_t DSC_VGA_D_THR_STSr_t;
#define DSC_VGA_D_THR_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_CLR
#define DSC_VGA_D_THR_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_SET
#define DSC_VGA_D_THR_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_STATUSf_SET
#define DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_GET
#define DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr_RX_DATA23_STATUSf_SET
#define READ_DSC_VGA_D_THR_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_VGA_D_THR_STSr
#define WRITE_DSC_VGA_D_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_VGA_D_THR_STSr
#define MODIFY_DSC_VGA_D_THR_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_VGA_D_THR_STSr
#define READLN_DSC_VGA_D_THR_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_VGA_D_THR_STSr
#define WRITELN_DSC_VGA_D_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_VGA_D_THR_STSr
#define WRITEALL_DSC_VGA_D_THR_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_VGA_D_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_VGA_D_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_CDR_CTL0
 * BLOCKS:   DSC_C
 * REGADDR:  0xd050
 * DEVAD:    1
 * DESC:     cdr control register 0.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_NRZ_VSR_MODE  NRZ mode select control and it is only applicable to the NRZ RX datapath.1: NRZ VSR mode.0: NRZ DFE mode.
 *     RX_PAM4_ER_MODE  PAM4 mode select control and it is only applicable to the PAM4 RX datapath.1: PAM4 ER (Extended Reach) mode.0: PAM4 NR (Normal Reach)   mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r (0x0001d050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl0[1];
	uint32_t _dsc_cdr_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_CLR(r) (r).dsc_cdr_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_SET(r,d) (r).dsc_cdr_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_GET(r) (r).dsc_cdr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_PAM4_ER_MODEf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_PAM4_ER_MODEf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))

/*
 * These macros can be used to access DSC_CDR_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_CDR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL0r BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r
#define DSC_CDR_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_t DSC_CDR_CTL0r_t;
#define DSC_CDR_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_CLR
#define DSC_CDR_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_SET
#define DSC_CDR_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_GET
#define DSC_CDR_CTL0r_RX_PAM4_ER_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_PAM4_ER_MODEf_GET
#define DSC_CDR_CTL0r_RX_PAM4_ER_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_PAM4_ER_MODEf_SET
#define DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_GET
#define DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r_RX_NRZ_VSR_MODEf_SET
#define READ_DSC_CDR_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_DSC_CDR_CTL0r
#define WRITE_DSC_CDR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_CDR_CTL0r
#define MODIFY_DSC_CDR_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_CDR_CTL0r
#define READLN_DSC_CDR_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_CDR_CTL0r
#define WRITELN_DSC_CDR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_CDR_CTL0r
#define WRITEALL_DSC_CDR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_CDR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_CDR_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd052
 * DEVAD:    1
 * DESC:     cdr control register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_LOOP_TIMING_SRC_SEL Needs to be 1 in order to gate the phase sum on.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r (0x0001d052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl2[1];
	uint32_t _dsc_cdr_ctl2;
} BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_CLR(r) (r).dsc_cdr_ctl2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_SET(r,d) (r).dsc_cdr_ctl2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_GET(r) (r).dsc_cdr_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))

/*
 * These macros can be used to access DSC_CDR_CTL2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_CDR_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL2r BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r
#define DSC_CDR_CTL2r_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_t DSC_CDR_CTL2r_t;
#define DSC_CDR_CTL2r_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_CLR
#define DSC_CDR_CTL2r_SET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_SET
#define DSC_CDR_CTL2r_GET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_GET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET
#define READ_DSC_CDR_CTL2r BCMI_TSCBH_FLEXE_XGXS_READ_DSC_CDR_CTL2r
#define WRITE_DSC_CDR_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_CDR_CTL2r
#define MODIFY_DSC_CDR_CTL2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_CDR_CTL2r
#define READLN_DSC_CDR_CTL2r BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_CDR_CTL2r
#define WRITELN_DSC_CDR_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_CDR_CTL2r
#define WRITEALL_DSC_CDR_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_CDR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_PI_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd053
 * DEVAD:    1
 * DESC:     rx pi control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_DISP_MSB_STATUS 0: register reads of the pi counters are the lower 8 bits.1: register reads of the pi counters are the upper 8 bits.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr (0x0001d053 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_ctl[1];
	uint32_t _dsc_rx_pi_ctl;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_CLR(r) (r).dsc_rx_pi_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_SET(r,d) (r).dsc_rx_pi_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_GET(r) (r).dsc_rx_pi_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access DSC_RX_PI_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CTLr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr
#define DSC_RX_PI_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_t DSC_RX_PI_CTLr_t;
#define DSC_RX_PI_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_CLR
#define DSC_RX_PI_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_SET
#define DSC_RX_PI_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_GET
#define DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_GET
#define DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr_RX_PI_DISP_MSB_STATUSf_SET
#define READ_DSC_RX_PI_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CTLr
#define WRITE_DSC_RX_PI_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CTLr
#define MODIFY_DSC_RX_PI_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CTLr
#define READLN_DSC_RX_PI_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CTLr
#define WRITELN_DSC_RX_PI_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CTLr
#define WRITEALL_DSC_RX_PI_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_SLCRS_WRITE_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05b
 * DEVAD:    1
 * DESC:     slicers override write control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_AFE_OVERRIDE_SEL Based on this value, an override can be applied to one of the data, phase or lms slicers0 - Invalid; 1 - data23 slicer; 2 - data14 slicer; 3 - data05 slicer; 4 - phase1 slicer; 5 - phase02 slicer; 6 - dfe taps 2 or 3; 8 - lms threshold; 15 - Dont use (used in lms threshold readout).
 *     RX_AFE_OVERRIDE_VAL override val of slicersthis value is binary. It is converted to gray before it is routed to AFE
 *     RX_AFE_OVERRIDE_WRITE strobe to write slicer values
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr (0x0001d05b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SLCRS_WRITE_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_slcrs_write_ctl[1];
	uint32_t _dsc_slcrs_write_ctl;
} BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_CLR(r) (r).dsc_slcrs_write_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_SET(r,d) (r).dsc_slcrs_write_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_GET(r) (r).dsc_slcrs_write_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_GET(r) ((((r).dsc_slcrs_write_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_SET(r,f) (r).dsc_slcrs_write_ctl[0]=(((r).dsc_slcrs_write_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_GET(r) ((((r).dsc_slcrs_write_ctl[0]) >> 7) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_SET(r,f) (r).dsc_slcrs_write_ctl[0]=(((r).dsc_slcrs_write_ctl[0] & ~((uint32_t)0xff << 7)) | ((((uint32_t)f) & 0xff) << 7)) | (255 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_GET(r) (((r).dsc_slcrs_write_ctl[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_SET(r,f) (r).dsc_slcrs_write_ctl[0]=(((r).dsc_slcrs_write_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SLCRS_WRITE_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr,(_r._dsc_slcrs_write_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr,(_r._dsc_slcrs_write_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr,(_r._dsc_slcrs_write_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SLCRS_WRITE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcrs_write_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SLCRS_WRITE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_slcrs_write_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SLCRS_WRITE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_slcrs_write_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SLCRS_WRITE_CTLr BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr
#define DSC_SLCRS_WRITE_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_t DSC_SLCRS_WRITE_CTLr_t;
#define DSC_SLCRS_WRITE_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_CLR
#define DSC_SLCRS_WRITE_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_SET
#define DSC_SLCRS_WRITE_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_WRITEf_SET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_VALf_SET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_GET
#define DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr_RX_AFE_OVERRIDE_SELf_SET
#define READ_DSC_SLCRS_WRITE_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SLCRS_WRITE_CTLr
#define WRITE_DSC_SLCRS_WRITE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SLCRS_WRITE_CTLr
#define MODIFY_DSC_SLCRS_WRITE_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SLCRS_WRITE_CTLr
#define READLN_DSC_SLCRS_WRITE_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SLCRS_WRITE_CTLr
#define WRITELN_DSC_SLCRS_WRITE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SLCRS_WRITE_CTLr
#define WRITEALL_DSC_SLCRS_WRITE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SLCRS_WRITE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_SLCRS_WRITE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_SM_CTL1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd061
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DSC_LOCK_FRC  rx_dsc_lock force.
 *     RX_DSC_LOCK_FRC_VAL rx_dsc_lock force value.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r (0x0001d061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl1[1];
	uint32_t _dsc_sm_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_CLR(r) (r).dsc_sm_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_SET(r,d) (r).dsc_sm_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_GET(r) (r).dsc_sm_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET(r) (((r).dsc_sm_ctl1[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL1r BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r
#define DSC_SM_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_t DSC_SM_CTL1r_t;
#define DSC_SM_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_CLR
#define DSC_SM_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_SET
#define DSC_SM_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET
#define READ_DSC_SM_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_CTL1r
#define WRITE_DSC_SM_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_CTL1r
#define MODIFY_DSC_SM_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_CTL1r
#define READLN_DSC_SM_CTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_CTL1r
#define WRITELN_DSC_SM_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_CTL1r
#define WRITEALL_DSC_SM_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_SM_CTL9
 * BLOCKS:   DSC_D
 * REGADDR:  0xd069
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_RESTART_PMD   1: restarts the RX PMD. This is a self-clear register bit.
 *     RX_RESTART_PMD_HOLD 1: restarts the RX PMD and holds it in RESTART state until this bit is cleared.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r (0x0001d069 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL9.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl9[1];
	uint32_t _dsc_sm_ctl9;
} BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_CLR(r) (r).dsc_sm_ctl9[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_SET(r,d) (r).dsc_sm_ctl9[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_GET(r) (r).dsc_sm_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET(r) ((((r).dsc_sm_ctl9[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET(r) (((r).dsc_sm_ctl9[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL9.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL9r BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r
#define DSC_SM_CTL9r_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_t DSC_SM_CTL9r_t;
#define DSC_SM_CTL9r_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_CLR
#define DSC_SM_CTL9r_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_SET
#define DSC_SM_CTL9r_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET
#define READ_DSC_SM_CTL9r BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_CTL9r
#define WRITE_DSC_SM_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_CTL9r
#define MODIFY_DSC_SM_CTL9r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_CTL9r
#define READLN_DSC_SM_CTL9r BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_CTL9r
#define WRITELN_DSC_SM_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_CTL9r
#define WRITEALL_DSC_SM_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_SM_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_ONE_HOT
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06b
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_ONE_HOT Sticky one-hot coded states. These registers are cleared on read.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr (0x0001d06b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_ONE_HOT.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_one_hot;
} BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_one_hot[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_one_hot[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_one_hot[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_one_hot[0]=(((r).dsc_sm_sts_dsc_st_one_hot[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_ONE_HOT.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_one_hot))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t DSC_SM_STS_DSC_ST_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_ONE_HOTr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06e
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_SM_READY_FOR_CMD Ready for Command.
 *     DSC_SM_GP_UC_REQ gp_uc_req.
 *     DSC_SM_SCRATCH   3 bits of dsc_scratch
 *     DSC_STATE        Live DSC SM state. Following are the state encodings.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9EEE_QUIET       =  10EEE_ANA_PWR     =  11EEE_ACQ_CDR     =  12EEE_CDR_SETTLE  =  13EEE_HW_TUNE     =  14EEE_MEASURE     =  15EEE_DONE        =  16
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr (0x0001d06e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st[1];
	uint32_t _dsc_sm_sts_dsc_st;
} BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_CLR(r) (r).dsc_sm_sts_dsc_st[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_SET(r,d) (r).dsc_sm_sts_dsc_st[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_GET(r) (r).dsc_sm_sts_dsc_st[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 11) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 8) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 1) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x3f << 1)) | ((((uint32_t)f) & 0x3f) << 1)) | (63 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET(r) (((r).dsc_sm_sts_dsc_st[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_STr BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr
#define DSC_SM_STS_DSC_STr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_t DSC_SM_STS_DSC_STr_t;
#define DSC_SM_STS_DSC_STr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_CLR
#define DSC_SM_STS_DSC_STr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_SET
#define DSC_SM_STS_DSC_STr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET
#define READ_DSC_SM_STS_DSC_STr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_SM_STS_DSC_STr
#define WRITE_DSC_SM_STS_DSC_STr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_SM_STS_DSC_STr
#define MODIFY_DSC_SM_STS_DSC_STr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_SM_STS_DSC_STr
#define READLN_DSC_SM_STS_DSC_STr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_SM_STS_DSC_STr
#define WRITELN_DSC_SM_STS_DSC_STr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_SM_STS_DSC_STr
#define WRITEALL_DSC_SM_STS_DSC_STr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_SM_STS_DSC_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_SM_STS_DSC_STr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_PD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd070
 * DEVAD:    1
 * DESC:     rx_pi status register, both p and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_P_PD     PI counter value for phase slicer.see description of cnt_bin_pq
 *     CNT_BIN_D_PD     PI counter value for phase quadrature slicer.see description of cnt_bin_pq
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr (0x0001d070 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_PD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_pd[1];
	uint32_t _dsc_rx_pi_cnt_bin_pd;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CLR(r) (r).dsc_rx_pi_cnt_bin_pd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_pd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_GET(r) (r).dsc_rx_pi_cnt_bin_pd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_pd[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET(r) (((r).dsc_rx_pi_cnt_bin_pd[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_PD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_PDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_PDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_pd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_PDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr
#define DSC_RX_PI_CNT_BIN_PDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_t DSC_RX_PI_CNT_BIN_PDr_t;
#define DSC_RX_PI_CNT_BIN_PDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CLR
#define DSC_RX_PI_CNT_BIN_PDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_SET
#define DSC_RX_PI_CNT_BIN_PDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_D_PDf_SET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr_CNT_BIN_P_PDf_SET
#define READ_DSC_RX_PI_CNT_BIN_PDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_PDr
#define WRITE_DSC_RX_PI_CNT_BIN_PDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_PDr
#define MODIFY_DSC_RX_PI_CNT_BIN_PDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_PDr
#define READLN_DSC_RX_PI_CNT_BIN_PDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_PDr
#define WRITELN_DSC_RX_PI_CNT_BIN_PDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_PDr
#define WRITEALL_DSC_RX_PI_CNT_BIN_PDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_PDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_PDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_LD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd071
 * DEVAD:    1
 * DESC:     rx_pi status register, both l and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_L_LD     PI counter value for LMS slicer.see description of cnt_bin_pq
 *     CNT_BIN_D_LD     PI counter value for LMS quadrature slicer.see description of cnt_bin_pq
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr (0x0001d071 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_LD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_ld[1];
	uint32_t _dsc_rx_pi_cnt_bin_ld;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CLR(r) (r).dsc_rx_pi_cnt_bin_ld[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_ld[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_GET(r) (r).dsc_rx_pi_cnt_bin_ld[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_ld[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET(r) (((r).dsc_rx_pi_cnt_bin_ld[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_LD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_LDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_LDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_ld))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_LDr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr
#define DSC_RX_PI_CNT_BIN_LDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_t DSC_RX_PI_CNT_BIN_LDr_t;
#define DSC_RX_PI_CNT_BIN_LDr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CLR
#define DSC_RX_PI_CNT_BIN_LDr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_SET
#define DSC_RX_PI_CNT_BIN_LDr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_D_LDf_SET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr_CNT_BIN_L_LDf_SET
#define READ_DSC_RX_PI_CNT_BIN_LDr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_LDr
#define WRITE_DSC_RX_PI_CNT_BIN_LDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_LDr
#define MODIFY_DSC_RX_PI_CNT_BIN_LDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_LDr
#define READLN_DSC_RX_PI_CNT_BIN_LDr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_LDr
#define WRITELN_DSC_RX_PI_CNT_BIN_LDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_LDr
#define WRITEALL_DSC_RX_PI_CNT_BIN_LDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_LDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_LDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_D
 * BLOCKS:   DSC_E
 * REGADDR:  0xd075
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_D        PI counter value for data slicer.see description of cnt_bin_pq
 *     CNT_BIN_DQ       PI counter value for data quadrature slicer.see description of cnt_bin_pq
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr (0x0001d075 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_D.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_d[1];
	uint32_t _dsc_rx_pi_cnt_bin_d;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR(r) (r).dsc_rx_pi_cnt_bin_d[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET(r,d) (r).dsc_rx_pi_cnt_bin_d[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET(r) (r).dsc_rx_pi_cnt_bin_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_d[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET(r) (((r).dsc_rx_pi_cnt_bin_d[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_D.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_d))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Dr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr
#define DSC_RX_PI_CNT_BIN_Dr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_t DSC_RX_PI_CNT_BIN_Dr_t;
#define DSC_RX_PI_CNT_BIN_Dr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR
#define DSC_RX_PI_CNT_BIN_Dr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET
#define DSC_RX_PI_CNT_BIN_Dr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_DQf_SET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_GET
#define DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr_CNT_BIN_Df_SET
#define READ_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr
#define WRITE_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr
#define MODIFY_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr
#define READLN_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr
#define WRITELN_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Dr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_P
 * BLOCKS:   DSC_E
 * REGADDR:  0xd076
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_P        PI counter value for phase slicer.see description of cnt_bin_pq
 *     CNT_BIN_PQ       PI counter value for phase quadrature slicer.When rx_pi_disp_msb_status is 0, the lower 8 bits of the 9 bit pointer are read..When rx_pi_disp_msb_status is 1, the upper 8 bits of the 9 bit pointer are read..
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr (0x0001d076 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_P.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_p[1];
	uint32_t _dsc_rx_pi_cnt_bin_p;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR(r) (r).dsc_rx_pi_cnt_bin_p[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET(r,d) (r).dsc_rx_pi_cnt_bin_p[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET(r) (r).dsc_rx_pi_cnt_bin_p[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_p[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET(r) (((r).dsc_rx_pi_cnt_bin_p[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_P.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_p))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Pr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr
#define DSC_RX_PI_CNT_BIN_Pr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_t DSC_RX_PI_CNT_BIN_Pr_t;
#define DSC_RX_PI_CNT_BIN_Pr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR
#define DSC_RX_PI_CNT_BIN_Pr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET
#define DSC_RX_PI_CNT_BIN_Pr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_PQf_SET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_GET
#define DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr_CNT_BIN_Pf_SET
#define READ_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr
#define WRITE_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr
#define MODIFY_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr
#define READLN_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr
#define WRITELN_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Pr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Pr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_L
 * BLOCKS:   DSC_E
 * REGADDR:  0xd077
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CNT_BIN_L        PI counter value for LMS slicer.see description of cnt_bin_pq
 *     CNT_BIN_LQ       PI counter value for LMS quadrature slicer.see description of cnt_bin_pq
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr (0x0001d077 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_L.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_l[1];
	uint32_t _dsc_rx_pi_cnt_bin_l;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CLR(r) (r).dsc_rx_pi_cnt_bin_l[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_SET(r,d) (r).dsc_rx_pi_cnt_bin_l[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_GET(r) (r).dsc_rx_pi_cnt_bin_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_l[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET(r) (((r).dsc_rx_pi_cnt_bin_l[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_L.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_Lr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Lr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_l))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Lr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr
#define DSC_RX_PI_CNT_BIN_Lr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_t DSC_RX_PI_CNT_BIN_Lr_t;
#define DSC_RX_PI_CNT_BIN_Lr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CLR
#define DSC_RX_PI_CNT_BIN_Lr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_SET
#define DSC_RX_PI_CNT_BIN_Lr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_LQf_SET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_GET
#define DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr_CNT_BIN_Lf_SET
#define READ_DSC_RX_PI_CNT_BIN_Lr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PI_CNT_BIN_Lr
#define WRITE_DSC_RX_PI_CNT_BIN_Lr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Lr
#define MODIFY_DSC_RX_PI_CNT_BIN_Lr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Lr
#define READLN_DSC_RX_PI_CNT_BIN_Lr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PI_CNT_BIN_Lr
#define WRITELN_DSC_RX_PI_CNT_BIN_Lr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Lr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Lr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Lr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PI_CNT_BIN_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_CDR_STS_INTEG
 * BLOCKS:   DSC_E
 * REGADDR:  0xd078
 * DEVAD:    1
 * DESC:     cdr status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_INTEG_REG    Divide this by 83.886 to get the approximate ppm frequency offset the CDR is tracking. (The CDR must settle first - rx_dsc_lock asserted high).
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr (0x0001d078 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_INTEG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_integ[1];
	uint32_t _dsc_cdr_sts_integ;
} BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_CLR(r) (r).dsc_cdr_sts_integ[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_SET(r,d) (r).dsc_cdr_sts_integ[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_GET(r) (r).dsc_cdr_sts_integ[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET(r) (((r).dsc_cdr_sts_integ[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET(r,f) (r).dsc_cdr_sts_integ[0]=(((r).dsc_cdr_sts_integ[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_CDR_STS_INTEG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_integ))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_INTEGr BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr
#define DSC_CDR_STS_INTEGr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_t DSC_CDR_STS_INTEGr_t;
#define DSC_CDR_STS_INTEGr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_CLR
#define DSC_CDR_STS_INTEGr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_SET
#define DSC_CDR_STS_INTEGr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET
#define READ_DSC_CDR_STS_INTEGr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_CDR_STS_INTEGr
#define WRITE_DSC_CDR_STS_INTEGr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_CDR_STS_INTEGr
#define MODIFY_DSC_CDR_STS_INTEGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_CDR_STS_INTEGr
#define READLN_DSC_CDR_STS_INTEGr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_CDR_STS_INTEGr
#define WRITELN_DSC_CDR_STS_INTEGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_CDR_STS_INTEGr
#define WRITEALL_DSC_CDR_STS_INTEGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_CDR_STS_INTEGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_CDR_STS_INTEGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07b
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXC_DFE_TAP2_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXB_DFE_TAP2_STATUS signed 2's complement  +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr (0x0001d07b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_sts[1];
	uint32_t _dsc_rx_dfe_tap2_sts;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_CLR(r) (r).dsc_rx_dfe_tap2_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_SET(r,d) (r).dsc_rx_dfe_tap2_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_GET(r) (r).dsc_rx_dfe_tap2_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_sts[0]) >> 10) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_sts[0]=(((r).dsc_rx_dfe_tap2_sts[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_sts[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_sts[0]=(((r).dsc_rx_dfe_tap2_sts[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_GET(r) (((r).dsc_rx_dfe_tap2_sts[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_sts[0]=(((r).dsc_rx_dfe_tap2_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr,(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr,(_r._dsc_rx_dfe_tap2_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr,(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_STSr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr
#define DSC_RX_DFE_TAP2_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_t DSC_RX_DFE_TAP2_STSr_t;
#define DSC_RX_DFE_TAP2_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_CLR
#define DSC_RX_DFE_TAP2_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_SET
#define DSC_RX_DFE_TAP2_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_GET
#define DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXA_DFE_TAP2_STATUSf_SET
#define DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXB_DFE_TAP2_STATUSf_SET
#define DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr_RXC_DFE_TAP2_STATUSf_SET
#define READ_DSC_RX_DFE_TAP2_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_STSr
#define WRITE_DSC_RX_DFE_TAP2_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_STSr
#define MODIFY_DSC_RX_DFE_TAP2_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_STSr
#define READLN_DSC_RX_DFE_TAP2_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_STSr
#define WRITELN_DSC_RX_DFE_TAP2_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_STSr
#define WRITEALL_DSC_RX_DFE_TAP2_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_3_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07c
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_3_status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXB_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP2_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr (0x0001d07c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_3_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_3_sts[1];
	uint32_t _dsc_rx_dfe_tap2_3_sts;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_CLR(r) (r).dsc_rx_dfe_tap2_3_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_SET(r,d) (r).dsc_rx_dfe_tap2_3_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_GET(r) (r).dsc_rx_dfe_tap2_3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_3_sts[0]) >> 10) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_3_sts[0]=(((r).dsc_rx_dfe_tap2_3_sts[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap2_3_sts[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_3_sts[0]=(((r).dsc_rx_dfe_tap2_3_sts[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_GET(r) (((r).dsc_rx_dfe_tap2_3_sts[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap2_3_sts[0]=(((r).dsc_rx_dfe_tap2_3_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_3_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr,(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr,(_r._dsc_rx_dfe_tap2_3_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr,(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_3_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_3_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_3_STSr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr
#define DSC_RX_DFE_TAP2_3_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_t DSC_RX_DFE_TAP2_3_STSr_t;
#define DSC_RX_DFE_TAP2_3_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_CLR
#define DSC_RX_DFE_TAP2_3_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_SET
#define DSC_RX_DFE_TAP2_3_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXD_DFE_TAP2_STATUSf_SET
#define DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXA_DFE_TAP3_STATUSf_SET
#define DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr_RXB_DFE_TAP3_STATUSf_SET
#define READ_DSC_RX_DFE_TAP2_3_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_3_STSr
#define WRITE_DSC_RX_DFE_TAP2_3_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_3_STSr
#define MODIFY_DSC_RX_DFE_TAP2_3_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_STSr
#define READLN_DSC_RX_DFE_TAP2_3_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_3_STSr
#define WRITELN_DSC_RX_DFE_TAP2_3_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_STSr
#define WRITEALL_DSC_RX_DFE_TAP2_3_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP3_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07d
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RXD_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP3_STATUS signed 2's complement +/-15, 1LSB=150mV/64
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr (0x0001d07d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_sts[1];
	uint32_t _dsc_rx_dfe_tap3_sts;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_CLR(r) (r).dsc_rx_dfe_tap3_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_SET(r,d) (r).dsc_rx_dfe_tap3_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_GET(r) (r).dsc_rx_dfe_tap3_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_GET(r) ((((r).dsc_rx_dfe_tap3_sts[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap3_sts[0]=(((r).dsc_rx_dfe_tap3_sts[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_GET(r) (((r).dsc_rx_dfe_tap3_sts[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_SET(r,f) (r).dsc_rx_dfe_tap3_sts[0]=(((r).dsc_rx_dfe_tap3_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr,(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr,(_r._dsc_rx_dfe_tap3_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr,(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP3_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP3_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP3_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap3_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_STSr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr
#define DSC_RX_DFE_TAP3_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_t DSC_RX_DFE_TAP3_STSr_t;
#define DSC_RX_DFE_TAP3_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_CLR
#define DSC_RX_DFE_TAP3_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_SET
#define DSC_RX_DFE_TAP3_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_GET
#define DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXC_DFE_TAP3_STATUSf_SET
#define DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_GET
#define DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr_RXD_DFE_TAP3_STATUSf_SET
#define READ_DSC_RX_DFE_TAP3_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP3_STSr
#define WRITE_DSC_RX_DFE_TAP3_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP3_STSr
#define MODIFY_DSC_RX_DFE_TAP3_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP3_STSr
#define READLN_DSC_RX_DFE_TAP3_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP3_STSr
#define WRITELN_DSC_RX_DFE_TAP3_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP3_STSr
#define WRITEALL_DSC_RX_DFE_TAP3_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP3_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LNKTRNUT_STS0
 * BLOCKS:   LINKTRN_USER_TX
 * REGADDR:  0xd096
 * DEVAD:    1
 * DESC:     linktrn Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LINKTRN_LOCAL_RX_READY Set to TRUE (1'b1) by the FSM when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     LINKTRN_TRAINING_FSM_SIGNAL_DETECT 1 - linktrn is in SEND_DATA state0 - linktrn is in training or reset state
 *     LINKTRN_XMT_COEFF_UPDATE_PARITY This fields indicates the parity of the current value of thelinktrn_xmt_update_page register field. This field can beused to adjust the parity of the Coeffcient Update field beforeit is sent to the link partner.0 - even parity - linktrn_xmt_update_page field has even number of 1's1 - odd parity  - linktrn_xmt_update_page field has odd number of 1'slinktrn_ignore_xmt_reg_value can be set to 1 stop the contents oflinktrn_xmt_update_page being sent while parity is being adjusted
 *     LINKTRN_XMT_STATUS_REPORT_PARITY This fields indicates the parity of the current value of thelinktrn_ld_xmt_status_page register field. This field can beused to adjust the parity of the Status page field beforeit is sent to the link partner.0 - even parity - linktrn_ld_xmt_status_page field has even number of 1's1 - odd parity  - linktrn_ld_xmt_status_page field has odd number of 1'slinktrn_ignore_xmt_reg_value can be set to 1 stop the contents oflinktrn_ld_xmt_status_page being sent while parity is being adjusted
 *     LINKTRN_SM_CURRENT_STATE Training State machine current state0 = ST_INITIALIZE1 = ST_SEND_TRAINING2 = ST_TRAIN_LOCAL3 = ST_TRAIN_REMOTE4 = ST_LINK_READY5 = ST_SEND_DATA6 = ST_TRAINING_FAILURE
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r (0x0001d096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program LNKTRNUT_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_s {
	uint32_t v[1];
	uint32_t lnktrnut_sts0[1];
	uint32_t _lnktrnut_sts0;
} BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_CLR(r) (r).lnktrnut_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_SET(r,d) (r).lnktrnut_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_GET(r) (r).lnktrnut_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_GET(r) ((((r).lnktrnut_sts0[0]) >> 12) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_GET(r) ((((r).lnktrnut_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_GET(r) ((((r).lnktrnut_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_GET(r) ((((r).lnktrnut_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_GET(r) (((r).lnktrnut_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_SET(r,f) (r).lnktrnut_sts0[0]=(((r).lnktrnut_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access LNKTRNUT_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r,(_r._lnktrnut_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r,(_r._lnktrnut_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r,(_r._lnktrnut_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNUT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNUT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._lnktrnut_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNUT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._lnktrnut_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LNKTRNUT_STS0r BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r
#define LNKTRNUT_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_t LNKTRNUT_STS0r_t;
#define LNKTRNUT_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_CLR
#define LNKTRNUT_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_SET
#define LNKTRNUT_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_GET
#define LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_GET
#define LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_SM_CURRENT_STATEf_SET
#define LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_GET
#define LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_STATUS_REPORT_PARITYf_SET
#define LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_GET
#define LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_XMT_COEFF_UPDATE_PARITYf_SET
#define LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_GET
#define LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_TRAINING_FSM_SIGNAL_DETECTf_SET
#define LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_GET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_GET
#define LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_SET BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r_LINKTRN_LOCAL_RX_READYf_SET
#define READ_LNKTRNUT_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_LNKTRNUT_STS0r
#define WRITE_LNKTRNUT_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_LNKTRNUT_STS0r
#define MODIFY_LNKTRNUT_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LNKTRNUT_STS0r
#define READLN_LNKTRNUT_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_LNKTRNUT_STS0r
#define WRITELN_LNKTRNUT_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LNKTRNUT_STS0r
#define WRITEALL_LNKTRNUT_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LNKTRNUT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LNKTRNUT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PI_CTL0
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a0
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 0
 * RESETVAL: 0x7000 (28672)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_EN         Transmit Phase Interpolator Enable. If 1'b0 will gate off the TX PI clock and also freeze the PI code.
 *     TX_PI_JITTER_FILTER_EN This enables the IIR filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) .
 *     TX_PI_EXT_CTRL_EN Enable for the phase error (inc/dec) from the remote loopback ( or HS Phase FIFO in case of Repeater )
 *     TX_PI_FREQ_OVERRIDE_EN Enable for the frequency override mode. It should be 1'b1 for fixed frequency and jitter generation modes.
 *     TX_PI_SJ_GEN_EN  Sinusoidal Jitter (SJ) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_SSC_GEN_EN Spread Spectrum Jitter (SSC) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_JIT_SSC_FREQ_MODE SSJ Mode Select:1'b1 : 10G SSC mode and 1'b0: 6G SSC mode
 *     TX_PI_FIRST_ORDER_BWSEL_INTEG First order bandwidth control.3'd0 - 110 KHz3'd1 - 220 KHz3'd2 - 440 KHz3'd3 - 880 KHz3'd4 - 1.7 MHz>= 3'd5 is unused and reserved for future use.
 *     TX_PI_SECOND_ORDER_BWSEL_INTEG Second order bandwidth control. Valid values are 0, 1, 2 and 3.
 *     TX_PI_EXT_PHASE_BWSEL_INTEG External Phase bandwidth control. Valid values are 0 to 7.
 *     TX_PI_SECOND_ORDER_LOOP_EN 2nd Order Loop Enable. 1'b1 will enable the 2nd order loop of the IIR filter. 1'b0 will reset the all the flops related to the 2nd order loop.This bit is only valid when tx_pi_jitter_filter_en is set to 1'b1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r (0x0001d0a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl0[1];
	uint32_t _tx_pi_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_CLR(r) (r).tx_pi_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_SET(r,d) (r).tx_pi_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_GET(r) (r).tx_pi_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 12) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 10) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_ctl0[0]) >> 7) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET(r) ((((r).tx_pi_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET(r) ((((r).tx_pi_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET(r) (((r).tx_pi_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET(r,f) (r).tx_pi_ctl0[0]=(((r).tx_pi_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r,(_r._tx_pi_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL0r BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r
#define TX_PI_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_t TX_PI_CTL0r_t;
#define TX_PI_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_CLR
#define TX_PI_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_SET
#define TX_PI_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET
#define TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET
#define TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SSC_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_GET
#define TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_SJ_GEN_ENf_SET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET
#define TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_GET
#define TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_EXT_CTRL_ENf_SET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_GET
#define TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_JITTER_FILTER_ENf_SET
#define TX_PI_CTL0r_TX_PI_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_ENf_GET
#define TX_PI_CTL0r_TX_PI_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r_TX_PI_ENf_SET
#define READ_TX_PI_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL0r
#define WRITE_TX_PI_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL0r
#define MODIFY_TX_PI_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL0r
#define READLN_TX_PI_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL0r
#define WRITELN_TX_PI_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL0r
#define WRITEALL_TX_PI_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PI_CTL1
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a1
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FREQ_OVERRIDE_VAL Fixed Frequncy Override Value: Valid values are -8192 to +8192. Register tx_pi_freq_override_en should be 1'b1 to enable the Fixed Frequncy Override mode.+8192 (-8192) value in this register will result into 1 TX PI phase inc (dec) every 20T tclk. This results into (1/64 * 1/20)UI phase inc (or dec) per UI = 781.25(-781.25) ppm. So 1 ppm = 10.486 value.If tx_pi_jit_gen_en is set to 1'b1 then this register provides initilization value for Jitter Gen Integ Reg. Valid values in jitter generation mode are -8192 to +8191
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r (0x0001d0a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl1[1];
	uint32_t _tx_pi_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_CLR(r) (r).tx_pi_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_SET(r,d) (r).tx_pi_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_GET(r) (r).tx_pi_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET(r) (((r).tx_pi_ctl1[0]) & 0x7fff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET(r,f) (r).tx_pi_ctl1[0]=(((r).tx_pi_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r,(_r._tx_pi_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL1r BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r
#define TX_PI_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_t TX_PI_CTL1r_t;
#define TX_PI_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_CLR
#define TX_PI_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_SET
#define TX_PI_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET
#define TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET
#define READ_TX_PI_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL1r
#define WRITE_TX_PI_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL1r
#define MODIFY_TX_PI_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL1r
#define READLN_TX_PI_CTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL1r
#define WRITELN_TX_PI_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL1r
#define WRITEALL_TX_PI_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PI_CTL2
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a2
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_JIT_FREQ_IDX Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator parameters.In SJ  mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details.In SSC mode: It provides Nssc.                                               Refer Jitter Generator spec for the table details.
 *     TX_PI_JIT_AMP    Jitter Generator Amplification Factor. Valid values are 0 to 63.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r (0x0001d0a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl2[1];
	uint32_t _tx_pi_ctl2;
} BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_CLR(r) (r).tx_pi_ctl2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_SET(r,d) (r).tx_pi_ctl2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_GET(r) (r).tx_pi_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET(r) ((((r).tx_pi_ctl2[0]) >> 8) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET(r) (((r).tx_pi_ctl2[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET(r,f) (r).tx_pi_ctl2[0]=(((r).tx_pi_ctl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_CTL2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r,(_r._tx_pi_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL2r BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r
#define TX_PI_CTL2r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_t TX_PI_CTL2r_t;
#define TX_PI_CTL2r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_CLR
#define TX_PI_CTL2r_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_SET
#define TX_PI_CTL2r_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_GET
#define TX_PI_CTL2r_TX_PI_JIT_AMPf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_AMPf_SET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_GET
#define TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r_TX_PI_JIT_FREQ_IDXf_SET
#define READ_TX_PI_CTL2r BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL2r
#define WRITE_TX_PI_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL2r
#define MODIFY_TX_PI_CTL2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL2r
#define READLN_TX_PI_CTL2r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL2r
#define WRITELN_TX_PI_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL2r
#define WRITEALL_TX_PI_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PI_CTL5
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a5
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 5
 * RESETVAL: 0x84 (132)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR_INVERT 1'b1: Inverts the hs_fifo_phserr[4:0] to invert the meaning of inc/dec from hs_fifo_phserr[4:0]. When this bit is 1'b0, 1'b1 is increment and 1'b0 is decrement.
 *     TX_PI_REPEATER_MODE_EN Selects the source of the Loop Timing CDR and Phase Detector inc/dec information.1'b1: Select external CDR and hs_fifo_phserr[4:0] from the high speed Phase FIFO PD inside AFE for ultra-low latency path.1'b0: selects the internal CDR and inc/dec from the Remote Loopback Phase Detector.
 *     TX_PI_EXT_PD_SEL Selects the source of the Phase Detector inc/dec information.1'b1: Select external PD path irrespective of rg_tx_pi_repeater_mode_en1'b0: Select PD path based on rg_tx_pi_repeater_mode_en
 *     TX_PI_HS_FIFO_PHSERR_SEL Selects the source of the Phase Detector inc/dec information. tx_pi_ext_pd_sel has higher priority so it should be 1'b0 for tx_pi_hs_fifo_phserr_sel to select.1'b1: hs_fifo_phserr[4] from the PD inside AFE for ultra-low latency path or TCA irrespective of rg_tx_pi_repeater_mode_en.1'b0: Select PD path based on rg_tx_pi_repeater_mode_en.
 *     TX_PI_EXT_PHASE_STEP_CNT_INVERT 1'b1 : invert pmd_tx_pi_ext_phase_step_cnt such that -x will become +x and vice-versa and 0 will remain 0.It is only valid when tx_pi_ext_phase_step_cnt_sel OR tx_pi_ext_pd_sel bits are 1'b1.
 *     TX_PI_EXT_PHASE_STEP_CNT_SEL 1'b1 : will select the pmd_tx_pi_ext_phase_step_cnt pin by controlling the tx_pi final inc/dec complete bypass mux .If tx_pi_jitter_filter_en OR tx_pi_freq_override_en OR tx_pi_ext_ctrl_en reg fields are enabled then final mux will automatically switch to the normal tx_pi modeas if tx_pi_ext_phase_step_cnt_sel is 1'b0. Once all these fields are cleared then it will switch back to the pmd_tx_pi_ext_pd_inc/dec pin control mode if tx_pi_ext_phase_step_cnt_sel is 1.
 *     TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASS 1'b1 : will select the pmd_tx_pi_ext_phase_step_cnt pin by controlling the tx_pi final inc/dec full bypass mux . Only have effect when tx_pi_ext_phase_step_cnt_sel = 1.1'b0 : pmd_tx_pi_ext_phase_step_cnt will go through the dsm2 filter
 *     AFE_TX_FIFO_RESETB 1'b0: will assert the reset pin tx_fifo_resetb to 1'b0.1'b1: Once this bit is written to 1'b1 then phase error (bit 4) from FIFO is looked for 2 transitions and then reset is de-asserted to the Phase FIFO.
 *     AFE_TX_FIFO_RESETB_FRC 1'b0: Normal mode where reset pin tx_fifo_resetb is controlled as per the description of the register afe_tx_fifo_resetb.1'b1: force the reset pin tx_fifo_resetb to value indicated in the register afe_tx_fifo_resetb.
 *     TX_PI_PD_BYPASS_FLT 1'b1 will enable filter bypass for inc/dec indication from all sources to get a quicker phase locking time.
 *     TX_PI_PD_BYPASS_VCO 1'b1 will enable filter and vco bypass for inc/dec indication from all sources to get a quicker phase locking time.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r (0x0001d0a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_CTL5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_s {
	uint32_t v[1];
	uint32_t tx_pi_ctl5[1];
	uint32_t _tx_pi_ctl5;
} BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_CLR(r) (r).tx_pi_ctl5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_SET(r,d) (r).tx_pi_ctl5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_GET(r) (r).tx_pi_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET(r) ((((r).tx_pi_ctl5[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET(r) ((((r).tx_pi_ctl5[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_ctl5[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_GET(r) ((((r).tx_pi_ctl5[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET(r) ((((r).tx_pi_ctl5[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET(r) ((((r).tx_pi_ctl5[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET(r) ((((r).tx_pi_ctl5[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET(r,f) (r).tx_pi_ctl5[0]=(((r).tx_pi_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access TX_PI_CTL5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r,(_r._tx_pi_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_CTL5r BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r
#define TX_PI_CTL5r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_t TX_PI_CTL5r_t;
#define TX_PI_CTL5r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_CLR
#define TX_PI_CTL5r_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_SET
#define TX_PI_CTL5r_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_VCOf_SET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_GET
#define TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_PD_BYPASS_FLTf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETB_FRCf_SET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_FULL_BYPASSf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_SELf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PHASE_STEP_CNT_INVERTf_SET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_GET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_SELf_SET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_GET
#define TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_EXT_PD_SELf_SET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_GET
#define TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_REPEATER_MODE_ENf_SET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_GET
#define TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r_TX_PI_HS_FIFO_PHSERR_INVERTf_SET
#define READ_TX_PI_CTL5r BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_CTL5r
#define WRITE_TX_PI_CTL5r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_CTL5r
#define MODIFY_TX_PI_CTL5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_CTL5r
#define READLN_TX_PI_CTL5r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_CTL5r
#define WRITELN_TX_PI_CTL5r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_CTL5r
#define WRITEALL_TX_PI_CTL5r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PI_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PI_STS1
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0a9
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG1_REG TX PI integ1 register. Signed Value.This field is meant for internal debug only.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r (0x0001d0a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts1[1];
	uint32_t _tx_pi_sts1;
} BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_CLR(r) (r).tx_pi_sts1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_SET(r,d) (r).tx_pi_sts1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_GET(r) (r).tx_pi_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET(r) (((r).tx_pi_sts1[0]) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET(r,f) (r).tx_pi_sts1[0]=(((r).tx_pi_sts1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_PI_STS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r,(_r._tx_pi_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS1r BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r
#define TX_PI_STS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_t TX_PI_STS1r_t;
#define TX_PI_STS1r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_CLR
#define TX_PI_STS1r_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_SET
#define TX_PI_STS1r_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_GET
#define TX_PI_STS1r_TX_PI_INTEG1_REGf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r_TX_PI_INTEG1_REGf_SET
#define READ_TX_PI_STS1r BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_STS1r
#define WRITE_TX_PI_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_STS1r
#define MODIFY_TX_PI_STS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_STS1r
#define READLN_TX_PI_STS1r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_STS1r
#define WRITELN_TX_PI_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_STS1r
#define WRITEALL_TX_PI_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PI_STS2
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0aa
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG2_REG TX PI integ2 register. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock.+8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock.Divide this register value by 10.485 to get the tclk ppm.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r (0x0001d0aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts2[1];
	uint32_t _tx_pi_sts2;
} BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_CLR(r) (r).tx_pi_sts2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_SET(r,d) (r).tx_pi_sts2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_GET(r) (r).tx_pi_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET(r) (((r).tx_pi_sts2[0]) & 0x7fff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET(r,f) (r).tx_pi_sts2[0]=(((r).tx_pi_sts2[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_STS2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r,(_r._tx_pi_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS2r BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r
#define TX_PI_STS2r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_t TX_PI_STS2r_t;
#define TX_PI_STS2r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_CLR
#define TX_PI_STS2r_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_SET
#define TX_PI_STS2r_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_GET
#define TX_PI_STS2r_TX_PI_INTEG2_REGf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r_TX_PI_INTEG2_REGf_SET
#define READ_TX_PI_STS2r BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_STS2r
#define WRITE_TX_PI_STS2r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_STS2r
#define MODIFY_TX_PI_STS2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_STS2r
#define READLN_TX_PI_STS2r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_STS2r
#define WRITELN_TX_PI_STS2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_STS2r
#define WRITEALL_TX_PI_STS2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PI_STS4
 * BLOCKS:   TX_PI_8X_PLL2X_V1P0
 * REGADDR:  0xd0ac
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_HS_FIFO_PHSERR Bit 4 of hs_fifo_pherr.
 *     ST_AFE_TX_FIFO_RESETB Status of the final afe_tx_fifo_resetb signal connected to the AFE pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r (0x0001d0ac | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_STS4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_s {
	uint32_t v[1];
	uint32_t tx_pi_sts4[1];
	uint32_t _tx_pi_sts4;
} BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_CLR(r) (r).tx_pi_sts4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_SET(r,d) (r).tx_pi_sts4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_GET(r) (r).tx_pi_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET(r) ((((r).tx_pi_sts4[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET(r) (((r).tx_pi_sts4[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET(r,f) (r).tx_pi_sts4[0]=(((r).tx_pi_sts4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_STS4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r,(_r._tx_pi_sts4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_STS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_STS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_sts4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_STS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_STS4r BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r
#define TX_PI_STS4r_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_t TX_PI_STS4r_t;
#define TX_PI_STS4r_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_CLR
#define TX_PI_STS4r_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_SET
#define TX_PI_STS4r_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_GET
#define TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_ST_AFE_TX_FIFO_RESETBf_SET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_GET
#define TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r_TX_PI_HS_FIFO_PHSERRf_SET
#define READ_TX_PI_STS4r BCMI_TSCBH_FLEXE_XGXS_READ_TX_PI_STS4r
#define WRITE_TX_PI_STS4r BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PI_STS4r
#define MODIFY_TX_PI_STS4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PI_STS4r
#define READLN_TX_PI_STS4r BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PI_STS4r
#define WRITELN_TX_PI_STS4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PI_STS4r
#define WRITEALL_TX_PI_STS4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PI_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PI_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_OSR_MODE_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b0
 * DEVAD:    1
 * DESC:     RXTXCOM_OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OSR_MODE_FRC_VAL NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     PAM4_MODE_FRC_VAL PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_er_mode reg field when 1'b1 is PAM4 ER mode and 1'b0 is PAM4 NR mode)Reserved      3'd2:3d7Note: This field is PMD uC driven and off limits for users
 *     PAM4_MODE_FRC    PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode.Othersise, the pin input values are used for pam4 mode Note: This field is PMD uC driven and off limits for users
 *     OSR_MODE_FRC     NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr (0x0001d0b0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_OSR_MODE_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_osr_mode_ctl[1];
	uint32_t _rxtxcom_osr_mode_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_CLR(r) (r).rxtxcom_osr_mode_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_SET(r,d) (r).rxtxcom_osr_mode_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_GET(r) (r).rxtxcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET(r) ((((r).rxtxcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_GET(r) ((((r).rxtxcom_osr_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_GET(r) ((((r).rxtxcom_osr_mode_ctl[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET(r) (((r).rxtxcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET(r,f) (r).rxtxcom_osr_mode_ctl[0]=(((r).rxtxcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_OSR_MODE_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr,(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr
#define RXTXCOM_OSR_MODE_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_t RXTXCOM_OSR_MODE_CTLr_t;
#define RXTXCOM_OSR_MODE_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_CLR
#define RXTXCOM_OSR_MODE_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_SET
#define RXTXCOM_OSR_MODE_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRCf_SET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_GET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRCf_SET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_GET
#define RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_PAM4_MODE_FRC_VALf_SET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET
#define RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET
#define READ_RXTXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_OSR_MODE_CTLr
#define WRITE_RXTXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_OSR_MODE_CTLr
#define MODIFY_RXTXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_OSR_MODE_CTLr
#define READLN_RXTXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_OSR_MODE_CTLr
#define WRITELN_RXTXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_OSR_MODE_CTLr
#define WRITEALL_RXTXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b1
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_DP_S_RSTB     Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d0b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rxtxcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET(r) (((r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET(r,f) (r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rxtxcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET
#define RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET
#define READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b3
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d0b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET(r) ((((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET(r,f) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET(r) (((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET(r,f) (r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET
#define RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET
#define READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_UC_ACK_LN_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b5
 * DEVAD:    1
 * DESC:     RXTXCOM_UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr (0x0001d0b5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_UC_ACK_LN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_uc_ack_ln_ctl[1];
	uint32_t _rxtxcom_uc_ack_ln_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_CLR(r) (r).rxtxcom_uc_ack_ln_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).rxtxcom_uc_ack_ln_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_GET(r) (r).rxtxcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).rxtxcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).rxtxcom_uc_ack_ln_ctl[0]=(((r).rxtxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).rxtxcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).rxtxcom_uc_ack_ln_ctl[0]=(((r).rxtxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_UC_ACK_LN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr,(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr
#define RXTXCOM_UC_ACK_LN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_t RXTXCOM_UC_ACK_LN_CTLr_t;
#define RXTXCOM_UC_ACK_LN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_CLR
#define RXTXCOM_UC_ACK_LN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_SET
#define RXTXCOM_UC_ACK_LN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET
#define RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET
#define READ_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_UC_ACK_LN_CTLr
#define WRITE_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_UC_ACK_LN_CTLr
#define MODIFY_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_UC_ACK_LN_CTLr
#define READLN_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_UC_ACK_LN_CTLr
#define WRITELN_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_UC_ACK_LN_CTLr
#define WRITEALL_RXTXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_LN_RST_OCC_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b6
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr (0x0001d0b6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_RST_OCC_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_rst_occ_ctl[1];
	uint32_t _rxtxcom_ln_rst_occ_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_CLR(r) (r).rxtxcom_ln_rst_occ_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).rxtxcom_ln_rst_occ_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_GET(r) (r).rxtxcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET(r) (((r).rxtxcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).rxtxcom_ln_rst_occ_ctl[0]=(((r).rxtxcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_RST_OCC_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr,(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr
#define RXTXCOM_LN_RST_OCC_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_t RXTXCOM_LN_RST_OCC_CTLr_t;
#define RXTXCOM_LN_RST_OCC_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_CLR
#define RXTXCOM_LN_RST_OCC_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_SET
#define RXTXCOM_LN_RST_OCC_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_GET
#define RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET
#define RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET
#define READ_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_RST_OCC_CTLr
#define WRITE_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_RST_OCC_CTLr
#define MODIFY_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_RST_OCC_CTLr
#define READLN_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_RST_OCC_CTLr
#define WRITELN_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_RST_OCC_CTLr
#define WRITEALL_RXTXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_PLL_SEL_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b7
 * DEVAD:    1
 * DESC:     RXTXCOM_PLL_SELECT_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_SELECT       This register controls the selection of the PLL0 or PLL1 as clock source for the  lane. This register will be only reset upon POR hard or POR soft reset.This register is expected to be changed only when  lane datapath is in reset.0 - Select PLL0 as clock for  lane.1 - Select PLL1 as clock for  lane.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr (0x0001d0b7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_PLL_SEL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_pll_sel_ctl[1];
	uint32_t _rxtxcom_pll_sel_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_CLR(r) (r).rxtxcom_pll_sel_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_SET(r,d) (r).rxtxcom_pll_sel_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_GET(r) (r).rxtxcom_pll_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_GET(r) (((r).rxtxcom_pll_sel_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_SET(r,f) (r).rxtxcom_pll_sel_ctl[0]=(((r).rxtxcom_pll_sel_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_PLL_SEL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr,(_r._rxtxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr,(_r._rxtxcom_pll_sel_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr,(_r._rxtxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_pll_sel_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr
#define RXTXCOM_PLL_SEL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_t RXTXCOM_PLL_SEL_CTLr_t;
#define RXTXCOM_PLL_SEL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_CLR
#define RXTXCOM_PLL_SEL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_SET
#define RXTXCOM_PLL_SEL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_GET
#define RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_GET
#define RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr_PLL_SELECTf_SET
#define READ_RXTXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_PLL_SEL_CTLr
#define WRITE_RXTXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_PLL_SEL_CTLr
#define MODIFY_RXTXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_PLL_SEL_CTLr
#define READLN_RXTXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_PLL_SEL_CTLr
#define WRITELN_RXTXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_PLL_SEL_CTLr
#define WRITEALL_RXTXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_PLL_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_PLL_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0b9
 * DEVAD:    1
 * DESC:     RXTXCOM_LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr (0x0001d0b9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_DP_RST_ST_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_dp_rst_st_sts[1];
	uint32_t _rxtxcom_ln_dp_rst_st_sts;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).rxtxcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).rxtxcom_ln_dp_rst_st_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_GET(r) (r).rxtxcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET(r) (((r).rxtxcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET(r,f) (r).rxtxcom_ln_dp_rst_st_sts[0]=(((r).rxtxcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_DP_RST_ST_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr,(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr
#define RXTXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_t RXTXCOM_LN_DP_RST_ST_STSr_t;
#define RXTXCOM_LN_DP_RST_ST_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_CLR
#define RXTXCOM_LN_DP_RST_ST_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_SET
#define RXTXCOM_LN_DP_RST_ST_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_GET
#define RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET
#define RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET
#define READ_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITE_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_DP_RST_ST_STSr
#define MODIFY_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_DP_RST_ST_STSr
#define READLN_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITELN_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_MCST_MASK_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0ba
 * DEVAD:    1
 * DESC:     RXTXCOM_MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr (0x0001d0ba | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_MCST_MASK_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_mcst_mask_ctl[1];
	uint32_t _rxtxcom_mcst_mask_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_CLR(r) (r).rxtxcom_mcst_mask_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_SET(r,d) (r).rxtxcom_mcst_mask_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_GET(r) (r).rxtxcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET(r) (((r).rxtxcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET(r,f) (r).rxtxcom_mcst_mask_ctl[0]=(((r).rxtxcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_MCST_MASK_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr,(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr
#define RXTXCOM_MCST_MASK_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_t RXTXCOM_MCST_MASK_CTLr_t;
#define RXTXCOM_MCST_MASK_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_CLR
#define RXTXCOM_MCST_MASK_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_SET
#define RXTXCOM_MCST_MASK_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_GET
#define RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_GET
#define RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr_MULTICAST_MASK_CONTROLf_SET
#define READ_RXTXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_MCST_MASK_CTLr
#define WRITE_RXTXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_MCST_MASK_CTLr
#define MODIFY_RXTXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_MCST_MASK_CTLr
#define READLN_RXTXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_MCST_MASK_CTLr
#define WRITELN_RXTXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_MCST_MASK_CTLr
#define WRITEALL_RXTXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0bb
 * DEVAD:    1
 * DESC:     RXTXCOM_OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     OSR_MODE         OSR Mode status after the osr_mode_frc/frc_val mux.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     PAM4_MODE        PAM4 signalling mode status after the pam4_mode_frc/frc_val mux.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_er_mode reg field when 1'b1 is PAM4 ER mode and 1'b0 is PAM4 NR mode)Reserved      3'd2:3d7
 *     MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr (0x0001d0bb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_OSR_MODE_STS_MC_MASK.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t rxtxcom_osr_mode_sts_mc_mask[1];
	uint32_t _rxtxcom_osr_mode_sts_mc_mask;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).rxtxcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).rxtxcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).rxtxcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).rxtxcom_osr_mode_sts_mc_mask[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_GET(r) ((((r).rxtxcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET(r) (((r).rxtxcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET(r,f) (r).rxtxcom_osr_mode_sts_mc_mask[0]=(((r).rxtxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXTXCOM_OSR_MODE_STS_MC_MASK.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_t RXTXCOM_OSR_MODE_STS_MC_MASKr_t;
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_MULTICAST_MASK_CONTROL_STATUSf_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_PAM4_MODEf_SET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_GET
#define RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr_OSR_MODEf_SET
#define READ_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_OSR_MODE_STS_MC_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXTXCOM_LN_S_RSTB_CTL
 * BLOCKS:   RXTXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd0be
 * DEVAD:    1
 * DESC:     RXTXCOM_LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_S_RSTB        Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *     HW_FW_HANDSHAKE_DISABLE 1: disables the HW-FW handshake logic for the TX lane which means there is no acknowledgement required from uC and lane reset will be de-asserted once reset register/pin conditions are de-asserted.This register bit is unused in RX lane.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr (0x0001d0be | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXTXCOM_LN_S_RSTB_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rxtxcom_ln_s_rstb_ctl[1];
	uint32_t _rxtxcom_ln_s_rstb_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_CLR(r) (r).rxtxcom_ln_s_rstb_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).rxtxcom_ln_s_rstb_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_GET(r) (r).rxtxcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).rxtxcom_ln_s_rstb_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).rxtxcom_ln_s_rstb_ctl[0]=(((r).rxtxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET(r) (((r).rxtxcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET(r,f) (r).rxtxcom_ln_s_rstb_ctl[0]=(((r).rxtxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXTXCOM_LN_S_RSTB_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr,(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxtxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxtxcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr
#define RXTXCOM_LN_S_RSTB_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_t RXTXCOM_LN_S_RSTB_CTLr_t;
#define RXTXCOM_LN_S_RSTB_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_CLR
#define RXTXCOM_LN_S_RSTB_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_SET
#define RXTXCOM_LN_S_RSTB_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_GET
#define RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_GET
#define RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_HW_FW_HANDSHAKE_DISABLEf_SET
#define RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_GET
#define RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr_LN_S_RSTBf_SET
#define READ_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXTXCOM_LN_S_RSTB_CTLr
#define WRITE_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXTXCOM_LN_S_RSTB_CTLr
#define MODIFY_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXTXCOM_LN_S_RSTB_CTLr
#define READLN_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXTXCOM_LN_S_RSTB_CTLr
#define WRITELN_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXTXCOM_LN_S_RSTB_CTLr
#define WRITEALL_RXTXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXTXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXTXCOM_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_RX_RX_CTL_10
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0ca
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_PF3_CTRL  controls boost for new PF with higher freq range, Gray code amsbus ctrl_out  163:160
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r (0x0001d0ca | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_RX_CTL_10.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_s {
	uint32_t v[1];
	uint32_t ams_rx_rx_ctl_10[1];
	uint32_t _ams_rx_rx_ctl_10;
} BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_CLR(r) (r).ams_rx_rx_ctl_10[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_SET(r,d) (r).ams_rx_rx_ctl_10[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_GET(r) (r).ams_rx_rx_ctl_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_GET(r) (((r).ams_rx_rx_ctl_10[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_SET(r,f) (r).ams_rx_rx_ctl_10[0]=(((r).ams_rx_rx_ctl_10[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_RX_RX_CTL_10.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r,(_r._ams_rx_rx_ctl_10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r,(_r._ams_rx_rx_ctl_10)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r,(_r._ams_rx_rx_ctl_10))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_RX_RX_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl_10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_RX_RX_CTL_10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_rx_ctl_10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_RX_RX_CTL_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_rx_ctl_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_RX_CTL_10r BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r
#define AMS_RX_RX_CTL_10r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_t AMS_RX_RX_CTL_10r_t;
#define AMS_RX_RX_CTL_10r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_CLR
#define AMS_RX_RX_CTL_10r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_SET
#define AMS_RX_RX_CTL_10r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_GET
#define AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r_AMS_RX_PF3_CTRLf_SET
#define READ_AMS_RX_RX_CTL_10r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_RX_RX_CTL_10r
#define WRITE_AMS_RX_RX_CTL_10r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_RX_RX_CTL_10r
#define MODIFY_AMS_RX_RX_CTL_10r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_RX_RX_CTL_10r
#define READLN_AMS_RX_RX_CTL_10r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_RX_RX_CTL_10r
#define WRITELN_AMS_RX_RX_CTL_10r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_RX_RX_CTL_10r
#define WRITEALL_AMS_RX_RX_CTL_10r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_RX_RX_CTL_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_RX_RX_CTL_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_TX_TX_CTL3
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d3
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_SPARE_52_48 AMS reserved[52:48] amsbus ctrl_out  52:48
 *     AMS_TX_PDET_MODE select update rate for phase detect (pdet) output. 0:Fwclk, 1:Fwclk/5 amsbus ctrl_out  53:53
 *     AMS_TX_SPARE_54  AMS reserved [54] amsbus ctrl_out  54:54
 *     AMS_TX_SEL_TXMASTER select TX lane as master, only one TX lane can be set to master. amsbus ctrl_out  55:55
 *     AMS_TX_SPARE_63_56 AMS reserved[63:56] amsbus ctrl_out  63:56
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r (0x0001d0d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_CTL3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_ctl3[1];
	uint32_t _ams_tx_tx_ctl3;
} BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_CLR(r) (r).ams_tx_tx_ctl3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_SET(r,d) (r).ams_tx_tx_ctl3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_GET(r) (r).ams_tx_tx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET(r) ((((r).ams_tx_tx_ctl3[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_GET(r) (((r).ams_tx_tx_ctl3[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_SET(r,f) (r).ams_tx_tx_ctl3[0]=(((r).ams_tx_tx_ctl3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_TX_TX_CTL3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r,(_r._ams_tx_tx_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r,(_r._ams_tx_tx_ctl3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r,(_r._ams_tx_tx_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_TX_TX_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_TX_TX_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_TX_TX_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_tx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_CTL3r BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r
#define AMS_TX_TX_CTL3r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_t AMS_TX_TX_CTL3r_t;
#define AMS_TX_TX_CTL3r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_CLR
#define AMS_TX_TX_CTL3r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_SET
#define AMS_TX_TX_CTL3r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_63_56f_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SEL_TXMASTERf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_54f_SET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_GET
#define AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_PDET_MODEf_SET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_GET
#define AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r_AMS_TX_SPARE_52_48f_SET
#define READ_AMS_TX_TX_CTL3r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_TX_TX_CTL3r
#define WRITE_AMS_TX_TX_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_TX_TX_CTL3r
#define MODIFY_AMS_TX_TX_CTL3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_TX_TX_CTL3r
#define READLN_AMS_TX_TX_CTL3r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_TX_TX_CTL3r
#define WRITELN_AMS_TX_TX_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_TX_TX_CTL3r
#define WRITEALL_AMS_TX_TX_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_TX_TX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_TX_TX_STS
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d9
 * DEVAD:    1
 * DESC:     AMS TX STATUS
 * RESETVAL: 0xa0 (160)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_TX_VERSION_ID AMS version ID. Used to track the core version.
 *     AMS_TX_ANA_RESCAL Copy of ana_rescal bus. Control code for global resistor calibration. See AMS for more details.
 *     AMS_TX_DRV_HV_DISABLE Copy of of tx_drv_hv_disable. By default, assume high voltage driver (HVD) mode and 1.25V
 *     AMS_TX_SPARE_13  AMS tx_sts bit13 reserve
 *     AMS_TX_LANE_ID   TX Lane ID
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr (0x0001d0d9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_TX_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_s {
	uint32_t v[1];
	uint32_t ams_tx_tx_sts[1];
	uint32_t _ams_tx_tx_sts;
} BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_CLR(r) (r).ams_tx_tx_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_SET(r,d) (r).ams_tx_tx_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_GET(r) (r).ams_tx_tx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_GET(r) ((((r).ams_tx_tx_sts[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET(r) ((((r).ams_tx_tx_sts[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET(r) (((r).ams_tx_tx_sts[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET(r,f) (r).ams_tx_tx_sts[0]=(((r).ams_tx_tx_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AMS_TX_TX_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr,(_r._ams_tx_tx_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr,(_r._ams_tx_tx_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr,(_r._ams_tx_tx_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_TX_TX_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_TX_TX_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_tx_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_TX_TX_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_tx_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_TX_STSr BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr
#define AMS_TX_TX_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_t AMS_TX_TX_STSr_t;
#define AMS_TX_TX_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_CLR
#define AMS_TX_TX_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_SET
#define AMS_TX_TX_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_GET
#define AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_GET
#define AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_LANE_IDf_SET
#define AMS_TX_TX_STSr_AMS_TX_SPARE_13f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_GET
#define AMS_TX_TX_STSr_AMS_TX_SPARE_13f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_SPARE_13f_SET
#define AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_GET
#define AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_DRV_HV_DISABLEf_SET
#define AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_GET
#define AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_ANA_RESCALf_SET
#define AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_GET
#define AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr_AMS_TX_VERSION_IDf_SET
#define READ_AMS_TX_TX_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AMS_TX_TX_STSr
#define WRITE_AMS_TX_TX_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_TX_TX_STSr
#define MODIFY_AMS_TX_TX_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_TX_TX_STSr
#define READLN_AMS_TX_TX_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_TX_TX_STSr
#define WRITELN_AMS_TX_TX_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_TX_TX_STSr
#define WRITEALL_AMS_TX_TX_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_TX_TX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_TX_TX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  SIGDET_STS0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e8
 * DEVAD:    1
 * DESC:     SIGDET_STATUS_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SIGNAL_DETECT    Filtered version of Signal Detect after frc/frc_val.
 *     SIGNAL_DETECT_CHANGE This latches the transition on signal_detect and cleared on read.
 *     SIGNAL_DETECT_RAW Raw version of Signal Detect going into the filter.
 *     SIGNAL_DETECT_RAW_CHANGE This latches the transition on signal_detect_raw and cleared on read.
 *     EXT_SIGDET       External LOS/sigdet from the pin going into the sigdet filter.
 *     EXT_SIGDET_CHANGE This latches the transition on ext_sigdet and cleared on read.
 *     AFE_SIGDET       Internal sigdet from the AFE sigdet block going into the sigdet filter.
 *     AFE_SIGDET_CHANGE This latches the transition on afe_sigdet and cleared on read.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r (0x0001d0e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_s {
	uint32_t v[1];
	uint32_t sigdet_sts0[1];
	uint32_t _sigdet_sts0;
} BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_CLR(r) (r).sigdet_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SET(r,d) (r).sigdet_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_GET(r) (r).sigdet_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDETf_GET(r) ((((r).sigdet_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDETf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET(r) ((((r).sigdet_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r,(_r._sigdet_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_SIGDET_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_SIGDET_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SIGDET_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS0r BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r
#define SIGDET_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_t SIGDET_STS0r_t;
#define SIGDET_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_CLR
#define SIGDET_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SET
#define SIGDET_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_AFE_SIGDETf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDETf_GET
#define SIGDET_STS0r_AFE_SIGDETf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_AFE_SIGDETf_SET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_GET
#define SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDET_CHANGEf_SET
#define SIGDET_STS0r_EXT_SIGDETf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDETf_GET
#define SIGDET_STS0r_EXT_SIGDETf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_EXT_SIGDETf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECTf_GET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET
#define SIGDET_STS0r_SIGNAL_DETECTf_SET BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_SIGDET_STS0r
#define WRITE_SIGDET_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_SIGDET_STS0r
#define MODIFY_SIGDET_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_SIGDET_STS0r
#define READLN_SIGDET_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_SIGDET_STS0r
#define WRITELN_SIGDET_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_SIGDET_STS0r
#define WRITEALL_SIGDET_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_SIGDET_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_SIGDET_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DIG_REVID0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd100
 * DEVAD:    1
 * DESC:     REVID0
 * RESETVAL: 0x366 (870)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_MODEL      model number
 *     REVID_PROCESS    technology process0 = 90nm1 = 65nm2 = 40nm3 = 28nm4 = 20nm5 = 16nm FFP6 = 16nm FFC7 = 7nm
 *     REVID_BONDING    bonding0 = wire bond1 = flip chip2-3 = reserved
 *     REVID_REV_NUMBER Metal mask revision number
 *     REVID_REV_LETTER All layer revision letter0 = revA1 = revB2 = revC3 = revD
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r (0x0001d100 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_s {
	uint32_t v[1];
	uint32_t dig_revid0[1];
	uint32_t _dig_revid0;
} BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_CLR(r) (r).dig_revid0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_SET(r,d) (r).dig_revid0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_GET(r) (r).dig_revid0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET(r) ((((r).dig_revid0[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET(r) ((((r).dig_revid0[0]) >> 11) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_BONDINGf_GET(r) ((((r).dig_revid0[0]) >> 9) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_BONDINGf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_PROCESSf_GET(r) ((((r).dig_revid0[0]) >> 6) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_PROCESSf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_MODELf_GET(r) (((r).dig_revid0[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_MODELf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DIG_REVID0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r,(_r._dig_revid0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_REVID0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_REVID0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_REVID0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID0r BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r
#define DIG_REVID0r_SIZE BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_t DIG_REVID0r_t;
#define DIG_REVID0r_CLR BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_CLR
#define DIG_REVID0r_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_SET
#define DIG_REVID0r_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_GET
#define DIG_REVID0r_REVID_REV_LETTERf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET
#define DIG_REVID0r_REVID_REV_LETTERf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET
#define DIG_REVID0r_REVID_REV_NUMBERf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET
#define DIG_REVID0r_REVID_REV_NUMBERf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET
#define DIG_REVID0r_REVID_BONDINGf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_BONDINGf_GET
#define DIG_REVID0r_REVID_BONDINGf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_BONDINGf_SET
#define DIG_REVID0r_REVID_PROCESSf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_PROCESSf_GET
#define DIG_REVID0r_REVID_PROCESSf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_PROCESSf_SET
#define DIG_REVID0r_REVID_MODELf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_MODELf_GET
#define DIG_REVID0r_REVID_MODELf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r_REVID_MODELf_SET
#define READ_DIG_REVID0r BCMI_TSCBH_FLEXE_XGXS_READ_DIG_REVID0r
#define WRITE_DIG_REVID0r BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_REVID0r
#define MODIFY_DIG_REVID0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_REVID0r
#define READLN_DIG_REVID0r BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_REVID0r
#define WRITELN_DIG_REVID0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_REVID0r
#define WRITEALL_DIG_REVID0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_REVID0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DIG_REVID0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DIG_RST_CTL_PMD
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd101
 * DEVAD:    1
 * DESC:     RESET_CONTROL_PMD
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_S_RSTB      Active Low Core Level Soft Reset. This soft reset is equivalent to the hard reset input pin pmd_por_h_rstb.Assertion of this register resets all the PMD logic including registers except MDIO, PMI-LP, MICRO and RMIC interface related logic which means.this register can be written to 1'b0 or 1'b1 from any of the register access interfaces.This regiter bit can only be reset by assertion of the hard reset input pin pmd_por_h_rstb.
 *     UC_ACTIVE        When set to 1'b1 then Hardware should wait for uC handshakes to wake up from datapath resetWhen set to 1'b0 then Hardware can internally assume that uc_ack_* = 1.This regiter bit can only be reset by assertion of the hard reset input pin pmd_por_h_rstb.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr (0x0001d101 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_PMD.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_pmd[1];
	uint32_t _dig_rst_ctl_pmd;
} BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_CLR(r) (r).dig_rst_ctl_pmd[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_SET(r,d) (r).dig_rst_ctl_pmd[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_GET(r) (r).dig_rst_ctl_pmd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_GET(r) ((((r).dig_rst_ctl_pmd[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_SET(r,f) (r).dig_rst_ctl_pmd[0]=(((r).dig_rst_ctl_pmd[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET(r) (((r).dig_rst_ctl_pmd[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET(r,f) (r).dig_rst_ctl_pmd[0]=(((r).dig_rst_ctl_pmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_RST_CTL_PMD.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_RST_CTL_PMDr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_RST_CTL_PMDr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_RST_CTL_PMDr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_pmd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_PMDr BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr
#define DIG_RST_CTL_PMDr_SIZE BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_t DIG_RST_CTL_PMDr_t;
#define DIG_RST_CTL_PMDr_CLR BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_CLR
#define DIG_RST_CTL_PMDr_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_SET
#define DIG_RST_CTL_PMDr_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_GET
#define DIG_RST_CTL_PMDr_UC_ACTIVEf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_GET
#define DIG_RST_CTL_PMDr_UC_ACTIVEf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_UC_ACTIVEf_SET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET
#define READ_DIG_RST_CTL_PMDr BCMI_TSCBH_FLEXE_XGXS_READ_DIG_RST_CTL_PMDr
#define WRITE_DIG_RST_CTL_PMDr BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_RST_CTL_PMDr
#define MODIFY_DIG_RST_CTL_PMDr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_RST_CTL_PMDr
#define READLN_DIG_RST_CTL_PMDr BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_RST_CTL_PMDr
#define WRITELN_DIG_RST_CTL_PMDr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_RST_CTL_PMDr
#define WRITEALL_DIG_RST_CTL_PMDr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_RST_CTL_PMDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_PMDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DIG_RST_CTL_CORE_DP
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd102
 * DEVAD:    1
 * DESC:     RESET_CONTROL_CORE_DP
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SUP_RST_SEQ_FRC_VAL Suppress reset sequence force value.
 *     SUP_RST_SEQ_FRC  Suppress reset sequence force.
 *     PMD_MDIO_TRANS_PKILL 1'b1 will disable the pmd_mdio_trans pin.
 *     DISABLE_ACK_TIMEOUT Setting this bit to 1 disables the ack timeout for all ports.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr (0x0001d102 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_CORE_DP.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_core_dp[1];
	uint32_t _dig_rst_ctl_core_dp;
} BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_CLR(r) (r).dig_rst_ctl_core_dp[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SET(r,d) (r).dig_rst_ctl_core_dp[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_GET(r) (r).dig_rst_ctl_core_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))

/*
 * These macros can be used to access DIG_RST_CTL_CORE_DP.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_core_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_CORE_DPr BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr
#define DIG_RST_CTL_CORE_DPr_SIZE BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_t DIG_RST_CTL_CORE_DPr_t;
#define DIG_RST_CTL_CORE_DPr_CLR BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_CLR
#define DIG_RST_CTL_CORE_DPr_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SET
#define DIG_RST_CTL_CORE_DPr_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_GET
#define DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_GET
#define DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_DISABLE_ACK_TIMEOUTf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET
#define READ_DIG_RST_CTL_CORE_DPr BCMI_TSCBH_FLEXE_XGXS_READ_DIG_RST_CTL_CORE_DPr
#define WRITE_DIG_RST_CTL_CORE_DPr BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_RST_CTL_CORE_DPr
#define MODIFY_DIG_RST_CTL_CORE_DPr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr
#define READLN_DIG_RST_CTL_CORE_DPr BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_RST_CTL_CORE_DPr
#define WRITELN_DIG_RST_CTL_CORE_DPr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr
#define WRITEALL_DIG_RST_CTL_CORE_DPr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DIG_RST_CTL_CORE_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DIG_TOP_USER_CTL0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd104
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL_0
 * RESETVAL: 0x271 (625)
 * ACCESS:   R/W
 * FIELDS:
 *     HEARTBEAT_COUNT_1US Heartbeat timer count in comclk cycles to create 1us heartbeat_1us period. It should be programmed to the nearest increment of 0.25Mhz value of the comclk frequency in Mhz.For example, for comclk of 125 Mhz, it should be programmed to 10'd500. For 156.25 Mhz comclk, it should be programmed to 10'd625 and similarly for any other comclk frequency.
 *     MASKDATA_BUS_ASSIGN This register is used to assign the maskdata bus to either the mdio or pmi_lp port .0: maskdata register is assigned to MDIO port1: maskdata register is assigned to PMI_LP port
 *     MDIO_FAST_MODE_FRC_VAL This value will be used to drive the internal mdio_fast_mode signal when mdio_fast_mode_frc is set to 1.0: Normal mdio frame operation with preamble1: Fast mdio frame operation without preamble
 *     MDIO_FAST_MODE_FRC Setting this bit will allow the register value to be used for mdio_fast_mode.Otherwise the pin mdio_fast_mode will be used.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r (0x0001d104 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TOP_USER_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_s {
	uint32_t v[1];
	uint32_t dig_top_user_ctl0[1];
	uint32_t _dig_top_user_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_CLR(r) (r).dig_top_user_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_SET(r,d) (r).dig_top_user_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_GET(r) (r).dig_top_user_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET(r) (((r).dig_top_user_ctl0[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DIG_TOP_USER_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_TOP_USER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_TOP_USER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_top_user_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_TOP_USER_CTL0r BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r
#define DIG_TOP_USER_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_t DIG_TOP_USER_CTL0r_t;
#define DIG_TOP_USER_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_CLR
#define DIG_TOP_USER_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_SET
#define DIG_TOP_USER_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_GET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_GET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRCf_SET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_GET
#define DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MDIO_FAST_MODE_FRC_VALf_SET
#define DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_GET
#define DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_MASKDATA_BUS_ASSIGNf_SET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET
#define READ_DIG_TOP_USER_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_DIG_TOP_USER_CTL0r
#define WRITE_DIG_TOP_USER_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_TOP_USER_CTL0r
#define MODIFY_DIG_TOP_USER_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_TOP_USER_CTL0r
#define READLN_DIG_TOP_USER_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_TOP_USER_CTL0r
#define WRITELN_DIG_TOP_USER_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_TOP_USER_CTL0r
#define WRITEALL_DIG_TOP_USER_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_TOP_USER_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DIG_TOP_USER_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DIG_CORE_DP_RST_ST_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd108
 * DEVAD:    1
 * DESC:     CORE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_RESET_RELEASED_INDEX Index of the lane number of the first TX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED_INDEX Index of the lane number of the first RX lane in lane_reset_released state.
 *     LANE_RESET_RELEASED indicates if a lane is currently at {rx_lane_dp_reset_active, rx_lane_dp_reset_occurred} = 01.
 *     TX_LANE_RESET_RELEASED indicates if a lane is currently at {tx_lane_dp_reset_active, tx_lane_dp_reset_occurred} = 01.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr (0x0001d108 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_DP_RST_ST_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t dig_core_dp_rst_st_sts[1];
	uint32_t _dig_core_dp_rst_st_sts;
} BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR(r) (r).dig_core_dp_rst_st_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_SET(r,d) (r).dig_core_dp_rst_st_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_GET(r) (r).dig_core_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 3) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))

/*
 * These macros can be used to access DIG_CORE_DP_RST_ST_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr
#define DIG_CORE_DP_RST_ST_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_t DIG_CORE_DP_RST_ST_STSr_t;
#define DIG_CORE_DP_RST_ST_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR
#define DIG_CORE_DP_RST_ST_STSr_SET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_SET
#define DIG_CORE_DP_RST_ST_STSr_GET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr_TX_LANE_RESET_RELEASED_INDEXf_SET
#define READ_DIG_CORE_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READ_DIG_CORE_DP_RST_ST_STSr
#define WRITE_DIG_CORE_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr
#define MODIFY_DIG_CORE_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr
#define READLN_DIG_CORE_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr
#define WRITELN_DIG_CORE_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr
#define WRITEALL_DIG_CORE_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DIG_CORE_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DIG_REVID1
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10a
 * DEVAD:    1
 * DESC:     REVID1
 * RESETVAL: 0x803c (32828)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_EEE        EEE support present in core
 *     REVID_LLP        Ultra low latency path present in core
 *     REVID_PIR        PCS interface retiming flops present in core
 *     REVID_CL72       Clause 72 present in core
 *     REVID_MICRO      Microcontroller present in core
 *     REVID_MDIO       MDIO interface present in core
 *     REVID_MULTIPLICITY Number of lanes
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r (0x0001d10a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_s {
	uint32_t v[1];
	uint32_t dig_revid1[1];
	uint32_t _dig_revid1;
} BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_CLR(r) (r).dig_revid1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_SET(r,d) (r).dig_revid1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_GET(r) (r).dig_revid1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET(r) ((((r).dig_revid1[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MDIOf_GET(r) ((((r).dig_revid1[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MDIOf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MICROf_GET(r) ((((r).dig_revid1[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MICROf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_CL72f_GET(r) ((((r).dig_revid1[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_CL72f_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_PIRf_GET(r) ((((r).dig_revid1[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_PIRf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_LLPf_GET(r) ((((r).dig_revid1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_LLPf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_EEEf_GET(r) (((r).dig_revid1[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_EEEf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_REVID1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r,(_r._dig_revid1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_REVID1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_REVID1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_REVID1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID1r BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r
#define DIG_REVID1r_SIZE BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_t DIG_REVID1r_t;
#define DIG_REVID1r_CLR BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_CLR
#define DIG_REVID1r_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_SET
#define DIG_REVID1r_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET
#define DIG_REVID1r_REVID_MDIOf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MDIOf_GET
#define DIG_REVID1r_REVID_MDIOf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MDIOf_SET
#define DIG_REVID1r_REVID_MICROf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MICROf_GET
#define DIG_REVID1r_REVID_MICROf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_MICROf_SET
#define DIG_REVID1r_REVID_CL72f_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_CL72f_GET
#define DIG_REVID1r_REVID_CL72f_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_CL72f_SET
#define DIG_REVID1r_REVID_PIRf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_PIRf_GET
#define DIG_REVID1r_REVID_PIRf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_PIRf_SET
#define DIG_REVID1r_REVID_LLPf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_LLPf_GET
#define DIG_REVID1r_REVID_LLPf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_LLPf_SET
#define DIG_REVID1r_REVID_EEEf_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_EEEf_GET
#define DIG_REVID1r_REVID_EEEf_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r_REVID_EEEf_SET
#define READ_DIG_REVID1r BCMI_TSCBH_FLEXE_XGXS_READ_DIG_REVID1r
#define WRITE_DIG_REVID1r BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_REVID1r
#define MODIFY_DIG_REVID1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_REVID1r
#define READLN_DIG_REVID1r BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_REVID1r
#define WRITELN_DIG_REVID1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_REVID1r
#define WRITEALL_DIG_REVID1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_REVID1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DIG_REVID1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DIG_REVID2
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10e
 * DEVAD:    1
 * DESC:     REVID2
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID2           Revision ID2 code
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r (0x0001d10e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_s {
	uint32_t v[1];
	uint32_t dig_revid2[1];
	uint32_t _dig_revid2;
} BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_CLR(r) (r).dig_revid2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_SET(r,d) (r).dig_revid2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_GET(r) (r).dig_revid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_REVID2f_GET(r) (((r).dig_revid2[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_REVID2f_SET(r,f) (r).dig_revid2[0]=(((r).dig_revid2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DIG_REVID2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r,(_r._dig_revid2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_REVID2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_REVID2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_REVID2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID2r BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r
#define DIG_REVID2r_SIZE BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_t DIG_REVID2r_t;
#define DIG_REVID2r_CLR BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_CLR
#define DIG_REVID2r_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_SET
#define DIG_REVID2r_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_GET
#define DIG_REVID2r_REVID2f_GET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_REVID2f_GET
#define DIG_REVID2r_REVID2f_SET BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r_REVID2f_SET
#define READ_DIG_REVID2r BCMI_TSCBH_FLEXE_XGXS_READ_DIG_REVID2r
#define WRITE_DIG_REVID2r BCMI_TSCBH_FLEXE_XGXS_WRITE_DIG_REVID2r
#define MODIFY_DIG_REVID2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_DIG_REVID2r
#define READLN_DIG_REVID2r BCMI_TSCBH_FLEXE_XGXS_READLN_DIG_REVID2r
#define WRITELN_DIG_REVID2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_DIG_REVID2r
#define WRITEALL_DIG_REVID2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DIG_REVID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DIG_REVID2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL0
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd110
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_0
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_SET_CLK4PCS program clk freq for clk4pcs. Combine with pll_ctrl[107] to form 3-bit control register. See AMS for details. amsbus ctrl_out  1:0DFT_MUX
 *     AMS_PLL_CP_CMFDBK_IADJ increases CP opamp current, 00:50uA, x1:CMF=100uA, 1x:UG=100uA amsbus ctrl_out  3:2DFT_MUX
 *     AMS_PLL_FP3_CTRL adjusts caps in 3rd pole, typically used in frc-N mode, and with fp3_rh, higher code=lower pole freq amsbus ctrl_out  7:4DFT_MUX
 *     AMS_PLL_FP3_RH   adjust res in 3rd pole by 4x amsbus ctrl_out  8:8DFT_MUX
 *     AMS_PLL_LPF_RZ   adjust Rz in the loop filter, 00=0.71K, 01=1K, 10=1.7K, 11=5K amsbus ctrl_out  10:9DFT_MUX
 *     AMS_PLL_REFCLK_1X When this bit is set, AFE outputs full speed refclk regardless of div4 or div2 values amsbus ctrl_out  11:11DFT_DFS=1'd0
 *     AMS_PLL_RESCAL_AUX over-ride ana_rescal[3:0] if force_rescal(pll_ctrl[79])=1 amsbus ctrl_out  15:12DFT_MUX
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r (0x0001d110 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl0[1];
	uint32_t _ams_pll_pll_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_CLR(r) (r).ams_pll_pll_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_SET(r,d) (r).ams_pll_pll_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_GET(r) (r).ams_pll_pll_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_REFCLK_1Xf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_REFCLK_1Xf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 9) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_GET(r) ((((r).ams_pll_pll_ctl0[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET(r) (((r).ams_pll_pll_ctl0[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET(r,f) (r).ams_pll_pll_ctl0[0]=(((r).ams_pll_pll_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r,(_r._ams_pll_pll_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r,(_r._ams_pll_pll_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r,(_r._ams_pll_pll_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL0r BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r
#define AMS_PLL_PLL_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_t AMS_PLL_PLL_CTL0r_t;
#define AMS_PLL_PLL_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_CLR
#define AMS_PLL_PLL_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_SET
#define AMS_PLL_PLL_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_RESCAL_AUXf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_REFCLK_1Xf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_REFCLK_1Xf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_REFCLK_1Xf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_REFCLK_1Xf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_LPF_RZf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_RHf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_FP3_CTRLf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_CP_CMFDBK_IADJf_SET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_GET
#define AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r_AMS_PLL_SET_CLK4PCSf_SET
#define READ_AMS_PLL_PLL_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL0r
#define WRITE_AMS_PLL_PLL_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL0r
#define MODIFY_AMS_PLL_PLL_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL0r
#define READLN_AMS_PLL_PLL_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL0r
#define WRITELN_AMS_PLL_PLL_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL0r
#define WRITEALL_AMS_PLL_PLL_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL1
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd111
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_1
 * RESETVAL: 0x8001 (32769)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_COMP_THRESH VCO tuning threshold (See AMS for details) amsbus ctrl_out  18:16DFT_MUX
 *     AMS_PLL_DRV_HV_DISABLE must be 0 if TVDD1P20=1.2V amsbus ctrl_out  19:19DFT_MUX
 *     AMS_PLL_MUXDIV_ICTRL_0 muxdiv_ictrl<0> - bias current control amsbus ctrl_out  20:20DFT_DFS=1'd0
 *     AMS_PLL_VCO_RES_CS test mode to enable a resistor only current bias for the main VCO, should reduce RJ, possibly worse PSRR amsbus ctrl_out  21:21DFT_MUX
 *     AMS_PLL_MUXDIV_ICTRL_1 muxdiv_ictrl<1> - bias current control amsbus ctrl_out  22:22DFT_MUX
 *     AMS_PLL_VCO2_15G enable and select the 15-22.6G VCO amsbus ctrl_out  23:23DFT_MUX
 *     AMS_PLL_VCOICTRL adjusts VCO bias current, ~6% steps. Only active if pll_ctrl[21]=0. amsbus ctrl_out  25:24DFT_MUX
 *     AMS_PLL_TEST_VCO2_CSSW test mode to disable current bias and convert current source to a switch. Could help with startup problems. amsbus ctrl_out  26:26DFT_MUX
 *     AMS_PLL_IVCO     ivco[2:0], max, min, mode amsbus ctrl_out  29:27DFT_MUX
 *     AMS_PLL_RESET    PLL reset, active high amsbus ctrl_out  30:30DFT_MUX
 *     AMS_PLL_ENABLE_FTUNE comparator for VCO tuning amsbus ctrl_out  31:31DFT_MUX
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r (0x0001d111 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl1[1];
	uint32_t _ams_pll_pll_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_CLR(r) (r).ams_pll_pll_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_SET(r,d) (r).ams_pll_pll_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_GET(r) (r).ams_pll_pll_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 11) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_1f_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_1f_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_0f_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_0f_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET(r) ((((r).ams_pll_pll_ctl1[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_GET(r) (((r).ams_pll_pll_ctl1[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_SET(r,f) (r).ams_pll_pll_ctl1[0]=(((r).ams_pll_pll_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r,(_r._ams_pll_pll_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r,(_r._ams_pll_pll_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r,(_r._ams_pll_pll_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL1r BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r
#define AMS_PLL_PLL_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_t AMS_PLL_PLL_CTL1r_t;
#define AMS_PLL_PLL_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_CLR
#define AMS_PLL_PLL_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_SET
#define AMS_PLL_PLL_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_RESETf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_IVCOf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_TEST_VCO2_CSSWf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO2_15Gf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_1f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_1f_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_1f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_1f_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_VCO_RES_CSf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_0f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_0f_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_0f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_MUXDIV_ICTRL_0f_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_GET
#define AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r_AMS_PLL_COMP_THRESHf_SET
#define READ_AMS_PLL_PLL_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL1r
#define WRITE_AMS_PLL_PLL_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL1r
#define MODIFY_AMS_PLL_PLL_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL1r
#define READLN_AMS_PLL_PLL_CTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL1r
#define WRITELN_AMS_PLL_PLL_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL1r
#define WRITEALL_AMS_PLL_PLL_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL4
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd114
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_4
 * RESETVAL: 0x77 (119)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_BGR_PTATADJ BG bias, same decoder as CTAT amsbus ctrl_out  67:64DFT_MUX
 *     AMS_PLL_BGR_CTATADJ BG CTAT bias control. See AMS for details. amsbus ctrl_out  71:68DFT_MUX
 *     AMS_PLL_PLL2RX_CLKBW controls BW of PLL output buffers for the RX/TX clks. See AMS for details. amsbus ctrl_out  73:72DFT_MUX
 *     AMS_PLL_TEST_VDDR4BG test mode to force VddR bias to BG. See AMS for details. amsbus ctrl_out  74:74DFT_MUX
 *     AMS_PLL_VDDR_BGB select between PVDD or BG, default, Vreference for the PLL bias currents amsbus ctrl_out  75:75DFT_MUX
 *     AMS_PLL_KVH_FORCE force Kvco, override tuning control amsbus ctrl_out  77:76DFT_MUX
 *     AMS_PLL_FORCE_KVH_BW enable force KVH,BW,test_vco2_cssw modes amsbus ctrl_out  78:78DFT_MUX
 *     AMS_PLL_FORCE_RESCAL force_rescal with pll_ctrl<15:12> amsbus ctrl_out  79:79DFT_MUX
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r (0x0001d114 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl4[1];
	uint32_t _ams_pll_pll_ctl4;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_CLR(r) (r).ams_pll_pll_ctl4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_SET(r,d) (r).ams_pll_pll_ctl4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_GET(r) (r).ams_pll_pll_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl4[0]) >> 4) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET(r) (((r).ams_pll_pll_ctl4[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl4[0]=(((r).ams_pll_pll_ctl4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r,(_r._ams_pll_pll_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r,(_r._ams_pll_pll_ctl4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r,(_r._ams_pll_pll_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL4r BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r
#define AMS_PLL_PLL_CTL4r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_t AMS_PLL_PLL_CTL4r_t;
#define AMS_PLL_PLL_CTL4r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_CLR
#define AMS_PLL_PLL_CTL4r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_SET
#define AMS_PLL_PLL_CTL4r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_TEST_VDDR4BGf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET
#define AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET
#define READ_AMS_PLL_PLL_CTL4r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL4r
#define WRITE_AMS_PLL_PLL_CTL4r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL4r
#define MODIFY_AMS_PLL_PLL_CTL4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL4r
#define READLN_AMS_PLL_PLL_CTL4r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL4r
#define WRITELN_AMS_PLL_PLL_CTL4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL4r
#define WRITEALL_AMS_PLL_PLL_CTL4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL6
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd116
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_RTERM200 set refclk termination impedance to 200 ohm amsbus ctrl_out  96:96DFT_MUX
 *     AMS_PLL_DIV2     input refclk divided 2 amsbus ctrl_out  97:97
 *     AMS_PLL_DIV4     input refclk divided 4 amsbus ctrl_out  98:98
 *     AMS_PLL_RTERM400 set refclk termination impedance to 400 ohm differential amsbus ctrl_out  99:99DFT_MUX
 *     AMS_PLL_RTERMHIZ set refclk termination impedance to HiZ amsbus ctrl_out  100:100DFT_MUX
 *     AMS_PLL_RTERM300 set refclk termination impedance to 300 ohm differential amsbus ctrl_out  101:101DFT_MUX
 *     AMS_PLL_CLK4SYNC_DIV Sets clk4sync output freq, 0=8T, 1=6T and T=1/VCO freq amsbus ctrl_out  102:102DFT_MUX
 *     AMS_PLL_CLK4SYNC_EN Enable control for clk4sync clock (0=disable, 1=enable) amsbus ctrl_out  103:103
 *     AMS_PLL_DOUBLER_CAP increases supported refclk freq by reducing delay with lower cap amsbus ctrl_out  106:104DFT_MUX
 *     AMS_PLL_SET_CLK4PCS_MSB add 3rd bit to expand divider options, see complete table in defintion for pll*_clk4pcs, msb of set_clk4pcs control. See definition of control bits 1:0 amsbus ctrl_out  107:107DFT_MUX
 *     AMS_PLL_DOUBLER_RES increases supported refclk freq by reducing delay with lower res. See AMS for details. amsbus ctrl_out  110:108DFT_MUX
 *     AMS_PLL_REFCLK_DOUBLER test mode pending lab data, increases internal refclk freq by 2X and should be useful for frac-N mode to reduce the Q noise. amsbus ctrl_out  111:111DFT_MUX
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r (0x0001d116 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL6.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl6[1];
	uint32_t _ams_pll_pll_ctl6;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_CLR(r) (r).ams_pll_pll_ctl6[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_SET(r,d) (r).ams_pll_pll_ctl6[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_GET(r) (r).ams_pll_pll_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 12) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 8) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET(r) ((((r).ams_pll_pll_ctl6[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET(r) (((r).ams_pll_pll_ctl6[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET(r,f) (r).ams_pll_pll_ctl6[0]=(((r).ams_pll_pll_ctl6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL6.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r,(_r._ams_pll_pll_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r,(_r._ams_pll_pll_ctl6)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r,(_r._ams_pll_pll_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL6r BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r
#define AMS_PLL_PLL_CTL6r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_t AMS_PLL_PLL_CTL6r_t;
#define AMS_PLL_PLL_CTL6r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_CLR
#define AMS_PLL_PLL_CTL6r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_SET
#define AMS_PLL_PLL_CTL6r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_REFCLK_DOUBLERf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_RESf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_SET_CLK4PCS_MSBf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DOUBLER_CAPf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_ENf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_CLK4SYNC_DIVf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM300f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERMHIZf_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM400f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV4f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_DIV2f_SET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_GET
#define AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r_AMS_PLL_RTERM200f_SET
#define READ_AMS_PLL_PLL_CTL6r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL6r
#define WRITE_AMS_PLL_PLL_CTL6r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL6r
#define MODIFY_AMS_PLL_PLL_CTL6r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL6r
#define READLN_AMS_PLL_PLL_CTL6r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL6r
#define WRITELN_AMS_PLL_PLL_CTL6r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL6r
#define WRITEALL_AMS_PLL_PLL_CTL6r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL7
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd117
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_7
 * RESETVAL: 0x2700 (9984)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_TEST_FRACN_EN test mode to power up fracn block when using the integer block and check for noise amsbus ctrl_out  112:112DFT_MUX
 *     AMS_PLL_PFD_SKEW_ENLARGE increases above delays to ~40ps. Test mode settings for debug of VCO coupling. amsbus ctrl_out  113:113DFT_MUX
 *     AMS_PLL_PFD_FB_SKEW adds ~20ps of delay in fdbck path amsbus ctrl_out  114:114DFT_MUX
 *     AMS_PLL_PFD_REF_SKEW adds ~20ps of delay in refclk path amsbus ctrl_out  115:115DFT_MUX
 *     AMS_PLL_NDIV_FRAC_VALID toggle high, then low to load in a new value for fracn_div[17:0]. This new mode should minimize any glitches when the fractional value is changed dynamically amsbus ctrl_out  116:116DFT_MUX
 *     AMS_PLL_VCODIV_REFOUT enables VCO divided by integer value, eg 80, set by pll*_mode<4:0> and sent to pll*_refoutp/n amsbus ctrl_out  117:117DFT_MUX
 *     AMS_PLL_MIX3P1CR_CTATADJ CTAT bias control for Mix3P1C/R amsbus ctrl_out  122:118DFT_MUX
 *     AMS_PLL_MIX3P1CR_PTATADJ PTAT bias control for Mix3P1C/R which is used in RX amsbus ctrl_out  127:123DFT_MUX
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r (0x0001d117 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl7[1];
	uint32_t _ams_pll_pll_ctl7;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_CLR(r) (r).ams_pll_pll_ctl7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_SET(r,d) (r).ams_pll_pll_ctl7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_GET(r) (r).ams_pll_pll_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 11) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 6) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_GET(r) ((((r).ams_pll_pll_ctl7[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_GET(r) (((r).ams_pll_pll_ctl7[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_SET(r,f) (r).ams_pll_pll_ctl7[0]=(((r).ams_pll_pll_ctl7[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r,(_r._ams_pll_pll_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r,(_r._ams_pll_pll_ctl7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r,(_r._ams_pll_pll_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL7r BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r
#define AMS_PLL_PLL_CTL7r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_t AMS_PLL_PLL_CTL7r_t;
#define AMS_PLL_PLL_CTL7r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_CLR
#define AMS_PLL_PLL_CTL7r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_SET
#define AMS_PLL_PLL_CTL7r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_VCODIV_REFOUTf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_NDIV_FRAC_VALIDf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_REF_SKEWf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_FB_SKEWf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_PFD_SKEW_ENLARGEf_SET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_GET
#define AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r_AMS_PLL_TEST_FRACN_ENf_SET
#define READ_AMS_PLL_PLL_CTL7r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL7r
#define WRITE_AMS_PLL_PLL_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL7r
#define MODIFY_AMS_PLL_PLL_CTL7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL7r
#define READLN_AMS_PLL_PLL_CTL7r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL7r
#define WRITELN_AMS_PLL_PLL_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL7r
#define WRITEALL_AMS_PLL_PLL_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL8
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd118
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_FRACN_DIV lower 16 bits fractional control of feedback divider. See AMS for details. amsbus ctrl_out  143:128DFT_MUX
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r (0x0001d118 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL8.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl8[1];
	uint32_t _ams_pll_pll_ctl8;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_CLR(r) (r).ams_pll_pll_ctl8[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_SET(r,d) (r).ams_pll_pll_ctl8[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_GET(r) (r).ams_pll_pll_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET(r) (((r).ams_pll_pll_ctl8[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET(r,f) (r).ams_pll_pll_ctl8[0]=(((r).ams_pll_pll_ctl8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL8.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r,(_r._ams_pll_pll_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r,(_r._ams_pll_pll_ctl8)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r,(_r._ams_pll_pll_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL8r BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r
#define AMS_PLL_PLL_CTL8r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_t AMS_PLL_PLL_CTL8r_t;
#define AMS_PLL_PLL_CTL8r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_CLR
#define AMS_PLL_PLL_CTL8r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_SET
#define AMS_PLL_PLL_CTL8r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_GET
#define AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_GET
#define AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r_AMS_PLL_FRACN_DIVf_SET
#define READ_AMS_PLL_PLL_CTL8r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL8r
#define WRITE_AMS_PLL_PLL_CTL8r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL8r
#define MODIFY_AMS_PLL_PLL_CTL8r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL8r
#define READLN_AMS_PLL_PLL_CTL8r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL8r
#define WRITELN_AMS_PLL_PLL_CTL8r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL8r
#define WRITEALL_AMS_PLL_PLL_CTL8r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_CTL9
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd119
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_FRACN_DIV_17_16 Upper 2 bits for fractional divider amsbus ctrl_out  145:144DFT_MUX
 *     AMS_PLL_FRACN_DIVRANGE selects MMD integer range for the value programmed by fracn_ndiv_int[9:0]. See AMS for details. amsbus ctrl_out  146:146DFT_MUX
 *     AMS_PLL_FRACN_BYPASS test option to bypass the integer mode of the frac-N SDM block. See AMS for details amsbus ctrl_out  147:147DFT_MUX
 *     AMS_PLL_FRACN_NDIV_INT fracn-N feedback divider integer control, See AMS for details amsbus ctrl_out  157:148DFT_MUX
 *     AMS_PLL_DITHEREN now only a test mode, enables dithering to reduce the refclk spur, and can be used during frac-N integer mode amsbus ctrl_out  158:158DFT_MUX
 *     AMS_PLL_FRACN_SEL master enable and select for the frac-N mode, disables the orignal integer mode controlled by pll_mode amsbus ctrl_out  159:159DFT_MUX
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r (0x0001d119 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_CTL9.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_ctl9[1];
	uint32_t _ams_pll_pll_ctl9;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_CLR(r) (r).ams_pll_pll_ctl9[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_SET(r,d) (r).ams_pll_pll_ctl9[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_GET(r) (r).ams_pll_pll_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 4) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x3ff << 4)) | ((((uint32_t)f) & 0x3ff) << 4)) | (1023 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET(r) ((((r).ams_pll_pll_ctl9[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET(r) (((r).ams_pll_pll_ctl9[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET(r,f) (r).ams_pll_pll_ctl9[0]=(((r).ams_pll_pll_ctl9[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_CTL9.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r,(_r._ams_pll_pll_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r,(_r._ams_pll_pll_ctl9)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r,(_r._ams_pll_pll_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_CTL9r BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r
#define AMS_PLL_PLL_CTL9r_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_t AMS_PLL_PLL_CTL9r_t;
#define AMS_PLL_PLL_CTL9r_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_CLR
#define AMS_PLL_PLL_CTL9r_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_SET
#define AMS_PLL_PLL_CTL9r_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_SELf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_DITHERENf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_NDIV_INTf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_BYPASSf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIVRANGEf_SET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_GET
#define AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r_AMS_PLL_FRACN_DIV_17_16f_SET
#define READ_AMS_PLL_PLL_CTL9r BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_CTL9r
#define WRITE_AMS_PLL_PLL_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_CTL9r
#define MODIFY_AMS_PLL_PLL_CTL9r BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_CTL9r
#define READLN_AMS_PLL_PLL_CTL9r BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_CTL9r
#define WRITELN_AMS_PLL_PLL_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_CTL9r
#define WRITEALL_AMS_PLL_PLL_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_INTCTL
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd11b
 * DEVAD:    1
 * DESC:     INTERNAL PLL CONTROL
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_RTERM_SEL when 0, sel rterm input pins, when 1 sel pll AMS ctrl
 *     AMS_PLL_DIV4_2_SEL when 0, sel div4/2 input pin, when 1 sel pll AMS ctrl
 *     AMS_PLL_PWRDN    when1, power down pll
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr (0x0001d11b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_INTCTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_intctl[1];
	uint32_t _ams_pll_pll_intctl;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_CLR(r) (r).ams_pll_pll_intctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_SET(r,d) (r).ams_pll_pll_intctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_GET(r) (r).ams_pll_pll_intctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET(r) ((((r).ams_pll_pll_intctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET(r) ((((r).ams_pll_pll_intctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET(r) (((r).ams_pll_pll_intctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET(r,f) (r).ams_pll_pll_intctl[0]=(((r).ams_pll_pll_intctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_INTCTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr,(_r._ams_pll_pll_intctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr,(_r._ams_pll_pll_intctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr,(_r._ams_pll_pll_intctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_INTCTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_intctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_INTCTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_intctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_INTCTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_intctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_INTCTLr BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr
#define AMS_PLL_PLL_INTCTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_t AMS_PLL_PLL_INTCTLr_t;
#define AMS_PLL_PLL_INTCTLr_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_CLR
#define AMS_PLL_PLL_INTCTLr_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_SET
#define AMS_PLL_PLL_INTCTLr_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_PWRDNf_SET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_DIV4_2_SELf_SET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_GET
#define AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr_AMS_PLL_RTERM_SELf_SET
#define READ_AMS_PLL_PLL_INTCTLr BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_INTCTLr
#define WRITE_AMS_PLL_PLL_INTCTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_INTCTLr
#define MODIFY_AMS_PLL_PLL_INTCTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_INTCTLr
#define READLN_AMS_PLL_PLL_INTCTLr BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_INTCTLr
#define WRITELN_AMS_PLL_PLL_INTCTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_INTCTLr
#define WRITEALL_AMS_PLL_PLL_INTCTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_INTCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_INTCTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  AMS_PLL_PLL_STS
 * BLOCKS:   AMS_PLL_COM
 * REGADDR:  0xd11c
 * DEVAD:    1
 * DESC:     AMS PLL STATUS
 * RESETVAL: 0x27 (39)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_PLL_MODE     pll_mode[4:0] bits
 *     AMS_PLL_LOW      VCO tuning output, HIGH when VCO Vctrl is low or PLL frequency is too low
 *     AMS_PLL_RANGE    VCO frequency range control (8 bits)
 *     AMS_PLL_KVH      KVH[1:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr (0x0001d11c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_PLL_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_s {
	uint32_t v[1];
	uint32_t ams_pll_pll_sts[1];
	uint32_t _ams_pll_pll_sts;
} BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_CLR(r) (r).ams_pll_pll_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_SET(r,d) (r).ams_pll_pll_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_GET(r) (r).ams_pll_pll_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 6) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET(r) ((((r).ams_pll_pll_sts[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_GET(r) (((r).ams_pll_pll_sts[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_SET(r,f) (r).ams_pll_pll_sts[0]=(((r).ams_pll_pll_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_PLL_PLL_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr,(_r._ams_pll_pll_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr,(_r._ams_pll_pll_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr,(_r._ams_pll_pll_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_pll_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_pll_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_PLL_STSr BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr
#define AMS_PLL_PLL_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_t AMS_PLL_PLL_STSr_t;
#define AMS_PLL_PLL_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_CLR
#define AMS_PLL_PLL_STSr_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_SET
#define AMS_PLL_PLL_STSr_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_KVHf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_RANGEf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_LOWf_SET
#define AMS_PLL_PLL_STSr_AMS_PLL_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_GET
#define AMS_PLL_PLL_STSr_AMS_PLL_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr_AMS_PLL_MODEf_SET
#define READ_AMS_PLL_PLL_STSr BCMI_TSCBH_FLEXE_XGXS_READ_AMS_PLL_PLL_STSr
#define WRITE_AMS_PLL_PLL_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_AMS_PLL_PLL_STSr
#define MODIFY_AMS_PLL_PLL_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_AMS_PLL_PLL_STSr
#define READLN_AMS_PLL_PLL_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_AMS_PLL_PLL_STSr
#define WRITELN_AMS_PLL_PLL_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_AMS_PLL_PLL_STSr
#define WRITEALL_AMS_PLL_PLL_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_AMS_PLL_PLL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_AMS_PLL_PLL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ0
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd120
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 0
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_0   Fixed Pattern Generator Sequence Word 0. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted last.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r (0x0001d120 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq0[1];
	uint32_t _patgen_patgen_seq0;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_CLR(r) (r).patgen_patgen_seq0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_SET(r,d) (r).patgen_patgen_seq0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_GET(r) (r).patgen_patgen_seq0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET(r) (((r).patgen_patgen_seq0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET(r,f) (r).patgen_patgen_seq0[0]=(((r).patgen_patgen_seq0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r,(_r._patgen_patgen_seq0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r,(_r._patgen_patgen_seq0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r,(_r._patgen_patgen_seq0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ0r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r
#define PATGEN_PATGEN_SEQ0r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_t PATGEN_PATGEN_SEQ0r_t;
#define PATGEN_PATGEN_SEQ0r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_CLR
#define PATGEN_PATGEN_SEQ0r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_SET
#define PATGEN_PATGEN_SEQ0r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_GET
#define PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_GET
#define PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r_PATT_GEN_SEQ_0f_SET
#define READ_PATGEN_PATGEN_SEQ0r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ0r
#define WRITE_PATGEN_PATGEN_SEQ0r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ0r
#define MODIFY_PATGEN_PATGEN_SEQ0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ0r
#define READLN_PATGEN_PATGEN_SEQ0r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ0r
#define WRITELN_PATGEN_PATGEN_SEQ0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ0r
#define WRITEALL_PATGEN_PATGEN_SEQ0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ1
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd121
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 1
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_1   Fixed Pattern Generator Sequence Word 1. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r (0x0001d121 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq1[1];
	uint32_t _patgen_patgen_seq1;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_CLR(r) (r).patgen_patgen_seq1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_SET(r,d) (r).patgen_patgen_seq1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_GET(r) (r).patgen_patgen_seq1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET(r) (((r).patgen_patgen_seq1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET(r,f) (r).patgen_patgen_seq1[0]=(((r).patgen_patgen_seq1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r,(_r._patgen_patgen_seq1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r,(_r._patgen_patgen_seq1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r,(_r._patgen_patgen_seq1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ1r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r
#define PATGEN_PATGEN_SEQ1r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_t PATGEN_PATGEN_SEQ1r_t;
#define PATGEN_PATGEN_SEQ1r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_CLR
#define PATGEN_PATGEN_SEQ1r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_SET
#define PATGEN_PATGEN_SEQ1r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_GET
#define PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_GET
#define PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r_PATT_GEN_SEQ_1f_SET
#define READ_PATGEN_PATGEN_SEQ1r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ1r
#define WRITE_PATGEN_PATGEN_SEQ1r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ1r
#define MODIFY_PATGEN_PATGEN_SEQ1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ1r
#define READLN_PATGEN_PATGEN_SEQ1r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ1r
#define WRITELN_PATGEN_PATGEN_SEQ1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ1r
#define WRITEALL_PATGEN_PATGEN_SEQ1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ2
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd122
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 2
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_2   Fixed Pattern Generator Sequence Word 2. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r (0x0001d122 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq2[1];
	uint32_t _patgen_patgen_seq2;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_CLR(r) (r).patgen_patgen_seq2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_SET(r,d) (r).patgen_patgen_seq2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_GET(r) (r).patgen_patgen_seq2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET(r) (((r).patgen_patgen_seq2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET(r,f) (r).patgen_patgen_seq2[0]=(((r).patgen_patgen_seq2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r,(_r._patgen_patgen_seq2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r,(_r._patgen_patgen_seq2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r,(_r._patgen_patgen_seq2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ2r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r
#define PATGEN_PATGEN_SEQ2r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_t PATGEN_PATGEN_SEQ2r_t;
#define PATGEN_PATGEN_SEQ2r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_CLR
#define PATGEN_PATGEN_SEQ2r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_SET
#define PATGEN_PATGEN_SEQ2r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_GET
#define PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_GET
#define PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r_PATT_GEN_SEQ_2f_SET
#define READ_PATGEN_PATGEN_SEQ2r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ2r
#define WRITE_PATGEN_PATGEN_SEQ2r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ2r
#define MODIFY_PATGEN_PATGEN_SEQ2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ2r
#define READLN_PATGEN_PATGEN_SEQ2r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ2r
#define WRITELN_PATGEN_PATGEN_SEQ2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ2r
#define WRITEALL_PATGEN_PATGEN_SEQ2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ3
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd123
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 3
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_3   Fixed Pattern Generator Sequence Word 3. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r (0x0001d123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq3[1];
	uint32_t _patgen_patgen_seq3;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_CLR(r) (r).patgen_patgen_seq3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_SET(r,d) (r).patgen_patgen_seq3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_GET(r) (r).patgen_patgen_seq3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET(r) (((r).patgen_patgen_seq3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET(r,f) (r).patgen_patgen_seq3[0]=(((r).patgen_patgen_seq3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r,(_r._patgen_patgen_seq3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r,(_r._patgen_patgen_seq3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r,(_r._patgen_patgen_seq3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ3r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r
#define PATGEN_PATGEN_SEQ3r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_t PATGEN_PATGEN_SEQ3r_t;
#define PATGEN_PATGEN_SEQ3r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_CLR
#define PATGEN_PATGEN_SEQ3r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_SET
#define PATGEN_PATGEN_SEQ3r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_GET
#define PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_GET
#define PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r_PATT_GEN_SEQ_3f_SET
#define READ_PATGEN_PATGEN_SEQ3r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ3r
#define WRITE_PATGEN_PATGEN_SEQ3r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ3r
#define MODIFY_PATGEN_PATGEN_SEQ3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ3r
#define READLN_PATGEN_PATGEN_SEQ3r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ3r
#define WRITELN_PATGEN_PATGEN_SEQ3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ3r
#define WRITEALL_PATGEN_PATGEN_SEQ3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ4
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd124
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 4
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_4   Fixed Pattern Generator Sequence Word 4. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r (0x0001d124 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq4[1];
	uint32_t _patgen_patgen_seq4;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_CLR(r) (r).patgen_patgen_seq4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_SET(r,d) (r).patgen_patgen_seq4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_GET(r) (r).patgen_patgen_seq4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET(r) (((r).patgen_patgen_seq4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET(r,f) (r).patgen_patgen_seq4[0]=(((r).patgen_patgen_seq4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r,(_r._patgen_patgen_seq4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r,(_r._patgen_patgen_seq4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r,(_r._patgen_patgen_seq4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ4r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r
#define PATGEN_PATGEN_SEQ4r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_t PATGEN_PATGEN_SEQ4r_t;
#define PATGEN_PATGEN_SEQ4r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_CLR
#define PATGEN_PATGEN_SEQ4r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_SET
#define PATGEN_PATGEN_SEQ4r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_GET
#define PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_GET
#define PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r_PATT_GEN_SEQ_4f_SET
#define READ_PATGEN_PATGEN_SEQ4r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ4r
#define WRITE_PATGEN_PATGEN_SEQ4r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ4r
#define MODIFY_PATGEN_PATGEN_SEQ4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ4r
#define READLN_PATGEN_PATGEN_SEQ4r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ4r
#define WRITELN_PATGEN_PATGEN_SEQ4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ4r
#define WRITEALL_PATGEN_PATGEN_SEQ4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ5
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd125
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 5
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_5   Fixed Pattern Generator Sequence Word 5. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r (0x0001d125 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq5[1];
	uint32_t _patgen_patgen_seq5;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_CLR(r) (r).patgen_patgen_seq5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_SET(r,d) (r).patgen_patgen_seq5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_GET(r) (r).patgen_patgen_seq5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET(r) (((r).patgen_patgen_seq5[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET(r,f) (r).patgen_patgen_seq5[0]=(((r).patgen_patgen_seq5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r,(_r._patgen_patgen_seq5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r,(_r._patgen_patgen_seq5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r,(_r._patgen_patgen_seq5))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ5r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r
#define PATGEN_PATGEN_SEQ5r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_t PATGEN_PATGEN_SEQ5r_t;
#define PATGEN_PATGEN_SEQ5r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_CLR
#define PATGEN_PATGEN_SEQ5r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_SET
#define PATGEN_PATGEN_SEQ5r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_GET
#define PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_GET
#define PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r_PATT_GEN_SEQ_5f_SET
#define READ_PATGEN_PATGEN_SEQ5r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ5r
#define WRITE_PATGEN_PATGEN_SEQ5r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ5r
#define MODIFY_PATGEN_PATGEN_SEQ5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ5r
#define READLN_PATGEN_PATGEN_SEQ5r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ5r
#define WRITELN_PATGEN_PATGEN_SEQ5r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ5r
#define WRITEALL_PATGEN_PATGEN_SEQ5r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ6
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd126
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 6
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_6   Fixed Pattern Generator Sequence Word 6. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r (0x0001d126 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ6.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq6[1];
	uint32_t _patgen_patgen_seq6;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_CLR(r) (r).patgen_patgen_seq6[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_SET(r,d) (r).patgen_patgen_seq6[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_GET(r) (r).patgen_patgen_seq6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET(r) (((r).patgen_patgen_seq6[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET(r,f) (r).patgen_patgen_seq6[0]=(((r).patgen_patgen_seq6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ6.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r,(_r._patgen_patgen_seq6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r,(_r._patgen_patgen_seq6)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r,(_r._patgen_patgen_seq6))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ6r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r
#define PATGEN_PATGEN_SEQ6r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_t PATGEN_PATGEN_SEQ6r_t;
#define PATGEN_PATGEN_SEQ6r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_CLR
#define PATGEN_PATGEN_SEQ6r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_SET
#define PATGEN_PATGEN_SEQ6r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_GET
#define PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_GET
#define PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r_PATT_GEN_SEQ_6f_SET
#define READ_PATGEN_PATGEN_SEQ6r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ6r
#define WRITE_PATGEN_PATGEN_SEQ6r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ6r
#define MODIFY_PATGEN_PATGEN_SEQ6r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ6r
#define READLN_PATGEN_PATGEN_SEQ6r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ6r
#define WRITELN_PATGEN_PATGEN_SEQ6r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ6r
#define WRITEALL_PATGEN_PATGEN_SEQ6r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ7
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd127
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 7
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_7   Fixed Pattern Generator Sequence Word 7. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r (0x0001d127 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq7[1];
	uint32_t _patgen_patgen_seq7;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_CLR(r) (r).patgen_patgen_seq7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_SET(r,d) (r).patgen_patgen_seq7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_GET(r) (r).patgen_patgen_seq7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET(r) (((r).patgen_patgen_seq7[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET(r,f) (r).patgen_patgen_seq7[0]=(((r).patgen_patgen_seq7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r,(_r._patgen_patgen_seq7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r,(_r._patgen_patgen_seq7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r,(_r._patgen_patgen_seq7))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ7r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r
#define PATGEN_PATGEN_SEQ7r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_t PATGEN_PATGEN_SEQ7r_t;
#define PATGEN_PATGEN_SEQ7r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_CLR
#define PATGEN_PATGEN_SEQ7r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_SET
#define PATGEN_PATGEN_SEQ7r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_GET
#define PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_GET
#define PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r_PATT_GEN_SEQ_7f_SET
#define READ_PATGEN_PATGEN_SEQ7r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ7r
#define WRITE_PATGEN_PATGEN_SEQ7r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ7r
#define MODIFY_PATGEN_PATGEN_SEQ7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ7r
#define READLN_PATGEN_PATGEN_SEQ7r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ7r
#define WRITELN_PATGEN_PATGEN_SEQ7r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ7r
#define WRITEALL_PATGEN_PATGEN_SEQ7r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ8
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd128
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 8
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_8   Fixed Pattern Generator Sequence Word 8. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r (0x0001d128 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ8.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq8[1];
	uint32_t _patgen_patgen_seq8;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_CLR(r) (r).patgen_patgen_seq8[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_SET(r,d) (r).patgen_patgen_seq8[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_GET(r) (r).patgen_patgen_seq8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET(r) (((r).patgen_patgen_seq8[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET(r,f) (r).patgen_patgen_seq8[0]=(((r).patgen_patgen_seq8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ8.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r,(_r._patgen_patgen_seq8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r,(_r._patgen_patgen_seq8)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r,(_r._patgen_patgen_seq8))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ8r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r
#define PATGEN_PATGEN_SEQ8r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_t PATGEN_PATGEN_SEQ8r_t;
#define PATGEN_PATGEN_SEQ8r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_CLR
#define PATGEN_PATGEN_SEQ8r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_SET
#define PATGEN_PATGEN_SEQ8r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_GET
#define PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_GET
#define PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r_PATT_GEN_SEQ_8f_SET
#define READ_PATGEN_PATGEN_SEQ8r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ8r
#define WRITE_PATGEN_PATGEN_SEQ8r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ8r
#define MODIFY_PATGEN_PATGEN_SEQ8r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ8r
#define READLN_PATGEN_PATGEN_SEQ8r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ8r
#define WRITELN_PATGEN_PATGEN_SEQ8r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ8r
#define WRITEALL_PATGEN_PATGEN_SEQ8r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ9
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd129
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 9
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_9   Fixed Pattern Generator Sequence Word 9. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r (0x0001d129 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ9.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq9[1];
	uint32_t _patgen_patgen_seq9;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_CLR(r) (r).patgen_patgen_seq9[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_SET(r,d) (r).patgen_patgen_seq9[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_GET(r) (r).patgen_patgen_seq9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET(r) (((r).patgen_patgen_seq9[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET(r,f) (r).patgen_patgen_seq9[0]=(((r).patgen_patgen_seq9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ9.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r,(_r._patgen_patgen_seq9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r,(_r._patgen_patgen_seq9)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r,(_r._patgen_patgen_seq9))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ9r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r
#define PATGEN_PATGEN_SEQ9r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_t PATGEN_PATGEN_SEQ9r_t;
#define PATGEN_PATGEN_SEQ9r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_CLR
#define PATGEN_PATGEN_SEQ9r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_SET
#define PATGEN_PATGEN_SEQ9r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_GET
#define PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_GET
#define PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r_PATT_GEN_SEQ_9f_SET
#define READ_PATGEN_PATGEN_SEQ9r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ9r
#define WRITE_PATGEN_PATGEN_SEQ9r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ9r
#define MODIFY_PATGEN_PATGEN_SEQ9r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ9r
#define READLN_PATGEN_PATGEN_SEQ9r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ9r
#define WRITELN_PATGEN_PATGEN_SEQ9r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ9r
#define WRITEALL_PATGEN_PATGEN_SEQ9r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_10
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12a
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 10
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_10  Fixed Pattern Generator Sequence Word 10. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r (0x0001d12a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_10.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_10[1];
	uint32_t _patgen_patgen_seq_10;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_CLR(r) (r).patgen_patgen_seq_10[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_SET(r,d) (r).patgen_patgen_seq_10[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_GET(r) (r).patgen_patgen_seq_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET(r) (((r).patgen_patgen_seq_10[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET(r,f) (r).patgen_patgen_seq_10[0]=(((r).patgen_patgen_seq_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_10.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r,(_r._patgen_patgen_seq_10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r,(_r._patgen_patgen_seq_10)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r,(_r._patgen_patgen_seq_10))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_10r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r
#define PATGEN_PATGEN_SEQ_10r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_t PATGEN_PATGEN_SEQ_10r_t;
#define PATGEN_PATGEN_SEQ_10r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_CLR
#define PATGEN_PATGEN_SEQ_10r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_SET
#define PATGEN_PATGEN_SEQ_10r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_GET
#define PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_GET
#define PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r_PATT_GEN_SEQ_10f_SET
#define READ_PATGEN_PATGEN_SEQ_10r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_10r
#define WRITE_PATGEN_PATGEN_SEQ_10r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_10r
#define MODIFY_PATGEN_PATGEN_SEQ_10r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_10r
#define READLN_PATGEN_PATGEN_SEQ_10r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_10r
#define WRITELN_PATGEN_PATGEN_SEQ_10r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_10r
#define WRITEALL_PATGEN_PATGEN_SEQ_10r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_11
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12b
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 11
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_11  Fixed Pattern Generator Sequence Word 11. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r (0x0001d12b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_11.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_11[1];
	uint32_t _patgen_patgen_seq_11;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_CLR(r) (r).patgen_patgen_seq_11[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_SET(r,d) (r).patgen_patgen_seq_11[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_GET(r) (r).patgen_patgen_seq_11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET(r) (((r).patgen_patgen_seq_11[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET(r,f) (r).patgen_patgen_seq_11[0]=(((r).patgen_patgen_seq_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_11.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r,(_r._patgen_patgen_seq_11))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r,(_r._patgen_patgen_seq_11)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r,(_r._patgen_patgen_seq_11))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_11r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_11))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_11r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_11))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_11r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r
#define PATGEN_PATGEN_SEQ_11r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_t PATGEN_PATGEN_SEQ_11r_t;
#define PATGEN_PATGEN_SEQ_11r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_CLR
#define PATGEN_PATGEN_SEQ_11r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_SET
#define PATGEN_PATGEN_SEQ_11r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_GET
#define PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_GET
#define PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r_PATT_GEN_SEQ_11f_SET
#define READ_PATGEN_PATGEN_SEQ_11r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_11r
#define WRITE_PATGEN_PATGEN_SEQ_11r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_11r
#define MODIFY_PATGEN_PATGEN_SEQ_11r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_11r
#define READLN_PATGEN_PATGEN_SEQ_11r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_11r
#define WRITELN_PATGEN_PATGEN_SEQ_11r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_11r
#define WRITEALL_PATGEN_PATGEN_SEQ_11r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_12
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12c
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 12
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_12  Fixed Pattern Generator Sequence Word 12. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r (0x0001d12c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_12.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_12[1];
	uint32_t _patgen_patgen_seq_12;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_CLR(r) (r).patgen_patgen_seq_12[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_SET(r,d) (r).patgen_patgen_seq_12[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_GET(r) (r).patgen_patgen_seq_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET(r) (((r).patgen_patgen_seq_12[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET(r,f) (r).patgen_patgen_seq_12[0]=(((r).patgen_patgen_seq_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_12.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r,(_r._patgen_patgen_seq_12))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r,(_r._patgen_patgen_seq_12)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r,(_r._patgen_patgen_seq_12))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_12r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_12))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_12r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_12))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_12r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_12r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r
#define PATGEN_PATGEN_SEQ_12r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_t PATGEN_PATGEN_SEQ_12r_t;
#define PATGEN_PATGEN_SEQ_12r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_CLR
#define PATGEN_PATGEN_SEQ_12r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_SET
#define PATGEN_PATGEN_SEQ_12r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_GET
#define PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_GET
#define PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r_PATT_GEN_SEQ_12f_SET
#define READ_PATGEN_PATGEN_SEQ_12r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_12r
#define WRITE_PATGEN_PATGEN_SEQ_12r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_12r
#define MODIFY_PATGEN_PATGEN_SEQ_12r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_12r
#define READLN_PATGEN_PATGEN_SEQ_12r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_12r
#define WRITELN_PATGEN_PATGEN_SEQ_12r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_12r
#define WRITEALL_PATGEN_PATGEN_SEQ_12r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_12r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_13
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12d
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 13
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_13  Fixed Pattern Generator Sequence Word 13. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r (0x0001d12d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_13.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_13[1];
	uint32_t _patgen_patgen_seq_13;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_CLR(r) (r).patgen_patgen_seq_13[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_SET(r,d) (r).patgen_patgen_seq_13[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_GET(r) (r).patgen_patgen_seq_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET(r) (((r).patgen_patgen_seq_13[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET(r,f) (r).patgen_patgen_seq_13[0]=(((r).patgen_patgen_seq_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_13.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r,(_r._patgen_patgen_seq_13))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r,(_r._patgen_patgen_seq_13)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r,(_r._patgen_patgen_seq_13))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_13r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_13))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_13r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_13))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_13r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_13r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r
#define PATGEN_PATGEN_SEQ_13r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_t PATGEN_PATGEN_SEQ_13r_t;
#define PATGEN_PATGEN_SEQ_13r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_CLR
#define PATGEN_PATGEN_SEQ_13r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_SET
#define PATGEN_PATGEN_SEQ_13r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_GET
#define PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_GET
#define PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r_PATT_GEN_SEQ_13f_SET
#define READ_PATGEN_PATGEN_SEQ_13r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_13r
#define WRITE_PATGEN_PATGEN_SEQ_13r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_13r
#define MODIFY_PATGEN_PATGEN_SEQ_13r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_13r
#define READLN_PATGEN_PATGEN_SEQ_13r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_13r
#define WRITELN_PATGEN_PATGEN_SEQ_13r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_13r
#define WRITEALL_PATGEN_PATGEN_SEQ_13r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_13r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PATGEN_PATGEN_SEQ_14
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12e
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 14
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_14  Fixed Pattern Generator Sequence Word 14. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted first.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r (0x0001d12e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_SIZE 4

/*
 * This structure should be used to declare and program PATGEN_PATGEN_SEQ_14.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_s {
	uint32_t v[1];
	uint32_t patgen_patgen_seq_14[1];
	uint32_t _patgen_patgen_seq_14;
} BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_CLR(r) (r).patgen_patgen_seq_14[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_SET(r,d) (r).patgen_patgen_seq_14[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_GET(r) (r).patgen_patgen_seq_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET(r) (((r).patgen_patgen_seq_14[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET(r,f) (r).patgen_patgen_seq_14[0]=(((r).patgen_patgen_seq_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATGEN_PATGEN_SEQ_14.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r,(_r._patgen_patgen_seq_14))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r,(_r._patgen_patgen_seq_14)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r,(_r._patgen_patgen_seq_14))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_14r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_14))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_14r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patgen_patgen_seq_14))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_14r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patgen_patgen_seq_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATGEN_PATGEN_SEQ_14r BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r
#define PATGEN_PATGEN_SEQ_14r_SIZE BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_t PATGEN_PATGEN_SEQ_14r_t;
#define PATGEN_PATGEN_SEQ_14r_CLR BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_CLR
#define PATGEN_PATGEN_SEQ_14r_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_SET
#define PATGEN_PATGEN_SEQ_14r_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_GET
#define PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_GET
#define PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r_PATT_GEN_SEQ_14f_SET
#define READ_PATGEN_PATGEN_SEQ_14r BCMI_TSCBH_FLEXE_XGXS_READ_PATGEN_PATGEN_SEQ_14r
#define WRITE_PATGEN_PATGEN_SEQ_14r BCMI_TSCBH_FLEXE_XGXS_WRITE_PATGEN_PATGEN_SEQ_14r
#define MODIFY_PATGEN_PATGEN_SEQ_14r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PATGEN_PATGEN_SEQ_14r
#define READLN_PATGEN_PATGEN_SEQ_14r BCMI_TSCBH_FLEXE_XGXS_READLN_PATGEN_PATGEN_SEQ_14r
#define WRITELN_PATGEN_PATGEN_SEQ_14r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PATGEN_PATGEN_SEQ_14r
#define WRITEALL_PATGEN_PATGEN_SEQ_14r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PATGEN_PATGEN_SEQ_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PATGEN_PATGEN_SEQ_14r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_UC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd130
 * DEVAD:    1
 * DESC:     Micro Control 0 Register
 * RESETVAL: 0xc160 (49504)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_TX_DISABLE micro tx disableThis field is used by the Microcontroller for tx disable control during CL93N72 forced modePlease see Falcon PMD Internal Functional Specification for details
 *     TX_DISABLE_TRIGGER Tx disable triggerWhen this bit is set to 1, it triggers a TX disable with timer starting at 0.No matter where the TX disable state is, it start a new timer and apply TX disable.This bit is self clearing
 *     DP_RESET_TX_DISABLE_DIS Tx disable based on data path reset0 - Enable tx disable based on data path reset1 - Disable tx disable based on data path resetNeed to set this bit to 1 if tx_disable_output_sel = 2'b01 (send TX power down).
 *     PMD_TX_DISABLE_PKILL Tx disable using the pmd_tx_disable pin disable control0 - enable tx disable from pmd_tx_disable pin1 - disable tx disable from pmd_tx_disable pin
 *     TX_DISABLE_TIMER_CTRL tx_disable timer value controlstx_disable_timer_ctrl[5] (MSB) selects the timer units0 - 2us units1 - 1ms unitstx_disable_timer_ctrl[4:0] (LSB[4:0]) = controls the number of units perthe list below0                 0 units1                 1 units2                 2 units3                 3 units4                 4 units5                 5 units6                 6 units7                 7 units8                 8 units9                10 units10               12 units11               14 units12               16 units13               20 units14               24 units15               28 units16               32 units17               40 units18               48 units19               56 units20               64 units21               80 units22               96 units23              112 units24              128 units25              160 units26              192 units27              224 units28              256 units29              320 units30              384 units31              448 units
 *     TX_EEE_QUIET_EN  Tx eee quiet mode control1 - Enable eee quiet mode when pmd_tx_mode (input pins) == 2'b010 - Disable eee quiet mode
 *     TX_EEE_ALERT_EN  Tx eee alert mode control1 - Enable eee alert mode when pmd_tx_mode (input pins) == 2'b100 - Disable eee alert mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r (0x0001d130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_UC_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_uc_ctl0[1];
	uint32_t _txfir_uc_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_CLR(r) (r).txfir_uc_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_SET(r,d) (r).txfir_uc_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_GET(r) (r).txfir_uc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 4) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x3f << 4)) | ((((uint32_t)f) & 0x3f) << 4)) | (63 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET(r) ((((r).txfir_uc_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET(r) (((r).txfir_uc_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_UC_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_UC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_UC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_UC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_uc_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_UC_CTL0r BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r
#define TXFIR_UC_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_t TXFIR_UC_CTL0r_t;
#define TXFIR_UC_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_CLR
#define TXFIR_UC_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_SET
#define TXFIR_UC_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_GET
#define TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_GET
#define TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_ALERT_ENf_SET
#define TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_GET
#define TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_EEE_QUIET_ENf_SET
#define TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_GET
#define TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TIMER_CTRLf_SET
#define TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_GET
#define TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_PMD_TX_DISABLE_PKILLf_SET
#define TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_GET
#define TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_DP_RESET_TX_DISABLE_DISf_SET
#define TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_GET
#define TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_TX_DISABLE_TRIGGERf_SET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET
#define READ_TXFIR_UC_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_UC_CTL0r
#define WRITE_TXFIR_UC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_UC_CTL0r
#define MODIFY_TXFIR_UC_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_UC_CTL0r
#define READLN_TXFIR_UC_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_UC_CTL0r
#define WRITELN_TXFIR_UC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_UC_CTL0r
#define WRITEALL_TXFIR_UC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_UC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_UC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_MISC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd131
 * DEVAD:    1
 * DESC:     Misc Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SDK_TX_DISABLE   sdk tx disableThis tx disable control field is for SDK use during TX programmingPlease see Eagle & Merlin PMD Internal Functional Specification for details
 *     TX_DISABLE_OUTPUT_SEL These bits select tx disable output function2'b00 - send electrical idles2'b01 - send power down2'b10 - send ones2'b11 - send zeroes
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r (0x0001d131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_misc_ctl0[1];
	uint32_t _txfir_misc_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_CLR(r) (r).txfir_misc_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SET(r,d) (r).txfir_misc_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_GET(r) (r).txfir_misc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET(r) ((((r).txfir_misc_ctl0[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET(r,f) (r).txfir_misc_ctl0[0]=(((r).txfir_misc_ctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET(r) (((r).txfir_misc_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET(r,f) (r).txfir_misc_ctl0[0]=(((r).txfir_misc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r,(_r._txfir_misc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r,(_r._txfir_misc_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r,(_r._txfir_misc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_MISC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_MISC_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_MISC_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_misc_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_CTL0r BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r
#define TXFIR_MISC_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_t TXFIR_MISC_CTL0r_t;
#define TXFIR_MISC_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_CLR
#define TXFIR_MISC_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SET
#define TXFIR_MISC_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_GET
#define TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_GET
#define TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_TX_DISABLE_OUTPUT_SELf_SET
#define TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_GET
#define TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r_SDK_TX_DISABLEf_SET
#define READ_TXFIR_MISC_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_MISC_CTL0r
#define WRITE_TXFIR_MISC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_MISC_CTL0r
#define MODIFY_TXFIR_MISC_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_MISC_CTL0r
#define READLN_TXFIR_MISC_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_MISC_CTL0r
#define WRITELN_TXFIR_MISC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_MISC_CTL0r
#define WRITEALL_TXFIR_MISC_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_MISC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_MISC_STS0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd132
 * DEVAD:    1
 * DESC:     Misc Status 0 Register
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_DISABLE_STATUS tx disable statusWhen this bit is set it indicates the tx_disable is active due to:1) pin at AN/PCS to PMD Interface OR2) dp_reset being asserted3) register bit dedicated to micro use4) register bit dedicated to SDK use5) tx disable timer that guarntees minimum assertion time has not expired
 *     TX_ELEC_IDLE_STATUS tx electrical idle statusWhen this bit is set it indicates the tx elecrticl idle active due to:1) tx disable being programmed to send electrical idles or2) An internal logic signal derived from PMD interface pins for EEE TX MODE
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r (0x0001d132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_s {
	uint32_t v[1];
	uint32_t txfir_misc_sts0[1];
	uint32_t _txfir_misc_sts0;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_CLR(r) (r).txfir_misc_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_SET(r,d) (r).txfir_misc_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_GET(r) (r).txfir_misc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET(r) ((((r).txfir_misc_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET(r,f) (r).txfir_misc_sts0[0]=(((r).txfir_misc_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET(r) (((r).txfir_misc_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET(r,f) (r).txfir_misc_sts0[0]=(((r).txfir_misc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r,(_r._txfir_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r,(_r._txfir_misc_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r,(_r._txfir_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_misc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r
#define TXFIR_MISC_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_t TXFIR_MISC_STS0r_t;
#define TXFIR_MISC_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_CLR
#define TXFIR_MISC_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_SET
#define TXFIR_MISC_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_GET
#define TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_GET
#define TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_ELEC_IDLE_STATUSf_SET
#define TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_GET
#define TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r_TX_DISABLE_STATUSf_SET
#define READ_TXFIR_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_MISC_STS0r
#define WRITE_TXFIR_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_MISC_STS0r
#define MODIFY_TXFIR_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_MISC_STS0r
#define READLN_TXFIR_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_MISC_STS0r
#define WRITELN_TXFIR_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_MISC_STS0r
#define WRITEALL_TXFIR_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_MISC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_MISC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd133
 * DEVAD:    1
 * DESC:     txfir tap control 0 register
 * RESETVAL: 0x3000 (12288)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP0_COEFF TXFIR tap 0 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 *     TXFIR_NRZ_TAP_RANGE_SEL TXFIR NRZ tap range select0 - PAM4 tap range -170..+1701 - NRZ tap range -127..+127
 *     TXFIR_TAP_LOAD   Load txfir tap valuesThe sequence to load the taps is:1) set taps values in the txfir_tap*_coeff fields as needed2) set txfir_tap_load field to 1'b1.This field is self-clearing, always read-back 0
 *     TXFIR_TAP_EN     txfir taps enable2'd0 - tap2:tap02'd1 - tap5:tap02'd2 - tap8:tap02'd3 - tap11:tap0
 *     TXFIR_TEST_DATA_EN txfir DAC test data enable1 - Test mode. Enables test data path from the DAC memory to the DAC for characterization0 - Normal modes. TXFIR DAC driver is used to drive the DAC.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r (0x0001d133 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl0[1];
	uint32_t _txfir_tap_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_CLR(r) (r).txfir_tap_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_SET(r,d) (r).txfir_tap_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_GET(r) (r).txfir_tap_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_GET(r) ((((r).txfir_tap_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_GET(r) (((r).txfir_tap_ctl0[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_SET(r,f) (r).txfir_tap_ctl0[0]=(((r).txfir_tap_ctl0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r,(_r._txfir_tap_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL0r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r
#define TXFIR_TAP_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_t TXFIR_TAP_CTL0r_t;
#define TXFIR_TAP_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_CLR
#define TXFIR_TAP_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_SET
#define TXFIR_TAP_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_GET
#define TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TEST_DATA_ENf_SET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_ENf_SET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP_LOADf_SET
#define TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_GET
#define TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_NRZ_TAP_RANGE_SELf_SET
#define TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_GET
#define TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r_TXFIR_TAP0_COEFFf_SET
#define READ_TXFIR_TAP_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL0r
#define WRITE_TXFIR_TAP_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL0r
#define MODIFY_TXFIR_TAP_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL0r
#define READLN_TXFIR_TAP_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL0r
#define WRITELN_TXFIR_TAP_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL0r
#define WRITEALL_TXFIR_TAP_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd134
 * DEVAD:    1
 * DESC:     txfir tap control 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP1_COEFF TXFIR tap 1 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r (0x0001d134 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl1[1];
	uint32_t _txfir_tap_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_CLR(r) (r).txfir_tap_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_SET(r,d) (r).txfir_tap_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_GET(r) (r).txfir_tap_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_GET(r) (((r).txfir_tap_ctl1[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_SET(r,f) (r).txfir_tap_ctl1[0]=(((r).txfir_tap_ctl1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r,(_r._txfir_tap_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r,(_r._txfir_tap_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r,(_r._txfir_tap_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL1r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r
#define TXFIR_TAP_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_t TXFIR_TAP_CTL1r_t;
#define TXFIR_TAP_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_CLR
#define TXFIR_TAP_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_SET
#define TXFIR_TAP_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_GET
#define TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_GET
#define TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r_TXFIR_TAP1_COEFFf_SET
#define READ_TXFIR_TAP_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL1r
#define WRITE_TXFIR_TAP_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL1r
#define MODIFY_TXFIR_TAP_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL1r
#define READLN_TXFIR_TAP_CTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL1r
#define WRITELN_TXFIR_TAP_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL1r
#define WRITEALL_TXFIR_TAP_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd135
 * DEVAD:    1
 * DESC:     txfir tap control 2 register
 * RESETVAL: 0xa8 (168)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP2_COEFF TXFIR tap 2 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r (0x0001d135 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl2[1];
	uint32_t _txfir_tap_ctl2;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_CLR(r) (r).txfir_tap_ctl2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_SET(r,d) (r).txfir_tap_ctl2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_GET(r) (r).txfir_tap_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_GET(r) (((r).txfir_tap_ctl2[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_SET(r,f) (r).txfir_tap_ctl2[0]=(((r).txfir_tap_ctl2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r,(_r._txfir_tap_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r,(_r._txfir_tap_ctl2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r,(_r._txfir_tap_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL2r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r
#define TXFIR_TAP_CTL2r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_t TXFIR_TAP_CTL2r_t;
#define TXFIR_TAP_CTL2r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_CLR
#define TXFIR_TAP_CTL2r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_SET
#define TXFIR_TAP_CTL2r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_GET
#define TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_GET
#define TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r_TXFIR_TAP2_COEFFf_SET
#define READ_TXFIR_TAP_CTL2r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL2r
#define WRITE_TXFIR_TAP_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL2r
#define MODIFY_TXFIR_TAP_CTL2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL2r
#define READLN_TXFIR_TAP_CTL2r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL2r
#define WRITELN_TXFIR_TAP_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL2r
#define WRITEALL_TXFIR_TAP_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL3
 * BLOCKS:   TX_FED
 * REGADDR:  0xd136
 * DEVAD:    1
 * DESC:     txfir tap control 3 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP3_COEFF TXFIR tap 3 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r (0x0001d136 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl3[1];
	uint32_t _txfir_tap_ctl3;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_CLR(r) (r).txfir_tap_ctl3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_SET(r,d) (r).txfir_tap_ctl3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_GET(r) (r).txfir_tap_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_GET(r) (((r).txfir_tap_ctl3[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_SET(r,f) (r).txfir_tap_ctl3[0]=(((r).txfir_tap_ctl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r,(_r._txfir_tap_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r,(_r._txfir_tap_ctl3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r,(_r._txfir_tap_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL3r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r
#define TXFIR_TAP_CTL3r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_t TXFIR_TAP_CTL3r_t;
#define TXFIR_TAP_CTL3r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_CLR
#define TXFIR_TAP_CTL3r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_SET
#define TXFIR_TAP_CTL3r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_GET
#define TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_GET
#define TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r_TXFIR_TAP3_COEFFf_SET
#define READ_TXFIR_TAP_CTL3r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL3r
#define WRITE_TXFIR_TAP_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL3r
#define MODIFY_TXFIR_TAP_CTL3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL3r
#define READLN_TXFIR_TAP_CTL3r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL3r
#define WRITELN_TXFIR_TAP_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL3r
#define WRITEALL_TXFIR_TAP_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL4
 * BLOCKS:   TX_FED
 * REGADDR:  0xd137
 * DEVAD:    1
 * DESC:     txfir tap control 4 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP4_COEFF TXFIR tap 4 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r (0x0001d137 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl4[1];
	uint32_t _txfir_tap_ctl4;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_CLR(r) (r).txfir_tap_ctl4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_SET(r,d) (r).txfir_tap_ctl4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_GET(r) (r).txfir_tap_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_GET(r) (((r).txfir_tap_ctl4[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_SET(r,f) (r).txfir_tap_ctl4[0]=(((r).txfir_tap_ctl4[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r,(_r._txfir_tap_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r,(_r._txfir_tap_ctl4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r,(_r._txfir_tap_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL4r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r
#define TXFIR_TAP_CTL4r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_t TXFIR_TAP_CTL4r_t;
#define TXFIR_TAP_CTL4r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_CLR
#define TXFIR_TAP_CTL4r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_SET
#define TXFIR_TAP_CTL4r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_GET
#define TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_GET
#define TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r_TXFIR_TAP4_COEFFf_SET
#define READ_TXFIR_TAP_CTL4r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL4r
#define WRITE_TXFIR_TAP_CTL4r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL4r
#define MODIFY_TXFIR_TAP_CTL4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL4r
#define READLN_TXFIR_TAP_CTL4r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL4r
#define WRITELN_TXFIR_TAP_CTL4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL4r
#define WRITEALL_TXFIR_TAP_CTL4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL5
 * BLOCKS:   TX_FED
 * REGADDR:  0xd138
 * DEVAD:    1
 * DESC:     txfir tap control 5 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP5_COEFF TXFIR tap 5 coeffient values in signed 2's complement formattap range: -170 to +170 in PAM4 mode-127 to +127 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r (0x0001d138 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl5[1];
	uint32_t _txfir_tap_ctl5;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_CLR(r) (r).txfir_tap_ctl5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_SET(r,d) (r).txfir_tap_ctl5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_GET(r) (r).txfir_tap_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_GET(r) (((r).txfir_tap_ctl5[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_SET(r,f) (r).txfir_tap_ctl5[0]=(((r).txfir_tap_ctl5[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r,(_r._txfir_tap_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r,(_r._txfir_tap_ctl5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r,(_r._txfir_tap_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL5r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r
#define TXFIR_TAP_CTL5r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_t TXFIR_TAP_CTL5r_t;
#define TXFIR_TAP_CTL5r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_CLR
#define TXFIR_TAP_CTL5r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_SET
#define TXFIR_TAP_CTL5r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_GET
#define TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_GET
#define TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r_TXFIR_TAP5_COEFFf_SET
#define READ_TXFIR_TAP_CTL5r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL5r
#define WRITE_TXFIR_TAP_CTL5r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL5r
#define MODIFY_TXFIR_TAP_CTL5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL5r
#define READLN_TXFIR_TAP_CTL5r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL5r
#define WRITELN_TXFIR_TAP_CTL5r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL5r
#define WRITEALL_TXFIR_TAP_CTL5r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL6
 * BLOCKS:   TX_FED
 * REGADDR:  0xd139
 * DEVAD:    1
 * DESC:     txfir tap control 6 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP6_COEFF TXFIR tap 6 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 *     TXFIR_DC_ADJUST  This field specify the amount of DC offset added to TXFIR outputThe range is -64 to +63
 *     TXFIR_LEVEL_SHIFT_MODE_EN Level shifting enable. Level shifting is achieved by re-purposingthe last 6 taps such that taps 6-8 provide level adjustment forlevel = 3 and Taps 9-11 for level = -31 - enabled0 - disabled
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r (0x0001d139 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL6.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl6[1];
	uint32_t _txfir_tap_ctl6;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_CLR(r) (r).txfir_tap_ctl6[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_SET(r,d) (r).txfir_tap_ctl6[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_GET(r) (r).txfir_tap_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_GET(r) ((((r).txfir_tap_ctl6[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_SET(r,f) (r).txfir_tap_ctl6[0]=(((r).txfir_tap_ctl6[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_GET(r) ((((r).txfir_tap_ctl6[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_SET(r,f) (r).txfir_tap_ctl6[0]=(((r).txfir_tap_ctl6[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_GET(r) (((r).txfir_tap_ctl6[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_SET(r,f) (r).txfir_tap_ctl6[0]=(((r).txfir_tap_ctl6[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL6.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r,(_r._txfir_tap_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r,(_r._txfir_tap_ctl6)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r,(_r._txfir_tap_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL6r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r
#define TXFIR_TAP_CTL6r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_t TXFIR_TAP_CTL6r_t;
#define TXFIR_TAP_CTL6r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_CLR
#define TXFIR_TAP_CTL6r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_SET
#define TXFIR_TAP_CTL6r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_GET
#define TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_GET
#define TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_LEVEL_SHIFT_MODE_ENf_SET
#define TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_GET
#define TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_DC_ADJUSTf_SET
#define TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_GET
#define TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r_TXFIR_TAP6_COEFFf_SET
#define READ_TXFIR_TAP_CTL6r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL6r
#define WRITE_TXFIR_TAP_CTL6r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL6r
#define MODIFY_TXFIR_TAP_CTL6r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL6r
#define READLN_TXFIR_TAP_CTL6r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL6r
#define WRITELN_TXFIR_TAP_CTL6r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL6r
#define WRITEALL_TXFIR_TAP_CTL6r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL7
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13a
 * DEVAD:    1
 * DESC:     txfir tap control 7 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP7_COEFF TXFIR tap 7 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r (0x0001d13a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl7[1];
	uint32_t _txfir_tap_ctl7;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_CLR(r) (r).txfir_tap_ctl7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_SET(r,d) (r).txfir_tap_ctl7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_GET(r) (r).txfir_tap_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_GET(r) (((r).txfir_tap_ctl7[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_SET(r,f) (r).txfir_tap_ctl7[0]=(((r).txfir_tap_ctl7[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r,(_r._txfir_tap_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r,(_r._txfir_tap_ctl7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r,(_r._txfir_tap_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL7r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r
#define TXFIR_TAP_CTL7r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_t TXFIR_TAP_CTL7r_t;
#define TXFIR_TAP_CTL7r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_CLR
#define TXFIR_TAP_CTL7r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_SET
#define TXFIR_TAP_CTL7r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_GET
#define TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_GET
#define TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r_TXFIR_TAP7_COEFFf_SET
#define READ_TXFIR_TAP_CTL7r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL7r
#define WRITE_TXFIR_TAP_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL7r
#define MODIFY_TXFIR_TAP_CTL7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL7r
#define READLN_TXFIR_TAP_CTL7r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL7r
#define WRITELN_TXFIR_TAP_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL7r
#define WRITEALL_TXFIR_TAP_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL8
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13b
 * DEVAD:    1
 * DESC:     txfir tap control 8 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP8_COEFF TXFIR tap 8 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r (0x0001d13b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL8.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl8[1];
	uint32_t _txfir_tap_ctl8;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_CLR(r) (r).txfir_tap_ctl8[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_SET(r,d) (r).txfir_tap_ctl8[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_GET(r) (r).txfir_tap_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_GET(r) (((r).txfir_tap_ctl8[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_SET(r,f) (r).txfir_tap_ctl8[0]=(((r).txfir_tap_ctl8[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL8.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r,(_r._txfir_tap_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r,(_r._txfir_tap_ctl8)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r,(_r._txfir_tap_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL8r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl8))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL8r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL8r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r
#define TXFIR_TAP_CTL8r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_t TXFIR_TAP_CTL8r_t;
#define TXFIR_TAP_CTL8r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_CLR
#define TXFIR_TAP_CTL8r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_SET
#define TXFIR_TAP_CTL8r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_GET
#define TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_GET
#define TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r_TXFIR_TAP8_COEFFf_SET
#define READ_TXFIR_TAP_CTL8r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL8r
#define WRITE_TXFIR_TAP_CTL8r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL8r
#define MODIFY_TXFIR_TAP_CTL8r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL8r
#define READLN_TXFIR_TAP_CTL8r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL8r
#define WRITELN_TXFIR_TAP_CTL8r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL8r
#define WRITEALL_TXFIR_TAP_CTL8r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL9
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13c
 * DEVAD:    1
 * DESC:     txfir tap control 9 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP9_COEFF TXFIR tap 9 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r (0x0001d13c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL9.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl9[1];
	uint32_t _txfir_tap_ctl9;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_CLR(r) (r).txfir_tap_ctl9[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_SET(r,d) (r).txfir_tap_ctl9[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_GET(r) (r).txfir_tap_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_GET(r) (((r).txfir_tap_ctl9[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_SET(r,f) (r).txfir_tap_ctl9[0]=(((r).txfir_tap_ctl9[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL9.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r,(_r._txfir_tap_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r,(_r._txfir_tap_ctl9)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r,(_r._txfir_tap_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL9r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl9))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL9r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL9r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r
#define TXFIR_TAP_CTL9r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_t TXFIR_TAP_CTL9r_t;
#define TXFIR_TAP_CTL9r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_CLR
#define TXFIR_TAP_CTL9r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_SET
#define TXFIR_TAP_CTL9r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_GET
#define TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_GET
#define TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r_TXFIR_TAP9_COEFFf_SET
#define READ_TXFIR_TAP_CTL9r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL9r
#define WRITE_TXFIR_TAP_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL9r
#define MODIFY_TXFIR_TAP_CTL9r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL9r
#define READLN_TXFIR_TAP_CTL9r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL9r
#define WRITELN_TXFIR_TAP_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL9r
#define WRITEALL_TXFIR_TAP_CTL9r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL10
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13d
 * DEVAD:    1
 * DESC:     txfir tap control 10 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP10_COEFF TXFIR tap 10 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r (0x0001d13d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL10.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl10[1];
	uint32_t _txfir_tap_ctl10;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_CLR(r) (r).txfir_tap_ctl10[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_SET(r,d) (r).txfir_tap_ctl10[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_GET(r) (r).txfir_tap_ctl10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_GET(r) (((r).txfir_tap_ctl10[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_SET(r,f) (r).txfir_tap_ctl10[0]=(((r).txfir_tap_ctl10[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL10.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r,(_r._txfir_tap_ctl10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r,(_r._txfir_tap_ctl10)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r,(_r._txfir_tap_ctl10))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL10r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL10r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl10))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL10r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL10r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r
#define TXFIR_TAP_CTL10r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_t TXFIR_TAP_CTL10r_t;
#define TXFIR_TAP_CTL10r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_CLR
#define TXFIR_TAP_CTL10r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_SET
#define TXFIR_TAP_CTL10r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_GET
#define TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_GET
#define TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r_TXFIR_TAP10_COEFFf_SET
#define READ_TXFIR_TAP_CTL10r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL10r
#define WRITE_TXFIR_TAP_CTL10r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL10r
#define MODIFY_TXFIR_TAP_CTL10r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL10r
#define READLN_TXFIR_TAP_CTL10r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL10r
#define WRITELN_TXFIR_TAP_CTL10r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL10r
#define WRITEALL_TXFIR_TAP_CTL10r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXFIR_TAP_CTL11
 * BLOCKS:   TX_FED
 * REGADDR:  0xd13e
 * DEVAD:    1
 * DESC:     txfir tap control 11 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_TAP11_COEFF TXFIR tap 11 coeffient values in signed 2's complement formattap range: -64 to +63 in PAM4 mode-24 to +23 in NRZ mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r (0x0001d13e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_TAP_CTL11.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_s {
	uint32_t v[1];
	uint32_t txfir_tap_ctl11[1];
	uint32_t _txfir_tap_ctl11;
} BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_CLR(r) (r).txfir_tap_ctl11[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_SET(r,d) (r).txfir_tap_ctl11[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_GET(r) (r).txfir_tap_ctl11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_GET(r) (((r).txfir_tap_ctl11[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_SET(r,f) (r).txfir_tap_ctl11[0]=(((r).txfir_tap_ctl11[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_TAP_CTL11.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r,(_r._txfir_tap_ctl11))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r,(_r._txfir_tap_ctl11)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r,(_r._txfir_tap_ctl11))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL11r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl11))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL11r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_tap_ctl11))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL11r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_tap_ctl11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_TAP_CTL11r BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r
#define TXFIR_TAP_CTL11r_SIZE BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_t TXFIR_TAP_CTL11r_t;
#define TXFIR_TAP_CTL11r_CLR BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_CLR
#define TXFIR_TAP_CTL11r_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_SET
#define TXFIR_TAP_CTL11r_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_GET
#define TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_GET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_GET
#define TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_SET BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r_TXFIR_TAP11_COEFFf_SET
#define READ_TXFIR_TAP_CTL11r BCMI_TSCBH_FLEXE_XGXS_READ_TXFIR_TAP_CTL11r
#define WRITE_TXFIR_TAP_CTL11r BCMI_TSCBH_FLEXE_XGXS_WRITE_TXFIR_TAP_CTL11r
#define MODIFY_TXFIR_TAP_CTL11r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXFIR_TAP_CTL11r
#define READLN_TXFIR_TAP_CTL11r BCMI_TSCBH_FLEXE_XGXS_READLN_TXFIR_TAP_CTL11r
#define WRITELN_TXFIR_TAP_CTL11r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXFIR_TAP_CTL11r
#define WRITEALL_TXFIR_TAP_CTL11r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXFIR_TAP_CTL11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXFIR_TAP_CTL11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PLL_CAL_CTL7
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd147
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 7.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_MODE         PLL Multiplier.00000  = 64;00001  = 66;00010  = 80;00011  = 128;00100  = 132;00101  = 140;00110  = 160;00111  = 165;01000  = 168;01001  = 170;01010  = 175;01011  = 180;01100  = 184;01101  = 200;01110  = 224;01111  = 264;10000  = 96;10001  = 120;10010  = 144;10011  = 198'
 *     RESCAL_FRC_VAL   rescal force value.
 *     RESCAL_FRC       rescal force to use rescal force value.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r (0x0001d147 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl7[1];
	uint32_t _pll_cal_ctl7;
} BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_CLR(r) (r).pll_cal_ctl7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_SET(r,d) (r).pll_cal_ctl7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_GET(r) (r).pll_cal_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET(r) ((((r).pll_cal_ctl7[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET(r) ((((r).pll_cal_ctl7[0]) >> 6) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET(r) (((r).pll_cal_ctl7[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PLL_CAL_CTL7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PLL_CAL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PLL_CAL_CTL7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PLL_CAL_CTL7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL7r BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r
#define PLL_CAL_CTL7r_SIZE BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_t PLL_CAL_CTL7r_t;
#define PLL_CAL_CTL7r_CLR BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_CLR
#define PLL_CAL_CTL7r_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_SET
#define PLL_CAL_CTL7r_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET
#define PLL_CAL_CTL7r_PLL_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET
#define PLL_CAL_CTL7r_PLL_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET
#define READ_PLL_CAL_CTL7r BCMI_TSCBH_FLEXE_XGXS_READ_PLL_CAL_CTL7r
#define WRITE_PLL_CAL_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITE_PLL_CAL_CTL7r
#define MODIFY_PLL_CAL_CTL7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PLL_CAL_CTL7r
#define READLN_PLL_CAL_CTL7r BCMI_TSCBH_FLEXE_XGXS_READLN_PLL_CAL_CTL7r
#define WRITELN_PLL_CAL_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PLL_CAL_CTL7r
#define WRITEALL_PLL_CAL_CTL7r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PLL_CAL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  PLL_CAL_CTL_STS0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd148
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL_LOCK_LH_LL   indicates change on pll_lock status bit. It is clear on read status register
 *     PLL_SEQ_PASS_LH_LL indicates change on pll_seq_pass status bit. It is clear on read status register
 *     PLL_SEQ_DONE_LH_LL indicates change on pll_seq_done status bit. It is clear on read status register
 *     FREQ_PASS_SM_LH_LL indicates change on freq_pass_sm status bit. It is clear on read status register
 *     FREQ_DONE_SM_LH_LL indicates change on freq_done_sm status bit. It is clear on read status register
 *     CAP_PASS_LH_LL   indicates change on cap_pass status bit. It is clear on read status register
 *     CAP_DONE_LH_LL   indicates change on cap_done status bit. It is clear on read status register
 *     PLL_LOCK         status bit indicating PLL is locked
 *     PLL_SEQ_PASS     status bit indicating pll sequencer finised successfully
 *     PLL_SEQ_DONE     status bit indicating pll sequencer is done
 *     FREQ_PASS_SM     status bit indicating frequency lock
 *     FREQ_DONE_SM     status bit indicating freq det is done
 *     CAP_PASS         status indicating cap value was found
 *     CAP_DONE         status indicating cap sequencer is done
 *     LOST_PLL_LOCK_SM status bit indicating pll_lock was lost, clear on read
 */
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r (0x0001d148 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts0[1];
	uint32_t _pll_cal_ctl_sts0;
} BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CLR(r) (r).pll_cal_ctl_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_SET(r,d) (r).pll_cal_ctl_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_GET(r) (r).pll_cal_ctl_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET(r) (((r).pll_cal_ctl_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_PLL_CAL_CTL_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_PLL_CAL_CTL_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS0r BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r
#define PLL_CAL_CTL_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_t PLL_CAL_CTL_STS0r_t;
#define PLL_CAL_CTL_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CLR
#define PLL_CAL_CTL_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_SET
#define PLL_CAL_CTL_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET
#define READ_PLL_CAL_CTL_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_PLL_CAL_CTL_STS0r
#define WRITE_PLL_CAL_CTL_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_PLL_CAL_CTL_STS0r
#define MODIFY_PLL_CAL_CTL_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_PLL_CAL_CTL_STS0r
#define READLN_PLL_CAL_CTL_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_PLL_CAL_CTL_STS0r
#define WRITELN_PLL_CAL_CTL_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_PLL_CAL_CTL_STS0r
#define WRITEALL_PLL_CAL_CTL_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_PLL_CAL_CTL_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_PLL_CAL_CTL_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CNT_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd160
 * DEVAD:    1
 * DESC:     PRBS Checker Count Control
 * RESETVAL: 0x8602 (34306)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_LOCK_CNT specifies the number of consecutive valid clock cycles without any bit errorfor PRBS checker to go into PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will lock as soon as it gets the first clock cycle with no bit error.likewise 31 indicates that PRBS will lock as soon as it gets the 32 consecutive clocks with no error.
 *     PRBS_CHK_OOL_CNT specifies the number of consecutive valid clock cycles with 1 or more bit errorsfor PRBS checker to go out of PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will go out of lock as soon as it gets the first clock cycle with 1 or more bit errors.likewise 31 indicates that PRBS will go out of lock as soon as it gets the 32 consecutive clocks with 1 or more errors.
 *     RX_TRN_ACTIVE_AUTO_MODE_EN 1'b1 will forcefully disable the below described RX datapath functions automatically while RX Link Training is enabled and active irrespective of the below register bit settings .- PAM4 Gray Decoder         (enabled by field pam4_gray_dec_en       )- PAM4 Decoder              (enabled by field pam4_decoder_en        )- PAM4 Symbol bit-swap      (enabled by field pam4_rx_symbol_bit_swap)- PAM4 Back Channel Decoder (enabled by field bc_dec_en              )- PAM4 Descrambler          (enabled by field rx_descrambler_en      )- NRZ  Differential Decoder (enabled by field tlb_rx_diff_dec_en     )1'b0 will ignore the control signal from RX Link Training and the above RX datapath functions will be enabled based on their individual enable bits irrespective of the RX training status where enabled or disabled.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr (0x0001d160 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CNT_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cnt_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cnt_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cnt_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cnt_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET(r) (r).tlb_rx_prbs_chk_cnt_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET(r) (((r).tlb_rx_prbs_chk_cnt_cfg[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CNT_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cnt_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr
#define TLB_RX_PRBS_CHK_CNT_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t TLB_RX_PRBS_CHK_CNT_CFGr_t;
#define TLB_RX_PRBS_CHK_CNT_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR
#define TLB_RX_PRBS_CHK_CNT_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_RX_TRN_ACTIVE_AUTO_MODE_ENf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr
#define READLN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd161
 * DEVAD:    1
 * DESC:     PRBS Checker Control
 * RESETVAL: 0x12a (298)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN      PRBS checker enable.1 => enable  the PRBS checker.0 => disable the PRBS checker.
 *     PRBS_CHK_MODE_SEL PRBS checker mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> PRBS 49 (1 + x^40 + x^49)
 *     PRBS_CHK_INV     PRBS Invert enable.1 => will invert all the data bits to the PRBS checker.0 => will send normal data to the PRBS checker.
 *     PRBS_CHK_MODE    PRBS LOCK state machine select.2'd0 -> Self-sync mode w/ hysteresis. PRBS seed register is continuously seeded with previous received bits.This mode results in faster locking, but bit errors are counted multiple times (often by 3x).2'd1 -> Initial seed mode w/ hysteresis. PRBS seed registers is seeded with previous received bits only till PRBS lock isacquired and then they run locally independently from the received data until the checker goes out of PRBS lock.2'd2 -> Initial seed mode w/o hysteresis. Similar to mode 1 above except once locked it stays locked until PRBS is disabled.2'd3 -> reserved for future use.
 *     PRBS_CHK_EN_AUTO_MODE PRBS Checker Enable Mode Control.1 => select (rx_dsc_lock & prbs_chk_en) as PRBS checker enable control.0 => select                prbs_chk_en  as PRBS checker enable control.
 *     PRBS_BURST_LEN_CHK_EN 0 => disbale, 1=> enable (default)
 *     PRBS_CHK_ERR_CNT_BURST_MODE PRBS Error Counter Mode.1 => Each busrt of error will be counted as 1 error in the error counter. Each error busrt must be separated by 1 error-free cycle of data which in worst case should be 39 bits.0 => Each bit error will be counted.
 *     TRNSUM_ERROR_COUNT_EN Training sum error counter Mode enable.1 => will make the PRBS error counter used as trnsum_error counter. PRBS checker can not be used during this mode.0 => PRBS checker mode.
 *     PRBS_CHK_CLK_EN_FRC_ON PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 *     PRBS_CHK_MODE_SEL_MSB Extending PRBS polynomial select by using this bit as bit[3] alongwith prbs_chk_mode_sel[2:0].1'b0 will select old PRBS polynomials for PRBS 7, 9, 11, 15, 23, 31, 49 and 58 based on prbs_chk_mode_sel[2:0].1'b1 will select new PRBS polynomials for PRBS 10, 20, 13 for PAM4 based on prbs_chk_mode_sel[2:0].1'b1 & prbs_chk_mode_sel[2:0] == 0 will select PRBS 10.1'b1 & prbs_chk_mode_sel[2:0] == 1 will select PRBS 20.1'b1 & prbs_chk_mode_sel[2:0] == 2 will select PRBS 13.1'b1 & prbs_chk_mode_sel[2:0] == 2 will select PRBS 13  with polynomial (1+x^1+x^2+x^12+x^13). This pattern is also used for PAM4 Link Training Lane 0 pattern.1'b1 & prbs_chk_mode_sel[2:0] == 3 is reserved for future use.1'b1 & prbs_chk_mode_sel[2:0] == 4 will select PAM4 Link Training Lane 1 PRBS 13  polynomial (1 + x2 + x3 + x7  + x13). Debug modes.1'b1 & prbs_chk_mode_sel[2:0] == 5 will select PAM4 Link Training Lane 2 PRBS 13  polynomial (1 + x2 + x4 + x8  + x13). Debug modes.1'b1 & prbs_chk_mode_sel[2:0] == 6 will select PAM4 Link Training Lane 3 PRBS 13  polynomial (1 + x2 + x5 + x9  + x13). Debug modes.1'b1 & prbs_chk_mode_sel[2:0] == 7 is reserved for future use.
 *     PRBS_CHK_BURST_ERR_CNT_EN PRBS checker burst error count mode enable.1'b1 will enable the PRBS checker burst error count mode. It should be enabled for prbs_chk_burst_err_cnt counter .Make sure that only one of the 2 register settings ((prbs_chk_en_timer_mode >=2 & prbs_chk_en_timeout > 0) and prbs_chk_burst_err_cnt_en) are TRUE at any given time and not simultaneously TRUE.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr (0x0001d161 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_GET(r) (r).tlb_rx_prbs_chk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 5) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 1) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET(r) (((r).tlb_rx_prbs_chk_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr
#define TLB_RX_PRBS_CHK_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_t TLB_RX_PRBS_CHK_CFGr_t;
#define TLB_RX_PRBS_CHK_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR
#define TLB_RX_PRBS_CHK_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_SET
#define TLB_RX_PRBS_CHK_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_BURST_ERR_CNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SEL_MSBf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET
#define READ_TLB_RX_PRBS_CHK_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr
#define READLN_TLB_RX_PRBS_CHK_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd162
 * DEVAD:    1
 * DESC:     Digital Loopback Control
 * RESETVAL: 0xe (14)
 * ACCESS:   R/W
 * FIELDS:
 *     DIG_LPBK_EN      TX to RX Parallel Loopback (Digital Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     DIG_LPBK_PD_MODE Digital Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     DIG_LPBK_PD_FLT_BYPASS Digital Loopback Phase Detector Filter Bypass. For repeater applications, it should be 1'b1.For other applications filter can be enabled for better jitter tolerance performance for the didgital loopback.
 *     DIG_LPBK_PD_BIAS_EN 1'b1 will enable PD inc bias mode where there will be inc generated every 16th clock cycle..1'b0 will disable the PD bias mode so inc/dec will be generated based on the PD output.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr (0x0001d162 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_cfg[1];
	uint32_t _tlb_rx_dig_lpbk_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR(r) (r).tlb_rx_dig_lpbk_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_SET(r,d) (r).tlb_rx_dig_lpbk_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_GET(r) (r).tlb_rx_dig_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET(r) (((r).tlb_rx_dig_lpbk_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr
#define TLB_RX_DIG_LPBK_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_t TLB_RX_DIG_LPBK_CFGr_t;
#define TLB_RX_DIG_LPBK_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR
#define TLB_RX_DIG_LPBK_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_SET
#define TLB_RX_DIG_LPBK_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_FLT_BYPASSf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET
#define READ_TLB_RX_DIG_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_DIG_LPBK_CFGr
#define WRITE_TLB_RX_DIG_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr
#define MODIFY_TLB_RX_DIG_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr
#define READLN_TLB_RX_DIG_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr
#define WRITELN_TLB_RX_DIG_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr
#define WRITEALL_TLB_RX_DIG_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_TLB_RX_MISC_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd163
 * DEVAD:    1
 * DESC:     TLB RX Misc. Control
 * RESETVAL: 0x700 (1792)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PMD_DP_INVERT RX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     RX_DESCRAMBLER_EN PAM4 RX Datapath De-scrambler Enable. Applicable only for the PAM4 modes with PRBS or PCS data.Not applicable when external FEC feedback is used.1 => PAM4 RX Datapath  De-scrambler is Enabled. If rx_descrambler_en is enabled then 40 bits of the transmitted datawill be XORed with the 40 MSB bits of the fixed pattern sequence register {patt_gen_seq_14[15:0], patt_gen_seq_13[15:0], patt_gen_seq_12[15:8]}.Make sure {patt_gen_seq_14[15:0], patt_gen_seq_13[15:0], patt_gen_seq_12[15:8]} bits are only re-programmed or changed when rx_descrambler_en reg field is 1'b0.0 => PAM4 RX Datapath De-scrambler is Disabled.
 *     DBG_MASK_DIG_LPBK_EN Mask bit for dig_lpbk_en in the pmd_rx_lock equation. This is a debug register.1 => pmd_rx_lock will be forced to 1'b0 during digital loopback.0 => pmd_rx_lock will be forced to 1'b1 during digital loopback.
 *     TLB_RX_DIFF_DEC_EN 1'b1 will enable the Differential Decoder for pmd_rx_data. Only applicable to PCS RX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 *     TLB_RX_NRZ_LL_MODE_EN RX low latency mode enable for the NRZ OSR modes. It is not applicable to the PAM4 modes.When Enabled by writing to 1'b1 for NRZ OS modes, following will be the data format on the 40 bit RX data bus. RX data_valid will be forced to 1'b1 in this case.PCS RX data can be fed directly to the PCS TX data (with TX native analog format mode bit enabled) on the other end for Repeater Applications.OS1/2/4 modes        - 20 bits of RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data bus going out to PCS.OS8/16/32 modes      - 20 bits of over-sampled RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data bus going out to PCS.OS16.5/OS20.25 modes - 20 bits of over-sampled RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data bus going out to PCS.
 *     PAM4_GRAY_DEC_EN PAM4 Gray Decoder Enable. Enable it only for the PAM4 modes.1 => PAM4 Gray Decoder is Enabled.0 => PAM4 Gray Decoder is Disabled.
 *     PAM4_DECODER_EN  PAM4 Decoder Enable. Enable it only for the PAM4 NR mode.1 => PAM4 Decoder is Enabled.0 => PAM4 Decoder is Disabled.
 *     PAM4_RX_SYMBOL_BIT_SWAP PAM4 Symbol bits {A,B} swap enable. Enable it only for the PAM4 modes. Bit swapping is done just after the PAM4 gray decoder.1 => 2 bits PAM4 symbol bits will be swapped where PAM4 symbol bits {A,B} maps to the datastream bits {[n+1], [n]} where n is the first bit in receive order.0 => No swapping, default mode. PAM4 symbol bits {A,B} maps to the datastream bits {[n], [n+1]} where n is the first bit in receive order.
 *     PRBS_CHK_AUTO_DETECT_CNT Specifies the timer for the auto-detect search in each polynomial setting.
 *     PRBS_CHK_AUTO_DETECT_EN PRBS checker Auto detect mode enable. If enabled then it will go through all the supported PRBS polynomials in round-robin fashion and search for prbs_chk_lock=1 until AUTO-DETECT SEARCH timer is expired.
 *     PRBS_CHK_AUTO_DETECT_RELOCK_EN PRBS checker Auto detect Re-lock enable. If enabled then it will go and start the auto-detect upon loss of signal once it already found a valid AUTO-DETECT LOCK.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr (0x0001d163 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_TLB_RX_MISC_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_tlb_rx_misc_cfg[1];
	uint32_t _tlb_rx_tlb_rx_misc_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR(r) (r).tlb_rx_tlb_rx_misc_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET(r,d) (r).tlb_rx_tlb_rx_misc_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET(r) (r).tlb_rx_tlb_rx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_GET(r) ((((r).tlb_rx_tlb_rx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET(r) (((r).tlb_rx_tlb_rx_misc_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET(r,f) (r).tlb_rx_tlb_rx_misc_cfg[0]=(((r).tlb_rx_tlb_rx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_TLB_RX_MISC_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr,(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_tlb_rx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_tlb_rx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr
#define TLB_RX_TLB_RX_MISC_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_t TLB_RX_TLB_RX_MISC_CFGr_t;
#define TLB_RX_TLB_RX_MISC_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_CLR
#define TLB_RX_TLB_RX_MISC_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_SET
#define TLB_RX_TLB_RX_MISC_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_RELOCK_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PRBS_CHK_AUTO_DETECT_CNTf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_RX_SYMBOL_BIT_SWAPf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_DECODER_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_PAM4_GRAY_DEC_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_NRZ_LL_MODE_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_DESCRAMBLER_ENf_SET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET
#define TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET
#define READ_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_TLB_RX_MISC_CFGr
#define WRITE_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_TLB_RX_MISC_CFGr
#define MODIFY_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_TLB_RX_MISC_CFGr
#define READLN_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITELN_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_TLB_RX_MISC_CFGr
#define WRITEALL_TLB_RX_TLB_RX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_TLB_RX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_TLB_RX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_EN_TMR_CTL
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd164
 * DEVAD:    1
 * DESC:     TLB RX PRBS Checker Enable Timer Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN_TIMER_MODE prbs_chk_en timer mode.2'b0x => prbs_chk_en timer is disabled and PRBS checker mode is enabled as per prbs_chk_en register.2'b10 => use heartbeat_toggle_1us for the timer.2'b11 => use heartbeat_toggle_1ms for the timer.Make sure that only one of the 2 register settings ((prbs_chk_en_timer_mode >=2 & prbs_chk_en_timeout > 0) and prbs_chk_burst_err_cnt_en) are TRUE at any given time and not simultaneously TRUE.
 *     PRBS_CHK_EN_TIMEOUT PRBS timer timeout value.Valid range 0 to 31 which maps to 0 to 448. Should be programmed before enabling the PRBS checker in timer mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr (0x0001d164 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_en_tmr_ctl[1];
	uint32_t _tlb_rx_prbs_chk_en_tmr_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET(r,d) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET(r) ((((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET(r) (((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_en_tmr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET
#define READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd165
 * DEVAD:    1
 * DESC:     PRBS Checker Burst Error Counter Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_BURST_ERR_CNT PRBS Checker Burst Error Counter Status Register. It is a clear on read register. This register countsthe number of Burst in errors separated by atleast 1 clock cycle worth of data without any bit in error.prbs_chk_burst_err_cnt_en should be set to 1'b1 for this counter to work.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr (0x0001d165 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_burst_err_cnt_sts[1];
	uint32_t _tlb_rx_prbs_chk_burst_err_cnt_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET(r,d) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET(r) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET(r) (((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_burst_err_cnt_sts[0]=(((r).tlb_rx_prbs_chk_burst_err_cnt_sts[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_BURST_ERR_CNT_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_burst_err_cnt_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_t;
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_CLR
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_SET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_GET
#define TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr_PRBS_CHK_BURST_ERR_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_BURST_ERR_CNT_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_DBG_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd166
 * DEVAD:    1
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DBG_PMD_RX_LOCK  Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     DBG_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr (0x0001d166 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DBG_PMD_RX_LOCK_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dbg_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_dbg_pmd_rx_lock_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_dbg_pmd_rx_lock_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_dbg_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_dbg_pmd_rx_lock_sts[0]=(((r).tlb_rx_dbg_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DBG_PMD_RX_LOCK_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr,(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dbg_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dbg_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_t TLB_RX_DBG_PMD_RX_LOCK_STSr_t;
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_GET
#define TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr_DBG_PMD_RX_LOCKf_SET
#define READ_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_DBG_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_DBG_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DBG_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_UC_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd167
 * DEVAD:    1
 * DESC:     Debug PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     UC_PMD_RX_LOCK   Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     UC_PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr (0x0001d167 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_UC_PMD_RX_LOCK_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_uc_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_uc_pmd_rx_lock_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_uc_pmd_rx_lock_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_uc_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_uc_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_uc_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_uc_pmd_rx_lock_sts[0]=(((r).tlb_rx_uc_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_UC_PMD_RX_LOCK_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr,(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_uc_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_uc_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_t TLB_RX_UC_PMD_RX_LOCK_STSr_t;
#define TLB_RX_UC_PMD_RX_LOCK_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_UC_PMD_RX_LOCK_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_GET
#define TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr_UC_PMD_RX_LOCKf_SET
#define READ_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_UC_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_UC_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_UC_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_UC_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_UC_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_PD_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd168
 * DEVAD:    1
 * DESC:     Digital Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     DIG_LPBK_PD_LATE_IND 1 means dp_rclk20 is sampling data late so reduce the delay of the dp_rclk20 clock phase. This will result in RX PI phase step decrement.
 *     DIG_LPBK_PD_EARLY_IND 1 means dp_rclk20 is sampling data earlier so delay the dp_rclk20 clock phase. This will result in RX PI phase step increment.
 *     PRBS_CHK_AUTO_DETECT_LOCK Live indication of AUTO-DETECT Lock. Set to 1'b1 once auto-detect finds the PRBS lock.
 *     PRBS_CHK_INV_AUTO_DETECT Valid only when prbs_chk_auto_detect_lock=1. Indicates te PRBS polynomial invert bit.
 *     PRBS_CHK_MODE_SEL_AUTO_DETECT Valid only when prbs_chk_auto_detect_lock=1. Equivalent to prbs_chk_mode_sel     register in auto-detect mode.
 *     PRBS_CHK_MODE_SEL_MSB_AUTO_DETECT Valid only when prbs_chk_auto_detect_lock=1. Equivalent to prbs_chk_mode_sel_msb register in auto-detect mode.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr (0x0001d168 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_PD_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_pd_sts[1];
	uint32_t _tlb_rx_dig_lpbk_pd_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR(r) (r).tlb_rx_dig_lpbk_pd_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET(r,d) (r).tlb_rx_dig_lpbk_pd_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET(r) (r).tlb_rx_dig_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 10) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_rx_dig_lpbk_pd_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_PD_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr
#define TLB_RX_DIG_LPBK_PD_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t TLB_RX_DIG_LPBK_PD_STSr_t;
#define TLB_RX_DIG_LPBK_PD_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR
#define TLB_RX_DIG_LPBK_PD_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET
#define TLB_RX_DIG_LPBK_PD_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_MSB_AUTO_DETECTf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_MODE_SEL_AUTO_DETECTf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_INV_AUTO_DETECTf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_PRBS_CHK_AUTO_DETECT_LOCKf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET
#define READ_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr
#define WRITE_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr
#define MODIFY_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr
#define READLN_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITELN_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITEALL_TLB_RX_DIG_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_DIG_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd169
 * DEVAD:    1
 * DESC:     PRBS Checker LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_LOCK    PRBS Checker LOCK Indication. This is a live indication of the status of the PRBS Checker state machine.1 => PRBS Checker is in LOCKED state.0 => PRBS Checker is out of LOCK state and state machine is searching for a LOCK.
 *     PRBS_CHK_ERR_CNT_NO_CLR PRBS Checker Error Counter which does not get cleared upon read.MSB bit 14 is OR of the MSB bits [30:14] of the internal error counter.LSB bits [13:0] are assigned to LSB bits [13:0] of the internal error counter.It can be cleared by reading the status register prbs_chk_err_cnt_msb.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr (0x0001d169 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_LOCK_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_lock_sts[1];
	uint32_t _tlb_rx_prbs_chk_lock_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR(r) (r).tlb_rx_prbs_chk_lock_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET(r,d) (r).tlb_rx_prbs_chk_lock_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET(r) (r).tlb_rx_prbs_chk_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET(r) ((((r).tlb_rx_prbs_chk_lock_sts[0]) >> 1) & 0x7fff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x7fff << 1)) | ((((uint32_t)f) & 0x7fff) << 1)) | (32767 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET(r) (((r).tlb_rx_prbs_chk_lock_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_LOCK_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr
#define TLB_RX_PRBS_CHK_LOCK_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t TLB_RX_PRBS_CHK_LOCK_STSr_t;
#define TLB_RX_PRBS_CHK_LOCK_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR
#define TLB_RX_PRBS_CHK_LOCK_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_ERR_CNT_NO_CLRf_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET
#define READ_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITE_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr
#define MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr
#define READLN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16a
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter MSB Status
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_MSB 15 bits MSB portion of PRBS Checker Error Counter Status Register. It is a clear on read register.Once MSB bits [30:16] of the counter are read then LSB bits [15:0] of the error counter is loadedinto a holding register and internal PRBS error counter's all bits are cleared to 0s(or if there are any error in that particular clock cycle then that will be loaded).MSB portion must be read first before reading the LSB portion of the error counter.
 *     PRBS_CHK_LOCK_LOST_LH PRBS Checker LOCK_LOST Latch High Indication. This register captures the 1->0 transition on theprbs_chk_lock live status register and keep it latched until read. This is a clear on read status register.prbs_chk_lock_lost_lh status bit also indicate other PRBS checker states as below.- PRBS Checker is currently not enabled ||- PRBS Checker is currently not locked ||- PRBS_LOCK was lost when checker was enabled since the last read
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr (0x0001d16a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_msb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_msb_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET(r) ((((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) & 0x7fff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16b
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter LSB Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_LSB 16 bits LSB portion of PRBS Checker Error Counter Status Register. This register indicatesthe value in the holding register when MSB portion [30:16] of the error counter are read.MSB portion must be read first before reading the LSB portion of the error counter.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr (0x0001d16b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_lsb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_lsb_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16c
 * DEVAD:    1
 * DESC:     PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_RX_LOCK      PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr (0x0001d16c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PMD_RX_LOCK_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_pmd_rx_lock_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_pmd_rx_lock_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_pmd_rx_lock_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PMD_RX_LOCK_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr
#define TLB_RX_PMD_RX_LOCK_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t TLB_RX_PMD_RX_LOCK_STSr_t;
#define TLB_RX_PMD_RX_LOCK_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_PMD_RX_LOCK_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET
#define TLB_RX_PMD_RX_LOCK_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET
#define READ_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_PMD_RX_LOCK_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16d
 * DEVAD:    1
 * DESC:     PRBS Burst Error Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error length count. This the live indication of the live status of the PRBS burst error length and max at 6'd63. This register is cleared upon read.This register is supported for all the data traffic modes but only required for NRZ OSR modes OS1, OS2 and OS4 and PAM4 NR/PAM4 ER modes with and without Back Channel enabled.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr (0x0001d16d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_prbs_burst_err_len_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_prbs_burst_err_len_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_prbs_burst_err_len_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_prbs_burst_err_len_sts[0]=(((r).tlb_rx_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_burst_err_len_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16e
 * DEVAD:    1
 * DESC:     PRBS Burst Error Maximum Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MAX_PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error max length count. This the status of the PRBS burst error max length and max at 6'd63. This register is cleared upon read.This register is supported for all the data traffic modes but only required for NRZ OSR modes OS1, OS2 and OS4 and PAM4 NR/PAM4 ER modes with and without Back Channel enabled.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr (0x0001d16e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_max_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_max_prbs_burst_err_len_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_max_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_max_prbs_burst_err_len_sts[0]=(((r).tlb_rx_max_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_max_prbs_burst_err_len_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_TX_PATGEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd170
 * DEVAD:    1
 * DESC:     Pattern Generator Control
 * RESETVAL: 0xb000 (45056)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_EN      Fixed pattern generator enable.1 => enable  the fixed pattern generator.0 => disable the fixed pattern generator.
 *     PAM4_TX_LINEARITY_PATT_EN PAM4 Transmitter Linearity Pattern Enable. Lower priority than pam4_tx_jp03b_patt_en if both bits are enabled simultaneously. Make sure gray encoder and PAM4 precoder is disabled for this fixed pattern mode.1 => enable  the fixed pattern for PAM4 Transmitter Linearity Pattern of 320 bits (i.e. 160 symbols) long repeating pattern of 10 PAM4 levels of {-1, -1/3, +1/3, +1, -1, +1, -1, +1, +1/3, -1/3} whereeach level is 16UI in duration.  Program reg field {patt_gen_seq_1[3:0], patt_gen_seq_0[15:0]} bits = 20'b_0001_1011_0011_0011_1001 = 20'h1B339 before enabling this pattern.Transmission order is MSB first.  If this bit is enabled then make sure that other lane fixed pattern do not use fixed pattern 20 bit chunk of bits 19:0.0 => disable the PAM4 Transmitter Linearity Pattern generation.
 *     PAM4_TX_JP03B_PATT_EN JP03B Fixed Pattern Enable. Higher priority than pam4_tx_linearity_patt_en if both bits are enabled simultaneously. Make sure gray encoder and PAM4 precoder is disabled for this fixed pattern mode.1 => Enable  the fixed pattern for JP03B pattern of 124 bits (i.e. 62 symbols) long repeating pattern of {15{00,11}} + {16{11,00}}. Program reg field patt_gen_seq_1[15:8] bits = 8'b_0011_1100 = 8'h3C before enabling this pattern.Transmission order is MSB first. If this bit is enabled then make sure that other lane fixed pattern do not use fixed pattern 20 bit chunk of bits 39:20.0 => Disable the JP03B fixed pattern generation.C
 *     PATT_GEN_STOP_POS Valid values are 11 to 0. Defines the stop  position of the pattern in 20 bit chunks.This register value should be less than or equal to rg_patt_gen_start_pos.11 means stop at bit  220,10 means stop at bit  200, ...,0 means stop at bit    0so stop  bit is (rg_patt_gen_stop_pos*20).
 *     PATT_GEN_START_POS Valid values are 11 to 0. Defines the start position of the pattern in 20 bit chunks.11 means start at bit 239,10 means start at bit 219, ...,0 means start at bit  19so start bit is (rg_patt_gen_start_pos*20 + 19).
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr (0x0001d170 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PATGEN_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_patgen_cfg[1];
	uint32_t _tlb_tx_patgen_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_CLR(r) (r).tlb_tx_patgen_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_SET(r,d) (r).tlb_tx_patgen_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_GET(r) (r).tlb_tx_patgen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 8) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_GET(r) ((((r).tlb_tx_patgen_cfg[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET(r) (((r).tlb_tx_patgen_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET(r,f) (r).tlb_tx_patgen_cfg[0]=(((r).tlb_tx_patgen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PATGEN_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr,(_r._tlb_tx_patgen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_PATGEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patgen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_PATGEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patgen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_PATGEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_patgen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PATGEN_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr
#define TLB_TX_PATGEN_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_t TLB_TX_PATGEN_CFGr_t;
#define TLB_TX_PATGEN_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_CLR
#define TLB_TX_PATGEN_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_SET
#define TLB_TX_PATGEN_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_START_POSf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_STOP_POSf_SET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_GET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_JP03B_PATT_ENf_SET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_GET
#define TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PAM4_TX_LINEARITY_PATT_ENf_SET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_GET
#define TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr_PATT_GEN_ENf_SET
#define READ_TLB_TX_PATGEN_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_PATGEN_CFGr
#define WRITE_TLB_TX_PATGEN_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_PATGEN_CFGr
#define MODIFY_TLB_TX_PATGEN_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_PATGEN_CFGr
#define READLN_TLB_TX_PATGEN_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_PATGEN_CFGr
#define WRITELN_TLB_TX_PATGEN_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_PATGEN_CFGr
#define WRITEALL_TLB_TX_PATGEN_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_PATGEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PATGEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_TX_PRBS_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd171
 * DEVAD:    1
 * DESC:     PRBS Generator Control
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_GEN_EN      PRBS generator enable.1 => enable  the PRBS generator.0 => disable the PRBS generator.
 *     PRBS_GEN_MODE_SEL PRBS generator mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> PRBS 49 (1 + x^40 + x^49)
 *     PRBS_GEN_INV     PRBS Invert enable.1 => will invert all the data bits from the PRBS generator.0 => will send normal data from the PRBS generator.
 *     PRBS_GEN_ERR_INS PRBS Error Insert.0 to 1 transition on this signal will insert single bit error in the MSB bit of the data bus.
 *     PRBS_GEN_MODE_SEL_MSB Extending PRBS polynomial select by using this bit as bit[3] alongwith prbs_gen_mode_sel[2:0].1'b0 will select old PRBS polynomials for PRBS 7, 9, 11, 15, 23, 31, 49 and 58 based on prbs_gen_mode_sel[2:0].1'b1 will select new PRBS polynomials for PRBS 10, 20, 13 for PAM4 based on prbs_gen_mode_sel[2:0].1'b1 & prbs_gen_mode_sel[2:0] == 0 will select PRBS 10.1'b1 & prbs_gen_mode_sel[2:0] == 1 will select PRBS 20.1'b1 & prbs_gen_mode_sel[2:0] == 2 will select PRBS 13  with polynomial (1+x^1+x^2+x^12+x^13). This pattern is also used for PAM4 Link Training Lane 0 pattern.1'b1 & prbs_gen_mode_sel[2:0] == 3 is reserved for future use.1'b1 & prbs_gen_mode_sel[2:0] == 4 will select PAM4 Link Training Lane 1 PRBS 13  polynomial (1 + x2 + x3 + x7  + x13). Debug modes so auto-detect and self-sync mode is not supported.1'b1 & prbs_gen_mode_sel[2:0] == 5 will select PAM4 Link Training Lane 2 PRBS 13  polynomial (1 + x2 + x4 + x8  + x13). Debug modes so auto-detect and self-sync mode is not supported.1'b1 & prbs_gen_mode_sel[2:0] == 6 will select PAM4 Link Training Lane 3 PRBS 13  polynomial (1 + x2 + x5 + x9  + x13). Debug modes so auto-detect and self-sync mode is not supported.1'b1 & prbs_gen_mode_sel[2:0] == 7 is reserved for future use.
 *     PRBS_GEN_PAUSE_STROBE PRBS Generator Pause Strobe (debug register). It is a self clear register bit.Wrting to 1 will pause the PRBS generator for 1 clock cycle which means same 40 bits data will be replicated in the paused clock cycle. This will result into loss of prbs checker lock on the link partner.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr (0x0001d171 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PRBS_GEN_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_prbs_gen_cfg[1];
	uint32_t _tlb_tx_prbs_gen_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR(r) (r).tlb_tx_prbs_gen_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_SET(r,d) (r).tlb_tx_prbs_gen_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_GET(r) (r).tlb_tx_prbs_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 1) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET(r) (((r).tlb_tx_prbs_gen_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PRBS_GEN_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_prbs_gen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PRBS_GEN_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr
#define TLB_TX_PRBS_GEN_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_t TLB_TX_PRBS_GEN_CFGr_t;
#define TLB_TX_PRBS_GEN_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR
#define TLB_TX_PRBS_GEN_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_SET
#define TLB_TX_PRBS_GEN_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_PAUSE_STROBEf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SEL_MSBf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET
#define READ_TLB_TX_PRBS_GEN_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_PRBS_GEN_CFGr
#define WRITE_TLB_TX_PRBS_GEN_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr
#define MODIFY_TLB_TX_PRBS_GEN_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr
#define READLN_TLB_TX_PRBS_GEN_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr
#define WRITELN_TLB_TX_PRBS_GEN_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr
#define WRITEALL_TLB_TX_PRBS_GEN_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_TX_PRBS_GEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd172
 * DEVAD:    1
 * DESC:     Remote Loopback Control
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     RMT_LPBK_EN      RX to TX Parallel Loopback (Remote Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     RMT_LPBK_PD_MODE Remote Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     RMT_LPBK_PD_FRC_ON Remote loopback PD enable by force irrespective of rg_rmt_lpbk_en.1'b1 - enable the phase detector without the remote loopback enable. Can be used to lock RX and TXclock phases when there is a remote loopback outside PMD
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr (0x0001d172 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_cfg[1];
	uint32_t _tlb_tx_rmt_lpbk_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR(r) (r).tlb_tx_rmt_lpbk_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_SET(r,d) (r).tlb_tx_rmt_lpbk_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_GET(r) (r).tlb_tx_rmt_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET(r) (((r).tlb_tx_rmt_lpbk_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr
#define TLB_TX_RMT_LPBK_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_t TLB_TX_RMT_LPBK_CFGr_t;
#define TLB_TX_RMT_LPBK_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR
#define TLB_TX_RMT_LPBK_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_SET
#define TLB_TX_RMT_LPBK_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET
#define READ_TLB_TX_RMT_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_RMT_LPBK_CFGr
#define WRITE_TLB_TX_RMT_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr
#define MODIFY_TLB_TX_RMT_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr
#define READLN_TLB_TX_RMT_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr
#define WRITELN_TLB_TX_RMT_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr
#define WRITEALL_TLB_TX_RMT_LPBK_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_TX_TLB_TX_MISC_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd173
 * DEVAD:    1
 * DESC:     TLB TX Misc. Control
 * RESETVAL: 0x10 (16)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PMD_DP_INVERT TX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     TX_PCS_NATIVE_ANA_FRMT_EN TX PCS Interface Native Analog Format Enable.1 => TX PCS Interface is enabled in the Native Analog Format mode. TX PCS sends the over-sampled data in this mode which is sent directly to AFE.0 => Raw Data Mode where for every data request TX PCS will send 20 bits of valid data.
 *     TX_MUX_SEL_ORDER TX Data MUX Select Priority Order. When 1'b1 then priority of Pattern and PRBS generators are swapped w.r.t. CL72.0 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, patt_gen, cl72_tx, prbs_gen, tx_pcs}.1 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, prbs_gen, cl72_tx, patt_gen, tx_pcs}.
 *     TLB_TX_DIFF_ENC_EN 1'b1 will enable the Differential Encoder for pmd_tx_data. Only applicable to PCS TX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 *     TX_TRN_ACTIVE_AUTO_MODE_EN 1'b1 will forcefully disable the below described TX datapath functions automatically while TX Link Training is enabled and active irrespective of the below register bit settings .- PAM4 Gray Encoder         (enabled by field pam4_gray_enc_en)- PAM4 Precoder             (enabled by field pam4_precoder_en)- PAM4 Symbol bit-swap      (enabled by field pam4_tx_symbol_bit_swap)- NRZ Differential Encoder  (enabled by field tlb_tx_diff_enc_en)In addition to these function Back channel encoder and Scrambler are always disabled while TX Link Training is enabled and active irrespective of this register value.1'b0 will ignore the control signal from TX Link Training and the above TX datapath functions will be enabled based on their individual enable bits irrespective of the TX training status where enabled or disabled.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr (0x0001d173 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_MISC_CFG.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_misc_cfg[1];
	uint32_t _tlb_tx_tlb_tx_misc_cfg;
} BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR(r) (r).tlb_tx_tlb_tx_misc_cfg[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET(r,d) (r).tlb_tx_tlb_tx_misc_cfg[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET(r) (r).tlb_tx_tlb_tx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET(r) ((((r).tlb_tx_tlb_tx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET(r) (((r).tlb_tx_tlb_tx_misc_cfg[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET(r,f) (r).tlb_tx_tlb_tx_misc_cfg[0]=(((r).tlb_tx_tlb_tx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_MISC_CFG.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr,(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_misc_cfg))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr
#define TLB_TX_TLB_TX_MISC_CFGr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_t TLB_TX_TLB_TX_MISC_CFGr_t;
#define TLB_TX_TLB_TX_MISC_CFGr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_CLR
#define TLB_TX_TLB_TX_MISC_CFGr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_SET
#define TLB_TX_TLB_TX_MISC_CFGr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_TRN_ACTIVE_AUTO_MODE_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET
#define TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET
#define READ_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_TLB_TX_MISC_CFGr
#define WRITE_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_TLB_TX_MISC_CFGr
#define MODIFY_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_TLB_TX_MISC_CFGr
#define READLN_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITELN_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_TLB_TX_MISC_CFGr
#define WRITEALL_TLB_TX_TLB_TX_MISC_CFGr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_TLB_TX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_TX_TLB_TX_PAM4_CFG0
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd175
 * DEVAD:    1
 * DESC:     TLB TX PAM4 Controls 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PAM4_GRAY_ENC_EN PAM4 Gray Encoder Enable. Enable it only for the PAM4 modes.1 => PAM4 Gray Encoder is Enabled.0 => PAM4 Gray Encoder is Disabled.
 *     PAM4_PRECODER_EN PAM4 Precoder Enable. Enable it only for the PAM4 modes.1 => PAM4 Precoder is Enabled.0 => PAM4 Precoder is Disabled.
 *     TX_SCRAMBLER_EN  PAM4 TX Datapath Scrambler Enable. Applicable only for the PAM4 modes with PRBS or PCS data.1 => PAM4 TX Datapath Scrambler is Enabled. If tx_scrambler_en is enabled then 40 bits of the transmitted datawill be XORed with the 40 LSB bits of the fixed pattern sequence register {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]}.Make sure {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]} bits are only re-programmed or changed when both tx_scrambler_en and bc_enc_err_ins_en reg fields are 1'b0.0 => PAM4 TX Datapath Scrambler is Disabled.
 *     PAM4_TX_SYMBOL_BIT_SWAP PAM4 Symbol bits {A,B} swap enable. Enable it only for the PAM4 modes. Bit swapping is done just before the PAM4 gray encoder.1 => 2 bits PAM4 symbol bits will be swapped where PAM4 symbol bits {A,B} maps to the datastream bits {[n+1], [n]} where n is the first bit in transmission order.0 => No swapping, default mode. PAM4 symbol bits {A,B} maps to the datastream bits {[n], [n+1]} where n is the first bit in transmission order.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r (0x0001d175 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_TLB_TX_PAM4_CFG0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_tx_tlb_tx_pam4_cfg0[1];
	uint32_t _tlb_tx_tlb_tx_pam4_cfg0;
} BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_CLR(r) (r).tlb_tx_tlb_tx_pam4_cfg0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SET(r,d) (r).tlb_tx_tlb_tx_pam4_cfg0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_GET(r) (r).tlb_tx_tlb_tx_pam4_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_GET(r) ((((r).tlb_tx_tlb_tx_pam4_cfg0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_GET(r) ((((r).tlb_tx_tlb_tx_pam4_cfg0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_GET(r) ((((r).tlb_tx_tlb_tx_pam4_cfg0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_GET(r) (((r).tlb_tx_tlb_tx_pam4_cfg0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_SET(r,f) (r).tlb_tx_tlb_tx_pam4_cfg0[0]=(((r).tlb_tx_tlb_tx_pam4_cfg0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_TLB_TX_PAM4_CFG0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r,(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r,(_r._tlb_tx_tlb_tx_pam4_cfg0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r,(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_tlb_tx_pam4_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_TLB_TX_PAM4_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_tlb_tx_pam4_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_TLB_TX_PAM4_CFG0r BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r
#define TLB_TX_TLB_TX_PAM4_CFG0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_t TLB_TX_TLB_TX_PAM4_CFG0r_t;
#define TLB_TX_TLB_TX_PAM4_CFG0r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_CLR
#define TLB_TX_TLB_TX_PAM4_CFG0r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_TX_SYMBOL_BIT_SWAPf_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_TX_SCRAMBLER_ENf_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_PRECODER_ENf_SET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_GET
#define TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r_PAM4_GRAY_ENC_ENf_SET
#define READ_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_TLB_TX_PAM4_CFG0r
#define WRITE_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_TLB_TX_PAM4_CFG0r
#define MODIFY_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_TLB_TX_PAM4_CFG0r
#define READLN_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_TLB_TX_PAM4_CFG0r
#define WRITELN_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_TLB_TX_PAM4_CFG0r
#define WRITEALL_TLB_TX_TLB_TX_PAM4_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_TLB_TX_PAM4_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_TX_TLB_TX_PAM4_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_PD_STS
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd178
 * DEVAD:    1
 * DESC:     Remote Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     RMT_LPBK_PD_LATE_IND 1 means dp_tclk20 is sampling data late so reduce the delay of the dp_tclk20 clock phase. This will result in TX PI phase step decrement.
 *     RMT_LPBK_PD_EARLY_IND 1 means dp_tclk20 is sampling data earlier so delay the dp_tclk20 clock phase. This will result in TX PI phase step increment.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr (0x0001d178 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_PD_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_pd_sts[1];
	uint32_t _tlb_tx_rmt_lpbk_pd_sts;
} BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR(r) (r).tlb_tx_rmt_lpbk_pd_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET(r,d) (r).tlb_tx_rmt_lpbk_pd_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET(r) (r).tlb_tx_rmt_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_tx_rmt_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_tx_rmt_lpbk_pd_sts[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_PD_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr
#define TLB_TX_RMT_LPBK_PD_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t TLB_TX_RMT_LPBK_PD_STSr_t;
#define TLB_TX_RMT_LPBK_PD_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR
#define TLB_TX_RMT_LPBK_PD_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET
#define TLB_TX_RMT_LPBK_PD_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET
#define READ_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr
#define WRITE_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr
#define MODIFY_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr
#define READLN_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITELN_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITEALL_TLB_TX_RMT_LPBK_PD_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_TX_RMT_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  CORE_PLL_PMD_CORE_MODE_STS
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd180
 * DEVAD:    1
 * DESC:     PMD_CORE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_CORE_MODE    This indicates the status of the core input bus pmd_core_mode[15:0].This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr (0x0001d180 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PMD_CORE_MODE_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_s {
	uint32_t v[1];
	uint32_t core_pll_pmd_core_mode_sts[1];
	uint32_t _core_pll_pmd_core_mode_sts;
} BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_CLR(r) (r).core_pll_pmd_core_mode_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SET(r,d) (r).core_pll_pmd_core_mode_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_GET(r) (r).core_pll_pmd_core_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET(r) (((r).core_pll_pmd_core_mode_sts[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET(r,f) (r).core_pll_pmd_core_mode_sts[0]=(((r).core_pll_pmd_core_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CORE_PLL_PMD_CORE_MODE_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr,(_r._core_pll_pmd_core_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr,(_r._core_pll_pmd_core_mode_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr,(_r._core_pll_pmd_core_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pmd_core_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pmd_core_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PMD_CORE_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pmd_core_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PMD_CORE_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr
#define CORE_PLL_PMD_CORE_MODE_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_t CORE_PLL_PMD_CORE_MODE_STSr_t;
#define CORE_PLL_PMD_CORE_MODE_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_CLR
#define CORE_PLL_PMD_CORE_MODE_STSr_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_SET
#define CORE_PLL_PMD_CORE_MODE_STSr_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_GET
#define CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET
#define CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET
#define READ_CORE_PLL_PMD_CORE_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PMD_CORE_MODE_STSr
#define WRITE_CORE_PLL_PMD_CORE_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PMD_CORE_MODE_STSr
#define MODIFY_CORE_PLL_PMD_CORE_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PMD_CORE_MODE_STSr
#define READLN_CORE_PLL_PMD_CORE_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PMD_CORE_MODE_STSr
#define WRITELN_CORE_PLL_PMD_CORE_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PMD_CORE_MODE_STSr
#define WRITEALL_CORE_PLL_PMD_CORE_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PMD_CORE_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PMD_CORE_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  CORE_PLL_TOP_USER_CTL
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd184
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_DP_S_RSTB   Active Low Core Level Datapath Soft Reset. If asserted by writingto 1'b0 will reset datapath logic of all the lanes. This soft resetis equivalent to the hard reset input pin core_dp_h_rstb.Minimum assertion time is 50 comclk cycles.
 *     AFE_S_PLL_PWRDN  Active High PLL Power Down control.Minimum assertion time is 50 comclk cycles.
 *     CORE_HW_FW_HANDSHAKE_DISABLE 1: disables the HW-FW handshake logic for the core which means there is no acknowledgement required from uC and core dp reset will be de-asserted once core reset register/pin conditions are de-asserted.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr (0x0001d184 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_TOP_USER_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_s {
	uint32_t v[1];
	uint32_t core_pll_top_user_ctl[1];
	uint32_t _core_pll_top_user_ctl;
} BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CLR(r) (r).core_pll_top_user_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_SET(r,d) (r).core_pll_top_user_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_GET(r) (r).core_pll_top_user_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET(r) ((((r).core_pll_top_user_ctl[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET(r,f) (r).core_pll_top_user_ctl[0]=(((r).core_pll_top_user_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))

/*
 * These macros can be used to access CORE_PLL_TOP_USER_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr,(_r._core_pll_top_user_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr,(_r._core_pll_top_user_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr,(_r._core_pll_top_user_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_TOP_USER_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_top_user_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_TOP_USER_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_top_user_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_TOP_USER_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_top_user_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_TOP_USER_CTLr BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr
#define CORE_PLL_TOP_USER_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_t CORE_PLL_TOP_USER_CTLr_t;
#define CORE_PLL_TOP_USER_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CLR
#define CORE_PLL_TOP_USER_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_SET
#define CORE_PLL_TOP_USER_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_GET
#define CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_GET
#define CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_HW_FW_HANDSHAKE_DISABLEf_SET
#define CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_GET
#define CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_AFE_S_PLL_PWRDNf_SET
#define CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_GET
#define CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr_CORE_DP_S_RSTBf_SET
#define READ_CORE_PLL_TOP_USER_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_TOP_USER_CTLr
#define WRITE_CORE_PLL_TOP_USER_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_TOP_USER_CTLr
#define MODIFY_CORE_PLL_TOP_USER_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_TOP_USER_CTLr
#define READLN_CORE_PLL_TOP_USER_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_TOP_USER_CTLr
#define WRITELN_CORE_PLL_TOP_USER_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_TOP_USER_CTLr
#define WRITEALL_CORE_PLL_TOP_USER_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_TOP_USER_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_TOP_USER_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  CORE_PLL_UC_ACK_CORE_CTL
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd185
 * DEVAD:    1
 * DESC:     UC_ACK_CORE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_CORE_CFG_DONE uC will write this to 1 to indicate it's configuration of the core is complete. Writing to 1'b1 willshould release internal hold on core_dp_reset, only if core_dp_reset_state is 3'b001.
 *     UC_ACK_CORE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "core_dp_reset_coccured".
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr (0x0001d185 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_UC_ACK_CORE_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_s {
	uint32_t v[1];
	uint32_t core_pll_uc_ack_core_ctl[1];
	uint32_t _core_pll_uc_ack_core_ctl;
} BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_CLR(r) (r).core_pll_uc_ack_core_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SET(r,d) (r).core_pll_uc_ack_core_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_GET(r) (r).core_pll_uc_ack_core_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET(r) ((((r).core_pll_uc_ack_core_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET(r,f) (r).core_pll_uc_ack_core_ctl[0]=(((r).core_pll_uc_ack_core_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET(r) (((r).core_pll_uc_ack_core_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET(r,f) (r).core_pll_uc_ack_core_ctl[0]=(((r).core_pll_uc_ack_core_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CORE_PLL_UC_ACK_CORE_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr,(_r._core_pll_uc_ack_core_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr,(_r._core_pll_uc_ack_core_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr,(_r._core_pll_uc_ack_core_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_uc_ack_core_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_uc_ack_core_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_UC_ACK_CORE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_uc_ack_core_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_UC_ACK_CORE_CTLr BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr
#define CORE_PLL_UC_ACK_CORE_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_t CORE_PLL_UC_ACK_CORE_CTLr_t;
#define CORE_PLL_UC_ACK_CORE_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_CLR
#define CORE_PLL_UC_ACK_CORE_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_SET
#define CORE_PLL_UC_ACK_CORE_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET
#define CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET
#define READ_CORE_PLL_UC_ACK_CORE_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_UC_ACK_CORE_CTLr
#define WRITE_CORE_PLL_UC_ACK_CORE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_UC_ACK_CORE_CTLr
#define MODIFY_CORE_PLL_UC_ACK_CORE_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_UC_ACK_CORE_CTLr
#define READLN_CORE_PLL_UC_ACK_CORE_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_UC_ACK_CORE_CTLr
#define WRITELN_CORE_PLL_UC_ACK_CORE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_UC_ACK_CORE_CTLr
#define WRITEALL_CORE_PLL_UC_ACK_CORE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_UC_ACK_CORE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_UC_ACK_CORE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  CORE_PLL_PLL_DP_RST_ST_STS
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd188
 * DEVAD:    1
 * DESC:     PLL_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     CORE_DP_RESET_STATE Bit 2: core_dp_reset_active   : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls.Bit 1: core_dp_reset_occurred : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: core_dp_reset_held     : Set to 1'b1 whenenver core_dp_reset is internally held. Cleared to 1'b0, only if core_dp_reset_state==001 and uc_ack_core_cfg_done == 1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr (0x0001d188 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PLL_DP_RST_ST_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t core_pll_pll_dp_rst_st_sts[1];
	uint32_t _core_pll_pll_dp_rst_st_sts;
} BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CLR(r) (r).core_pll_pll_dp_rst_st_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SET(r,d) (r).core_pll_pll_dp_rst_st_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_GET(r) (r).core_pll_pll_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET(r) (((r).core_pll_pll_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET(r,f) (r).core_pll_pll_dp_rst_st_sts[0]=(((r).core_pll_pll_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access CORE_PLL_PLL_DP_RST_ST_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr,(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr,(_r._core_pll_pll_dp_rst_st_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr,(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PLL_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pll_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PLL_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr
#define CORE_PLL_PLL_DP_RST_ST_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_t CORE_PLL_PLL_DP_RST_ST_STSr_t;
#define CORE_PLL_PLL_DP_RST_ST_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CLR
#define CORE_PLL_PLL_DP_RST_ST_STSr_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_SET
#define CORE_PLL_PLL_DP_RST_ST_STSr_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_GET
#define CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET
#define CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET
#define READ_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PLL_DP_RST_ST_STSr
#define WRITE_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PLL_DP_RST_ST_STSr
#define MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PLL_DP_RST_ST_STSr
#define READLN_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PLL_DP_RST_ST_STSr
#define WRITELN_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PLL_DP_RST_ST_STSr
#define WRITEALL_CORE_PLL_PLL_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PLL_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  CORE_PLL_PLL_CFG_FWAPI_DATA0
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd18d
 * DEVAD:    1
 * DESC:     PLL_CFG_FWAPI_DATA0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_CFG_FWAPI_DATA0 PLL configuration firmware/API data 0This is a scratch register used by the firmware and API code to store and/or exchangePLL configuration information
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r (0x0001d18d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PLL_CFG_FWAPI_DATA0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_s {
	uint32_t v[1];
	uint32_t core_pll_pll_cfg_fwapi_data0[1];
	uint32_t _core_pll_pll_cfg_fwapi_data0;
} BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_CLR(r) (r).core_pll_pll_cfg_fwapi_data0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SET(r,d) (r).core_pll_pll_cfg_fwapi_data0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_GET(r) (r).core_pll_pll_cfg_fwapi_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_GET(r) (((r).core_pll_pll_cfg_fwapi_data0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_SET(r,f) (r).core_pll_pll_cfg_fwapi_data0[0]=(((r).core_pll_pll_cfg_fwapi_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CORE_PLL_PLL_CFG_FWAPI_DATA0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r,(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r,(_r._core_pll_pll_cfg_fwapi_data0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r,(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pll_cfg_fwapi_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_SIZE BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_t CORE_PLL_PLL_CFG_FWAPI_DATA0r_t;
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_CLR BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_CLR
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_SET
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r_PLL_CFG_FWAPI_DATA0f_SET
#define READ_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define READLN_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA0r
#define WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  CORE_PLL_PLL_CFG_FWAPI_DATA1
 * BLOCKS:   CORE_PLL_COM
 * REGADDR:  0xd18e
 * DEVAD:    1
 * DESC:     PLL_CFG_FWAPI_DATA1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_CFG_FWAPI_DATA1 PLL configuration firmware/API data 1This is a scratch register used by the firmware and API code to store and/or exchangePLL configuration information
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r (0x0001d18e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program CORE_PLL_PLL_CFG_FWAPI_DATA1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_s {
	uint32_t v[1];
	uint32_t core_pll_pll_cfg_fwapi_data1[1];
	uint32_t _core_pll_pll_cfg_fwapi_data1;
} BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_CLR(r) (r).core_pll_pll_cfg_fwapi_data1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SET(r,d) (r).core_pll_pll_cfg_fwapi_data1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_GET(r) (r).core_pll_pll_cfg_fwapi_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_GET(r) (((r).core_pll_pll_cfg_fwapi_data1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_SET(r,f) (r).core_pll_pll_cfg_fwapi_data1[0]=(((r).core_pll_pll_cfg_fwapi_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CORE_PLL_PLL_CFG_FWAPI_DATA1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r,(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r,(_r._core_pll_pll_cfg_fwapi_data1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r,(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._core_pll_pll_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._core_pll_pll_cfg_fwapi_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_SIZE BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_t CORE_PLL_PLL_CFG_FWAPI_DATA1r_t;
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_CLR BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_CLR
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_SET
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_GET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_GET
#define CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_SET BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r_PLL_CFG_FWAPI_DATA1f_SET
#define READ_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_READ_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITE_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define READLN_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_READLN_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_CORE_PLL_PLL_CFG_FWAPI_DATA1r
#define WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_CORE_PLL_PLL_CFG_FWAPI_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_CORE_PLL_PLL_CFG_FWAPI_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR0
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd190
 * DEVAD:    1
 * DESC:     LANE_ADDR_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_0   Determines the logical address associated with the PMD RX lane with physical index  "_0" at the PCS interface.rx_lane_addr_0 is the logical address of the lane with pins at the PCS interface labeled "_0".
 *     TX_LANE_ADDR_0   Determines the logical address associated with the PMD TX lane with physical index  "_0" at the PCS interface.tx_lane_addr_0 is the logical address of the TX lane with pins at the PCS interface labeled "_0".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r (0x0001d190 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_s {
	uint32_t v[1];
	uint32_t ln_addr0[1];
	uint32_t _ln_addr0;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_CLR(r) (r).ln_addr0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_SET(r,d) (r).ln_addr0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_GET(r) (r).ln_addr0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_GET(r) ((((r).ln_addr0[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_GET(r) (((r).ln_addr0[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_SET(r,f) (r).ln_addr0[0]=(((r).ln_addr0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r,(_r._ln_addr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r,(_r._ln_addr0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r,(_r._ln_addr0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR0r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r
#define LN_ADDR0r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_t LN_ADDR0r_t;
#define LN_ADDR0r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_CLR
#define LN_ADDR0r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_SET
#define LN_ADDR0r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_GET
#define LN_ADDR0r_TX_LANE_ADDR_0f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_TX_LANE_ADDR_0f_SET
#define LN_ADDR0r_RX_LANE_ADDR_0f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_GET
#define LN_ADDR0r_RX_LANE_ADDR_0f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r_RX_LANE_ADDR_0f_SET
#define READ_LN_ADDR0r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR0r
#define WRITE_LN_ADDR0r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR0r
#define MODIFY_LN_ADDR0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR0r
#define READLN_LN_ADDR0r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR0r
#define WRITELN_LN_ADDR0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR0r
#define WRITEALL_LN_ADDR0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR1
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd191
 * DEVAD:    1
 * DESC:     LANE_ADDR_1
 * RESETVAL: 0x101 (257)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_1   Determines the logical address associated with the PMD RX lane with physical index  "_1" at the PCS interface.rx_lane_addr_1 is the logical address of the lane with pins at the PCS interface labeled "_1".
 *     TX_LANE_ADDR_1   Determines the logical address associated with the PMD TX lane with physical index  "_1" at the PCS interface.tx_lane_addr_1 is the logical address of the TX lane with pins at the PCS interface labeled "_1".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r (0x0001d191 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_s {
	uint32_t v[1];
	uint32_t ln_addr1[1];
	uint32_t _ln_addr1;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_CLR(r) (r).ln_addr1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_SET(r,d) (r).ln_addr1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_GET(r) (r).ln_addr1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_GET(r) ((((r).ln_addr1[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_GET(r) (((r).ln_addr1[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_SET(r,f) (r).ln_addr1[0]=(((r).ln_addr1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r,(_r._ln_addr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r,(_r._ln_addr1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r,(_r._ln_addr1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR1r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r
#define LN_ADDR1r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_t LN_ADDR1r_t;
#define LN_ADDR1r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_CLR
#define LN_ADDR1r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_SET
#define LN_ADDR1r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_GET
#define LN_ADDR1r_TX_LANE_ADDR_1f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_TX_LANE_ADDR_1f_SET
#define LN_ADDR1r_RX_LANE_ADDR_1f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_GET
#define LN_ADDR1r_RX_LANE_ADDR_1f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r_RX_LANE_ADDR_1f_SET
#define READ_LN_ADDR1r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR1r
#define WRITE_LN_ADDR1r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR1r
#define MODIFY_LN_ADDR1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR1r
#define READLN_LN_ADDR1r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR1r
#define WRITELN_LN_ADDR1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR1r
#define WRITEALL_LN_ADDR1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR2
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd192
 * DEVAD:    1
 * DESC:     LANE_ADDR_2
 * RESETVAL: 0x202 (514)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_2   Determines the logical address associated with the PMD RX lane with physical index  "_2" at the PCS interface.rx_lane_addr_2 is the logical address of the lane with pins at the PCS interface labeled "_2".
 *     TX_LANE_ADDR_2   Determines the logical address associated with the PMD TX lane with physical index  "_2" at the PCS interface.tx_lane_addr_2 is the logical address of the TX lane with pins at the PCS interface labeled "_2".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r (0x0001d192 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_s {
	uint32_t v[1];
	uint32_t ln_addr2[1];
	uint32_t _ln_addr2;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_CLR(r) (r).ln_addr2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_SET(r,d) (r).ln_addr2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_GET(r) (r).ln_addr2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_GET(r) ((((r).ln_addr2[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_GET(r) (((r).ln_addr2[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_SET(r,f) (r).ln_addr2[0]=(((r).ln_addr2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r,(_r._ln_addr2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r,(_r._ln_addr2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r,(_r._ln_addr2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR2r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r
#define LN_ADDR2r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_t LN_ADDR2r_t;
#define LN_ADDR2r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_CLR
#define LN_ADDR2r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_SET
#define LN_ADDR2r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_GET
#define LN_ADDR2r_TX_LANE_ADDR_2f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_TX_LANE_ADDR_2f_SET
#define LN_ADDR2r_RX_LANE_ADDR_2f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_GET
#define LN_ADDR2r_RX_LANE_ADDR_2f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r_RX_LANE_ADDR_2f_SET
#define READ_LN_ADDR2r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR2r
#define WRITE_LN_ADDR2r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR2r
#define MODIFY_LN_ADDR2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR2r
#define READLN_LN_ADDR2r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR2r
#define WRITELN_LN_ADDR2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR2r
#define WRITEALL_LN_ADDR2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR3
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd193
 * DEVAD:    1
 * DESC:     LANE_ADDR_3
 * RESETVAL: 0x303 (771)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_3   Determines the logical address associated with the PMD RX lane with physical index  "_3" at the PCS interface.rx_lane_addr_3 is the logical address of the lane with pins at the PCS interface labeled "_3".
 *     TX_LANE_ADDR_3   Determines the logical address associated with the PMD TX lane with physical index  "_3" at the PCS interface.tx_lane_addr_3 is the logical address of the TX lane with pins at the PCS interface labeled "_3".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r (0x0001d193 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_s {
	uint32_t v[1];
	uint32_t ln_addr3[1];
	uint32_t _ln_addr3;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_CLR(r) (r).ln_addr3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_SET(r,d) (r).ln_addr3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_GET(r) (r).ln_addr3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_GET(r) ((((r).ln_addr3[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_GET(r) (((r).ln_addr3[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_SET(r,f) (r).ln_addr3[0]=(((r).ln_addr3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r,(_r._ln_addr3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r,(_r._ln_addr3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r,(_r._ln_addr3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR3r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r
#define LN_ADDR3r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_t LN_ADDR3r_t;
#define LN_ADDR3r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_CLR
#define LN_ADDR3r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_SET
#define LN_ADDR3r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_GET
#define LN_ADDR3r_TX_LANE_ADDR_3f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_TX_LANE_ADDR_3f_SET
#define LN_ADDR3r_RX_LANE_ADDR_3f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_GET
#define LN_ADDR3r_RX_LANE_ADDR_3f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r_RX_LANE_ADDR_3f_SET
#define READ_LN_ADDR3r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR3r
#define WRITE_LN_ADDR3r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR3r
#define MODIFY_LN_ADDR3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR3r
#define READLN_LN_ADDR3r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR3r
#define WRITELN_LN_ADDR3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR3r
#define WRITEALL_LN_ADDR3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR4
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd194
 * DEVAD:    1
 * DESC:     LANE_ADDR_4
 * RESETVAL: 0x404 (1028)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_4   Determines the logical address associated with the PMD RX lane with physical index  "_4" at the PCS interface.rx_lane_addr_4 is the logical address of the lane with pins at the PCS interface labeled "_4".
 *     TX_LANE_ADDR_4   Determines the logical address associated with the PMD TX lane with physical index  "_4" at the PCS interface.tx_lane_addr_4 is the logical address of the TX lane with pins at the PCS interface labeled "_4".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r (0x0001d194 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_s {
	uint32_t v[1];
	uint32_t ln_addr4[1];
	uint32_t _ln_addr4;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_CLR(r) (r).ln_addr4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_SET(r,d) (r).ln_addr4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_GET(r) (r).ln_addr4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_GET(r) ((((r).ln_addr4[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_SET(r,f) (r).ln_addr4[0]=(((r).ln_addr4[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_GET(r) (((r).ln_addr4[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_SET(r,f) (r).ln_addr4[0]=(((r).ln_addr4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r,(_r._ln_addr4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r,(_r._ln_addr4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r,(_r._ln_addr4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR4r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r
#define LN_ADDR4r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_t LN_ADDR4r_t;
#define LN_ADDR4r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_CLR
#define LN_ADDR4r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_SET
#define LN_ADDR4r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_GET
#define LN_ADDR4r_TX_LANE_ADDR_4f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_GET
#define LN_ADDR4r_TX_LANE_ADDR_4f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_TX_LANE_ADDR_4f_SET
#define LN_ADDR4r_RX_LANE_ADDR_4f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_GET
#define LN_ADDR4r_RX_LANE_ADDR_4f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r_RX_LANE_ADDR_4f_SET
#define READ_LN_ADDR4r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR4r
#define WRITE_LN_ADDR4r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR4r
#define MODIFY_LN_ADDR4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR4r
#define READLN_LN_ADDR4r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR4r
#define WRITELN_LN_ADDR4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR4r
#define WRITEALL_LN_ADDR4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR5
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd195
 * DEVAD:    1
 * DESC:     LANE_ADDR_5
 * RESETVAL: 0x505 (1285)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_5   Determines the logical address associated with the PMD RX lane with physical index  "_5" at the PCS interface.rx_lane_addr_5 is the logical address of the lane with pins at the PCS interface labeled "_5".
 *     TX_LANE_ADDR_5   Determines the logical address associated with the PMD TX lane with physical index  "_5" at the PCS interface.tx_lane_addr_5 is the logical address of the TX lane with pins at the PCS interface labeled "_5".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r (0x0001d195 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_s {
	uint32_t v[1];
	uint32_t ln_addr5[1];
	uint32_t _ln_addr5;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_CLR(r) (r).ln_addr5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_SET(r,d) (r).ln_addr5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_GET(r) (r).ln_addr5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_GET(r) ((((r).ln_addr5[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_SET(r,f) (r).ln_addr5[0]=(((r).ln_addr5[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_GET(r) (((r).ln_addr5[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_SET(r,f) (r).ln_addr5[0]=(((r).ln_addr5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r,(_r._ln_addr5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r,(_r._ln_addr5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r,(_r._ln_addr5))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR5r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r
#define LN_ADDR5r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_t LN_ADDR5r_t;
#define LN_ADDR5r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_CLR
#define LN_ADDR5r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_SET
#define LN_ADDR5r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_GET
#define LN_ADDR5r_TX_LANE_ADDR_5f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_GET
#define LN_ADDR5r_TX_LANE_ADDR_5f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_TX_LANE_ADDR_5f_SET
#define LN_ADDR5r_RX_LANE_ADDR_5f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_GET
#define LN_ADDR5r_RX_LANE_ADDR_5f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r_RX_LANE_ADDR_5f_SET
#define READ_LN_ADDR5r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR5r
#define WRITE_LN_ADDR5r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR5r
#define MODIFY_LN_ADDR5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR5r
#define READLN_LN_ADDR5r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR5r
#define WRITELN_LN_ADDR5r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR5r
#define WRITEALL_LN_ADDR5r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR6
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd196
 * DEVAD:    1
 * DESC:     LANE_ADDR_6
 * RESETVAL: 0x606 (1542)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_6   Determines the logical address associated with the PMD RX lane with physical index  "_6" at the PCS interface.rx_lane_addr_6 is the logical address of the lane with pins at the PCS interface labeled "_6".
 *     TX_LANE_ADDR_6   Determines the logical address associated with the PMD TX lane with physical index  "_6" at the PCS interface.tx_lane_addr_6 is the logical address of the TX lane with pins at the PCS interface labeled "_6".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r (0x0001d196 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR6.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_s {
	uint32_t v[1];
	uint32_t ln_addr6[1];
	uint32_t _ln_addr6;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_CLR(r) (r).ln_addr6[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_SET(r,d) (r).ln_addr6[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_GET(r) (r).ln_addr6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_GET(r) ((((r).ln_addr6[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_SET(r,f) (r).ln_addr6[0]=(((r).ln_addr6[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_GET(r) (((r).ln_addr6[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_SET(r,f) (r).ln_addr6[0]=(((r).ln_addr6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR6.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r,(_r._ln_addr6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r,(_r._ln_addr6)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r,(_r._ln_addr6))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR6r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r
#define LN_ADDR6r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_t LN_ADDR6r_t;
#define LN_ADDR6r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_CLR
#define LN_ADDR6r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_SET
#define LN_ADDR6r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_GET
#define LN_ADDR6r_TX_LANE_ADDR_6f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_GET
#define LN_ADDR6r_TX_LANE_ADDR_6f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_TX_LANE_ADDR_6f_SET
#define LN_ADDR6r_RX_LANE_ADDR_6f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_GET
#define LN_ADDR6r_RX_LANE_ADDR_6f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r_RX_LANE_ADDR_6f_SET
#define READ_LN_ADDR6r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR6r
#define WRITE_LN_ADDR6r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR6r
#define MODIFY_LN_ADDR6r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR6r
#define READLN_LN_ADDR6r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR6r
#define WRITELN_LN_ADDR6r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR6r
#define WRITEALL_LN_ADDR6r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_ADDR7
 * BLOCKS:   DIG_COM_B
 * REGADDR:  0xd197
 * DEVAD:    1
 * DESC:     LANE_ADDR_7
 * RESETVAL: 0x707 (1799)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_ADDR_7   Determines the logical address associated with the PMD RX lane with physical index  "_7" at the PCS interface.rx_lane_addr_7 is the logical address of the lane with pins at the PCS interface labeled "_7".
 *     TX_LANE_ADDR_7   Determines the logical address associated with the PMD TX lane with physical index  "_7" at the PCS interface.tx_lane_addr_7 is the logical address of the TX lane with pins at the PCS interface labeled "_7".
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r (0x0001d197 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_SIZE 4

/*
 * This structure should be used to declare and program LN_ADDR7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_s {
	uint32_t v[1];
	uint32_t ln_addr7[1];
	uint32_t _ln_addr7;
} BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_CLR(r) (r).ln_addr7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_SET(r,d) (r).ln_addr7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_GET(r) (r).ln_addr7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_GET(r) ((((r).ln_addr7[0]) >> 8) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_SET(r,f) (r).ln_addr7[0]=(((r).ln_addr7[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_GET(r) (((r).ln_addr7[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_SET(r,f) (r).ln_addr7[0]=(((r).ln_addr7[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access LN_ADDR7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r,(_r._ln_addr7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r,(_r._ln_addr7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r,(_r._ln_addr7))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_addr7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_addr7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_ADDR7r BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r
#define LN_ADDR7r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_t LN_ADDR7r_t;
#define LN_ADDR7r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_CLR
#define LN_ADDR7r_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_SET
#define LN_ADDR7r_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_GET
#define LN_ADDR7r_TX_LANE_ADDR_7f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_GET
#define LN_ADDR7r_TX_LANE_ADDR_7f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_TX_LANE_ADDR_7f_SET
#define LN_ADDR7r_RX_LANE_ADDR_7f_GET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_GET
#define LN_ADDR7r_RX_LANE_ADDR_7f_SET BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r_RX_LANE_ADDR_7f_SET
#define READ_LN_ADDR7r BCMI_TSCBH_FLEXE_XGXS_READ_LN_ADDR7r
#define WRITE_LN_ADDR7r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_ADDR7r
#define MODIFY_LN_ADDR7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_ADDR7r
#define READLN_LN_ADDR7r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_ADDR7r
#define WRITELN_LN_ADDR7r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_ADDR7r
#define WRITEALL_LN_ADDR7r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_ADDR7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_ADDR7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a1
 * DEVAD:    1
 * DESC:     RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_PWRDN    Active High Power Down control for RX Lane.If asserted by writing to 1'b1 will power down the RX Lane.
 *     AFE_SIGDET_PWRDN Power Down for Signal Detect. 1=power down
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rx_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET(r) ((((r).rx_ln_clk_rst_n_pwrdwn_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET(r,f) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET(r) (((r).rx_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET(r,f) (r).rx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_t RX_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET
#define RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET
#define READ_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_LN_AFE_RST_PWRDWN_CTL_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a2
 * DEVAD:    1
 * DESC:     RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_RX_PWRDN_FRC AFE RX Lane powerdown force.
 *     AFE_RX_PWRDN_FRC_VAL AFE RX Lane powerdown force value.
 *     AFE_RX_RESET_FRC AFE RX Lane reset force.
 *     AFE_RX_RESET_FRC_VAL AFE RX Lane reset force value.
 *     AFE_RX_RCLK20_PWRDN_FRC AFE RX Lane rx_rclk20_pwrdwn force.
 *     AFE_RX_RCLK20_PWRDN_FRC_VAL AFE RX Lane rx_rclk20_pwrdwn force value.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr (0x0001d1a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_afe_rst_pwrdwn_ctl_ctl[1];
	uint32_t _rx_ln_afe_rst_pwrdwn_ctl_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR(r) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET(r,d) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET(r) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET(r) ((((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET(r) (((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET(r,f) (r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).rx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_afe_rst_pwrdwn_ctl_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t RX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_RESET_FRCf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRC_VALf_SET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_GET
#define RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_RX_PWRDN_FRCf_SET
#define READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_AFE_RST_PWRDWN_CTL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_LN_AFE_RST_PWRDWN_CTL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a3
 * DEVAD:    1
 * DESC:     RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_RX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_rx_h_pwrdn input pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rx_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET(r) (((r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET(r,f) (r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rx_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET
#define RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET
#define READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_LN_DBG_RST_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a4
 * DEVAD:    1
 * DESC:     RX_LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_RSTB     Active Low Lane Soft Reset for RX datapath and registers. If asserted by writing to 1'b0 will reset the RX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_RX_DP_S_RSTB  Active Low Lane Soft Reset for RX datapath. If asserted by writing to 1'b0 will reset the RX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     SIGDET_DP_RSTB_EN If asserted by writing to 1'b1 then lane datapath reset will also reset the sigdet filetr logic alomg with lane register reset.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr (0x0001d1a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_LN_DBG_RST_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t rx_ln_dbg_rst_ctl[1];
	uint32_t _rx_ln_dbg_rst_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_CLR(r) (r).rx_ln_dbg_rst_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SET(r,d) (r).rx_ln_dbg_rst_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_GET(r) (r).rx_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET(r) ((((r).rx_ln_dbg_rst_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET(r) ((((r).rx_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET(r) (((r).rx_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET(r,f) (r).rx_ln_dbg_rst_ctl[0]=(((r).rx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_LN_DBG_RST_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr,(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_ln_dbg_rst_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr
#define RX_LN_DBG_RST_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_t RX_LN_DBG_RST_CTLr_t;
#define RX_LN_DBG_RST_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_CLR
#define RX_LN_DBG_RST_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SET
#define RX_LN_DBG_RST_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_GET
#define RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET
#define RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET
#define RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET
#define RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET
#define RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET
#define RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET
#define READ_RX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_LN_DBG_RST_CTLr
#define WRITE_RX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_LN_DBG_RST_CTLr
#define MODIFY_RX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_LN_DBG_RST_CTLr
#define READLN_RX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_LN_DBG_RST_CTLr
#define WRITELN_RX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_LN_DBG_RST_CTLr
#define WRITEALL_RX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_LN_DBG_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_CLK_N_RST_DBG_CTL
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a7
 * DEVAD:    1
 * DESC:     RX_CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_CLKGATE_FRC_ON RX Active High Lane clock gator enable. If 1'1b1 then rx lane clock will be gated off. It does not affect the rclk goingto RMIC block so rx lane based registers can still be readable but not writable.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while rx_s_clkgate_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_SEL Mux control for selection of comclk for RX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_sel is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_FRC_ON Mux control for selection of comclk for RX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     PMD_RX_CLK_VLD_FRC pmd_rx_clk_vld core output pin force.
 *     PMD_RX_CLK_VLD_FRC_VAL pmd_rx_clk_vld core output pin force value.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr (0x0001d1a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_CLK_N_RST_DBG_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t rx_clk_n_rst_dbg_ctl[1];
	uint32_t _rx_clk_n_rst_dbg_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_CLR(r) (r).rx_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_SET(r,d) (r).rx_clk_n_rst_dbg_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_GET(r) (r).rx_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET(r) ((((r).rx_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET(r) (((r).rx_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET(r,f) (r).rx_clk_n_rst_dbg_ctl[0]=(((r).rx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_CLK_N_RST_DBG_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr,(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_clk_n_rst_dbg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr
#define RX_CLK_N_RST_DBG_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_t RX_CLK_N_RST_DBG_CTLr_t;
#define RX_CLK_N_RST_DBG_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_CLR
#define RX_CLK_N_RST_DBG_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_SET
#define RX_CLK_N_RST_DBG_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET
#define RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET
#define RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET
#define READ_RX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RX_CLK_N_RST_DBG_CTLr
#define WRITE_RX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_CLK_N_RST_DBG_CTLr
#define MODIFY_RX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_CLK_N_RST_DBG_CTLr
#define READLN_RX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_CLK_N_RST_DBG_CTLr
#define WRITELN_RX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_CLK_N_RST_DBG_CTLr
#define WRITEALL_RX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_CLK_N_RST_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RX_PMD_LN_MODE_STS
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1a8
 * DEVAD:    1
 * DESC:     RX_PMD_LANE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_RX_LANE_MODE This indicates the status of the core input pin pmd_rx_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr (0x0001d1a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_PMD_LN_MODE_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t rx_pmd_ln_mode_sts[1];
	uint32_t _rx_pmd_ln_mode_sts;
} BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_CLR(r) (r).rx_pmd_ln_mode_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_SET(r,d) (r).rx_pmd_ln_mode_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_GET(r) (r).rx_pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_GET(r) (((r).rx_pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_SET(r,f) (r).rx_pmd_ln_mode_sts[0]=(((r).rx_pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_PMD_LN_MODE_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr,(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_pmd_ln_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr
#define RX_PMD_LN_MODE_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_t RX_PMD_LN_MODE_STSr_t;
#define RX_PMD_LN_MODE_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_CLR
#define RX_PMD_LN_MODE_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_SET
#define RX_PMD_LN_MODE_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_GET
#define RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_GET
#define RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr_PMD_RX_LANE_MODEf_SET
#define READ_RX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RX_PMD_LN_MODE_STSr
#define WRITE_RX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RX_PMD_LN_MODE_STSr
#define MODIFY_RX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RX_PMD_LN_MODE_STSr
#define READLN_RX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RX_PMD_LN_MODE_STSr
#define WRITELN_RX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RX_PMD_LN_MODE_STSr
#define WRITEALL_RX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RX_PMD_LN_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RX_PMD_LN_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_CFG_FWAPI_DATA0
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ad
 * DEVAD:    1
 * DESC:     LANE_CFG_FWAPI_DATA0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_CFG_FWAPI_DATA0 Lane configuration firmware/API data 0This is a scratch register used by the firmware and API code to store and/or exchangelane configuration information
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r (0x0001d1ad | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program LN_CFG_FWAPI_DATA0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_s {
	uint32_t v[1];
	uint32_t ln_cfg_fwapi_data0[1];
	uint32_t _ln_cfg_fwapi_data0;
} BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_CLR(r) (r).ln_cfg_fwapi_data0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_SET(r,d) (r).ln_cfg_fwapi_data0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_GET(r) (r).ln_cfg_fwapi_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_GET(r) (((r).ln_cfg_fwapi_data0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_SET(r,f) (r).ln_cfg_fwapi_data0[0]=(((r).ln_cfg_fwapi_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LN_CFG_FWAPI_DATA0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r,(_r._ln_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r,(_r._ln_cfg_fwapi_data0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r,(_r._ln_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_cfg_fwapi_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r
#define LN_CFG_FWAPI_DATA0r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_t LN_CFG_FWAPI_DATA0r_t;
#define LN_CFG_FWAPI_DATA0r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_CLR
#define LN_CFG_FWAPI_DATA0r_SET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_SET
#define LN_CFG_FWAPI_DATA0r_GET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_GET
#define LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_GET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_GET
#define LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_SET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r_LANE_CFG_FWAPI_DATA0f_SET
#define READ_LN_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_READ_LN_CFG_FWAPI_DATA0r
#define WRITE_LN_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_CFG_FWAPI_DATA0r
#define MODIFY_LN_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_CFG_FWAPI_DATA0r
#define READLN_LN_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_CFG_FWAPI_DATA0r
#define WRITELN_LN_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_CFG_FWAPI_DATA0r
#define WRITEALL_LN_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_CFG_FWAPI_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  LN_CFG_FWAPI_DATA1
 * BLOCKS:   RX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ae
 * DEVAD:    1
 * DESC:     LANE_CFG_FWAPI_DATA1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_CFG_FWAPI_DATA1 Lane configuration firmware/API data 1This is a scratch register used by the firmware and API code to store and/or exchangelane configuration information
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r (0x0001d1ae | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program LN_CFG_FWAPI_DATA1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_s {
	uint32_t v[1];
	uint32_t ln_cfg_fwapi_data1[1];
	uint32_t _ln_cfg_fwapi_data1;
} BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_CLR(r) (r).ln_cfg_fwapi_data1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_SET(r,d) (r).ln_cfg_fwapi_data1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_GET(r) (r).ln_cfg_fwapi_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_GET(r) (((r).ln_cfg_fwapi_data1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_SET(r,f) (r).ln_cfg_fwapi_data1[0]=(((r).ln_cfg_fwapi_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access LN_CFG_FWAPI_DATA1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r,(_r._ln_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r,(_r._ln_cfg_fwapi_data1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r,(_r._ln_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_LN_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_CFG_FWAPI_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ln_cfg_fwapi_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_CFG_FWAPI_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ln_cfg_fwapi_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define LN_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r
#define LN_CFG_FWAPI_DATA1r_SIZE BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_t LN_CFG_FWAPI_DATA1r_t;
#define LN_CFG_FWAPI_DATA1r_CLR BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_CLR
#define LN_CFG_FWAPI_DATA1r_SET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_SET
#define LN_CFG_FWAPI_DATA1r_GET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_GET
#define LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_GET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_GET
#define LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_SET BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r_LANE_CFG_FWAPI_DATA1f_SET
#define READ_LN_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_READ_LN_CFG_FWAPI_DATA1r
#define WRITE_LN_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITE_LN_CFG_FWAPI_DATA1r
#define MODIFY_LN_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_LN_CFG_FWAPI_DATA1r
#define READLN_LN_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_READLN_LN_CFG_FWAPI_DATA1r
#define WRITELN_LN_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_LN_CFG_FWAPI_DATA1r
#define WRITEALL_LN_CFG_FWAPI_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_LN_CFG_FWAPI_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_LN_CFG_FWAPI_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b1
 * DEVAD:    1
 * DESC:     TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_PWRDN    Active High Power Down control for TX Lane.If asserted by writing to 1'b1 will power down the TX Lane.
 *     AFE_TX_RESET_DEASSERT AFE TX Lane reset control. This register will be reset upon POR reg/pin or lane reset reg/pin. Lower priority than the afe_tx_reset_frc/frc_val option.1 - AFE TX Lane tx_reset pin will be forcefully de-asserted irrespective of core/lane datapath pin/reg resets asserted.This bit must be set to 1'b1 for TX_Disable all 1s/0s mode to allow TX AFE to transmit the all 1s/0s data.0 - AFE TX Lane tx_reset pin will be asserted if core/lane pin/reg resets are asserted.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _tx_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET(r) ((((r).tx_ln_clk_rst_n_pwrdwn_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET(r,f) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).tx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET(r) (((r).tx_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET(r,f) (r).tx_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).tx_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_t TX_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_AFE_TX_RESET_DEASSERTf_SET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET
#define TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET
#define READ_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_LN_AFE_RST_PWRDWN_CTL_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b2
 * DEVAD:    1
 * DESC:     TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_TX_PWRDN_FRC AFE TX Lane powerdown force.
 *     AFE_TX_PWRDN_FRC_VAL AFE TX Lane powerdown force value.
 *     AFE_TX_RESET_FRC AFE TX Lane reset force.
 *     AFE_TX_RESET_FRC_VAL AFE TX Lane reset force value.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr (0x0001d1b2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_afe_rst_pwrdwn_ctl_ctl[1];
	uint32_t _tx_ln_afe_rst_pwrdwn_ctl_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR(r) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET(r,d) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET(r) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET(r) ((((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET(r) (((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET(r,f) (r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0]=(((r).tx_ln_afe_rst_pwrdwn_ctl_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_AFE_RST_PWRDWN_CTL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_afe_rst_pwrdwn_ctl_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t TX_LN_AFE_RST_PWRDWN_CTL_CTLr_t;
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_CLR
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRC_VALf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_RESET_FRCf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRC_VALf_SET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_GET
#define TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr_AFE_TX_PWRDN_FRCf_SET
#define READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_AFE_RST_PWRDWN_CTL_CTLr
#define WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_AFE_RST_PWRDWN_CTL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_LN_AFE_RST_PWRDWN_CTL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b3
 * DEVAD:    1
 * DESC:     TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_TX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_tx_h_pwrdn input pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _tx_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET(r) (((r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET(r,f) (r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).tx_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET
#define TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET
#define READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_LN_DBG_RST_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b4
 * DEVAD:    1
 * DESC:     TX_LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_RSTB     Active Low Lane Soft Reset for TX datapath and registers. If asserted by writing to 1'b0 will reset the TX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_TX_DP_S_RSTB  Active Low Lane Soft Reset for TX datapath. If asserted by writing to 1'b0 will reset the TX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr (0x0001d1b4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_LN_DBG_RST_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t tx_ln_dbg_rst_ctl[1];
	uint32_t _tx_ln_dbg_rst_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_CLR(r) (r).tx_ln_dbg_rst_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_SET(r,d) (r).tx_ln_dbg_rst_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_GET(r) (r).tx_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET(r) ((((r).tx_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET(r,f) (r).tx_ln_dbg_rst_ctl[0]=(((r).tx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET(r) (((r).tx_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET(r,f) (r).tx_ln_dbg_rst_ctl[0]=(((r).tx_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_LN_DBG_RST_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr,(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ln_dbg_rst_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_DBG_RST_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ln_dbg_rst_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr
#define TX_LN_DBG_RST_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_t TX_LN_DBG_RST_CTLr_t;
#define TX_LN_DBG_RST_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_CLR
#define TX_LN_DBG_RST_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_SET
#define TX_LN_DBG_RST_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET
#define TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET
#define TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET
#define READ_TX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_LN_DBG_RST_CTLr
#define WRITE_TX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_LN_DBG_RST_CTLr
#define MODIFY_TX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_LN_DBG_RST_CTLr
#define READLN_TX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_LN_DBG_RST_CTLr
#define WRITELN_TX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_LN_DBG_RST_CTLr
#define WRITEALL_TX_LN_DBG_RST_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_LN_DBG_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_CLK_N_RST_DBG_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b7
 * DEVAD:    1
 * DESC:     TX_CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_TX_S_CLKGATE_FRC_ON TX Active High Lane clock gator enable. If 1'1b1 then tx lane clock will be gated off. It does not affect the tclk goingto RMIC block so tx lane based registers can still be readable but not writable.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_clkgate_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_SEL Mux control for selection of comclk for TX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_sel is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     LN_TX_S_COMCLK_FRC_ON Mux control for selection of comclk for TX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the TX lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     PMD_TX_CLK_VLD_FRC pmd_tx_clk_vld core output pin force.
 *     PMD_TX_CLK_VLD_FRC_VAL pmd_tx_clk_vld core output pin force value.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr (0x0001d1b7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_CLK_N_RST_DBG_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t tx_clk_n_rst_dbg_ctl[1];
	uint32_t _tx_clk_n_rst_dbg_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_CLR(r) (r).tx_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_SET(r,d) (r).tx_clk_n_rst_dbg_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_GET(r) (r).tx_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET(r) ((((r).tx_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET(r) (((r).tx_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET(r,f) (r).tx_clk_n_rst_dbg_ctl[0]=(((r).tx_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CLK_N_RST_DBG_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr,(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_dbg_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_clk_n_rst_dbg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr
#define TX_CLK_N_RST_DBG_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_t TX_CLK_N_RST_DBG_CTLr_t;
#define TX_CLK_N_RST_DBG_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_CLR
#define TX_CLK_N_RST_DBG_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_SET
#define TX_CLK_N_RST_DBG_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRC_VALf_SET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_GET
#define TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_PMD_TX_CLK_VLD_FRCf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_FRC_ONf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_COMCLK_SELf_SET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_GET
#define TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr_LN_TX_S_CLKGATE_FRC_ONf_SET
#define READ_TX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_CLK_N_RST_DBG_CTLr
#define WRITE_TX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_CLK_N_RST_DBG_CTLr
#define MODIFY_TX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_CLK_N_RST_DBG_CTLr
#define READLN_TX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_CLK_N_RST_DBG_CTLr
#define WRITELN_TX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_CLK_N_RST_DBG_CTLr
#define WRITEALL_TX_CLK_N_RST_DBG_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_PMD_LN_MODE_STS
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1b8
 * DEVAD:    1
 * DESC:     TX_PMD_LANE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_TX_LANE_MODE This indicates the status of the core input pin pmd_rx_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr (0x0001d1b8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_PMD_LN_MODE_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t tx_pmd_ln_mode_sts[1];
	uint32_t _tx_pmd_ln_mode_sts;
} BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_CLR(r) (r).tx_pmd_ln_mode_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_SET(r,d) (r).tx_pmd_ln_mode_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_GET(r) (r).tx_pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET(r) (((r).tx_pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET(r,f) (r).tx_pmd_ln_mode_sts[0]=(((r).tx_pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_PMD_LN_MODE_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr,(_r._tx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr,(_r._tx_pmd_ln_mode_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr,(_r._tx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pmd_ln_mode_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PMD_LN_MODE_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pmd_ln_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr
#define TX_PMD_LN_MODE_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_t TX_PMD_LN_MODE_STSr_t;
#define TX_PMD_LN_MODE_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_CLR
#define TX_PMD_LN_MODE_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_SET
#define TX_PMD_LN_MODE_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_GET
#define TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_GET
#define TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr_PMD_TX_LANE_MODEf_SET
#define READ_TX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TX_PMD_LN_MODE_STSr
#define WRITE_TX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_PMD_LN_MODE_STSr
#define MODIFY_TX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_PMD_LN_MODE_STSr
#define READLN_TX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_PMD_LN_MODE_STSr
#define WRITELN_TX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_PMD_LN_MODE_STSr
#define WRITEALL_TX_PMD_LN_MODE_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_PMD_LN_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_PMD_LN_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TX_CLK_N_RST_MISC_CTL
 * BLOCKS:   TX_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1bd
 * DEVAD:    1
 * DESC:     TX_CLOCK_N_RESET_MISC_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_LOOP_FILTER_STABLE This register bit is ANDed with pmd_tx_clk_vld before frc/frc_val mux. This register will be controlled by the firmware when TX_PI is enabled.When TX_PI is enabled then this register will be written to 1'b0 while TX_PI is acquiring the lock with the source clock and will be written to 1'b1 by firmwareto indicate that clocks are locked. It indicates to chip level via pmd_tx_clk_vld to reset any datapath FIFOs and come out of reset when TX clock is stable.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr (0x0001d1bd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_CLK_N_RST_MISC_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_s {
	uint32_t v[1];
	uint32_t tx_clk_n_rst_misc_ctl[1];
	uint32_t _tx_clk_n_rst_misc_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_CLR(r) (r).tx_clk_n_rst_misc_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_SET(r,d) (r).tx_clk_n_rst_misc_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_GET(r) (r).tx_clk_n_rst_misc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET(r) (((r).tx_clk_n_rst_misc_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET(r,f) (r).tx_clk_n_rst_misc_ctl[0]=(((r).tx_clk_n_rst_misc_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_CLK_N_RST_MISC_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr,(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TX_CLK_N_RST_MISC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_CLK_N_RST_MISC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_clk_n_rst_misc_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_CLK_N_RST_MISC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_clk_n_rst_misc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CLK_N_RST_MISC_CTLr BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr
#define TX_CLK_N_RST_MISC_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_t TX_CLK_N_RST_MISC_CTLr_t;
#define TX_CLK_N_RST_MISC_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_CLR
#define TX_CLK_N_RST_MISC_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_SET
#define TX_CLK_N_RST_MISC_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_GET
#define TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_GET
#define TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr_TX_PI_LOOP_FILTER_STABLEf_SET
#define READ_TX_CLK_N_RST_MISC_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TX_CLK_N_RST_MISC_CTLr
#define WRITE_TX_CLK_N_RST_MISC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TX_CLK_N_RST_MISC_CTLr
#define MODIFY_TX_CLK_N_RST_MISC_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TX_CLK_N_RST_MISC_CTLr
#define READLN_TX_CLK_N_RST_MISC_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TX_CLK_N_RST_MISC_CTLr
#define WRITELN_TX_CLK_N_RST_MISC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TX_CLK_N_RST_MISC_CTLr
#define WRITEALL_TX_CLK_N_RST_MISC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TX_CLK_N_RST_MISC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TX_CLK_N_RST_MISC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_OSR_MODE_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c0
 * DEVAD:    1
 * DESC:     RXCOM_OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_OSR_MODE_FRC_VAL NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     RX_PAM4_MODE_FRC_VAL PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_er_mode reg field when 1'b1 is PAM4 ER mode and 1'b0 is PAM4 NR mode)Reserved      3'd2:3d7Note: This field is PMD uC driven and off limits for users
 *     RX_PAM4_MODE_FRC PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode.Othersise, the pin input values are used for pam4 mode Note: This field is PMD uC driven and off limits for users
 *     RX_OSR_MODE_FRC  NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr (0x0001d1c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_OSR_MODE_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_osr_mode_ctl[1];
	uint32_t _rxcom_osr_mode_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_CLR(r) (r).rxcom_osr_mode_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_SET(r,d) (r).rxcom_osr_mode_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_GET(r) (r).rxcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET(r) ((((r).rxcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_GET(r) ((((r).rxcom_osr_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_GET(r) ((((r).rxcom_osr_mode_ctl[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET(r) (((r).rxcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET(r,f) (r).rxcom_osr_mode_ctl[0]=(((r).rxcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_OSR_MODE_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr,(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr
#define RXCOM_OSR_MODE_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_t RXCOM_OSR_MODE_CTLr_t;
#define RXCOM_OSR_MODE_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_CLR
#define RXCOM_OSR_MODE_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_SET
#define RXCOM_OSR_MODE_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRCf_SET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_GET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRCf_SET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_GET
#define RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_PAM4_MODE_FRC_VALf_SET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_GET
#define RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr_RX_OSR_MODE_FRC_VALf_SET
#define READ_RXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_OSR_MODE_CTLr
#define WRITE_RXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_OSR_MODE_CTLr
#define MODIFY_RXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_OSR_MODE_CTLr
#define READLN_RXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_OSR_MODE_CTLr
#define WRITELN_RXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_OSR_MODE_CTLr
#define WRITEALL_RXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c1
 * DEVAD:    1
 * DESC:     RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LN_DP_S_RSTB  Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _rxcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET(r) (((r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET(r,f) (r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).rxcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_GET
#define RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr_RX_LN_DP_S_RSTBf_SET
#define READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c3
 * DEVAD:    1
 * DESC:     RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_RX_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_RX_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1c3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _rxcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET(r) ((((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET(r,f) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET(r) (((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET(r,f) (r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).rxcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_DP_H_RSTB_PKILLf_SET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_GET
#define RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_RSTB_PKILLf_SET
#define READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_UC_ACK_LN_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c5
 * DEVAD:    1
 * DESC:     RXCOM_UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     RX_UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr (0x0001d1c5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_UC_ACK_LN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_uc_ack_ln_ctl[1];
	uint32_t _rxcom_uc_ack_ln_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_CLR(r) (r).rxcom_uc_ack_ln_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).rxcom_uc_ack_ln_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_GET(r) (r).rxcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).rxcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).rxcom_uc_ack_ln_ctl[0]=(((r).rxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).rxcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).rxcom_uc_ack_ln_ctl[0]=(((r).rxcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_UC_ACK_LN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr,(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr
#define RXCOM_UC_ACK_LN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_t RXCOM_UC_ACK_LN_CTLr_t;
#define RXCOM_UC_ACK_LN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_CLR
#define RXCOM_UC_ACK_LN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_SET
#define RXCOM_UC_ACK_LN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_DP_RESETf_SET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_GET
#define RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr_RX_UC_ACK_LANE_CFG_DONEf_SET
#define READ_RXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_UC_ACK_LN_CTLr
#define WRITE_RXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_UC_ACK_LN_CTLr
#define MODIFY_RXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_UC_ACK_LN_CTLr
#define READLN_RXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_UC_ACK_LN_CTLr
#define WRITELN_RXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_UC_ACK_LN_CTLr
#define WRITEALL_RXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_LN_RST_OCC_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c6
 * DEVAD:    1
 * DESC:     RXCOM_LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr (0x0001d1c6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_RST_OCC_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_rst_occ_ctl[1];
	uint32_t _rxcom_ln_rst_occ_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_CLR(r) (r).rxcom_ln_rst_occ_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).rxcom_ln_rst_occ_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_GET(r) (r).rxcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET(r) (((r).rxcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).rxcom_ln_rst_occ_ctl[0]=(((r).rxcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_RST_OCC_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr,(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr
#define RXCOM_LN_RST_OCC_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_t RXCOM_LN_RST_OCC_CTLr_t;
#define RXCOM_LN_RST_OCC_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_CLR
#define RXCOM_LN_RST_OCC_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_SET
#define RXCOM_LN_RST_OCC_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_GET
#define RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_GET
#define RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr_RX_LANE_REG_RESET_OCCURREDf_SET
#define READ_RXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_RST_OCC_CTLr
#define WRITE_RXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_RST_OCC_CTLr
#define MODIFY_RXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_RST_OCC_CTLr
#define READLN_RXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_RST_OCC_CTLr
#define WRITELN_RXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_RST_OCC_CTLr
#define WRITEALL_RXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_PLL_SEL_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c7
 * DEVAD:    1
 * DESC:     RXCOM_PLL_SELECT_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PLL_SELECT    This register controls the selection of the PLL0 or PLL1 as clock source for the rx_ lane. This register will be only reset upon POR hard or POR soft reset.This register is expected to be changed only when rx_ lane datapath is in reset.0 - Select PLL0 as clock for rx_ lane.1 - Select PLL1 as clock for rx_ lane.This register bit also drive the AFE rx_ctrl[95] pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr (0x0001d1c7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_PLL_SEL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_pll_sel_ctl[1];
	uint32_t _rxcom_pll_sel_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_CLR(r) (r).rxcom_pll_sel_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_SET(r,d) (r).rxcom_pll_sel_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_GET(r) (r).rxcom_pll_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_GET(r) (((r).rxcom_pll_sel_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_SET(r,f) (r).rxcom_pll_sel_ctl[0]=(((r).rxcom_pll_sel_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_PLL_SEL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr,(_r._rxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr,(_r._rxcom_pll_sel_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr,(_r._rxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_pll_sel_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr
#define RXCOM_PLL_SEL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_t RXCOM_PLL_SEL_CTLr_t;
#define RXCOM_PLL_SEL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_CLR
#define RXCOM_PLL_SEL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_SET
#define RXCOM_PLL_SEL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_GET
#define RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_GET
#define RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr_RX_PLL_SELECTf_SET
#define READ_RXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_PLL_SEL_CTLr
#define WRITE_RXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_PLL_SEL_CTLr
#define MODIFY_RXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_PLL_SEL_CTLr
#define READLN_RXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_PLL_SEL_CTLr
#define WRITELN_RXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_PLL_SEL_CTLr
#define WRITEALL_RXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_PLL_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_PLL_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1c9
 * DEVAD:    1
 * DESC:     RXCOM_LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr (0x0001d1c9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_DP_RST_ST_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_dp_rst_st_sts[1];
	uint32_t _rxcom_ln_dp_rst_st_sts;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).rxcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).rxcom_ln_dp_rst_st_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_GET(r) (r).rxcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET(r) (((r).rxcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET(r,f) (r).rxcom_ln_dp_rst_st_sts[0]=(((r).rxcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RXCOM_LN_DP_RST_ST_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr,(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr
#define RXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_t RXCOM_LN_DP_RST_ST_STSr_t;
#define RXCOM_LN_DP_RST_ST_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_CLR
#define RXCOM_LN_DP_RST_ST_STSr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_SET
#define RXCOM_LN_DP_RST_ST_STSr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_GET
#define RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_GET
#define RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr_RX_LANE_DP_RESET_STATEf_SET
#define READ_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_DP_RST_ST_STSr
#define WRITE_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_DP_RST_ST_STSr
#define MODIFY_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_DP_RST_ST_STSr
#define READLN_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_DP_RST_ST_STSr
#define WRITELN_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_RXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_MCST_MASK_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ca
 * DEVAD:    1
 * DESC:     RXCOM_MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr (0x0001d1ca | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_MCST_MASK_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_mcst_mask_ctl[1];
	uint32_t _rxcom_mcst_mask_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_CLR(r) (r).rxcom_mcst_mask_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_SET(r,d) (r).rxcom_mcst_mask_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_GET(r) (r).rxcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET(r) (((r).rxcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET(r,f) (r).rxcom_mcst_mask_ctl[0]=(((r).rxcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_MCST_MASK_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr,(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr
#define RXCOM_MCST_MASK_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_t RXCOM_MCST_MASK_CTLr_t;
#define RXCOM_MCST_MASK_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_CLR
#define RXCOM_MCST_MASK_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_SET
#define RXCOM_MCST_MASK_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_GET
#define RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_GET
#define RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr_RX_MULTICAST_MASK_CONTROLf_SET
#define READ_RXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_MCST_MASK_CTLr
#define WRITE_RXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_MCST_MASK_CTLr
#define MODIFY_RXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_MCST_MASK_CTLr
#define READLN_RXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_MCST_MASK_CTLr
#define WRITELN_RXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_MCST_MASK_CTLr
#define WRITEALL_RXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1cb
 * DEVAD:    1
 * DESC:     RXCOM_OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_OSR_MODE      OSR Mode status after the osr_mode_frc/frc_val mux.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     RX_PAM4_MODE     PAM4 signalling mode status after the pam4_mode_frc/frc_val mux.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_er_mode reg field when 1'b1 is PAM4 ER mode and 1'b0 is PAM4 NR mode)Reserved      3'd2:3d7
 *     RX_MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr (0x0001d1cb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_OSR_MODE_STS_MC_MASK.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t rxcom_osr_mode_sts_mc_mask[1];
	uint32_t _rxcom_osr_mode_sts_mc_mask;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).rxcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).rxcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).rxcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).rxcom_osr_mode_sts_mc_mask[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_GET(r) ((((r).rxcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET(r) (((r).rxcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET(r,f) (r).rxcom_osr_mode_sts_mc_mask[0]=(((r).rxcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RXCOM_OSR_MODE_STS_MC_MASK.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr,(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr
#define RXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_t RXCOM_OSR_MODE_STS_MC_MASKr_t;
#define RXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define RXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_MULTICAST_MASK_CONTROL_STATUSf_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_PAM4_MODEf_SET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_GET
#define RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr_RX_OSR_MODEf_SET
#define READ_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_OSR_MODE_STS_MC_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  RXCOM_LN_S_RSTB_CTL
 * BLOCKS:   RXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1ce
 * DEVAD:    1
 * DESC:     RXCOM_LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *     RX_HW_FW_HANDSHAKE_DISABLE This register bit is unused in RX lane.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr (0x0001d1ce | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RXCOM_LN_S_RSTB_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t rxcom_ln_s_rstb_ctl[1];
	uint32_t _rxcom_ln_s_rstb_ctl;
} BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_CLR(r) (r).rxcom_ln_s_rstb_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).rxcom_ln_s_rstb_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_GET(r) (r).rxcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).rxcom_ln_s_rstb_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).rxcom_ln_s_rstb_ctl[0]=(((r).rxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET(r) (((r).rxcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET(r,f) (r).rxcom_ln_s_rstb_ctl[0]=(((r).rxcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RXCOM_LN_S_RSTB_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr,(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rxcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rxcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr
#define RXCOM_LN_S_RSTB_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_t RXCOM_LN_S_RSTB_CTLr_t;
#define RXCOM_LN_S_RSTB_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_CLR
#define RXCOM_LN_S_RSTB_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_SET
#define RXCOM_LN_S_RSTB_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_HW_FW_HANDSHAKE_DISABLEf_SET
#define RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_GET
#define RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr_RX_LN_S_RSTBf_SET
#define READ_RXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_RXCOM_LN_S_RSTB_CTLr
#define WRITE_RXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_RXCOM_LN_S_RSTB_CTLr
#define MODIFY_RXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_RXCOM_LN_S_RSTB_CTLr
#define READLN_RXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_RXCOM_LN_S_RSTB_CTLr
#define WRITELN_RXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_RXCOM_LN_S_RSTB_CTLr
#define WRITEALL_RXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_RXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_RXCOM_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_OSR_MODE_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d0
 * DEVAD:    1
 * DESC:     TXCOM_OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_OSR_MODE_FRC_VAL NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     TX_PAM4_MODE_FRC_VAL PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_er_mode reg field when 1'b1 is PAM4 ER mode and 1'b0 is PAM4 NR mode)Reserved      3'd2:3d7Note: This field is PMD uC driven and off limits for users
 *     TX_PAM4_MODE_FRC PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode.Othersise, the pin input values are used for pam4 mode Note: This field is PMD uC driven and off limits for users
 *     TX_OSR_MODE_FRC  NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr (0x0001d1d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_OSR_MODE_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_osr_mode_ctl[1];
	uint32_t _txcom_osr_mode_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_CLR(r) (r).txcom_osr_mode_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_SET(r,d) (r).txcom_osr_mode_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_GET(r) (r).txcom_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET(r) ((((r).txcom_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_GET(r) ((((r).txcom_osr_mode_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_GET(r) ((((r).txcom_osr_mode_ctl[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET(r) (((r).txcom_osr_mode_ctl[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET(r,f) (r).txcom_osr_mode_ctl[0]=(((r).txcom_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_OSR_MODE_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr,(_r._txcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_OSR_MODE_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_OSR_MODE_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr
#define TXCOM_OSR_MODE_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_t TXCOM_OSR_MODE_CTLr_t;
#define TXCOM_OSR_MODE_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_CLR
#define TXCOM_OSR_MODE_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_SET
#define TXCOM_OSR_MODE_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRCf_SET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_GET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRCf_SET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_GET
#define TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_PAM4_MODE_FRC_VALf_SET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_GET
#define TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr_TX_OSR_MODE_FRC_VALf_SET
#define READ_TXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_OSR_MODE_CTLr
#define WRITE_TXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_OSR_MODE_CTLr
#define MODIFY_TXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_OSR_MODE_CTLr
#define READLN_TXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_OSR_MODE_CTLr
#define WRITELN_TXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_OSR_MODE_CTLr
#define WRITEALL_TXCOM_OSR_MODE_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d1
 * DEVAD:    1
 * DESC:     TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_DP_S_RSTB  Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d1d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _txcom_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET(r) (((r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET(r,f) (r).txcom_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).txcom_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_GET
#define TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr_TX_LN_DP_S_RSTBf_SET
#define READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d3
 * DEVAD:    1
 * DESC:     TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_TX_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_TX_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d1d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _txcom_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET(r) ((((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET(r,f) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET(r) (((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET(r,f) (r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).txcom_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_DP_H_RSTB_PKILLf_SET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_GET
#define TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_RSTB_PKILLf_SET
#define READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_UC_ACK_LN_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d5
 * DEVAD:    1
 * DESC:     TXCOM_UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     TX_UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr (0x0001d1d5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_UC_ACK_LN_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_uc_ack_ln_ctl[1];
	uint32_t _txcom_uc_ack_ln_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_CLR(r) (r).txcom_uc_ack_ln_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_SET(r,d) (r).txcom_uc_ack_ln_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_GET(r) (r).txcom_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).txcom_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).txcom_uc_ack_ln_ctl[0]=(((r).txcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).txcom_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).txcom_uc_ack_ln_ctl[0]=(((r).txcom_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_UC_ACK_LN_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr,(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_uc_ack_ln_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_UC_ACK_LN_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr
#define TXCOM_UC_ACK_LN_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_t TXCOM_UC_ACK_LN_CTLr_t;
#define TXCOM_UC_ACK_LN_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_CLR
#define TXCOM_UC_ACK_LN_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_SET
#define TXCOM_UC_ACK_LN_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_DP_RESETf_SET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_GET
#define TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr_TX_UC_ACK_LANE_CFG_DONEf_SET
#define READ_TXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_UC_ACK_LN_CTLr
#define WRITE_TXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_UC_ACK_LN_CTLr
#define MODIFY_TXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_UC_ACK_LN_CTLr
#define READLN_TXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_UC_ACK_LN_CTLr
#define WRITELN_TXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_UC_ACK_LN_CTLr
#define WRITEALL_TXCOM_UC_ACK_LN_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_LN_RST_OCC_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d6
 * DEVAD:    1
 * DESC:     TXCOM_LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr (0x0001d1d6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_RST_OCC_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_rst_occ_ctl[1];
	uint32_t _txcom_ln_rst_occ_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_CLR(r) (r).txcom_ln_rst_occ_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_SET(r,d) (r).txcom_ln_rst_occ_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_GET(r) (r).txcom_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET(r) (((r).txcom_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).txcom_ln_rst_occ_ctl[0]=(((r).txcom_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_RST_OCC_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr,(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_rst_occ_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_RST_OCC_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr
#define TXCOM_LN_RST_OCC_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_t TXCOM_LN_RST_OCC_CTLr_t;
#define TXCOM_LN_RST_OCC_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_CLR
#define TXCOM_LN_RST_OCC_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_SET
#define TXCOM_LN_RST_OCC_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_GET
#define TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_GET
#define TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr_TX_LANE_REG_RESET_OCCURREDf_SET
#define READ_TXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_RST_OCC_CTLr
#define WRITE_TXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_RST_OCC_CTLr
#define MODIFY_TXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_RST_OCC_CTLr
#define READLN_TXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_RST_OCC_CTLr
#define WRITELN_TXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_RST_OCC_CTLr
#define WRITEALL_TXCOM_LN_RST_OCC_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_PLL_SEL_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d7
 * DEVAD:    1
 * DESC:     TXCOM_PLL_SELECT_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PLL_SELECT    This register controls the selection of the PLL0 or PLL1 as clock source for the tx_ lane. This register will be only reset upon POR hard or POR soft reset.This register is expected to be changed only when tx_ lane datapath is in reset.0 - Select PLL0 as clock for tx_ lane.1 - Select PLL1 as clock for tx_ lane.This register bit also drive the AFE tx_ctrl[0] pin.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr (0x0001d1d7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_PLL_SEL_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_pll_sel_ctl[1];
	uint32_t _txcom_pll_sel_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_CLR(r) (r).txcom_pll_sel_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_SET(r,d) (r).txcom_pll_sel_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_GET(r) (r).txcom_pll_sel_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_GET(r) (((r).txcom_pll_sel_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_SET(r,f) (r).txcom_pll_sel_ctl[0]=(((r).txcom_pll_sel_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_PLL_SEL_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr,(_r._txcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr,(_r._txcom_pll_sel_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr,(_r._txcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_PLL_SEL_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_pll_sel_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_PLL_SEL_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_pll_sel_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr
#define TXCOM_PLL_SEL_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_t TXCOM_PLL_SEL_CTLr_t;
#define TXCOM_PLL_SEL_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_CLR
#define TXCOM_PLL_SEL_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_SET
#define TXCOM_PLL_SEL_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_GET
#define TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_GET
#define TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr_TX_PLL_SELECTf_SET
#define READ_TXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_PLL_SEL_CTLr
#define WRITE_TXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_PLL_SEL_CTLr
#define MODIFY_TXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_PLL_SEL_CTLr
#define READLN_TXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_PLL_SEL_CTLr
#define WRITELN_TXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_PLL_SEL_CTLr
#define WRITEALL_TXCOM_PLL_SEL_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_PLL_SEL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_PLL_SEL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_LN_DP_RST_ST_STS
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1d9
 * DEVAD:    1
 * DESC:     TXCOM_LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr (0x0001d1d9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_DP_RST_ST_STS.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t txcom_ln_dp_rst_st_sts[1];
	uint32_t _txcom_ln_dp_rst_st_sts;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_CLR(r) (r).txcom_ln_dp_rst_st_sts[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_SET(r,d) (r).txcom_ln_dp_rst_st_sts[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_GET(r) (r).txcom_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET(r) (((r).txcom_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET(r,f) (r).txcom_ln_dp_rst_st_sts[0]=(((r).txcom_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TXCOM_LN_DP_RST_ST_STS.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr,(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_dp_rst_st_sts))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_DP_RST_ST_STSr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr
#define TXCOM_LN_DP_RST_ST_STSr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_t TXCOM_LN_DP_RST_ST_STSr_t;
#define TXCOM_LN_DP_RST_ST_STSr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_CLR
#define TXCOM_LN_DP_RST_ST_STSr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_SET
#define TXCOM_LN_DP_RST_ST_STSr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_GET
#define TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_GET
#define TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr_TX_LANE_DP_RESET_STATEf_SET
#define READ_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_DP_RST_ST_STSr
#define WRITE_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_DP_RST_ST_STSr
#define MODIFY_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_DP_RST_ST_STSr
#define READLN_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_DP_RST_ST_STSr
#define WRITELN_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_DP_RST_ST_STSr
#define WRITEALL_TXCOM_LN_DP_RST_ST_STSr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_MCST_MASK_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1da
 * DEVAD:    1
 * DESC:     TXCOM_MULTICAST_MASK_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr (0x0001d1da | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_MCST_MASK_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_mcst_mask_ctl[1];
	uint32_t _txcom_mcst_mask_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_CLR(r) (r).txcom_mcst_mask_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_SET(r,d) (r).txcom_mcst_mask_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_GET(r) (r).txcom_mcst_mask_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET(r) (((r).txcom_mcst_mask_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET(r,f) (r).txcom_mcst_mask_ctl[0]=(((r).txcom_mcst_mask_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_MCST_MASK_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr,(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_MCST_MASK_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_mcst_mask_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_MCST_MASK_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_mcst_mask_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr
#define TXCOM_MCST_MASK_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_t TXCOM_MCST_MASK_CTLr_t;
#define TXCOM_MCST_MASK_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_CLR
#define TXCOM_MCST_MASK_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_SET
#define TXCOM_MCST_MASK_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_GET
#define TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_GET
#define TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr_TX_MULTICAST_MASK_CONTROLf_SET
#define READ_TXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_MCST_MASK_CTLr
#define WRITE_TXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_MCST_MASK_CTLr
#define MODIFY_TXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_MCST_MASK_CTLr
#define READLN_TXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_MCST_MASK_CTLr
#define WRITELN_TXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_MCST_MASK_CTLr
#define WRITEALL_TXCOM_MCST_MASK_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_MCST_MASK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_MCST_MASK_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_OSR_MODE_STS_MC_MASK
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1db
 * DEVAD:    1
 * DESC:     TXCOM_OSR_MODE_STATUS_MC_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_OSR_MODE      OSR Mode status after the osr_mode_frc/frc_val mux.OSX1          4'd0     (NRZ mode and PAM4 mode)OSX2          4'd1     (NRZ mode and PAM4 mode)OSX4          4'd2     (NRZ mode only         )OSX21P25      4'd4     (NRZ mode only         )OSX16P5       4'd8     (NRZ mode only         )OSX20P625     4'd12    (NRZ mode only         )OSX8          4'd5     (NRZ mode only         )OSX16         4'd9     (NRZ mode only         )OSX32         4'd13    (NRZ mode only         )
 *     TX_PAM4_MODE     PAM4 signalling mode status after the pam4_mode_frc/frc_val mux.NRZ OS modes  3'd0PAM4 OS modes 3'd1         (rx_pam4_er_mode reg field when 1'b1 is PAM4 ER mode and 1'b0 is PAM4 NR mode)Reserved      3'd2:3d7
 *     TX_MULTICAST_MASK_CONTROL_STATUS Status of multicast mask control for masking lane from multicast write operation.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr (0x0001d1db | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_OSR_MODE_STS_MC_MASK.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_s {
	uint32_t v[1];
	uint32_t txcom_osr_mode_sts_mc_mask[1];
	uint32_t _txcom_osr_mode_sts_mc_mask;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_CLR(r) (r).txcom_osr_mode_sts_mc_mask[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SET(r,d) (r).txcom_osr_mode_sts_mc_mask[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_GET(r) (r).txcom_osr_mode_sts_mc_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET(r) ((((r).txcom_osr_mode_sts_mc_mask[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_GET(r) ((((r).txcom_osr_mode_sts_mc_mask[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET(r) (((r).txcom_osr_mode_sts_mc_mask[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET(r,f) (r).txcom_osr_mode_sts_mc_mask[0]=(((r).txcom_osr_mode_sts_mc_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXCOM_OSR_MODE_STS_MC_MASK.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr,(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_osr_mode_sts_mc_mask))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_osr_mode_sts_mc_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr
#define TXCOM_OSR_MODE_STS_MC_MASKr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_t TXCOM_OSR_MODE_STS_MC_MASKr_t;
#define TXCOM_OSR_MODE_STS_MC_MASKr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_CLR
#define TXCOM_OSR_MODE_STS_MC_MASKr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_MULTICAST_MASK_CONTROL_STATUSf_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_PAM4_MODEf_SET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_GET
#define TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr_TX_OSR_MODEf_SET
#define READ_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITE_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_OSR_MODE_STS_MC_MASKr
#define MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_OSR_MODE_STS_MC_MASKr
#define READLN_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_OSR_MODE_STS_MC_MASKr
#define WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_OSR_MODE_STS_MC_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_OSR_MODE_STS_MC_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TXCOM_LN_S_RSTB_CTL
 * BLOCKS:   TXCOM_CKRST_CTRL_8X_PLL2X_V1P0
 * REGADDR:  0xd1de
 * DEVAD:    1
 * DESC:     TXCOM_LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LN_S_RSTB     Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 *     TX_HW_FW_HANDSHAKE_DISABLE 1: disables the HW-FW handshake logic for the TX lane which means there is no acknowledgement required from uC and lane reset will be de-asserted once reset register/pin conditions are de-asserted.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr (0x0001d1de | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TXCOM_LN_S_RSTB_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t txcom_ln_s_rstb_ctl[1];
	uint32_t _txcom_ln_s_rstb_ctl;
} BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_CLR(r) (r).txcom_ln_s_rstb_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_SET(r,d) (r).txcom_ln_s_rstb_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_GET(r) (r).txcom_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_GET(r) ((((r).txcom_ln_s_rstb_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_SET(r,f) (r).txcom_ln_s_rstb_ctl[0]=(((r).txcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET(r) (((r).txcom_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET(r,f) (r).txcom_ln_s_rstb_ctl[0]=(((r).txcom_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXCOM_LN_S_RSTB_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr,(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txcom_ln_s_rstb_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_S_RSTB_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txcom_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr
#define TXCOM_LN_S_RSTB_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_t TXCOM_LN_S_RSTB_CTLr_t;
#define TXCOM_LN_S_RSTB_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_CLR
#define TXCOM_LN_S_RSTB_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_SET
#define TXCOM_LN_S_RSTB_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_HW_FW_HANDSHAKE_DISABLEf_SET
#define TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_GET
#define TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr_TX_LN_S_RSTBf_SET
#define READ_TXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_TXCOM_LN_S_RSTB_CTLr
#define WRITE_TXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_TXCOM_LN_S_RSTB_CTLr
#define MODIFY_TXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TXCOM_LN_S_RSTB_CTLr
#define READLN_TXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_TXCOM_LN_S_RSTB_CTLr
#define WRITELN_TXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TXCOM_LN_S_RSTB_CTLr
#define WRITEALL_TXCOM_LN_S_RSTB_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TXCOM_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TXCOM_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_TLB_RX_C_CFG0
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f0
 * DEVAD:    1
 * DESC:     TLB_RX_C Control 0
 * RESETVAL: 0x440c (17420)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_CLEAR_ERROR_ANALYZER_STATUS When a write is executed in this register, it will clear all the error analyzer error count status registers.This register is self-clear.
 *     TLB_ERR_ERROR_COUNT_THRESH If number of symbold errors > Error threshold then the error analyzer would count a bad frame.Valid values for this field are from 0-15
 *     TLB_ERR_IGNORE_BACK_CHANNEL By setting this bit, the frame counter in the error analyzer continues count when back channel word arrives.When back channel word arrives, the error analyzer treats it like a valid prbs code but assumes zero errors.This is a debug feature.
 *     TLB_ERR_FEC_L_EN If 1 implies that 20 MSBs of the 40 bit word are processed else 20 LSBs are processed.
 *     TLB_ERR_FEC_L_R_EN If 1 implies that two fecs are processing the rx data. The error analyzer looks at only 20 bits out of a 40 bit word.
 *     TLB_ERR_FEC_SIZE Defines the size of the FEC frame.Valid values for this field must be >= 6The frame size = (tlb_err_fec_size * 320) bitsTo get 5440 bits FEC, N = 5440/320 = 17.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r (0x0001d1f0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_TLB_RX_C_CFG0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_tlb_rx_c_cfg0[1];
	uint32_t _tlb_rx_c_tlb_rx_c_cfg0;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_CLR(r) (r).tlb_rx_c_tlb_rx_c_cfg0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SET(r,d) (r).tlb_rx_c_tlb_rx_c_cfg0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_GET(r) (r).tlb_rx_c_tlb_rx_c_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 10) & 0x3f)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x3f << 10)) | ((((uint32_t)f) & 0x3f) << 10)) | (63 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 2) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg0[0]=(((r).tlb_rx_c_tlb_rx_c_cfg0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access TLB_RX_C_TLB_RX_C_CFG0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r,(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r,(_r._tlb_rx_c_tlb_rx_c_cfg0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r,(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_tlb_rx_c_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_TLB_RX_C_CFG0r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r
#define TLB_RX_C_TLB_RX_C_CFG0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_t TLB_RX_C_TLB_RX_C_CFG0r_t;
#define TLB_RX_C_TLB_RX_C_CFG0r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_CLR
#define TLB_RX_C_TLB_RX_C_CFG0r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_SIZEf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_R_ENf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_FEC_L_ENf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_IGNORE_BACK_CHANNELf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_ERROR_COUNT_THRESHf_SET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_GET
#define TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r_TLB_ERR_CLEAR_ERROR_ANALYZER_STATUSf_SET
#define READ_TLB_RX_C_TLB_RX_C_CFG0r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG0r
#define WRITE_TLB_RX_C_TLB_RX_C_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG0r
#define MODIFY_TLB_RX_C_TLB_RX_C_CFG0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG0r
#define READLN_TLB_RX_C_TLB_RX_C_CFG0r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG0r
#define WRITELN_TLB_RX_C_TLB_RX_C_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG0r
#define WRITEALL_TLB_RX_C_TLB_RX_C_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_TLB_RX_C_CFG1
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f1
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 1
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_HISTOGRAM_ERROR_THRESH Sets the value x, which determines counting the number of FEC frames with x, x+1,..,x+7 errorsValid values for this field are from 0-8
 *     TLB_ERR_CLEAR_STATUS_ON_READ Enables read on clear for all error status counters
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r (0x0001d1f1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_TLB_RX_C_CFG1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_tlb_rx_c_cfg1[1];
	uint32_t _tlb_rx_c_tlb_rx_c_cfg1;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_CLR(r) (r).tlb_rx_c_tlb_rx_c_cfg1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SET(r,d) (r).tlb_rx_c_tlb_rx_c_cfg1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_GET(r) (r).tlb_rx_c_tlb_rx_c_cfg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_GET(r) ((((r).tlb_rx_c_tlb_rx_c_cfg1[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg1[0]=(((r).tlb_rx_c_tlb_rx_c_cfg1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_GET(r) (((r).tlb_rx_c_tlb_rx_c_cfg1[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_SET(r,f) (r).tlb_rx_c_tlb_rx_c_cfg1[0]=(((r).tlb_rx_c_tlb_rx_c_cfg1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_RX_C_TLB_RX_C_CFG1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r,(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r,(_r._tlb_rx_c_tlb_rx_c_cfg1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r,(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_tlb_rx_c_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_tlb_rx_c_cfg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_TLB_RX_C_CFG1r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r
#define TLB_RX_C_TLB_RX_C_CFG1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_t TLB_RX_C_TLB_RX_C_CFG1r_t;
#define TLB_RX_C_TLB_RX_C_CFG1r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_CLR
#define TLB_RX_C_TLB_RX_C_CFG1r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_SET
#define TLB_RX_C_TLB_RX_C_CFG1r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_GET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_GET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_CLEAR_STATUS_ON_READf_SET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_GET
#define TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r_TLB_ERR_HISTOGRAM_ERROR_THRESHf_SET
#define READ_TLB_RX_C_TLB_RX_C_CFG1r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_TLB_RX_C_CFG1r
#define WRITE_TLB_RX_C_TLB_RX_C_CFG1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_TLB_RX_C_CFG1r
#define MODIFY_TLB_RX_C_TLB_RX_C_CFG1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_TLB_RX_C_CFG1r
#define READLN_TLB_RX_C_TLB_RX_C_CFG1r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_TLB_RX_C_CFG1r
#define WRITELN_TLB_RX_C_TLB_RX_C_CFG1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_TLB_RX_C_CFG1r
#define WRITEALL_TLB_RX_C_TLB_RX_C_CFG1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_TLB_RX_C_CFG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_TLB_RX_C_CFG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HI
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f5
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_ERROR_HI Top 4 bits out of 20 bit register that stores the status of how many number of FEC frames have errors >= tlb_err_error_count_threshtlb_err_count_error_lo needs to be read before this status register to read the correct value
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr (0x0001d1f5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_num_errs_in_fec_frames_sts_hi[1];
	uint32_t _tlb_rx_c_num_errs_in_fec_frames_sts_hi;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET(r,d) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_GET(r) (((r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_SET(r,f) (r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_rx_c_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_COUNT_ERROR_HIf_SET
#define READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_HIr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LO
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f6
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_ERROR_LO Bottom 16 bits out of 20 bit register that stores the status of how many number of FEC frames have errors >= tlb_err_error_count_thresh
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr (0x0001d1f6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_num_errs_in_fec_frames_sts_lo[1];
	uint32_t _tlb_rx_c_num_errs_in_fec_frames_sts_lo;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET(r,d) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET(r) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_GET(r) (((r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_SET(r,f) (r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0]=(((r).tlb_rx_c_num_errs_in_fec_frames_sts_lo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_num_errs_in_fec_frames_sts_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_GET
#define TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_COUNT_ERROR_LOf_SET
#define READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_NUM_ERRS_IN_FEC_FRAMES_STS_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f7
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7 Number of times 'N+7' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r (0x0001d1f7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs7[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs7;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs7[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs7[0]=(((r).tlb_rx_c_cnt_histogram_err_offs7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_rx_c_cnt_histogram_err_offs7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f8
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6 Number of times 'N+6' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r (0x0001d1f8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs6[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs6;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs6[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs6[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs6[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs6[0]=(((r).tlb_rx_c_cnt_histogram_err_offs6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_rx_c_cnt_histogram_err_offs6)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1f9
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5 Number of times 'N+5' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r (0x0001d1f9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs5[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs5;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs5[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs5[0]=(((r).tlb_rx_c_cnt_histogram_err_offs5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_rx_c_cnt_histogram_err_offs5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fa
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4 Number of times 'N+4' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r (0x0001d1fa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs4[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs4;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs4[0]=(((r).tlb_rx_c_cnt_histogram_err_offs4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_rx_c_cnt_histogram_err_offs4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fb
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3 Number of times 'N+3' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r (0x0001d1fb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs3[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs3;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs3[0]=(((r).tlb_rx_c_cnt_histogram_err_offs3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_rx_c_cnt_histogram_err_offs3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fc
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2 Number of times 'N+2' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r (0x0001d1fc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs2[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs2;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs2[0]=(((r).tlb_rx_c_cnt_histogram_err_offs2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_rx_c_cnt_histogram_err_offs2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fd
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1 Number of times 'N+1' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r (0x0001d1fd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs1[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs1;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs1[0]=(((r).tlb_rx_c_cnt_histogram_err_offs1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_rx_c_cnt_histogram_err_offs1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0
 * BLOCKS:   TLB_RX_C
 * REGADDR:  0xd1fe
 * DEVAD:    1
 * DESC:     TLB_RX_C Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0 Number of times 'N' errors occurr in FEC frames, where N is defined by the register tlb_err_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r (0x0001d1fe | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_s {
	uint32_t v[1];
	uint32_t tlb_rx_c_cnt_histogram_err_offs0[1];
	uint32_t _tlb_rx_c_cnt_histogram_err_offs0;
} BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_CLR(r) (r).tlb_rx_c_cnt_histogram_err_offs0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SET(r,d) (r).tlb_rx_c_cnt_histogram_err_offs0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_GET(r) (r).tlb_rx_c_cnt_histogram_err_offs0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET(r) (((r).tlb_rx_c_cnt_histogram_err_offs0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET(r,f) (r).tlb_rx_c_cnt_histogram_err_offs0[0]=(((r).tlb_rx_c_cnt_histogram_err_offs0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_rx_c_cnt_histogram_err_offs0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_c_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_c_cnt_histogram_err_offs0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_t TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_t;
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_CLR
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_SET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET
#define TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET
#define READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_RX_C_CNT_HISTOGRAM_ERR_OFFS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_CLK_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd200
 * DEVAD:    1
 * DESC:     Clock control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_CLK_EN master clock enable:By default the clock to micro sub-system is disabled andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 enable the master clock0 - disabled1 - enables
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r (0x0001d200 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CLK_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_clk_ctl0[1];
	uint32_t _uc_clk_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_CLR(r) (r).uc_clk_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_SET(r,d) (r).uc_clk_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_GET(r) (r).uc_clk_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET(r) (((r).uc_clk_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CLK_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_clk_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r
#define UC_CLK_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_t UC_CLK_CTL0r_t;
#define UC_CLK_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_CLR
#define UC_CLK_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_SET
#define UC_CLK_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_GET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET
#define READ_UC_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_CLK_CTL0r
#define WRITE_UC_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_CLK_CTL0r
#define MODIFY_UC_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_CLK_CTL0r
#define READLN_UC_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_CLK_CTL0r
#define WRITELN_UC_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_CLK_CTL0r
#define WRITEALL_UC_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_CLK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_CLK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RST_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd201
 * DEVAD:    1
 * DESC:     Reset control registers 0
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_RSTB master reset :By default a reset to micro controller sub-system is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the micro-subsystem0 - asserted1 - de-asserted
 *     MICRO_SW_TIMESTAMP_TIMER_RSTB Timestamp timer software resetThis field allows the chip firmware to reset the timestamp timers inall Serdes cores to be be with 1 or 2 time units.0 - asserted, Timestamp timer set 0.1 - de-asserted,  normal operation.
 *     MICRO_PRAM_IF_RSTB PRAM interface reset :By default a reset to the PRAM interface is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the PRAM interface0 - asserted1 - de-asserted
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r (0x0001d201 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RST_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rst_ctl0[1];
	uint32_t _uc_rst_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_CLR(r) (r).uc_rst_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_SET(r,d) (r).uc_rst_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_GET(r) (r).uc_rst_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET(r) (((r).uc_rst_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RST_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rst_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r
#define UC_RST_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_t UC_RST_CTL0r_t;
#define UC_RST_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_CLR
#define UC_RST_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_SET
#define UC_RST_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET
#define UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_GET
#define UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_SW_TIMESTAMP_TIMER_RSTBf_SET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET
#define READ_UC_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RST_CTL0r
#define WRITE_UC_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RST_CTL0r
#define MODIFY_UC_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RST_CTL0r
#define READLN_UC_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RST_CTL0r
#define WRITELN_UC_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RST_CTL0r
#define WRITEALL_UC_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RST_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RST_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd202
 * DEVAD:    1
 * DESC:     rmi to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATASIZE write data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_RDDATASIZE read data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_INIT    Intialize code/data RAM2'b01: initailize code RAM - write zeroes to all locations2'b10: initialize data RAM - write zeroes to all loactions2'b00, 2'b11: ignored
 *     MICRO_AUTOINC_WRADDR_EN Automatic increment write address enable0 - disabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the constant addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.1 - enabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the start addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.the address automatically increments based on the micro_ra_wrdatasize field afterthe write has been performed
 *     MICRO_AUTOINC_RDADDR_EN Automatic increment read address enable0 - disabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the constant addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw fileds1 - enabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the start addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw filedsthe address automatically increments based on the micro_ra_rddatasize field afterthe read has been performed
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r (0x0001d202 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_ctl0[1];
	uint32_t _uc_ahb_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_CLR(r) (r).uc_ahb_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_SET(r,d) (r).uc_ahb_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_GET(r) (r).uc_ahb_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 8) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 4) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET(r) (((r).uc_ahb_ctl0[0]) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access UC_AHB_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r
#define UC_AHB_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_t UC_AHB_CTL0r_t;
#define UC_AHB_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_CLR
#define UC_AHB_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_SET
#define UC_AHB_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_RA_INITf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET
#define UC_AHB_CTL0r_MICRO_RA_INITf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET
#define READ_UC_AHB_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_CTL0r
#define WRITE_UC_AHB_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_CTL0r
#define MODIFY_UC_AHB_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_CTL0r
#define READLN_UC_AHB_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_CTL0r
#define WRITELN_UC_AHB_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_CTL0r
#define WRITEALL_UC_AHB_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_STS0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd203
 * DEVAD:    1
 * DESC:     rmi to ahb status registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_INITDONE When this bit is set, it indicate that code/data RAM initialization process is completeThis reamins set until
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r (0x0001d203 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_sts0[1];
	uint32_t _uc_ahb_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_CLR(r) (r).uc_ahb_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_SET(r,d) (r).uc_ahb_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_GET(r) (r).uc_ahb_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET(r) (((r).uc_ahb_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET(r,f) (r).uc_ahb_sts0[0]=(((r).uc_ahb_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_AHB_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r
#define UC_AHB_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_t UC_AHB_STS0r_t;
#define UC_AHB_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_CLR
#define UC_AHB_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_SET
#define UC_AHB_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET
#define READ_UC_AHB_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_STS0r
#define WRITE_UC_AHB_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_STS0r
#define MODIFY_UC_AHB_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_STS0r
#define READLN_UC_AHB_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_STS0r
#define WRITELN_UC_AHB_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_STS0r
#define WRITEALL_UC_AHB_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd204
 * DEVAD:    1
 * DESC:     rmi to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during write transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactions
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr (0x0001d204 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_lsw[1];
	uint32_t _uc_ahb_wraddr_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_CLR(r) (r).uc_ahb_wraddr_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_SET(r,d) (r).uc_ahb_wraddr_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_GET(r) (r).uc_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET(r) (((r).uc_ahb_wraddr_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET(r,f) (r).uc_ahb_wraddr_lsw[0]=(((r).uc_ahb_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr
#define UC_AHB_WRADDR_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_t UC_AHB_WRADDR_LSWr_t;
#define UC_AHB_WRADDR_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_CLR
#define UC_AHB_WRADDR_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_SET
#define UC_AHB_WRADDR_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET
#define READ_UC_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRADDR_LSWr
#define WRITE_UC_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRADDR_LSWr
#define MODIFY_UC_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRADDR_LSWr
#define READLN_UC_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRADDR_LSWr
#define WRITELN_UC_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRADDR_LSWr
#define WRITEALL_UC_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd205
 * DEVAD:    1
 * DESC:     rmi to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during write transactions
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr (0x0001d205 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_MSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_msw[1];
	uint32_t _uc_ahb_wraddr_msw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_CLR(r) (r).uc_ahb_wraddr_msw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_SET(r,d) (r).uc_ahb_wraddr_msw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_GET(r) (r).uc_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET(r) (((r).uc_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET(r,f) (r).uc_ahb_wraddr_msw[0]=(((r).uc_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_MSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr
#define UC_AHB_WRADDR_MSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_t UC_AHB_WRADDR_MSWr_t;
#define UC_AHB_WRADDR_MSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_CLR
#define UC_AHB_WRADDR_MSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_SET
#define UC_AHB_WRADDR_MSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET
#define READ_UC_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRADDR_MSWr
#define WRITE_UC_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRADDR_MSWr
#define MODIFY_UC_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRADDR_MSWr
#define READLN_UC_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRADDR_MSWr
#define WRITELN_UC_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRADDR_MSWr
#define WRITEALL_UC_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_WRDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd206
 * DEVAD:    1
 * DESC:     rmi to ahb write data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_LSW These bits are used to generate the lower 16-bits of the data on the AHB-Lite bus during write transactionsWrite transaction on the AHB-Lite is initiated when this register is written
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr (0x0001d206 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_lsw[1];
	uint32_t _uc_ahb_wrdata_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_CLR(r) (r).uc_ahb_wrdata_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_SET(r,d) (r).uc_ahb_wrdata_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_GET(r) (r).uc_ahb_wrdata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET(r) (((r).uc_ahb_wrdata_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET(r,f) (r).uc_ahb_wrdata_lsw[0]=(((r).uc_ahb_wrdata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr
#define UC_AHB_WRDATA_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_t UC_AHB_WRDATA_LSWr_t;
#define UC_AHB_WRDATA_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_CLR
#define UC_AHB_WRDATA_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_SET
#define UC_AHB_WRDATA_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET
#define READ_UC_AHB_WRDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRDATA_LSWr
#define WRITE_UC_AHB_WRDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRDATA_LSWr
#define MODIFY_UC_AHB_WRDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRDATA_LSWr
#define READLN_UC_AHB_WRDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRDATA_LSWr
#define WRITELN_UC_AHB_WRDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRDATA_LSWr
#define WRITEALL_UC_AHB_WRDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_WRDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd207
 * DEVAD:    1
 * DESC:     rmi to ahb write data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_MSW These bits are used  to generate the upper 16-bits of the data on the AHB-Lite bus during write transactions
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr (0x0001d207 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_MSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_msw[1];
	uint32_t _uc_ahb_wrdata_msw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_CLR(r) (r).uc_ahb_wrdata_msw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_SET(r,d) (r).uc_ahb_wrdata_msw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_GET(r) (r).uc_ahb_wrdata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET(r) (((r).uc_ahb_wrdata_msw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET(r,f) (r).uc_ahb_wrdata_msw[0]=(((r).uc_ahb_wrdata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_MSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr
#define UC_AHB_WRDATA_MSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_t UC_AHB_WRDATA_MSWr_t;
#define UC_AHB_WRDATA_MSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_CLR
#define UC_AHB_WRDATA_MSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_SET
#define UC_AHB_WRDATA_MSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET
#define READ_UC_AHB_WRDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_WRDATA_MSWr
#define WRITE_UC_AHB_WRDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_WRDATA_MSWr
#define MODIFY_UC_AHB_WRDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_WRDATA_MSWr
#define READLN_UC_AHB_WRDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_WRDATA_MSWr
#define WRITELN_UC_AHB_WRDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_WRDATA_MSWr
#define WRITEALL_UC_AHB_WRDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_WRDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_RDADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd208
 * DEVAD:    1
 * DESC:     rmi to ahb read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during read transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactionsRead transaction is initiated on the AHB-Lite when this register is written
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr (0x0001d208 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_lsw[1];
	uint32_t _uc_ahb_rdaddr_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_CLR(r) (r).uc_ahb_rdaddr_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_SET(r,d) (r).uc_ahb_rdaddr_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_GET(r) (r).uc_ahb_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET(r) (((r).uc_ahb_rdaddr_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET(r,f) (r).uc_ahb_rdaddr_lsw[0]=(((r).uc_ahb_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr
#define UC_AHB_RDADDR_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_t UC_AHB_RDADDR_LSWr_t;
#define UC_AHB_RDADDR_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_CLR
#define UC_AHB_RDADDR_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_SET
#define UC_AHB_RDADDR_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET
#define READ_UC_AHB_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDADDR_LSWr
#define WRITE_UC_AHB_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDADDR_LSWr
#define MODIFY_UC_AHB_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDADDR_LSWr
#define READLN_UC_AHB_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDADDR_LSWr
#define WRITELN_UC_AHB_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDADDR_LSWr
#define WRITEALL_UC_AHB_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_RDADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd209
 * DEVAD:    1
 * DESC:     rmi to ahb read address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_MSW These bits are used by to generate the upper 16-bits of the address on the AHB-Lite bus during read transactions
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr (0x0001d209 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_MSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_msw[1];
	uint32_t _uc_ahb_rdaddr_msw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_CLR(r) (r).uc_ahb_rdaddr_msw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_SET(r,d) (r).uc_ahb_rdaddr_msw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_GET(r) (r).uc_ahb_rdaddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET(r) (((r).uc_ahb_rdaddr_msw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET(r,f) (r).uc_ahb_rdaddr_msw[0]=(((r).uc_ahb_rdaddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_MSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr
#define UC_AHB_RDADDR_MSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_t UC_AHB_RDADDR_MSWr_t;
#define UC_AHB_RDADDR_MSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_CLR
#define UC_AHB_RDADDR_MSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_SET
#define UC_AHB_RDADDR_MSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET
#define READ_UC_AHB_RDADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDADDR_MSWr
#define WRITE_UC_AHB_RDADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDADDR_MSWr
#define MODIFY_UC_AHB_RDADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDADDR_MSWr
#define READLN_UC_AHB_RDADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDADDR_MSWr
#define WRITELN_UC_AHB_RDADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDADDR_MSWr
#define WRITEALL_UC_AHB_RDADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_RDDATA_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20a
 * DEVAD:    1
 * DESC:     rmi to ahb read data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_LSW These are the lower 16-bits of the read data from the AHB-Lite slave deviceRead transaction is initiated on the AHB-Lite when this register is read
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr (0x0001d20a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_lsw[1];
	uint32_t _uc_ahb_rddata_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_CLR(r) (r).uc_ahb_rddata_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_SET(r,d) (r).uc_ahb_rddata_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_GET(r) (r).uc_ahb_rddata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET(r) (((r).uc_ahb_rddata_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET(r,f) (r).uc_ahb_rddata_lsw[0]=(((r).uc_ahb_rddata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr
#define UC_AHB_RDDATA_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_t UC_AHB_RDDATA_LSWr_t;
#define UC_AHB_RDDATA_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_CLR
#define UC_AHB_RDDATA_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_SET
#define UC_AHB_RDDATA_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET
#define READ_UC_AHB_RDDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDDATA_LSWr
#define WRITE_UC_AHB_RDDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDDATA_LSWr
#define MODIFY_UC_AHB_RDDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDDATA_LSWr
#define READLN_UC_AHB_RDDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDDATA_LSWr
#define WRITELN_UC_AHB_RDDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDDATA_LSWr
#define WRITEALL_UC_AHB_RDDATA_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_AHB_RDDATA_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20b
 * DEVAD:    1
 * DESC:     rmi to ahb read data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_MSW These are the upper 16-bits of the read data from the AHB-Lite slave device
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr (0x0001d20b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_MSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_msw[1];
	uint32_t _uc_ahb_rddata_msw;
} BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_CLR(r) (r).uc_ahb_rddata_msw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_SET(r,d) (r).uc_ahb_rddata_msw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_GET(r) (r).uc_ahb_rddata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET(r) (((r).uc_ahb_rddata_msw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET(r,f) (r).uc_ahb_rddata_msw[0]=(((r).uc_ahb_rddata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_MSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr
#define UC_AHB_RDDATA_MSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_t UC_AHB_RDDATA_MSWr_t;
#define UC_AHB_RDDATA_MSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_CLR
#define UC_AHB_RDDATA_MSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_SET
#define UC_AHB_RDDATA_MSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET
#define READ_UC_AHB_RDDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_AHB_RDDATA_MSWr
#define WRITE_UC_AHB_RDDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_AHB_RDDATA_MSWr
#define MODIFY_UC_AHB_RDDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_AHB_RDDATA_MSWr
#define READLN_UC_AHB_RDDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_AHB_RDDATA_MSWr
#define WRITELN_UC_AHB_RDDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_AHB_RDDATA_MSWr
#define WRITEALL_UC_AHB_RDDATA_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_AHB_RDDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_PRAMIF_CTL0
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20c
 * DEVAD:    1
 * DESC:     pram i/f to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_EN  When this bit is set, pram if interface can generate write transactions on theAHB-Lite bus, the start address of the transaction is specifieldin the pramif_ahb_wraddr_lsw and pramif_ahb_wraddr_msw fields
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r (0x0001d20c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_pramif_ctl0[1];
	uint32_t _uc_pramif_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_CLR(r) (r).uc_pramif_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_SET(r,d) (r).uc_pramif_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_GET(r) (r).uc_pramif_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET(r) (((r).uc_pramif_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET(r,f) (r).uc_pramif_ctl0[0]=(((r).uc_pramif_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_PRAMIF_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PRAMIF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r
#define UC_PRAMIF_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_t UC_PRAMIF_CTL0r_t;
#define UC_PRAMIF_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_CLR
#define UC_PRAMIF_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_SET
#define UC_PRAMIF_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET
#define READ_UC_PRAMIF_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_PRAMIF_CTL0r
#define WRITE_UC_PRAMIF_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PRAMIF_CTL0r
#define MODIFY_UC_PRAMIF_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PRAMIF_CTL0r
#define READLN_UC_PRAMIF_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PRAMIF_CTL0r
#define WRITELN_UC_PRAMIF_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PRAMIF_CTL0r
#define WRITEALL_UC_PRAMIF_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PRAMIF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20d
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_LSW These bits are used to generate the lower 14-bits of the address on the AHB-Lite bus during pram interface write transactionsbits[1:0] are not used for 32 transactions
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr (0x0001d20d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_lsw[1];
	uint32_t _uc_pramif_ahb_wraddr_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR(r) (r).uc_pramif_ahb_wraddr_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET(r) (r).uc_pramif_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET(r) ((((r).uc_pramif_ahb_wraddr_lsw[0]) >> 2) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_lsw[0]=(((r).uc_pramif_ahb_wraddr_lsw[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr
#define UC_PRAMIF_AHB_WRADDR_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t UC_PRAMIF_AHB_WRADDR_LSWr_t;
#define UC_PRAMIF_AHB_WRADDR_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET
#define UC_PRAMIF_AHB_WRADDR_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A
 * REGADDR:  0xd20e
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during pram interface write transactions
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr (0x0001d20e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_MSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_msw[1];
	uint32_t _uc_pramif_ahb_wraddr_msw;
} BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR(r) (r).uc_pramif_ahb_wraddr_msw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_msw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET(r) (r).uc_pramif_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET(r) (((r).uc_pramif_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_msw[0]=(((r).uc_pramif_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_MSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr
#define UC_PRAMIF_AHB_WRADDR_MSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t UC_PRAMIF_AHB_WRADDR_MSWr_t;
#define UC_PRAMIF_AHB_WRADDR_MSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_MSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET
#define UC_PRAMIF_AHB_WRADDR_MSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_PVT_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd210
 * DEVAD:    1
 * DESC:     pvt temperature status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_RMI temperature data{6'd0,tempearture_data[9:0]}reads the current value of the temperature data capatured
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r (0x0001d210 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PVT_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_s {
	uint32_t v[1];
	uint32_t uc_pvt_sts0[1];
	uint32_t _uc_pvt_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_CLR(r) (r).uc_pvt_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_SET(r,d) (r).uc_pvt_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_GET(r) (r).uc_pvt_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET(r) (((r).uc_pvt_sts0[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET(r,f) (r).uc_pvt_sts0[0]=(((r).uc_pvt_sts0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_PVT_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PVT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PVT_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PVT_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pvt_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PVT_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r
#define UC_PVT_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_t UC_PVT_STS0r_t;
#define UC_PVT_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_CLR
#define UC_PVT_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_SET
#define UC_PVT_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET
#define READ_UC_PVT_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_PVT_STS0r
#define WRITE_UC_PVT_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_PVT_STS0r
#define MODIFY_UC_PVT_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_PVT_STS0r
#define READLN_UC_PVT_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_PVT_STS0r
#define WRITELN_UC_PVT_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_PVT_STS0r
#define WRITEALL_UC_PVT_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_PVT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_PVT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_AHB_CTL1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd211
 * DEVAD:    1
 * DESC:     ahb control register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_ACK_TIMEOUT_DIS pmi_hp_ack_timeout disableWhen micro initates a read/write transctions on the pmi_hp busit allows upto 256 clock cycles for pmi_hp_ack to be assertedIf pmi_hp_ack_* is not received within this time, then it1. terminates the current transactions on the pmi_hp bus2. set the pmi_hp_ack_timeout_status field of the ahbcommon_pmi_hp_status0 register.3. performs the response error signaling on the micro AHB bus when micro_m0p_hresp_en field is set to 1'b1This timeout period/error reporting/reponse error signaling can be disabled by setting this field i.e.0: enabled1: disabled
 *     MICRO_RA_ARG_MICROBLK_SEL select micro to access it's amba bus registers through the registers interface0 - select micro 0 amba registers1 - select micro 1 amba registers2 - select micro 2 amba registers3 - select micro 3 amba registers
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r (0x0001d211 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_ctl1[1];
	uint32_t _uc_rmi_ahb_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_CLR(r) (r).uc_rmi_ahb_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_SET(r,d) (r).uc_rmi_ahb_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_GET(r) (r).uc_rmi_ahb_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 4) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET(r) (((r).uc_rmi_ahb_ctl1[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_CTL1r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r
#define UC_RMI_AHB_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_t UC_RMI_AHB_CTL1r_t;
#define UC_RMI_AHB_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_CLR
#define UC_RMI_AHB_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_SET
#define UC_RMI_AHB_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_GET
#define UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_GET
#define UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_RA_ARG_MICROBLK_SELf_SET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_GET
#define UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r_MICRO_PMI_HP_ACK_TIMEOUT_DISf_SET
#define READ_UC_RMI_AHB_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_AHB_CTL1r
#define WRITE_UC_RMI_AHB_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_AHB_CTL1r
#define MODIFY_UC_RMI_AHB_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_AHB_CTL1r
#define READLN_UC_RMI_AHB_CTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_AHB_CTL1r
#define WRITELN_UC_RMI_AHB_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_AHB_CTL1r
#define WRITEALL_UC_RMI_AHB_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_AHB_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_AHB_STS1
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd212
 * DEVAD:    1
 * DESC:     ahb status register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_DEFAULT_SLAVE_ERROR register interface default slave error detected. Register interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_PR_DEFAULT_SLAVE_ERROR PRAM interface default slave error detected. PRAM interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r (0x0001d212 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_STS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_sts1[1];
	uint32_t _uc_rmi_ahb_sts1;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_CLR(r) (r).uc_rmi_ahb_sts1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_SET(r,d) (r).uc_rmi_ahb_sts1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_GET(r) (r).uc_rmi_ahb_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET(r) (((r).uc_rmi_ahb_sts1[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_STS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_AHB_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_STS1r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r
#define UC_RMI_AHB_STS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_t UC_RMI_AHB_STS1r_t;
#define UC_RMI_AHB_STS1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_CLR
#define UC_RMI_AHB_STS1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_SET
#define UC_RMI_AHB_STS1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET
#define READ_UC_RMI_AHB_STS1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_AHB_STS1r
#define WRITE_UC_RMI_AHB_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_AHB_STS1r
#define MODIFY_UC_RMI_AHB_STS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_AHB_STS1r
#define READLN_UC_RMI_AHB_STS1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_AHB_STS1r
#define WRITELN_UC_RMI_AHB_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_AHB_STS1r
#define WRITEALL_UC_RMI_AHB_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_AHB_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_AHB_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd213
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_WRADDR_LSW When the micro_autoinc_wraddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr (0x0001d213 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_wraddr_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_RDADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd214
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_RDADDR_LSW When the micro_autoinc_rdaddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next read transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr (0x0001d214 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_rdaddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_rdaddr_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_PR_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd215
 * DEVAD:    1
 * DESC:     pram i/f to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PR_AUTOINC_NXT_WRADDR_LSW When pram interface is used to write to the code/data RAMthen these bits indicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr (0x0001d215 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_pr_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_pr_ainc_nxt_wraddr_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_PVT_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd216
 * DEVAD:    1
 * DESC:     rmi pvt temperature control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_FRCVAL temperature data force valueWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 *     MICRO_PVT_TEMPDATA_FRC temperature dat force enableWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r (0x0001d216 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PVT_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pvt_ctl0[1];
	uint32_t _uc_rmi_pvt_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_CLR(r) (r).uc_rmi_pvt_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_SET(r,d) (r).uc_rmi_pvt_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_GET(r) (r).uc_rmi_pvt_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET(r) ((((r).uc_rmi_pvt_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET(r) (((r).uc_rmi_pvt_ctl0[0]) & 0x3ff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_RMI_PVT_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pvt_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PVT_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r
#define UC_RMI_PVT_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_t UC_RMI_PVT_CTL0r_t;
#define UC_RMI_PVT_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_CLR
#define UC_RMI_PVT_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_SET
#define UC_RMI_PVT_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET
#define READ_UC_RMI_PVT_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_PVT_CTL0r
#define WRITE_UC_RMI_PVT_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_PVT_CTL0r
#define MODIFY_UC_RMI_PVT_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_PVT_CTL0r
#define READLN_UC_RMI_PVT_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_PVT_CTL0r
#define WRITELN_UC_RMI_PVT_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_PVT_CTL0r
#define WRITEALL_UC_RMI_PVT_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_PVT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PVT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_RAM_CR_CRCCTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd217
 * DEVAD:    1
 * DESC:     code ram crc control 0 register
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_CRC_CALC_EN Calculate/Update Code RAM CRC16 CCITT checksum enable1: calculate new CRC16 CCITT checksum when code RAM is written0: do not calculate (or stop calculating) CRC16 CCITT checksum when code RAM is written
 *     MICRO_CR_CRC_INIT Code RAM CRC16 CCITT checksum initializeWhen thes micro_cr_crc_init is set to 1'b1, it initialize CRC16 CCITT checksum to 16'hFFFF{micro_cr_crc_init, micro_cr_crc_calc_en}2'b1x   - initialize crc checksum to 16'hFFFF2'b01   - update/calculate CRC upon writes to the code RAM
 *     MICRO_CR_CRC_PRTSEL This field selects the Code RAM port to be used for CRC calculation0 - Select Port A1 - Select Port B
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r (0x0001d217 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RAM_CR_CRCCTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ram_cr_crcctl0[1];
	uint32_t _uc_rmi_ram_cr_crcctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_CLR(r) (r).uc_rmi_ram_cr_crcctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SET(r,d) (r).uc_rmi_ram_cr_crcctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_GET(r) (r).uc_rmi_ram_cr_crcctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_GET(r) ((((r).uc_rmi_ram_cr_crcctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_SET(r,f) (r).uc_rmi_ram_cr_crcctl0[0]=(((r).uc_rmi_ram_cr_crcctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_GET(r) ((((r).uc_rmi_ram_cr_crcctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_SET(r,f) (r).uc_rmi_ram_cr_crcctl0[0]=(((r).uc_rmi_ram_cr_crcctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_GET(r) (((r).uc_rmi_ram_cr_crcctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_SET(r,f) (r).uc_rmi_ram_cr_crcctl0[0]=(((r).uc_rmi_ram_cr_crcctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_RAM_CR_CRCCTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r,(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r,(_r._uc_rmi_ram_cr_crcctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r,(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RAM_CR_CRCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RAM_CR_CRCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ram_cr_crcctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RAM_CR_CRCCTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r
#define UC_RMI_RAM_CR_CRCCTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_t UC_RMI_RAM_CR_CRCCTL0r_t;
#define UC_RMI_RAM_CR_CRCCTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_CLR
#define UC_RMI_RAM_CR_CRCCTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_SET
#define UC_RMI_RAM_CR_CRCCTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_PRTSELf_SET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_INITf_SET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_GET
#define UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r_MICRO_CR_CRC_CALC_ENf_SET
#define READ_UC_RMI_RAM_CR_CRCCTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RAM_CR_CRCCTL0r
#define WRITE_UC_RMI_RAM_CR_CRCCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RAM_CR_CRCCTL0r
#define MODIFY_UC_RMI_RAM_CR_CRCCTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RAM_CR_CRCCTL0r
#define READLN_UC_RMI_RAM_CR_CRCCTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RAM_CR_CRCCTL0r
#define WRITELN_UC_RMI_RAM_CR_CRCCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RAM_CR_CRCCTL0r
#define WRITEALL_UC_RMI_RAM_CR_CRCCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_RAM_CR_CRCSTS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd218
 * DEVAD:    1
 * DESC:     code ram crc status 0 register
 * RESETVAL: 0xffff (65535)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_CR_CRC_CHECKSUM This field indicate the current crc16 ccitt checksum.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r (0x0001d218 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RAM_CR_CRCSTS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ram_cr_crcsts0[1];
	uint32_t _uc_rmi_ram_cr_crcsts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_CLR(r) (r).uc_rmi_ram_cr_crcsts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SET(r,d) (r).uc_rmi_ram_cr_crcsts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_GET(r) (r).uc_rmi_ram_cr_crcsts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_GET(r) (((r).uc_rmi_ram_cr_crcsts0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_SET(r,f) (r).uc_rmi_ram_cr_crcsts0[0]=(((r).uc_rmi_ram_cr_crcsts0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RAM_CR_CRCSTS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r,(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r,(_r._uc_rmi_ram_cr_crcsts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r,(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RAM_CR_CRCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RAM_CR_CRCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ram_cr_crcsts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ram_cr_crcsts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RAM_CR_CRCSTS0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r
#define UC_RMI_RAM_CR_CRCSTS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_t UC_RMI_RAM_CR_CRCSTS0r_t;
#define UC_RMI_RAM_CR_CRCSTS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_CLR
#define UC_RMI_RAM_CR_CRCSTS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_SET
#define UC_RMI_RAM_CR_CRCSTS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_GET
#define UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_GET
#define UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r_MICRO_CR_CRC_CHECKSUMf_SET
#define READ_UC_RMI_RAM_CR_CRCSTS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_RAM_CR_CRCSTS0r
#define WRITE_UC_RMI_RAM_CR_CRCSTS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_RAM_CR_CRCSTS0r
#define MODIFY_UC_RMI_RAM_CR_CRCSTS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_RAM_CR_CRCSTS0r
#define READLN_UC_RMI_RAM_CR_CRCSTS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_RAM_CR_CRCSTS0r
#define WRITELN_UC_RMI_RAM_CR_CRCSTS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_RAM_CR_CRCSTS0r
#define WRITEALL_UC_RMI_RAM_CR_CRCSTS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_RAM_CR_CRCSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_RAM_CR_CRCSTS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_HARDFAULT_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd219
 * DEVAD:    1
 * DESC:     micro hard fault control 0 register
 * RESETVAL: 0xe01 (3585)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_ERROR_INTR_EN Enable interrupt on IRQ2 when pmi_hp_error signal is asserted by RMICduring pmi_hp bus tranactions1 - Enable0 - Disable
 *     MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_EN Enable interrupt on IRQ2 when M0P performs 32-bit operations to access on pmi_hp busOnly 8/16-bits operations are allowed1 - Enable interrupt on IRQ20 - Disable
 *     MICRO_PMI_HP_ACK_TIMEOUT_INTR_EN Enable interrupt on IRQ2 when pmi_hp_ack signal timeout on the pmi_hp busdoes not toggle within 256 clock cycle1 - Enable0 - Disable
 *     MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_EN Enable interrupt on IRQ2 when M0P detects default slave error.Default slave error are detected when M0P attempted to access un-used address1 - Enable0 - Disable
 *     MICRO_PMI_HP_ERROR_HRESP_EN Enable HRESP hard fault signaling when pmi_hp_error signal is asserted by RMICduring pmi_hp bus tranactions1 - Enable0 - Disable
 *     MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_EN Enable HRESP hard fault signaling when M0P performs 32-bit operations to access on pmi_hp busOnly 8/16-bits operations are allowed1 - Enable interrupt on IRQ20 - Disable
 *     MICRO_PMI_HP_ACK_TIMEOUT_HRESP_EN Enable HRESP hard fault signaling  when pmi_hp_ack signal timeout on the pmi_hp busdoes not toggle within 256 clock cycle1 - Enable0 - Disable
 *     MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_EN Enable HRESP hard fault signaling when M0P detects default slave error.Default slave error are detected when M0P attempted to access un-used address1 - Enable0 - Disable
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r (0x0001d219 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_HARDFAULT_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_hardfault_ctl0[1];
	uint32_t _uc_rmi_uc_hardfault_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_CLR(r) (r).uc_rmi_uc_hardfault_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SET(r,d) (r).uc_rmi_uc_hardfault_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_GET(r) (r).uc_rmi_uc_hardfault_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_uc_hardfault_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_GET(r) (((r).uc_rmi_uc_hardfault_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_SET(r,f) (r).uc_rmi_uc_hardfault_ctl0[0]=(((r).uc_rmi_uc_hardfault_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_UC_HARDFAULT_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r,(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r,(_r._uc_rmi_uc_hardfault_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r,(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_hardfault_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_HARDFAULT_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_hardfault_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_HARDFAULT_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r
#define UC_RMI_UC_HARDFAULT_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_t UC_RMI_UC_HARDFAULT_CTL0r_t;
#define UC_RMI_UC_HARDFAULT_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_CLR
#define UC_RMI_UC_HARDFAULT_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_HRESP_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_INTR_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ACK_TIMEOUT_INTR_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_WORD_ACCESS_ERR_INTR_ENf_SET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_GET
#define UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r_MICRO_PMI_HP_ERROR_INTR_ENf_SET
#define READ_UC_RMI_UC_HARDFAULT_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_HARDFAULT_CTL0r
#define WRITE_UC_RMI_UC_HARDFAULT_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_HARDFAULT_CTL0r
#define MODIFY_UC_RMI_UC_HARDFAULT_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_HARDFAULT_CTL0r
#define READLN_UC_RMI_UC_HARDFAULT_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_HARDFAULT_CTL0r
#define WRITELN_UC_RMI_UC_HARDFAULT_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_HARDFAULT_CTL0r
#define WRITEALL_UC_RMI_UC_HARDFAULT_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_HARDFAULT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_HARDFAULT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_SDK_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21a
 * DEVAD:    1
 * DESC:     micro SDK status 0 register
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_UC_ACTIVE_0 Indicates if micro core 0 is active1 - active0 - not active
 *     MICRO_UC_ACTIVE_1 Indicates if micro core 1 is active1 - active0 - not active
 *     MICRO_UC_ACTIVE_2 Indicates if micro core 2 is active1 - active0 - not active
 *     MICRO_UC_ACTIVE_3 Indicates if micro core 3 is active1 - active0 - not active
 *     MICRO_NUM_UC_CORES Number of micro cores in the micro controller subsystemrange is 1 to 15
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r (0x0001d21a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_SDK_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_sdk_sts0[1];
	uint32_t _uc_rmi_uc_sdk_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_CLR(r) (r).uc_rmi_uc_sdk_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_SET(r,d) (r).uc_rmi_uc_sdk_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_GET(r) (r).uc_rmi_uc_sdk_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 12) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_GET(r) ((((r).uc_rmi_uc_sdk_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_GET(r) (((r).uc_rmi_uc_sdk_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_SET(r,f) (r).uc_rmi_uc_sdk_sts0[0]=(((r).uc_rmi_uc_sdk_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_UC_SDK_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r,(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r,(_r._uc_rmi_uc_sdk_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r,(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_SDK_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_SDK_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_sdk_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_SDK_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_sdk_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_SDK_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r
#define UC_RMI_UC_SDK_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_t UC_RMI_UC_SDK_STS0r_t;
#define UC_RMI_UC_SDK_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_CLR
#define UC_RMI_UC_SDK_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_SET
#define UC_RMI_UC_SDK_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_NUM_UC_CORESf_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_3f_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_2f_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_1f_SET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_GET
#define UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r_MICRO_UC_ACTIVE_0f_SET
#define READ_UC_RMI_UC_SDK_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_SDK_STS0r
#define WRITE_UC_RMI_UC_SDK_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_SDK_STS0r
#define MODIFY_UC_RMI_UC_SDK_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_SDK_STS0r
#define READLN_UC_RMI_UC_SDK_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_SDK_STS0r
#define WRITELN_UC_RMI_UC_SDK_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_SDK_STS0r
#define WRITEALL_UC_RMI_UC_SDK_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_SDK_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_SDK_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_DBGGER_ID_LSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21b
 * DEVAD:    1
 * DESC:     micro debugger id bits [15:0]
 * RESETVAL: 0x617f (24959)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_DEBUGGER_ID_LSW micro debugger id bits [15:0]32bit debugger id consists of [31:0] = {micro core instance_id[3:0], prtad_strap[4:0], revid0[10:0], brcm jtag id bits [11:0]}Where:micro core instance id[3:0]  = 0,1,2,3..15 for micro core 0,1,2,3..15. Maps to bits [31:28]. Please see micro_num_uc_coresprtad_strap[4:0]             = external input, shared with mdio controller. Maps to bits [27:23]revid0[10:0]                 = revid0 bits [10:0]. Map bits[22:12]BRCM jtag ID[11:0]           = {JEP106 continuation[3:0], JEP106 identification[6:0], 1'b1} = 12'h17F. Maps to bits [11:0]
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr (0x0001d21b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_DBGGER_ID_LSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_dbgger_id_lsw[1];
	uint32_t _uc_rmi_uc_dbgger_id_lsw;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_CLR(r) (r).uc_rmi_uc_dbgger_id_lsw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SET(r,d) (r).uc_rmi_uc_dbgger_id_lsw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_GET(r) (r).uc_rmi_uc_dbgger_id_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_GET(r) (((r).uc_rmi_uc_dbgger_id_lsw[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_SET(r,f) (r).uc_rmi_uc_dbgger_id_lsw[0]=(((r).uc_rmi_uc_dbgger_id_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_DBGGER_ID_LSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr,(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr,(_r._uc_rmi_uc_dbgger_id_lsw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr,(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_lsw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_LSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_dbgger_id_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_DBGGER_ID_LSWr BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr
#define UC_RMI_UC_DBGGER_ID_LSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_t UC_RMI_UC_DBGGER_ID_LSWr_t;
#define UC_RMI_UC_DBGGER_ID_LSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_CLR
#define UC_RMI_UC_DBGGER_ID_LSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_SET
#define UC_RMI_UC_DBGGER_ID_LSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_GET
#define UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_GET
#define UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr_MICRO_DEBUGGER_ID_LSWf_SET
#define READ_UC_RMI_UC_DBGGER_ID_LSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_DBGGER_ID_LSWr
#define WRITE_UC_RMI_UC_DBGGER_ID_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_LSWr
#define MODIFY_UC_RMI_UC_DBGGER_ID_LSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_LSWr
#define READLN_UC_RMI_UC_DBGGER_ID_LSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_DBGGER_ID_LSWr
#define WRITELN_UC_RMI_UC_DBGGER_ID_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_LSWr
#define WRITEALL_UC_RMI_UC_DBGGER_ID_LSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_DBGGER_ID_MSW
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21c
 * DEVAD:    1
 * DESC:     micro debugger id bits [27:16]
 * RESETVAL: 0x36 (54)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_DEBUGGER_ID_MSW micro debugger id bits [27:16]32bit debugger id consists of [31:0] = {micro core instance_id[3:0], prtad_strap[4:0], revid0[10:0], brcm jtag id bits [11:0]}Where:micro core instance id[3:0]  = 0,1,2,3..15 for micro core 0,1,2,3..15. Maps to bits [31:28]. Please see micro_num_uc_coresprtad_strap[4:0]             = external input, shared with mdio controller. Maps to bits [27:23]revid0[10:0]                 = revid0 bits [10:0]. Map bits[22:12]BRCM jtag ID[11:0]           = {JEP106 continuation[3:0], JEP106 identification[6:0], 1'b1} = 12'h17F. Maps to bits [11:0]Note: the default value assue prtad_strap = 5'd0
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr (0x0001d21c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_DBGGER_ID_MSW.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_dbgger_id_msw[1];
	uint32_t _uc_rmi_uc_dbgger_id_msw;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_CLR(r) (r).uc_rmi_uc_dbgger_id_msw[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SET(r,d) (r).uc_rmi_uc_dbgger_id_msw[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_GET(r) (r).uc_rmi_uc_dbgger_id_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_GET(r) (((r).uc_rmi_uc_dbgger_id_msw[0]) & 0xfff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_SET(r,f) (r).uc_rmi_uc_dbgger_id_msw[0]=(((r).uc_rmi_uc_dbgger_id_msw[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access UC_RMI_UC_DBGGER_ID_MSW.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr,(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr,(_r._uc_rmi_uc_dbgger_id_msw)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr,(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_id_msw))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_MSWr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_dbgger_id_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_DBGGER_ID_MSWr BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr
#define UC_RMI_UC_DBGGER_ID_MSWr_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_t UC_RMI_UC_DBGGER_ID_MSWr_t;
#define UC_RMI_UC_DBGGER_ID_MSWr_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_CLR
#define UC_RMI_UC_DBGGER_ID_MSWr_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_SET
#define UC_RMI_UC_DBGGER_ID_MSWr_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_GET
#define UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_GET
#define UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr_MICRO_DEBUGGER_ID_MSWf_SET
#define READ_UC_RMI_UC_DBGGER_ID_MSWr BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_DBGGER_ID_MSWr
#define WRITE_UC_RMI_UC_DBGGER_ID_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_DBGGER_ID_MSWr
#define MODIFY_UC_RMI_UC_DBGGER_ID_MSWr BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_DBGGER_ID_MSWr
#define READLN_UC_RMI_UC_DBGGER_ID_MSWr BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_DBGGER_ID_MSWr
#define WRITELN_UC_RMI_UC_DBGGER_ID_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_DBGGER_ID_MSWr
#define WRITEALL_UC_RMI_UC_DBGGER_ID_MSWr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_DBGGER_ID_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_ID_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_MISC_STS0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21d
 * DEVAD:    1
 * DESC:     micro misc status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_WRADDR_MSB When the micro_autoinc_wraddr_en is set to 1, then{micro_ra_autoinc_nxt_wraddr_msb, micro_ra_autoinc_nxt_wraddr_lsw[15:0]}indicate address that will be used during the next write transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 *     MICRO_RA_AUTOINC_NXT_RDADDR_MSB When the micro_autoinc_rdaddr_en is set, then{micro_ra_autoinc_nxt_rdaddr_msb, micro_ra_autoinc_nxt_rdaddr_lsw[15:0]} indicate{address that will be used during the next read transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 *     MICRO_PR_AUTOINC_NXT_WRADDR_MSB When pram interface is used to write to the code/data RAMthen {micro_pr_autoinc_nxt_wraddr_msb, micro_pr_autoinc_nxt_wraddr_lsw[15:0]}indicate the address that will be used during the next write transaction.These bits allow address tracking
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r (0x0001d21d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MISC_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_misc_sts0[1];
	uint32_t _uc_rmi_uc_misc_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_CLR(r) (r).uc_rmi_uc_misc_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_SET(r,d) (r).uc_rmi_uc_misc_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_GET(r) (r).uc_rmi_uc_misc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_GET(r) ((((r).uc_rmi_uc_misc_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_SET(r,f) (r).uc_rmi_uc_misc_sts0[0]=(((r).uc_rmi_uc_misc_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_GET(r) ((((r).uc_rmi_uc_misc_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_SET(r,f) (r).uc_rmi_uc_misc_sts0[0]=(((r).uc_rmi_uc_misc_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_GET(r) (((r).uc_rmi_uc_misc_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_SET(r,f) (r).uc_rmi_uc_misc_sts0[0]=(((r).uc_rmi_uc_misc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_UC_MISC_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r,(_r._uc_rmi_uc_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r,(_r._uc_rmi_uc_misc_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r,(_r._uc_rmi_uc_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MISC_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_misc_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MISC_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_misc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r
#define UC_RMI_UC_MISC_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_t UC_RMI_UC_MISC_STS0r_t;
#define UC_RMI_UC_MISC_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_CLR
#define UC_RMI_UC_MISC_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_SET
#define UC_RMI_UC_MISC_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_PR_AUTOINC_NXT_WRADDR_MSBf_SET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_RDADDR_MSBf_SET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_GET
#define UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r_MICRO_RA_AUTOINC_NXT_WRADDR_MSBf_SET
#define READ_UC_RMI_UC_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MISC_STS0r
#define WRITE_UC_RMI_UC_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MISC_STS0r
#define MODIFY_UC_RMI_UC_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MISC_STS0r
#define READLN_UC_RMI_UC_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MISC_STS0r
#define WRITELN_UC_RMI_UC_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MISC_STS0r
#define WRITEALL_UC_RMI_UC_MISC_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MISC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MISC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_DBGGER_CTL0
 * BLOCKS:   MICRO_B
 * REGADDR:  0xd21e
 * DEVAD:    1
 * DESC:     micro debugger control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_DEBUGGER_ID_FRCVAL micro debugger id bits [27:20] force valueThe micro debugger has 32bit id. Bit 27 to 20 can be forced to different valueusing micro_debugger_id_frc and micro_debugger_id_frcval fields i.e.micro_debugger_id[31:28]  = micro core instance id[3:0], i.e. 0,1,2,3 .... 15micro_debugger_id[27:23]  = micro_debugger_id_frc ? micro_debugger_id_frcval[7:3] : prtad_strap[4:0];micro_debugger_id[22:20]  = micro_debugger_id_frc ? micro_debugger_id_frcval[2:0] : revid0[10:8]micro_debugger_id[19:12]  = revid0[7:0]micro_debugger_id[19:12]  = BRCM jtag ID[11:0]
 *     MICRO_DEBUGGER_ID_FRC micro debugger id force enablemicro_debugger_id_frc and micro_debugger_id_frcval are used to override portion of the micro debugger IDPlease note that the debugger ID should only be changed while all of the micro cores are in reset i.e.micro_master_rstb = 1'b0 to avoid any problems
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r (0x0001d21e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_DBGGER_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_dbgger_ctl0[1];
	uint32_t _uc_rmi_uc_dbgger_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_CLR(r) (r).uc_rmi_uc_dbgger_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_SET(r,d) (r).uc_rmi_uc_dbgger_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_GET(r) (r).uc_rmi_uc_dbgger_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_GET(r) ((((r).uc_rmi_uc_dbgger_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_SET(r,f) (r).uc_rmi_uc_dbgger_ctl0[0]=(((r).uc_rmi_uc_dbgger_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_GET(r) (((r).uc_rmi_uc_dbgger_ctl0[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_SET(r,f) (r).uc_rmi_uc_dbgger_ctl0[0]=(((r).uc_rmi_uc_dbgger_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access UC_RMI_UC_DBGGER_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r,(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r,(_r._uc_rmi_uc_dbgger_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r,(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_DBGGER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_DBGGER_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_dbgger_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_DBGGER_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_dbgger_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_DBGGER_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r
#define UC_RMI_UC_DBGGER_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_t UC_RMI_UC_DBGGER_CTL0r_t;
#define UC_RMI_UC_DBGGER_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_CLR
#define UC_RMI_UC_DBGGER_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_SET
#define UC_RMI_UC_DBGGER_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_GET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_GET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCf_SET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_GET
#define UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r_MICRO_DEBUGGER_ID_FRCVALf_SET
#define READ_UC_RMI_UC_DBGGER_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_DBGGER_CTL0r
#define WRITE_UC_RMI_UC_DBGGER_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_DBGGER_CTL0r
#define MODIFY_UC_RMI_UC_DBGGER_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_DBGGER_CTL0r
#define READLN_UC_RMI_UC_DBGGER_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_DBGGER_CTL0r
#define WRITELN_UC_RMI_UC_DBGGER_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_DBGGER_CTL0r
#define WRITEALL_UC_RMI_UC_DBGGER_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_DBGGER_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_DBGGER_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_ECCCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd220
 * DEVAD:    1
 * DESC:     ram ecc control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_ECCG_MODE ecc code generation mode for code RAM0: Hardware mode - ECC code generated by hardware, ECC error checking enabled1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAMECC error checking disabled. This mode is only supportedwhen register interface is used
 *     MICRO_CR_ECC_FRC_DISABLE ecc force disable for code RAM0: ECC Enabled  - ECC error code generation determine by the micro_eccg_mode fieldECC error checking enabled in hardware mode only1: ECC Disabled - ECC error codes values written into the RAM set to zeroECC error checking disabled
 *     MICRO_CR_ECC_CORRUPT This field allows the ecc codes to be corrupted in code RAM for testing.2'b00 - normal mode2'b01 - corrupt the ECC code written into the code/data RAM2'b10 - corrupt data - add 1 bit data error on the RX side2'b11 - corrupt data - add 2 bit data error on the RA side
 *     MICRO_CR_ECC_DEBUG_PRTSEL The field selects the RAM port to used for ECC debug and software ECC mode:0 - Select Port A1 - Select Port BAssumptions:a.  Only one RAM (code or data) is used during ECC debug, thereforemicro_ra_ecc_wrdata and micro_ra_ecc_rddata fields are sharedbetween Code and Data RAMb.  Only one port RAM (port A or port B) used during ECC debug, thereforemicro_cr_ecc_err_addr, micro_cr_ecc_corr_err, and micro_cr_ecc_corr_errfields are shared between Port A and Port B
 *     MICRO_DR_ECCG_MODE ecc code generation mode for data RAM0: Hardware mode - ECC code generated by hardware, ECC error checking enabled1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAMECC error checking disabled. This mode is only supportedwhen register interface is used
 *     MICRO_DR_ECC_FRC_DISABLE ecc force disable for data RAM0: ECC Enabled  - ECC error code generation determine by the micro_eccg_mode fieldECC error checking enabled in hardware mode only1: ECC Disabled - ECC error codes values written into the RAM set to zeroECC error checking disabled
 *     MICRO_DR_ECC_CORRUPT This field allows the ecc codes to be corrupted in data RAM for testing.2'b00 - normal mode2'b01 - corrupt the ECC code written into the data RAM2'b10 - corrupt data - add 1 bit data error on the RX side2'b11 - corrupt data - add 2 bit data error on the RA side
 *     MICRO_DR_ECC_DEBUG_PRTSEL The field selects the RAM port to used for ECC debug and software ECC mode:0 - Select Port A1 - Select Port BAssumptions:a.  Only one RAM (code or data) is used during ECC debug, thereforemicro_ra_ecc_wrdata and micro_ra_ecc_rddata fields are sharedbetween Code and Data RAMb.  Only one port RAM (port A or port B) used during ECC debug, thereforemicro_dr_ecc_err_addr, micro_dr_ecc_corr_err, and micro_dr_ecc_corr_errfields are shared between Port A and Port B
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r (0x0001d220 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCCTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccctl0[1];
	uint32_t _uc_ram_eccctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_CLR(r) (r).uc_ram_eccctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_SET(r,d) (r).uc_ram_eccctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_GET(r) (r).uc_ram_eccctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 10) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 2) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_GET(r) ((((r).uc_ram_eccctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_GET(r) (((r).uc_ram_eccctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_SET(r,f) (r).uc_ram_eccctl0[0]=(((r).uc_ram_eccctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RAM_ECCCTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r,(_r._uc_ram_eccctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r,(_r._uc_ram_eccctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r,(_r._uc_ram_eccctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCCTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCCTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r
#define UC_RAM_ECCCTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_t UC_RAM_ECCCTL0r_t;
#define UC_RAM_ECCCTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_CLR
#define UC_RAM_ECCCTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_SET
#define UC_RAM_ECCCTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_DEBUG_PRTSELf_SET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_CORRUPTf_SET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECC_FRC_DISABLEf_SET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_GET
#define UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_DR_ECCG_MODEf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_DEBUG_PRTSELf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_CORRUPTf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECC_FRC_DISABLEf_SET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_GET
#define UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r_MICRO_CR_ECCG_MODEf_SET
#define READ_UC_RAM_ECCCTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCCTL0r
#define WRITE_UC_RAM_ECCCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCCTL0r
#define MODIFY_UC_RAM_ECCCTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCCTL0r
#define READLN_UC_RAM_ECCCTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCCTL0r
#define WRITELN_UC_RAM_ECCCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCCTL0r
#define WRITEALL_UC_RAM_ECCCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_ECCCTL1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd221
 * DEVAD:    1
 * DESC:     ram ecc control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_ECC_WRDATA This foield is used to write the ECC codes into the code/data RAM when ECC software modes is enabled
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r (0x0001d221 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCCTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccctl1[1];
	uint32_t _uc_ram_eccctl1;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_CLR(r) (r).uc_ram_eccctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_SET(r,d) (r).uc_ram_eccctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_GET(r) (r).uc_ram_eccctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_GET(r) (((r).uc_ram_eccctl1[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_SET(r,f) (r).uc_ram_eccctl1[0]=(((r).uc_ram_eccctl1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_RAM_ECCCTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r,(_r._uc_ram_eccctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r,(_r._uc_ram_eccctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r,(_r._uc_ram_eccctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCCTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCCTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCCTL1r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r
#define UC_RAM_ECCCTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_t UC_RAM_ECCCTL1r_t;
#define UC_RAM_ECCCTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_CLR
#define UC_RAM_ECCCTL1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_SET
#define UC_RAM_ECCCTL1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_GET
#define UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_GET
#define UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r_MICRO_RA_ECC_WRDATAf_SET
#define READ_UC_RAM_ECCCTL1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCCTL1r
#define WRITE_UC_RAM_ECCCTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCCTL1r
#define MODIFY_UC_RAM_ECCCTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCCTL1r
#define READLN_UC_RAM_ECCCTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCCTL1r
#define WRITELN_UC_RAM_ECCCTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCCTL1r
#define WRITEALL_UC_RAM_ECCCTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_ECCSTS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd222
 * DEVAD:    1
 * DESC:     ram ecc status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_CR_ECC_ADDRESS_STATUS First ecc error address detected in the Code RAM
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r (0x0001d222 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCSTS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccsts0[1];
	uint32_t _uc_ram_eccsts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_CLR(r) (r).uc_ram_eccsts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_SET(r,d) (r).uc_ram_eccsts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_GET(r) (r).uc_ram_eccsts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_GET(r) ((((r).uc_ram_eccsts0[0]) >> 2) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_SET(r,f) (r).uc_ram_eccsts0[0]=(((r).uc_ram_eccsts0[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_RAM_ECCSTS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r,(_r._uc_ram_eccsts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r,(_r._uc_ram_eccsts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r,(_r._uc_ram_eccsts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCSTS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCSTS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccsts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCSTS0r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r
#define UC_RAM_ECCSTS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_t UC_RAM_ECCSTS0r_t;
#define UC_RAM_ECCSTS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_CLR
#define UC_RAM_ECCSTS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_SET
#define UC_RAM_ECCSTS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_GET
#define UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_GET
#define UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r_MICRO_RMI_CR_ECC_ADDRESS_STATUSf_SET
#define READ_UC_RAM_ECCSTS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCSTS0r
#define WRITE_UC_RAM_ECCSTS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCSTS0r
#define MODIFY_UC_RAM_ECCSTS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCSTS0r
#define READLN_UC_RAM_ECCSTS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCSTS0r
#define WRITELN_UC_RAM_ECCSTS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCSTS0r
#define WRITEALL_UC_RAM_ECCSTS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_ECCSTS1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd223
 * DEVAD:    1
 * DESC:     ram ecc status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_ECC_RDDATA When the register interface is used to read code/data RAM, then this field providesECC codes currently stored in the code/data RAM
 *     MICRO_RMI_CR_ECC_ADDRESS_STATUS_16 ECC error address bit 16 detected in the Code RAM
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r (0x0001d223 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCSTS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccsts1[1];
	uint32_t _uc_ram_eccsts1;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_CLR(r) (r).uc_ram_eccsts1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_SET(r,d) (r).uc_ram_eccsts1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_GET(r) (r).uc_ram_eccsts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RMI_CR_ECC_ADDRESS_STATUS_16f_GET(r) ((((r).uc_ram_eccsts1[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RMI_CR_ECC_ADDRESS_STATUS_16f_SET(r,f) (r).uc_ram_eccsts1[0]=(((r).uc_ram_eccsts1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET(r) (((r).uc_ram_eccsts1[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET(r,f) (r).uc_ram_eccsts1[0]=(((r).uc_ram_eccsts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_RAM_ECCSTS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r,(_r._uc_ram_eccsts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r,(_r._uc_ram_eccsts1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r,(_r._uc_ram_eccsts1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCSTS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCSTS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCSTS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccsts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCSTS1r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r
#define UC_RAM_ECCSTS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_t UC_RAM_ECCSTS1r_t;
#define UC_RAM_ECCSTS1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_CLR
#define UC_RAM_ECCSTS1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_SET
#define UC_RAM_ECCSTS1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_GET
#define UC_RAM_ECCSTS1r_MICRO_RMI_CR_ECC_ADDRESS_STATUS_16f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RMI_CR_ECC_ADDRESS_STATUS_16f_GET
#define UC_RAM_ECCSTS1r_MICRO_RMI_CR_ECC_ADDRESS_STATUS_16f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RMI_CR_ECC_ADDRESS_STATUS_16f_SET
#define UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET
#define UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET
#define READ_UC_RAM_ECCSTS1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCSTS1r
#define WRITE_UC_RAM_ECCSTS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCSTS1r
#define MODIFY_UC_RAM_ECCSTS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCSTS1r
#define READLN_UC_RAM_ECCSTS1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCSTS1r
#define WRITELN_UC_RAM_ECCSTS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCSTS1r
#define WRITEALL_UC_RAM_ECCSTS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCSTS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_ECCSTS2
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd224
 * DEVAD:    1
 * DESC:     ram ecc status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_DR_ECC_ADDRESS_STATUS First ecc error address detected in the Data RAM
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r (0x0001d224 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_ECCSTS2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_s {
	uint32_t v[1];
	uint32_t uc_ram_eccsts2[1];
	uint32_t _uc_ram_eccsts2;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_CLR(r) (r).uc_ram_eccsts2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_SET(r,d) (r).uc_ram_eccsts2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_GET(r) (r).uc_ram_eccsts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_GET(r) ((((r).uc_ram_eccsts2[0]) >> 2) & 0x3fff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_SET(r,f) (r).uc_ram_eccsts2[0]=(((r).uc_ram_eccsts2[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_RAM_ECCSTS2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r,(_r._uc_ram_eccsts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r,(_r._uc_ram_eccsts2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r,(_r._uc_ram_eccsts2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCSTS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCSTS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_eccsts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCSTS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_eccsts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_ECCSTS2r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r
#define UC_RAM_ECCSTS2r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_t UC_RAM_ECCSTS2r_t;
#define UC_RAM_ECCSTS2r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_CLR
#define UC_RAM_ECCSTS2r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_SET
#define UC_RAM_ECCSTS2r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_GET
#define UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_GET
#define UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r_MICRO_RMI_DR_ECC_ADDRESS_STATUSf_SET
#define READ_UC_RAM_ECCSTS2r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_ECCSTS2r
#define WRITE_UC_RAM_ECCSTS2r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_ECCSTS2r
#define MODIFY_UC_RAM_ECCSTS2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_ECCSTS2r
#define READLN_UC_RAM_ECCSTS2r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_ECCSTS2r
#define WRITELN_UC_RAM_ECCSTS2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_ECCSTS2r
#define WRITEALL_UC_RAM_ECCSTS2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_ECCSTS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_ECCSTS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_TESTIFCTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd225
 * DEVAD:    1
 * DESC:     ram test interface control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_TM      Code RAM Test Mode.These pins are used to put Code RAM the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<?:0>='d0. It ishighly recommended that the user has control over all thetm<?:0> inputs. All tm<?:0> inputs are asynchronous. Seethe Test Modes section of the on line M16SP WebSpecification for further details.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r (0x0001d225 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_TESTIFCTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_testifctl0[1];
	uint32_t _uc_ram_testifctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_CLR(r) (r).uc_ram_testifctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_SET(r,d) (r).uc_ram_testifctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_GET(r) (r).uc_ram_testifctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_GET(r) (((r).uc_ram_testifctl0[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_SET(r,f) (r).uc_ram_testifctl0[0]=(((r).uc_ram_testifctl0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access UC_RAM_TESTIFCTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r,(_r._uc_ram_testifctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r,(_r._uc_ram_testifctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r,(_r._uc_ram_testifctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_TESTIFCTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_testifctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_TESTIFCTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r
#define UC_RAM_TESTIFCTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_t UC_RAM_TESTIFCTL0r_t;
#define UC_RAM_TESTIFCTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_CLR
#define UC_RAM_TESTIFCTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_SET
#define UC_RAM_TESTIFCTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_GET
#define UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_GET
#define UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r_MICRO_CR_TMf_SET
#define READ_UC_RAM_TESTIFCTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_TESTIFCTL0r
#define WRITE_UC_RAM_TESTIFCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_TESTIFCTL0r
#define MODIFY_UC_RAM_TESTIFCTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_TESTIFCTL0r
#define READLN_UC_RAM_TESTIFCTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_TESTIFCTL0r
#define WRITELN_UC_RAM_TESTIFCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_TESTIFCTL0r
#define WRITEALL_UC_RAM_TESTIFCTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_TESTIFCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_TESTIFCTL1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd226
 * DEVAD:    1
 * DESC:     ram test interface control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_DR_TM      Data RAM Test Mode.These pins are used to put Code RAM the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<?:0>='d0. It ishighly recommended that the user has control over all thetm<?:0> inputs. All tm<?:0> inputs are asynchronous. Seethe Test Modes section of the on line M16SP WebSpecification for further details.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r (0x0001d226 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_TESTIFCTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_s {
	uint32_t v[1];
	uint32_t uc_ram_testifctl1[1];
	uint32_t _uc_ram_testifctl1;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_CLR(r) (r).uc_ram_testifctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_SET(r,d) (r).uc_ram_testifctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_GET(r) (r).uc_ram_testifctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_GET(r) (((r).uc_ram_testifctl1[0]) & 0x1ff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_SET(r,f) (r).uc_ram_testifctl1[0]=(((r).uc_ram_testifctl1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access UC_RAM_TESTIFCTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r,(_r._uc_ram_testifctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r,(_r._uc_ram_testifctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r,(_r._uc_ram_testifctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_TESTIFCTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_TESTIFCTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_testifctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_TESTIFCTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_testifctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_TESTIFCTL1r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r
#define UC_RAM_TESTIFCTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_t UC_RAM_TESTIFCTL1r_t;
#define UC_RAM_TESTIFCTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_CLR
#define UC_RAM_TESTIFCTL1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_SET
#define UC_RAM_TESTIFCTL1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_GET
#define UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_GET
#define UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r_MICRO_DR_TMf_SET
#define READ_UC_RAM_TESTIFCTL1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_TESTIFCTL1r
#define WRITE_UC_RAM_TESTIFCTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_TESTIFCTL1r
#define MODIFY_UC_RAM_TESTIFCTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_TESTIFCTL1r
#define READLN_UC_RAM_TESTIFCTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_TESTIFCTL1r
#define WRITELN_UC_RAM_TESTIFCTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_TESTIFCTL1r
#define WRITEALL_UC_RAM_TESTIFCTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_TESTIFCTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_TESTIFCTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd227
 * DEVAD:    1
 * DESC:     ram configuration register 0
 * RESETVAL: 0x8382 (33666)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_ACCESS_EN Code RAM access enable0 - Disabled. RAM address, data, chip select and write enable are set to inactive stateto prevent timing violations from corrupting the contents of the RAMThe API software should clear this field before loading the firmware and also re-starting the micro1 - Enabled.
 *     MICRO_CR_IGNORE_MICRO_CODE_WRITES Code RAM ignore micro writes to the code portion of the RAM0 - Allow writes1 - Ignore writes
 *     MICRO_CR_RAIF_PRTSEL Selects Code RAM Port to used when accessing the memory through the register interface0 - Port A1 - Port B
 *     MICRO_CR_PRIF_PRTSEL Selects Code RAM Port to used when writing memory through the PRAM interface0 - Port A1 - Port B
 *     MICRO_CR_LOWPOWER_EN Code RAM low power enable1 - Enabled. Gate of the chip select to the Code RAM when memory is not being acccessed to save dynamic power(i.e. mem_cs = ~rg_cr_lowpower_en & rg_master_rstb & rg_cr_access_en).0 - Disabled
 *     MICRO_DR_ACCESS_EN Data RAM access enable0 - Disabled. RAM address, data, chip select and write enable are set to inactive stateto prevent timing violations from corrupting the contents of the RAMThe API software should clear this field before loading the firmware and also re-starting the micro1 - Enabled.
 *     MICRO_DR_IGNORE_MICRO_CODE_WRITES Data RAM ignore micro writes to the code portion of the RAM0 - Allow writes1 - Ignore writes
 *     MICRO_DR_RAIF_PRTSEL Selects Data RAM Port to used when accessing the memory through the register interface0 - Port A1 - Port B
 *     MICRO_DR_PRIF_PRTSEL Selects Data RAM Port to used when writing memory through the PRAM interface0 - Port A1 - Port B
 *     MICRO_DR_LOWPOWER_EN Data RAM low power enable1 - Enabled. Gate of the chip select to the Data RAM when memory is not being acccessed to save dynamic power(i.e. mem_cs = ~rg_dr_lowpower_en & rg_master_rstb & rg_dr_access_en).0 - Disabled
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r (0x0001d227 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl0[1];
	uint32_t _uc_ram_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_CLR(r) (r).uc_ram_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_SET(r,d) (r).uc_ram_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_GET(r) (r).uc_ram_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_GET(r) ((((r).uc_ram_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_GET(r) ((((r).uc_ram_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_GET(r) ((((r).uc_ram_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_GET(r) ((((r).uc_ram_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_GET(r) ((((r).uc_ram_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_GET(r) ((((r).uc_ram_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_GET(r) (((r).uc_ram_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RAM_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r
#define UC_RAM_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_t UC_RAM_CTL0r_t;
#define UC_RAM_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_CLR
#define UC_RAM_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_SET
#define UC_RAM_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_GET
#define UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_GET
#define UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_LOWPOWER_ENf_SET
#define UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_PRIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_RAIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_GET
#define UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_IGNORE_MICRO_CODE_WRITESf_SET
#define UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_GET
#define UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_DR_ACCESS_ENf_SET
#define UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_GET
#define UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_LOWPOWER_ENf_SET
#define UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_PRIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_GET
#define UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_RAIF_PRTSELf_SET
#define UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_GET
#define UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_IGNORE_MICRO_CODE_WRITESf_SET
#define UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_GET
#define UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r_MICRO_CR_ACCESS_ENf_SET
#define READ_UC_RAM_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_CTL0r
#define WRITE_UC_RAM_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_CTL0r
#define MODIFY_UC_RAM_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_CTL0r
#define READLN_UC_RAM_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_CTL0r
#define WRITELN_UC_RAM_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_CTL0r
#define WRITEALL_UC_RAM_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_CTL1
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd228
 * DEVAD:    1
 * DESC:     ram configuration register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CR_DATA_SIZE Code RAM - allocation for data storgaeThe CODE_RAM_SIZE=80KB and this field is used to allocate code RAM for data storgae on a 1KB granualarity7'd0  : code RAM allocation for data = 0KB,  code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data7'd1  : code RAM allocation for data = 1KB,  code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data7'd2  : code RAM allocation for data = 2KB,  code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data...   : code RAM allocation for data = .. ,  code RAM allocation for code = .....   : code RAM allocation for data = .. ,  code RAM allocation for code = ..7'd79 : code RAM allocation for data = 79KB, code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data7'd80 : code RAM allocation for data = 80KB, code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data
 *     MICRO_DR_CODE_SIZE Data RAM - allocation for code storgaeThe DATA_RAM_SIZE=40KB and this field is used to allocate data RAM for code storgae on a 1KB granualarity7'd0  : data RAM allocation for code = 0KB,  data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code7'd1  : data RAM allocation for code = 1KB,  data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code7'd2  : data RAM allocation for code = 2KB,  data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code...   : data RAM allocation for code = .. ,  data RAM allocation for data = .....   : data RAM allocation for code = .. ,  data RAM allocation for data = ..7'd39 : data RAM allocation for code = 39KB, data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code7'd40 : data RAM allocation for code = 40KB, data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r (0x0001d228 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl1[1];
	uint32_t _uc_ram_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_CLR(r) (r).uc_ram_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_SET(r,d) (r).uc_ram_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_GET(r) (r).uc_ram_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_GET(r) ((((r).uc_ram_ctl1[0]) >> 8) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_SET(r,f) (r).uc_ram_ctl1[0]=(((r).uc_ram_ctl1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_GET(r) (((r).uc_ram_ctl1[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_SET(r,f) (r).uc_ram_ctl1[0]=(((r).uc_ram_ctl1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_RAM_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r,(_r._uc_ram_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r,(_r._uc_ram_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r,(_r._uc_ram_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL1r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r
#define UC_RAM_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_t UC_RAM_CTL1r_t;
#define UC_RAM_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_CLR
#define UC_RAM_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_SET
#define UC_RAM_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_GET
#define UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_GET
#define UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_DR_CODE_SIZEf_SET
#define UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_GET
#define UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r_MICRO_CR_DATA_SIZEf_SET
#define READ_UC_RAM_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_CTL1r
#define WRITE_UC_RAM_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_CTL1r
#define MODIFY_UC_RAM_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_CTL1r
#define READLN_UC_RAM_CTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_CTL1r
#define WRITELN_UC_RAM_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_CTL1r
#define WRITEALL_UC_RAM_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd229
 * DEVAD:    1
 * DESC:     rmi external interrupt control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_CR_ECC_CORR_ERR_INTR_EN Code RAM ECC 1 bit correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_EN Code RAM ECC 2 bit un-correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_EN Code RAM ECC error on multiple row detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_DR_ECC_CORR_ERR_INTR_EN Data RAM ECC 1 bit correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_EN Data RAM ECC 2 bit un-correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_EN Data RAM ECC error on multiple row detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0P_LOCKUP_INTR_EN M0P lockup interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0p_lockup_status_or field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_EN M0P systemresetreq interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_systemresetreq_status_or field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_MBOX_MSGOUT_INTR_EN Mailbox memssage out Interrupt EnableWhen this field is set to 1'b1 then the micro_rmi_mbox_msgout_status_or field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r (0x0001d229 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_ctl0[1];
	uint32_t _uc_rmi_ext_intr_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR(r) (r).uc_rmi_ext_intr_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_SET(r,d) (r).uc_rmi_ext_intr_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_GET(r) (r).uc_rmi_ext_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_GET(r) (((r).uc_rmi_ext_intr_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r
#define UC_RMI_EXT_INTR_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_t UC_RMI_EXT_INTR_CTL0r_t;
#define UC_RMI_EXT_INTR_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR
#define UC_RMI_EXT_INTR_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_SET
#define UC_RMI_EXT_INTR_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_SYSTEMRESETREQ_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0P_LOCKUP_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_UNCORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_DR_ECC_CORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_UNCORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_CR_ECC_CORR_ERR_INTR_ENf_SET
#define READ_UC_RMI_EXT_INTR_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_EXT_INTR_CTL0r
#define WRITE_UC_RMI_EXT_INTR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r
#define MODIFY_UC_RMI_EXT_INTR_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r
#define READLN_UC_RMI_EXT_INTR_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r
#define WRITELN_UC_RMI_EXT_INTR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r
#define WRITEALL_UC_RMI_EXT_INTR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22a
 * DEVAD:    1
 * DESC:     rmi external interrupt status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_CR_ECC_CORR_ERR_STATUS Code RAM ECC 1 bit correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_CR_ECC_UNCORR_ERR_STATUS Code RAM ECC 2 bit un-correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit un-correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUS Code RAM ECC error on multiple row detected  statusThis field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows.This bits remain remains set until this register is read
 *     MICRO_RMI_DR_ECC_CORR_ERR_STATUS Data RAM ECC 1 bit correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_DR_ECC_UNCORR_ERR_STATUS Data RAM ECC 2 bit un-correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit un-correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUS Data RAM ECC error on multiple row detected  statusThis field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows.This bits remain remains set until this register is read
 *     MICRO_RMI_M0P_LOCKUP_STATUS_OR This is logic OR of the M0P lockup status from all micro cores in the designThis field is set to 1'b1 when any of the M0P "lockup" signal is set to 1'b1It will remain set until M0P "lockup" signal from all M0P cores are zero andm0p_lockup_status field for all micro cores are zero
 *     MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_OR This is logic OR of the M0P systemresetreq status field from all micro cores in the designThis field is set to 1'b1 when any of the M0P cores "systemresetreq" signal is set to 1'b 1It will remain set until "systemresetreq" signals from all M0P cores are zero andsystemresetreq status field for all micro cores are zero
 *     MICRO_RMI_MBOX_MSGOUT_STATUS_OR This is logic OR of the mbox_msgout_status field from all micro cores in the designIt will remain set until "mbox_msgout_status" field for all micro cores are zero
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r (0x0001d22a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_sts0[1];
	uint32_t _uc_rmi_ext_intr_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_CLR(r) (r).uc_rmi_ext_intr_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_SET(r,d) (r).uc_rmi_ext_intr_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_GET(r) (r).uc_rmi_ext_intr_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 9) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 8) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_GET(r) (((r).uc_rmi_ext_intr_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r
#define UC_RMI_EXT_INTR_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_t UC_RMI_EXT_INTR_STS0r_t;
#define UC_RMI_EXT_INTR_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_CLR
#define UC_RMI_EXT_INTR_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_SET
#define UC_RMI_EXT_INTR_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUS_ORf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS_ORf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0P_LOCKUP_STATUS_ORf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_MULTIROW_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_UNCORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_DR_ECC_CORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_MULTIROW_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_UNCORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_CR_ECC_CORR_ERR_STATUSf_SET
#define READ_UC_RMI_EXT_INTR_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_EXT_INTR_STS0r
#define WRITE_UC_RMI_EXT_INTR_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r
#define MODIFY_UC_RMI_EXT_INTR_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r
#define READLN_UC_RMI_EXT_INTR_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_EXT_INTR_STS0r
#define WRITELN_UC_RMI_EXT_INTR_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r
#define WRITEALL_UC_RMI_EXT_INTR_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_EXT_INTR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_PMI_IF_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22b
 * DEVAD:    1
 * DESC:     pmi interface control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PMI_HP_FAST_READ_EN pmi hp interface fast read enable1 - use pmi_hp_read_vld during read0 - use pmi_hp_ack during read
 *     MICRO_PMI_HP_FAST_BKTOBK_EN pmi hp interface fast back to back enable1 - skip over some of the states in the fsm during back to back transition0 - state transitions as in f28
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r (0x0001d22b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PMI_IF_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pmi_if_ctl0[1];
	uint32_t _uc_rmi_pmi_if_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_CLR(r) (r).uc_rmi_pmi_if_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_SET(r,d) (r).uc_rmi_pmi_if_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_GET(r) (r).uc_rmi_pmi_if_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET(r) ((((r).uc_rmi_pmi_if_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET(r) (((r).uc_rmi_pmi_if_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET(r,f) (r).uc_rmi_pmi_if_ctl0[0]=(((r).uc_rmi_pmi_if_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_PMI_IF_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r,(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_PMI_IF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_PMI_IF_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pmi_if_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_PMI_IF_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pmi_if_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PMI_IF_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r
#define UC_RMI_PMI_IF_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_t UC_RMI_PMI_IF_CTL0r_t;
#define UC_RMI_PMI_IF_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_CLR
#define UC_RMI_PMI_IF_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_SET
#define UC_RMI_PMI_IF_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_BKTOBK_ENf_SET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_GET
#define UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r_MICRO_PMI_HP_FAST_READ_ENf_SET
#define READ_UC_RMI_PMI_IF_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_PMI_IF_CTL0r
#define WRITE_UC_RMI_PMI_IF_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_PMI_IF_CTL0r
#define MODIFY_UC_RMI_PMI_IF_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_PMI_IF_CTL0r
#define READLN_UC_RMI_PMI_IF_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_PMI_IF_CTL0r
#define WRITELN_UC_RMI_PMI_IF_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_PMI_IF_CTL0r
#define WRITEALL_UC_RMI_PMI_IF_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_PMI_IF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_PMI_IF_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_SILICON_DBG_CTL0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22c
 * DEVAD:    1
 * DESC:     Silicon debug control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUX_SEL This field is used to select the data to be muxed to rmi_silicon_debug_status0 registers0 - register interface - {5'd0, init_req,  wraddr_changed,  write_req,rdaddr_changed, read_req, ra_state[1:0],1'b0, ra_his_state[2:0]}1 - pram interface     - {1'b0, pif_state_status[1:0], pif_his_state_status[3:0],pr_hready, pr_dr_chipsel, pr_cr_chipsel, pr_state[1:0], 1'b0,pr_his_state[2:0]};2 - pmi_hp interface of micro_core 0  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}3 - pmi_hp interface of micro_core 1  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}4 - pmi_hp interface of micro_core 2  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}5 - pmi_hp interface of micro_core 3  - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]}
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r (0x0001d22c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_ctl0[1];
	uint32_t _uc_rmi_silicon_dbg_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_CLR(r) (r).uc_rmi_silicon_dbg_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_SET(r,d) (r).uc_rmi_silicon_dbg_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_GET(r) (r).uc_rmi_silicon_dbg_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET(r) (((r).uc_rmi_silicon_dbg_ctl0[0]) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET(r,f) (r).uc_rmi_silicon_dbg_ctl0[0]=(((r).uc_rmi_silicon_dbg_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r,(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_SILICON_DBG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_SILICON_DBG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_SILICON_DBG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_silicon_dbg_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r
#define UC_RMI_SILICON_DBG_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_t UC_RMI_SILICON_DBG_CTL0r_t;
#define UC_RMI_SILICON_DBG_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_CLR
#define UC_RMI_SILICON_DBG_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_SET
#define UC_RMI_SILICON_DBG_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_GET
#define UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r_MICRO_SILICON_DEBUG_STATUS_MUX_SELf_SET
#define READ_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_SILICON_DBG_CTL0r
#define WRITE_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_SILICON_DBG_CTL0r
#define MODIFY_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_SILICON_DBG_CTL0r
#define READLN_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_SILICON_DBG_CTL0r
#define WRITELN_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_SILICON_DBG_CTL0r
#define WRITEALL_UC_RMI_SILICON_DBG_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_SILICON_DBG_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_SILICON_DBG_STS0
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22d
 * DEVAD:    1
 * DESC:     Silicon debug status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_SILICON_DEBUG_STATUS_MUXED_DATA Muxed status data is made avaialable on this field.micro_silicon_debug_status_mux_sel is used to select the data source
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r (0x0001d22d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_SILICON_DBG_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_silicon_dbg_sts0[1];
	uint32_t _uc_rmi_silicon_dbg_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_CLR(r) (r).uc_rmi_silicon_dbg_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_SET(r,d) (r).uc_rmi_silicon_dbg_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_GET(r) (r).uc_rmi_silicon_dbg_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET(r) (((r).uc_rmi_silicon_dbg_sts0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET(r,f) (r).uc_rmi_silicon_dbg_sts0[0]=(((r).uc_rmi_silicon_dbg_sts0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_SILICON_DBG_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r,(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_SILICON_DBG_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_SILICON_DBG_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_silicon_dbg_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_SILICON_DBG_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_silicon_dbg_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_SILICON_DBG_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r
#define UC_RMI_SILICON_DBG_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_t UC_RMI_SILICON_DBG_STS0r_t;
#define UC_RMI_SILICON_DBG_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_CLR
#define UC_RMI_SILICON_DBG_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_SET
#define UC_RMI_SILICON_DBG_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_GET
#define UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r_MICRO_SILICON_DEBUG_STATUS_MUXED_DATAf_SET
#define READ_UC_RMI_SILICON_DBG_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_SILICON_DBG_STS0r
#define WRITE_UC_RMI_SILICON_DBG_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_SILICON_DBG_STS0r
#define MODIFY_UC_RMI_SILICON_DBG_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_SILICON_DBG_STS0r
#define READLN_UC_RMI_SILICON_DBG_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_SILICON_DBG_STS0r
#define WRITELN_UC_RMI_SILICON_DBG_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_SILICON_DBG_STS0r
#define WRITEALL_UC_RMI_SILICON_DBG_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_SILICON_DBG_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_SILICON_DBG_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RAM_CTL2
 * BLOCKS:   MICRO_C
 * REGADDR:  0xd22e
 * DEVAD:    1
 * DESC:     ram configuration register 2
 * RESETVAL: 0x8400 (33792)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_STACK_SIZE Micro Core Stack SizeThis field is used to set the stack size for a micro core on a 4 byte granualarity.All of the micro cores (Cortex-M0P) use the same stack size. The total amount ofmemory allocated for stack = number of cores * micro_core_stack_size.For 40K Data RAM, limiting the stack size to 8K.
 *     MICRO_CORE_STACK_EN Micro Core Stack Enable1 - Enabled (default) - perform logical to physical address mapping un the data RAM for stack0 - Disabled
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r (0x0001d22e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl2[1];
	uint32_t _uc_ram_ctl2;
} BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_CLR(r) (r).uc_ram_ctl2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_SET(r,d) (r).uc_ram_ctl2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_GET(r) (r).uc_ram_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_GET(r) ((((r).uc_ram_ctl2[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_SET(r,f) (r).uc_ram_ctl2[0]=(((r).uc_ram_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_GET(r) ((((r).uc_ram_ctl2[0]) >> 2) & 0xfff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_SET(r,f) (r).uc_ram_ctl2[0]=(((r).uc_ram_ctl2[0] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2)) | (4095 << (16 + 2))

/*
 * These macros can be used to access UC_RAM_CTL2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r,(_r._uc_ram_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r,(_r._uc_ram_ctl2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r,(_r._uc_ram_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL2r BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r
#define UC_RAM_CTL2r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_t UC_RAM_CTL2r_t;
#define UC_RAM_CTL2r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_CLR
#define UC_RAM_CTL2r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_SET
#define UC_RAM_CTL2r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_GET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_GET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_ENf_SET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_GET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_GET
#define UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_SET BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r_MICRO_CORE_STACK_SIZEf_SET
#define READ_UC_RAM_CTL2r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RAM_CTL2r
#define WRITE_UC_RAM_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RAM_CTL2r
#define MODIFY_UC_RAM_CTL2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RAM_CTL2r
#define READLN_UC_RAM_CTL2r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RAM_CTL2r
#define WRITELN_UC_RAM_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RAM_CTL2r
#define WRITEALL_UC_RAM_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RAM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RAM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL0
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd230
 * DEVAD:    1
 * DESC:     micro message control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG0       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r (0x0001d230 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl0[1];
	uint32_t _uc_rmi_uc_msg_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_CLR(r) (r).uc_rmi_uc_msg_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_SET(r,d) (r).uc_rmi_uc_msg_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_GET(r) (r).uc_rmi_uc_msg_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_GET(r) (((r).uc_rmi_uc_msg_ctl0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_SET(r,f) (r).uc_rmi_uc_msg_ctl0[0]=(((r).uc_rmi_uc_msg_ctl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r,(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r,(_r._uc_rmi_uc_msg_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r,(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r
#define UC_RMI_UC_MSG_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_t UC_RMI_UC_MSG_CTL0r_t;
#define UC_RMI_UC_MSG_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_CLR
#define UC_RMI_UC_MSG_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_SET
#define UC_RMI_UC_MSG_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_GET
#define UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_GET
#define UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r_MICRO_MSG0f_SET
#define READ_UC_RMI_UC_MSG_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL0r
#define WRITE_UC_RMI_UC_MSG_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL0r
#define MODIFY_UC_RMI_UC_MSG_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL0r
#define READLN_UC_RMI_UC_MSG_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL0r
#define WRITELN_UC_RMI_UC_MSG_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL0r
#define WRITEALL_UC_RMI_UC_MSG_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL1
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd231
 * DEVAD:    1
 * DESC:     micro message control register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG1       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r (0x0001d231 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl1[1];
	uint32_t _uc_rmi_uc_msg_ctl1;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_CLR(r) (r).uc_rmi_uc_msg_ctl1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_SET(r,d) (r).uc_rmi_uc_msg_ctl1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_GET(r) (r).uc_rmi_uc_msg_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_GET(r) (((r).uc_rmi_uc_msg_ctl1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_SET(r,f) (r).uc_rmi_uc_msg_ctl1[0]=(((r).uc_rmi_uc_msg_ctl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r,(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r,(_r._uc_rmi_uc_msg_ctl1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r,(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL1r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r
#define UC_RMI_UC_MSG_CTL1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_t UC_RMI_UC_MSG_CTL1r_t;
#define UC_RMI_UC_MSG_CTL1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_CLR
#define UC_RMI_UC_MSG_CTL1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_SET
#define UC_RMI_UC_MSG_CTL1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_GET
#define UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_GET
#define UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r_MICRO_MSG1f_SET
#define READ_UC_RMI_UC_MSG_CTL1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL1r
#define WRITE_UC_RMI_UC_MSG_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL1r
#define MODIFY_UC_RMI_UC_MSG_CTL1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL1r
#define READLN_UC_RMI_UC_MSG_CTL1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL1r
#define WRITELN_UC_RMI_UC_MSG_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL1r
#define WRITEALL_UC_RMI_UC_MSG_CTL1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL2
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd232
 * DEVAD:    1
 * DESC:     micro message control register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG2       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r (0x0001d232 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl2[1];
	uint32_t _uc_rmi_uc_msg_ctl2;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_CLR(r) (r).uc_rmi_uc_msg_ctl2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_SET(r,d) (r).uc_rmi_uc_msg_ctl2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_GET(r) (r).uc_rmi_uc_msg_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_GET(r) (((r).uc_rmi_uc_msg_ctl2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_SET(r,f) (r).uc_rmi_uc_msg_ctl2[0]=(((r).uc_rmi_uc_msg_ctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r,(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r,(_r._uc_rmi_uc_msg_ctl2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r,(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL2r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r
#define UC_RMI_UC_MSG_CTL2r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_t UC_RMI_UC_MSG_CTL2r_t;
#define UC_RMI_UC_MSG_CTL2r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_CLR
#define UC_RMI_UC_MSG_CTL2r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_SET
#define UC_RMI_UC_MSG_CTL2r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_GET
#define UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_GET
#define UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r_MICRO_MSG2f_SET
#define READ_UC_RMI_UC_MSG_CTL2r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL2r
#define WRITE_UC_RMI_UC_MSG_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL2r
#define MODIFY_UC_RMI_UC_MSG_CTL2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL2r
#define READLN_UC_RMI_UC_MSG_CTL2r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL2r
#define WRITELN_UC_RMI_UC_MSG_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL2r
#define WRITEALL_UC_RMI_UC_MSG_CTL2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_RMI_UC_MSG_CTL3
 * BLOCKS:   MICRO_D
 * REGADDR:  0xd233
 * DEVAD:    1
 * DESC:     micro message control register 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MSG3       This field is used to exchange information between micro core(s) and chip level firmwareBoth the micro cores(s) and the chip level firmware can read/write this field
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r (0x0001d233 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_UC_MSG_CTL3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_s {
	uint32_t v[1];
	uint32_t uc_rmi_uc_msg_ctl3[1];
	uint32_t _uc_rmi_uc_msg_ctl3;
} BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_CLR(r) (r).uc_rmi_uc_msg_ctl3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_SET(r,d) (r).uc_rmi_uc_msg_ctl3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_GET(r) (r).uc_rmi_uc_msg_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_GET(r) (((r).uc_rmi_uc_msg_ctl3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_SET(r,f) (r).uc_rmi_uc_msg_ctl3[0]=(((r).uc_rmi_uc_msg_ctl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_UC_MSG_CTL3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r,(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r,(_r._uc_rmi_uc_msg_ctl3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r,(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_uc_msg_ctl3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_uc_msg_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_UC_MSG_CTL3r BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r
#define UC_RMI_UC_MSG_CTL3r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_t UC_RMI_UC_MSG_CTL3r_t;
#define UC_RMI_UC_MSG_CTL3r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_CLR
#define UC_RMI_UC_MSG_CTL3r_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_SET
#define UC_RMI_UC_MSG_CTL3r_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_GET
#define UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_GET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_GET
#define UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_SET BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r_MICRO_MSG3f_SET
#define READ_UC_RMI_UC_MSG_CTL3r BCMI_TSCBH_FLEXE_XGXS_READ_UC_RMI_UC_MSG_CTL3r
#define WRITE_UC_RMI_UC_MSG_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_RMI_UC_MSG_CTL3r
#define MODIFY_UC_RMI_UC_MSG_CTL3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_RMI_UC_MSG_CTL3r
#define READLN_UC_RMI_UC_MSG_CTL3r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_RMI_UC_MSG_CTL3r
#define WRITELN_UC_RMI_UC_MSG_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_RMI_UC_MSG_CTL3r
#define WRITEALL_UC_RMI_UC_MSG_CTL3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_RMI_UC_MSG_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_RMI_UC_MSG_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_CLK_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd240
 * DEVAD:    1
 * DESC:     micro core clock control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_CLK_EN micro core clock enable for core:While the micro-code is being loaded into the code RAM, the clock tomicro_core is normally disabled and a reset is asserted0 - disabled1 - enables
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r (0x0001d240 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CLK_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_clk_ctl0[1];
	uint32_t _uc_uc_core_clk_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_CLR(r) (r).uc_uc_core_clk_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_SET(r,d) (r).uc_uc_core_clk_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_GET(r) (r).uc_uc_core_clk_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET(r) (((r).uc_uc_core_clk_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET(r,f) (r).uc_uc_core_clk_ctl0[0]=(((r).uc_uc_core_clk_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_CLK_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r,(_r._uc_uc_core_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r,(_r._uc_uc_core_clk_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r,(_r._uc_uc_core_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CLK_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_clk_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CLK_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_clk_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r
#define UC_UC_CORE_CLK_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_t UC_UC_CORE_CLK_CTL0r_t;
#define UC_UC_CORE_CLK_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_CLR
#define UC_UC_CORE_CLK_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_SET
#define UC_UC_CORE_CLK_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_GET
#define UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET
#define UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET
#define READ_UC_UC_CORE_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CLK_CTL0r
#define WRITE_UC_UC_CORE_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CLK_CTL0r
#define MODIFY_UC_UC_CORE_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CLK_CTL0r
#define READLN_UC_UC_CORE_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CLK_CTL0r
#define WRITELN_UC_UC_CORE_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CLK_CTL0r
#define WRITEALL_UC_UC_CORE_CLK_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CLK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CLK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_RST_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd241
 * DEVAD:    1
 * DESC:     micro core reset control registers 0
 * RESETVAL: 0xc000 (49152)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_RSTB  micro core reset for core:While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted.Setting this field to 1'b1 de-asserts a reset to the micro.0 - disabled1 - enables
 *     MICRO_DAP_PORESET_S_RSTB micro core dap software por reset:A reset on the M0P DAP PORESET pin is asserted when:1) pmd_por_h_rstb pin = 0 (upon power-on) OR2) micro_dap_poreset_s_rstb register filed = 0 (software reset)0 - asserted1 - de-asserted
 *     MICRO_SW_PMI_HP_RSTB Software reset pmi_hp interface logicThis bit is to initialize the pmi_hp block0 - reset asserted1 - reset de-asserted
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r (0x0001d241 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_RST_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_rst_ctl0[1];
	uint32_t _uc_uc_core_rst_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_CLR(r) (r).uc_uc_core_rst_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_SET(r,d) (r).uc_uc_core_rst_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_GET(r) (r).uc_uc_core_rst_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_GET(r) ((((r).uc_uc_core_rst_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_SET(r,f) (r).uc_uc_core_rst_ctl0[0]=(((r).uc_uc_core_rst_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_GET(r) ((((r).uc_uc_core_rst_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_SET(r,f) (r).uc_uc_core_rst_ctl0[0]=(((r).uc_uc_core_rst_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_GET(r) (((r).uc_uc_core_rst_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_SET(r,f) (r).uc_uc_core_rst_ctl0[0]=(((r).uc_uc_core_rst_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_RST_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r,(_r._uc_uc_core_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r,(_r._uc_uc_core_rst_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r,(_r._uc_uc_core_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_RST_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_rst_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_RST_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_rst_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r
#define UC_UC_CORE_RST_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_t UC_UC_CORE_RST_CTL0r_t;
#define UC_UC_CORE_RST_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_CLR
#define UC_UC_CORE_RST_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_SET
#define UC_UC_CORE_RST_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_SW_PMI_HP_RSTBf_SET
#define UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_DAP_PORESET_S_RSTBf_SET
#define UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_GET
#define UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r_MICRO_CORE_RSTBf_SET
#define READ_UC_UC_CORE_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_RST_CTL0r
#define WRITE_UC_UC_CORE_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_RST_CTL0r
#define MODIFY_UC_UC_CORE_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_RST_CTL0r
#define READLN_UC_UC_CORE_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_RST_CTL0r
#define WRITELN_UC_UC_CORE_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_RST_CTL0r
#define WRITEALL_UC_UC_CORE_RST_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_RST_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_RST_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_STS0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd242
 * DEVAD:    1
 * DESC:     rmi micro core status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PMI_HP_ERROR_STATUS pmi_hp_error signal statusThis field is set when pmi_hp_error signal is asserted by RMIC during pmi_hp bus tranactionsThis bit remains set, until this register is read (latch high, clear on read)
 *     MICRO_PMI_HP_WORD_ACCESS_ERR_STATUS This field is set when 32-bit operation is perform to generate transations on the pmi_hp busOnly 8/16-bits operations are allowedThis bit remains set, until this register is read (latch high, clear on read)
 *     MICRO_PMI_HP_ACK_TIMEOUT_STATUS This field is set when pmi_hp_ack signal on the pmi_hp bus does not toggle within 256 clock cycleThis bit remains set, until this register is read (latch high, clear on read)
 *     MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUS m0p default slave error detected. M0P attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r (0x0001d242 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_sts0[1];
	uint32_t _uc_uc_core_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_CLR(r) (r).uc_uc_core_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_SET(r,d) (r).uc_uc_core_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_GET(r) (r).uc_uc_core_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_GET(r) ((((r).uc_uc_core_sts0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_GET(r) ((((r).uc_uc_core_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_GET(r) ((((r).uc_uc_core_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_GET(r) (((r).uc_uc_core_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_SET(r,f) (r).uc_uc_core_sts0[0]=(((r).uc_uc_core_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r,(_r._uc_uc_core_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r,(_r._uc_uc_core_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r,(_r._uc_uc_core_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r
#define UC_UC_CORE_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_t UC_UC_CORE_STS0r_t;
#define UC_UC_CORE_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_CLR
#define UC_UC_CORE_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_SET
#define UC_UC_CORE_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_GET
#define UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_M0P_DEFAULT_SLAVE_ERROR_STATUSf_SET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ACK_TIMEOUT_STATUSf_SET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_WORD_ACCESS_ERR_STATUSf_SET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_GET
#define UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r_MICRO_PMI_HP_ERROR_STATUSf_SET
#define READ_UC_UC_CORE_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_STS0r
#define WRITE_UC_UC_CORE_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_STS0r
#define MODIFY_UC_UC_CORE_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_STS0r
#define READLN_UC_UC_CORE_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_STS0r
#define WRITELN_UC_UC_CORE_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_STS0r
#define WRITEALL_UC_UC_CORE_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd243
 * DEVAD:    1
 * DESC:     rmi micro core control register 0
 * RESETVAL: 0x3 (3)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_LN_SEL This field indicates lanes that are selected for micro_corePLEASE NOTE:The default value of this register field for each micro core is unique.the default values are:micro core 0 - 8'h3micro core 1 - 8'hCmicro core 2 - 8'h30micro core 3 - 8'hC0
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r (0x0001d243 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_ctl0[1];
	uint32_t _uc_uc_core_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_CLR(r) (r).uc_uc_core_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_SET(r,d) (r).uc_uc_core_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_GET(r) (r).uc_uc_core_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_GET(r) (((r).uc_uc_core_ctl0[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_SET(r,f) (r).uc_uc_core_ctl0[0]=(((r).uc_uc_core_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access UC_UC_CORE_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r,(_r._uc_uc_core_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r,(_r._uc_uc_core_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r,(_r._uc_uc_core_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r
#define UC_UC_CORE_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_t UC_UC_CORE_CTL0r_t;
#define UC_UC_CORE_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_CLR
#define UC_UC_CORE_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_SET
#define UC_UC_CORE_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_GET
#define UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_GET
#define UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r_MICRO_CORE_LN_SELf_SET
#define READ_UC_UC_CORE_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CTL0r
#define WRITE_UC_UC_CORE_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CTL0r
#define MODIFY_UC_UC_CORE_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CTL0r
#define READLN_UC_UC_CORE_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CTL0r
#define WRITELN_UC_UC_CORE_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CTL0r
#define WRITEALL_UC_UC_CORE_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_MBOX_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd244
 * DEVAD:    1
 * DESC:     rmi micro core mail box control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MBOX_MSGIN_INTR mailbox message in interrupt for microSet by the MDIO/PMI_LP, cleared by the micro via PMI HPDrive the micro interrupt pin
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r (0x0001d244 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_MBOX_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_mbox_ctl0[1];
	uint32_t _uc_uc_core_mbox_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_CLR(r) (r).uc_uc_core_mbox_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_SET(r,d) (r).uc_uc_core_mbox_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_GET(r) (r).uc_uc_core_mbox_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_GET(r) (((r).uc_uc_core_mbox_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_SET(r,f) (r).uc_uc_core_mbox_ctl0[0]=(((r).uc_uc_core_mbox_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_MBOX_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r,(_r._uc_uc_core_mbox_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r,(_r._uc_uc_core_mbox_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r,(_r._uc_uc_core_mbox_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_MBOX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_mbox_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_MBOX_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_mbox_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_MBOX_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_mbox_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_MBOX_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r
#define UC_UC_CORE_MBOX_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_t UC_UC_CORE_MBOX_CTL0r_t;
#define UC_UC_CORE_MBOX_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_CLR
#define UC_UC_CORE_MBOX_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_SET
#define UC_UC_CORE_MBOX_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_GET
#define UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_GET
#define UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r_MICRO_MBOX_MSGIN_INTRf_SET
#define READ_UC_UC_CORE_MBOX_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_MBOX_CTL0r
#define WRITE_UC_UC_CORE_MBOX_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_MBOX_CTL0r
#define MODIFY_UC_UC_CORE_MBOX_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_MBOX_CTL0r
#define READLN_UC_UC_CORE_MBOX_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_MBOX_CTL0r
#define WRITELN_UC_UC_CORE_MBOX_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_MBOX_CTL0r
#define WRITEALL_UC_UC_CORE_MBOX_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_MBOX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_MBOX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_LOW_PWR_CTL0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd245
 * DEVAD:    1
 * DESC:     rmi micro core low power control register 0
 * RESETVAL: 0xe (14)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_WICENREQ   WIC-based Deep Sleep request for micro core1 - request for Deep Sleep0 - no request
 *     MICRO_SLEEPHOLDREQ_N Request to extend the processor sleeping state regardlessof wake-up events. If the processor acknowledges this requestdriving m0p_sleepholdack_n LOW, this guarantees the processorremains idle even on receipt of a wake-up event.This is used to safely shutdown the micro_core0 - request to extend deep sleep state1 - no request
 *     MICRO_M0P_GCLK_FRCVAL M0P core clock gate force valueThe clock to the M0P cores can be gated of in the low power modeusing GATEHCLK signals for M0P core. The micro_m0p_gclk_frc andmicro_m0p_gclk_frcval provides a mechanism override the clock gating{micro_m0p_gclk_frc, micro_m0p_gclk_frcval}2'b11 - GATEHCLK ignored. Clock gate bypass (default)2'b10 - GATEHCLK ignored. M0P hclk clock gated off2'b0X - GATEHCLK used to gate M0P hclk clock
 *     MICRO_M0P_GCLK_FRC M0P core clock gate force enableThe clock to the M0P core can be gated of in the low power modeusing GATEHCLK signals for M0P core. The micro_m0p_gclk_frc andmicro_m0p_gclk_frcval provides a mechanism override the clock gating{micro_m0p_gclk_frc, micro_m0p_gclk_frcval}2'b11 - GATEHCLK ignored. Clock gate bypass (default)2'b10 - GATEHCLK ignored. M0P hclk clock gated off2'b0X - GATEHCLK used to gate M0P hclk clock
 *     MICRO_M0P_WAKEUP M0P core wakeupThis is self-clearing field. When this set 1, it generate a pulseon the M0P core RXEV pin to wakeup M0P from WFE sleep state
 *     MICRO_DP_RCLK20_RST_WAKEUP_EN M0P core - Enable wakeup event upon detecting a change on the lane dp_rclk20_rstWhen this is set 1, and any bits in the micro_dp_rclk20_rst_status_LH are setthen M0P core RXEV pin is set to 1'b1 to wake-up M0P from WFE sleep state
 *     MICRO_PMD_SIGNAL_DETECT_WAKEUP_EN M0P core - Enable wakeup event upon detecting a change on the lane pmd_signal_detectWhen this is set 1, and any bits in the micro_pmd_signal_detect_status_LH are setthen M0P core RXEV pin is set to 1'b1 to wake-up M0P from WFE sleep state
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r (0x0001d245 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_LOW_PWR_CTL0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_low_pwr_ctl0[1];
	uint32_t _uc_uc_core_low_pwr_ctl0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_CLR(r) (r).uc_uc_core_low_pwr_ctl0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SET(r,d) (r).uc_uc_core_low_pwr_ctl0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_GET(r) (r).uc_uc_core_low_pwr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_GET(r) ((((r).uc_uc_core_low_pwr_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_GET(r) (((r).uc_uc_core_low_pwr_ctl0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_SET(r,f) (r).uc_uc_core_low_pwr_ctl0[0]=(((r).uc_uc_core_low_pwr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_LOW_PWR_CTL0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r,(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r,(_r._uc_uc_core_low_pwr_ctl0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r,(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_ctl0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_CTL0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_low_pwr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_LOW_PWR_CTL0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r
#define UC_UC_CORE_LOW_PWR_CTL0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_t UC_UC_CORE_LOW_PWR_CTL0r_t;
#define UC_UC_CORE_LOW_PWR_CTL0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_CLR
#define UC_UC_CORE_LOW_PWR_CTL0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_PMD_SIGNAL_DETECT_WAKEUP_ENf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_DP_RCLK20_RST_WAKEUP_ENf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_WAKEUPf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_M0P_GCLK_FRCVALf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_SLEEPHOLDREQ_Nf_SET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_GET
#define UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r_MICRO_WICENREQf_SET
#define READ_UC_UC_CORE_LOW_PWR_CTL0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_LOW_PWR_CTL0r
#define WRITE_UC_UC_CORE_LOW_PWR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_LOW_PWR_CTL0r
#define MODIFY_UC_UC_CORE_LOW_PWR_CTL0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_CTL0r
#define READLN_UC_UC_CORE_LOW_PWR_CTL0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_LOW_PWR_CTL0r
#define WRITELN_UC_UC_CORE_LOW_PWR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_CTL0r
#define WRITEALL_UC_UC_CORE_LOW_PWR_CTL0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_LOW_PWR_STS0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd246
 * DEVAD:    1
 * DESC:     rmi micro core low power status register 0
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_WICENACK   Active HIGH acknowledge signal for micro_wicenreq1 - Acknowledge0 - none
 *     MICRO_SLEEPHOLDACK_N Response to micro_sleepholdreq_n.If this signal is LOW, irrespective of the micro_sleepingsignal value, the processor does not advance in executionand does not perform any memory operations. This is used tosafely shutdown the micro_core0 - Acknowledge1 - none
 *     MICRO_SLEEPING   for micro1 - indicates the processor is idle, waiting for an interrupton the IRQ or internal SysTick.0 - indicates that the processor is running or wants to leave sleep modeIf micro_sleepholdack_n is 0, then the processordoes not perform any fetches until micro_sleepholdreq_n is 1
 *     MICRO_SLEEPDEEP  Active only when micro_sleeping is 1Indicates that the SLEEPDEEP bit in the NVIC is set to 1
 *     MICRO_SLEEPING_LH Latch high sleeping. This field is set to 1'b1 when micro_sleeping is 1It will remain set until micro_sleeping is set to 0 andand this register is readclear-on-read
 *     MICRO_SLEEPDEEP_LH Latch high sleepdeep. This field is set to 1'b1 when micro_sleepdeep is 1It will remain set until micro_sleepdeep is set to 0 andand this register is readclear-on-read
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r (0x0001d246 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_LOW_PWR_STS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_low_pwr_sts0[1];
	uint32_t _uc_uc_core_low_pwr_sts0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_CLR(r) (r).uc_uc_core_low_pwr_sts0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SET(r,d) (r).uc_uc_core_low_pwr_sts0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_GET(r) (r).uc_uc_core_low_pwr_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_GET(r) ((((r).uc_uc_core_low_pwr_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_GET(r) (((r).uc_uc_core_low_pwr_sts0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_SET(r,f) (r).uc_uc_core_low_pwr_sts0[0]=(((r).uc_uc_core_low_pwr_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_LOW_PWR_STS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r,(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r,(_r._uc_uc_core_low_pwr_sts0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r,(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_LOW_PWR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_STS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_low_pwr_sts0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_STS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_low_pwr_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_LOW_PWR_STS0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r
#define UC_UC_CORE_LOW_PWR_STS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_t UC_UC_CORE_LOW_PWR_STS0r_t;
#define UC_UC_CORE_LOW_PWR_STS0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_CLR
#define UC_UC_CORE_LOW_PWR_STS0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_SET
#define UC_UC_CORE_LOW_PWR_STS0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEP_LHf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPING_LHf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPDEEPf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPINGf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_SLEEPHOLDACK_Nf_SET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_GET
#define UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r_MICRO_WICENACKf_SET
#define READ_UC_UC_CORE_LOW_PWR_STS0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_LOW_PWR_STS0r
#define WRITE_UC_UC_CORE_LOW_PWR_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_LOW_PWR_STS0r
#define MODIFY_UC_UC_CORE_LOW_PWR_STS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_LOW_PWR_STS0r
#define READLN_UC_UC_CORE_LOW_PWR_STS0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_LOW_PWR_STS0r
#define WRITELN_UC_UC_CORE_LOW_PWR_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_LOW_PWR_STS0r
#define WRITEALL_UC_UC_CORE_LOW_PWR_STS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_LOW_PWR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_LOW_PWR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_STS1
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd247
 * DEVAD:    1
 * DESC:     rmi micro core status register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_M0P_LOCKUP_STATUS M0P lockup statusThis field is set to 1'b1 when M0P "lockup" signal is set to 1'b1 to indicate lockupIt will remain set until M0P "lockup" signal goes to 1'b0 and this filed is read
 *     MICRO_RMI_M0P_SYSTEMRESETREQ_STATUS M0P systemresetreq statusThis field is set to 1'b1 when M0P "systemresetreq" signal is set to 1'b1It will remain set until systemresetreq is set to 1'b0 and this field is read
 *     MICRO_RMI_MBOX_MSGOUT_STATUS mailbox message out statusThis field is set to 1'b1 when the firmware set the ahbcommon_mbox_send_msgout to 1'b1to send a message outIt will remain set until this field is read
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r (0x0001d247 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_STS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_sts1[1];
	uint32_t _uc_uc_core_sts1;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_CLR(r) (r).uc_uc_core_sts1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_SET(r,d) (r).uc_uc_core_sts1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_GET(r) (r).uc_uc_core_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET(r) ((((r).uc_uc_core_sts1[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET(r,f) (r).uc_uc_core_sts1[0]=(((r).uc_uc_core_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_GET(r) ((((r).uc_uc_core_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_SET(r,f) (r).uc_uc_core_sts1[0]=(((r).uc_uc_core_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_GET(r) (((r).uc_uc_core_sts1[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_SET(r,f) (r).uc_uc_core_sts1[0]=(((r).uc_uc_core_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_UC_CORE_STS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r,(_r._uc_uc_core_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r,(_r._uc_uc_core_sts1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r,(_r._uc_uc_core_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_STS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_STS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_STS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_STS1r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r
#define UC_UC_CORE_STS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_t UC_UC_CORE_STS1r_t;
#define UC_UC_CORE_STS1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_CLR
#define UC_UC_CORE_STS1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_SET
#define UC_UC_CORE_STS1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_SYSTEMRESETREQ_STATUSf_SET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_GET
#define UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r_MICRO_RMI_M0P_LOCKUP_STATUSf_SET
#define READ_UC_UC_CORE_STS1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_STS1r
#define WRITE_UC_UC_CORE_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_STS1r
#define MODIFY_UC_UC_CORE_STS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_STS1r
#define READLN_UC_UC_CORE_STS1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_STS1r
#define WRITELN_UC_UC_CORE_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_STS1r
#define WRITEALL_UC_UC_CORE_STS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_STS2
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd248
 * DEVAD:    1
 * DESC:     rmi micro core status register 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_DP_RCLK20_RST_STATUS_LH Indicatees a change on rx lane datapath reset detected1 - change detected. This can be used to  generate wake-up eventif micro_dp_rclk20_rst_wakeup_en is set to 1'b10 - no changesclear-on-read
 *     MICRO_PMD_SIGNAL_DETECT_STATUS_LH Indicates a changes lane pmd_signal_detect detected1 - change detected. This can be used to  generate wake-up eventif micro_pmd_signal_detect_wakeup_en is set to 1'b10 - no changesclear-on-read
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r (0x0001d248 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_STS2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_sts2[1];
	uint32_t _uc_uc_core_sts2;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_CLR(r) (r).uc_uc_core_sts2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_SET(r,d) (r).uc_uc_core_sts2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_GET(r) (r).uc_uc_core_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_GET(r) ((((r).uc_uc_core_sts2[0]) >> 8) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_SET(r,f) (r).uc_uc_core_sts2[0]=(((r).uc_uc_core_sts2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_GET(r) (((r).uc_uc_core_sts2[0]) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_SET(r,f) (r).uc_uc_core_sts2[0]=(((r).uc_uc_core_sts2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access UC_UC_CORE_STS2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r,(_r._uc_uc_core_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r,(_r._uc_uc_core_sts2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r,(_r._uc_uc_core_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_STS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_STS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_sts2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_STS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_STS2r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r
#define UC_UC_CORE_STS2r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_t UC_UC_CORE_STS2r_t;
#define UC_UC_CORE_STS2r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_CLR
#define UC_UC_CORE_STS2r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_SET
#define UC_UC_CORE_STS2r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_GET
#define UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_GET
#define UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_PMD_SIGNAL_DETECT_STATUS_LHf_SET
#define UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_GET
#define UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r_MICRO_DP_RCLK20_RST_STATUS_LHf_SET
#define READ_UC_UC_CORE_STS2r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_STS2r
#define WRITE_UC_UC_CORE_STS2r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_STS2r
#define MODIFY_UC_UC_CORE_STS2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_STS2r
#define READLN_UC_UC_CORE_STS2r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_STS2r
#define WRITELN_UC_UC_CORE_STS2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_STS2r
#define WRITEALL_UC_UC_CORE_STS2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_CFG_FWAPI_DATA0
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd24d
 * DEVAD:    1
 * DESC:     micro core firmware/api data registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_CFG_FWAPI_DATA0 Micro core firmware/API data 0This is a scratch register used by the firmware and API code to store and/or exchangemicro core configuration information
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r (0x0001d24d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CFG_FWAPI_DATA0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_cfg_fwapi_data0[1];
	uint32_t _uc_uc_core_cfg_fwapi_data0;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_CLR(r) (r).uc_uc_core_cfg_fwapi_data0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SET(r,d) (r).uc_uc_core_cfg_fwapi_data0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_GET(r) (r).uc_uc_core_cfg_fwapi_data0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_GET(r) (((r).uc_uc_core_cfg_fwapi_data0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_SET(r,f) (r).uc_uc_core_cfg_fwapi_data0[0]=(((r).uc_uc_core_cfg_fwapi_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_CORE_CFG_FWAPI_DATA0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r,(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r,(_r._uc_uc_core_cfg_fwapi_data0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r,(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fwapi_data0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CFG_FWAPI_DATA0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_cfg_fwapi_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r
#define UC_UC_CORE_CFG_FWAPI_DATA0r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_t UC_UC_CORE_CFG_FWAPI_DATA0r_t;
#define UC_UC_CORE_CFG_FWAPI_DATA0r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_CLR
#define UC_UC_CORE_CFG_FWAPI_DATA0r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_SET
#define UC_UC_CORE_CFG_FWAPI_DATA0r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_GET
#define UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_GET
#define UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r_MICRO_CORE_CFG_FWAPI_DATA0f_SET
#define READ_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CFG_FWAPI_DATA0r
#define WRITE_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CFG_FWAPI_DATA0r
#define MODIFY_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CFG_FWAPI_DATA0r
#define READLN_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CFG_FWAPI_DATA0r
#define WRITELN_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CFG_FWAPI_DATA0r
#define WRITEALL_UC_UC_CORE_CFG_FWAPI_DATA0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CFG_FWAPI_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FWAPI_DATA0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  UC_UC_CORE_CFG_FW_API_DATA1
 * BLOCKS:   MICRO_E
 * REGADDR:  0xd24e
 * DEVAD:    1
 * DESC:     micro core firmware/api data registers 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CORE_CFG_FWAPI_DATA1 Micro core firmware/API data 1This is a scratch register used by the firmware and API code to store and/or exchangemicro core configuration information
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r (0x0001d24e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_CORE_CFG_FW_API_DATA1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_s {
	uint32_t v[1];
	uint32_t uc_uc_core_cfg_fw_api_data1[1];
	uint32_t _uc_uc_core_cfg_fw_api_data1;
} BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_CLR(r) (r).uc_uc_core_cfg_fw_api_data1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SET(r,d) (r).uc_uc_core_cfg_fw_api_data1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_GET(r) (r).uc_uc_core_cfg_fw_api_data1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_GET(r) (((r).uc_uc_core_cfg_fw_api_data1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_SET(r,f) (r).uc_uc_core_cfg_fw_api_data1[0]=(((r).uc_uc_core_cfg_fw_api_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_CORE_CFG_FW_API_DATA1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r,(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r,(_r._uc_uc_core_cfg_fw_api_data1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r,(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_core_cfg_fw_api_data1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CFG_FW_API_DATA1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_core_cfg_fw_api_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_CORE_CFG_FW_API_DATA1r BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r
#define UC_UC_CORE_CFG_FW_API_DATA1r_SIZE BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_t UC_UC_CORE_CFG_FW_API_DATA1r_t;
#define UC_UC_CORE_CFG_FW_API_DATA1r_CLR BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_CLR
#define UC_UC_CORE_CFG_FW_API_DATA1r_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_SET
#define UC_UC_CORE_CFG_FW_API_DATA1r_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_GET
#define UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_GET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_GET
#define UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_SET BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r_MICRO_CORE_CFG_FWAPI_DATA1f_SET
#define READ_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_TSCBH_FLEXE_XGXS_READ_UC_UC_CORE_CFG_FW_API_DATA1r
#define WRITE_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITE_UC_UC_CORE_CFG_FW_API_DATA1r
#define MODIFY_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_UC_UC_CORE_CFG_FW_API_DATA1r
#define READLN_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_TSCBH_FLEXE_XGXS_READLN_UC_UC_CORE_CFG_FW_API_DATA1r
#define WRITELN_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_UC_UC_CORE_CFG_FW_API_DATA1r
#define WRITEALL_UC_UC_CORE_CFG_FW_API_DATA1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_UC_UC_CORE_CFG_FW_API_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_UC_UC_CORE_CFG_FW_API_DATA1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd310
 * DEVAD:    1
 * DESC:     tlb_err_aggr Control 0
 * RESETVAL: 0xc (12)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_AGGR_EN  Enables the multi lane error aggregation to start perfoming error analysis
 *     TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUS When a write is executed in this register, it will clear all the error aggregation error count status registers.This register is self-clear.
 *     TLB_ERR_AGGR_ERROR_COUNT_THRESH Error threshold number beyond which the error aggregation would count a bad frame.Valid values for this field are from 0-15
 *     TLB_ERR_AGGR_LANES_ACTIVE Out of lanes 0-7, which lanes are chosen for aggregation00000001 - lane 0 active, 11111111 - all lanes activeFor a quad lane core, top 4 bits should be 0000For a bi lane core, top 6 bits should be 000000
 *     TLB_ERR_AGGR_MODE Defines how many lanes are being aggregated00-not active (clock gated), 01 - bi lane, 10 - quad, 11 - octal
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r (0x0001d310 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_tlb_err_aggr_cfg0[1];
	uint32_t _tlb_err_aggr_tlb_err_aggr_cfg0;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_CLR(r) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SET(r,d) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_GET(r) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 14) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 6) & 0xff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 2) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) >> 1) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_GET(r) (((r).tlb_err_aggr_tlb_err_aggr_cfg0[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg0[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r,(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r,(_r._tlb_err_aggr_tlb_err_aggr_cfg0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r,(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_tlb_err_aggr_cfg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_t TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_t;
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_CLR
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_MODEf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_LANES_ACTIVEf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ERROR_COUNT_THRESHf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_CLEAR_ERROR_ANALYZER_STATUSf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r_TLB_ERR_AGGR_ENf_SET
#define READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r
#define WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd311
 * DEVAD:    1
 * DESC:     TLB_RX_B Control 1
 * RESETVAL: 0xa3 (163)
 * ACCESS:   R/W
 * FIELDS:
 *     TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESH Sets the value x, which determines counting the number of FEC frames with x, x+1,..,x+7 errorsValid values for this field are from 0-8
 *     TLB_ERR_AGGR_CLEAR_STATUS_ON_READ Enables read on clear for all error status counters
 *     TLB_ERR_AGGR_GCLK_DIV2_EN_IGNORE When this bit is unset, it uses clk32 to sample lane error frame counters instead of clk16.This mode should only be used in PAM4 OS2 mode. This is a debug feature.
 *     TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTH These bits define the depth of pattern recognition for enabling the tlb error aggregation block0 - Detects 9'bxxxxxxx10, 1 - Detects 9'bxxxxxx100, 2 - Detects 9'bxxxxx1000, 3 - Detects 9'bxxxx10000.4 - Detects 9'bxxx100000, 5 - Detects 9'bxx1000000, 6 - Detects 9'bx10000000, 7 - Detects 9'b100000000.0 - This is a debug feature
 *     TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTH These bits define the depth of pattern recognition for enabling the tlb error aggregation block0 - Out of sync 4 clk_16s, 1 - Out of sync 5 clk_16s, 2 - Out of sync 6 clk_16s, 3 - Out of sync 7 clk_16s4 - Out of sync 8 clk_16s, 5 - Out of sync 9 clk_16s, 6 - Out of sync 10 clk_16s, 7 - Out of sync 11 clk_16sThe number of programmed clock cycles should be less than the FEC frame size value 'N' (tlb_err_fec_size)0 - This is a debug feature
 *     TLB_ERR_AGGR_DELAY_DATA_CAPTURE From when the error data launches, delay the capturing of data0 - 3 clks, 1 - 4 clks, 2 - 5 clks, 3 - 6 clks0 - clk by default is clk16. There is a feature to make the clock clk320 - This is a debug feature
 *     TLB_ERR_AGGR_EN_FORCE Enables the aggregation block by force even when the pattern is not matched0 - This is a debug feature
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r (0x0001d311 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_tlb_err_aggr_cfg1[1];
	uint32_t _tlb_err_aggr_tlb_err_aggr_cfg1;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_CLR(r) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SET(r,d) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_GET(r) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 12) & 0x3)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 9) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 6) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_GET(r) ((((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_GET(r) (((r).tlb_err_aggr_tlb_err_aggr_cfg1[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_SET(r,f) (r).tlb_err_aggr_tlb_err_aggr_cfg1[0]=(((r).tlb_err_aggr_tlb_err_aggr_cfg1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r,(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r,(_r._tlb_err_aggr_tlb_err_aggr_cfg1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r,(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_tlb_err_aggr_cfg1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_tlb_err_aggr_cfg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_t TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_t;
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_CLR
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_EN_FORCEf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_DELAY_DATA_CAPTUREf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLK_OUT_OF_SYNC_PATTERN_DEPTHf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_ACTIVE_PATTERN_DEPTHf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_GCLK_DIV2_EN_IGNOREf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_CLEAR_STATUS_ON_READf_SET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_GET
#define TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r_TLB_ERR_AGGR_HISTOGRAM_ERROR_THRESHf_SET
#define READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r
#define WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_TLB_ERR_AGGR_CFG1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HI
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd315
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_ERROR_HI Top 4 bits out of 20 bit register that stores the status of how many number of FEC frames have errors >= tlb_err_aggr_error_count_threshtlb_err_aggr_count_error_lo needs to be read before this status register to read the correct value
 *     TLB_ERR_AGGR_ACTIVE_STATUS This bit is set when the tlb error aggregation feature is enabled after pattern recognition
 *     TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUS This bit indicates that a clocks out of sync scenario is detected due to clock wander
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr (0x0001d315 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_num_errs_in_fec_frames_sts_hi[1];
	uint32_t _tlb_err_aggr_num_errs_in_fec_frames_sts_hi;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET(r,d) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_GET(r) ((((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_GET(r) ((((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_GET(r) (((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]) & 0xf)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_hi[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HI.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_t;
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_CLR
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_CLKS_OUT_OF_SYNC_STATUSf_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_ACTIVE_STATUSf_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr_TLB_ERR_AGGR_COUNT_ERROR_HIf_SET
#define READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr
#define WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_HIr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LO
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd316
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_ERROR_LO Bottom 16 bits out of 20 bit register that stores the status of how many number of FEC frames have errors >= tlb_err_aggr_error_count_thresh
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr (0x0001d316 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_num_errs_in_fec_frames_sts_lo[1];
	uint32_t _tlb_err_aggr_num_errs_in_fec_frames_sts_lo;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET(r,d) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET(r) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_GET(r) (((r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_SET(r,f) (r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0]=(((r).tlb_err_aggr_num_errs_in_fec_frames_sts_lo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LO.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_num_errs_in_fec_frames_sts_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_t;
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_CLR
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_SET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_GET
#define TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr_TLB_ERR_AGGR_COUNT_ERROR_LOf_SET
#define READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr
#define WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_NUM_ERRS_IN_FEC_FRAMES_STS_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd317
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7 Number of times 'N+7' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r (0x0001d317 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs7[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs7;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs7[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs7[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs7[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs7[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_err_aggr_cnt_histogram_err_offs7)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r,(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs7))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_7f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd318
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6 Number of times 'N+6' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r (0x0001d318 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs6[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs6;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs6[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs6[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs6[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs6[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_err_aggr_cnt_histogram_err_offs6)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r,(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs6))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_6f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd319
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5 Number of times 'N+5' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r (0x0001d319 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs5[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs5;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs5[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs5[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs5[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs5[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_err_aggr_cnt_histogram_err_offs5)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r,(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs5))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_5f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31a
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4 Number of times 'N+4' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r (0x0001d31a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs4[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs4;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs4[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs4[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs4[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs4[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_err_aggr_cnt_histogram_err_offs4)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r,(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs4))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_4f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31b
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3 Number of times 'N+3' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r (0x0001d31b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs3[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs3;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs3[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs3[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs3[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs3[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_err_aggr_cnt_histogram_err_offs3)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r,(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs3))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_3f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31c
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2 Number of times 'N+2' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r (0x0001d31c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs2[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs2;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs2[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs2[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs2[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs2[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_err_aggr_cnt_histogram_err_offs2)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r,(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs2))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_2f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31d
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1 Number of times 'N+1' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r (0x0001d31d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs1[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs1;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs1[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs1[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs1[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs1[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_err_aggr_cnt_histogram_err_offs1)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r,(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs1))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_1f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0
 * BLOCKS:   TLB_ERR_AGGR
 * REGADDR:  0xd31e
 * DEVAD:    1
 * DESC:     tlb_err_aggr Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0 Number of times 'N' errors occurr in FEC frames, where N is defined by the register tlb_err_aggr_histogram_error_thresh.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r (0x0001d31e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SIZE 4

/*
 * This structure should be used to declare and program TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_s {
	uint32_t v[1];
	uint32_t tlb_err_aggr_cnt_histogram_err_offs0[1];
	uint32_t _tlb_err_aggr_cnt_histogram_err_offs0;
} BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_t;

#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_CLR(r) (r).tlb_err_aggr_cnt_histogram_err_offs0[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SET(r,d) (r).tlb_err_aggr_cnt_histogram_err_offs0[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_GET(r) (r).tlb_err_aggr_cnt_histogram_err_offs0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET(r) (((r).tlb_err_aggr_cnt_histogram_err_offs0[0]) & 0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET(r,f) (r).tlb_err_aggr_cnt_histogram_err_offs0[0]=(((r).tlb_err_aggr_cnt_histogram_err_offs0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_err_aggr_cnt_histogram_err_offs0)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r,(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_err_aggr_cnt_histogram_err_offs0))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_err_aggr_cnt_histogram_err_offs0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SIZE BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_t TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_t;
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_CLR BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_CLR
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_SET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_GET
#define TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r_TLB_ERR_AGGR_COUNT_HISTOGRAM_ERROR_OFFSET_0f_SET
#define READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_READ_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_WRITE_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_MODIFY_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_READLN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_WRITELN_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r
#define WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r BCMI_TSCBH_FLEXE_XGXS_WRITEALL_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_TLB_ERR_AGGR_CNT_HISTOGRAM_ERR_OFFS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_CTL
 * BLOCKS:   DSC_G
 * REGADDR:  0xd414
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_ctrl register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_DFE_TAP2_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXB_DFE_TAP2_VAL signed 2's complement  +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2_WRITE write strobe for writing to rxa_dfe_tap2; need to set rx_afe_override_sel to 6
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr (0x0001d414 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_ctl[1];
	uint32_t _dsc_rx_dfe_tap2_ctl;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_CLR(r) (r).dsc_rx_dfe_tap2_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_SET(r,d) (r).dsc_rx_dfe_tap2_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_GET(r) (r).dsc_rx_dfe_tap2_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap2_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_ctl[0]) >> 10) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_ctl[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_GET(r) (((r).dsc_rx_dfe_tap2_ctl[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_ctl[0]=(((r).dsc_rx_dfe_tap2_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr,(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr,(_r._dsc_rx_dfe_tap2_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr,(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_CTLr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr
#define DSC_RX_DFE_TAP2_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_t DSC_RX_DFE_TAP2_CTLr_t;
#define DSC_RX_DFE_TAP2_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_CLR
#define DSC_RX_DFE_TAP2_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_SET
#define DSC_RX_DFE_TAP2_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_GET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXA_DFE_TAP2_VALf_SET
#define DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXB_DFE_TAP2_VALf_SET
#define DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr_RXC_DFE_TAP2_VALf_SET
#define READ_DSC_RX_DFE_TAP2_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_CTLr
#define WRITE_DSC_RX_DFE_TAP2_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_CTLr
#define MODIFY_DSC_RX_DFE_TAP2_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_CTLr
#define READLN_DSC_RX_DFE_TAP2_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_CTLr
#define WRITELN_DSC_RX_DFE_TAP2_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_CTLr
#define WRITEALL_DSC_RX_DFE_TAP2_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_3_CTL
 * BLOCKS:   DSC_G
 * REGADDR:  0xd415
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_3_ctrl register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP2_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP2_WRITE write strobe for writing to rxd_dfe_tap2; need to set rx_afe_override_sel to 6
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr (0x0001d415 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_3_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_3_ctl[1];
	uint32_t _dsc_rx_dfe_tap2_3_ctl;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_CLR(r) (r).dsc_rx_dfe_tap2_3_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SET(r,d) (r).dsc_rx_dfe_tap2_3_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_GET(r) (r).dsc_rx_dfe_tap2_3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap2_3_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_3_ctl[0]) >> 10) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_GET(r) ((((r).dsc_rx_dfe_tap2_3_ctl[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_GET(r) (((r).dsc_rx_dfe_tap2_3_ctl[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap2_3_ctl[0]=(((r).dsc_rx_dfe_tap2_3_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_3_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr,(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr,(_r._dsc_rx_dfe_tap2_3_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr,(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_3_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_3_CTLr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr
#define DSC_RX_DFE_TAP2_3_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_t DSC_RX_DFE_TAP2_3_CTLr_t;
#define DSC_RX_DFE_TAP2_3_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_CLR
#define DSC_RX_DFE_TAP2_3_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_SET
#define DSC_RX_DFE_TAP2_3_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXD_DFE_TAP2_VALf_SET
#define DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXA_DFE_TAP3_VALf_SET
#define DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr_RXB_DFE_TAP3_VALf_SET
#define READ_DSC_RX_DFE_TAP2_3_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP2_3_CTLr
#define WRITE_DSC_RX_DFE_TAP2_3_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP2_3_CTLr
#define MODIFY_DSC_RX_DFE_TAP2_3_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP2_3_CTLr
#define READLN_DSC_RX_DFE_TAP2_3_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP2_3_CTLr
#define WRITELN_DSC_RX_DFE_TAP2_3_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP2_3_CTLr
#define WRITEALL_DSC_RX_DFE_TAP2_3_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP2_3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP2_3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_DFE_TAP3_CTL
 * BLOCKS:   DSC_G
 * REGADDR:  0xd416
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_ctrl register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP3_VAL signed 2's complement +/-15, 1LSB=150mV/64
 *     RXD_DFE_TAP3_WRITE write strobe for writing to rxd_dfe_tap3; need to set rx_afe_override_sel to 6
 *     RXC_DFE_TAP3_WRITE write strobe for writing to rxc_dfe_tap3; need to set rx_afe_override_sel to 6
 *     RXB_DFE_TAP3_WRITE write strobe for writing to rxb_dfe_tap3; need to set rx_afe_override_sel to 6
 *     RXA_DFE_TAP3_WRITE write strobe for writing to rxa_dfe_tap3; need to set rx_afe_override_sel to 6
 *     RXC_DFE_TAP2_WRITE write strobe for writing to rxc_dfe_tap2; need to set rx_afe_override_sel to 6
 *     RXB_DFE_TAP2_WRITE write strobe for writing to rxb_dfe_tap2; need to set rx_afe_override_sel to 6
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr (0x0001d416 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_CTL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_ctl[1];
	uint32_t _dsc_rx_dfe_tap3_ctl;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_CLR(r) (r).dsc_rx_dfe_tap3_ctl[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_SET(r,d) (r).dsc_rx_dfe_tap3_ctl[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_GET(r) (r).dsc_rx_dfe_tap3_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 13) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 11) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 10) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_GET(r) ((((r).dsc_rx_dfe_tap3_ctl[0]) >> 5) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_GET(r) (((r).dsc_rx_dfe_tap3_ctl[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_SET(r,f) (r).dsc_rx_dfe_tap3_ctl[0]=(((r).dsc_rx_dfe_tap3_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_CTL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr,(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr,(_r._dsc_rx_dfe_tap3_ctl)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr,(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP3_CTLr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_ctl))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP3_CTLr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap3_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_CTLr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr
#define DSC_RX_DFE_TAP3_CTLr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_t DSC_RX_DFE_TAP3_CTLr_t;
#define DSC_RX_DFE_TAP3_CTLr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_CLR
#define DSC_RX_DFE_TAP3_CTLr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_SET
#define DSC_RX_DFE_TAP3_CTLr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_GET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP2_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXA_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXB_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_WRITEf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXC_DFE_TAP3_VALf_SET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_GET
#define DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr_RXD_DFE_TAP3_VALf_SET
#define READ_DSC_RX_DFE_TAP3_CTLr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_DFE_TAP3_CTLr
#define WRITE_DSC_RX_DFE_TAP3_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_DFE_TAP3_CTLr
#define MODIFY_DSC_RX_DFE_TAP3_CTLr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_DFE_TAP3_CTLr
#define READLN_DSC_RX_DFE_TAP3_CTLr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_DFE_TAP3_CTLr
#define WRITELN_DSC_RX_DFE_TAP3_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_DFE_TAP3_CTLr
#define WRITEALL_DSC_RX_DFE_TAP3_CTLr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_DFE_TAP3_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_DFE_TAP3_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  DSC_RX_PF_CTL_DC_OFFS_AND_VGA
 * BLOCKS:   DSC_H
 * REGADDR:  0xd42e
 * DEVAD:    1
 * DESC:     rx_pf_ctrl_dc_offset_and_vga register.
 * RESETVAL: 0x27 (39)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_VGA_VAL       this is the value of vga that sets the final vga value
 *     RX_PF2_CTRL_VAL  DC cut (Low PF),
 *     RX_PF_CTRL_VAL   Main Peaking Filter
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr (0x0001d42e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PF_CTL_DC_OFFS_AND_VGA.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pf_ctl_dc_offs_and_vga[1];
	uint32_t _dsc_rx_pf_ctl_dc_offs_and_vga;
} BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_t;

#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_CLR(r) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SET(r,d) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_GET(r) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs_and_vga[0]) >> 10) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]=(((r).dsc_rx_pf_ctl_dc_offs_and_vga[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs_and_vga[0]) >> 7) & 0x7)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]=(((r).dsc_rx_pf_ctl_dc_offs_and_vga[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_VALf_GET(r) (((r).dsc_rx_pf_ctl_dc_offs_and_vga[0]) & 0x7f)
#define BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_VALf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs_and_vga[0]=(((r).dsc_rx_pf_ctl_dc_offs_and_vga[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_RX_PF_CTL_DC_OFFS_AND_VGA.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr,(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr,(_r._dsc_rx_pf_ctl_dc_offs_and_vga)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr,(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pf_ctl_dc_offs_and_vga))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pf_ctl_dc_offs_and_vga))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SIZE BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_t DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_t;
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_CLR BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_CLR
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_SET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF_CTRL_VALf_SET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_PF2_CTRL_VALf_SET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_VALf_GET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_VALf_GET
#define DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_VALf_SET BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr_RX_VGA_VALf_SET
#define READ_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_TSCBH_FLEXE_XGXS_READ_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define WRITE_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_TSCBH_FLEXE_XGXS_WRITE_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define MODIFY_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_TSCBH_FLEXE_XGXS_MODIFY_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define READLN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_TSCBH_FLEXE_XGXS_READLN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define WRITELN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_TSCBH_FLEXE_XGXS_WRITELN_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr
#define WRITEALL_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_DSC_RX_PF_CTL_DC_OFFS_AND_VGAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MDIO_BCST_PORT_ADDR
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdc
 * DEVAD:    1
 * DESC:     Broadcast Port Address
 * RESETVAL: 0x1f (31)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BRCST_PORT_ADDR Braodcast port address that can be used to broadcast mdio commandsto multiple controllers connected to the same mdio station manager
 *     MDIO_DRV_COMCLK  Debug control bit to select between mdio_clk and comclk to drive out mdio_out and mdio_oeb signals.0=mdio_clk, 1=comclk
 */
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr (0x0001ffdc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BCST_PORT_ADDR.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_bcst_port_addr[1];
	uint32_t _mdio_bcst_port_addr;
} BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_CLR(r) (r).mdio_bcst_port_addr[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_SET(r,d) (r).mdio_bcst_port_addr[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_GET(r) (r).mdio_bcst_port_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET(r) ((((r).mdio_bcst_port_addr[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET(r) (((r).mdio_bcst_port_addr[0]) & 0x1f)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access MDIO_BCST_PORT_ADDR.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_bcst_port_addr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BCST_PORT_ADDRr BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr
#define MDIO_BCST_PORT_ADDRr_SIZE BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_t MDIO_BCST_PORT_ADDRr_t;
#define MDIO_BCST_PORT_ADDRr_CLR BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_CLR
#define MDIO_BCST_PORT_ADDRr_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_SET
#define MDIO_BCST_PORT_ADDRr_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_DRV_COMCLKf_SET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET
#define READ_MDIO_BCST_PORT_ADDRr BCMI_TSCBH_FLEXE_XGXS_READ_MDIO_BCST_PORT_ADDRr
#define WRITE_MDIO_BCST_PORT_ADDRr BCMI_TSCBH_FLEXE_XGXS_WRITE_MDIO_BCST_PORT_ADDRr
#define MODIFY_MDIO_BCST_PORT_ADDRr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr
#define READLN_MDIO_BCST_PORT_ADDRr BCMI_TSCBH_FLEXE_XGXS_READLN_MDIO_BCST_PORT_ADDRr
#define WRITELN_MDIO_BCST_PORT_ADDRr BCMI_TSCBH_FLEXE_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr
#define WRITEALL_MDIO_BCST_PORT_ADDRr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MDIO_BCST_PORT_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MDIO_MMD_SEL
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdd
 * DEVAD:    1
 * DESC:     MMD Select
 * RESETVAL: 0x404d (16461)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DEV_ID0_EN  When set and mdio_multi_mmds_en=1 then device id 0 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PMD_EN  When set and mdio_multi_mmds_en=1 then the PMD device=1 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_AN_EN   When set and mdio_multi_mmds_en=1 then the AN device=7 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PHY_EN  When set and mdio_multi_mmds_en=1 then the PHY device=4 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_DTE_EN  When set and mdio_multi_mmds_en=1 then the DTE device=5 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PCS_EN  When set and mdio_multi_mmds_en=1 then the PCS device=3 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_MULTI_MMDS_EN When set enables the multiple MMD functionality.  MD_ST is ignored andeach device can be accessed directly with the appropriate CL45protocol.
 *     MDIO_MULTI_PRTS_EN When set enables multiple prtad functionality.  Each of the lanes'mmds can be accessed with consecutive PRTADs.  Lane 0 is accessedwith PRTAD_STRAP, lane 1 with PRTAD_STRAP+1, lane 2 with PRTAD_STRAP+2and lane 3 with PRTAD_STRAP+3.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr (0x0001ffdd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MMD_SEL.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_s {
	uint32_t v[1];
	uint32_t mdio_mmd_sel[1];
	uint32_t _mdio_mmd_sel;
} BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_CLR(r) (r).mdio_mmd_sel[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_SET(r,d) (r).mdio_mmd_sel[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_GET(r) (r).mdio_mmd_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 15) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 14) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 6) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 5) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 4) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 3) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 2) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_GET(r) (((r).mdio_mmd_sel[0]) & 0x1)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_MMD_SEL.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_MDIO_MMD_SELr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_mmd_sel))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MMD_SELr BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr
#define MDIO_MMD_SELr_SIZE BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_t MDIO_MMD_SELr_t;
#define MDIO_MMD_SELr_CLR BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_CLR
#define MDIO_MMD_SELr_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_SET
#define MDIO_MMD_SELr_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr_MDIO_DEV_ID0_ENf_SET
#define READ_MDIO_MMD_SELr BCMI_TSCBH_FLEXE_XGXS_READ_MDIO_MMD_SELr
#define WRITE_MDIO_MMD_SELr BCMI_TSCBH_FLEXE_XGXS_WRITE_MDIO_MMD_SELr
#define MODIFY_MDIO_MMD_SELr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MDIO_MMD_SELr
#define READLN_MDIO_MMD_SELr BCMI_TSCBH_FLEXE_XGXS_READLN_MDIO_MMD_SELr
#define WRITELN_MDIO_MMD_SELr BCMI_TSCBH_FLEXE_XGXS_WRITELN_MDIO_MMD_SELr
#define WRITEALL_MDIO_MMD_SELr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_MDIO_MMD_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MDIO_MMD_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_TSCBH_FLEXE_XGXS
 * REGISTER:  MDIO_AER
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffde
 * DEVAD:    1
 * DESC:     AER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_AER         Provides 11-bits of 32-bit address for clause45 mdio transactions
 */
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr (0x0001ffde | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_AER.
 */
typedef union BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_s {
	uint32_t v[1];
	uint32_t mdio_aer[1];
	uint32_t _mdio_aer;
} BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_t;

#define BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_CLR(r) (r).mdio_aer[0] = 0
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_SET(r,d) (r).mdio_aer[0] = d
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_GET(r) (r).mdio_aer[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_MDIO_AERf_GET(r) (((r).mdio_aer[0]) & 0x7ff)
#define BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_MDIO_AERf_SET(r,f) (r).mdio_aer[0]=(((r).mdio_aer[0] & ~((uint32_t)0x7ff)) | (((uint32_t)f) & 0x7ff)) | (0x7ff << 16)

/*
 * These macros can be used to access MDIO_AER.
 */
#define BCMI_TSCBH_FLEXE_XGXS_READ_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_TSCBH_FLEXE_XGXS_WRITE_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr,(_r._mdio_aer)&0xffff)
#define BCMI_TSCBH_FLEXE_XGXS_MODIFY_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_TSCBH_FLEXE_XGXS_READLN_MDIO_AERr(_pc,_l,_r) phymod_tscbh_iblk_read(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_TSCBH_FLEXE_XGXS_WRITELN_MDIO_AERr(_pc,_l,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_TSCBH_FLEXE_XGXS_WRITEALL_MDIO_AERr(_pc,_r) phymod_tscbh_iblk_write(_pc,BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_aer))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_AERr BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr
#define MDIO_AERr_SIZE BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_SIZE
typedef BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_t MDIO_AERr_t;
#define MDIO_AERr_CLR BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_CLR
#define MDIO_AERr_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_SET
#define MDIO_AERr_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_GET
#define MDIO_AERr_MDIO_AERf_GET BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_MDIO_AERf_GET
#define MDIO_AERr_MDIO_AERf_SET BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr_MDIO_AERf_SET
#define READ_MDIO_AERr BCMI_TSCBH_FLEXE_XGXS_READ_MDIO_AERr
#define WRITE_MDIO_AERr BCMI_TSCBH_FLEXE_XGXS_WRITE_MDIO_AERr
#define MODIFY_MDIO_AERr BCMI_TSCBH_FLEXE_XGXS_MODIFY_MDIO_AERr
#define READLN_MDIO_AERr BCMI_TSCBH_FLEXE_XGXS_READLN_MDIO_AERr
#define WRITELN_MDIO_AERr BCMI_TSCBH_FLEXE_XGXS_WRITELN_MDIO_AERr
#define WRITEALL_MDIO_AERr BCMI_TSCBH_FLEXE_XGXS_WRITEALL_MDIO_AERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCBH_FLEXE_XGXS_MDIO_AERr'
 */




#endif /* __BCMI_TSCBH_FLEXE_XGXS_DEFS_H__ */
