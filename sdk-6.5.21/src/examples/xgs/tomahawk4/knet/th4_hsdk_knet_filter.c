/*  Feature  : KNET
 *
 *  Usage    : BCM.0> cint th4_hsdk_knet_filter.c
 *
 *  config   : bcm56990_a0-generic-64x400_knet_config.yml
 *
 *  Log file : th4_hsdk_knet_filter_log.txt
 *
 *  Test Topology :
 *
 *                   +------------------------------+
 *                   |                              |
 *                   |                              |
 *                   |                              |
 *                   |                              |
 *  +----------------+          SWITCH              +-----------------+
 *                   |                              |
 *                   |                              |
 *                   |                              |
 *                   |                              |
 *                   |                              |
 *                   +------------------------------+
 *
 *
 *  Summary:
 *  ========
 *    This CINT script demonstrate how to send and receive packets using
 *    a KNET virtual network interface. This example shows how to create a
 *    virtual network interface using the PKTIO KNET API. It also includes
 *    source for sample programs that send and receive network packets using
 *    standard sockets.
 *    
 *    Prerequistes:
 *    =============
 *      a) Build HSDK, the KNET feature is built by default.
 *      b) Compile th4_hsdk_knet_tx and th4_hsdk_knet_rx from the source files
 *         th4_hsdk_knet_tx.c and th4_hsdk_knet_rx.c for test target CPU.
 *     
 *    Detailed steps performed by the CINT script:
 *    ============================================
 *
 *    =====================================================
 *    1) Step1 - Test Setup: Create and configure a single KNET virtual network
 *       interface using the function "create_knet_interface()".
 *       Configure the rest of the switch using "test_setup()".
 *      a) Create KNET interface that is bound to a port using
 *         BCM_PKTIO_NETIF_F_BIND_TX_PORT.
 *      b) Create low priority KNET filters to drop broadcast and multicast
 *         packets that are generated by the Linux network stack.
 *      c) Create a high priority KNET filter to divert select protocol
 *         packets to the KNET interface.
 *    2) Step2 - Configuration: Configure switch elements for test.
 *      a) Enable switch control "ArpReplyToCpu" and "ArpRequestCpu"
 *      b) Register Rx Callback
 *      c) Bring up network interface using a system call to "ifconfig"
 *      d) Configure ports using "bshell".
 *        
 *    3) Step3 - Verification (Done in verify())
 *      a) Execute the program "th4_hsdk_knet_rx" in background
 *      b) Execute the program "th4_hsdk_knet_tx" in foreground, transmit 4 protcol
 *         packets.
 *      c) Display KNET filter statistics.
 *
 *      Expected Result:
 *      knet_tx executable will send 4 packets over KNET interface
 *
 *      knet_rx executable will receive 4 packets over KNET interface
 *      and display and them.
 *
 *      The KNET filter statistics shows that there are 4 KNET filters:
 *        i) A "catch all" filter that directs packets to the PKTIO RX
 *           interface. Packets matching on this filter will be displayed
 *           by the RX callback function in this file. If everything
 *           works correctly, no packets should be displayed by the
 *           callbck and the "hits" count should be zero.
 *        ii) A filter called "Broadcast Drop" that causes matching
 *           broadcast packets to be dropped by the KNET driver. Sometimes
 *           the operating system may transmit broadcast packets and we
 *           don't want to display these. Hits should be zero
 *        iii) A filter called "Multicast Drop" that causes matching
 *           multicast packets to be dropped by the KNET driver. Sometimes
 *           the operating system may transmit multicast packets and we
 *           don't want to display these. Hits should be zero
 *        iv) A filter called "CPU Protocol" that causes matching packets
 *            to be sent to the KNET interface. The hits count should be 4.
 */

cint_reset();

/* Data structure used by RX callback to track status packets. */
typedef struct rx_counts_t {
    int                 tx_app_pkt_count;
    int                 rx_app_pkt_count;
    int                 unexpected;
};

/*******************************************************************************
 * Function: create_knet_interface
 *
 * Create a KNET interface bound to a specified port. Add a filter to direct
 * protocol packets to CPU and multiple filters to drop unwanted packets.
 *
 * Parameters:
 *   unit: Unit number for device under test (DUT)
 *   port: Port to bind KNET interface to.
 *   vlan: VLAN of new network interface
 *   interface_name: Name of new KNET interface
 *   local_mac: MAC address associated with new KNET interface
 *
 * Returns:
 * BCM_E_NONE on success, otherwise a bcm_error_t enum specifying reason
 * for failure.
 */
bcm_error_t
create_knet_interface(int unit, bcm_port_t port, bcm_vlan_t vlan, char *interface_name,
                      bcm_mac_t local_mac)
{
    /* Local RX MAC address */
    const uint8         application_status[6] = { 0x88, 0x88, 0x88, 0x88, 0x88, 0x88 };

    /* Standard multicast MAC address */
    const uint8         multicast_mac_addr[5] = { 0x01, 0x00, 0x5E, 0x00, 0x00 };

    /* RS destination MAC address */
    const uint8         rs_dest_mac_addr[2] = { 0x33, 0x33 };

    bcm_error_t         rv;
    bcm_pktio_filter_t  broadcast_filter;
    bcm_pktio_filter_t  cpu_protocol_filter;
    bcm_pktio_filter_t  multicast_filter;
    bcm_pktio_filter_t  rs_dest_filter;
    bcm_pktio_filter_t  application_filter;
    bcm_pktio_netif_t   netif;
    int                 idx;

    /* Create an interface bound to specific port */
    sal_memset(&netif, 0, sizeof(netif));
    netif.flags |= BCM_PKTIO_NETIF_F_BIND_TX_PORT;
    netif.vlan = vlan;
    netif.port = port;
    /* Set device name */
    sal_strcpy(netif.name, interface_name);
    /* Set MAC address associated with this interface */
    netif.mac_addr = local_mac;

    rv = bcm_pktio_netif_create(unit, &netif);
    if (BCM_FAILURE(rv)) {
        printf("\nError in bcm_pktio_netif_create(): %s\n", bcm_errmsg(rv));
        return rv;
    }

    /* Add a drop filter to catch broadcast packets, we don't want to see these. */
    sal_memset(&broadcast_filter, 0, sizeof(broadcast_filter));
    sal_strcpy(broadcast_filter.desc, "Broadcast Drop");
    broadcast_filter.type = BCM_PKTIO_FILTER_T_RX_PKT;
    broadcast_filter.priority = 250;    /* Low but not lowest */
    /* Drop packet */
    broadcast_filter.dest_type = BCM_PKTIO_DEST_T_NULL;
    broadcast_filter.dest_id = netif.id;
    /* Set up raw match on first 6 bytes of the packet */
    broadcast_filter.match_flags = BCM_PKTIO_FILTER_M_RAW;
    broadcast_filter.raw_size = 6;
    for (idx = 0; idx < broadcast_filter.raw_size; idx++) {
        broadcast_filter.m_raw_data[idx] = 0xFF;        /* Raw data to match. */
        broadcast_filter.m_raw_mask[idx] = 0xFF;        /* Raw data mask to match. */
    }
    rv = bcm_pktio_filter_create(unit, &broadcast_filter);
    if (BCM_FAILURE(rv)) {
        printf("\nError in bcm_pktio_filter_create() : %s\n", bcm_errmsg(rv));
        return rv;
    }

    /* Add a drop filter to catch multicast packets, we don't want to see these. */
    sal_memset(&multicast_filter, 0, sizeof(multicast_filter));
    sal_strcpy(multicast_filter.desc, "Multicast Drop");
    multicast_filter.type = BCM_PKTIO_FILTER_T_RX_PKT;
    multicast_filter.priority = 251;    /* Low but not lowest */
    /* Drop packet */
    multicast_filter.dest_type = BCM_PKTIO_DEST_T_NULL;
    multicast_filter.dest_id = netif.id;
    /* Set up raw match on first 5 bytes of the packet */
    multicast_filter.match_flags = BCM_PKTIO_FILTER_M_RAW;
    multicast_filter.raw_size = 5;
    for (idx = 0; idx < multicast_filter.raw_size; idx++) {
        multicast_filter.m_raw_data[idx] = multicast_mac_addr[idx];     /* Raw data to match. */
        multicast_filter.m_raw_mask[idx] = 0xFF;        /* Raw data mask to match. */
    }
    rv = bcm_pktio_filter_create(unit, &multicast_filter);
    if (BCM_FAILURE(rv)) {
        printf("\nError in bcm_pktio_filter_create() : %s\n", bcm_errmsg(rv));
        return rv;
    }

    /* Add a drop filter to catch RS destination packets, we don't want to see these. */
    sal_memset(&rs_dest_filter, 0, sizeof(rs_dest_filter));
    sal_strcpy(rs_dest_filter.desc, "RS Dest Drop");
    rs_dest_filter.type = BCM_PKTIO_FILTER_T_RX_PKT;
    rs_dest_filter.priority = 252;      /* Low but not lowest */
    /* Drop packet */
    rs_dest_filter.dest_type = BCM_PKTIO_DEST_T_NULL;
    rs_dest_filter.dest_id = netif.id;
    /* Set up raw match on first 2 bytes of the packet */
    rs_dest_filter.match_flags = BCM_PKTIO_FILTER_M_RAW;
    rs_dest_filter.raw_size = 2;
    for (idx = 0; idx < rs_dest_filter.raw_size; idx++) {
        rs_dest_filter.m_raw_data[idx] = rs_dest_mac_addr[idx]; /* Raw data to match. */
        rs_dest_filter.m_raw_mask[idx] = idx ? 0xFF : 0x00;     /* Raw data mask to match. */
    }
    rv = bcm_pktio_filter_create(unit, &rs_dest_filter);
    if (BCM_FAILURE(rv)) {
        printf("\nError in bcm_pktio_filter_create() : %s\n", bcm_errmsg(rv));
        return rv;
    }
//    Currently destintation type "API" isn't working: SDK-228384
//
//    /* Add special filter to catch status packets from TX/RX applications. */
//    sal_memset(&application_filter, 0, sizeof(application_filter));
//    sal_strcpy(application_filter.desc, "Application Status");
//    application_filter.type = BCM_PKTIO_FILTER_T_RX_PKT;
//    application_filter.priority = 25;
//    /* Send packet to RX callback */
//    application_filter.dest_type = BCM_PKTIO_DEST_T_BCM_RX_API;
//    //application_filter.dest_type = BCM_PKTIO_DEST_T_NETIF;
//    // application_filter.dest_id = 1;
//    /* Set up raw match on first 6 bytes of the packet */
//    application_filter.match_flags = BCM_PKTIO_FILTER_M_RAW;
//    application_filter.raw_size = 6;
//    for (idx = 0; idx < application_filter.raw_size; idx++) {
//        application_filter.m_raw_data[idx] = application_status[idx];   /* Raw data to match. */
//        application_filter.m_raw_mask[idx] = idx ? 0xFF : 0x00; /* Raw data mask to match. */
//    }
//    rv = bcm_pktio_filter_create(unit, &application_filter);
//    if (BCM_FAILURE(rv)) {
//        printf("\nError in bcm_pktio_filter_create() : %s\n", bcm_errmsg(rv));
//        return rv;
//    }

    /* Add filter to catch CPU protocol packets */
    sal_memset(&cpu_protocol_filter, 0, sizeof(cpu_protocol_filter));
    sal_strcpy(cpu_protocol_filter.desc, "CPU Protocol");
    cpu_protocol_filter.type = BCM_PKTIO_FILTER_T_RX_PKT;
    cpu_protocol_filter.flags = BCM_PKTIO_FILTER_F_STRIP_TAG;
    cpu_protocol_filter.priority = 55;
    cpu_protocol_filter.dest_type = BCM_PKTIO_DEST_T_NETIF;
    cpu_protocol_filter.dest_id = netif.id;
    cpu_protocol_filter.match_flags = BCM_PKTIO_FILTER_M_REASON;
    BCM_PKTIO_REASON_SET(&cpu_protocol_filter.m_reason,
                         BCM_PKTIO_RX_REASON_CPU_PROTOCOL_PKT);
    rv = bcm_pktio_filter_create(unit, &cpu_protocol_filter);
    if (BCM_FAILURE(rv)) {
        printf("\nError in bcm_pktio_filter_create(): %s\n", bcm_errmsg(rv));
        return rv;
    }
    return BCM_E_NONE;
}

/*******************************************************************************
 * Function: knet_setup
 *
 * Wrapper function for create_knet_interface.
 *
 * Parameters:
 *   unit: Unit number for device under test (DUT)
 *   interface_name: Name of new KNET interface
 *   port: Port to bind KNET interface to.
 *   vlan: VLAN of new network interface
 *
 * Returns:
 * BCM_E_NONE on success, otherwise a bcm_error_t enum specifying reason
 * for failure.
 */
bcm_error_t
knet_setup(int unit, char *interface_name, bcm_port_t port, bcm_vlan_t vlan)
{
    bcm_error_t         rv;
    const bcm_mac_t     local_mac = { 0x80, 0x80, 0x80, 0x80, 0x80, 0xF0 };

    printf("Create a KNET interface to handle protocol and local station packets\n");
    rv = create_knet_interface(unit, port, vlan, interface_name, local_mac);
    if (BCM_FAILURE(rv)) {
        printf("\nError in create_knet_interface(): %s\n", bcm_errmsg(rv));
        return rv;
    }

    return BCM_E_NONE;
}

/*******************************************************************************
 * Function: dump_buffer
 *
 * Utility function: print an unsigned character buffer
 *
 * Parameters:
 *   data: Pointer to buffer
 *   size: Size of buffer
 *
 * Returns:
 *   N/A
 */
void
dump_buffer(unsigned char *data, int size)
{
    const char         *const to_hex = "0123456789ABCDEF";
    int                 i;
    char                buffer[128];
    char               *buffer_ptr;
    int                 addr = 0;

    buffer_ptr = buffer;
    for (i = 0; i < size; i++) {
        *buffer_ptr++ = ' ';
        *buffer_ptr++ = to_hex[(data[i] >> 4) & 0xF];
        *buffer_ptr++ = to_hex[data[i] & 0xF];
        if (((i % 16) == 15) || (i == size - 1)) {
            *buffer_ptr = '\0';
            buffer_ptr = buffer;
            printf("%04X  %s\n", addr, buffer);
            addr = i + 1;
        }
    }
}

/*******************************************************************************
 * Function: my_pktio_rx_cb
 *
 * Receive Task Callback. Special status packets come in with a unique L2
 * header.  For these special packets, get embedded RX and TX counts. These
 * are later compared with expected values by the "verify" task. Packet NOT
 * matching these unique headers are printed, we don't expect these.
 *
 * Parameters:
 *   unit: Unit number for device under test (DUT)
 *   packet: Incoming packet, including PMD, headers and payload
 *   cookie: Pointer to structure to receive status packet counts
 *
 * Returns:
 * BCM_E_NONE on success, otherwise a bcm_error_t enum specifying reason
 * for failure.
 */
bcm_pktio_rx_t
my_pktio_rx_cb(int unit, bcm_pktio_pkt_t * packet, void *cookie)
{
    rx_counts_t        *count = (auto) cookie;
    bcm_pktio_reasons_t reasons;
    int                 reason;
    uint32              length;
    unsigned char      *buffer;
    int                 reason_count;
    const uint8         tx_status[18] =
      { 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x98, 0x98, 0x98, 0x98, 0x98, 0x98, 0x81,
        0x00, 0x00, 0x01, 0x99, 0x99
    };
    const uint8         rx_status[18] =
      { 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x81,
        0x00, 0x00, 0x01, 0x99, 0x99
    };

    if (BCM_FAILURE(bcm_pktio_pmd_reasons_get(unit, packet, &reasons))) {
        return BCM_PKTIO_RX_NOT_HANDLED;
    }

    /* Get the pointer to the incoming packet buffer */
    if (BCM_FAILURE(bcm_pktio_pkt_data_get(unit, packet, (void *) &buffer, &length))) {
        return BCM_PKTIO_RX_NOT_HANDLED;
    }

    if (sal_memcmp(tx_status, buffer, 18) == 0) {
        count->tx_app_pkt_count = (buffer[18] << 8) + buffer[19];
        printf("Received TX App status: TX App sent %d packets\n",
               count->tx_app_pkt_count);
    } else if (sal_memcmp(rx_status, buffer, 18) == 0) {
        count->rx_app_pkt_count = (buffer[18] << 8) + buffer[19];
        printf("Received RX App status: RX App received %d packets\n",
               count->tx_app_pkt_count);
    } else {
        printf
          ("---RX Callback------------------------------------------------------------------\n");
        printf("** Reasons:\n");
        reason_count = 0;
        BCM_PKTIO_REASON_ITER(reasons.rx_reasons, reason) {
            reason_count++;
            printf("   Reason[%d]: %d\n", reason_count, reason);
        }
        if (reason_count == 0) {
            printf("   None\n");
        }

        printf("Packet %d: %d bytes\n", count->unexpected, length);
        dump_buffer(buffer, length);
        printf
          ("//==//==//==//==//==//==//==//==//==//==//==//==//==//==//==//==//==//==//==//==//\n");

        count->unexpected++;
    }
    /* Packet handled. Dispatcher will skip next callback. */
    return BCM_PKTIO_RX_HANDLED;
}

/*******************************************************************************
 * Function: my_pktio_rx_register
 *
 * Register receive callback function for received packets.
 *
 * Parameters:
 *   unit: Unit number for device under test (DUT)
 *   count: Pointer to structure to receive status packet counts.
 *
 * Returns:
 * BCM_E_NONE on success, otherwise a bcm_error_t enum specifying reason
 * for failure.
 */
bcm_error_t
my_pktio_rx_register(int unit, rx_counts_t * count)
{
    const uint8         priority = 100;
    const uint32        flags = 0;      /* Flags only used on match (for now) */

    BCM_IF_ERROR_RETURN(bcm_pktio_rx_register
                        (unit, "rx_cb", my_pktio_rx_cb, priority, count, flags));
    printf("Registered RX Callback\n");
    return BCM_E_NONE;
}

/*******************************************************************************
 * Function: get_device_type
 *
 * Get current device type as listed on PCI bus. Used to determine if current
 * device is supported byt this test.
 *
 * Parameters:
 *   unit: Unit number for device under test (DUT)
 *   dev_type: Pointer to receive device type code.
 *
 * Returns:
 * BCM_E_NONE on success, otherwise a bcm_error_t enum specifying reason
 * for failure.
 */
bcm_error_t
get_device_type(int unit, uint32 * dev_type)
{
    bcm_info_t          info;

    BCM_IF_ERROR_RETURN(bcm_info_get(unit, &info));

    *dev_type = info.device & 0x0000FFF0;       /* Mask off lowest hex digit to get dev group */

    return BCM_E_NONE;
}

/*******************************************************************************
 * Function: test_setup
 *
 * Perform various "set up" operations including:
 *   1) Check DUT device type, reject unsupported devices.
 *   2) Register RX callback
 *   3) Direct ARP packets to the CPU
 *   4) Bring up KNET interface using "ifconfig"
 *   5) Configure test ports
 *
 * Parameters:
 *   unit: Unit number for device under test (DUT)
 *   count: Pointer to structure to receive status packet counts
 *   dev_type: Device type for DUT
 *   interface_name: Name of new KNET interface
 *
 * Returns:
 * BCM_E_NONE on success, otherwise a bcm_error_t enum specifying reason
 * for failure.
 */
bcm_error_t
test_setup(int unit, rx_counts_t * count, uint32 dev_type, char *interface_name)
{
    const int           verbose = 0;    /* For test debug */
    bcm_error_t         rv = BCM_E_NONE;
    char                command_string[80];

    if (dev_type != 0xB990) {
        printf("Unsupported Device Type: %04X\n", dev_type);
        return BCM_E_UNAVAIL;
    }

    rv = my_pktio_rx_register(unit, count);
    if (BCM_FAILURE(rv)) {
        printf("Error in my_pktio_rx_register(): %s\n", bcm_errmsg(rv));
        return rv;
    }

    rv = bcm_switch_control_set(unit, bcmSwitchArpReplyToCpu, TRUE);
    if (BCM_FAILURE(rv)) {
        printf("\nError in bcm_switch_control_set() 
                  bcmSwitchArpReplyToCpu : %s.\n", bcm_errmsg(rv));
        return rv;
    }

    rv = bcm_switch_control_set(unit, bcmSwitchArpRequestToCpu, TRUE);
    if (BCM_FAILURE(rv)) {
        printf("\nError in bcm_switch_control_set() 
                  bcmSwitchArpRequestToCpu : %s.\n", bcm_errmsg(rv));
        return rv;
    }

    /* Configure interface. Assign IP address and bring interface up. */
    sprintf(command_string,
            "sh /sbin/ifconfig %s 192.168.2.254 netmask 255.255.255.0 up",
            interface_name);
    bshell(unit, command_string);

    if (verbose) {
        /* Wait for interface to settle down. */
        sal_sleep(2);

        /* Display interface status */
        sprintf(command_string, "sh ifconfig %s", interface_name);
        bshell(unit, command_string);
    }

    /* Disble ports not used in this test */
    bshell(unit, "port xe,cd1-cd63 enable=false");

    /* Enable test port and put into loopback */
    bshell(unit, "port cd0 enable=true lb=mac");

    return rv;
}

/*******************************************************************************
 * Function: verify
 *
 * Verify KNET functionality:
 *   1) Spawn RX application in background.
 *   2) Run TX application in foreground.
 *   3) Verify status packets at RX callback after TX and RX application complete
 *
 * Parameters:
 *   unit: Unit number for device under test (DUT)
 *   interface_name: Name of KNET virtual network interface
 *   count: Data structure used to capture RX callback status packet
 *     information.
 *
 * Returns:
 * BCM_E_NONE on success, BCM_E_FAIL if RX status counts don't match expected.
 */
int
verify(int unit, char *interface_name, rx_counts_t * count)
{
    const int           pkts_to_send = 6;
    const int           verbose = 0;    /* For test debug */
    char                command_string[80];
    int                 success;

    /* Spawn background knet_rx process with 2 second timeout */
    sprintf(command_string, "sh ./th4_hsdk_knet_rx -timeout 2 %s %d &", interface_name,
            pkts_to_send + 1);
    bshell(unit, command_string);

    /* Send 4 packets using knet_tx */
    sprintf(command_string, "sh ./th4_hsdk_knet_tx -count %d %s", pkts_to_send,
            interface_name);
    bshell(unit, command_string);

    printf("Wait for TX and RX processes to complete\n");
    sal_sleep(8);

    if (verbose) {
        /* Display KNET filter statistics */
        bshell(unit, "sh cat /proc/linux_ngknet/filter_info");

        /* Wait for output */
        sal_sleep(2);
        printf
          ("\nConfirm the following filter \"hit counts\" to verify KNET functionality:\n");
        printf("  Filter ID 1 low priority \"catch all\" hit count should be zero\n");
        printf
          ("  Filter ID 2 Broadcast Drop hit count should be zero, ignore non zero counts\n");
        printf
          ("  Filter ID 3 Multicast Drop hit count should be zero, ignore non zero counts\n");
        printf
          ("  Filter ID 4 RS Dest Drop hit count should be zero, ignore non zero counts\n");
        printf("  Filter ID 5 CPU Protocol hit count should be %d\n", pkts_to_send);
    }
    success =
      (count->tx_app_pkt_count == pkts_to_send) &&
      (count->rx_app_pkt_count == pkts_to_send) && (count->unexpected == 0);

    if (!success) {
        printf("KNET Test Failure\n");
        if (count->tx_app_pkt_count != pkts_to_send) {
            printf("Expected TX count: %d; Actual TX count: %d\n", pkts_to_send,
                   count->tx_app_pkt_count);
        }
        if (count->rx_app_pkt_count != pkts_to_send) {
            printf("Expected RX count: %d; Actual RX count: %d\n", pkts_to_send,
                   count->rx_app_pkt_count);
        }
        if (count->unexpected != 0) {
            printf("%d unknown packets received by RX application\n", count->unexpected);
        }
    }
    return success ? BCM_E_NONE : BCM_E_FAIL;
}

/*******************************************************************************
 * Function: execute
 *
 * Test entry point. Test paramters defined here, calls "setup" and "verify"
 * functions.
 *
 * Parameters:
 *   None, all test parameters are defined by this function.
 *
 * Returns:
 * BCM_E_NONE on success, otherwise a bcm_error_t enum specifying reason
 * for failure.
 */
bcm_error_t
execute()
{
    const bcm_port_t    port = 1;       /* Coresponds to cd0 */
    const bcm_vlan_t    vlan = 1;
    const int           unit = 0;
    const char         *interface_name = "virt-intf0";

    bcm_error_t         rv;
    rx_counts_t         count;
    uint32              dev_type;

    count.tx_app_pkt_count = 0;
    count.rx_app_pkt_count = 0;
    count.unexpected = 0;
    bshell(unit, "attach ; version");

    BCM_IF_ERROR_RETURN(get_device_type(unit, &dev_type));

    if (BCM_FAILURE((rv = knet_setup(unit, interface_name, port, vlan)))) {
        printf("KNET Setup Failed: %s\n", bcm_errmsg(rv));
        return rv;
    }

    if (BCM_FAILURE((rv = test_setup(unit, &count, dev_type, interface_name)))) {
        printf("test_setup() failed: %s\n", bcm_errmsg(rv));
        return rv;
    }

    rv = verify(unit, interface_name, &count);

    printf("KNET Test Status: %s\n", bcm_errmsg(rv));
    return rv;
}

/*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
 * Entry point
 */

const char         *auto_execute = (ARGC == 1) ? ARGV[0] : "YES";
if (!sal_strcmp(auto_execute, "YES")) {
    if (BCM_FAILURE(execute())) {
        printf("Test Failed\n");
    }
}
