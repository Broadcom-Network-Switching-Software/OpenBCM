/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */

#include <bcm/oob.h>
#include <bcm_int/control.h>

#include <bcm_int/ltsw/mbcm/oob.h>
#include <bcm_int/ltsw/lt_intf.h>
#include <bcm_int/ltsw/dev.h>
#include <bcm_int/ltsw/port.h>
#include <bcm_int/ltsw/cosq.h>

#include <bsl/bsl.h>
#include <sal/sal_types.h>
#include <shr/shr_debug.h>
#include <bcmltd/chip/bcmltd_str.h>
#include <bcmlt/bcmlt.h>

/******************************************************************************
 * Local definitions
 */

#define BSL_LOG_MODULE BSL_LS_BCM_OOB

/*! Number of OOB queue mapping profile. */
#define OOB_QUEUE_MAP_PROFILE_NUM 4

/*! Egress congestion states are packed into 8-bit messages in the OOBFC frame. */
#define OOB_EGR_CNG_REPORT_MODE0_WIDTH 8

/*! Egress congestion states are packed into 16-bit messages in the OOBFC frame. */
#define OOB_EGR_CNG_REPORT_MODE1_WIDTH 16

/******************************************************************************
 * Private functions
 */


/*!
 * \brief Set OOB port mapping
 *
 * Maps logical port number to OOB port number.
 *
 * \param [in] unit Logical unit number.
 * \param [in] port Logical port number.
 * \param [in] oobport OOB port number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_port_set_hw(int unit, int port, int oobport)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {OOB_PORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    field[1].u.val = oobport;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, TM_OOBFC_PORTs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve OOB port mapping
 *
 * Retrieve logical port number to OOB port number mapping.
 *
 * \param [in] unit Logical unit number.
 * \param [in] port Logical port number.
 * \param [out] oobport OOB port number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_port_get_hw(int unit, int port, int *oobport)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {OOB_PORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_OOBFC_PORTs,
                           &lt_entry,
                           NULL, NULL));
    *oobport = field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Init default OOB port mapping.
 *
 * \param [in] unit Unit Number.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_port_mapping_init(int unit)
{
    int port, oob_port = 0;
    bcm_pbmp_t pbmp;
    int warm = bcmi_warmboot_get(unit);
    SHR_FUNC_ENTER(unit);

    if (warm) {
        SHR_EXIT();
    }

    /* Retrieve all ports bitmap. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_port_bitmap(unit, BCMI_LTSW_PORT_TYPE_ALL, &pbmp));

    /* Traverse port bitmap and set oob port mapping. */
    BCM_PBMP_ITER(pbmp, port) {
        SHR_IF_ERR_VERBOSE_EXIT
            (oob_port_set_hw(unit, port, oob_port));
        oob_port++;
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set logical port to OOB port mapping.
 *
 * \param [in] unit Unit Number.
 * \param [in] count The number of device port to OOB port mappings.
 * \param [in] port_array Logical port array.
 * \param [in] oob_port_array OOB port array.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_port_mapping_set(int unit, int count, int *port_array, int *oob_port_array)
{
    int i, port, *oob_port_used= NULL, *lport_allocated = NULL;
    uint32_t lport_num = 0, oobport_num = 0;
    uint64_t min = 0;
    uint64_t max = 0;
    SHR_FUNC_ENTER(unit);

    /* Get logical port number. */
    lport_num = bcmi_ltsw_dev_logic_port_num(unit);
    lport_allocated = sal_alloc(lport_num * sizeof(int), "ooblport");
    SHR_NULL_CHECK(lport_allocated, SHR_E_MEMORY);

    /* Initialize variable. */
    for (i = 0; i < lport_num; i++) {
        lport_allocated[i] = -1;
    }

    /* Get oob port number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_field_value_range_get(unit,
                                       TM_OOBFC_PORTs,
                                       OOB_PORTs,
                                       &min,
                                       &max));
    oobport_num = (uint32_t)max + 1;
    oob_port_used = sal_alloc(oobport_num * sizeof(int), "oobport");
    SHR_NULL_CHECK(oob_port_used, SHR_E_MEMORY);
    sal_memset(oob_port_used, 0, oobport_num * sizeof(int));

    for (i = 0; i < count; i++) {
        /* Validate logical port id. */
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_ltsw_port_gport_validate(unit, port_array[i], &port));
        /* Check oob port id. */
        if (!(oob_port_array[i] >= 0 && oob_port_array[i] <= max)) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        /*
         * If more than one port mapped to the same oob port
         * or one port is mapped to different oob ports, input is invalid
         */
        if (oob_port_used[oob_port_array[i]] ||
            lport_allocated[port_array[i]] != -1) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        oob_port_used[oob_port_array[i]] = 1;
        lport_allocated[port_array[i]] = oob_port_array[i];
    }

    /* Traverse all ports. */
    for (port = 0; port < lport_num; port++) {
        /* spare port is not mapped to any oob port */
        if (bcmi_ltsw_port_is_type(unit, port, BCMI_LTSW_PORT_TYPE_SPARE)) {
            continue;
        }
        if (lport_allocated[port] != -1) {
            SHR_IF_ERR_VERBOSE_EXIT
                (oob_port_set_hw(unit, port, lport_allocated[port]));
        }
    }

exit:
    SHR_FREE(lport_allocated);
    SHR_FREE(oob_port_used);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve logical port to OOB port mapping.
 *
 * \param [in] unit Unit Number.
 * \param [in] max_count Allocated number of device port to oob port mappings.
 * \param [in] port_array Logical port array.
 * \param [out] oob_port_array Returned OOB port array.
 * \param [out] count The number of mappings returned.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_port_mapping_get(int unit, int max_count, int *port_array,
                     int *oob_port_array, int *count)
{
    int i, lport_num, num, port, rv;
    SHR_FUNC_ENTER(unit);

    *count = 0;
    /* Get logical port number. */
    lport_num = bcmi_ltsw_dev_logic_port_num(unit);
    num = (max_count > lport_num) ? lport_num : max_count;

    for (i = 0; i < num; i++) {
        /* spare port is not mapped to any oob port */
        if (bcmi_ltsw_port_is_type(unit, port_array[i],
                                   BCMI_LTSW_PORT_TYPE_SPARE)) {
            oob_port_array[i] = -1;
            continue;
        }
        /* Not accept invalid port. */
        rv = bcmi_ltsw_port_gport_validate(unit, port_array[i], &port);
        if (rv == SHR_E_PORT) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }

        rv = oob_port_get_hw(unit, port_array[i], &oob_port_array[i]);
        if (rv == SHR_E_NOT_FOUND) {
            oob_port_array[i] = -1;
            continue;
        } else if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(rv);
        }
    }
    *count = i;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Validate OOB global config parameters.
 *
 * \param [in] unit Unit Number.
 * \param [in] config OOB global configuration structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_config_validate(int unit, bcm_oob_fc_tx_config_t *config)
{
    bcmi_ltsw_cosq_device_info_t info;
    SHR_FUNC_ENTER(unit);

    /* Get device specific TM information. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &info));

    /* Validate service pool id. */
    if (config->gcs_id < 0 || config->gcs_id >= info.num_service_pool) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* egress mode - 0: 8bit, 1: 16bit. */
    if (config->egr_mode < 0 || config->egr_mode > 1) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    if (config->flags & BCM_OOB_FC_TX_FCN_EN) {
        SHR_ERR_EXIT(SHR_E_UNAVAIL);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Program OOB global configurations.
 *
 * \param [in] unit Unit Number.
 * \param [in] config OOB global configuration structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_config_set(int unit, bcm_oob_fc_tx_config_t *config)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {INGRESS_REPORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {EGRESS_REPORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {SERVICE_POOL_REPORTs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {INTER_PACKET_GAPs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*4*/ {SERVICE_POOL_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*5*/ {EGRESS_STATUS_SIZEs, BCMI_LT_FIELD_F_SET |
                                    BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    if (config->flags & BCM_OOB_FC_TX_ING_EN) {
        field[0].u.val = 1;
    }

    if (config->flags & BCM_OOB_FC_TX_EGR_EN) {
        field[1].u.val = 1;
    }

    if (config->flags & BCM_OOB_FC_TX_POOL_EN) {
        field[2].u.val = 1;
    }

    field[3].u.val = config->inter_pkt_gap;
    field[4].u.val = config->gcs_id;
    field[5].u.sym_val = config->egr_mode ? EGRESS_SIZE_16s : EGRESS_SIZE_8s;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, TM_OOBFC_CONTROLs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve OOB global configurations.
 *
 * \param [in] unit Unit Number.
 * \param [out] config OOB global configuration structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_config_get(int unit, bcm_oob_fc_tx_config_t *config)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {INGRESS_REPORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {EGRESS_REPORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {SERVICE_POOL_REPORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {INTER_PACKET_GAPs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*4*/ {SERVICE_POOL_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*5*/ {EGRESS_STATUS_SIZEs, BCMI_LT_FIELD_F_GET |
                                    BCMI_LT_FIELD_F_SYMBOL, 0, {0}},
    };
    const char *tbl_name = TM_OOBFC_CONTROLs;
    int rv;
    bcmlt_field_def_t fld_def;
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           tbl_name,
                           &lt_entry,
                           NULL, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[0].fld_name,
                                   &fld_def));
        if (fld_def.def) {
            config->flags |= BCM_OOB_FC_TX_ING_EN;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[1].fld_name,
                                   &fld_def));
        if (fld_def.def) {
            config->flags |= BCM_OOB_FC_TX_EGR_EN;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[2].fld_name,
                                   &fld_def));
        if (fld_def.def) {
            config->flags |= BCM_OOB_FC_TX_POOL_EN;
        }

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[3].fld_name,
                                   &fld_def));
        config->inter_pkt_gap = fld_def.def;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[4].fld_name,
                                   &fld_def));
        config->gcs_id = fld_def.def;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[5].fld_name,
                                   &fld_def));
        if (!sal_strcmp(fld_def.sym_def, EGRESS_SIZE_16s)) {
            config->egr_mode = 1;
        } else if (!sal_strcmp(fld_def.sym_def, EGRESS_SIZE_8s)) {
            config->egr_mode = 0;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    } else if (SHR_SUCCESS(rv)) {
        if (field[0].u.val) {
            config->flags |= BCM_OOB_FC_TX_ING_EN;
        }

        if (field[1].u.val) {
            config->flags |= BCM_OOB_FC_TX_EGR_EN;
        }

        if (field[2].u.val) {
            config->flags |= BCM_OOB_FC_TX_POOL_EN;
        }

        config->inter_pkt_gap = field[3].u.val;
        config->gcs_id = field[4].u.val;
        if (!sal_strcmp(field[5].u.sym_val, EGRESS_SIZE_16s)) {
            config->egr_mode = 1;
        } else if (!sal_strcmp(field[5].u.sym_val, EGRESS_SIZE_8s)) {
            config->egr_mode = 0;
        } else {
            SHR_IF_ERR_VERBOSE_EXIT(SHR_E_PARAM);
        }
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve the OOBFC Tx global information.
 *
 * \param [in] unit Unit Number.
 * \param [out] info Pointer to OOBFC Tx global information structure.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_info_get(int unit, bcm_oob_fc_tx_info_t *info)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {INGRESS_CHANNEL_BASEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*1*/ {EGRESS_CHANNEL_BASEs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {POOL_CHANNEL_BASEs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    const char *tbl_name = TM_OOBFC_CONTROLs;
    int rv;
    bcmlt_field_def_t fld_def;
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    rv = bcmi_lt_entry_get(unit,
                           tbl_name,
                           &lt_entry,
                           NULL, NULL);
    if (rv == SHR_E_NOT_FOUND) {
        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[0].fld_name,
                                   &fld_def));
        info->ing_base = fld_def.def;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[1].fld_name,
                                   &fld_def));
        info->cos_base = fld_def.def;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_field_def_get(unit, tbl_name,
                                   field[2].fld_name,
                                   &fld_def));
        info->pool_base = fld_def.def;
        info->ucast_base = 0;
        info->mcast_base = 0;
    } else if (SHR_SUCCESS(rv)) {
        info->ing_base = field[0].u.val;
        info->cos_base = field[1].u.val;
        info->pool_base = field[2].u.val;
        info->ucast_base = 0;
        info->mcast_base = 0;
    } else {
        SHR_IF_ERR_VERBOSE_EXIT(rv);
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set OOB Queue profile table.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id OOB Queue configuration profile id.
 * \param [in] count The number of Queue configurations in the config array.
 * \param [in] config Queue configuration array.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_queue_profile_table_set(int unit, int profile_id, int count,
                            bcm_oob_fc_tx_queue_config_t *config)
{
    int i, num_uc_queue, num_mc_queue;
    const char *table;
    int offset_ref[OOB_EGR_CNG_REPORT_MODE1_WIDTH] = {0};
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_OOBFC_Q_MAP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {CONGESTION_NOTIFYs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*3*/ {OOB_BIT_OFFSETs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    /* Get UC/MC queue number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_uc_queue, &num_mc_queue));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < count; i++) {
        if (config[i].queue_enable) {
            offset_ref[config[i].queue_offset]++;
            if (offset_ref[config[i].queue_offset] > 2) {
                /* At most two queues can be mapped to the same bit offset. */
                SHR_ERR_EXIT(SHR_E_PARAM);
            }
        }
        table = config[i].cosq >= num_uc_queue ? TM_OOBFC_MC_Q_MAP_PROFILEs:
                                                 TM_OOBFC_UC_Q_MAP_PROFILEs;

        if (config[i].cosq >= num_uc_queue) {
            field[0].fld_name = TM_MC_Q_IDs;
            field[0].u.val = config[i].cosq- num_uc_queue;
        } else {
            field[0].fld_name = TM_UC_Q_IDs;
            field[0].u.val = config[i].cosq;
        }
        field[1].u.val = profile_id;
        field[2].u.val = config[i].queue_enable;
        field[3].u.val = config[i].queue_offset;

        SHR_IF_ERR_VERBOSE_EXIT
            (bcmi_lt_entry_set(unit, table, &lt_entry, NULL));
    }

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Retrieve OOB Queue configuration profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id OOB Queue configuration profile id.
 * \param [in] max_count Allocated number of Queue configurations.
 * \param [out] config Queue configuration array.
 * \param [out] count The number of Queue configurations returned.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_queue_profile_get(int unit, int profile_id, int max_count,
                      bcm_oob_fc_tx_queue_config_t *config, int *count)
{
    int i, num_queue, num_uc_queue, num_mc_queue;
    int rv = SHR_E_NONE, count_tmp = 0;
    bcmi_ltsw_cosq_device_info_t info;
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {NULL, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_OOBFC_Q_MAP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*2*/ {CONGESTION_NOTIFYs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {OOB_BIT_OFFSETs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    const char *table;
    SHR_FUNC_ENTER(unit);

    if (profile_id < 0 || profile_id >= OOB_QUEUE_MAP_PROFILE_NUM) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Retrieve device specific TM information. */
    sal_memset(&info, 0x0, sizeof(bcmi_ltsw_cosq_device_info_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &info));
    num_queue = info.num_queue;

    /* Get UC/MC queue number. */
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_num_queue_get(unit, &num_uc_queue, &num_mc_queue));

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    for (i = 0; i < max_count && i < num_queue; i++) {
        if (i >= num_uc_queue) {
            table = TM_OOBFC_MC_Q_MAP_PROFILEs;
            field[0].fld_name = TM_MC_Q_IDs;
            field[0].u.val= i - num_uc_queue;
        } else {
            table = TM_OOBFC_UC_Q_MAP_PROFILEs;
            field[0].fld_name = TM_UC_Q_IDs;
            field[0].u.val= i;
        }
        field[1].u.val = profile_id;

        rv = bcmi_lt_entry_get(unit,
                               table,
                               &lt_entry,
                               NULL, NULL);
        if (rv == SHR_E_NOT_FOUND) {
            continue;
        } else if (SHR_FAILURE(rv)) {
            SHR_ERR_EXIT(rv);
        }
        config[i].cosq = i;
        config[i].queue_enable = field[2].u.val;
        config[i].queue_offset = field[3].u.val;
        count_tmp++;
    }
    *count = count_tmp;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set OOB Queue configuration profile.
 *
 * \param [in] unit Unit Number.
 * \param [in] profile_id OOB Queue configuration profile id.
 * \param [in] count The number of Queue configurations in the config array.
 * \param [in] config Queue configuration array.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_queue_profile_set(int unit, int profile_id, int count,
                      bcm_oob_fc_tx_queue_config_t *config)
{
    int num_bit, num_queue, ref_count = 0, alloc_sz = 0, i, rv;
    bcm_oob_fc_tx_config_t oob_config;
    bcmi_ltsw_cosq_device_info_t info;
    bcm_oob_fc_tx_queue_config_t *entire_profile = NULL;
    SHR_FUNC_ENTER(unit);

    /* Retrieve device specific TM information. */
    sal_memset(&info, 0x0, sizeof(bcmi_ltsw_cosq_device_info_t));
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_ltsw_cosq_device_info_get(unit, &info));
    num_queue = info.num_queue;

    /* Parameters check. */
    if (count <= 0 || count > info.num_queue ||
        profile_id < 0 || profile_id >= OOB_QUEUE_MAP_PROFILE_NUM) {
        SHR_ERR_EXIT(SHR_E_PARAM);
    }

    /* Retrieve OOB global config. */
    sal_memset(&oob_config, 0x0, sizeof(bcm_oob_fc_tx_config_t));
    num_bit = OOB_EGR_CNG_REPORT_MODE0_WIDTH;
    rv = oob_config_get(unit, &oob_config);
    /* If get returns not found, go on to set. */
    if (SHR_FAILURE(rv) && rv != SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(rv);
    }

    num_bit = oob_config.egr_mode ? num_queue : OOB_EGR_CNG_REPORT_MODE0_WIDTH;

    /* Get old profile. */
    alloc_sz = num_queue * sizeof(bcm_oob_fc_tx_queue_config_t);
    entire_profile = sal_alloc(alloc_sz, "oobprofile");
    SHR_NULL_CHECK(entire_profile, SHR_E_MEMORY);
    sal_memset(entire_profile, 0x0, alloc_sz);
    rv = oob_queue_profile_get(unit,
                               profile_id,
                               num_queue,
                               entire_profile,
                               &ref_count);
    /* If get returns not found, go on to set. */
    if (SHR_FAILURE(rv) && rv != SHR_E_NOT_FOUND) {
        SHR_ERR_EXIT(rv);
    }

    /* Overwrite existing profile with new entry. */
    for (i = 0; i < count; i++) {
        if (config[i].queue_offset >= num_bit) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if (config[i].queue_enable != 0 && config[i].queue_enable != 1) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        if (config[i].cosq < 0 || config[i].cosq >= num_queue) {
            SHR_ERR_EXIT(SHR_E_PARAM);
        }
        sal_memcpy(&entire_profile[config[i].cosq], &config[i],
                   sizeof(bcm_oob_fc_tx_queue_config_t));
    }

    /* Write profile to HW. */
    SHR_IF_ERR_VERBOSE_EXIT
        (oob_queue_profile_table_set(unit,
                                     profile_id,
                                     num_queue,
                                     entire_profile));
exit:
    SHR_FREE(entire_profile);
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set OOB queue profile id for a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 * \param [in] profile_id OOB queue profile id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_egr_profile_id_set(int unit, bcm_port_t port, int profile_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_OOBFC_Q_MAP_PROFILE_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    field[1].u.val = profile_id;

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, TM_OOBFC_PORTs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get OOB queue profile id on a port.
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 * \param [out] profile_id OOB queue profile id.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_egr_profile_id_get(int unit, bcm_port_t port, int *profile_id)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {TM_OOBFC_Q_MAP_PROFILE_IDs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_OOBFC_PORTs,
                           &lt_entry,
                           NULL, NULL));
    *profile_id = field[1].u.val;

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Set OOB port configuration(enable/disable OOB notification on a port).
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 * \param [in] egress 0 = Ingreess, 1 = Egress.
 * \param [in] enable Enable/Disable congestion State reporting.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_port_control_set(int unit, bcm_port_t port, int egress, int enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {INGRESSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {EGRESSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*3*/ {CNG_REPORTs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    int rv;
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    rv = bcmi_lt_entry_get(unit,
                           TM_OOBFC_PORTs,
                           &lt_entry,
                           NULL, NULL);
    if (rv != SHR_E_NOT_FOUND && SHR_FAILURE(rv)) {
        SHR_ERR_EXIT(rv);
    }

    if (egress) {
        field[2].u.val = enable;
        field[2].flags = BCMI_LT_FIELD_F_SET;
    } else {
        field[1].u.val = enable;
        field[1].flags = BCMI_LT_FIELD_F_SET;
    }

    /*
     * Turn off congestion reporting from MMU to OOB
     * only when ingress and egress reporting are both turned off.
     */
    if (field[1].u.val == 0 && field[2].u.val == 0) {
        field[3].u.val = 0;
        field[3].flags = BCMI_LT_FIELD_F_SET;
    } else {
        field[3].u.val = 1;
        field[3].flags = BCMI_LT_FIELD_F_SET;
    }

    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_set(unit, TM_OOBFC_PORTs, &lt_entry, NULL));

exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Get OOB port configuration(OOB notification status on a port).
 *
 * \param [in] unit Unit Number.
 * \param [in] port Port id.
 * \param [in] egress 0 = Ingreess, 1 = Egress.
 * \param [out] enable Enable/Disable congestion State reporting.
 *
 * \retval SHR_E_NONE on success and error code otherwise.
 */
static int
oob_port_control_get(int unit, bcm_port_t port, int egress, int *enable)
{
    bcmi_lt_entry_t lt_entry;
    bcmi_lt_field_t field[] =
    {
        /*0*/ {PORT_IDs, BCMI_LT_FIELD_F_SET, 0, {0}},
        /*1*/ {INGRESSs, BCMI_LT_FIELD_F_GET, 0, {0}},
        /*2*/ {EGRESSs, BCMI_LT_FIELD_F_GET, 0, {0}},
    };
    SHR_FUNC_ENTER(unit);

    lt_entry.fields = field;
    lt_entry.nfields = sizeof(field)/sizeof(field[0]);
    lt_entry.attr = 0;

    field[0].u.val = port;
    SHR_IF_ERR_VERBOSE_EXIT
        (bcmi_lt_entry_get(unit,
                           TM_OOBFC_PORTs,
                           &lt_entry,
                           NULL, NULL));
    if (egress) {
        *enable = field[2].u.val;
    } else {
        *enable = field[1].u.val;
    }

exit:
    SHR_FUNC_EXIT();
}


static int
bcm56780_a0_ltsw_oob_init(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (oob_port_mapping_init(unit));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_detach(int unit)
{
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_oob_tx_queue_profile_set(
    int unit,
    int profile_id,
    int count,
    bcm_oob_fc_tx_queue_config_t *config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (oob_queue_profile_set(unit, profile_id, count, config));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_tx_queue_profile_get(
    int unit,
    int profile_id,
    int max_count,
    bcm_oob_fc_tx_queue_config_t *config,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (oob_queue_profile_get(unit, profile_id, max_count, config, count));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_tx_port_mapping_set(
    int unit,
    int count,
    int *port_array,
    int *oob_port_array)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (oob_port_mapping_set(unit, count, port_array, oob_port_array));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_tx_port_mapping_get(
    int unit,
    int max_count,
    int *port_array,
    int *oob_port_array,
    int *count)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (oob_port_mapping_get(unit,
                              max_count,
                              port_array,
                              oob_port_array,
                              count));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_tx_config_set(
    int unit,
    bcm_oob_fc_tx_config_t *config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
         (oob_config_validate(unit, config));

    SHR_IF_ERR_VERBOSE_EXIT
         (oob_config_set(unit, config));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_tx_config_get(
    int unit,
    bcm_oob_fc_tx_config_t *config)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
         (oob_config_get(unit, config));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_tx_info_get(
    int unit,
    bcm_oob_fc_tx_info_t *info)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (oob_info_get(unit, info));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_egr_profile_id_set(
    int unit,
    bcm_port_t port,
    int profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
         (oob_egr_profile_id_set(unit, port, profile_id));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_egr_profile_id_get(
    int unit,
    bcm_port_t port,
    int *profile_id)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
         (oob_egr_profile_id_get(unit, port, profile_id));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_egr_profile_num_get(
    int unit,
    int *num)
{
    if (num) {
        *num = OOB_QUEUE_MAP_PROFILE_NUM;
    }
    return SHR_E_NONE;
}

static int
bcm56780_a0_ltsw_oob_port_control_set(
    int unit,
    bcm_port_t port,
    int egress,
    int enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
         (oob_port_control_set(unit, port, egress, enable));
exit:
    SHR_FUNC_EXIT();
}

static int
bcm56780_a0_ltsw_oob_port_control_get(
    int unit,
    bcm_port_t port,
    int egress,
    int *enable)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
         (oob_port_control_get(unit, port, egress, enable));
exit:
    SHR_FUNC_EXIT();
}

/*!
 * \brief Oob driver function variable for bcm56780_a0 device.
 */
static mbcm_ltsw_oob_drv_t bcm56780_a0_ltsw_oob_drv = {
    .oob_init = bcm56780_a0_ltsw_oob_init,
    .oob_detach = bcm56780_a0_ltsw_oob_detach,
    .oob_tx_queue_profile_set = bcm56780_a0_ltsw_oob_tx_queue_profile_set,
    .oob_tx_queue_profile_get = bcm56780_a0_ltsw_oob_tx_queue_profile_get,
    .oob_tx_port_mapping_set = bcm56780_a0_ltsw_oob_tx_port_mapping_set,
    .oob_tx_port_mapping_get = bcm56780_a0_ltsw_oob_tx_port_mapping_get,
    .oob_tx_config_set = bcm56780_a0_ltsw_oob_tx_config_set,
    .oob_tx_config_get = bcm56780_a0_ltsw_oob_tx_config_get,
    .oob_tx_info_get = bcm56780_a0_ltsw_oob_tx_info_get,
    .oob_egr_profile_id_set = bcm56780_a0_ltsw_oob_egr_profile_id_set,
    .oob_egr_profile_id_get = bcm56780_a0_ltsw_oob_egr_profile_id_get,
    .oob_egr_profile_num_get = bcm56780_a0_ltsw_oob_egr_profile_num_get,
    .oob_port_control_set = bcm56780_a0_ltsw_oob_port_control_set,
    .oob_port_control_get = bcm56780_a0_ltsw_oob_port_control_get
};

/******************************************************************************
 * Public functions
 */

int
bcm56780_a0_ltsw_oob_drv_attach(int unit)
{
    SHR_FUNC_ENTER(unit);

    SHR_IF_ERR_VERBOSE_EXIT
        (mbcm_ltsw_oob_drv_set(unit, &bcm56780_a0_ltsw_oob_drv));

exit:
    SHR_FUNC_EXIT();
}

