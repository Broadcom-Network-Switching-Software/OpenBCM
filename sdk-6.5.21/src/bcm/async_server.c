/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * Asynchronous BCM API Server
 *
 * Most of the support routines and header definitions for async api
 * routines are generated by mkdispatch:
 *
 * User access:
 * include/bcm/async.h		user declarations of bcm_*_async routines
 * src/bcm/async.c		bcm_*_async routines
 *
 * Internal async server support:
 * include/bcm_int/async_req.h	bcm async request definition
 * src/bcm/async_run.c		execution of bcm async request
 *
 * bcm async requests share a common header format that is used
 * by the routines in this file.
 *
 * This file provides the actual async execution server thread and
 * the queueing routines.
 */

#ifdef	BCM_ASYNC_SUPPORT

#include <sal/core/sync.h>
#include <sal/core/thread.h>
#include <shared/alloc.h>
#include <sal/appl/sal.h>	/* sal_dma_alloc, sal_dma_free */

#include <bcm/types.h>
#include <bcm_int/async_server.h>

#define	ASYNC_THREAD_STACK	SAL_THREAD_STKSZ
#define	ASYNC_THREAD_PRIO	255

#define	ASYNC_LOCK		sal_mutex_take(_async_lock, sal_mutex_FOREVER)
#define	ASYNC_UNLOCK		sal_mutex_give(_async_lock)
#define	ASYNC_SLEEP		sal_sem_take(_async_sem, sal_sem_FOREVER)
#define	ASYNC_WAKE		sal_sem_give(_async_sem)

static	sal_mutex_t	_async_lock;		/* lock access to _async_req */
static	sal_sem_t	_async_sem;		/* wait for async_adds */
static	sal_thread_t	_async_thread = SAL_THREAD_ERROR;
static	int		_async_thread_exit;

static	bcm_async_req_t	*_async_req_head;
static	bcm_async_req_t	*_async_req_tail;

/*
 * Add an async request to the end of the queue
 */
void
bcm_async_add(bcm_async_req_t *req)
{
    if (req == NULL) {
	return;
    }
    if (_async_thread == SAL_THREAD_ERROR) {
	if (req->callback != NULL) {
	    (*req->callback)(req->cookie, BCM_E_UNAVAIL);
	}
	sal_free(req);
	return;
    }
    ASYNC_LOCK;
    if (_async_req_head == NULL) {		/* empty */
	_async_req_head = _async_req_tail = req;
    } else {
	_async_req_tail->next = req;
	_async_req_tail = req;
    }
    ASYNC_UNLOCK;
    ASYNC_WAKE;
}

/*
 * Async Server thread.
 * Pull an entry off the front of the queue and run it.
 */
STATIC void
_bcm_async_thread(void *cookie)
{
    bcm_async_req_t	*req, *nreq;

    COMPILER_REFERENCE(cookie);

    _async_thread_exit = 0;
    for (;;) {
	ASYNC_SLEEP;

	/* grab a set of requests off the queue */
	ASYNC_LOCK;
	req = _async_req_head;
	_async_req_head = _async_req_tail = NULL;
	ASYNC_UNLOCK;

	/* run the requests */
	while (req != NULL) {
	    nreq = req->next;
	    (*req->run)(req);		/* bcm_async_run */
	    req = nreq;
	}
	if (_async_thread_exit) {
	    _async_thread = SAL_THREAD_ERROR;
	    sal_thread_exit(0);
	    return;
	}
    }
}

/*
 * Start the Async thread
 */
int
bcm_async_start(void)
{
    if (_async_thread != SAL_THREAD_ERROR) {
	return BCM_E_BUSY;
    }
    _async_lock = sal_mutex_create("bcm_async");
    _async_sem = sal_sem_create("bcm_async", sal_sem_BINARY, 0);
    _async_thread = sal_thread_create("bcmASYNC",
				      ASYNC_THREAD_STACK,
				      ASYNC_THREAD_PRIO,
				      _bcm_async_thread,
				      NULL);
    if (_async_thread == SAL_THREAD_ERROR) {
	sal_sem_destroy(_async_sem);
	sal_mutex_destroy(_async_lock);
	_async_lock = NULL;
	return BCM_E_RESOURCE;
    }
    return BCM_E_NONE;
}

/*
 * Stop the Async thread
 */
int
bcm_async_stop(void)
{
    if (_async_thread == SAL_THREAD_ERROR) {
	return BCM_E_NONE;
    }
    _async_thread_exit = 1;
    ASYNC_WAKE;
    sal_thread_yield();
    while (_async_thread != SAL_THREAD_ERROR) {
	ASYNC_WAKE;
	sal_usleep(10000);
    }
    sal_sem_destroy(_async_sem);
    sal_mutex_destroy(_async_lock);
    _async_lock = NULL;
    return BCM_E_NONE;
}

#endif	/* BCM_ASYNC_SUPPORT */

typedef int _bcm_async_server_not_empty; /* Make ISO compilers happy. */
