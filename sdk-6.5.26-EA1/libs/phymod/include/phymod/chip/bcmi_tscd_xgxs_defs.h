#ifndef __BCMI_TSCD_XGXS_DEFS_H__
#define __BCMI_TSCD_XGXS_DEFS_H__
/*******************************************************************************
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2022 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_TSCD_XGXS.
 * This file provides all basic definitions required to program the BCMI_TSCD_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 *
 ******************************************************************************/

#ifndef _DV_TB_
#include <phymod/acc/phymod_tsc_iblk.h>
#endif /* _DV_TB_ */

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PHYID2
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0002
 * DESC:     IEEE phyID2 Register
 * RESETVAL: 0x600d (24589)
 * ACCESS:   R/O
 * FIELDS:
 *     REGID1           PHYID2 register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PHYID2r (0x00000002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PHYID2r_SIZE 4

/*
 * This structure should be used to declare and program PHYID2.
 *
 */
typedef union BCMI_TSCD_XGXS_PHYID2r_s {
	uint32_t v[1];
	uint32_t phyid2[1];
	uint32_t _phyid2;
} BCMI_TSCD_XGXS_PHYID2r_t;

#define BCMI_TSCD_XGXS_PHYID2r_CLR(r) (r).phyid2[0] = 0
#define BCMI_TSCD_XGXS_PHYID2r_SET(r,d) (r).phyid2[0] = d
#define BCMI_TSCD_XGXS_PHYID2r_GET(r) (r).phyid2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PHYID2r_REGID1f_GET(r) (((r).phyid2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PHYID2r_REGID1f_SET(r,f) (r).phyid2[0]=(((r).phyid2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PHYID2.
 *
 */
#define BCMI_TSCD_XGXS_READ_PHYID2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_TSCD_XGXS_WRITE_PHYID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID2r,(_r._phyid2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PHYID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID2r,(_r._phyid2))
#define BCMI_TSCD_XGXS_READLN_PHYID2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_TSCD_XGXS_WRITELN_PHYID2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid2))
#define BCMI_TSCD_XGXS_WRITEALL_PHYID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHYID2r BCMI_TSCD_XGXS_PHYID2r
#define PHYID2r_SIZE BCMI_TSCD_XGXS_PHYID2r_SIZE
typedef BCMI_TSCD_XGXS_PHYID2r_t PHYID2r_t;
#define PHYID2r_CLR BCMI_TSCD_XGXS_PHYID2r_CLR
#define PHYID2r_SET BCMI_TSCD_XGXS_PHYID2r_SET
#define PHYID2r_GET BCMI_TSCD_XGXS_PHYID2r_GET
#define PHYID2r_REGID1f_GET BCMI_TSCD_XGXS_PHYID2r_REGID1f_GET
#define PHYID2r_REGID1f_SET BCMI_TSCD_XGXS_PHYID2r_REGID1f_SET
#define READ_PHYID2r BCMI_TSCD_XGXS_READ_PHYID2r
#define WRITE_PHYID2r BCMI_TSCD_XGXS_WRITE_PHYID2r
#define MODIFY_PHYID2r BCMI_TSCD_XGXS_MODIFY_PHYID2r
#define READLN_PHYID2r BCMI_TSCD_XGXS_READLN_PHYID2r
#define WRITELN_PHYID2r BCMI_TSCD_XGXS_WRITELN_PHYID2r
#define WRITEALL_PHYID2r BCMI_TSCD_XGXS_WRITEALL_PHYID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PHYID2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PHYID3
 * BLOCKS:   CL22_B0
 * REGADDR:  0x0003
 * DESC:     IEEE phyID3 Register
 * RESETVAL: 0x8770 (34672)
 * ACCESS:   R/O
 * FIELDS:
 *     REGID2           PHYID3 register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PHYID3r (0x00000003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PHYID3r_SIZE 4

/*
 * This structure should be used to declare and program PHYID3.
 *
 */
typedef union BCMI_TSCD_XGXS_PHYID3r_s {
	uint32_t v[1];
	uint32_t phyid3[1];
	uint32_t _phyid3;
} BCMI_TSCD_XGXS_PHYID3r_t;

#define BCMI_TSCD_XGXS_PHYID3r_CLR(r) (r).phyid3[0] = 0
#define BCMI_TSCD_XGXS_PHYID3r_SET(r,d) (r).phyid3[0] = d
#define BCMI_TSCD_XGXS_PHYID3r_GET(r) (r).phyid3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PHYID3r_REGID2f_GET(r) (((r).phyid3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PHYID3r_REGID2f_SET(r,f) (r).phyid3[0]=(((r).phyid3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PHYID3.
 *
 */
#define BCMI_TSCD_XGXS_READ_PHYID3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_TSCD_XGXS_WRITE_PHYID3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID3r,(_r._phyid3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PHYID3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID3r,(_r._phyid3))
#define BCMI_TSCD_XGXS_READLN_PHYID3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_TSCD_XGXS_WRITELN_PHYID3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._phyid3))
#define BCMI_TSCD_XGXS_WRITEALL_PHYID3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PHYID3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._phyid3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PHYID3r BCMI_TSCD_XGXS_PHYID3r
#define PHYID3r_SIZE BCMI_TSCD_XGXS_PHYID3r_SIZE
typedef BCMI_TSCD_XGXS_PHYID3r_t PHYID3r_t;
#define PHYID3r_CLR BCMI_TSCD_XGXS_PHYID3r_CLR
#define PHYID3r_SET BCMI_TSCD_XGXS_PHYID3r_SET
#define PHYID3r_GET BCMI_TSCD_XGXS_PHYID3r_GET
#define PHYID3r_REGID2f_GET BCMI_TSCD_XGXS_PHYID3r_REGID2f_GET
#define PHYID3r_REGID2f_SET BCMI_TSCD_XGXS_PHYID3r_REGID2f_SET
#define READ_PHYID3r BCMI_TSCD_XGXS_READ_PHYID3r
#define WRITE_PHYID3r BCMI_TSCD_XGXS_WRITE_PHYID3r
#define MODIFY_PHYID3r BCMI_TSCD_XGXS_MODIFY_PHYID3r
#define READLN_PHYID3r BCMI_TSCD_XGXS_READLN_PHYID3r
#define WRITELN_PHYID3r BCMI_TSCD_XGXS_WRITELN_PHYID3r
#define WRITEALL_PHYID3r BCMI_TSCD_XGXS_WRITEALL_PHYID3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PHYID3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_SETUP
 * BLOCKS:   MAIN0
 * REGADDR:  0x9000
 * DESC:     main control register
 * RESETVAL: 0x180 (384)
 * ACCESS:   R/W
 * FIELDS:
 *     TSC_CLK_CTRL     1'b0 - tsc_clk frequency : PLL/401'b1 - tsc_clk frequency : PLL/48
 *     CL73_VCO         1'b0 - VCO frequency : 20.625G1'b1 - VCO frequency : 25.78125
 *     STAND_ALONE_MODE This mode is used for testing without a MAC.The credits from the TSC and loopbed back into the TSC as DVs.The same is true for the PORT and TDM fields
 *     SINGLE_PORT_MODE Indicates TSC is in single port mode.  Used by AN logic to determine whether to reset the PLL after AN completes.If set, when AN completes, the PLL will be reset to operate consistent with the resolved AN speed.If not set, the PLL will not change once AN completes.
 *     PORT_MODE_SEL    port configuration selectsTRI_1_PORT - lanes 2,3 aggregated and 0,1 as 3 portsTRI_2_PORT - lanes 1,0 aggregated and 3,2 as 3 ports
 *     REFCLK_SEL       Specifies refclk frequency
 *     CL72_EN          Per LOGICAL LANE control to enable cl72
 *     MASTER_PORT_NUM  Port that will control PMD core logic and PLL reset0 : port 0 is master1 : port 1 is master2 : port 2 is master3 : port 3 is master
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_SETUPr (0x00109000 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_SETUPr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SETUP.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_SETUPr_s {
	uint32_t v[1];
	uint32_t main0_setup[1];
	uint32_t _main0_setup;
} BCMI_TSCD_XGXS_MAIN0_SETUPr_t;

#define BCMI_TSCD_XGXS_MAIN0_SETUPr_CLR(r) (r).main0_setup[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_SET(r,d) (r).main0_setup[0] = d
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_GET(r) (r).main0_setup[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_GET(r) ((((r).main0_setup[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_CL72_ENf_GET(r) ((((r).main0_setup[0]) >> 10) & 0xf)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_CL72_ENf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0xf << 10)) | ((((uint32_t)f) & 0xf) << 10)) | (15 << (16 + 10))
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_REFCLK_SELf_GET(r) ((((r).main0_setup[0]) >> 7) & 0x7)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_REFCLK_SELf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_GET(r) ((((r).main0_setup[0]) >> 4) & 0x7)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_GET(r) ((((r).main0_setup[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_GET(r) ((((r).main0_setup[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_CL73_VCOf_GET(r) ((((r).main0_setup[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_CL73_VCOf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_TSC_CLK_CTRLf_GET(r) (((r).main0_setup[0]) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_SETUPr_TSC_CLK_CTRLf_SET(r,f) (r).main0_setup[0]=(((r).main0_setup[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_SETUP.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_SETUPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_SETUPr,(_r._main0_setup))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_SETUPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SETUPr,(_r._main0_setup)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_SETUPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SETUPr,(_r._main0_setup))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SETUPr BCMI_TSCD_XGXS_MAIN0_SETUPr
#define MAIN0_SETUPr_SIZE BCMI_TSCD_XGXS_MAIN0_SETUPr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_SETUPr_t MAIN0_SETUPr_t;
#define MAIN0_SETUPr_CLR BCMI_TSCD_XGXS_MAIN0_SETUPr_CLR
#define MAIN0_SETUPr_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_SET
#define MAIN0_SETUPr_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_GET
#define MAIN0_SETUPr_MASTER_PORT_NUMf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_GET
#define MAIN0_SETUPr_MASTER_PORT_NUMf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_MASTER_PORT_NUMf_SET
#define MAIN0_SETUPr_CL72_ENf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_CL72_ENf_GET
#define MAIN0_SETUPr_CL72_ENf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_CL72_ENf_SET
#define MAIN0_SETUPr_REFCLK_SELf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_REFCLK_SELf_GET
#define MAIN0_SETUPr_REFCLK_SELf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_REFCLK_SELf_SET
#define MAIN0_SETUPr_PORT_MODE_SELf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_GET
#define MAIN0_SETUPr_PORT_MODE_SELf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_PORT_MODE_SELf_SET
#define MAIN0_SETUPr_SINGLE_PORT_MODEf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_GET
#define MAIN0_SETUPr_SINGLE_PORT_MODEf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_SINGLE_PORT_MODEf_SET
#define MAIN0_SETUPr_STAND_ALONE_MODEf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_GET
#define MAIN0_SETUPr_STAND_ALONE_MODEf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_STAND_ALONE_MODEf_SET
#define MAIN0_SETUPr_CL73_VCOf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_CL73_VCOf_GET
#define MAIN0_SETUPr_CL73_VCOf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_CL73_VCOf_SET
#define MAIN0_SETUPr_TSC_CLK_CTRLf_GET BCMI_TSCD_XGXS_MAIN0_SETUPr_TSC_CLK_CTRLf_GET
#define MAIN0_SETUPr_TSC_CLK_CTRLf_SET BCMI_TSCD_XGXS_MAIN0_SETUPr_TSC_CLK_CTRLf_SET
#define READ_MAIN0_SETUPr BCMI_TSCD_XGXS_READ_MAIN0_SETUPr
#define WRITE_MAIN0_SETUPr BCMI_TSCD_XGXS_WRITE_MAIN0_SETUPr
#define MODIFY_MAIN0_SETUPr BCMI_TSCD_XGXS_MODIFY_MAIN0_SETUPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_SETUPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_SYNCE_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x9001
 * DESC:     SyncE mode register
 * RESETVAL: 0xaa (170)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_MODE_PHY_LANE0 this is for syncE stage1 mode control
 *     SYNCE_MODE_PHY_LANE1 this is for syncE stage1 mode control
 *     SYNCE_MODE_PHY_LANE2 this is for syncE stage1 mode control
 *     SYNCE_MODE_PHY_LANE3 this is for syncE stage1 mode control
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr (0x00109001 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SYNCE_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_s {
	uint32_t v[1];
	uint32_t main0_synce_ctl[1];
	uint32_t _main0_synce_ctl;
} BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_t;

#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_CLR(r) (r).main0_synce_ctl[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SET(r,d) (r).main0_synce_ctl[0] = d
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_GET(r) (r).main0_synce_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE3f_GET(r) ((((r).main0_synce_ctl[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE3f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE2f_GET(r) ((((r).main0_synce_ctl[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE2f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE1f_GET(r) ((((r).main0_synce_ctl[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE1f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE0f_GET(r) (((r).main0_synce_ctl[0]) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE0f_SET(r,f) (r).main0_synce_ctl[0]=(((r).main0_synce_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_SYNCE_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr,(_r._main0_synce_ctl))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr,(_r._main0_synce_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_SYNCE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr,(_r._main0_synce_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SYNCE_CTLr BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr
#define MAIN0_SYNCE_CTLr_SIZE BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_t MAIN0_SYNCE_CTLr_t;
#define MAIN0_SYNCE_CTLr_CLR BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_CLR
#define MAIN0_SYNCE_CTLr_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SET
#define MAIN0_SYNCE_CTLr_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE3f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE3f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE3f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE3f_SET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE2f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE2f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE2f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE2f_SET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE1f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE1f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE1f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE1f_SET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE0f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE0f_GET
#define MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE0f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr_SYNCE_MODE_PHY_LANE0f_SET
#define READ_MAIN0_SYNCE_CTLr BCMI_TSCD_XGXS_READ_MAIN0_SYNCE_CTLr
#define WRITE_MAIN0_SYNCE_CTLr BCMI_TSCD_XGXS_WRITE_MAIN0_SYNCE_CTLr
#define MODIFY_MAIN0_SYNCE_CTLr BCMI_TSCD_XGXS_MODIFY_MAIN0_SYNCE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_SYNCE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_SYNCE_CTL_STAGE0
 * BLOCKS:   MAIN0
 * REGADDR:  0x9002
 * DESC:     SyncE mode register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_STAGE0_MODE_PHY_LANE0 this is for syncE stage0 mode control
 *     SYNCE_STAGE0_MODE_PHY_LANE1 this is for syncE stage0 mode control
 *     SYNCE_STAGE0_MODE_PHY_LANE2 this is for syncE stage0 mode control
 *     SYNCE_STAGE0_MODE_PHY_LANE3 this is for syncE stage0 mode control
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r (0x00109002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SYNCE_CTL_STAGE0.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_s {
	uint32_t v[1];
	uint32_t main0_synce_ctl_stage0[1];
	uint32_t _main0_synce_ctl_stage0;
} BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_t;

#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_CLR(r) (r).main0_synce_ctl_stage0[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SET(r,d) (r).main0_synce_ctl_stage0[0] = d
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_GET(r) (r).main0_synce_ctl_stage0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE3f_GET(r) ((((r).main0_synce_ctl_stage0[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE3f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE2f_GET(r) ((((r).main0_synce_ctl_stage0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE2f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE1f_GET(r) ((((r).main0_synce_ctl_stage0[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE1f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE0f_GET(r) (((r).main0_synce_ctl_stage0[0]) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE0f_SET(r,f) (r).main0_synce_ctl_stage0[0]=(((r).main0_synce_ctl_stage0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access MAIN0_SYNCE_CTL_STAGE0.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_SYNCE_CTL_STAGE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r,(_r._main0_synce_ctl_stage0))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_SYNCE_CTL_STAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r,(_r._main0_synce_ctl_stage0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_SYNCE_CTL_STAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r,(_r._main0_synce_ctl_stage0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r
#define MAIN0_SYNCE_CTL_STAGE0r_SIZE BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_t MAIN0_SYNCE_CTL_STAGE0r_t;
#define MAIN0_SYNCE_CTL_STAGE0r_CLR BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_CLR
#define MAIN0_SYNCE_CTL_STAGE0r_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SET
#define MAIN0_SYNCE_CTL_STAGE0r_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE3f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE3f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE3f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE3f_SET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE2f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE2f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE2f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE2f_SET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE1f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE1f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE1f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE1f_SET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE0f_GET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE0f_GET
#define MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE0f_SET BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r_SYNCE_STAGE0_MODE_PHY_LANE0f_SET
#define READ_MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCD_XGXS_READ_MAIN0_SYNCE_CTL_STAGE0r
#define WRITE_MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCD_XGXS_WRITE_MAIN0_SYNCE_CTL_STAGE0r
#define MODIFY_MAIN0_SYNCE_CTL_STAGE0r BCMI_TSCD_XGXS_MODIFY_MAIN0_SYNCE_CTL_STAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_SYNCE_CTL_STAGE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_SPD_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x9003
 * DESC:     Speed Control Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_RESET_EN     Enable reseting PMD core logic and PLL by Speed control. The port that will reset the pll is selected by master_port_number
 *     TSC_CREDIT_SEL   1-Enables generation of credit based on tsc_clk.0-Enables generation of credit based on PMD transmit clock.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr (0x00109003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SPD_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_s {
	uint32_t v[1];
	uint32_t main0_spd_ctl[1];
	uint32_t _main0_spd_ctl;
} BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_t;

#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_CLR(r) (r).main0_spd_ctl[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_SET(r,d) (r).main0_spd_ctl[0] = d
#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_GET(r) (r).main0_spd_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_TSC_CREDIT_SELf_GET(r) ((((r).main0_spd_ctl[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_TSC_CREDIT_SELf_SET(r,f) (r).main0_spd_ctl[0]=(((r).main0_spd_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_PLL_RESET_ENf_GET(r) ((((r).main0_spd_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_PLL_RESET_ENf_SET(r,f) (r).main0_spd_ctl[0]=(((r).main0_spd_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))

/*
 * These macros can be used to access MAIN0_SPD_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_SPD_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_SPD_CTLr,(_r._main0_spd_ctl))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_SPD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SPD_CTLr,(_r._main0_spd_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_SPD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SPD_CTLr,(_r._main0_spd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SPD_CTLr BCMI_TSCD_XGXS_MAIN0_SPD_CTLr
#define MAIN0_SPD_CTLr_SIZE BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_t MAIN0_SPD_CTLr_t;
#define MAIN0_SPD_CTLr_CLR BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_CLR
#define MAIN0_SPD_CTLr_SET BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_SET
#define MAIN0_SPD_CTLr_GET BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_GET
#define MAIN0_SPD_CTLr_TSC_CREDIT_SELf_GET BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_TSC_CREDIT_SELf_GET
#define MAIN0_SPD_CTLr_TSC_CREDIT_SELf_SET BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_TSC_CREDIT_SELf_SET
#define MAIN0_SPD_CTLr_PLL_RESET_ENf_GET BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_PLL_RESET_ENf_GET
#define MAIN0_SPD_CTLr_PLL_RESET_ENf_SET BCMI_TSCD_XGXS_MAIN0_SPD_CTLr_PLL_RESET_ENf_SET
#define READ_MAIN0_SPD_CTLr BCMI_TSCD_XGXS_READ_MAIN0_SPD_CTLr
#define WRITE_MAIN0_SPD_CTLr BCMI_TSCD_XGXS_WRITE_MAIN0_SPD_CTLr
#define MODIFY_MAIN0_SPD_CTLr BCMI_TSCD_XGXS_MODIFY_MAIN0_SPD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_SPD_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_DEVINPKG5
 * BLOCKS:   MAIN0
 * REGADDR:  0x9004
 * DESC:     Devices in Package5
 * RESETVAL: 0x83 (131)
 * ACCESS:   R/O
 * FIELDS:
 *     CLAUSE22         1 = Clause 22 registers present in package0 = Clause 22 registers not present in package
 *     PMA_PMD          1 = PMA/PMD present in package0 = PMA/PMD not present in package
 *     WIS              1 = WIS present in package0 = WIS not present in package
 *     PCS_XS           1 = PCS present in package0 = PCS not present in package
 *     PHY_XS           1 = PHY XS present in package0 = PHY XS not present in package
 *     DTE_XS           1 = DTE XS present in package0 = DTE XS not present in package
 *     TC               1 = TC present in package0 = TC not present in package
 *     AN               1 = Auto-Negotiation present in package0 = Auto-Negotiation not present in package
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r (0x00109004 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_DEVINPKG5.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_s {
	uint32_t v[1];
	uint32_t main0_devinpkg5[1];
	uint32_t _main0_devinpkg5;
} BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_t;

#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_CLR(r) (r).main0_devinpkg5[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_SET(r,d) (r).main0_devinpkg5[0] = d
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_GET(r) (r).main0_devinpkg5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_ANf_GET(r) ((((r).main0_devinpkg5[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_ANf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_TCf_GET(r) ((((r).main0_devinpkg5[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_TCf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_GET(r) ((((r).main0_devinpkg5[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_WISf_GET(r) ((((r).main0_devinpkg5[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_WISf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_GET(r) ((((r).main0_devinpkg5[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_GET(r) (((r).main0_devinpkg5[0]) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_SET(r,f) (r).main0_devinpkg5[0]=(((r).main0_devinpkg5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_DEVINPKG5.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_DEVINPKG5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_DEVINPKG5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_DEVINPKG5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r,(_r._main0_devinpkg5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_DEVINPKG5r BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r
#define MAIN0_DEVINPKG5r_SIZE BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_t MAIN0_DEVINPKG5r_t;
#define MAIN0_DEVINPKG5r_CLR BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_CLR
#define MAIN0_DEVINPKG5r_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_SET
#define MAIN0_DEVINPKG5r_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_GET
#define MAIN0_DEVINPKG5r_ANf_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_ANf_GET
#define MAIN0_DEVINPKG5r_ANf_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_ANf_SET
#define MAIN0_DEVINPKG5r_TCf_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_TCf_GET
#define MAIN0_DEVINPKG5r_TCf_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_TCf_SET
#define MAIN0_DEVINPKG5r_DTE_XSf_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_GET
#define MAIN0_DEVINPKG5r_DTE_XSf_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_DTE_XSf_SET
#define MAIN0_DEVINPKG5r_PHY_XSf_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_GET
#define MAIN0_DEVINPKG5r_PHY_XSf_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PHY_XSf_SET
#define MAIN0_DEVINPKG5r_PCS_XSf_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_GET
#define MAIN0_DEVINPKG5r_PCS_XSf_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PCS_XSf_SET
#define MAIN0_DEVINPKG5r_WISf_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_WISf_GET
#define MAIN0_DEVINPKG5r_WISf_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_WISf_SET
#define MAIN0_DEVINPKG5r_PMA_PMDf_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_GET
#define MAIN0_DEVINPKG5r_PMA_PMDf_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_PMA_PMDf_SET
#define MAIN0_DEVINPKG5r_CLAUSE22f_GET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_GET
#define MAIN0_DEVINPKG5r_CLAUSE22f_SET BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r_CLAUSE22f_SET
#define READ_MAIN0_DEVINPKG5r BCMI_TSCD_XGXS_READ_MAIN0_DEVINPKG5r
#define WRITE_MAIN0_DEVINPKG5r BCMI_TSCD_XGXS_WRITE_MAIN0_DEVINPKG5r
#define MODIFY_MAIN0_DEVINPKG5r BCMI_TSCD_XGXS_MODIFY_MAIN0_DEVINPKG5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_DEVINPKG5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_TS_TMR_OFFS
 * BLOCKS:   MAIN0
 * REGADDR:  0x9005
 * DESC:     1588 timestamp offset register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     U_TS_OFFSET      Unsigned offset(represented as nanoseconds) to 52-bit timestamp, at PCS level, to account for staging registerson ts_timer and GLAS input stage.This offset will be added to the timestamp from GLAS, both by TX and RX pipelines.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr (0x00109005 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TS_TMR_OFFS.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_s {
	uint32_t v[1];
	uint32_t main0_ts_tmr_offs[1];
	uint32_t _main0_ts_tmr_offs;
} BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_t;

#define BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_CLR(r) (r).main0_ts_tmr_offs[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_SET(r,d) (r).main0_ts_tmr_offs[0] = d
#define BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_GET(r) (r).main0_ts_tmr_offs[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_U_TS_OFFSETf_GET(r) (((r).main0_ts_tmr_offs[0]) & 0xff)
#define BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_U_TS_OFFSETf_SET(r,f) (r).main0_ts_tmr_offs[0]=(((r).main0_ts_tmr_offs[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MAIN0_TS_TMR_OFFS.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_TS_TMR_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr,(_r._main0_ts_tmr_offs))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_TS_TMR_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr,(_r._main0_ts_tmr_offs)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_TS_TMR_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr,(_r._main0_ts_tmr_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TS_TMR_OFFSr BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr
#define MAIN0_TS_TMR_OFFSr_SIZE BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_t MAIN0_TS_TMR_OFFSr_t;
#define MAIN0_TS_TMR_OFFSr_CLR BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_CLR
#define MAIN0_TS_TMR_OFFSr_SET BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_SET
#define MAIN0_TS_TMR_OFFSr_GET BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_GET
#define MAIN0_TS_TMR_OFFSr_U_TS_OFFSETf_GET BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_U_TS_OFFSETf_GET
#define MAIN0_TS_TMR_OFFSr_U_TS_OFFSETf_SET BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr_U_TS_OFFSETf_SET
#define READ_MAIN0_TS_TMR_OFFSr BCMI_TSCD_XGXS_READ_MAIN0_TS_TMR_OFFSr
#define WRITE_MAIN0_TS_TMR_OFFSr BCMI_TSCD_XGXS_WRITE_MAIN0_TS_TMR_OFFSr
#define MODIFY_MAIN0_TS_TMR_OFFSr BCMI_TSCD_XGXS_MODIFY_MAIN0_TS_TMR_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_TS_TMR_OFFSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_TICK_CTL1
 * BLOCKS:   MAIN0
 * REGADDR:  0x9007
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TICK_NUMERATOR_UPPER Bits [18:4] of the tick numerator.  Used when tick_override is true
 *     TICK_OVERRIDE    Enables override of tick counts instead of using refclk_sel
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r (0x00109007 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TICK_CTL1.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_s {
	uint32_t v[1];
	uint32_t main0_tick_ctl1[1];
	uint32_t _main0_tick_ctl1;
} BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_t;

#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_CLR(r) (r).main0_tick_ctl1[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_SET(r,d) (r).main0_tick_ctl1[0] = d
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_GET(r) (r).main0_tick_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET(r) ((((r).main0_tick_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET(r,f) (r).main0_tick_ctl1[0]=(((r).main0_tick_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET(r) (((r).main0_tick_ctl1[0]) & 0x7fff)
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET(r,f) (r).main0_tick_ctl1[0]=(((r).main0_tick_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access MAIN0_TICK_CTL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_TICK_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_TICK_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_TICK_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r,(_r._main0_tick_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TICK_CTL1r BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r
#define MAIN0_TICK_CTL1r_SIZE BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_t MAIN0_TICK_CTL1r_t;
#define MAIN0_TICK_CTL1r_CLR BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_CLR
#define MAIN0_TICK_CTL1r_SET BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_SET
#define MAIN0_TICK_CTL1r_GET BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_GET
#define MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_GET
#define MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_OVERRIDEf_SET
#define MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_GET
#define MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r_TICK_NUMERATOR_UPPERf_SET
#define READ_MAIN0_TICK_CTL1r BCMI_TSCD_XGXS_READ_MAIN0_TICK_CTL1r
#define WRITE_MAIN0_TICK_CTL1r BCMI_TSCD_XGXS_WRITE_MAIN0_TICK_CTL1r
#define MODIFY_MAIN0_TICK_CTL1r BCMI_TSCD_XGXS_MODIFY_MAIN0_TICK_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_TICK_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_TICK_CTL0
 * BLOCKS:   MAIN0
 * REGADDR:  0x9008
 * DESC:     TICK GENERATION CONTROL REGISTER 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TICK_DENOMINATOR Tick denominator.  Used when tick_override is true
 *     TICK_NUMERATOR_LOWER Bits [3:0] of the tick numerator.  Used when tick_override is true
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r (0x00109008 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TICK_CTL0.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_s {
	uint32_t v[1];
	uint32_t main0_tick_ctl0[1];
	uint32_t _main0_tick_ctl0;
} BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_t;

#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_CLR(r) (r).main0_tick_ctl0[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_SET(r,d) (r).main0_tick_ctl0[0] = d
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_GET(r) (r).main0_tick_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET(r) ((((r).main0_tick_ctl0[0]) >> 12) & 0xf)
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET(r,f) (r).main0_tick_ctl0[0]=(((r).main0_tick_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET(r) ((((r).main0_tick_ctl0[0]) >> 2) & 0x3ff)
#define BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET(r,f) (r).main0_tick_ctl0[0]=(((r).main0_tick_ctl0[0] & ~((uint32_t)0x3ff << 2)) | ((((uint32_t)f) & 0x3ff) << 2)) | (1023 << (16 + 2))

/*
 * These macros can be used to access MAIN0_TICK_CTL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_TICK_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_TICK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_TICK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r,(_r._main0_tick_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TICK_CTL0r BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r
#define MAIN0_TICK_CTL0r_SIZE BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_t MAIN0_TICK_CTL0r_t;
#define MAIN0_TICK_CTL0r_CLR BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_CLR
#define MAIN0_TICK_CTL0r_SET BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_SET
#define MAIN0_TICK_CTL0r_GET BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_GET
#define MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_GET
#define MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_NUMERATOR_LOWERf_SET
#define MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_GET
#define MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r_TICK_DENOMINATORf_SET
#define READ_MAIN0_TICK_CTL0r BCMI_TSCD_XGXS_READ_MAIN0_TICK_CTL0r
#define WRITE_MAIN0_TICK_CTL0r BCMI_TSCD_XGXS_WRITE_MAIN0_TICK_CTL0r
#define MODIFY_MAIN0_TICK_CTL0r BCMI_TSCD_XGXS_MODIFY_MAIN0_TICK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_TICK_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_LPBK_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x9009
 * DESC:     LOOPBACK CONTROL REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOCAL_PCS_LOOPBACK_ENABLE Per LOGICAL LANE control to enable PCS based local (TX to RX) loopback
 *     REMOTE_PCS_LOOPBACK_ENABLE Per LOGICAL LANE control to enable PCS based remote (RX to TX) loopback
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr (0x00109009 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_LPBK_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_s {
	uint32_t v[1];
	uint32_t main0_lpbk_ctl[1];
	uint32_t _main0_lpbk_ctl;
} BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_t;

#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_CLR(r) (r).main0_lpbk_ctl[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_SET(r,d) (r).main0_lpbk_ctl[0] = d
#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_GET(r) (r).main0_lpbk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET(r) ((((r).main0_lpbk_ctl[0]) >> 4) & 0xf)
#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).main0_lpbk_ctl[0]=(((r).main0_lpbk_ctl[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET(r) (((r).main0_lpbk_ctl[0]) & 0xf)
#define BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET(r,f) (r).main0_lpbk_ctl[0]=(((r).main0_lpbk_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access MAIN0_LPBK_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_LPBK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr,(_r._main0_lpbk_ctl))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_LPBK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr,(_r._main0_lpbk_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_LPBK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr,(_r._main0_lpbk_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_LPBK_CTLr BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr
#define MAIN0_LPBK_CTLr_SIZE BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_t MAIN0_LPBK_CTLr_t;
#define MAIN0_LPBK_CTLr_CLR BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_CLR
#define MAIN0_LPBK_CTLr_SET BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_SET
#define MAIN0_LPBK_CTLr_GET BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_GET
#define MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_GET
#define MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_REMOTE_PCS_LOOPBACK_ENABLEf_SET
#define MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_GET
#define MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr_LOCAL_PCS_LOOPBACK_ENABLEf_SET
#define READ_MAIN0_LPBK_CTLr BCMI_TSCD_XGXS_READ_MAIN0_LPBK_CTLr
#define WRITE_MAIN0_LPBK_CTLr BCMI_TSCD_XGXS_WRITE_MAIN0_LPBK_CTLr
#define MODIFY_MAIN0_LPBK_CTLr BCMI_TSCD_XGXS_MODIFY_MAIN0_LPBK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_LPBK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_MDIO_BCST
 * BLOCKS:   MAIN0
 * REGADDR:  0x900a
 * DESC:     PRTAD Broadcast Values
 * RESETVAL: 0xf800 (63488)
 * ACCESS:   R/W
 * FIELDS:
 *     MULTIPRTS_EN     per port Broadcast enable
 *     PRTAD_BCST       PORT VALUE FOR BROADCASTING TO MULTIPLE PORTS
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr (0x0010900a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_MDIO_BCST.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_s {
	uint32_t v[1];
	uint32_t main0_mdio_bcst[1];
	uint32_t _main0_mdio_bcst;
} BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_t;

#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_CLR(r) (r).main0_mdio_bcst[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_SET(r,d) (r).main0_mdio_bcst[0] = d
#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_GET(r) (r).main0_mdio_bcst[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_GET(r) ((((r).main0_mdio_bcst[0]) >> 11) & 0x1f)
#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_SET(r,f) (r).main0_mdio_bcst[0]=(((r).main0_mdio_bcst[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_GET(r) ((((r).main0_mdio_bcst[0]) >> 7) & 0xf)
#define BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_SET(r,f) (r).main0_mdio_bcst[0]=(((r).main0_mdio_bcst[0] & ~((uint32_t)0xf << 7)) | ((((uint32_t)f) & 0xf) << 7)) | (15 << (16 + 7))

/*
 * These macros can be used to access MAIN0_MDIO_BCST.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_MDIO_BCSTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr,(_r._main0_mdio_bcst))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_MDIO_BCSTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr,(_r._main0_mdio_bcst)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_MDIO_BCSTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr,(_r._main0_mdio_bcst))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_MDIO_BCSTr BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr
#define MAIN0_MDIO_BCSTr_SIZE BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_t MAIN0_MDIO_BCSTr_t;
#define MAIN0_MDIO_BCSTr_CLR BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_CLR
#define MAIN0_MDIO_BCSTr_SET BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_SET
#define MAIN0_MDIO_BCSTr_GET BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_GET
#define MAIN0_MDIO_BCSTr_PRTAD_BCSTf_GET BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_GET
#define MAIN0_MDIO_BCSTr_PRTAD_BCSTf_SET BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_PRTAD_BCSTf_SET
#define MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_GET BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_GET
#define MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_SET BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr_MULTIPRTS_ENf_SET
#define READ_MAIN0_MDIO_BCSTr BCMI_TSCD_XGXS_READ_MAIN0_MDIO_BCSTr
#define WRITE_MAIN0_MDIO_BCSTr BCMI_TSCD_XGXS_WRITE_MAIN0_MDIO_BCSTr
#define MODIFY_MAIN0_MDIO_BCSTr BCMI_TSCD_XGXS_MODIFY_MAIN0_MDIO_BCSTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_MDIO_BCSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0ACC_TMOUT
 * BLOCKS:   MAIN0
 * REGADDR:  0x900b
 * DESC:     External Access timeout register
 * RESETVAL: 0x50 (80)
 * ACCESS:   R/W
 * FIELDS:
 *     TIMEOUT_COUNT    Timeout count for external access statemachine.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr (0x0010900b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0ACC_TMOUT.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_s {
	uint32_t v[1];
	uint32_t main0acc_tmout[1];
	uint32_t _main0acc_tmout;
} BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_t;

#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_CLR(r) (r).main0acc_tmout[0] = 0
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_SET(r,d) (r).main0acc_tmout[0] = d
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_GET(r) (r).main0acc_tmout[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_TIMEOUT_COUNTf_GET(r) (((r).main0acc_tmout[0]) & 0xff)
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_TIMEOUT_COUNTf_SET(r,f) (r).main0acc_tmout[0]=(((r).main0acc_tmout[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access MAIN0ACC_TMOUT.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0ACC_TMOUTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr,(_r._main0acc_tmout))
#define BCMI_TSCD_XGXS_WRITE_MAIN0ACC_TMOUTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr,(_r._main0acc_tmout)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0ACC_TMOUTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr,(_r._main0acc_tmout))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0ACC_TMOUTr BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr
#define MAIN0ACC_TMOUTr_SIZE BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_t MAIN0ACC_TMOUTr_t;
#define MAIN0ACC_TMOUTr_CLR BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_CLR
#define MAIN0ACC_TMOUTr_SET BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_SET
#define MAIN0ACC_TMOUTr_GET BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_GET
#define MAIN0ACC_TMOUTr_TIMEOUT_COUNTf_GET BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_TIMEOUT_COUNTf_GET
#define MAIN0ACC_TMOUTr_TIMEOUT_COUNTf_SET BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr_TIMEOUT_COUNTf_SET
#define READ_MAIN0ACC_TMOUTr BCMI_TSCD_XGXS_READ_MAIN0ACC_TMOUTr
#define WRITE_MAIN0ACC_TMOUTr BCMI_TSCD_XGXS_WRITE_MAIN0ACC_TMOUTr
#define MODIFY_MAIN0ACC_TMOUTr BCMI_TSCD_XGXS_MODIFY_MAIN0ACC_TMOUTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0ACC_TMOUTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0ACC_TMOUT_STS
 * BLOCKS:   MAIN0
 * REGADDR:  0x900c
 * DESC:     External Access timeout status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TIMEOUT_ERROR    Status indicating the external access state machine did not receive an ack within the timeout_count duration.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr (0x0010900c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0ACC_TMOUT_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_s {
	uint32_t v[1];
	uint32_t main0acc_tmout_sts[1];
	uint32_t _main0acc_tmout_sts;
} BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_t;

#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_CLR(r) (r).main0acc_tmout_sts[0] = 0
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_SET(r,d) (r).main0acc_tmout_sts[0] = d
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_GET(r) (r).main0acc_tmout_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_TIMEOUT_ERRORf_GET(r) (((r).main0acc_tmout_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_TIMEOUT_ERRORf_SET(r,f) (r).main0acc_tmout_sts[0]=(((r).main0acc_tmout_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0ACC_TMOUT_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0ACC_TMOUT_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr,(_r._main0acc_tmout_sts))
#define BCMI_TSCD_XGXS_WRITE_MAIN0ACC_TMOUT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr,(_r._main0acc_tmout_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0ACC_TMOUT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr,(_r._main0acc_tmout_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0ACC_TMOUT_STSr BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr
#define MAIN0ACC_TMOUT_STSr_SIZE BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_t MAIN0ACC_TMOUT_STSr_t;
#define MAIN0ACC_TMOUT_STSr_CLR BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_CLR
#define MAIN0ACC_TMOUT_STSr_SET BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_SET
#define MAIN0ACC_TMOUT_STSr_GET BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_GET
#define MAIN0ACC_TMOUT_STSr_TIMEOUT_ERRORf_GET BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_TIMEOUT_ERRORf_GET
#define MAIN0ACC_TMOUT_STSr_TIMEOUT_ERRORf_SET BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr_TIMEOUT_ERRORf_SET
#define READ_MAIN0ACC_TMOUT_STSr BCMI_TSCD_XGXS_READ_MAIN0ACC_TMOUT_STSr
#define WRITE_MAIN0ACC_TMOUT_STSr BCMI_TSCD_XGXS_WRITE_MAIN0ACC_TMOUT_STSr
#define MODIFY_MAIN0ACC_TMOUT_STSr BCMI_TSCD_XGXS_MODIFY_MAIN0ACC_TMOUT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0ACC_TMOUT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_TS_1588_CTL
 * BLOCKS:   MAIN0
 * REGADDR:  0x900d
 * DESC:     1588 timestamp Control Register
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     RXTX_1588_TS_EN  Enable 1588 timestamping of packets within the TXP and RXP pipelines.
 *     TX_1588_TS_DBG_EN Reserved. This configuration bit has no effect on the design.
 *     RX_TS_RECOVERY_FREQ This bit may be changed to 1, ONLY for VCO 10.3125G or higher, AND 125Mhz timer ts_clk only.Setting this bit to 1 allows RXP timestamp upper bits recovery to be faster.Default Value 0 means frequency of timestamp upper bits recovery is once every 3 ts_clk periods.Value 1 means frequency of timestamp upper bits recovery is once every 2 ts_clk periods.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr (0x0010900d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_TS_1588_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_s {
	uint32_t v[1];
	uint32_t main0_ts_1588_ctl[1];
	uint32_t _main0_ts_1588_ctl;
} BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_t;

#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_CLR(r) (r).main0_ts_1588_ctl[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_SET(r,d) (r).main0_ts_1588_ctl[0] = d
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_GET(r) (r).main0_ts_1588_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RX_TS_RECOVERY_FREQf_GET(r) ((((r).main0_ts_1588_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RX_TS_RECOVERY_FREQf_SET(r,f) (r).main0_ts_1588_ctl[0]=(((r).main0_ts_1588_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_TX_1588_TS_DBG_ENf_GET(r) ((((r).main0_ts_1588_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_TX_1588_TS_DBG_ENf_SET(r,f) (r).main0_ts_1588_ctl[0]=(((r).main0_ts_1588_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RXTX_1588_TS_ENf_GET(r) (((r).main0_ts_1588_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RXTX_1588_TS_ENf_SET(r,f) (r).main0_ts_1588_ctl[0]=(((r).main0_ts_1588_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MAIN0_TS_1588_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_TS_1588_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr,(_r._main0_ts_1588_ctl))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_TS_1588_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr,(_r._main0_ts_1588_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_TS_1588_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr,(_r._main0_ts_1588_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_TS_1588_CTLr BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr
#define MAIN0_TS_1588_CTLr_SIZE BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_t MAIN0_TS_1588_CTLr_t;
#define MAIN0_TS_1588_CTLr_CLR BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_CLR
#define MAIN0_TS_1588_CTLr_SET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_SET
#define MAIN0_TS_1588_CTLr_GET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_GET
#define MAIN0_TS_1588_CTLr_RX_TS_RECOVERY_FREQf_GET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RX_TS_RECOVERY_FREQf_GET
#define MAIN0_TS_1588_CTLr_RX_TS_RECOVERY_FREQf_SET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RX_TS_RECOVERY_FREQf_SET
#define MAIN0_TS_1588_CTLr_TX_1588_TS_DBG_ENf_GET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_TX_1588_TS_DBG_ENf_GET
#define MAIN0_TS_1588_CTLr_TX_1588_TS_DBG_ENf_SET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_TX_1588_TS_DBG_ENf_SET
#define MAIN0_TS_1588_CTLr_RXTX_1588_TS_ENf_GET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RXTX_1588_TS_ENf_GET
#define MAIN0_TS_1588_CTLr_RXTX_1588_TS_ENf_SET BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr_RXTX_1588_TS_ENf_SET
#define READ_MAIN0_TS_1588_CTLr BCMI_TSCD_XGXS_READ_MAIN0_TS_1588_CTLr
#define WRITE_MAIN0_TS_1588_CTLr BCMI_TSCD_XGXS_WRITE_MAIN0_TS_1588_CTLr
#define MODIFY_MAIN0_TS_1588_CTLr BCMI_TSCD_XGXS_MODIFY_MAIN0_TS_1588_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_TS_1588_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  MAIN0_SERDESID
 * BLOCKS:   MAIN0
 * REGADDR:  0x900e
 * DESC:     Serdes ID Register
 * RESETVAL: 0x3ae (942)
 * ACCESS:   R/O
 * FIELDS:
 *     MODEL_NUMBER     Same as phyID model number
 *     TECH_PROC        
 *     BONDING          
 *     REV_NUMBER       
 *     REV_LETTER       
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr (0x0010900e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_SIZE 4

/*
 * This structure should be used to declare and program MAIN0_SERDESID.
 *
 */
typedef union BCMI_TSCD_XGXS_MAIN0_SERDESIDr_s {
	uint32_t v[1];
	uint32_t main0_serdesid[1];
	uint32_t _main0_serdesid;
} BCMI_TSCD_XGXS_MAIN0_SERDESIDr_t;

#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_CLR(r) (r).main0_serdesid[0] = 0
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_SET(r,d) (r).main0_serdesid[0] = d
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_GET(r) (r).main0_serdesid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_LETTERf_GET(r) ((((r).main0_serdesid[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_LETTERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_GET(r) ((((r).main0_serdesid[0]) >> 11) & 0x7)
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_BONDINGf_GET(r) ((((r).main0_serdesid[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_BONDINGf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_TECH_PROCf_GET(r) ((((r).main0_serdesid[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_TECH_PROCf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_GET(r) (((r).main0_serdesid[0]) & 0x3f)
#define BCMI_TSCD_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_SET(r,f) (r).main0_serdesid[0]=(((r).main0_serdesid[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access MAIN0_SERDESID.
 *
 */
#define BCMI_TSCD_XGXS_READ_MAIN0_SERDESIDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid))
#define BCMI_TSCD_XGXS_WRITE_MAIN0_SERDESIDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_MAIN0_SERDESIDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_MAIN0_SERDESIDr,(_r._main0_serdesid))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MAIN0_SERDESIDr BCMI_TSCD_XGXS_MAIN0_SERDESIDr
#define MAIN0_SERDESIDr_SIZE BCMI_TSCD_XGXS_MAIN0_SERDESIDr_SIZE
typedef BCMI_TSCD_XGXS_MAIN0_SERDESIDr_t MAIN0_SERDESIDr_t;
#define MAIN0_SERDESIDr_CLR BCMI_TSCD_XGXS_MAIN0_SERDESIDr_CLR
#define MAIN0_SERDESIDr_SET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_SET
#define MAIN0_SERDESIDr_GET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_GET
#define MAIN0_SERDESIDr_REV_LETTERf_GET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_LETTERf_GET
#define MAIN0_SERDESIDr_REV_LETTERf_SET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_LETTERf_SET
#define MAIN0_SERDESIDr_REV_NUMBERf_GET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_GET
#define MAIN0_SERDESIDr_REV_NUMBERf_SET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_REV_NUMBERf_SET
#define MAIN0_SERDESIDr_BONDINGf_GET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_BONDINGf_GET
#define MAIN0_SERDESIDr_BONDINGf_SET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_BONDINGf_SET
#define MAIN0_SERDESIDr_TECH_PROCf_GET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_TECH_PROCf_GET
#define MAIN0_SERDESIDr_TECH_PROCf_SET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_TECH_PROCf_SET
#define MAIN0_SERDESIDr_MODEL_NUMBERf_GET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_GET
#define MAIN0_SERDESIDr_MODEL_NUMBERf_SET BCMI_TSCD_XGXS_MAIN0_SERDESIDr_MODEL_NUMBERf_SET
#define READ_MAIN0_SERDESIDr BCMI_TSCD_XGXS_READ_MAIN0_SERDESIDr
#define WRITE_MAIN0_SERDESIDr BCMI_TSCD_XGXS_WRITE_MAIN0_SERDESIDr
#define MODIFY_MAIN0_SERDESIDr BCMI_TSCD_XGXS_MODIFY_MAIN0_SERDESIDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_MAIN0_SERDESIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X1_CTL
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9010
 * DESC:     Global PMD reset controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_DP_H_RSTB   PMD Core data path reset override valueOnly used for Speed Control bypass operationby default is zero to keep PMD in reset till enabled
 *     POR_H_RSTB       PMD Core power on resetby default is zero too keep PMD in reset till enabled
 *     REF_CLK_DIV_2    Use CLK buffer IP to generate div/2 clock
 *     REF_CLK_HYST_EN  Enable Hysthesis mode for CLK buffer IPNo Test: Not valid for D5 PMD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X1_CTLr (0x00109010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X1_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x1_ctl[1];
	uint32_t _pmd_x1_ctl;
} BCMI_TSCD_XGXS_PMD_X1_CTLr_t;

#define BCMI_TSCD_XGXS_PMD_X1_CTLr_CLR(r) (r).pmd_x1_ctl[0] = 0
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_SET(r,d) (r).pmd_x1_ctl[0] = d
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_GET(r) (r).pmd_x1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_HYST_ENf_GET(r) ((((r).pmd_x1_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_HYST_ENf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_DIV_2f_GET(r) ((((r).pmd_x1_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_DIV_2f_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET(r) ((((r).pmd_x1_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET(r) (((r).pmd_x1_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET(r,f) (r).pmd_x1_ctl[0]=(((r).pmd_x1_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X1_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))
#define BCMI_TSCD_XGXS_WRITE_PMD_X1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_CTLr,(_r._pmd_x1_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_CTLr BCMI_TSCD_XGXS_PMD_X1_CTLr
#define PMD_X1_CTLr_SIZE BCMI_TSCD_XGXS_PMD_X1_CTLr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X1_CTLr_t PMD_X1_CTLr_t;
#define PMD_X1_CTLr_CLR BCMI_TSCD_XGXS_PMD_X1_CTLr_CLR
#define PMD_X1_CTLr_SET BCMI_TSCD_XGXS_PMD_X1_CTLr_SET
#define PMD_X1_CTLr_GET BCMI_TSCD_XGXS_PMD_X1_CTLr_GET
#define PMD_X1_CTLr_REF_CLK_HYST_ENf_GET BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_HYST_ENf_GET
#define PMD_X1_CTLr_REF_CLK_HYST_ENf_SET BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_HYST_ENf_SET
#define PMD_X1_CTLr_REF_CLK_DIV_2f_GET BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_DIV_2f_GET
#define PMD_X1_CTLr_REF_CLK_DIV_2f_SET BCMI_TSCD_XGXS_PMD_X1_CTLr_REF_CLK_DIV_2f_SET
#define PMD_X1_CTLr_POR_H_RSTBf_GET BCMI_TSCD_XGXS_PMD_X1_CTLr_POR_H_RSTBf_GET
#define PMD_X1_CTLr_POR_H_RSTBf_SET BCMI_TSCD_XGXS_PMD_X1_CTLr_POR_H_RSTBf_SET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_GET BCMI_TSCD_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_GET
#define PMD_X1_CTLr_CORE_DP_H_RSTBf_SET BCMI_TSCD_XGXS_PMD_X1_CTLr_CORE_DP_H_RSTBf_SET
#define READ_PMD_X1_CTLr BCMI_TSCD_XGXS_READ_PMD_X1_CTLr
#define WRITE_PMD_X1_CTLr BCMI_TSCD_XGXS_WRITE_PMD_X1_CTLr
#define MODIFY_PMD_X1_CTLr BCMI_TSCD_XGXS_MODIFY_PMD_X1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X1_MODE
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9011
 * DESC:     Global PMD mode configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_MODE        PMD code mode. Only used when Speed Control logic is bypassedBits 15:12 - Reserved.Bit  11:8  - otp_options.Bits  7:0  - speed_id.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X1_MODEr (0x00109011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X1_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_MODE.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X1_MODEr_s {
	uint32_t v[1];
	uint32_t pmd_x1_mode[1];
	uint32_t _pmd_x1_mode;
} BCMI_TSCD_XGXS_PMD_X1_MODEr_t;

#define BCMI_TSCD_XGXS_PMD_X1_MODEr_CLR(r) (r).pmd_x1_mode[0] = 0
#define BCMI_TSCD_XGXS_PMD_X1_MODEr_SET(r,d) (r).pmd_x1_mode[0] = d
#define BCMI_TSCD_XGXS_PMD_X1_MODEr_GET(r) (r).pmd_x1_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X1_MODEr_CORE_MODEf_GET(r) (((r).pmd_x1_mode[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PMD_X1_MODEr_CORE_MODEf_SET(r,f) (r).pmd_x1_mode[0]=(((r).pmd_x1_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X1_MODE.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X1_MODEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode))
#define BCMI_TSCD_XGXS_WRITE_PMD_X1_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X1_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_MODEr,(_r._pmd_x1_mode))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_MODEr BCMI_TSCD_XGXS_PMD_X1_MODEr
#define PMD_X1_MODEr_SIZE BCMI_TSCD_XGXS_PMD_X1_MODEr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X1_MODEr_t PMD_X1_MODEr_t;
#define PMD_X1_MODEr_CLR BCMI_TSCD_XGXS_PMD_X1_MODEr_CLR
#define PMD_X1_MODEr_SET BCMI_TSCD_XGXS_PMD_X1_MODEr_SET
#define PMD_X1_MODEr_GET BCMI_TSCD_XGXS_PMD_X1_MODEr_GET
#define PMD_X1_MODEr_CORE_MODEf_GET BCMI_TSCD_XGXS_PMD_X1_MODEr_CORE_MODEf_GET
#define PMD_X1_MODEr_CORE_MODEf_SET BCMI_TSCD_XGXS_PMD_X1_MODEr_CORE_MODEf_SET
#define READ_PMD_X1_MODEr BCMI_TSCD_XGXS_READ_PMD_X1_MODEr
#define WRITE_PMD_X1_MODEr BCMI_TSCD_XGXS_WRITE_PMD_X1_MODEr
#define MODIFY_PMD_X1_MODEr BCMI_TSCD_XGXS_MODIFY_PMD_X1_MODEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X1_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X1_STS
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9012
 * DESC:     Global PMD status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL0_LOCK_STS    PMD PLL lock indication
 *     PLL1_LOCK_STS    
 *     PLL2_LOCK_STS    
 *     PLL3_LOCK_STS    
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X1_STSr (0x00109012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X1_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X1_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x1_sts[1];
	uint32_t _pmd_x1_sts;
} BCMI_TSCD_XGXS_PMD_X1_STSr_t;

#define BCMI_TSCD_XGXS_PMD_X1_STSr_CLR(r) (r).pmd_x1_sts[0] = 0
#define BCMI_TSCD_XGXS_PMD_X1_STSr_SET(r,d) (r).pmd_x1_sts[0] = d
#define BCMI_TSCD_XGXS_PMD_X1_STSr_GET(r) (r).pmd_x1_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL3_LOCK_STSf_GET(r) ((((r).pmd_x1_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL3_LOCK_STSf_SET(r,f) (r).pmd_x1_sts[0]=(((r).pmd_x1_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL2_LOCK_STSf_GET(r) ((((r).pmd_x1_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL2_LOCK_STSf_SET(r,f) (r).pmd_x1_sts[0]=(((r).pmd_x1_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL1_LOCK_STSf_GET(r) ((((r).pmd_x1_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL1_LOCK_STSf_SET(r,f) (r).pmd_x1_sts[0]=(((r).pmd_x1_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL0_LOCK_STSf_GET(r) (((r).pmd_x1_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_STSr_PLL0_LOCK_STSf_SET(r,f) (r).pmd_x1_sts[0]=(((r).pmd_x1_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X1_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts))
#define BCMI_TSCD_XGXS_WRITE_PMD_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_STSr,(_r._pmd_x1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_STSr BCMI_TSCD_XGXS_PMD_X1_STSr
#define PMD_X1_STSr_SIZE BCMI_TSCD_XGXS_PMD_X1_STSr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X1_STSr_t PMD_X1_STSr_t;
#define PMD_X1_STSr_CLR BCMI_TSCD_XGXS_PMD_X1_STSr_CLR
#define PMD_X1_STSr_SET BCMI_TSCD_XGXS_PMD_X1_STSr_SET
#define PMD_X1_STSr_GET BCMI_TSCD_XGXS_PMD_X1_STSr_GET
#define PMD_X1_STSr_PLL3_LOCK_STSf_GET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL3_LOCK_STSf_GET
#define PMD_X1_STSr_PLL3_LOCK_STSf_SET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL3_LOCK_STSf_SET
#define PMD_X1_STSr_PLL2_LOCK_STSf_GET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL2_LOCK_STSf_GET
#define PMD_X1_STSr_PLL2_LOCK_STSf_SET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL2_LOCK_STSf_SET
#define PMD_X1_STSr_PLL1_LOCK_STSf_GET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL1_LOCK_STSf_GET
#define PMD_X1_STSr_PLL1_LOCK_STSf_SET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL1_LOCK_STSf_SET
#define PMD_X1_STSr_PLL0_LOCK_STSf_GET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL0_LOCK_STSf_GET
#define PMD_X1_STSr_PLL0_LOCK_STSf_SET BCMI_TSCD_XGXS_PMD_X1_STSr_PLL0_LOCK_STSf_SET
#define READ_PMD_X1_STSr BCMI_TSCD_XGXS_READ_PMD_X1_STSr
#define WRITE_PMD_X1_STSr BCMI_TSCD_XGXS_WRITE_PMD_X1_STSr
#define MODIFY_PMD_X1_STSr BCMI_TSCD_XGXS_MODIFY_PMD_X1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X1_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X1_OVRR
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9013
 * DESC:     Global PMD override
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL0_LOCK_OVRD   PMD PLL0 Lock OverrideOnly used for Speed Control bypass operation
 *     PLL1_LOCK_OVRD   PMD PLL1 Lock OverrideOnly used for Speed Control bypass operation
 *     CORE_MODE_OEN    Override enable for core modeOnly used for Speed Control bypass operation
 *     CORE_DP_H_RSTB_OEN Override enable for PMD Core data path resetOnly used for Speed Control bypass operation
 *     PLL0_VCOCLK4PCS_VLD_OVRD Override for pll0_vcoclk4pcs_vld indication.No Test: Not valid for D5 PMD
 *     PLL1_VCOCLK4PCS_VLD_OVRD Override for pll1_vcoclk4pcs_vld indication.No Test: Not valid for D5 PMD
 *     PLL2_LOCK_OVRD   PMD PLL2 Lock OverrideOnly used for Speed Control bypass operation
 *     PLL3_LOCK_OVRD   PMD PLL3 Lock OverrideOnly used for Speed Control bypass operation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr (0x00109013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_OVRR.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X1_OVRRr_s {
	uint32_t v[1];
	uint32_t pmd_x1_ovrr[1];
	uint32_t _pmd_x1_ovrr;
} BCMI_TSCD_XGXS_PMD_X1_OVRRr_t;

#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_CLR(r) (r).pmd_x1_ovrr[0] = 0
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_SET(r,d) (r).pmd_x1_ovrr[0] = d
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_GET(r) (r).pmd_x1_ovrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL3_LOCK_OVRDf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL3_LOCK_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL2_LOCK_OVRDf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL2_LOCK_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_VCOCLK4PCS_VLD_OVRDf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_VCOCLK4PCS_VLD_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_VCOCLK4PCS_VLD_OVRDf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_VCOCLK4PCS_VLD_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_LOCK_OVRDf_GET(r) ((((r).pmd_x1_ovrr[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_LOCK_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_LOCK_OVRDf_GET(r) (((r).pmd_x1_ovrr[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_LOCK_OVRDf_SET(r,f) (r).pmd_x1_ovrr[0]=(((r).pmd_x1_ovrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X1_OVRR.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X1_OVRRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr))
#define BCMI_TSCD_XGXS_WRITE_PMD_X1_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X1_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_OVRRr,(_r._pmd_x1_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_OVRRr BCMI_TSCD_XGXS_PMD_X1_OVRRr
#define PMD_X1_OVRRr_SIZE BCMI_TSCD_XGXS_PMD_X1_OVRRr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X1_OVRRr_t PMD_X1_OVRRr_t;
#define PMD_X1_OVRRr_CLR BCMI_TSCD_XGXS_PMD_X1_OVRRr_CLR
#define PMD_X1_OVRRr_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_SET
#define PMD_X1_OVRRr_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_GET
#define PMD_X1_OVRRr_PLL3_LOCK_OVRDf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL3_LOCK_OVRDf_GET
#define PMD_X1_OVRRr_PLL3_LOCK_OVRDf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL3_LOCK_OVRDf_SET
#define PMD_X1_OVRRr_PLL2_LOCK_OVRDf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL2_LOCK_OVRDf_GET
#define PMD_X1_OVRRr_PLL2_LOCK_OVRDf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL2_LOCK_OVRDf_SET
#define PMD_X1_OVRRr_PLL1_VCOCLK4PCS_VLD_OVRDf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_VCOCLK4PCS_VLD_OVRDf_GET
#define PMD_X1_OVRRr_PLL1_VCOCLK4PCS_VLD_OVRDf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_VCOCLK4PCS_VLD_OVRDf_SET
#define PMD_X1_OVRRr_PLL0_VCOCLK4PCS_VLD_OVRDf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_VCOCLK4PCS_VLD_OVRDf_GET
#define PMD_X1_OVRRr_PLL0_VCOCLK4PCS_VLD_OVRDf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_VCOCLK4PCS_VLD_OVRDf_SET
#define PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_GET
#define PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_DP_H_RSTB_OENf_SET
#define PMD_X1_OVRRr_CORE_MODE_OENf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_GET
#define PMD_X1_OVRRr_CORE_MODE_OENf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_CORE_MODE_OENf_SET
#define PMD_X1_OVRRr_PLL1_LOCK_OVRDf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_LOCK_OVRDf_GET
#define PMD_X1_OVRRr_PLL1_LOCK_OVRDf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL1_LOCK_OVRDf_SET
#define PMD_X1_OVRRr_PLL0_LOCK_OVRDf_GET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_LOCK_OVRDf_GET
#define PMD_X1_OVRRr_PLL0_LOCK_OVRDf_SET BCMI_TSCD_XGXS_PMD_X1_OVRRr_PLL0_LOCK_OVRDf_SET
#define READ_PMD_X1_OVRRr BCMI_TSCD_XGXS_READ_PMD_X1_OVRRr
#define WRITE_PMD_X1_OVRRr BCMI_TSCD_XGXS_WRITE_PMD_X1_OVRRr
#define MODIFY_PMD_X1_OVRRr BCMI_TSCD_XGXS_MODIFY_PMD_X1_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X1_OVRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X1_FCLK_PERIOD
 * BLOCKS:   PMD_X1
 * REGADDR:  0x9014
 * DESC:     GLAS Fast_clk_period
 * RESETVAL: 0x634c (25420)
 * ACCESS:   R/W
 * FIELDS:
 *     FRAC_NS          Fractional nanoseconds equal to 1 FCLK periodFCLK is VCO-div-8 for 20.625G, 21.875G,25.78125G and27.34375G VCO rates
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr (0x00109014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X1_FCLK_PERIOD.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_s {
	uint32_t v[1];
	uint32_t pmd_x1_fclk_period[1];
	uint32_t _pmd_x1_fclk_period;
} BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_t;

#define BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_CLR(r) (r).pmd_x1_fclk_period[0] = 0
#define BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_SET(r,d) (r).pmd_x1_fclk_period[0] = d
#define BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_GET(r) (r).pmd_x1_fclk_period[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_FRAC_NSf_GET(r) (((r).pmd_x1_fclk_period[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_FRAC_NSf_SET(r,f) (r).pmd_x1_fclk_period[0]=(((r).pmd_x1_fclk_period[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X1_FCLK_PERIOD.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X1_FCLK_PERIODr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr,(_r._pmd_x1_fclk_period))
#define BCMI_TSCD_XGXS_WRITE_PMD_X1_FCLK_PERIODr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr,(_r._pmd_x1_fclk_period)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X1_FCLK_PERIODr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr,(_r._pmd_x1_fclk_period))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X1_FCLK_PERIODr BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr
#define PMD_X1_FCLK_PERIODr_SIZE BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_t PMD_X1_FCLK_PERIODr_t;
#define PMD_X1_FCLK_PERIODr_CLR BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_CLR
#define PMD_X1_FCLK_PERIODr_SET BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_SET
#define PMD_X1_FCLK_PERIODr_GET BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_GET
#define PMD_X1_FCLK_PERIODr_FRAC_NSf_GET BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_FRAC_NSf_GET
#define PMD_X1_FCLK_PERIODr_FRAC_NSf_SET BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr_FRAC_NSf_SET
#define READ_PMD_X1_FCLK_PERIODr BCMI_TSCD_XGXS_READ_PMD_X1_FCLK_PERIODr
#define WRITE_PMD_X1_FCLK_PERIODr BCMI_TSCD_XGXS_WRITE_PMD_X1_FCLK_PERIODr
#define MODIFY_PMD_X1_FCLK_PERIODr BCMI_TSCD_XGXS_MODIFY_PMD_X1_FCLK_PERIODr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X1_FCLK_PERIODr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_CTL1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9030
 * DESC:     Packet Gen Control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRTP_DATA_PATTERN_SEL 0: Local Fault Pattern, 1: Zeros Data PatternPer lane control
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_CTL1r (0x00109030 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_CTL1.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_CTL1r_s {
	uint32_t v[1];
	uint32_t pktgen_ctl1[1];
	uint32_t _pktgen_ctl1;
} BCMI_TSCD_XGXS_PKTGEN_CTL1r_t;

#define BCMI_TSCD_XGXS_PKTGEN_CTL1r_CLR(r) (r).pktgen_ctl1[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_CTL1r_SET(r,d) (r).pktgen_ctl1[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_CTL1r_GET(r) (r).pktgen_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET(r) ((((r).pktgen_ctl1[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET(r,f) (r).pktgen_ctl1[0]=(((r).pktgen_ctl1[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))

/*
 * These macros can be used to access PKTGEN_CTL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_CTL1r,(_r._pktgen_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_CTL1r BCMI_TSCD_XGXS_PKTGEN_CTL1r
#define PKTGEN_CTL1r_SIZE BCMI_TSCD_XGXS_PKTGEN_CTL1r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_CTL1r_t PKTGEN_CTL1r_t;
#define PKTGEN_CTL1r_CLR BCMI_TSCD_XGXS_PKTGEN_CTL1r_CLR
#define PKTGEN_CTL1r_SET BCMI_TSCD_XGXS_PKTGEN_CTL1r_SET
#define PKTGEN_CTL1r_GET BCMI_TSCD_XGXS_PKTGEN_CTL1r_GET
#define PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET BCMI_TSCD_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_GET
#define PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET BCMI_TSCD_XGXS_PKTGEN_CTL1r_PRTP_DATA_PATTERN_SELf_SET
#define READ_PKTGEN_CTL1r BCMI_TSCD_XGXS_READ_PKTGEN_CTL1r
#define WRITE_PKTGEN_CTL1r BCMI_TSCD_XGXS_WRITE_PKTGEN_CTL1r
#define MODIFY_PKTGEN_CTL1r BCMI_TSCD_XGXS_MODIFY_PKTGEN_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PRTPCTL
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9033
 * DESC:     PRTP CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PRTP_EN       Enable Pseudo Random Test Pattern(PRTP) checker
 *     TX_PRTP_EN       Enable Pseudo Random Test Pattern(PRTP) Generator
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr (0x00109033 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PRTPCTL.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_s {
	uint32_t v[1];
	uint32_t pktgen_prtpctl[1];
	uint32_t _pktgen_prtpctl;
} BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_t;

#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_CLR(r) (r).pktgen_prtpctl[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_SET(r,d) (r).pktgen_prtpctl[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_GET(r) (r).pktgen_prtpctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_GET(r) ((((r).pktgen_prtpctl[0]) >> 12) & 0xf)
#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_SET(r,f) (r).pktgen_prtpctl[0]=(((r).pktgen_prtpctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET(r) ((((r).pktgen_prtpctl[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET(r,f) (r).pktgen_prtpctl[0]=(((r).pktgen_prtpctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))

/*
 * These macros can be used to access PKTGEN_PRTPCTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PRTPCTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PRTPCTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PRTPCTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr,(_r._pktgen_prtpctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PRTPCTLr BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr
#define PKTGEN_PRTPCTLr_SIZE BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_t PKTGEN_PRTPCTLr_t;
#define PKTGEN_PRTPCTLr_CLR BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_CLR
#define PKTGEN_PRTPCTLr_SET BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_SET
#define PKTGEN_PRTPCTLr_GET BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_GET
#define PKTGEN_PRTPCTLr_TX_PRTP_ENf_GET BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_GET
#define PKTGEN_PRTPCTLr_TX_PRTP_ENf_SET BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_TX_PRTP_ENf_SET
#define PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_GET
#define PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr_RX_PRTP_ENf_SET
#define READ_PKTGEN_PRTPCTLr BCMI_TSCD_XGXS_READ_PKTGEN_PRTPCTLr
#define WRITE_PKTGEN_PRTPCTLr BCMI_TSCD_XGXS_WRITE_PKTGEN_PRTPCTLr
#define MODIFY_PKTGEN_PRTPCTLr BCMI_TSCD_XGXS_MODIFY_PKTGEN_PRTPCTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PRTPCTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_CRCERRCNT
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9034
 * DESC:     CRC Error Count Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CRCERRCNT        Count of received packet with bad crc. Always returns 0.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr (0x00109034 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_CRCERRCNT.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_s {
	uint32_t v[1];
	uint32_t pktgen_crcerrcnt[1];
	uint32_t _pktgen_crcerrcnt;
} BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_t;

#define BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_CLR(r) (r).pktgen_crcerrcnt[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_SET(r,d) (r).pktgen_crcerrcnt[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_GET(r) (r).pktgen_crcerrcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_GET(r) (((r).pktgen_crcerrcnt[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_SET(r,f) (r).pktgen_crcerrcnt[0]=(((r).pktgen_crcerrcnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_CRCERRCNT.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_CRCERRCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr,(_r._pktgen_crcerrcnt))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_CRCERRCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr,(_r._pktgen_crcerrcnt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_CRCERRCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr,(_r._pktgen_crcerrcnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_CRCERRCNTr BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr
#define PKTGEN_CRCERRCNTr_SIZE BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_t PKTGEN_CRCERRCNTr_t;
#define PKTGEN_CRCERRCNTr_CLR BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_CLR
#define PKTGEN_CRCERRCNTr_SET BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_SET
#define PKTGEN_CRCERRCNTr_GET BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_GET
#define PKTGEN_CRCERRCNTr_CRCERRCNTf_GET BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_GET
#define PKTGEN_CRCERRCNTr_CRCERRCNTf_SET BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr_CRCERRCNTf_SET
#define READ_PKTGEN_CRCERRCNTr BCMI_TSCD_XGXS_READ_PKTGEN_CRCERRCNTr
#define WRITE_PKTGEN_CRCERRCNTr BCMI_TSCD_XGXS_WRITE_PKTGEN_CRCERRCNTr
#define MODIFY_PKTGEN_CRCERRCNTr BCMI_TSCD_XGXS_MODIFY_PKTGEN_CRCERRCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_CRCERRCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9037
 * DESC:     10GBASE-R PCS 0022 test pattern seed A word bits 15:00
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA0           10GBASE-R PCS test pattern seed A bits 0-15, seedA0[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r (0x00109037 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA0.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda0[1];
	uint32_t _pktgen_pcs_seeda0;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_CLR(r) (r).pktgen_pcs_seeda0[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SET(r,d) (r).pktgen_pcs_seeda0[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_GET(r) (r).pktgen_pcs_seeda0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_GET(r) (((r).pktgen_pcs_seeda0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_SET(r,f) (r).pktgen_pcs_seeda0[0]=(((r).pktgen_pcs_seeda0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA0.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r,(_r._pktgen_pcs_seeda0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA0r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r
#define PKTGEN_PCS_SEEDA0r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_t PKTGEN_PCS_SEEDA0r_t;
#define PKTGEN_PCS_SEEDA0r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_CLR
#define PKTGEN_PCS_SEEDA0r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SET
#define PKTGEN_PCS_SEEDA0r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_GET
#define PKTGEN_PCS_SEEDA0r_SEEDA0f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_GET
#define PKTGEN_PCS_SEEDA0r_SEEDA0f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r_SEEDA0f_SET
#define READ_PKTGEN_PCS_SEEDA0r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA0r
#define WRITE_PKTGEN_PCS_SEEDA0r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA0r
#define MODIFY_PKTGEN_PCS_SEEDA0r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9038
 * DESC:     10GBASE-R PCS 0023 test pattern seed A word bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA1           10GBASE-R PCS test pattern seed A bits 16-31, seedA1[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r (0x00109038 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA1.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda1[1];
	uint32_t _pktgen_pcs_seeda1;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_CLR(r) (r).pktgen_pcs_seeda1[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SET(r,d) (r).pktgen_pcs_seeda1[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_GET(r) (r).pktgen_pcs_seeda1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_GET(r) (((r).pktgen_pcs_seeda1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_SET(r,f) (r).pktgen_pcs_seeda1[0]=(((r).pktgen_pcs_seeda1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA1.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r,(_r._pktgen_pcs_seeda1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA1r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r
#define PKTGEN_PCS_SEEDA1r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_t PKTGEN_PCS_SEEDA1r_t;
#define PKTGEN_PCS_SEEDA1r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_CLR
#define PKTGEN_PCS_SEEDA1r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SET
#define PKTGEN_PCS_SEEDA1r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_GET
#define PKTGEN_PCS_SEEDA1r_SEEDA1f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_GET
#define PKTGEN_PCS_SEEDA1r_SEEDA1f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r_SEEDA1f_SET
#define READ_PKTGEN_PCS_SEEDA1r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA1r
#define WRITE_PKTGEN_PCS_SEEDA1r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA1r
#define MODIFY_PKTGEN_PCS_SEEDA1r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x9039
 * DESC:     10GBASE-R PCS 0024 test pattern seed A word bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA2           10GBASE-R PCS test pattern seed A bits 32-47, seedA2[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r (0x00109039 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA2.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda2[1];
	uint32_t _pktgen_pcs_seeda2;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_CLR(r) (r).pktgen_pcs_seeda2[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SET(r,d) (r).pktgen_pcs_seeda2[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_GET(r) (r).pktgen_pcs_seeda2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_GET(r) (((r).pktgen_pcs_seeda2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_SET(r,f) (r).pktgen_pcs_seeda2[0]=(((r).pktgen_pcs_seeda2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA2.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r,(_r._pktgen_pcs_seeda2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA2r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r
#define PKTGEN_PCS_SEEDA2r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_t PKTGEN_PCS_SEEDA2r_t;
#define PKTGEN_PCS_SEEDA2r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_CLR
#define PKTGEN_PCS_SEEDA2r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SET
#define PKTGEN_PCS_SEEDA2r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_GET
#define PKTGEN_PCS_SEEDA2r_SEEDA2f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_GET
#define PKTGEN_PCS_SEEDA2r_SEEDA2f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r_SEEDA2f_SET
#define READ_PKTGEN_PCS_SEEDA2r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA2r
#define WRITE_PKTGEN_PCS_SEEDA2r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA2r
#define MODIFY_PKTGEN_PCS_SEEDA2r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDA3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903a
 * DESC:     10GBASE-R PCS 0025 test pattern seed A word bits 57:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDA3           10GBASE-R PCS test pattern seed A bits 48-57, seedA3[9:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r (0x0010903a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDA3.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seeda3[1];
	uint32_t _pktgen_pcs_seeda3;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_CLR(r) (r).pktgen_pcs_seeda3[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SET(r,d) (r).pktgen_pcs_seeda3[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_GET(r) (r).pktgen_pcs_seeda3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_GET(r) (((r).pktgen_pcs_seeda3[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_SET(r,f) (r).pktgen_pcs_seeda3[0]=(((r).pktgen_pcs_seeda3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDA3.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r,(_r._pktgen_pcs_seeda3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDA3r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r
#define PKTGEN_PCS_SEEDA3r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_t PKTGEN_PCS_SEEDA3r_t;
#define PKTGEN_PCS_SEEDA3r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_CLR
#define PKTGEN_PCS_SEEDA3r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SET
#define PKTGEN_PCS_SEEDA3r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_GET
#define PKTGEN_PCS_SEEDA3r_SEEDA3f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_GET
#define PKTGEN_PCS_SEEDA3r_SEEDA3f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r_SEEDA3f_SET
#define READ_PKTGEN_PCS_SEEDA3r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDA3r
#define WRITE_PKTGEN_PCS_SEEDA3r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDA3r
#define MODIFY_PKTGEN_PCS_SEEDA3r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDA3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB0
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903b
 * DESC:     10GBASE-R PCS 0026 test pattern seed B word bits 15:00
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB0           10GBASE-R PCS test pattern seed B bits 0-15, seedB0[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r (0x0010903b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB0.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb0[1];
	uint32_t _pktgen_pcs_seedb0;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_CLR(r) (r).pktgen_pcs_seedb0[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SET(r,d) (r).pktgen_pcs_seedb0[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_GET(r) (r).pktgen_pcs_seedb0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_GET(r) (((r).pktgen_pcs_seedb0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_SET(r,f) (r).pktgen_pcs_seedb0[0]=(((r).pktgen_pcs_seedb0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB0.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r,(_r._pktgen_pcs_seedb0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB0r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r
#define PKTGEN_PCS_SEEDB0r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_t PKTGEN_PCS_SEEDB0r_t;
#define PKTGEN_PCS_SEEDB0r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_CLR
#define PKTGEN_PCS_SEEDB0r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SET
#define PKTGEN_PCS_SEEDB0r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_GET
#define PKTGEN_PCS_SEEDB0r_SEEDB0f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_GET
#define PKTGEN_PCS_SEEDB0r_SEEDB0f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r_SEEDB0f_SET
#define READ_PKTGEN_PCS_SEEDB0r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB0r
#define WRITE_PKTGEN_PCS_SEEDB0r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB0r
#define MODIFY_PKTGEN_PCS_SEEDB0r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB1
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903c
 * DESC:     10GBASE-R PCS 0027 test pattern seed B word bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB1           10GBASE-R PCS test pattern seed B bits 16-31, seedB1[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r (0x0010903c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB1.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb1[1];
	uint32_t _pktgen_pcs_seedb1;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_CLR(r) (r).pktgen_pcs_seedb1[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SET(r,d) (r).pktgen_pcs_seedb1[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_GET(r) (r).pktgen_pcs_seedb1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_GET(r) (((r).pktgen_pcs_seedb1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_SET(r,f) (r).pktgen_pcs_seedb1[0]=(((r).pktgen_pcs_seedb1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB1.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r,(_r._pktgen_pcs_seedb1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB1r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r
#define PKTGEN_PCS_SEEDB1r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_t PKTGEN_PCS_SEEDB1r_t;
#define PKTGEN_PCS_SEEDB1r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_CLR
#define PKTGEN_PCS_SEEDB1r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SET
#define PKTGEN_PCS_SEEDB1r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_GET
#define PKTGEN_PCS_SEEDB1r_SEEDB1f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_GET
#define PKTGEN_PCS_SEEDB1r_SEEDB1f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r_SEEDB1f_SET
#define READ_PKTGEN_PCS_SEEDB1r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB1r
#define WRITE_PKTGEN_PCS_SEEDB1r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB1r
#define MODIFY_PKTGEN_PCS_SEEDB1r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB2
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903d
 * DESC:     10GBASE-R PCS 0028 test pattern seed B word bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB2           10GBASE-R PCS test pattern seed B bits 32-47, seedB2[15:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r (0x0010903d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB2.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb2[1];
	uint32_t _pktgen_pcs_seedb2;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_CLR(r) (r).pktgen_pcs_seedb2[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SET(r,d) (r).pktgen_pcs_seedb2[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_GET(r) (r).pktgen_pcs_seedb2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_GET(r) (((r).pktgen_pcs_seedb2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_SET(r,f) (r).pktgen_pcs_seedb2[0]=(((r).pktgen_pcs_seedb2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB2.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r,(_r._pktgen_pcs_seedb2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB2r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r
#define PKTGEN_PCS_SEEDB2r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_t PKTGEN_PCS_SEEDB2r_t;
#define PKTGEN_PCS_SEEDB2r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_CLR
#define PKTGEN_PCS_SEEDB2r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SET
#define PKTGEN_PCS_SEEDB2r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_GET
#define PKTGEN_PCS_SEEDB2r_SEEDB2f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_GET
#define PKTGEN_PCS_SEEDB2r_SEEDB2f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r_SEEDB2f_SET
#define READ_PKTGEN_PCS_SEEDB2r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB2r
#define WRITE_PKTGEN_PCS_SEEDB2r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB2r
#define MODIFY_PKTGEN_PCS_SEEDB2r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_PCS_SEEDB3
 * BLOCKS:   PKTGEN0
 * REGADDR:  0x903e
 * DESC:     10GBASE-R PCS 0029 test pattern seed B word bits 57:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SEEDB3           10GBASE-R PCS test pattern seed B bits 48-57, seedB3[9:0]
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r (0x0010903e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_PCS_SEEDB3.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_s {
	uint32_t v[1];
	uint32_t pktgen_pcs_seedb3[1];
	uint32_t _pktgen_pcs_seedb3;
} BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_t;

#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_CLR(r) (r).pktgen_pcs_seedb3[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SET(r,d) (r).pktgen_pcs_seedb3[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_GET(r) (r).pktgen_pcs_seedb3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_GET(r) (((r).pktgen_pcs_seedb3[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_SET(r,f) (r).pktgen_pcs_seedb3[0]=(((r).pktgen_pcs_seedb3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access PKTGEN_PCS_SEEDB3.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r,(_r._pktgen_pcs_seedb3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_PCS_SEEDB3r BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r
#define PKTGEN_PCS_SEEDB3r_SIZE BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_t PKTGEN_PCS_SEEDB3r_t;
#define PKTGEN_PCS_SEEDB3r_CLR BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_CLR
#define PKTGEN_PCS_SEEDB3r_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SET
#define PKTGEN_PCS_SEEDB3r_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_GET
#define PKTGEN_PCS_SEEDB3r_SEEDB3f_GET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_GET
#define PKTGEN_PCS_SEEDB3r_SEEDB3f_SET BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r_SEEDB3f_SET
#define READ_PKTGEN_PCS_SEEDB3r BCMI_TSCD_XGXS_READ_PKTGEN_PCS_SEEDB3r
#define WRITE_PKTGEN_PCS_SEEDB3r BCMI_TSCD_XGXS_WRITE_PKTGEN_PCS_SEEDB3r
#define MODIFY_PKTGEN_PCS_SEEDB3r BCMI_TSCD_XGXS_MODIFY_PKTGEN_PCS_SEEDB3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_PCS_SEEDB3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_ERRMASK4
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9041
 * DESC:     Error mask bits 79:64
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_65_64 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r (0x00109041 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK4.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask4[1];
	uint32_t _pktgen_errmask4;
} BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_t;

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_CLR(r) (r).pktgen_errmask4[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_SET(r,d) (r).pktgen_errmask4[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_GET(r) (r).pktgen_errmask4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_65_64f_GET(r) (((r).pktgen_errmask4[0]) & 0x3)
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_65_64f_SET(r,f) (r).pktgen_errmask4[0]=(((r).pktgen_errmask4[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK4.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r,(_r._pktgen_errmask4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK4r BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r
#define PKTGEN_ERRMASK4r_SIZE BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_t PKTGEN_ERRMASK4r_t;
#define PKTGEN_ERRMASK4r_CLR BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_CLR
#define PKTGEN_ERRMASK4r_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_SET
#define PKTGEN_ERRMASK4r_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_GET
#define PKTGEN_ERRMASK4r_ERROR_MASK_65_64f_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_65_64f_GET
#define PKTGEN_ERRMASK4r_ERROR_MASK_65_64f_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r_ERROR_MASK_65_64f_SET
#define READ_PKTGEN_ERRMASK4r BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK4r
#define WRITE_PKTGEN_ERRMASK4r BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK4r
#define MODIFY_PKTGEN_ERRMASK4r BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_ERRMASK4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_ERRMASK3
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9042
 * DESC:     Error mask bits 63:48
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_63_48 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r (0x00109042 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK3.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask3[1];
	uint32_t _pktgen_errmask3;
} BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_t;

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_CLR(r) (r).pktgen_errmask3[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_SET(r,d) (r).pktgen_errmask3[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_GET(r) (r).pktgen_errmask3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET(r) (((r).pktgen_errmask3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET(r,f) (r).pktgen_errmask3[0]=(((r).pktgen_errmask3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK3.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r,(_r._pktgen_errmask3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK3r BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r
#define PKTGEN_ERRMASK3r_SIZE BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_t PKTGEN_ERRMASK3r_t;
#define PKTGEN_ERRMASK3r_CLR BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_CLR
#define PKTGEN_ERRMASK3r_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_SET
#define PKTGEN_ERRMASK3r_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_GET
#define PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_GET
#define PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r_ERROR_MASK_63_48f_SET
#define READ_PKTGEN_ERRMASK3r BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK3r
#define WRITE_PKTGEN_ERRMASK3r BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK3r
#define MODIFY_PKTGEN_ERRMASK3r BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_ERRMASK3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_ERRMASK2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9043
 * DESC:     Error mask bits 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_47_32 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r (0x00109043 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK2.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask2[1];
	uint32_t _pktgen_errmask2;
} BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_t;

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_CLR(r) (r).pktgen_errmask2[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_SET(r,d) (r).pktgen_errmask2[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_GET(r) (r).pktgen_errmask2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET(r) (((r).pktgen_errmask2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET(r,f) (r).pktgen_errmask2[0]=(((r).pktgen_errmask2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK2.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r,(_r._pktgen_errmask2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK2r BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r
#define PKTGEN_ERRMASK2r_SIZE BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_t PKTGEN_ERRMASK2r_t;
#define PKTGEN_ERRMASK2r_CLR BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_CLR
#define PKTGEN_ERRMASK2r_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_SET
#define PKTGEN_ERRMASK2r_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_GET
#define PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_GET
#define PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r_ERROR_MASK_47_32f_SET
#define READ_PKTGEN_ERRMASK2r BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK2r
#define WRITE_PKTGEN_ERRMASK2r BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK2r
#define MODIFY_PKTGEN_ERRMASK2r BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_ERRMASK2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_ERRMASK1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9044
 * DESC:     Error mask bits 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_31_16 Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r (0x00109044 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK1.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask1[1];
	uint32_t _pktgen_errmask1;
} BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_t;

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_CLR(r) (r).pktgen_errmask1[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_SET(r,d) (r).pktgen_errmask1[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_GET(r) (r).pktgen_errmask1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET(r) (((r).pktgen_errmask1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET(r,f) (r).pktgen_errmask1[0]=(((r).pktgen_errmask1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK1.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r,(_r._pktgen_errmask1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK1r BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r
#define PKTGEN_ERRMASK1r_SIZE BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_t PKTGEN_ERRMASK1r_t;
#define PKTGEN_ERRMASK1r_CLR BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_CLR
#define PKTGEN_ERRMASK1r_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_SET
#define PKTGEN_ERRMASK1r_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_GET
#define PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_GET
#define PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r_ERROR_MASK_31_16f_SET
#define READ_PKTGEN_ERRMASK1r BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK1r
#define WRITE_PKTGEN_ERRMASK1r BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK1r
#define MODIFY_PKTGEN_ERRMASK1r BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_ERRMASK1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_ERRMASK0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9045
 * DESC:     Error mask bits 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_MASK_15_0  Error Mask used to generate errors
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r (0x00109045 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERRMASK0.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_s {
	uint32_t v[1];
	uint32_t pktgen_errmask0[1];
	uint32_t _pktgen_errmask0;
} BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_t;

#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_CLR(r) (r).pktgen_errmask0[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_SET(r,d) (r).pktgen_errmask0[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_GET(r) (r).pktgen_errmask0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET(r) (((r).pktgen_errmask0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET(r,f) (r).pktgen_errmask0[0]=(((r).pktgen_errmask0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_ERRMASK0.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r,(_r._pktgen_errmask0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERRMASK0r BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r
#define PKTGEN_ERRMASK0r_SIZE BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_t PKTGEN_ERRMASK0r_t;
#define PKTGEN_ERRMASK0r_CLR BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_CLR
#define PKTGEN_ERRMASK0r_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_SET
#define PKTGEN_ERRMASK0r_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_GET
#define PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_GET
#define PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r_ERROR_MASK_15_0f_SET
#define READ_PKTGEN_ERRMASK0r BCMI_TSCD_XGXS_READ_PKTGEN_ERRMASK0r
#define WRITE_PKTGEN_ERRMASK0r BCMI_TSCD_XGXS_WRITE_PKTGEN_ERRMASK0r
#define MODIFY_PKTGEN_ERRMASK0r BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERRMASK0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_ERRMASK0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_ERR_INJ_EN0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9046
 * DESC:     Error injection enable control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERRGEN_EN_PH0    PER stream control to enable 66-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     ERRGEN_EN_PH1    PER stream control to enable 66-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     ERRGEN_EN_PH2    PER stream control to enable 66-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r (0x00109046 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERR_INJ_EN0.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_s {
	uint32_t v[1];
	uint32_t pktgen_err_inj_en0[1];
	uint32_t _pktgen_err_inj_en0;
} BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_t;

#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_CLR(r) (r).pktgen_err_inj_en0[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_SET(r,d) (r).pktgen_err_inj_en0[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_GET(r) (r).pktgen_err_inj_en0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH2f_GET(r) ((((r).pktgen_err_inj_en0[0]) >> 10) & 0x1f)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH2f_SET(r,f) (r).pktgen_err_inj_en0[0]=(((r).pktgen_err_inj_en0[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH1f_GET(r) ((((r).pktgen_err_inj_en0[0]) >> 5) & 0x1f)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH1f_SET(r,f) (r).pktgen_err_inj_en0[0]=(((r).pktgen_err_inj_en0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH0f_GET(r) (((r).pktgen_err_inj_en0[0]) & 0x1f)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH0f_SET(r,f) (r).pktgen_err_inj_en0[0]=(((r).pktgen_err_inj_en0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PKTGEN_ERR_INJ_EN0.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_ERR_INJ_EN0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r,(_r._pktgen_err_inj_en0))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_ERR_INJ_EN0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r,(_r._pktgen_err_inj_en0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERR_INJ_EN0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r,(_r._pktgen_err_inj_en0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERR_INJ_EN0r BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r
#define PKTGEN_ERR_INJ_EN0r_SIZE BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_t PKTGEN_ERR_INJ_EN0r_t;
#define PKTGEN_ERR_INJ_EN0r_CLR BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_CLR
#define PKTGEN_ERR_INJ_EN0r_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_SET
#define PKTGEN_ERR_INJ_EN0r_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_GET
#define PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH2f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH2f_GET
#define PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH2f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH2f_SET
#define PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH1f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH1f_GET
#define PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH1f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH1f_SET
#define PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH0f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH0f_GET
#define PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH0f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r_ERRGEN_EN_PH0f_SET
#define READ_PKTGEN_ERR_INJ_EN0r BCMI_TSCD_XGXS_READ_PKTGEN_ERR_INJ_EN0r
#define WRITE_PKTGEN_ERR_INJ_EN0r BCMI_TSCD_XGXS_WRITE_PKTGEN_ERR_INJ_EN0r
#define MODIFY_PKTGEN_ERR_INJ_EN0r BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERR_INJ_EN0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_ERR_INJ_EN1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9047
 * DESC:     Error injection enable control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERRGEN_EN_PH3    PER stream control to enable 66-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_40B_ERRGEN_EN_P0 PER lane control to enable 40-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_40B_ERRGEN_EN_P1 PER lane control to enable 40-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_40B_ERRGEN_EN_P2 PER lane control to enable 40-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_40B_ERRGEN_EN_P3 PER lane control to enable 40-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_80B_ERRGEN_EN_P0 PER lane control to enable 80-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_80B_ERRGEN_EN_P1 PER lane control to enable 80-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_80B_ERRGEN_EN_P2 PER lane control to enable 80-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *     CL91_80B_ERRGEN_EN_P3 PER lane control to enable 80-bit error gen maskNote: Setting this bit results in a one time application of the error mask
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r (0x00109047 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_ERR_INJ_EN1.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_s {
	uint32_t v[1];
	uint32_t pktgen_err_inj_en1[1];
	uint32_t _pktgen_err_inj_en1;
} BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_t;

#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CLR(r) (r).pktgen_err_inj_en1[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_SET(r,d) (r).pktgen_err_inj_en1[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_GET(r) (r).pktgen_err_inj_en1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P3f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P3f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P2f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P2f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P1f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P1f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P0f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P0f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P3f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P3f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P2f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P2f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P1f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P1f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P0f_GET(r) ((((r).pktgen_err_inj_en1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P0f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_ERRGEN_EN_PH3f_GET(r) (((r).pktgen_err_inj_en1[0]) & 0x1f)
#define BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_ERRGEN_EN_PH3f_SET(r,f) (r).pktgen_err_inj_en1[0]=(((r).pktgen_err_inj_en1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access PKTGEN_ERR_INJ_EN1.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_ERR_INJ_EN1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r,(_r._pktgen_err_inj_en1))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_ERR_INJ_EN1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r,(_r._pktgen_err_inj_en1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERR_INJ_EN1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r,(_r._pktgen_err_inj_en1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_ERR_INJ_EN1r BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r
#define PKTGEN_ERR_INJ_EN1r_SIZE BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_t PKTGEN_ERR_INJ_EN1r_t;
#define PKTGEN_ERR_INJ_EN1r_CLR BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CLR
#define PKTGEN_ERR_INJ_EN1r_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_SET
#define PKTGEN_ERR_INJ_EN1r_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P3f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P3f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P3f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P3f_SET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P2f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P2f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P2f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P2f_SET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P1f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P1f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P1f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P1f_SET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P0f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P0f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P0f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_80B_ERRGEN_EN_P0f_SET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P3f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P3f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P3f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P3f_SET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P2f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P2f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P2f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P2f_SET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P1f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P1f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P1f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P1f_SET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P0f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P0f_GET
#define PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P0f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_CL91_40B_ERRGEN_EN_P0f_SET
#define PKTGEN_ERR_INJ_EN1r_ERRGEN_EN_PH3f_GET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_ERRGEN_EN_PH3f_GET
#define PKTGEN_ERR_INJ_EN1r_ERRGEN_EN_PH3f_SET BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r_ERRGEN_EN_PH3f_SET
#define READ_PKTGEN_ERR_INJ_EN1r BCMI_TSCD_XGXS_READ_PKTGEN_ERR_INJ_EN1r
#define WRITE_PKTGEN_ERR_INJ_EN1r BCMI_TSCD_XGXS_WRITE_PKTGEN_ERR_INJ_EN1r
#define MODIFY_PKTGEN_ERR_INJ_EN1r BCMI_TSCD_XGXS_MODIFY_PKTGEN_ERR_INJ_EN1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_ERR_INJ_EN1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_CTL
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9048
 * DESC:     GLAS Test Control
 * RESETVAL: 0x7c (124)
 * ACCESS:   R/W
 * FIELDS:
 *     GLASTEST_EN      1=Enable Test Mode for all GLAS instances. 0=Enable Functional Mode for all GLAS instances.When this bit is set to 1, 1588 timestamping function is not supported.
 *     GLASTEST_ONESHOT When SW writes a 1 to this bit, HW will issue OneShot test for all GLAS instances.Self-clearing after 256 tsc_clk periods.This should be enabled only when normal traffic is not ON".
 *     GLASTEST_ID      GLAS instance selector for Expected and Actual. 0,1,2,3=RX_TS. 9,10,11,12=TX_PMA, 17,18,19,20=TX_TSIf GlasTest_ID values of 17-31 are selected the GlasTest_exp andGlasTest_ActData register reads will always provide zeroesS/W is expected to write a value of 31, whenever the GlasTest mode operation is complete.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr (0x00109048 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_ctl[1];
	uint32_t _pktgen_glastest_ctl;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_CLR(r) (r).pktgen_glastest_ctl[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_SET(r,d) (r).pktgen_glastest_ctl[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GET(r) (r).pktgen_glastest_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_GET(r) ((((r).pktgen_glastest_ctl[0]) >> 2) & 0x1f)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_SET(r,f) (r).pktgen_glastest_ctl[0]=(((r).pktgen_glastest_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2)) | (31 << (16 + 2))
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_GET(r) ((((r).pktgen_glastest_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_SET(r,f) (r).pktgen_glastest_ctl[0]=(((r).pktgen_glastest_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_GET(r) (((r).pktgen_glastest_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_SET(r,f) (r).pktgen_glastest_ctl[0]=(((r).pktgen_glastest_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr,(_r._pktgen_glastest_ctl))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr,(_r._pktgen_glastest_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr,(_r._pktgen_glastest_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_CTLr BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr
#define PKTGEN_GLASTEST_CTLr_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_t PKTGEN_GLASTEST_CTLr_t;
#define PKTGEN_GLASTEST_CTLr_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_CLR
#define PKTGEN_GLASTEST_CTLr_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_SET
#define PKTGEN_GLASTEST_CTLr_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_IDf_SET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ONESHOTf_SET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_GET
#define PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr_GLASTEST_ENf_SET
#define READ_PKTGEN_GLASTEST_CTLr BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_CTLr
#define WRITE_PKTGEN_GLASTEST_CTLr BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_CTLr
#define MODIFY_PKTGEN_GLASTEST_CTLr BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_EXP0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x9049
 * DESC:     GLAS Test Expected Data 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_EXP_15_0 Expected Data output of GLAS. Bits 15:0For 8x RX TS GLAS instances, all bits are validFor 8x TX PMA GLAS instances, only bits 13:0 are validFor 1x TX TS GLAS instances, all bits are valid
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r (0x00109049 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_EXP0.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_exp0[1];
	uint32_t _pktgen_glastest_exp0;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_CLR(r) (r).pktgen_glastest_exp0[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_SET(r,d) (r).pktgen_glastest_exp0[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_GET(r) (r).pktgen_glastest_exp0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_GET(r) (((r).pktgen_glastest_exp0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_SET(r,f) (r).pktgen_glastest_exp0[0]=(((r).pktgen_glastest_exp0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_EXP0.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_EXP0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r,(_r._pktgen_glastest_exp0))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_EXP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r,(_r._pktgen_glastest_exp0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_EXP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r,(_r._pktgen_glastest_exp0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_EXP0r BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r
#define PKTGEN_GLASTEST_EXP0r_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_t PKTGEN_GLASTEST_EXP0r_t;
#define PKTGEN_GLASTEST_EXP0r_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_CLR
#define PKTGEN_GLASTEST_EXP0r_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_SET
#define PKTGEN_GLASTEST_EXP0r_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_GET
#define PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_GET
#define PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r_GLASTEST_EXP_15_0f_SET
#define READ_PKTGEN_GLASTEST_EXP0r BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_EXP0r
#define WRITE_PKTGEN_GLASTEST_EXP0r BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_EXP0r
#define MODIFY_PKTGEN_GLASTEST_EXP0r BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_EXP0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_EXP1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904a
 * DESC:     GLAS Test Expected Data 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_EXP_31_16 Expected Data output of GLAS. Bits 31:16Used only for 1x TX TS GLAS instance.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r (0x0010904a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_EXP1.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_exp1[1];
	uint32_t _pktgen_glastest_exp1;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_CLR(r) (r).pktgen_glastest_exp1[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_SET(r,d) (r).pktgen_glastest_exp1[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_GET(r) (r).pktgen_glastest_exp1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_GET(r) (((r).pktgen_glastest_exp1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_SET(r,f) (r).pktgen_glastest_exp1[0]=(((r).pktgen_glastest_exp1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_EXP1.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_EXP1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r,(_r._pktgen_glastest_exp1))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_EXP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r,(_r._pktgen_glastest_exp1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_EXP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r,(_r._pktgen_glastest_exp1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_EXP1r BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r
#define PKTGEN_GLASTEST_EXP1r_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_t PKTGEN_GLASTEST_EXP1r_t;
#define PKTGEN_GLASTEST_EXP1r_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_CLR
#define PKTGEN_GLASTEST_EXP1r_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_SET
#define PKTGEN_GLASTEST_EXP1r_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_GET
#define PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_GET
#define PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r_GLASTEST_EXP_31_16f_SET
#define READ_PKTGEN_GLASTEST_EXP1r BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_EXP1r
#define WRITE_PKTGEN_GLASTEST_EXP1r BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_EXP1r
#define MODIFY_PKTGEN_GLASTEST_EXP1r BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_EXP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_EXP2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904b
 * DESC:     GLAS Test Expected Data 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_EXP_47_32 Expected Data output of GLAS. Bits 47:32Used only for 1x TX TS GLAS instance.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r (0x0010904b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_EXP2.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_exp2[1];
	uint32_t _pktgen_glastest_exp2;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_CLR(r) (r).pktgen_glastest_exp2[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_SET(r,d) (r).pktgen_glastest_exp2[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_GET(r) (r).pktgen_glastest_exp2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_GET(r) (((r).pktgen_glastest_exp2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_SET(r,f) (r).pktgen_glastest_exp2[0]=(((r).pktgen_glastest_exp2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_EXP2.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_EXP2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r,(_r._pktgen_glastest_exp2))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_EXP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r,(_r._pktgen_glastest_exp2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_EXP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r,(_r._pktgen_glastest_exp2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_EXP2r BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r
#define PKTGEN_GLASTEST_EXP2r_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_t PKTGEN_GLASTEST_EXP2r_t;
#define PKTGEN_GLASTEST_EXP2r_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_CLR
#define PKTGEN_GLASTEST_EXP2r_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_SET
#define PKTGEN_GLASTEST_EXP2r_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_GET
#define PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_GET
#define PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r_GLASTEST_EXP_47_32f_SET
#define READ_PKTGEN_GLASTEST_EXP2r BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_EXP2r
#define WRITE_PKTGEN_GLASTEST_EXP2r BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_EXP2r
#define MODIFY_PKTGEN_GLASTEST_EXP2r BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_EXP2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_EXP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTDATA0
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904c
 * DESC:     GLAS Test Status Actual Data output 15:0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_DAT_15_0 Actual Data output of GLAS. Bits 15:0For 8x RX TS  GLAS instances, all bits are validFor 8x TX PMA GLAS instances, only bits 13:0 are validFor 1x TX TS  GLAS instances, all bits are valid.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r (0x0010904c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTDATA0.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actdata0[1];
	uint32_t _pktgen_glastest_actdata0;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_CLR(r) (r).pktgen_glastest_actdata0[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SET(r,d) (r).pktgen_glastest_actdata0[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GET(r) (r).pktgen_glastest_actdata0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_GET(r) (((r).pktgen_glastest_actdata0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_SET(r,f) (r).pktgen_glastest_actdata0[0]=(((r).pktgen_glastest_actdata0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTDATA0.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTDATA0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r,(_r._pktgen_glastest_actdata0))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r,(_r._pktgen_glastest_actdata0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r,(_r._pktgen_glastest_actdata0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r
#define PKTGEN_GLASTEST_ACTDATA0r_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_t PKTGEN_GLASTEST_ACTDATA0r_t;
#define PKTGEN_GLASTEST_ACTDATA0r_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_CLR
#define PKTGEN_GLASTEST_ACTDATA0r_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_SET
#define PKTGEN_GLASTEST_ACTDATA0r_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GET
#define PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_GET
#define PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r_GLASTEST_DAT_15_0f_SET
#define READ_PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTDATA0r
#define WRITE_PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA0r
#define MODIFY_PKTGEN_GLASTEST_ACTDATA0r BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTDATA1
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904d
 * DESC:     GLAS Test Status Actual Data output 31:16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_DAT_31_16 Actual Data output of GLAS. Bits 31:16Used only for 1x TX TS GLAS instance.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r (0x0010904d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTDATA1.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actdata1[1];
	uint32_t _pktgen_glastest_actdata1;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_CLR(r) (r).pktgen_glastest_actdata1[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SET(r,d) (r).pktgen_glastest_actdata1[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GET(r) (r).pktgen_glastest_actdata1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_GET(r) (((r).pktgen_glastest_actdata1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_SET(r,f) (r).pktgen_glastest_actdata1[0]=(((r).pktgen_glastest_actdata1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTDATA1.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTDATA1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r,(_r._pktgen_glastest_actdata1))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r,(_r._pktgen_glastest_actdata1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r,(_r._pktgen_glastest_actdata1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r
#define PKTGEN_GLASTEST_ACTDATA1r_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_t PKTGEN_GLASTEST_ACTDATA1r_t;
#define PKTGEN_GLASTEST_ACTDATA1r_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_CLR
#define PKTGEN_GLASTEST_ACTDATA1r_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_SET
#define PKTGEN_GLASTEST_ACTDATA1r_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GET
#define PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_GET
#define PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r_GLASTEST_DAT_31_16f_SET
#define READ_PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTDATA1r
#define WRITE_PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA1r
#define MODIFY_PKTGEN_GLASTEST_ACTDATA1r BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTDATA2
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904e
 * DESC:     GLAS Test Status Actual Data output 47:32
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_DAT_47_32 Actual Data output of GLAS. Bits 47:32Used only for 1x TX TS GLAS instance.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r (0x0010904e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTDATA2.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actdata2[1];
	uint32_t _pktgen_glastest_actdata2;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_CLR(r) (r).pktgen_glastest_actdata2[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SET(r,d) (r).pktgen_glastest_actdata2[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GET(r) (r).pktgen_glastest_actdata2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_GET(r) (((r).pktgen_glastest_actdata2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_SET(r,f) (r).pktgen_glastest_actdata2[0]=(((r).pktgen_glastest_actdata2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTDATA2.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTDATA2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r,(_r._pktgen_glastest_actdata2))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r,(_r._pktgen_glastest_actdata2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r,(_r._pktgen_glastest_actdata2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r
#define PKTGEN_GLASTEST_ACTDATA2r_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_t PKTGEN_GLASTEST_ACTDATA2r_t;
#define PKTGEN_GLASTEST_ACTDATA2r_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_CLR
#define PKTGEN_GLASTEST_ACTDATA2r_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_SET
#define PKTGEN_GLASTEST_ACTDATA2r_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GET
#define PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_GET
#define PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r_GLASTEST_DAT_47_32f_SET
#define READ_PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTDATA2r
#define WRITE_PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTDATA2r
#define MODIFY_PKTGEN_GLASTEST_ACTDATA2r BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTDATA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTDATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PKTGEN_GLASTEST_ACTADJ
 * BLOCKS:   PKTGEN1
 * REGADDR:  0x904f
 * DESC:     GLAS Test Status Actual Adjust output AND upper 4 bits of Expected and Actual 52bit TS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLASTEST_ADJ     Actual Adjust output of GLASFor 8x RX TS  GLAS instances, only bits 5:0 are validFor 8x TX PMA GLAS instances, only bits 6:0 are validFor 1x TX TS  GLAS instances, only bits 5:0 are valid.
 *     GLASTEST_EXP_51_48 Expected Data output of GLAS. Bits 51:48Used only for 1x TX TS GLAS instance.
 *     GLASTEST_DAT_51_48 Actual Data output of GLAS. Bits 51:48Used only for 1x TX TS GLAS instance.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr (0x0010904f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_SIZE 4

/*
 * This structure should be used to declare and program PKTGEN_GLASTEST_ACTADJ.
 *
 */
typedef union BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_s {
	uint32_t v[1];
	uint32_t pktgen_glastest_actadj[1];
	uint32_t _pktgen_glastest_actadj;
} BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_t;

#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_CLR(r) (r).pktgen_glastest_actadj[0] = 0
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_SET(r,d) (r).pktgen_glastest_actadj[0] = d
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GET(r) (r).pktgen_glastest_actadj[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_GET(r) ((((r).pktgen_glastest_actadj[0]) >> 12) & 0xf)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_SET(r,f) (r).pktgen_glastest_actadj[0]=(((r).pktgen_glastest_actadj[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_GET(r) ((((r).pktgen_glastest_actadj[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_SET(r,f) (r).pktgen_glastest_actadj[0]=(((r).pktgen_glastest_actadj[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_GET(r) (((r).pktgen_glastest_actadj[0]) & 0xff)
#define BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_SET(r,f) (r).pktgen_glastest_actadj[0]=(((r).pktgen_glastest_actadj[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PKTGEN_GLASTEST_ACTADJ.
 *
 */
#define BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTADJr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr,(_r._pktgen_glastest_actadj))
#define BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTADJr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr,(_r._pktgen_glastest_actadj)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTADJr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr,(_r._pktgen_glastest_actadj))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PKTGEN_GLASTEST_ACTADJr BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr
#define PKTGEN_GLASTEST_ACTADJr_SIZE BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_SIZE
typedef BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_t PKTGEN_GLASTEST_ACTADJr_t;
#define PKTGEN_GLASTEST_ACTADJr_CLR BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_CLR
#define PKTGEN_GLASTEST_ACTADJr_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_SET
#define PKTGEN_GLASTEST_ACTADJr_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_DAT_51_48f_SET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_EXP_51_48f_SET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_GET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_GET
#define PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_SET BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr_GLASTEST_ADJf_SET
#define READ_PKTGEN_GLASTEST_ACTADJr BCMI_TSCD_XGXS_READ_PKTGEN_GLASTEST_ACTADJr
#define WRITE_PKTGEN_GLASTEST_ACTADJr BCMI_TSCD_XGXS_WRITE_PKTGEN_GLASTEST_ACTADJr
#define MODIFY_PKTGEN_GLASTEST_ACTADJr BCMI_TSCD_XGXS_MODIFY_PKTGEN_GLASTEST_ACTADJr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PKTGEN_GLASTEST_ACTADJr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_00
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9050
 * DESC:     Serdes Config Map 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_00 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_00 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_00      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r (0x00109050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_00.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_00[1];
	uint32_t _serdes_cfg_map_00;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_CLR(r) (r).serdes_cfg_map_00[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SET(r,d) (r).serdes_cfg_map_00[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_GET(r) (r).serdes_cfg_map_00[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SPEED_ID_00f_GET(r) ((((r).serdes_cfg_map_00[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SPEED_ID_00f_SET(r,f) (r).serdes_cfg_map_00[0]=(((r).serdes_cfg_map_00[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_O_OR_C_00f_GET(r) ((((r).serdes_cfg_map_00[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_O_OR_C_00f_SET(r,f) (r).serdes_cfg_map_00[0]=(((r).serdes_cfg_map_00[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_ID_00f_GET(r) (((r).serdes_cfg_map_00[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_ID_00f_SET(r,f) (r).serdes_cfg_map_00[0]=(((r).serdes_cfg_map_00[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_00.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_00r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r,(_r._serdes_cfg_map_00))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_00r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r,(_r._serdes_cfg_map_00)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_00r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r,(_r._serdes_cfg_map_00))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_00r BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r
#define SERDES_CFG_MAP_00r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_t SERDES_CFG_MAP_00r_t;
#define SERDES_CFG_MAP_00r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_CLR
#define SERDES_CFG_MAP_00r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SET
#define SERDES_CFG_MAP_00r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_GET
#define SERDES_CFG_MAP_00r_SPEED_ID_00f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SPEED_ID_00f_GET
#define SERDES_CFG_MAP_00r_SPEED_ID_00f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SPEED_ID_00f_SET
#define SERDES_CFG_MAP_00r_SERDES_CONFIG_O_OR_C_00f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_O_OR_C_00f_GET
#define SERDES_CFG_MAP_00r_SERDES_CONFIG_O_OR_C_00f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_O_OR_C_00f_SET
#define SERDES_CFG_MAP_00r_SERDES_CONFIG_ID_00f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_ID_00f_GET
#define SERDES_CFG_MAP_00r_SERDES_CONFIG_ID_00f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r_SERDES_CONFIG_ID_00f_SET
#define READ_SERDES_CFG_MAP_00r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_00r
#define WRITE_SERDES_CFG_MAP_00r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_00r
#define MODIFY_SERDES_CFG_MAP_00r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_00r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_00r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_01
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9051
 * DESC:     Serdes Config Map 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_01 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_01 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_01      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r (0x00109051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_01.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_01[1];
	uint32_t _serdes_cfg_map_01;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_CLR(r) (r).serdes_cfg_map_01[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SET(r,d) (r).serdes_cfg_map_01[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_GET(r) (r).serdes_cfg_map_01[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SPEED_ID_01f_GET(r) ((((r).serdes_cfg_map_01[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SPEED_ID_01f_SET(r,f) (r).serdes_cfg_map_01[0]=(((r).serdes_cfg_map_01[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_O_OR_C_01f_GET(r) ((((r).serdes_cfg_map_01[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_O_OR_C_01f_SET(r,f) (r).serdes_cfg_map_01[0]=(((r).serdes_cfg_map_01[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_ID_01f_GET(r) (((r).serdes_cfg_map_01[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_ID_01f_SET(r,f) (r).serdes_cfg_map_01[0]=(((r).serdes_cfg_map_01[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_01.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_01r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r,(_r._serdes_cfg_map_01))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_01r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r,(_r._serdes_cfg_map_01)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_01r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r,(_r._serdes_cfg_map_01))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_01r BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r
#define SERDES_CFG_MAP_01r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_t SERDES_CFG_MAP_01r_t;
#define SERDES_CFG_MAP_01r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_CLR
#define SERDES_CFG_MAP_01r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SET
#define SERDES_CFG_MAP_01r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_GET
#define SERDES_CFG_MAP_01r_SPEED_ID_01f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SPEED_ID_01f_GET
#define SERDES_CFG_MAP_01r_SPEED_ID_01f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SPEED_ID_01f_SET
#define SERDES_CFG_MAP_01r_SERDES_CONFIG_O_OR_C_01f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_O_OR_C_01f_GET
#define SERDES_CFG_MAP_01r_SERDES_CONFIG_O_OR_C_01f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_O_OR_C_01f_SET
#define SERDES_CFG_MAP_01r_SERDES_CONFIG_ID_01f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_ID_01f_GET
#define SERDES_CFG_MAP_01r_SERDES_CONFIG_ID_01f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r_SERDES_CONFIG_ID_01f_SET
#define READ_SERDES_CFG_MAP_01r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_01r
#define WRITE_SERDES_CFG_MAP_01r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_01r
#define MODIFY_SERDES_CFG_MAP_01r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_01r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_01r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_02
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9052
 * DESC:     Serdes Config Map 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_02 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_02 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_02      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r (0x00109052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_02.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_02[1];
	uint32_t _serdes_cfg_map_02;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_CLR(r) (r).serdes_cfg_map_02[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SET(r,d) (r).serdes_cfg_map_02[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_GET(r) (r).serdes_cfg_map_02[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SPEED_ID_02f_GET(r) ((((r).serdes_cfg_map_02[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SPEED_ID_02f_SET(r,f) (r).serdes_cfg_map_02[0]=(((r).serdes_cfg_map_02[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_O_OR_C_02f_GET(r) ((((r).serdes_cfg_map_02[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_O_OR_C_02f_SET(r,f) (r).serdes_cfg_map_02[0]=(((r).serdes_cfg_map_02[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_ID_02f_GET(r) (((r).serdes_cfg_map_02[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_ID_02f_SET(r,f) (r).serdes_cfg_map_02[0]=(((r).serdes_cfg_map_02[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_02.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_02r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r,(_r._serdes_cfg_map_02))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_02r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r,(_r._serdes_cfg_map_02)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_02r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r,(_r._serdes_cfg_map_02))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_02r BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r
#define SERDES_CFG_MAP_02r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_t SERDES_CFG_MAP_02r_t;
#define SERDES_CFG_MAP_02r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_CLR
#define SERDES_CFG_MAP_02r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SET
#define SERDES_CFG_MAP_02r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_GET
#define SERDES_CFG_MAP_02r_SPEED_ID_02f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SPEED_ID_02f_GET
#define SERDES_CFG_MAP_02r_SPEED_ID_02f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SPEED_ID_02f_SET
#define SERDES_CFG_MAP_02r_SERDES_CONFIG_O_OR_C_02f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_O_OR_C_02f_GET
#define SERDES_CFG_MAP_02r_SERDES_CONFIG_O_OR_C_02f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_O_OR_C_02f_SET
#define SERDES_CFG_MAP_02r_SERDES_CONFIG_ID_02f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_ID_02f_GET
#define SERDES_CFG_MAP_02r_SERDES_CONFIG_ID_02f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r_SERDES_CONFIG_ID_02f_SET
#define READ_SERDES_CFG_MAP_02r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_02r
#define WRITE_SERDES_CFG_MAP_02r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_02r
#define MODIFY_SERDES_CFG_MAP_02r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_02r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_02r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_03
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9053
 * DESC:     Serdes Config Map 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_03 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_03 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_03      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r (0x00109053 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_03.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_03[1];
	uint32_t _serdes_cfg_map_03;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_CLR(r) (r).serdes_cfg_map_03[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SET(r,d) (r).serdes_cfg_map_03[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_GET(r) (r).serdes_cfg_map_03[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SPEED_ID_03f_GET(r) ((((r).serdes_cfg_map_03[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SPEED_ID_03f_SET(r,f) (r).serdes_cfg_map_03[0]=(((r).serdes_cfg_map_03[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_O_OR_C_03f_GET(r) ((((r).serdes_cfg_map_03[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_O_OR_C_03f_SET(r,f) (r).serdes_cfg_map_03[0]=(((r).serdes_cfg_map_03[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_ID_03f_GET(r) (((r).serdes_cfg_map_03[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_ID_03f_SET(r,f) (r).serdes_cfg_map_03[0]=(((r).serdes_cfg_map_03[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_03.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_03r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r,(_r._serdes_cfg_map_03))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_03r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r,(_r._serdes_cfg_map_03)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_03r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r,(_r._serdes_cfg_map_03))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_03r BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r
#define SERDES_CFG_MAP_03r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_t SERDES_CFG_MAP_03r_t;
#define SERDES_CFG_MAP_03r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_CLR
#define SERDES_CFG_MAP_03r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SET
#define SERDES_CFG_MAP_03r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_GET
#define SERDES_CFG_MAP_03r_SPEED_ID_03f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SPEED_ID_03f_GET
#define SERDES_CFG_MAP_03r_SPEED_ID_03f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SPEED_ID_03f_SET
#define SERDES_CFG_MAP_03r_SERDES_CONFIG_O_OR_C_03f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_O_OR_C_03f_GET
#define SERDES_CFG_MAP_03r_SERDES_CONFIG_O_OR_C_03f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_O_OR_C_03f_SET
#define SERDES_CFG_MAP_03r_SERDES_CONFIG_ID_03f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_ID_03f_GET
#define SERDES_CFG_MAP_03r_SERDES_CONFIG_ID_03f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r_SERDES_CONFIG_ID_03f_SET
#define READ_SERDES_CFG_MAP_03r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_03r
#define WRITE_SERDES_CFG_MAP_03r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_03r
#define MODIFY_SERDES_CFG_MAP_03r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_03r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_03r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_04
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9054
 * DESC:     Serdes Config Map 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_04 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_04 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_04      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r (0x00109054 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_04.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_04[1];
	uint32_t _serdes_cfg_map_04;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_CLR(r) (r).serdes_cfg_map_04[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SET(r,d) (r).serdes_cfg_map_04[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_GET(r) (r).serdes_cfg_map_04[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SPEED_ID_04f_GET(r) ((((r).serdes_cfg_map_04[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SPEED_ID_04f_SET(r,f) (r).serdes_cfg_map_04[0]=(((r).serdes_cfg_map_04[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_O_OR_C_04f_GET(r) ((((r).serdes_cfg_map_04[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_O_OR_C_04f_SET(r,f) (r).serdes_cfg_map_04[0]=(((r).serdes_cfg_map_04[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_ID_04f_GET(r) (((r).serdes_cfg_map_04[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_ID_04f_SET(r,f) (r).serdes_cfg_map_04[0]=(((r).serdes_cfg_map_04[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_04.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_04r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r,(_r._serdes_cfg_map_04))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_04r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r,(_r._serdes_cfg_map_04)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_04r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r,(_r._serdes_cfg_map_04))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_04r BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r
#define SERDES_CFG_MAP_04r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_t SERDES_CFG_MAP_04r_t;
#define SERDES_CFG_MAP_04r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_CLR
#define SERDES_CFG_MAP_04r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SET
#define SERDES_CFG_MAP_04r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_GET
#define SERDES_CFG_MAP_04r_SPEED_ID_04f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SPEED_ID_04f_GET
#define SERDES_CFG_MAP_04r_SPEED_ID_04f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SPEED_ID_04f_SET
#define SERDES_CFG_MAP_04r_SERDES_CONFIG_O_OR_C_04f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_O_OR_C_04f_GET
#define SERDES_CFG_MAP_04r_SERDES_CONFIG_O_OR_C_04f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_O_OR_C_04f_SET
#define SERDES_CFG_MAP_04r_SERDES_CONFIG_ID_04f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_ID_04f_GET
#define SERDES_CFG_MAP_04r_SERDES_CONFIG_ID_04f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r_SERDES_CONFIG_ID_04f_SET
#define READ_SERDES_CFG_MAP_04r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_04r
#define WRITE_SERDES_CFG_MAP_04r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_04r
#define MODIFY_SERDES_CFG_MAP_04r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_04r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_04r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_05
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9055
 * DESC:     Serdes Config Map 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_05 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_05 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_05      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r (0x00109055 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_05.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_05[1];
	uint32_t _serdes_cfg_map_05;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_CLR(r) (r).serdes_cfg_map_05[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SET(r,d) (r).serdes_cfg_map_05[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_GET(r) (r).serdes_cfg_map_05[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SPEED_ID_05f_GET(r) ((((r).serdes_cfg_map_05[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SPEED_ID_05f_SET(r,f) (r).serdes_cfg_map_05[0]=(((r).serdes_cfg_map_05[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_O_OR_C_05f_GET(r) ((((r).serdes_cfg_map_05[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_O_OR_C_05f_SET(r,f) (r).serdes_cfg_map_05[0]=(((r).serdes_cfg_map_05[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_ID_05f_GET(r) (((r).serdes_cfg_map_05[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_ID_05f_SET(r,f) (r).serdes_cfg_map_05[0]=(((r).serdes_cfg_map_05[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_05.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_05r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r,(_r._serdes_cfg_map_05))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_05r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r,(_r._serdes_cfg_map_05)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_05r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r,(_r._serdes_cfg_map_05))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_05r BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r
#define SERDES_CFG_MAP_05r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_t SERDES_CFG_MAP_05r_t;
#define SERDES_CFG_MAP_05r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_CLR
#define SERDES_CFG_MAP_05r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SET
#define SERDES_CFG_MAP_05r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_GET
#define SERDES_CFG_MAP_05r_SPEED_ID_05f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SPEED_ID_05f_GET
#define SERDES_CFG_MAP_05r_SPEED_ID_05f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SPEED_ID_05f_SET
#define SERDES_CFG_MAP_05r_SERDES_CONFIG_O_OR_C_05f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_O_OR_C_05f_GET
#define SERDES_CFG_MAP_05r_SERDES_CONFIG_O_OR_C_05f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_O_OR_C_05f_SET
#define SERDES_CFG_MAP_05r_SERDES_CONFIG_ID_05f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_ID_05f_GET
#define SERDES_CFG_MAP_05r_SERDES_CONFIG_ID_05f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r_SERDES_CONFIG_ID_05f_SET
#define READ_SERDES_CFG_MAP_05r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_05r
#define WRITE_SERDES_CFG_MAP_05r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_05r
#define MODIFY_SERDES_CFG_MAP_05r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_05r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_05r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_06
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9056
 * DESC:     Serdes Config Map 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_06 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_06 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_06      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r (0x00109056 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_06.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_06[1];
	uint32_t _serdes_cfg_map_06;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_CLR(r) (r).serdes_cfg_map_06[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SET(r,d) (r).serdes_cfg_map_06[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_GET(r) (r).serdes_cfg_map_06[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SPEED_ID_06f_GET(r) ((((r).serdes_cfg_map_06[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SPEED_ID_06f_SET(r,f) (r).serdes_cfg_map_06[0]=(((r).serdes_cfg_map_06[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_O_OR_C_06f_GET(r) ((((r).serdes_cfg_map_06[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_O_OR_C_06f_SET(r,f) (r).serdes_cfg_map_06[0]=(((r).serdes_cfg_map_06[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_ID_06f_GET(r) (((r).serdes_cfg_map_06[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_ID_06f_SET(r,f) (r).serdes_cfg_map_06[0]=(((r).serdes_cfg_map_06[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_06.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_06r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r,(_r._serdes_cfg_map_06))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_06r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r,(_r._serdes_cfg_map_06)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_06r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r,(_r._serdes_cfg_map_06))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_06r BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r
#define SERDES_CFG_MAP_06r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_t SERDES_CFG_MAP_06r_t;
#define SERDES_CFG_MAP_06r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_CLR
#define SERDES_CFG_MAP_06r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SET
#define SERDES_CFG_MAP_06r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_GET
#define SERDES_CFG_MAP_06r_SPEED_ID_06f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SPEED_ID_06f_GET
#define SERDES_CFG_MAP_06r_SPEED_ID_06f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SPEED_ID_06f_SET
#define SERDES_CFG_MAP_06r_SERDES_CONFIG_O_OR_C_06f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_O_OR_C_06f_GET
#define SERDES_CFG_MAP_06r_SERDES_CONFIG_O_OR_C_06f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_O_OR_C_06f_SET
#define SERDES_CFG_MAP_06r_SERDES_CONFIG_ID_06f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_ID_06f_GET
#define SERDES_CFG_MAP_06r_SERDES_CONFIG_ID_06f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r_SERDES_CONFIG_ID_06f_SET
#define READ_SERDES_CFG_MAP_06r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_06r
#define WRITE_SERDES_CFG_MAP_06r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_06r
#define MODIFY_SERDES_CFG_MAP_06r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_06r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_06r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_07
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9057
 * DESC:     Serdes Config Map 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_07 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_07 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_07      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r (0x00109057 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_07.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_07[1];
	uint32_t _serdes_cfg_map_07;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_CLR(r) (r).serdes_cfg_map_07[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SET(r,d) (r).serdes_cfg_map_07[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_GET(r) (r).serdes_cfg_map_07[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SPEED_ID_07f_GET(r) ((((r).serdes_cfg_map_07[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SPEED_ID_07f_SET(r,f) (r).serdes_cfg_map_07[0]=(((r).serdes_cfg_map_07[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_O_OR_C_07f_GET(r) ((((r).serdes_cfg_map_07[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_O_OR_C_07f_SET(r,f) (r).serdes_cfg_map_07[0]=(((r).serdes_cfg_map_07[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_ID_07f_GET(r) (((r).serdes_cfg_map_07[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_ID_07f_SET(r,f) (r).serdes_cfg_map_07[0]=(((r).serdes_cfg_map_07[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_07.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_07r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r,(_r._serdes_cfg_map_07))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_07r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r,(_r._serdes_cfg_map_07)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_07r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r,(_r._serdes_cfg_map_07))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_07r BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r
#define SERDES_CFG_MAP_07r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_t SERDES_CFG_MAP_07r_t;
#define SERDES_CFG_MAP_07r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_CLR
#define SERDES_CFG_MAP_07r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SET
#define SERDES_CFG_MAP_07r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_GET
#define SERDES_CFG_MAP_07r_SPEED_ID_07f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SPEED_ID_07f_GET
#define SERDES_CFG_MAP_07r_SPEED_ID_07f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SPEED_ID_07f_SET
#define SERDES_CFG_MAP_07r_SERDES_CONFIG_O_OR_C_07f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_O_OR_C_07f_GET
#define SERDES_CFG_MAP_07r_SERDES_CONFIG_O_OR_C_07f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_O_OR_C_07f_SET
#define SERDES_CFG_MAP_07r_SERDES_CONFIG_ID_07f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_ID_07f_GET
#define SERDES_CFG_MAP_07r_SERDES_CONFIG_ID_07f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r_SERDES_CONFIG_ID_07f_SET
#define READ_SERDES_CFG_MAP_07r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_07r
#define WRITE_SERDES_CFG_MAP_07r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_07r
#define MODIFY_SERDES_CFG_MAP_07r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_07r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_07r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_08
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9058
 * DESC:     Serdes Config Map 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_08 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_08 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_08      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r (0x00109058 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_08.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_08[1];
	uint32_t _serdes_cfg_map_08;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_CLR(r) (r).serdes_cfg_map_08[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SET(r,d) (r).serdes_cfg_map_08[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_GET(r) (r).serdes_cfg_map_08[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SPEED_ID_08f_GET(r) ((((r).serdes_cfg_map_08[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SPEED_ID_08f_SET(r,f) (r).serdes_cfg_map_08[0]=(((r).serdes_cfg_map_08[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_O_OR_C_08f_GET(r) ((((r).serdes_cfg_map_08[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_O_OR_C_08f_SET(r,f) (r).serdes_cfg_map_08[0]=(((r).serdes_cfg_map_08[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_ID_08f_GET(r) (((r).serdes_cfg_map_08[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_ID_08f_SET(r,f) (r).serdes_cfg_map_08[0]=(((r).serdes_cfg_map_08[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_08.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_08r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r,(_r._serdes_cfg_map_08))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_08r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r,(_r._serdes_cfg_map_08)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_08r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r,(_r._serdes_cfg_map_08))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_08r BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r
#define SERDES_CFG_MAP_08r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_t SERDES_CFG_MAP_08r_t;
#define SERDES_CFG_MAP_08r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_CLR
#define SERDES_CFG_MAP_08r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SET
#define SERDES_CFG_MAP_08r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_GET
#define SERDES_CFG_MAP_08r_SPEED_ID_08f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SPEED_ID_08f_GET
#define SERDES_CFG_MAP_08r_SPEED_ID_08f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SPEED_ID_08f_SET
#define SERDES_CFG_MAP_08r_SERDES_CONFIG_O_OR_C_08f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_O_OR_C_08f_GET
#define SERDES_CFG_MAP_08r_SERDES_CONFIG_O_OR_C_08f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_O_OR_C_08f_SET
#define SERDES_CFG_MAP_08r_SERDES_CONFIG_ID_08f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_ID_08f_GET
#define SERDES_CFG_MAP_08r_SERDES_CONFIG_ID_08f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r_SERDES_CONFIG_ID_08f_SET
#define READ_SERDES_CFG_MAP_08r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_08r
#define WRITE_SERDES_CFG_MAP_08r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_08r
#define MODIFY_SERDES_CFG_MAP_08r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_08r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_08r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_09
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x9059
 * DESC:     Serdes Config Map 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_09 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_09 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_09      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r (0x00109059 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_09.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_09[1];
	uint32_t _serdes_cfg_map_09;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_CLR(r) (r).serdes_cfg_map_09[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SET(r,d) (r).serdes_cfg_map_09[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_GET(r) (r).serdes_cfg_map_09[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SPEED_ID_09f_GET(r) ((((r).serdes_cfg_map_09[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SPEED_ID_09f_SET(r,f) (r).serdes_cfg_map_09[0]=(((r).serdes_cfg_map_09[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_O_OR_C_09f_GET(r) ((((r).serdes_cfg_map_09[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_O_OR_C_09f_SET(r,f) (r).serdes_cfg_map_09[0]=(((r).serdes_cfg_map_09[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_ID_09f_GET(r) (((r).serdes_cfg_map_09[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_ID_09f_SET(r,f) (r).serdes_cfg_map_09[0]=(((r).serdes_cfg_map_09[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_09.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_09r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r,(_r._serdes_cfg_map_09))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_09r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r,(_r._serdes_cfg_map_09)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_09r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r,(_r._serdes_cfg_map_09))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_09r BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r
#define SERDES_CFG_MAP_09r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_t SERDES_CFG_MAP_09r_t;
#define SERDES_CFG_MAP_09r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_CLR
#define SERDES_CFG_MAP_09r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SET
#define SERDES_CFG_MAP_09r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_GET
#define SERDES_CFG_MAP_09r_SPEED_ID_09f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SPEED_ID_09f_GET
#define SERDES_CFG_MAP_09r_SPEED_ID_09f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SPEED_ID_09f_SET
#define SERDES_CFG_MAP_09r_SERDES_CONFIG_O_OR_C_09f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_O_OR_C_09f_GET
#define SERDES_CFG_MAP_09r_SERDES_CONFIG_O_OR_C_09f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_O_OR_C_09f_SET
#define SERDES_CFG_MAP_09r_SERDES_CONFIG_ID_09f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_ID_09f_GET
#define SERDES_CFG_MAP_09r_SERDES_CONFIG_ID_09f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r_SERDES_CONFIG_ID_09f_SET
#define READ_SERDES_CFG_MAP_09r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_09r
#define WRITE_SERDES_CFG_MAP_09r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_09r
#define MODIFY_SERDES_CFG_MAP_09r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_09r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_09r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_10
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x905a
 * DESC:     Serdes Config Map 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_10 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_10 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_10      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r (0x0010905a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_10[1];
	uint32_t _serdes_cfg_map_10;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_CLR(r) (r).serdes_cfg_map_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SET(r,d) (r).serdes_cfg_map_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_GET(r) (r).serdes_cfg_map_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SPEED_ID_10f_GET(r) ((((r).serdes_cfg_map_10[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SPEED_ID_10f_SET(r,f) (r).serdes_cfg_map_10[0]=(((r).serdes_cfg_map_10[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_O_OR_C_10f_GET(r) ((((r).serdes_cfg_map_10[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_O_OR_C_10f_SET(r,f) (r).serdes_cfg_map_10[0]=(((r).serdes_cfg_map_10[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_ID_10f_GET(r) (((r).serdes_cfg_map_10[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_ID_10f_SET(r,f) (r).serdes_cfg_map_10[0]=(((r).serdes_cfg_map_10[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r,(_r._serdes_cfg_map_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r,(_r._serdes_cfg_map_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r,(_r._serdes_cfg_map_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_10r BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r
#define SERDES_CFG_MAP_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_t SERDES_CFG_MAP_10r_t;
#define SERDES_CFG_MAP_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_CLR
#define SERDES_CFG_MAP_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SET
#define SERDES_CFG_MAP_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_GET
#define SERDES_CFG_MAP_10r_SPEED_ID_10f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SPEED_ID_10f_GET
#define SERDES_CFG_MAP_10r_SPEED_ID_10f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SPEED_ID_10f_SET
#define SERDES_CFG_MAP_10r_SERDES_CONFIG_O_OR_C_10f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_O_OR_C_10f_GET
#define SERDES_CFG_MAP_10r_SERDES_CONFIG_O_OR_C_10f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_O_OR_C_10f_SET
#define SERDES_CFG_MAP_10r_SERDES_CONFIG_ID_10f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_ID_10f_GET
#define SERDES_CFG_MAP_10r_SERDES_CONFIG_ID_10f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r_SERDES_CONFIG_ID_10f_SET
#define READ_SERDES_CFG_MAP_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_10r
#define WRITE_SERDES_CFG_MAP_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_10r
#define MODIFY_SERDES_CFG_MAP_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_11
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x905b
 * DESC:     Serdes Config Map 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_11 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_11 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_11      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r (0x0010905b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_11[1];
	uint32_t _serdes_cfg_map_11;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_CLR(r) (r).serdes_cfg_map_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SET(r,d) (r).serdes_cfg_map_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_GET(r) (r).serdes_cfg_map_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SPEED_ID_11f_GET(r) ((((r).serdes_cfg_map_11[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SPEED_ID_11f_SET(r,f) (r).serdes_cfg_map_11[0]=(((r).serdes_cfg_map_11[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_O_OR_C_11f_GET(r) ((((r).serdes_cfg_map_11[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_O_OR_C_11f_SET(r,f) (r).serdes_cfg_map_11[0]=(((r).serdes_cfg_map_11[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_ID_11f_GET(r) (((r).serdes_cfg_map_11[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_ID_11f_SET(r,f) (r).serdes_cfg_map_11[0]=(((r).serdes_cfg_map_11[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r,(_r._serdes_cfg_map_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r,(_r._serdes_cfg_map_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r,(_r._serdes_cfg_map_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_11r BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r
#define SERDES_CFG_MAP_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_t SERDES_CFG_MAP_11r_t;
#define SERDES_CFG_MAP_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_CLR
#define SERDES_CFG_MAP_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SET
#define SERDES_CFG_MAP_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_GET
#define SERDES_CFG_MAP_11r_SPEED_ID_11f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SPEED_ID_11f_GET
#define SERDES_CFG_MAP_11r_SPEED_ID_11f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SPEED_ID_11f_SET
#define SERDES_CFG_MAP_11r_SERDES_CONFIG_O_OR_C_11f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_O_OR_C_11f_GET
#define SERDES_CFG_MAP_11r_SERDES_CONFIG_O_OR_C_11f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_O_OR_C_11f_SET
#define SERDES_CFG_MAP_11r_SERDES_CONFIG_ID_11f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_ID_11f_GET
#define SERDES_CFG_MAP_11r_SERDES_CONFIG_ID_11f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r_SERDES_CONFIG_ID_11f_SET
#define READ_SERDES_CFG_MAP_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_11r
#define WRITE_SERDES_CFG_MAP_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_11r
#define MODIFY_SERDES_CFG_MAP_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_12
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x905c
 * DESC:     Serdes Config Map 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_12 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_12 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_12      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r (0x0010905c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_12[1];
	uint32_t _serdes_cfg_map_12;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_CLR(r) (r).serdes_cfg_map_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SET(r,d) (r).serdes_cfg_map_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_GET(r) (r).serdes_cfg_map_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SPEED_ID_12f_GET(r) ((((r).serdes_cfg_map_12[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SPEED_ID_12f_SET(r,f) (r).serdes_cfg_map_12[0]=(((r).serdes_cfg_map_12[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_O_OR_C_12f_GET(r) ((((r).serdes_cfg_map_12[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_O_OR_C_12f_SET(r,f) (r).serdes_cfg_map_12[0]=(((r).serdes_cfg_map_12[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_ID_12f_GET(r) (((r).serdes_cfg_map_12[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_ID_12f_SET(r,f) (r).serdes_cfg_map_12[0]=(((r).serdes_cfg_map_12[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r,(_r._serdes_cfg_map_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r,(_r._serdes_cfg_map_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r,(_r._serdes_cfg_map_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_12r BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r
#define SERDES_CFG_MAP_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_t SERDES_CFG_MAP_12r_t;
#define SERDES_CFG_MAP_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_CLR
#define SERDES_CFG_MAP_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SET
#define SERDES_CFG_MAP_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_GET
#define SERDES_CFG_MAP_12r_SPEED_ID_12f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SPEED_ID_12f_GET
#define SERDES_CFG_MAP_12r_SPEED_ID_12f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SPEED_ID_12f_SET
#define SERDES_CFG_MAP_12r_SERDES_CONFIG_O_OR_C_12f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_O_OR_C_12f_GET
#define SERDES_CFG_MAP_12r_SERDES_CONFIG_O_OR_C_12f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_O_OR_C_12f_SET
#define SERDES_CFG_MAP_12r_SERDES_CONFIG_ID_12f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_ID_12f_GET
#define SERDES_CFG_MAP_12r_SERDES_CONFIG_ID_12f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r_SERDES_CONFIG_ID_12f_SET
#define READ_SERDES_CFG_MAP_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_12r
#define WRITE_SERDES_CFG_MAP_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_12r
#define MODIFY_SERDES_CFG_MAP_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_13
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x905d
 * DESC:     Serdes Config Map 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_13 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_13 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_13      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r (0x0010905d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_13[1];
	uint32_t _serdes_cfg_map_13;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_CLR(r) (r).serdes_cfg_map_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SET(r,d) (r).serdes_cfg_map_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_GET(r) (r).serdes_cfg_map_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SPEED_ID_13f_GET(r) ((((r).serdes_cfg_map_13[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SPEED_ID_13f_SET(r,f) (r).serdes_cfg_map_13[0]=(((r).serdes_cfg_map_13[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_O_OR_C_13f_GET(r) ((((r).serdes_cfg_map_13[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_O_OR_C_13f_SET(r,f) (r).serdes_cfg_map_13[0]=(((r).serdes_cfg_map_13[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_ID_13f_GET(r) (((r).serdes_cfg_map_13[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_ID_13f_SET(r,f) (r).serdes_cfg_map_13[0]=(((r).serdes_cfg_map_13[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r,(_r._serdes_cfg_map_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r,(_r._serdes_cfg_map_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r,(_r._serdes_cfg_map_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_13r BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r
#define SERDES_CFG_MAP_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_t SERDES_CFG_MAP_13r_t;
#define SERDES_CFG_MAP_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_CLR
#define SERDES_CFG_MAP_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SET
#define SERDES_CFG_MAP_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_GET
#define SERDES_CFG_MAP_13r_SPEED_ID_13f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SPEED_ID_13f_GET
#define SERDES_CFG_MAP_13r_SPEED_ID_13f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SPEED_ID_13f_SET
#define SERDES_CFG_MAP_13r_SERDES_CONFIG_O_OR_C_13f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_O_OR_C_13f_GET
#define SERDES_CFG_MAP_13r_SERDES_CONFIG_O_OR_C_13f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_O_OR_C_13f_SET
#define SERDES_CFG_MAP_13r_SERDES_CONFIG_ID_13f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_ID_13f_GET
#define SERDES_CFG_MAP_13r_SERDES_CONFIG_ID_13f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r_SERDES_CONFIG_ID_13f_SET
#define READ_SERDES_CFG_MAP_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_13r
#define WRITE_SERDES_CFG_MAP_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_13r
#define MODIFY_SERDES_CFG_MAP_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_14
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x905e
 * DESC:     Serdes Config Map 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_14 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_14 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_14      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r (0x0010905e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_14[1];
	uint32_t _serdes_cfg_map_14;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_CLR(r) (r).serdes_cfg_map_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SET(r,d) (r).serdes_cfg_map_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_GET(r) (r).serdes_cfg_map_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SPEED_ID_14f_GET(r) ((((r).serdes_cfg_map_14[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SPEED_ID_14f_SET(r,f) (r).serdes_cfg_map_14[0]=(((r).serdes_cfg_map_14[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_O_OR_C_14f_GET(r) ((((r).serdes_cfg_map_14[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_O_OR_C_14f_SET(r,f) (r).serdes_cfg_map_14[0]=(((r).serdes_cfg_map_14[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_ID_14f_GET(r) (((r).serdes_cfg_map_14[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_ID_14f_SET(r,f) (r).serdes_cfg_map_14[0]=(((r).serdes_cfg_map_14[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r,(_r._serdes_cfg_map_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r,(_r._serdes_cfg_map_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r,(_r._serdes_cfg_map_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_14r BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r
#define SERDES_CFG_MAP_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_t SERDES_CFG_MAP_14r_t;
#define SERDES_CFG_MAP_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_CLR
#define SERDES_CFG_MAP_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SET
#define SERDES_CFG_MAP_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_GET
#define SERDES_CFG_MAP_14r_SPEED_ID_14f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SPEED_ID_14f_GET
#define SERDES_CFG_MAP_14r_SPEED_ID_14f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SPEED_ID_14f_SET
#define SERDES_CFG_MAP_14r_SERDES_CONFIG_O_OR_C_14f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_O_OR_C_14f_GET
#define SERDES_CFG_MAP_14r_SERDES_CONFIG_O_OR_C_14f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_O_OR_C_14f_SET
#define SERDES_CFG_MAP_14r_SERDES_CONFIG_ID_14f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_ID_14f_GET
#define SERDES_CFG_MAP_14r_SERDES_CONFIG_ID_14f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r_SERDES_CONFIG_ID_14f_SET
#define READ_SERDES_CFG_MAP_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_14r
#define WRITE_SERDES_CFG_MAP_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_14r
#define MODIFY_SERDES_CFG_MAP_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_15
 * BLOCKS:   SERDESCFGMAP0
 * REGADDR:  0x905f
 * DESC:     Serdes Config Map 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_15 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_15 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_15      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r (0x0010905f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_15[1];
	uint32_t _serdes_cfg_map_15;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_CLR(r) (r).serdes_cfg_map_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SET(r,d) (r).serdes_cfg_map_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_GET(r) (r).serdes_cfg_map_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SPEED_ID_15f_GET(r) ((((r).serdes_cfg_map_15[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SPEED_ID_15f_SET(r,f) (r).serdes_cfg_map_15[0]=(((r).serdes_cfg_map_15[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_O_OR_C_15f_GET(r) ((((r).serdes_cfg_map_15[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_O_OR_C_15f_SET(r,f) (r).serdes_cfg_map_15[0]=(((r).serdes_cfg_map_15[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_ID_15f_GET(r) (((r).serdes_cfg_map_15[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_ID_15f_SET(r,f) (r).serdes_cfg_map_15[0]=(((r).serdes_cfg_map_15[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r,(_r._serdes_cfg_map_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r,(_r._serdes_cfg_map_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r,(_r._serdes_cfg_map_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_15r BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r
#define SERDES_CFG_MAP_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_t SERDES_CFG_MAP_15r_t;
#define SERDES_CFG_MAP_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_CLR
#define SERDES_CFG_MAP_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SET
#define SERDES_CFG_MAP_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_GET
#define SERDES_CFG_MAP_15r_SPEED_ID_15f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SPEED_ID_15f_GET
#define SERDES_CFG_MAP_15r_SPEED_ID_15f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SPEED_ID_15f_SET
#define SERDES_CFG_MAP_15r_SERDES_CONFIG_O_OR_C_15f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_O_OR_C_15f_GET
#define SERDES_CFG_MAP_15r_SERDES_CONFIG_O_OR_C_15f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_O_OR_C_15f_SET
#define SERDES_CFG_MAP_15r_SERDES_CONFIG_ID_15f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_ID_15f_GET
#define SERDES_CFG_MAP_15r_SERDES_CONFIG_ID_15f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r_SERDES_CONFIG_ID_15f_SET
#define READ_SERDES_CFG_MAP_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_15r
#define WRITE_SERDES_CFG_MAP_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_15r
#define MODIFY_SERDES_CFG_MAP_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_16
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9060
 * DESC:     Serdes Config Map 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_16 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_16 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_16      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r (0x00109060 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_16[1];
	uint32_t _serdes_cfg_map_16;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_CLR(r) (r).serdes_cfg_map_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SET(r,d) (r).serdes_cfg_map_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_GET(r) (r).serdes_cfg_map_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SPEED_ID_16f_GET(r) ((((r).serdes_cfg_map_16[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SPEED_ID_16f_SET(r,f) (r).serdes_cfg_map_16[0]=(((r).serdes_cfg_map_16[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_O_OR_C_16f_GET(r) ((((r).serdes_cfg_map_16[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_O_OR_C_16f_SET(r,f) (r).serdes_cfg_map_16[0]=(((r).serdes_cfg_map_16[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_ID_16f_GET(r) (((r).serdes_cfg_map_16[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_ID_16f_SET(r,f) (r).serdes_cfg_map_16[0]=(((r).serdes_cfg_map_16[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r,(_r._serdes_cfg_map_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r,(_r._serdes_cfg_map_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r,(_r._serdes_cfg_map_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_16r BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r
#define SERDES_CFG_MAP_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_t SERDES_CFG_MAP_16r_t;
#define SERDES_CFG_MAP_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_CLR
#define SERDES_CFG_MAP_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SET
#define SERDES_CFG_MAP_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_GET
#define SERDES_CFG_MAP_16r_SPEED_ID_16f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SPEED_ID_16f_GET
#define SERDES_CFG_MAP_16r_SPEED_ID_16f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SPEED_ID_16f_SET
#define SERDES_CFG_MAP_16r_SERDES_CONFIG_O_OR_C_16f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_O_OR_C_16f_GET
#define SERDES_CFG_MAP_16r_SERDES_CONFIG_O_OR_C_16f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_O_OR_C_16f_SET
#define SERDES_CFG_MAP_16r_SERDES_CONFIG_ID_16f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_ID_16f_GET
#define SERDES_CFG_MAP_16r_SERDES_CONFIG_ID_16f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r_SERDES_CONFIG_ID_16f_SET
#define READ_SERDES_CFG_MAP_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_16r
#define WRITE_SERDES_CFG_MAP_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_16r
#define MODIFY_SERDES_CFG_MAP_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_17
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9061
 * DESC:     Serdes Config Map 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_17 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_17 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_17      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r (0x00109061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_17[1];
	uint32_t _serdes_cfg_map_17;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_CLR(r) (r).serdes_cfg_map_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SET(r,d) (r).serdes_cfg_map_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_GET(r) (r).serdes_cfg_map_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SPEED_ID_17f_GET(r) ((((r).serdes_cfg_map_17[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SPEED_ID_17f_SET(r,f) (r).serdes_cfg_map_17[0]=(((r).serdes_cfg_map_17[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_O_OR_C_17f_GET(r) ((((r).serdes_cfg_map_17[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_O_OR_C_17f_SET(r,f) (r).serdes_cfg_map_17[0]=(((r).serdes_cfg_map_17[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_ID_17f_GET(r) (((r).serdes_cfg_map_17[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_ID_17f_SET(r,f) (r).serdes_cfg_map_17[0]=(((r).serdes_cfg_map_17[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r,(_r._serdes_cfg_map_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r,(_r._serdes_cfg_map_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r,(_r._serdes_cfg_map_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_17r BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r
#define SERDES_CFG_MAP_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_t SERDES_CFG_MAP_17r_t;
#define SERDES_CFG_MAP_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_CLR
#define SERDES_CFG_MAP_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SET
#define SERDES_CFG_MAP_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_GET
#define SERDES_CFG_MAP_17r_SPEED_ID_17f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SPEED_ID_17f_GET
#define SERDES_CFG_MAP_17r_SPEED_ID_17f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SPEED_ID_17f_SET
#define SERDES_CFG_MAP_17r_SERDES_CONFIG_O_OR_C_17f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_O_OR_C_17f_GET
#define SERDES_CFG_MAP_17r_SERDES_CONFIG_O_OR_C_17f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_O_OR_C_17f_SET
#define SERDES_CFG_MAP_17r_SERDES_CONFIG_ID_17f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_ID_17f_GET
#define SERDES_CFG_MAP_17r_SERDES_CONFIG_ID_17f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r_SERDES_CONFIG_ID_17f_SET
#define READ_SERDES_CFG_MAP_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_17r
#define WRITE_SERDES_CFG_MAP_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_17r
#define MODIFY_SERDES_CFG_MAP_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_18
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9062
 * DESC:     Serdes Config Map 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_18 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_18 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_18      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r (0x00109062 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_18[1];
	uint32_t _serdes_cfg_map_18;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_CLR(r) (r).serdes_cfg_map_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SET(r,d) (r).serdes_cfg_map_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_GET(r) (r).serdes_cfg_map_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SPEED_ID_18f_GET(r) ((((r).serdes_cfg_map_18[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SPEED_ID_18f_SET(r,f) (r).serdes_cfg_map_18[0]=(((r).serdes_cfg_map_18[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_O_OR_C_18f_GET(r) ((((r).serdes_cfg_map_18[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_O_OR_C_18f_SET(r,f) (r).serdes_cfg_map_18[0]=(((r).serdes_cfg_map_18[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_ID_18f_GET(r) (((r).serdes_cfg_map_18[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_ID_18f_SET(r,f) (r).serdes_cfg_map_18[0]=(((r).serdes_cfg_map_18[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r,(_r._serdes_cfg_map_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r,(_r._serdes_cfg_map_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r,(_r._serdes_cfg_map_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_18r BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r
#define SERDES_CFG_MAP_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_t SERDES_CFG_MAP_18r_t;
#define SERDES_CFG_MAP_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_CLR
#define SERDES_CFG_MAP_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SET
#define SERDES_CFG_MAP_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_GET
#define SERDES_CFG_MAP_18r_SPEED_ID_18f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SPEED_ID_18f_GET
#define SERDES_CFG_MAP_18r_SPEED_ID_18f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SPEED_ID_18f_SET
#define SERDES_CFG_MAP_18r_SERDES_CONFIG_O_OR_C_18f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_O_OR_C_18f_GET
#define SERDES_CFG_MAP_18r_SERDES_CONFIG_O_OR_C_18f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_O_OR_C_18f_SET
#define SERDES_CFG_MAP_18r_SERDES_CONFIG_ID_18f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_ID_18f_GET
#define SERDES_CFG_MAP_18r_SERDES_CONFIG_ID_18f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r_SERDES_CONFIG_ID_18f_SET
#define READ_SERDES_CFG_MAP_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_18r
#define WRITE_SERDES_CFG_MAP_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_18r
#define MODIFY_SERDES_CFG_MAP_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_19
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9063
 * DESC:     Serdes Config Map 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_19 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_19 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_19      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r (0x00109063 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_19[1];
	uint32_t _serdes_cfg_map_19;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_CLR(r) (r).serdes_cfg_map_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SET(r,d) (r).serdes_cfg_map_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_GET(r) (r).serdes_cfg_map_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SPEED_ID_19f_GET(r) ((((r).serdes_cfg_map_19[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SPEED_ID_19f_SET(r,f) (r).serdes_cfg_map_19[0]=(((r).serdes_cfg_map_19[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_O_OR_C_19f_GET(r) ((((r).serdes_cfg_map_19[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_O_OR_C_19f_SET(r,f) (r).serdes_cfg_map_19[0]=(((r).serdes_cfg_map_19[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_ID_19f_GET(r) (((r).serdes_cfg_map_19[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_ID_19f_SET(r,f) (r).serdes_cfg_map_19[0]=(((r).serdes_cfg_map_19[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r,(_r._serdes_cfg_map_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r,(_r._serdes_cfg_map_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r,(_r._serdes_cfg_map_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_19r BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r
#define SERDES_CFG_MAP_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_t SERDES_CFG_MAP_19r_t;
#define SERDES_CFG_MAP_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_CLR
#define SERDES_CFG_MAP_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SET
#define SERDES_CFG_MAP_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_GET
#define SERDES_CFG_MAP_19r_SPEED_ID_19f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SPEED_ID_19f_GET
#define SERDES_CFG_MAP_19r_SPEED_ID_19f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SPEED_ID_19f_SET
#define SERDES_CFG_MAP_19r_SERDES_CONFIG_O_OR_C_19f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_O_OR_C_19f_GET
#define SERDES_CFG_MAP_19r_SERDES_CONFIG_O_OR_C_19f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_O_OR_C_19f_SET
#define SERDES_CFG_MAP_19r_SERDES_CONFIG_ID_19f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_ID_19f_GET
#define SERDES_CFG_MAP_19r_SERDES_CONFIG_ID_19f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r_SERDES_CONFIG_ID_19f_SET
#define READ_SERDES_CFG_MAP_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_19r
#define WRITE_SERDES_CFG_MAP_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_19r
#define MODIFY_SERDES_CFG_MAP_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_20
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9064
 * DESC:     Serdes Config Map 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_20 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_20 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_20      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r (0x00109064 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_20[1];
	uint32_t _serdes_cfg_map_20;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_CLR(r) (r).serdes_cfg_map_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SET(r,d) (r).serdes_cfg_map_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_GET(r) (r).serdes_cfg_map_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SPEED_ID_20f_GET(r) ((((r).serdes_cfg_map_20[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SPEED_ID_20f_SET(r,f) (r).serdes_cfg_map_20[0]=(((r).serdes_cfg_map_20[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_O_OR_C_20f_GET(r) ((((r).serdes_cfg_map_20[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_O_OR_C_20f_SET(r,f) (r).serdes_cfg_map_20[0]=(((r).serdes_cfg_map_20[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_ID_20f_GET(r) (((r).serdes_cfg_map_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_ID_20f_SET(r,f) (r).serdes_cfg_map_20[0]=(((r).serdes_cfg_map_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r,(_r._serdes_cfg_map_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r,(_r._serdes_cfg_map_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r,(_r._serdes_cfg_map_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_20r BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r
#define SERDES_CFG_MAP_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_t SERDES_CFG_MAP_20r_t;
#define SERDES_CFG_MAP_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_CLR
#define SERDES_CFG_MAP_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SET
#define SERDES_CFG_MAP_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_GET
#define SERDES_CFG_MAP_20r_SPEED_ID_20f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SPEED_ID_20f_GET
#define SERDES_CFG_MAP_20r_SPEED_ID_20f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SPEED_ID_20f_SET
#define SERDES_CFG_MAP_20r_SERDES_CONFIG_O_OR_C_20f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_O_OR_C_20f_GET
#define SERDES_CFG_MAP_20r_SERDES_CONFIG_O_OR_C_20f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_O_OR_C_20f_SET
#define SERDES_CFG_MAP_20r_SERDES_CONFIG_ID_20f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_ID_20f_GET
#define SERDES_CFG_MAP_20r_SERDES_CONFIG_ID_20f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r_SERDES_CONFIG_ID_20f_SET
#define READ_SERDES_CFG_MAP_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_20r
#define WRITE_SERDES_CFG_MAP_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_20r
#define MODIFY_SERDES_CFG_MAP_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_21
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9065
 * DESC:     Serdes Config Map 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_21 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_21 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_21      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r (0x00109065 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_21[1];
	uint32_t _serdes_cfg_map_21;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_CLR(r) (r).serdes_cfg_map_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SET(r,d) (r).serdes_cfg_map_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_GET(r) (r).serdes_cfg_map_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SPEED_ID_21f_GET(r) ((((r).serdes_cfg_map_21[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SPEED_ID_21f_SET(r,f) (r).serdes_cfg_map_21[0]=(((r).serdes_cfg_map_21[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_O_OR_C_21f_GET(r) ((((r).serdes_cfg_map_21[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_O_OR_C_21f_SET(r,f) (r).serdes_cfg_map_21[0]=(((r).serdes_cfg_map_21[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_ID_21f_GET(r) (((r).serdes_cfg_map_21[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_ID_21f_SET(r,f) (r).serdes_cfg_map_21[0]=(((r).serdes_cfg_map_21[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r,(_r._serdes_cfg_map_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r,(_r._serdes_cfg_map_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r,(_r._serdes_cfg_map_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_21r BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r
#define SERDES_CFG_MAP_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_t SERDES_CFG_MAP_21r_t;
#define SERDES_CFG_MAP_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_CLR
#define SERDES_CFG_MAP_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SET
#define SERDES_CFG_MAP_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_GET
#define SERDES_CFG_MAP_21r_SPEED_ID_21f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SPEED_ID_21f_GET
#define SERDES_CFG_MAP_21r_SPEED_ID_21f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SPEED_ID_21f_SET
#define SERDES_CFG_MAP_21r_SERDES_CONFIG_O_OR_C_21f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_O_OR_C_21f_GET
#define SERDES_CFG_MAP_21r_SERDES_CONFIG_O_OR_C_21f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_O_OR_C_21f_SET
#define SERDES_CFG_MAP_21r_SERDES_CONFIG_ID_21f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_ID_21f_GET
#define SERDES_CFG_MAP_21r_SERDES_CONFIG_ID_21f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r_SERDES_CONFIG_ID_21f_SET
#define READ_SERDES_CFG_MAP_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_21r
#define WRITE_SERDES_CFG_MAP_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_21r
#define MODIFY_SERDES_CFG_MAP_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_22
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9066
 * DESC:     Serdes Config Map 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_22 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_22 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_22      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r (0x00109066 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_22[1];
	uint32_t _serdes_cfg_map_22;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_CLR(r) (r).serdes_cfg_map_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SET(r,d) (r).serdes_cfg_map_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_GET(r) (r).serdes_cfg_map_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SPEED_ID_22f_GET(r) ((((r).serdes_cfg_map_22[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SPEED_ID_22f_SET(r,f) (r).serdes_cfg_map_22[0]=(((r).serdes_cfg_map_22[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_O_OR_C_22f_GET(r) ((((r).serdes_cfg_map_22[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_O_OR_C_22f_SET(r,f) (r).serdes_cfg_map_22[0]=(((r).serdes_cfg_map_22[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_ID_22f_GET(r) (((r).serdes_cfg_map_22[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_ID_22f_SET(r,f) (r).serdes_cfg_map_22[0]=(((r).serdes_cfg_map_22[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r,(_r._serdes_cfg_map_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r,(_r._serdes_cfg_map_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r,(_r._serdes_cfg_map_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_22r BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r
#define SERDES_CFG_MAP_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_t SERDES_CFG_MAP_22r_t;
#define SERDES_CFG_MAP_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_CLR
#define SERDES_CFG_MAP_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SET
#define SERDES_CFG_MAP_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_GET
#define SERDES_CFG_MAP_22r_SPEED_ID_22f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SPEED_ID_22f_GET
#define SERDES_CFG_MAP_22r_SPEED_ID_22f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SPEED_ID_22f_SET
#define SERDES_CFG_MAP_22r_SERDES_CONFIG_O_OR_C_22f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_O_OR_C_22f_GET
#define SERDES_CFG_MAP_22r_SERDES_CONFIG_O_OR_C_22f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_O_OR_C_22f_SET
#define SERDES_CFG_MAP_22r_SERDES_CONFIG_ID_22f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_ID_22f_GET
#define SERDES_CFG_MAP_22r_SERDES_CONFIG_ID_22f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r_SERDES_CONFIG_ID_22f_SET
#define READ_SERDES_CFG_MAP_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_22r
#define WRITE_SERDES_CFG_MAP_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_22r
#define MODIFY_SERDES_CFG_MAP_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_23
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9067
 * DESC:     Serdes Config Map 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_23 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_23 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_23      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r (0x00109067 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_23[1];
	uint32_t _serdes_cfg_map_23;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_CLR(r) (r).serdes_cfg_map_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SET(r,d) (r).serdes_cfg_map_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_GET(r) (r).serdes_cfg_map_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SPEED_ID_23f_GET(r) ((((r).serdes_cfg_map_23[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SPEED_ID_23f_SET(r,f) (r).serdes_cfg_map_23[0]=(((r).serdes_cfg_map_23[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_O_OR_C_23f_GET(r) ((((r).serdes_cfg_map_23[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_O_OR_C_23f_SET(r,f) (r).serdes_cfg_map_23[0]=(((r).serdes_cfg_map_23[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_ID_23f_GET(r) (((r).serdes_cfg_map_23[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_ID_23f_SET(r,f) (r).serdes_cfg_map_23[0]=(((r).serdes_cfg_map_23[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r,(_r._serdes_cfg_map_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r,(_r._serdes_cfg_map_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r,(_r._serdes_cfg_map_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_23r BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r
#define SERDES_CFG_MAP_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_t SERDES_CFG_MAP_23r_t;
#define SERDES_CFG_MAP_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_CLR
#define SERDES_CFG_MAP_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SET
#define SERDES_CFG_MAP_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_GET
#define SERDES_CFG_MAP_23r_SPEED_ID_23f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SPEED_ID_23f_GET
#define SERDES_CFG_MAP_23r_SPEED_ID_23f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SPEED_ID_23f_SET
#define SERDES_CFG_MAP_23r_SERDES_CONFIG_O_OR_C_23f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_O_OR_C_23f_GET
#define SERDES_CFG_MAP_23r_SERDES_CONFIG_O_OR_C_23f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_O_OR_C_23f_SET
#define SERDES_CFG_MAP_23r_SERDES_CONFIG_ID_23f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_ID_23f_GET
#define SERDES_CFG_MAP_23r_SERDES_CONFIG_ID_23f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r_SERDES_CONFIG_ID_23f_SET
#define READ_SERDES_CFG_MAP_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_23r
#define WRITE_SERDES_CFG_MAP_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_23r
#define MODIFY_SERDES_CFG_MAP_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_24
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9068
 * DESC:     Serdes Config Map 24
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_24 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_24 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_24      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r (0x00109068 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_24.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_24[1];
	uint32_t _serdes_cfg_map_24;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_CLR(r) (r).serdes_cfg_map_24[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SET(r,d) (r).serdes_cfg_map_24[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_GET(r) (r).serdes_cfg_map_24[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SPEED_ID_24f_GET(r) ((((r).serdes_cfg_map_24[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SPEED_ID_24f_SET(r,f) (r).serdes_cfg_map_24[0]=(((r).serdes_cfg_map_24[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_O_OR_C_24f_GET(r) ((((r).serdes_cfg_map_24[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_O_OR_C_24f_SET(r,f) (r).serdes_cfg_map_24[0]=(((r).serdes_cfg_map_24[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_ID_24f_GET(r) (((r).serdes_cfg_map_24[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_ID_24f_SET(r,f) (r).serdes_cfg_map_24[0]=(((r).serdes_cfg_map_24[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_24.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_24r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r,(_r._serdes_cfg_map_24))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_24r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r,(_r._serdes_cfg_map_24)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_24r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r,(_r._serdes_cfg_map_24))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_24r BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r
#define SERDES_CFG_MAP_24r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_t SERDES_CFG_MAP_24r_t;
#define SERDES_CFG_MAP_24r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_CLR
#define SERDES_CFG_MAP_24r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SET
#define SERDES_CFG_MAP_24r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_GET
#define SERDES_CFG_MAP_24r_SPEED_ID_24f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SPEED_ID_24f_GET
#define SERDES_CFG_MAP_24r_SPEED_ID_24f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SPEED_ID_24f_SET
#define SERDES_CFG_MAP_24r_SERDES_CONFIG_O_OR_C_24f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_O_OR_C_24f_GET
#define SERDES_CFG_MAP_24r_SERDES_CONFIG_O_OR_C_24f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_O_OR_C_24f_SET
#define SERDES_CFG_MAP_24r_SERDES_CONFIG_ID_24f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_ID_24f_GET
#define SERDES_CFG_MAP_24r_SERDES_CONFIG_ID_24f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r_SERDES_CONFIG_ID_24f_SET
#define READ_SERDES_CFG_MAP_24r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_24r
#define WRITE_SERDES_CFG_MAP_24r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_24r
#define MODIFY_SERDES_CFG_MAP_24r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_24r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_25
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x9069
 * DESC:     Serdes Config Map 25
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_25 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_25 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_25      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r (0x00109069 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_25.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_25[1];
	uint32_t _serdes_cfg_map_25;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_CLR(r) (r).serdes_cfg_map_25[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SET(r,d) (r).serdes_cfg_map_25[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_GET(r) (r).serdes_cfg_map_25[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SPEED_ID_25f_GET(r) ((((r).serdes_cfg_map_25[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SPEED_ID_25f_SET(r,f) (r).serdes_cfg_map_25[0]=(((r).serdes_cfg_map_25[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_O_OR_C_25f_GET(r) ((((r).serdes_cfg_map_25[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_O_OR_C_25f_SET(r,f) (r).serdes_cfg_map_25[0]=(((r).serdes_cfg_map_25[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_ID_25f_GET(r) (((r).serdes_cfg_map_25[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_ID_25f_SET(r,f) (r).serdes_cfg_map_25[0]=(((r).serdes_cfg_map_25[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_25.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_25r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r,(_r._serdes_cfg_map_25))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_25r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r,(_r._serdes_cfg_map_25)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_25r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r,(_r._serdes_cfg_map_25))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_25r BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r
#define SERDES_CFG_MAP_25r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_t SERDES_CFG_MAP_25r_t;
#define SERDES_CFG_MAP_25r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_CLR
#define SERDES_CFG_MAP_25r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SET
#define SERDES_CFG_MAP_25r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_GET
#define SERDES_CFG_MAP_25r_SPEED_ID_25f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SPEED_ID_25f_GET
#define SERDES_CFG_MAP_25r_SPEED_ID_25f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SPEED_ID_25f_SET
#define SERDES_CFG_MAP_25r_SERDES_CONFIG_O_OR_C_25f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_O_OR_C_25f_GET
#define SERDES_CFG_MAP_25r_SERDES_CONFIG_O_OR_C_25f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_O_OR_C_25f_SET
#define SERDES_CFG_MAP_25r_SERDES_CONFIG_ID_25f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_ID_25f_GET
#define SERDES_CFG_MAP_25r_SERDES_CONFIG_ID_25f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r_SERDES_CONFIG_ID_25f_SET
#define READ_SERDES_CFG_MAP_25r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_25r
#define WRITE_SERDES_CFG_MAP_25r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_25r
#define MODIFY_SERDES_CFG_MAP_25r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_25r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_25r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_26
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x906a
 * DESC:     Serdes Config Map 26
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_26 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_26 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_26      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r (0x0010906a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_26.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_26[1];
	uint32_t _serdes_cfg_map_26;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_CLR(r) (r).serdes_cfg_map_26[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SET(r,d) (r).serdes_cfg_map_26[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_GET(r) (r).serdes_cfg_map_26[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SPEED_ID_26f_GET(r) ((((r).serdes_cfg_map_26[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SPEED_ID_26f_SET(r,f) (r).serdes_cfg_map_26[0]=(((r).serdes_cfg_map_26[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_O_OR_C_26f_GET(r) ((((r).serdes_cfg_map_26[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_O_OR_C_26f_SET(r,f) (r).serdes_cfg_map_26[0]=(((r).serdes_cfg_map_26[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_ID_26f_GET(r) (((r).serdes_cfg_map_26[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_ID_26f_SET(r,f) (r).serdes_cfg_map_26[0]=(((r).serdes_cfg_map_26[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_26.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_26r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r,(_r._serdes_cfg_map_26))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_26r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r,(_r._serdes_cfg_map_26)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_26r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r,(_r._serdes_cfg_map_26))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_26r BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r
#define SERDES_CFG_MAP_26r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_t SERDES_CFG_MAP_26r_t;
#define SERDES_CFG_MAP_26r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_CLR
#define SERDES_CFG_MAP_26r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SET
#define SERDES_CFG_MAP_26r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_GET
#define SERDES_CFG_MAP_26r_SPEED_ID_26f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SPEED_ID_26f_GET
#define SERDES_CFG_MAP_26r_SPEED_ID_26f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SPEED_ID_26f_SET
#define SERDES_CFG_MAP_26r_SERDES_CONFIG_O_OR_C_26f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_O_OR_C_26f_GET
#define SERDES_CFG_MAP_26r_SERDES_CONFIG_O_OR_C_26f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_O_OR_C_26f_SET
#define SERDES_CFG_MAP_26r_SERDES_CONFIG_ID_26f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_ID_26f_GET
#define SERDES_CFG_MAP_26r_SERDES_CONFIG_ID_26f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r_SERDES_CONFIG_ID_26f_SET
#define READ_SERDES_CFG_MAP_26r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_26r
#define WRITE_SERDES_CFG_MAP_26r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_26r
#define MODIFY_SERDES_CFG_MAP_26r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_26r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_26r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_27
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x906b
 * DESC:     Serdes Config Map 27
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_27 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_27 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_27      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r (0x0010906b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_27.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_27[1];
	uint32_t _serdes_cfg_map_27;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_CLR(r) (r).serdes_cfg_map_27[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SET(r,d) (r).serdes_cfg_map_27[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_GET(r) (r).serdes_cfg_map_27[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SPEED_ID_27f_GET(r) ((((r).serdes_cfg_map_27[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SPEED_ID_27f_SET(r,f) (r).serdes_cfg_map_27[0]=(((r).serdes_cfg_map_27[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_O_OR_C_27f_GET(r) ((((r).serdes_cfg_map_27[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_O_OR_C_27f_SET(r,f) (r).serdes_cfg_map_27[0]=(((r).serdes_cfg_map_27[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_ID_27f_GET(r) (((r).serdes_cfg_map_27[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_ID_27f_SET(r,f) (r).serdes_cfg_map_27[0]=(((r).serdes_cfg_map_27[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_27.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_27r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r,(_r._serdes_cfg_map_27))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_27r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r,(_r._serdes_cfg_map_27)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_27r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r,(_r._serdes_cfg_map_27))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_27r BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r
#define SERDES_CFG_MAP_27r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_t SERDES_CFG_MAP_27r_t;
#define SERDES_CFG_MAP_27r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_CLR
#define SERDES_CFG_MAP_27r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SET
#define SERDES_CFG_MAP_27r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_GET
#define SERDES_CFG_MAP_27r_SPEED_ID_27f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SPEED_ID_27f_GET
#define SERDES_CFG_MAP_27r_SPEED_ID_27f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SPEED_ID_27f_SET
#define SERDES_CFG_MAP_27r_SERDES_CONFIG_O_OR_C_27f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_O_OR_C_27f_GET
#define SERDES_CFG_MAP_27r_SERDES_CONFIG_O_OR_C_27f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_O_OR_C_27f_SET
#define SERDES_CFG_MAP_27r_SERDES_CONFIG_ID_27f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_ID_27f_GET
#define SERDES_CFG_MAP_27r_SERDES_CONFIG_ID_27f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r_SERDES_CONFIG_ID_27f_SET
#define READ_SERDES_CFG_MAP_27r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_27r
#define WRITE_SERDES_CFG_MAP_27r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_27r
#define MODIFY_SERDES_CFG_MAP_27r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_27r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_27r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_28
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x906c
 * DESC:     Serdes Config Map 28
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_28 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_28 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_28      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r (0x0010906c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_28.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_28[1];
	uint32_t _serdes_cfg_map_28;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_CLR(r) (r).serdes_cfg_map_28[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SET(r,d) (r).serdes_cfg_map_28[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_GET(r) (r).serdes_cfg_map_28[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SPEED_ID_28f_GET(r) ((((r).serdes_cfg_map_28[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SPEED_ID_28f_SET(r,f) (r).serdes_cfg_map_28[0]=(((r).serdes_cfg_map_28[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_O_OR_C_28f_GET(r) ((((r).serdes_cfg_map_28[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_O_OR_C_28f_SET(r,f) (r).serdes_cfg_map_28[0]=(((r).serdes_cfg_map_28[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_ID_28f_GET(r) (((r).serdes_cfg_map_28[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_ID_28f_SET(r,f) (r).serdes_cfg_map_28[0]=(((r).serdes_cfg_map_28[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_28.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_28r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r,(_r._serdes_cfg_map_28))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_28r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r,(_r._serdes_cfg_map_28)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_28r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r,(_r._serdes_cfg_map_28))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_28r BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r
#define SERDES_CFG_MAP_28r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_t SERDES_CFG_MAP_28r_t;
#define SERDES_CFG_MAP_28r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_CLR
#define SERDES_CFG_MAP_28r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SET
#define SERDES_CFG_MAP_28r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_GET
#define SERDES_CFG_MAP_28r_SPEED_ID_28f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SPEED_ID_28f_GET
#define SERDES_CFG_MAP_28r_SPEED_ID_28f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SPEED_ID_28f_SET
#define SERDES_CFG_MAP_28r_SERDES_CONFIG_O_OR_C_28f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_O_OR_C_28f_GET
#define SERDES_CFG_MAP_28r_SERDES_CONFIG_O_OR_C_28f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_O_OR_C_28f_SET
#define SERDES_CFG_MAP_28r_SERDES_CONFIG_ID_28f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_ID_28f_GET
#define SERDES_CFG_MAP_28r_SERDES_CONFIG_ID_28f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r_SERDES_CONFIG_ID_28f_SET
#define READ_SERDES_CFG_MAP_28r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_28r
#define WRITE_SERDES_CFG_MAP_28r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_28r
#define MODIFY_SERDES_CFG_MAP_28r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_28r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_29
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x906d
 * DESC:     Serdes Config Map 29
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_29 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_29 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_29      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r (0x0010906d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_29.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_29[1];
	uint32_t _serdes_cfg_map_29;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_CLR(r) (r).serdes_cfg_map_29[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SET(r,d) (r).serdes_cfg_map_29[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_GET(r) (r).serdes_cfg_map_29[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SPEED_ID_29f_GET(r) ((((r).serdes_cfg_map_29[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SPEED_ID_29f_SET(r,f) (r).serdes_cfg_map_29[0]=(((r).serdes_cfg_map_29[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_O_OR_C_29f_GET(r) ((((r).serdes_cfg_map_29[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_O_OR_C_29f_SET(r,f) (r).serdes_cfg_map_29[0]=(((r).serdes_cfg_map_29[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_ID_29f_GET(r) (((r).serdes_cfg_map_29[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_ID_29f_SET(r,f) (r).serdes_cfg_map_29[0]=(((r).serdes_cfg_map_29[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_29.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_29r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r,(_r._serdes_cfg_map_29))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_29r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r,(_r._serdes_cfg_map_29)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_29r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r,(_r._serdes_cfg_map_29))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_29r BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r
#define SERDES_CFG_MAP_29r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_t SERDES_CFG_MAP_29r_t;
#define SERDES_CFG_MAP_29r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_CLR
#define SERDES_CFG_MAP_29r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SET
#define SERDES_CFG_MAP_29r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_GET
#define SERDES_CFG_MAP_29r_SPEED_ID_29f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SPEED_ID_29f_GET
#define SERDES_CFG_MAP_29r_SPEED_ID_29f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SPEED_ID_29f_SET
#define SERDES_CFG_MAP_29r_SERDES_CONFIG_O_OR_C_29f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_O_OR_C_29f_GET
#define SERDES_CFG_MAP_29r_SERDES_CONFIG_O_OR_C_29f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_O_OR_C_29f_SET
#define SERDES_CFG_MAP_29r_SERDES_CONFIG_ID_29f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_ID_29f_GET
#define SERDES_CFG_MAP_29r_SERDES_CONFIG_ID_29f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r_SERDES_CONFIG_ID_29f_SET
#define READ_SERDES_CFG_MAP_29r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_29r
#define WRITE_SERDES_CFG_MAP_29r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_29r
#define MODIFY_SERDES_CFG_MAP_29r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_29r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_29r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_30
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x906e
 * DESC:     Serdes Config Map 30
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_30 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_30 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_30      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r (0x0010906e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_30.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_30[1];
	uint32_t _serdes_cfg_map_30;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_CLR(r) (r).serdes_cfg_map_30[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SET(r,d) (r).serdes_cfg_map_30[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_GET(r) (r).serdes_cfg_map_30[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SPEED_ID_30f_GET(r) ((((r).serdes_cfg_map_30[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SPEED_ID_30f_SET(r,f) (r).serdes_cfg_map_30[0]=(((r).serdes_cfg_map_30[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_O_OR_C_30f_GET(r) ((((r).serdes_cfg_map_30[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_O_OR_C_30f_SET(r,f) (r).serdes_cfg_map_30[0]=(((r).serdes_cfg_map_30[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_ID_30f_GET(r) (((r).serdes_cfg_map_30[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_ID_30f_SET(r,f) (r).serdes_cfg_map_30[0]=(((r).serdes_cfg_map_30[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_30.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_30r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r,(_r._serdes_cfg_map_30))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_30r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r,(_r._serdes_cfg_map_30)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_30r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r,(_r._serdes_cfg_map_30))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_30r BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r
#define SERDES_CFG_MAP_30r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_t SERDES_CFG_MAP_30r_t;
#define SERDES_CFG_MAP_30r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_CLR
#define SERDES_CFG_MAP_30r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SET
#define SERDES_CFG_MAP_30r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_GET
#define SERDES_CFG_MAP_30r_SPEED_ID_30f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SPEED_ID_30f_GET
#define SERDES_CFG_MAP_30r_SPEED_ID_30f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SPEED_ID_30f_SET
#define SERDES_CFG_MAP_30r_SERDES_CONFIG_O_OR_C_30f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_O_OR_C_30f_GET
#define SERDES_CFG_MAP_30r_SERDES_CONFIG_O_OR_C_30f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_O_OR_C_30f_SET
#define SERDES_CFG_MAP_30r_SERDES_CONFIG_ID_30f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_ID_30f_GET
#define SERDES_CFG_MAP_30r_SERDES_CONFIG_ID_30f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r_SERDES_CONFIG_ID_30f_SET
#define READ_SERDES_CFG_MAP_30r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_30r
#define WRITE_SERDES_CFG_MAP_30r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_30r
#define MODIFY_SERDES_CFG_MAP_30r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_30r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_30r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_MAP_31
 * BLOCKS:   SERDESCFGMAP1
 * REGADDR:  0x906f
 * DESC:     Serdes Config Map 31
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SERDES_CONFIG_ID_31 0: Pick appropriate D5 Serdes config from the 10 standard D5 Serdes config for the above AN speed or fixed speed.Per lane control
 *     SERDES_CONFIG_O_OR_C_31 0: Media is Back Plane Copper.1: Media is Optical Channel.
 *     SPEED_ID_31      Specifies speed selected, there are total of 64 speeds (Could be from Negotiated speed or fixed speed)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r (0x0010906f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_MAP_31.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_map_31[1];
	uint32_t _serdes_cfg_map_31;
} BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_CLR(r) (r).serdes_cfg_map_31[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SET(r,d) (r).serdes_cfg_map_31[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_GET(r) (r).serdes_cfg_map_31[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SPEED_ID_31f_GET(r) ((((r).serdes_cfg_map_31[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SPEED_ID_31f_SET(r,f) (r).serdes_cfg_map_31[0]=(((r).serdes_cfg_map_31[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_O_OR_C_31f_GET(r) ((((r).serdes_cfg_map_31[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_O_OR_C_31f_SET(r,f) (r).serdes_cfg_map_31[0]=(((r).serdes_cfg_map_31[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_ID_31f_GET(r) (((r).serdes_cfg_map_31[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_ID_31f_SET(r,f) (r).serdes_cfg_map_31[0]=(((r).serdes_cfg_map_31[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_MAP_31.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_31r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r,(_r._serdes_cfg_map_31))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_31r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r,(_r._serdes_cfg_map_31)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_31r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r,(_r._serdes_cfg_map_31))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_MAP_31r BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r
#define SERDES_CFG_MAP_31r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_t SERDES_CFG_MAP_31r_t;
#define SERDES_CFG_MAP_31r_CLR BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_CLR
#define SERDES_CFG_MAP_31r_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SET
#define SERDES_CFG_MAP_31r_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_GET
#define SERDES_CFG_MAP_31r_SPEED_ID_31f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SPEED_ID_31f_GET
#define SERDES_CFG_MAP_31r_SPEED_ID_31f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SPEED_ID_31f_SET
#define SERDES_CFG_MAP_31r_SERDES_CONFIG_O_OR_C_31f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_O_OR_C_31f_GET
#define SERDES_CFG_MAP_31r_SERDES_CONFIG_O_OR_C_31f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_O_OR_C_31f_SET
#define SERDES_CFG_MAP_31r_SERDES_CONFIG_ID_31f_GET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_ID_31f_GET
#define SERDES_CFG_MAP_31r_SERDES_CONFIG_ID_31f_SET BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r_SERDES_CONFIG_ID_31f_SET
#define READ_SERDES_CFG_MAP_31r BCMI_TSCD_XGXS_READ_SERDES_CFG_MAP_31r
#define WRITE_SERDES_CFG_MAP_31r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_MAP_31r
#define MODIFY_SERDES_CFG_MAP_31r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_MAP_31r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_MAP_31r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_AM_TMR
 * BLOCKS:   CL82_SHARED
 * REGADDR:  0x9123
 * DESC:     cl82 AM timer register
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_TIMER_INIT_VAL Alignment marker initial timer valueUsed by both the TX and RX pipelines
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_AM_TMRr (0x00109123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_AM_TMRr_SIZE 4

/*
 * This structure should be used to declare and program CL82_AM_TMR.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_AM_TMRr_s {
	uint32_t v[1];
	uint32_t cl82_am_tmr[1];
	uint32_t _cl82_am_tmr;
} BCMI_TSCD_XGXS_CL82_AM_TMRr_t;

#define BCMI_TSCD_XGXS_CL82_AM_TMRr_CLR(r) (r).cl82_am_tmr[0] = 0
#define BCMI_TSCD_XGXS_CL82_AM_TMRr_SET(r,d) (r).cl82_am_tmr[0] = d
#define BCMI_TSCD_XGXS_CL82_AM_TMRr_GET(r) (r).cl82_am_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_AM_TMRr_AM_TIMER_INIT_VALf_GET(r) (((r).cl82_am_tmr[0]) & 0xffff)
#define BCMI_TSCD_XGXS_CL82_AM_TMRr_AM_TIMER_INIT_VALf_SET(r,f) (r).cl82_am_tmr[0]=(((r).cl82_am_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_AM_TMR.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_AM_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_AM_TMRr,(_r._cl82_am_tmr))
#define BCMI_TSCD_XGXS_WRITE_CL82_AM_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_AM_TMRr,(_r._cl82_am_tmr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_AM_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_AM_TMRr,(_r._cl82_am_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_AM_TMRr BCMI_TSCD_XGXS_CL82_AM_TMRr
#define CL82_AM_TMRr_SIZE BCMI_TSCD_XGXS_CL82_AM_TMRr_SIZE
typedef BCMI_TSCD_XGXS_CL82_AM_TMRr_t CL82_AM_TMRr_t;
#define CL82_AM_TMRr_CLR BCMI_TSCD_XGXS_CL82_AM_TMRr_CLR
#define CL82_AM_TMRr_SET BCMI_TSCD_XGXS_CL82_AM_TMRr_SET
#define CL82_AM_TMRr_GET BCMI_TSCD_XGXS_CL82_AM_TMRr_GET
#define CL82_AM_TMRr_AM_TIMER_INIT_VALf_GET BCMI_TSCD_XGXS_CL82_AM_TMRr_AM_TIMER_INIT_VALf_GET
#define CL82_AM_TMRr_AM_TIMER_INIT_VALf_SET BCMI_TSCD_XGXS_CL82_AM_TMRr_AM_TIMER_INIT_VALf_SET
#define READ_CL82_AM_TMRr BCMI_TSCD_XGXS_READ_CL82_AM_TMRr
#define WRITE_CL82_AM_TMRr BCMI_TSCD_XGXS_WRITE_CL82_AM_TMRr
#define MODIFY_CL82_AM_TMRr BCMI_TSCD_XGXS_MODIFY_CL82_AM_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_AM_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_LN_0_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9130
 * DESC:     cl82 LANE 0 AM BYTES 1 AND 0 register
 * RESETVAL: 0x7690 (30352)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_0_AM_1_0    MLD Alignment Market Bytes 1 and 0 for LANE 0.  Used in MLD20G and MLD120G modes only
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r (0x00109130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LN_0_AM_BYTE10.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_ln_0_am_byte10[1];
	uint32_t _cl82_ln_0_am_byte10;
} BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_t;

#define BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_CLR(r) (r).cl82_ln_0_am_byte10[0] = 0
#define BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_SET(r,d) (r).cl82_ln_0_am_byte10[0] = d
#define BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_GET(r) (r).cl82_ln_0_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_GET(r) (((r).cl82_ln_0_am_byte10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_SET(r,f) (r).cl82_ln_0_am_byte10[0]=(((r).cl82_ln_0_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_LN_0_AM_BYTE10.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_LN_0_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r,(_r._cl82_ln_0_am_byte10))
#define BCMI_TSCD_XGXS_WRITE_CL82_LN_0_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r,(_r._cl82_ln_0_am_byte10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_LN_0_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r,(_r._cl82_ln_0_am_byte10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_LN_0_AM_BYTE10r BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r
#define CL82_LN_0_AM_BYTE10r_SIZE BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_SIZE
typedef BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_t CL82_LN_0_AM_BYTE10r_t;
#define CL82_LN_0_AM_BYTE10r_CLR BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_CLR
#define CL82_LN_0_AM_BYTE10r_SET BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_SET
#define CL82_LN_0_AM_BYTE10r_GET BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_GET
#define CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_GET BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_GET
#define CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_SET BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r_LANE_0_AM_1_0f_SET
#define READ_CL82_LN_0_AM_BYTE10r BCMI_TSCD_XGXS_READ_CL82_LN_0_AM_BYTE10r
#define WRITE_CL82_LN_0_AM_BYTE10r BCMI_TSCD_XGXS_WRITE_CL82_LN_0_AM_BYTE10r
#define MODIFY_CL82_LN_0_AM_BYTE10r BCMI_TSCD_XGXS_MODIFY_CL82_LN_0_AM_BYTE10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_LN_0_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_LN_1_AM_BYTE10
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9131
 * DESC:     cl82 LANE 1 AM BYTES 1 AND 0 register
 * RESETVAL: 0xc4f0 (50416)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_1_AM_1_0    MLD Alignment Market Bytes 1 and 0 for LANE 1.  Used in MLD20G and MLD120G modes only
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r (0x00109131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LN_1_AM_BYTE10.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_s {
	uint32_t v[1];
	uint32_t cl82_ln_1_am_byte10[1];
	uint32_t _cl82_ln_1_am_byte10;
} BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_t;

#define BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_CLR(r) (r).cl82_ln_1_am_byte10[0] = 0
#define BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_SET(r,d) (r).cl82_ln_1_am_byte10[0] = d
#define BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_GET(r) (r).cl82_ln_1_am_byte10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_GET(r) (((r).cl82_ln_1_am_byte10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_SET(r,f) (r).cl82_ln_1_am_byte10[0]=(((r).cl82_ln_1_am_byte10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL82_LN_1_AM_BYTE10.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_LN_1_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r,(_r._cl82_ln_1_am_byte10))
#define BCMI_TSCD_XGXS_WRITE_CL82_LN_1_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r,(_r._cl82_ln_1_am_byte10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_LN_1_AM_BYTE10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r,(_r._cl82_ln_1_am_byte10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_LN_1_AM_BYTE10r BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r
#define CL82_LN_1_AM_BYTE10r_SIZE BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_SIZE
typedef BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_t CL82_LN_1_AM_BYTE10r_t;
#define CL82_LN_1_AM_BYTE10r_CLR BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_CLR
#define CL82_LN_1_AM_BYTE10r_SET BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_SET
#define CL82_LN_1_AM_BYTE10r_GET BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_GET
#define CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_GET BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_GET
#define CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_SET BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r_LANE_1_AM_1_0f_SET
#define READ_CL82_LN_1_AM_BYTE10r BCMI_TSCD_XGXS_READ_CL82_LN_1_AM_BYTE10r
#define WRITE_CL82_LN_1_AM_BYTE10r BCMI_TSCD_XGXS_WRITE_CL82_LN_1_AM_BYTE10r
#define MODIFY_CL82_LN_1_AM_BYTE10r BCMI_TSCD_XGXS_MODIFY_CL82_LN_1_AM_BYTE10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_LN_1_AM_BYTE10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_LANES_1_0_AM_BYTE2
 * BLOCKS:   CL82_AM_REGS
 * REGADDR:  0x9132
 * DESC:     cl82 LANES 1 and 0 AM BYTE 2 register
 * RESETVAL: 0xe647 (58951)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_0_AM_2      MLD Alignment Market Byte 2 for LANE 0.  Used in MLD20G and MLD120G modes only
 *     LANE_1_AM_2      MLD Alignment Market Byte 2 for LANE 1.  Used in MLD20G and MLD120G modes only
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r (0x00109132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_SIZE 4

/*
 * This structure should be used to declare and program CL82_LANES_1_0_AM_BYTE2.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_s {
	uint32_t v[1];
	uint32_t cl82_lanes_1_0_am_byte2[1];
	uint32_t _cl82_lanes_1_0_am_byte2;
} BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_t;

#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_CLR(r) (r).cl82_lanes_1_0_am_byte2[0] = 0
#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_SET(r,d) (r).cl82_lanes_1_0_am_byte2[0] = d
#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_GET(r) (r).cl82_lanes_1_0_am_byte2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_GET(r) ((((r).cl82_lanes_1_0_am_byte2[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_SET(r,f) (r).cl82_lanes_1_0_am_byte2[0]=(((r).cl82_lanes_1_0_am_byte2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_GET(r) (((r).cl82_lanes_1_0_am_byte2[0]) & 0xff)
#define BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_SET(r,f) (r).cl82_lanes_1_0_am_byte2[0]=(((r).cl82_lanes_1_0_am_byte2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access CL82_LANES_1_0_AM_BYTE2.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2))
#define BCMI_TSCD_XGXS_WRITE_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_LANES_1_0_AM_BYTE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r,(_r._cl82_lanes_1_0_am_byte2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_LANES_1_0_AM_BYTE2r BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r
#define CL82_LANES_1_0_AM_BYTE2r_SIZE BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_SIZE
typedef BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_t CL82_LANES_1_0_AM_BYTE2r_t;
#define CL82_LANES_1_0_AM_BYTE2r_CLR BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_CLR
#define CL82_LANES_1_0_AM_BYTE2r_SET BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_SET
#define CL82_LANES_1_0_AM_BYTE2r_GET BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_GET BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_SET BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_1_AM_2f_SET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_GET BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_GET
#define CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_SET BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r_LANE_0_AM_2f_SET
#define READ_CL82_LANES_1_0_AM_BYTE2r BCMI_TSCD_XGXS_READ_CL82_LANES_1_0_AM_BYTE2r
#define WRITE_CL82_LANES_1_0_AM_BYTE2r BCMI_TSCD_XGXS_WRITE_CL82_LANES_1_0_AM_BYTE2r
#define MODIFY_CL82_LANES_1_0_AM_BYTE2r BCMI_TSCD_XGXS_MODIFY_CL82_LANES_1_0_AM_BYTE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_LANES_1_0_AM_BYTE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_TX_LN_SWP
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9200
 * DESC:     TX lane swap register
 * RESETVAL: 0xe4 (228)
 * ACCESS:   R/W
 * FIELDS:
 *     LOGICAL0_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical0_to_phy_sel indicates for LOGICAL lane 0 which lane to PHYSICAL send the data to
 *     LOGICAL1_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical1_to_phy_sel indicates for LOGICAL lane 1 which lane to PHYSICAL send the data to
 *     LOGICAL2_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical2_to_phy_sel indicates for LOGICAL lane 2 which lane to PHYSICAL send the data to
 *     LOGICAL3_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical3_to_phy_sel indicates for LOGICAL lane 3 which lane to PHYSICAL send the data to
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr (0x00109200 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TX_LN_SWP.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_s {
	uint32_t v[1];
	uint32_t tx_x1_tx_ln_swp[1];
	uint32_t _tx_x1_tx_ln_swp;
} BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_t;

#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_CLR(r) (r).tx_x1_tx_ln_swp[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_SET(r,d) (r).tx_x1_tx_ln_swp[0] = d
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_GET(r) (r).tx_x1_tx_ln_swp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL3_TO_PHY_SELf_GET(r) ((((r).tx_x1_tx_ln_swp[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL3_TO_PHY_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL2_TO_PHY_SELf_GET(r) ((((r).tx_x1_tx_ln_swp[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL2_TO_PHY_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL1_TO_PHY_SELf_GET(r) ((((r).tx_x1_tx_ln_swp[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL1_TO_PHY_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL0_TO_PHY_SELf_GET(r) (((r).tx_x1_tx_ln_swp[0]) & 0x3)
#define BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL0_TO_PHY_SELf_SET(r,f) (r).tx_x1_tx_ln_swp[0]=(((r).tx_x1_tx_ln_swp[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TX_X1_TX_LN_SWP.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_TX_LN_SWPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr,(_r._tx_x1_tx_ln_swp))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_TX_LN_SWPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr,(_r._tx_x1_tx_ln_swp)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_TX_LN_SWPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr,(_r._tx_x1_tx_ln_swp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TX_LN_SWPr BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr
#define TX_X1_TX_LN_SWPr_SIZE BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_t TX_X1_TX_LN_SWPr_t;
#define TX_X1_TX_LN_SWPr_CLR BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_CLR
#define TX_X1_TX_LN_SWPr_SET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_SET
#define TX_X1_TX_LN_SWPr_GET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_GET
#define TX_X1_TX_LN_SWPr_LOGICAL3_TO_PHY_SELf_GET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL3_TO_PHY_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL3_TO_PHY_SELf_SET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL3_TO_PHY_SELf_SET
#define TX_X1_TX_LN_SWPr_LOGICAL2_TO_PHY_SELf_GET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL2_TO_PHY_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL2_TO_PHY_SELf_SET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL2_TO_PHY_SELf_SET
#define TX_X1_TX_LN_SWPr_LOGICAL1_TO_PHY_SELf_GET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL1_TO_PHY_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL1_TO_PHY_SELf_SET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL1_TO_PHY_SELf_SET
#define TX_X1_TX_LN_SWPr_LOGICAL0_TO_PHY_SELf_GET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL0_TO_PHY_SELf_GET
#define TX_X1_TX_LN_SWPr_LOGICAL0_TO_PHY_SELf_SET BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr_LOGICAL0_TO_PHY_SELf_SET
#define READ_TX_X1_TX_LN_SWPr BCMI_TSCD_XGXS_READ_TX_X1_TX_LN_SWPr
#define WRITE_TX_X1_TX_LN_SWPr BCMI_TSCD_XGXS_WRITE_TX_X1_TX_LN_SWPr
#define MODIFY_TX_X1_TX_LN_SWPr BCMI_TSCD_XGXS_MODIFY_TX_X1_TX_LN_SWPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_TX_LN_SWPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_TS_DBG_WORD2_VALUE
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9201
 * DESC:     TS Debug High register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TS_DBG_VAL_WORD2 Not supported in TSCF Gen3.Bits 47:32 of the timestamp value used for UDP checksum and Correction Field updates in One-step timestamping packets.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr (0x00109201 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TS_DBG_WORD2_VALUE.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_s {
	uint32_t v[1];
	uint32_t tx_x1_ts_dbg_word2_value[1];
	uint32_t _tx_x1_ts_dbg_word2_value;
} BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_t;

#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_CLR(r) (r).tx_x1_ts_dbg_word2_value[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_SET(r,d) (r).tx_x1_ts_dbg_word2_value[0] = d
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_GET(r) (r).tx_x1_ts_dbg_word2_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_TS_DBG_VAL_WORD2f_GET(r) (((r).tx_x1_ts_dbg_word2_value[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_TS_DBG_VAL_WORD2f_SET(r,f) (r).tx_x1_ts_dbg_word2_value[0]=(((r).tx_x1_ts_dbg_word2_value[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_TS_DBG_WORD2_VALUE.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_TS_DBG_WORD2_VALUEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr,(_r._tx_x1_ts_dbg_word2_value))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_TS_DBG_WORD2_VALUEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr,(_r._tx_x1_ts_dbg_word2_value)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_TS_DBG_WORD2_VALUEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr,(_r._tx_x1_ts_dbg_word2_value))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TS_DBG_WORD2_VALUEr BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr
#define TX_X1_TS_DBG_WORD2_VALUEr_SIZE BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_t TX_X1_TS_DBG_WORD2_VALUEr_t;
#define TX_X1_TS_DBG_WORD2_VALUEr_CLR BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_CLR
#define TX_X1_TS_DBG_WORD2_VALUEr_SET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_SET
#define TX_X1_TS_DBG_WORD2_VALUEr_GET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_GET
#define TX_X1_TS_DBG_WORD2_VALUEr_TS_DBG_VAL_WORD2f_GET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_TS_DBG_VAL_WORD2f_GET
#define TX_X1_TS_DBG_WORD2_VALUEr_TS_DBG_VAL_WORD2f_SET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr_TS_DBG_VAL_WORD2f_SET
#define READ_TX_X1_TS_DBG_WORD2_VALUEr BCMI_TSCD_XGXS_READ_TX_X1_TS_DBG_WORD2_VALUEr
#define WRITE_TX_X1_TS_DBG_WORD2_VALUEr BCMI_TSCD_XGXS_WRITE_TX_X1_TS_DBG_WORD2_VALUEr
#define MODIFY_TX_X1_TS_DBG_WORD2_VALUEr BCMI_TSCD_XGXS_MODIFY_TX_X1_TS_DBG_WORD2_VALUEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD2_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_TS_DBG_WORD1_VALUE
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9202
 * DESC:     TS Debug Int register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TS_DBG_VAL_WORD1 Not supported in TSCF Gen3.Bits 31:16 of the timestamp value used for UDP checksum and Correction Field updates in One-step timestamping packets.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr (0x00109202 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TS_DBG_WORD1_VALUE.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_s {
	uint32_t v[1];
	uint32_t tx_x1_ts_dbg_word1_value[1];
	uint32_t _tx_x1_ts_dbg_word1_value;
} BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_t;

#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_CLR(r) (r).tx_x1_ts_dbg_word1_value[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_SET(r,d) (r).tx_x1_ts_dbg_word1_value[0] = d
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_GET(r) (r).tx_x1_ts_dbg_word1_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_TS_DBG_VAL_WORD1f_GET(r) (((r).tx_x1_ts_dbg_word1_value[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_TS_DBG_VAL_WORD1f_SET(r,f) (r).tx_x1_ts_dbg_word1_value[0]=(((r).tx_x1_ts_dbg_word1_value[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_TS_DBG_WORD1_VALUE.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_TS_DBG_WORD1_VALUEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr,(_r._tx_x1_ts_dbg_word1_value))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_TS_DBG_WORD1_VALUEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr,(_r._tx_x1_ts_dbg_word1_value)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_TS_DBG_WORD1_VALUEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr,(_r._tx_x1_ts_dbg_word1_value))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TS_DBG_WORD1_VALUEr BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr
#define TX_X1_TS_DBG_WORD1_VALUEr_SIZE BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_t TX_X1_TS_DBG_WORD1_VALUEr_t;
#define TX_X1_TS_DBG_WORD1_VALUEr_CLR BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_CLR
#define TX_X1_TS_DBG_WORD1_VALUEr_SET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_SET
#define TX_X1_TS_DBG_WORD1_VALUEr_GET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_GET
#define TX_X1_TS_DBG_WORD1_VALUEr_TS_DBG_VAL_WORD1f_GET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_TS_DBG_VAL_WORD1f_GET
#define TX_X1_TS_DBG_WORD1_VALUEr_TS_DBG_VAL_WORD1f_SET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr_TS_DBG_VAL_WORD1f_SET
#define READ_TX_X1_TS_DBG_WORD1_VALUEr BCMI_TSCD_XGXS_READ_TX_X1_TS_DBG_WORD1_VALUEr
#define WRITE_TX_X1_TS_DBG_WORD1_VALUEr BCMI_TSCD_XGXS_WRITE_TX_X1_TS_DBG_WORD1_VALUEr
#define MODIFY_TX_X1_TS_DBG_WORD1_VALUEr BCMI_TSCD_XGXS_MODIFY_TX_X1_TS_DBG_WORD1_VALUEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD1_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_TS_DBG_WORD0_VALUE
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9203
 * DESC:     TS Debug Low register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TS_DBG_VAL_WORD0 Not supported in TSCF Gen3.Bits 15:0 of the timestamp value used for UDP checksum and Correction Field updates in One-step timestamping packets.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr (0x00109203 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_TS_DBG_WORD0_VALUE.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_s {
	uint32_t v[1];
	uint32_t tx_x1_ts_dbg_word0_value[1];
	uint32_t _tx_x1_ts_dbg_word0_value;
} BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_t;

#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_CLR(r) (r).tx_x1_ts_dbg_word0_value[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_SET(r,d) (r).tx_x1_ts_dbg_word0_value[0] = d
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_GET(r) (r).tx_x1_ts_dbg_word0_value[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_TS_DBG_VAL_WORD0f_GET(r) (((r).tx_x1_ts_dbg_word0_value[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_TS_DBG_VAL_WORD0f_SET(r,f) (r).tx_x1_ts_dbg_word0_value[0]=(((r).tx_x1_ts_dbg_word0_value[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_TS_DBG_WORD0_VALUE.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_TS_DBG_WORD0_VALUEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr,(_r._tx_x1_ts_dbg_word0_value))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_TS_DBG_WORD0_VALUEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr,(_r._tx_x1_ts_dbg_word0_value)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_TS_DBG_WORD0_VALUEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr,(_r._tx_x1_ts_dbg_word0_value))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_TS_DBG_WORD0_VALUEr BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr
#define TX_X1_TS_DBG_WORD0_VALUEr_SIZE BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_t TX_X1_TS_DBG_WORD0_VALUEr_t;
#define TX_X1_TS_DBG_WORD0_VALUEr_CLR BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_CLR
#define TX_X1_TS_DBG_WORD0_VALUEr_SET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_SET
#define TX_X1_TS_DBG_WORD0_VALUEr_GET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_GET
#define TX_X1_TS_DBG_WORD0_VALUEr_TS_DBG_VAL_WORD0f_GET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_TS_DBG_VAL_WORD0f_GET
#define TX_X1_TS_DBG_WORD0_VALUEr_TS_DBG_VAL_WORD0f_SET BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr_TS_DBG_VAL_WORD0f_SET
#define READ_TX_X1_TS_DBG_WORD0_VALUEr BCMI_TSCD_XGXS_READ_TX_X1_TS_DBG_WORD0_VALUEr
#define WRITE_TX_X1_TS_DBG_WORD0_VALUEr BCMI_TSCD_XGXS_WRITE_TX_X1_TS_DBG_WORD0_VALUEr
#define MODIFY_TX_X1_TS_DBG_WORD0_VALUEr BCMI_TSCD_XGXS_MODIFY_TX_X1_TS_DBG_WORD0_VALUEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_TS_DBG_WORD0_VALUEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_CTL
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9204
 * DESC:     T_PMA GLAS capture control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_EN Enable capturing data,adj values from tpma glas instances as defined by the maskRising edge required to trigger capture. SW must write 1 to trigger capture, then write 0 to end capture.
 *     GLAS_TPMA_CAPTURE_MASK 1bit enable per tpma glas. Indexed in logical domain.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr (0x00109204 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_ctl[1];
	uint32_t _tx_x1_glas_tpma_ctl;
} BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_t;

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_CLR(r) (r).tx_x1_glas_tpma_ctl[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_SET(r,d) (r).tx_x1_glas_tpma_ctl[0] = d
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GET(r) (r).tx_x1_glas_tpma_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_GET(r) ((((r).tx_x1_glas_tpma_ctl[0]) >> 1) & 0xf)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_SET(r,f) (r).tx_x1_glas_tpma_ctl[0]=(((r).tx_x1_glas_tpma_ctl[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_GET(r) (((r).tx_x1_glas_tpma_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_SET(r,f) (r).tx_x1_glas_tpma_ctl[0]=(((r).tx_x1_glas_tpma_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr,(_r._tx_x1_glas_tpma_ctl))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr,(_r._tx_x1_glas_tpma_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr,(_r._tx_x1_glas_tpma_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_CTLr BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr
#define TX_X1_GLAS_TPMA_CTLr_SIZE BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_t TX_X1_GLAS_TPMA_CTLr_t;
#define TX_X1_GLAS_TPMA_CTLr_CLR BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_CLR
#define TX_X1_GLAS_TPMA_CTLr_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_SET
#define TX_X1_GLAS_TPMA_CTLr_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_GET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_MASKf_SET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_GET
#define TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr_GLAS_TPMA_CAPTURE_ENf_SET
#define READ_TX_X1_GLAS_TPMA_CTLr BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_CTLr
#define WRITE_TX_X1_GLAS_TPMA_CTLr BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_CTLr
#define MODIFY_TX_X1_GLAS_TPMA_CTLr BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA0
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9205
 * DESC:     T_PMA 0 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_0 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count of Logical lane 0.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r (0x00109205 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA0.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data0[1];
	uint32_t _tx_x1_glas_tpma_data0;
} BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_t;

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_CLR(r) (r).tx_x1_glas_tpma_data0[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_SET(r,d) (r).tx_x1_glas_tpma_data0[0] = d
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_GET(r) (r).tx_x1_glas_tpma_data0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_GET(r) (((r).tx_x1_glas_tpma_data0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_SET(r,f) (r).tx_x1_glas_tpma_data0[0]=(((r).tx_x1_glas_tpma_data0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA0.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r,(_r._tx_x1_glas_tpma_data0))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r,(_r._tx_x1_glas_tpma_data0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r,(_r._tx_x1_glas_tpma_data0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA0r BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r
#define TX_X1_GLAS_TPMA_DATA0r_SIZE BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_t TX_X1_GLAS_TPMA_DATA0r_t;
#define TX_X1_GLAS_TPMA_DATA0r_CLR BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_CLR
#define TX_X1_GLAS_TPMA_DATA0r_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_SET
#define TX_X1_GLAS_TPMA_DATA0r_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_GET
#define TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_GET
#define TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r_GLAS_TPMA_CAPTURE_DATA_0f_SET
#define READ_TX_X1_GLAS_TPMA_DATA0r BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA0r
#define WRITE_TX_X1_GLAS_TPMA_DATA0r BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA0r
#define MODIFY_TX_X1_GLAS_TPMA_DATA0r BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA1
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9206
 * DESC:     T_PMA 1 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_1 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count of Logical Lane 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r (0x00109206 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA1.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data1[1];
	uint32_t _tx_x1_glas_tpma_data1;
} BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_t;

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_CLR(r) (r).tx_x1_glas_tpma_data1[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_SET(r,d) (r).tx_x1_glas_tpma_data1[0] = d
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_GET(r) (r).tx_x1_glas_tpma_data1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_GET(r) (((r).tx_x1_glas_tpma_data1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_SET(r,f) (r).tx_x1_glas_tpma_data1[0]=(((r).tx_x1_glas_tpma_data1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA1.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r,(_r._tx_x1_glas_tpma_data1))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r,(_r._tx_x1_glas_tpma_data1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r,(_r._tx_x1_glas_tpma_data1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA1r BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r
#define TX_X1_GLAS_TPMA_DATA1r_SIZE BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_t TX_X1_GLAS_TPMA_DATA1r_t;
#define TX_X1_GLAS_TPMA_DATA1r_CLR BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_CLR
#define TX_X1_GLAS_TPMA_DATA1r_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_SET
#define TX_X1_GLAS_TPMA_DATA1r_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_GET
#define TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_GET
#define TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r_GLAS_TPMA_CAPTURE_DATA_1f_SET
#define READ_TX_X1_GLAS_TPMA_DATA1r BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA1r
#define WRITE_TX_X1_GLAS_TPMA_DATA1r BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA1r
#define MODIFY_TX_X1_GLAS_TPMA_DATA1r BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA2
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9207
 * DESC:     T_PMA 2 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_2 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count of Logical Lane 2.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r (0x00109207 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA2.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data2[1];
	uint32_t _tx_x1_glas_tpma_data2;
} BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_t;

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_CLR(r) (r).tx_x1_glas_tpma_data2[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_SET(r,d) (r).tx_x1_glas_tpma_data2[0] = d
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_GET(r) (r).tx_x1_glas_tpma_data2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_GET(r) (((r).tx_x1_glas_tpma_data2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_SET(r,f) (r).tx_x1_glas_tpma_data2[0]=(((r).tx_x1_glas_tpma_data2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA2.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r,(_r._tx_x1_glas_tpma_data2))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r,(_r._tx_x1_glas_tpma_data2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r,(_r._tx_x1_glas_tpma_data2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA2r BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r
#define TX_X1_GLAS_TPMA_DATA2r_SIZE BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_t TX_X1_GLAS_TPMA_DATA2r_t;
#define TX_X1_GLAS_TPMA_DATA2r_CLR BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_CLR
#define TX_X1_GLAS_TPMA_DATA2r_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_SET
#define TX_X1_GLAS_TPMA_DATA2r_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_GET
#define TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_GET
#define TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r_GLAS_TPMA_CAPTURE_DATA_2f_SET
#define READ_TX_X1_GLAS_TPMA_DATA2r BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA2r
#define WRITE_TX_X1_GLAS_TPMA_DATA2r BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA2r
#define MODIFY_TX_X1_GLAS_TPMA_DATA2r BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_DATA3
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9208
 * DESC:     T_PMA 3 GLAS data capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_DATA_3 TPMA GLAS data, captured for estimating TX skew between selected lanesThis quantity represents bit count of Logical Lane 3.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r (0x00109208 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_DATA3.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_data3[1];
	uint32_t _tx_x1_glas_tpma_data3;
} BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_t;

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_CLR(r) (r).tx_x1_glas_tpma_data3[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_SET(r,d) (r).tx_x1_glas_tpma_data3[0] = d
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_GET(r) (r).tx_x1_glas_tpma_data3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_GET(r) (((r).tx_x1_glas_tpma_data3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_SET(r,f) (r).tx_x1_glas_tpma_data3[0]=(((r).tx_x1_glas_tpma_data3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_DATA3.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r,(_r._tx_x1_glas_tpma_data3))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r,(_r._tx_x1_glas_tpma_data3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r,(_r._tx_x1_glas_tpma_data3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_DATA3r BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r
#define TX_X1_GLAS_TPMA_DATA3r_SIZE BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_t TX_X1_GLAS_TPMA_DATA3r_t;
#define TX_X1_GLAS_TPMA_DATA3r_CLR BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_CLR
#define TX_X1_GLAS_TPMA_DATA3r_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_SET
#define TX_X1_GLAS_TPMA_DATA3r_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_GET
#define TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_GET
#define TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r_GLAS_TPMA_CAPTURE_DATA_3f_SET
#define READ_TX_X1_GLAS_TPMA_DATA3r BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_DATA3r
#define WRITE_TX_X1_GLAS_TPMA_DATA3r BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_DATA3r
#define MODIFY_TX_X1_GLAS_TPMA_DATA3r BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_DATA3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_DATA3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_ADJ_0_1
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x9209
 * DESC:     T_PMA 0,1 GLAS adjust capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_ADJ_0 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods, of Logical Lane 0.
 *     GLAS_TPMA_CAPTURE_ADJ_1 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods, of Logical Lane 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r (0x00109209 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_ADJ_0_1.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_adj_0_1[1];
	uint32_t _tx_x1_glas_tpma_adj_0_1;
} BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_t;

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_CLR(r) (r).tx_x1_glas_tpma_adj_0_1[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SET(r,d) (r).tx_x1_glas_tpma_adj_0_1[0] = d
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GET(r) (r).tx_x1_glas_tpma_adj_0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_GET(r) ((((r).tx_x1_glas_tpma_adj_0_1[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_SET(r,f) (r).tx_x1_glas_tpma_adj_0_1[0]=(((r).tx_x1_glas_tpma_adj_0_1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_GET(r) (((r).tx_x1_glas_tpma_adj_0_1[0]) & 0xff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_SET(r,f) (r).tx_x1_glas_tpma_adj_0_1[0]=(((r).tx_x1_glas_tpma_adj_0_1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_ADJ_0_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_0_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r,(_r._tx_x1_glas_tpma_adj_0_1))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r,(_r._tx_x1_glas_tpma_adj_0_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r,(_r._tx_x1_glas_tpma_adj_0_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r
#define TX_X1_GLAS_TPMA_ADJ_0_1r_SIZE BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_t TX_X1_GLAS_TPMA_ADJ_0_1r_t;
#define TX_X1_GLAS_TPMA_ADJ_0_1r_CLR BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_CLR
#define TX_X1_GLAS_TPMA_ADJ_0_1r_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_SET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_GET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_1f_SET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_GET
#define TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r_GLAS_TPMA_CAPTURE_ADJ_0f_SET
#define READ_TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_0_1r
#define WRITE_TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_0_1r
#define MODIFY_TX_X1_GLAS_TPMA_ADJ_0_1r BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X1_GLAS_TPMA_ADJ_2_3
 * BLOCKS:   TX_X1_CONTROL0
 * REGADDR:  0x920a
 * DESC:     T_PMA 2,3 GLAS adjust capture register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     GLAS_TPMA_CAPTURE_ADJ_2 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods, of Logical Lane 2.
 *     GLAS_TPMA_CAPTURE_ADJ_3 TPMA GLAS adjust, captured for estimating TX skew between selected lanesThis quantity represents number of fclk periods, of Logical Lane 3.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r (0x0010920a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SIZE 4

/*
 * This structure should be used to declare and program TX_X1_GLAS_TPMA_ADJ_2_3.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_s {
	uint32_t v[1];
	uint32_t tx_x1_glas_tpma_adj_2_3[1];
	uint32_t _tx_x1_glas_tpma_adj_2_3;
} BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_t;

#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_CLR(r) (r).tx_x1_glas_tpma_adj_2_3[0] = 0
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SET(r,d) (r).tx_x1_glas_tpma_adj_2_3[0] = d
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GET(r) (r).tx_x1_glas_tpma_adj_2_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_GET(r) ((((r).tx_x1_glas_tpma_adj_2_3[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_SET(r,f) (r).tx_x1_glas_tpma_adj_2_3[0]=(((r).tx_x1_glas_tpma_adj_2_3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_GET(r) (((r).tx_x1_glas_tpma_adj_2_3[0]) & 0xff)
#define BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_SET(r,f) (r).tx_x1_glas_tpma_adj_2_3[0]=(((r).tx_x1_glas_tpma_adj_2_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X1_GLAS_TPMA_ADJ_2_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_2_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r,(_r._tx_x1_glas_tpma_adj_2_3))
#define BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r,(_r._tx_x1_glas_tpma_adj_2_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r,(_r._tx_x1_glas_tpma_adj_2_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r
#define TX_X1_GLAS_TPMA_ADJ_2_3r_SIZE BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SIZE
typedef BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_t TX_X1_GLAS_TPMA_ADJ_2_3r_t;
#define TX_X1_GLAS_TPMA_ADJ_2_3r_CLR BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_CLR
#define TX_X1_GLAS_TPMA_ADJ_2_3r_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_SET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_GET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_3f_SET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_GET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_GET
#define TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_SET BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r_GLAS_TPMA_CAPTURE_ADJ_2f_SET
#define READ_TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCD_XGXS_READ_TX_X1_GLAS_TPMA_ADJ_2_3r
#define WRITE_TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCD_XGXS_WRITE_TX_X1_GLAS_TPMA_ADJ_2_3r
#define MODIFY_TX_X1_GLAS_TPMA_ADJ_2_3r BCMI_TSCD_XGXS_MODIFY_TX_X1_GLAS_TPMA_ADJ_2_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X1_GLAS_TPMA_ADJ_2_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_DEC_CTL1
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9221
 * DESC:     decode_control_1 register
 * RESETVAL: 0x6140 (24896)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_BER_LIMIT   Number of Error Blocks before HI_BER is determined for CL49
 *     CL82_BER_LIMIT   Number of Error Blocks before HI_BER is determined for CL82
 *     SET_BER_WINDOW_512 Sets the BER measurement window to 512 blocks instead of the IEEE definition.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r (0x00109221 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DEC_CTL1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_s {
	uint32_t v[1];
	uint32_t rx_x1_dec_ctl1[1];
	uint32_t _rx_x1_dec_ctl1;
} BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_t;

#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CLR(r) (r).rx_x1_dec_ctl1[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SET(r,d) (r).rx_x1_dec_ctl1[0] = d
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_GET(r) (r).rx_x1_dec_ctl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_GET(r) ((((r).rx_x1_dec_ctl1[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_SET(r,f) (r).rx_x1_dec_ctl1[0]=(((r).rx_x1_dec_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_GET(r) ((((r).rx_x1_dec_ctl1[0]) >> 8) & 0x7f)
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_SET(r,f) (r).rx_x1_dec_ctl1[0]=(((r).rx_x1_dec_ctl1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_GET(r) ((((r).rx_x1_dec_ctl1[0]) >> 2) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_SET(r,f) (r).rx_x1_dec_ctl1[0]=(((r).rx_x1_dec_ctl1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))

/*
 * These macros can be used to access RX_X1_DEC_CTL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r,(_r._rx_x1_dec_ctl1))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r,(_r._rx_x1_dec_ctl1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_DEC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r,(_r._rx_x1_dec_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DEC_CTL1r BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r
#define RX_X1_DEC_CTL1r_SIZE BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_t RX_X1_DEC_CTL1r_t;
#define RX_X1_DEC_CTL1r_CLR BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CLR
#define RX_X1_DEC_CTL1r_SET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SET
#define RX_X1_DEC_CTL1r_GET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_GET
#define RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_GET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_GET
#define RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_SET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_SET_BER_WINDOW_512f_SET
#define RX_X1_DEC_CTL1r_CL82_BER_LIMITf_GET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_GET
#define RX_X1_DEC_CTL1r_CL82_BER_LIMITf_SET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL82_BER_LIMITf_SET
#define RX_X1_DEC_CTL1r_CL49_BER_LIMITf_GET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_GET
#define RX_X1_DEC_CTL1r_CL49_BER_LIMITf_SET BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r_CL49_BER_LIMITf_SET
#define READ_RX_X1_DEC_CTL1r BCMI_TSCD_XGXS_READ_RX_X1_DEC_CTL1r
#define WRITE_RX_X1_DEC_CTL1r BCMI_TSCD_XGXS_WRITE_RX_X1_DEC_CTL1r
#define MODIFY_RX_X1_DEC_CTL1r BCMI_TSCD_XGXS_MODIFY_RX_X1_DEC_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_DEC_CTL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_DESKEW_WINS0
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9222
 * DESC:     deskew_windows_0 register
 * RESETVAL: 0x4a6 (1190)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_DSWIN       CL82 Block based deskew window size for 20g and 40g configurationsdeskew_window = (cl82_dswin+1)blocks
 *     CL82_DSWIN_100G  CL82 Block based deskew window size for 100g and higher configurationsdeskew_window = (cl82_dswin_100g+1)blocks
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r (0x00109222 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DESKEW_WINS0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_s {
	uint32_t v[1];
	uint32_t rx_x1_deskew_wins0[1];
	uint32_t _rx_x1_deskew_wins0;
} BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_t;

#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CLR(r) (r).rx_x1_deskew_wins0[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_SET(r,d) (r).rx_x1_deskew_wins0[0] = d
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_GET(r) (r).rx_x1_deskew_wins0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWIN_100Gf_GET(r) ((((r).rx_x1_deskew_wins0[0]) >> 6) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWIN_100Gf_SET(r,f) (r).rx_x1_deskew_wins0[0]=(((r).rx_x1_deskew_wins0[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWINf_GET(r) (((r).rx_x1_deskew_wins0[0]) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWINf_SET(r,f) (r).rx_x1_deskew_wins0[0]=(((r).rx_x1_deskew_wins0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access RX_X1_DESKEW_WINS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_DESKEW_WINS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r,(_r._rx_x1_deskew_wins0))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_DESKEW_WINS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r,(_r._rx_x1_deskew_wins0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_DESKEW_WINS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r,(_r._rx_x1_deskew_wins0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DESKEW_WINS0r BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r
#define RX_X1_DESKEW_WINS0r_SIZE BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_t RX_X1_DESKEW_WINS0r_t;
#define RX_X1_DESKEW_WINS0r_CLR BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CLR
#define RX_X1_DESKEW_WINS0r_SET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_SET
#define RX_X1_DESKEW_WINS0r_GET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_GET
#define RX_X1_DESKEW_WINS0r_CL82_DSWIN_100Gf_GET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWIN_100Gf_GET
#define RX_X1_DESKEW_WINS0r_CL82_DSWIN_100Gf_SET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWIN_100Gf_SET
#define RX_X1_DESKEW_WINS0r_CL82_DSWINf_GET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWINf_GET
#define RX_X1_DESKEW_WINS0r_CL82_DSWINf_SET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r_CL82_DSWINf_SET
#define READ_RX_X1_DESKEW_WINS0r BCMI_TSCD_XGXS_READ_RX_X1_DESKEW_WINS0r
#define WRITE_RX_X1_DESKEW_WINS0r BCMI_TSCD_XGXS_WRITE_RX_X1_DESKEW_WINS0r
#define MODIFY_RX_X1_DESKEW_WINS0r BCMI_TSCD_XGXS_MODIFY_RX_X1_DESKEW_WINS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_CL91_CFG
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9223
 * DESC:     cl91 configuration register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SET_SYMB_ERR_WINDOW_128 1'b0 - Check for symbol errors over 8192 codeword window.1'b1 - Check for symbol errors over 128 codeword window.
 *     FEC_BYP_CORR_EN  It decides the latency of all the frames. The actual mode of operation depends on the per port fec_byp_corr_en config.
 *     FEC_BYP_IND_EN   It decides the latency of all the frames. The actual mode of operation depends on the per port fec_byp_ind_en config.
 *     FEC_DBG_BYP_CORR 1'b0 - Normal operation.1'b1 - Disable data correction independent of the datapath (which is determined by fec_byp_corr_en and fec_byp_ind_en.
 *     CL91_AM_SPACING_1024 1'b0 - AM spacing per virtual lane = 163841'b1 - AM spacing per virtual lane = 1024
 *     CL91_FC_LOCK_CORR_CW 1'b0 - lock on a codeword boundary only if the first CW contains syndrome equal to 0.1'b1 - lock on a codeword boundary even if the first CW contains syndrome not equal to 0, but the codeword is correctable.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr (0x00109223 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_CL91_CFG.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_s {
	uint32_t v[1];
	uint32_t rx_x1_cl91_cfg[1];
	uint32_t _rx_x1_cl91_cfg;
} BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_t;

#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CLR(r) (r).rx_x1_cl91_cfg[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SET(r,d) (r).rx_x1_cl91_cfg[0] = d
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_GET(r) (r).rx_x1_cl91_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_FC_LOCK_CORR_CWf_GET(r) ((((r).rx_x1_cl91_cfg[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_FC_LOCK_CORR_CWf_SET(r,f) (r).rx_x1_cl91_cfg[0]=(((r).rx_x1_cl91_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_AM_SPACING_1024f_GET(r) ((((r).rx_x1_cl91_cfg[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_AM_SPACING_1024f_SET(r,f) (r).rx_x1_cl91_cfg[0]=(((r).rx_x1_cl91_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_DBG_BYP_CORRf_GET(r) ((((r).rx_x1_cl91_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_DBG_BYP_CORRf_SET(r,f) (r).rx_x1_cl91_cfg[0]=(((r).rx_x1_cl91_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_IND_ENf_GET(r) ((((r).rx_x1_cl91_cfg[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_IND_ENf_SET(r,f) (r).rx_x1_cl91_cfg[0]=(((r).rx_x1_cl91_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_CORR_ENf_GET(r) ((((r).rx_x1_cl91_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_CORR_ENf_SET(r,f) (r).rx_x1_cl91_cfg[0]=(((r).rx_x1_cl91_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SET_SYMB_ERR_WINDOW_128f_GET(r) ((((r).rx_x1_cl91_cfg[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SET_SYMB_ERR_WINDOW_128f_SET(r,f) (r).rx_x1_cl91_cfg[0]=(((r).rx_x1_cl91_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access RX_X1_CL91_CFG.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_CL91_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_CL91_CFGr,(_r._rx_x1_cl91_cfg))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_CL91_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_CL91_CFGr,(_r._rx_x1_cl91_cfg)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_CL91_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_CL91_CFGr,(_r._rx_x1_cl91_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_CL91_CFGr BCMI_TSCD_XGXS_RX_X1_CL91_CFGr
#define RX_X1_CL91_CFGr_SIZE BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_t RX_X1_CL91_CFGr_t;
#define RX_X1_CL91_CFGr_CLR BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CLR
#define RX_X1_CL91_CFGr_SET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SET
#define RX_X1_CL91_CFGr_GET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_GET
#define RX_X1_CL91_CFGr_CL91_FC_LOCK_CORR_CWf_GET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_FC_LOCK_CORR_CWf_GET
#define RX_X1_CL91_CFGr_CL91_FC_LOCK_CORR_CWf_SET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_FC_LOCK_CORR_CWf_SET
#define RX_X1_CL91_CFGr_CL91_AM_SPACING_1024f_GET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_AM_SPACING_1024f_GET
#define RX_X1_CL91_CFGr_CL91_AM_SPACING_1024f_SET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_CL91_AM_SPACING_1024f_SET
#define RX_X1_CL91_CFGr_FEC_DBG_BYP_CORRf_GET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_DBG_BYP_CORRf_GET
#define RX_X1_CL91_CFGr_FEC_DBG_BYP_CORRf_SET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_DBG_BYP_CORRf_SET
#define RX_X1_CL91_CFGr_FEC_BYP_IND_ENf_GET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_IND_ENf_GET
#define RX_X1_CL91_CFGr_FEC_BYP_IND_ENf_SET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_IND_ENf_SET
#define RX_X1_CL91_CFGr_FEC_BYP_CORR_ENf_GET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_CORR_ENf_GET
#define RX_X1_CL91_CFGr_FEC_BYP_CORR_ENf_SET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_FEC_BYP_CORR_ENf_SET
#define RX_X1_CL91_CFGr_SET_SYMB_ERR_WINDOW_128f_GET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SET_SYMB_ERR_WINDOW_128f_GET
#define RX_X1_CL91_CFGr_SET_SYMB_ERR_WINDOW_128f_SET BCMI_TSCD_XGXS_RX_X1_CL91_CFGr_SET_SYMB_ERR_WINDOW_128f_SET
#define READ_RX_X1_CL91_CFGr BCMI_TSCD_XGXS_READ_RX_X1_CL91_CFGr
#define WRITE_RX_X1_CL91_CFGr BCMI_TSCD_XGXS_WRITE_RX_X1_CL91_CFGr
#define MODIFY_RX_X1_CL91_CFGr BCMI_TSCD_XGXS_MODIFY_RX_X1_CL91_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_CL91_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_DESKEW_WINS1
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9224
 * DESC:     deskew_windows_1 register
 * RESETVAL: 0x54 (84)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_DSWIN_CL91  CL82 Block based deskew window size for CL91 modedeskew_window = (cl82_dswin_cl91+1)blocksSupports skew of upto 96 blocks
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r (0x00109224 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_DESKEW_WINS1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_s {
	uint32_t v[1];
	uint32_t rx_x1_deskew_wins1[1];
	uint32_t _rx_x1_deskew_wins1;
} BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_t;

#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_CLR(r) (r).rx_x1_deskew_wins1[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_SET(r,d) (r).rx_x1_deskew_wins1[0] = d
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_GET(r) (r).rx_x1_deskew_wins1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_CL82_DSWIN_CL91f_GET(r) (((r).rx_x1_deskew_wins1[0]) & 0x7f)
#define BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_CL82_DSWIN_CL91f_SET(r,f) (r).rx_x1_deskew_wins1[0]=(((r).rx_x1_deskew_wins1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access RX_X1_DESKEW_WINS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_DESKEW_WINS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r,(_r._rx_x1_deskew_wins1))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_DESKEW_WINS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r,(_r._rx_x1_deskew_wins1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_DESKEW_WINS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r,(_r._rx_x1_deskew_wins1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_DESKEW_WINS1r BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r
#define RX_X1_DESKEW_WINS1r_SIZE BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_t RX_X1_DESKEW_WINS1r_t;
#define RX_X1_DESKEW_WINS1r_CLR BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_CLR
#define RX_X1_DESKEW_WINS1r_SET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_SET
#define RX_X1_DESKEW_WINS1r_GET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_GET
#define RX_X1_DESKEW_WINS1r_CL82_DSWIN_CL91f_GET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_CL82_DSWIN_CL91f_GET
#define RX_X1_DESKEW_WINS1r_CL82_DSWIN_CL91f_SET BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r_CL82_DSWIN_CL91f_SET
#define READ_RX_X1_DESKEW_WINS1r BCMI_TSCD_XGXS_READ_RX_X1_DESKEW_WINS1r
#define WRITE_RX_X1_DESKEW_WINS1r BCMI_TSCD_XGXS_WRITE_RX_X1_DESKEW_WINS1r
#define MODIFY_RX_X1_DESKEW_WINS1r BCMI_TSCD_XGXS_MODIFY_RX_X1_DESKEW_WINS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_DESKEW_WINS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_RX_LN_SWP
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9225
 * DESC:     RX lane swap register
 * RESETVAL: 0xe4 (228)
 * ACCESS:   R/W
 * FIELDS:
 *     LOGICAL0_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical0_to_phy_sel indicates for LOGICAL lane 0 which lane to PHYSICAL send the data to
 *     LOGICAL1_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical1_to_phy_sel indicates for LOGICAL lane 1 which lane to PHYSICAL send the data to
 *     LOGICAL2_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical2_to_phy_sel indicates for LOGICAL lane 2 which lane to PHYSICAL send the data to
 *     LOGICAL3_TO_PHY_SEL This is a LOGICAL to PHYSICAL mapping control.logical3_to_phy_sel indicates for LOGICAL lane 3 which lane to PHYSICAL send the data to
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr (0x00109225 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_RX_LN_SWP.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_s {
	uint32_t v[1];
	uint32_t rx_x1_rx_ln_swp[1];
	uint32_t _rx_x1_rx_ln_swp;
} BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_t;

#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_CLR(r) (r).rx_x1_rx_ln_swp[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_SET(r,d) (r).rx_x1_rx_ln_swp[0] = d
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_GET(r) (r).rx_x1_rx_ln_swp[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL3_TO_PHY_SELf_GET(r) ((((r).rx_x1_rx_ln_swp[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL3_TO_PHY_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL2_TO_PHY_SELf_GET(r) ((((r).rx_x1_rx_ln_swp[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL2_TO_PHY_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL1_TO_PHY_SELf_GET(r) ((((r).rx_x1_rx_ln_swp[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL1_TO_PHY_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL0_TO_PHY_SELf_GET(r) (((r).rx_x1_rx_ln_swp[0]) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL0_TO_PHY_SELf_SET(r,f) (r).rx_x1_rx_ln_swp[0]=(((r).rx_x1_rx_ln_swp[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X1_RX_LN_SWP.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_RX_LN_SWPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr,(_r._rx_x1_rx_ln_swp))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_RX_LN_SWPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr,(_r._rx_x1_rx_ln_swp)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_RX_LN_SWPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr,(_r._rx_x1_rx_ln_swp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_RX_LN_SWPr BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr
#define RX_X1_RX_LN_SWPr_SIZE BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_t RX_X1_RX_LN_SWPr_t;
#define RX_X1_RX_LN_SWPr_CLR BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_CLR
#define RX_X1_RX_LN_SWPr_SET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_SET
#define RX_X1_RX_LN_SWPr_GET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_GET
#define RX_X1_RX_LN_SWPr_LOGICAL3_TO_PHY_SELf_GET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL3_TO_PHY_SELf_GET
#define RX_X1_RX_LN_SWPr_LOGICAL3_TO_PHY_SELf_SET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL3_TO_PHY_SELf_SET
#define RX_X1_RX_LN_SWPr_LOGICAL2_TO_PHY_SELf_GET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL2_TO_PHY_SELf_GET
#define RX_X1_RX_LN_SWPr_LOGICAL2_TO_PHY_SELf_SET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL2_TO_PHY_SELf_SET
#define RX_X1_RX_LN_SWPr_LOGICAL1_TO_PHY_SELf_GET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL1_TO_PHY_SELf_GET
#define RX_X1_RX_LN_SWPr_LOGICAL1_TO_PHY_SELf_SET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL1_TO_PHY_SELf_SET
#define RX_X1_RX_LN_SWPr_LOGICAL0_TO_PHY_SELf_GET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL0_TO_PHY_SELf_GET
#define RX_X1_RX_LN_SWPr_LOGICAL0_TO_PHY_SELf_SET BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr_LOGICAL0_TO_PHY_SELf_SET
#define READ_RX_X1_RX_LN_SWPr BCMI_TSCD_XGXS_READ_RX_X1_RX_LN_SWPr
#define WRITE_RX_X1_RX_LN_SWPr BCMI_TSCD_XGXS_WRITE_RX_X1_RX_LN_SWPr
#define MODIFY_RX_X1_RX_LN_SWPr BCMI_TSCD_XGXS_MODIFY_RX_X1_RX_LN_SWPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_RX_LN_SWPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_SRF_MEM_CTL
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9226
 * DESC:     SRF memory DFT controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SRF_MEM_TM       TM control for all the SRF memories in the TSCF
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr (0x00109226 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_SRF_MEM_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x1_srf_mem_ctl[1];
	uint32_t _rx_x1_srf_mem_ctl;
} BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_t;

#define BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_CLR(r) (r).rx_x1_srf_mem_ctl[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SET(r,d) (r).rx_x1_srf_mem_ctl[0] = d
#define BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_GET(r) (r).rx_x1_srf_mem_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SRF_MEM_TMf_GET(r) (((r).rx_x1_srf_mem_ctl[0]) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SRF_MEM_TMf_SET(r,f) (r).rx_x1_srf_mem_ctl[0]=(((r).rx_x1_srf_mem_ctl[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X1_SRF_MEM_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_SRF_MEM_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr,(_r._rx_x1_srf_mem_ctl))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_SRF_MEM_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr,(_r._rx_x1_srf_mem_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_SRF_MEM_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr,(_r._rx_x1_srf_mem_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_SRF_MEM_CTLr BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr
#define RX_X1_SRF_MEM_CTLr_SIZE BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_t RX_X1_SRF_MEM_CTLr_t;
#define RX_X1_SRF_MEM_CTLr_CLR BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_CLR
#define RX_X1_SRF_MEM_CTLr_SET BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SET
#define RX_X1_SRF_MEM_CTLr_GET BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_GET
#define RX_X1_SRF_MEM_CTLr_SRF_MEM_TMf_GET BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SRF_MEM_TMf_GET
#define RX_X1_SRF_MEM_CTLr_SRF_MEM_TMf_SET BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr_SRF_MEM_TMf_SET
#define READ_RX_X1_SRF_MEM_CTLr BCMI_TSCD_XGXS_READ_RX_X1_SRF_MEM_CTLr
#define WRITE_RX_X1_SRF_MEM_CTLr BCMI_TSCD_XGXS_WRITE_RX_X1_SRF_MEM_CTLr
#define MODIFY_RX_X1_SRF_MEM_CTLr BCMI_TSCD_XGXS_MODIFY_RX_X1_SRF_MEM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_SRF_MEM_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_RF_MEM_CTL
 * BLOCKS:   RX_X1_CONTROL0
 * REGADDR:  0x9227
 * DESC:     RF memory DFT controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RF_MEM_TM        TM control for all the RF memories in the TSCF
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr (0x00109227 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_RF_MEM_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x1_rf_mem_ctl[1];
	uint32_t _rx_x1_rf_mem_ctl;
} BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_t;

#define BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_CLR(r) (r).rx_x1_rf_mem_ctl[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_SET(r,d) (r).rx_x1_rf_mem_ctl[0] = d
#define BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_GET(r) (r).rx_x1_rf_mem_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_RF_MEM_TMf_GET(r) (((r).rx_x1_rf_mem_ctl[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_RF_MEM_TMf_SET(r,f) (r).rx_x1_rf_mem_ctl[0]=(((r).rx_x1_rf_mem_ctl[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X1_RF_MEM_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_RF_MEM_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr,(_r._rx_x1_rf_mem_ctl))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_RF_MEM_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr,(_r._rx_x1_rf_mem_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_RF_MEM_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr,(_r._rx_x1_rf_mem_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_RF_MEM_CTLr BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr
#define RX_X1_RF_MEM_CTLr_SIZE BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_t RX_X1_RF_MEM_CTLr_t;
#define RX_X1_RF_MEM_CTLr_CLR BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_CLR
#define RX_X1_RF_MEM_CTLr_SET BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_SET
#define RX_X1_RF_MEM_CTLr_GET BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_GET
#define RX_X1_RF_MEM_CTLr_RF_MEM_TMf_GET BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_RF_MEM_TMf_GET
#define RX_X1_RF_MEM_CTLr_RF_MEM_TMf_SET BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr_RF_MEM_TMf_SET
#define READ_RX_X1_RF_MEM_CTLr BCMI_TSCD_XGXS_READ_RX_X1_RF_MEM_CTLr
#define WRITE_RX_X1_RF_MEM_CTLr BCMI_TSCD_XGXS_WRITE_RX_X1_RF_MEM_CTLr
#define MODIFY_RX_X1_RF_MEM_CTLr BCMI_TSCD_XGXS_MODIFY_RX_X1_RF_MEM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_RF_MEM_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_STS_FEC_MEM0
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9230
 * DESC:     ECC status register for FEC physical lane 0 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_FEC_0 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_FEC_0 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_FEC_0 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r (0x00109230 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_FEC_MEM0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_fec_mem0[1];
	uint32_t _rx_x1_ecc_sts_fec_mem0;
} BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_CLR(r) (r).rx_x1_ecc_sts_fec_mem0[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_SET(r,d) (r).rx_x1_ecc_sts_fec_mem0[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_GET(r) (r).rx_x1_ecc_sts_fec_mem0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_TWO_BIT_ERR_EVENT_FEC_0f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_TWO_BIT_ERR_EVENT_FEC_0f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem0[0]=(((r).rx_x1_ecc_sts_fec_mem0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ONE_BIT_ERR_EVENT_FEC_0f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem0[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ONE_BIT_ERR_EVENT_FEC_0f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem0[0]=(((r).rx_x1_ecc_sts_fec_mem0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ERR_EVENT_ADDRESS_FEC_0f_GET(r) (((r).rx_x1_ecc_sts_fec_mem0[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ERR_EVENT_ADDRESS_FEC_0f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem0[0]=(((r).rx_x1_ecc_sts_fec_mem0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_FEC_MEM0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r,(_r._rx_x1_ecc_sts_fec_mem0))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r,(_r._rx_x1_ecc_sts_fec_mem0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r,(_r._rx_x1_ecc_sts_fec_mem0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_FEC_MEM0r BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r
#define RX_X1_ECC_STS_FEC_MEM0r_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_t RX_X1_ECC_STS_FEC_MEM0r_t;
#define RX_X1_ECC_STS_FEC_MEM0r_CLR BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_CLR
#define RX_X1_ECC_STS_FEC_MEM0r_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_SET
#define RX_X1_ECC_STS_FEC_MEM0r_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_GET
#define RX_X1_ECC_STS_FEC_MEM0r_TWO_BIT_ERR_EVENT_FEC_0f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_TWO_BIT_ERR_EVENT_FEC_0f_GET
#define RX_X1_ECC_STS_FEC_MEM0r_TWO_BIT_ERR_EVENT_FEC_0f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_TWO_BIT_ERR_EVENT_FEC_0f_SET
#define RX_X1_ECC_STS_FEC_MEM0r_ONE_BIT_ERR_EVENT_FEC_0f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ONE_BIT_ERR_EVENT_FEC_0f_GET
#define RX_X1_ECC_STS_FEC_MEM0r_ONE_BIT_ERR_EVENT_FEC_0f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ONE_BIT_ERR_EVENT_FEC_0f_SET
#define RX_X1_ECC_STS_FEC_MEM0r_ERR_EVENT_ADDRESS_FEC_0f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ERR_EVENT_ADDRESS_FEC_0f_GET
#define RX_X1_ECC_STS_FEC_MEM0r_ERR_EVENT_ADDRESS_FEC_0f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r_ERR_EVENT_ADDRESS_FEC_0f_SET
#define READ_RX_X1_ECC_STS_FEC_MEM0r BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM0r
#define WRITE_RX_X1_ECC_STS_FEC_MEM0r BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM0r
#define MODIFY_RX_X1_ECC_STS_FEC_MEM0r BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_STS_FEC_MEM1
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9231
 * DESC:     ECC status register for FEC physical lane 1 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_FEC_1 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_FEC_1 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_FEC_1 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r (0x00109231 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_FEC_MEM1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_fec_mem1[1];
	uint32_t _rx_x1_ecc_sts_fec_mem1;
} BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_CLR(r) (r).rx_x1_ecc_sts_fec_mem1[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_SET(r,d) (r).rx_x1_ecc_sts_fec_mem1[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_GET(r) (r).rx_x1_ecc_sts_fec_mem1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_TWO_BIT_ERR_EVENT_FEC_1f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem1[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_TWO_BIT_ERR_EVENT_FEC_1f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem1[0]=(((r).rx_x1_ecc_sts_fec_mem1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ONE_BIT_ERR_EVENT_FEC_1f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem1[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ONE_BIT_ERR_EVENT_FEC_1f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem1[0]=(((r).rx_x1_ecc_sts_fec_mem1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ERR_EVENT_ADDRESS_FEC_1f_GET(r) (((r).rx_x1_ecc_sts_fec_mem1[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ERR_EVENT_ADDRESS_FEC_1f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem1[0]=(((r).rx_x1_ecc_sts_fec_mem1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_FEC_MEM1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r,(_r._rx_x1_ecc_sts_fec_mem1))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r,(_r._rx_x1_ecc_sts_fec_mem1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r,(_r._rx_x1_ecc_sts_fec_mem1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_FEC_MEM1r BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r
#define RX_X1_ECC_STS_FEC_MEM1r_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_t RX_X1_ECC_STS_FEC_MEM1r_t;
#define RX_X1_ECC_STS_FEC_MEM1r_CLR BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_CLR
#define RX_X1_ECC_STS_FEC_MEM1r_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_SET
#define RX_X1_ECC_STS_FEC_MEM1r_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_GET
#define RX_X1_ECC_STS_FEC_MEM1r_TWO_BIT_ERR_EVENT_FEC_1f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_TWO_BIT_ERR_EVENT_FEC_1f_GET
#define RX_X1_ECC_STS_FEC_MEM1r_TWO_BIT_ERR_EVENT_FEC_1f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_TWO_BIT_ERR_EVENT_FEC_1f_SET
#define RX_X1_ECC_STS_FEC_MEM1r_ONE_BIT_ERR_EVENT_FEC_1f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ONE_BIT_ERR_EVENT_FEC_1f_GET
#define RX_X1_ECC_STS_FEC_MEM1r_ONE_BIT_ERR_EVENT_FEC_1f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ONE_BIT_ERR_EVENT_FEC_1f_SET
#define RX_X1_ECC_STS_FEC_MEM1r_ERR_EVENT_ADDRESS_FEC_1f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ERR_EVENT_ADDRESS_FEC_1f_GET
#define RX_X1_ECC_STS_FEC_MEM1r_ERR_EVENT_ADDRESS_FEC_1f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r_ERR_EVENT_ADDRESS_FEC_1f_SET
#define READ_RX_X1_ECC_STS_FEC_MEM1r BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM1r
#define WRITE_RX_X1_ECC_STS_FEC_MEM1r BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM1r
#define MODIFY_RX_X1_ECC_STS_FEC_MEM1r BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_STS_FEC_MEM2
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9232
 * DESC:     ECC status register for FEC physical lane 2 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_FEC_2 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_FEC_2 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_FEC_2 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r (0x00109232 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_FEC_MEM2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_fec_mem2[1];
	uint32_t _rx_x1_ecc_sts_fec_mem2;
} BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_CLR(r) (r).rx_x1_ecc_sts_fec_mem2[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_SET(r,d) (r).rx_x1_ecc_sts_fec_mem2[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_GET(r) (r).rx_x1_ecc_sts_fec_mem2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_TWO_BIT_ERR_EVENT_FEC_2f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem2[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_TWO_BIT_ERR_EVENT_FEC_2f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem2[0]=(((r).rx_x1_ecc_sts_fec_mem2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ONE_BIT_ERR_EVENT_FEC_2f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem2[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ONE_BIT_ERR_EVENT_FEC_2f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem2[0]=(((r).rx_x1_ecc_sts_fec_mem2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ERR_EVENT_ADDRESS_FEC_2f_GET(r) (((r).rx_x1_ecc_sts_fec_mem2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ERR_EVENT_ADDRESS_FEC_2f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem2[0]=(((r).rx_x1_ecc_sts_fec_mem2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_FEC_MEM2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r,(_r._rx_x1_ecc_sts_fec_mem2))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r,(_r._rx_x1_ecc_sts_fec_mem2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r,(_r._rx_x1_ecc_sts_fec_mem2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_FEC_MEM2r BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r
#define RX_X1_ECC_STS_FEC_MEM2r_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_t RX_X1_ECC_STS_FEC_MEM2r_t;
#define RX_X1_ECC_STS_FEC_MEM2r_CLR BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_CLR
#define RX_X1_ECC_STS_FEC_MEM2r_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_SET
#define RX_X1_ECC_STS_FEC_MEM2r_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_GET
#define RX_X1_ECC_STS_FEC_MEM2r_TWO_BIT_ERR_EVENT_FEC_2f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_TWO_BIT_ERR_EVENT_FEC_2f_GET
#define RX_X1_ECC_STS_FEC_MEM2r_TWO_BIT_ERR_EVENT_FEC_2f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_TWO_BIT_ERR_EVENT_FEC_2f_SET
#define RX_X1_ECC_STS_FEC_MEM2r_ONE_BIT_ERR_EVENT_FEC_2f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ONE_BIT_ERR_EVENT_FEC_2f_GET
#define RX_X1_ECC_STS_FEC_MEM2r_ONE_BIT_ERR_EVENT_FEC_2f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ONE_BIT_ERR_EVENT_FEC_2f_SET
#define RX_X1_ECC_STS_FEC_MEM2r_ERR_EVENT_ADDRESS_FEC_2f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ERR_EVENT_ADDRESS_FEC_2f_GET
#define RX_X1_ECC_STS_FEC_MEM2r_ERR_EVENT_ADDRESS_FEC_2f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r_ERR_EVENT_ADDRESS_FEC_2f_SET
#define READ_RX_X1_ECC_STS_FEC_MEM2r BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM2r
#define WRITE_RX_X1_ECC_STS_FEC_MEM2r BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM2r
#define MODIFY_RX_X1_ECC_STS_FEC_MEM2r BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_STS_FEC_MEM3
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9233
 * DESC:     ECC status register for FEC physical lane 3 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_FEC_3 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_FEC_3 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_FEC_3 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r (0x00109233 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_STS_FEC_MEM3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_sts_fec_mem3[1];
	uint32_t _rx_x1_ecc_sts_fec_mem3;
} BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_CLR(r) (r).rx_x1_ecc_sts_fec_mem3[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_SET(r,d) (r).rx_x1_ecc_sts_fec_mem3[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_GET(r) (r).rx_x1_ecc_sts_fec_mem3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_TWO_BIT_ERR_EVENT_FEC_3f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem3[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_TWO_BIT_ERR_EVENT_FEC_3f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem3[0]=(((r).rx_x1_ecc_sts_fec_mem3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ONE_BIT_ERR_EVENT_FEC_3f_GET(r) ((((r).rx_x1_ecc_sts_fec_mem3[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ONE_BIT_ERR_EVENT_FEC_3f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem3[0]=(((r).rx_x1_ecc_sts_fec_mem3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ERR_EVENT_ADDRESS_FEC_3f_GET(r) (((r).rx_x1_ecc_sts_fec_mem3[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ERR_EVENT_ADDRESS_FEC_3f_SET(r,f) (r).rx_x1_ecc_sts_fec_mem3[0]=(((r).rx_x1_ecc_sts_fec_mem3[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_ECC_STS_FEC_MEM3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r,(_r._rx_x1_ecc_sts_fec_mem3))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r,(_r._rx_x1_ecc_sts_fec_mem3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r,(_r._rx_x1_ecc_sts_fec_mem3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_STS_FEC_MEM3r BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r
#define RX_X1_ECC_STS_FEC_MEM3r_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_t RX_X1_ECC_STS_FEC_MEM3r_t;
#define RX_X1_ECC_STS_FEC_MEM3r_CLR BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_CLR
#define RX_X1_ECC_STS_FEC_MEM3r_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_SET
#define RX_X1_ECC_STS_FEC_MEM3r_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_GET
#define RX_X1_ECC_STS_FEC_MEM3r_TWO_BIT_ERR_EVENT_FEC_3f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_TWO_BIT_ERR_EVENT_FEC_3f_GET
#define RX_X1_ECC_STS_FEC_MEM3r_TWO_BIT_ERR_EVENT_FEC_3f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_TWO_BIT_ERR_EVENT_FEC_3f_SET
#define RX_X1_ECC_STS_FEC_MEM3r_ONE_BIT_ERR_EVENT_FEC_3f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ONE_BIT_ERR_EVENT_FEC_3f_GET
#define RX_X1_ECC_STS_FEC_MEM3r_ONE_BIT_ERR_EVENT_FEC_3f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ONE_BIT_ERR_EVENT_FEC_3f_SET
#define RX_X1_ECC_STS_FEC_MEM3r_ERR_EVENT_ADDRESS_FEC_3f_GET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ERR_EVENT_ADDRESS_FEC_3f_GET
#define RX_X1_ECC_STS_FEC_MEM3r_ERR_EVENT_ADDRESS_FEC_3f_SET BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r_ERR_EVENT_ADDRESS_FEC_3f_SET
#define READ_RX_X1_ECC_STS_FEC_MEM3r BCMI_TSCD_XGXS_READ_RX_X1_ECC_STS_FEC_MEM3r
#define WRITE_RX_X1_ECC_STS_FEC_MEM3r BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_STS_FEC_MEM3r
#define MODIFY_RX_X1_ECC_STS_FEC_MEM3r BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_STS_FEC_MEM3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_STS_FEC_MEM3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_INTR_STS_1BIT
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9238
 * DESC:     ECC 1-bit interrupt status register (Physical lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     FEC_MEM_0_1BIT_INT_STATUS Single bit, correctable error detected
 *     FEC_MEM_1_1BIT_INT_STATUS Single bit, correctable error detected
 *     FEC_MEM_2_1BIT_INT_STATUS Single bit, correctable error detected
 *     FEC_MEM_3_1BIT_INT_STATUS Single bit, correctable error detected
 *     CL91_FEC_RAM1_LO_1BIT_INT_STATUS Single bit, correctable error detected
 *     CL91_FEC_RAM1_HI_1BIT_INT_STATUS Single bit, correctable error detected
 *     CL91_FEC_RAM2_LO_1BIT_INT_STATUS Single bit, correctable error detected
 *     CL91_FEC_RAM2_HI_1BIT_INT_STATUS Single bit, correctable error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr (0x00109238 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_INTR_STS_1BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_intr_sts_1bit[1];
	uint32_t _rx_x1_ecc_intr_sts_1bit;
} BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CLR(r) (r).rx_x1_ecc_intr_sts_1bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_SET(r,d) (r).rx_x1_ecc_intr_sts_1bit[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_GET(r) (r).rx_x1_ecc_intr_sts_1bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_1bit[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_1bit[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_1bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_1bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_3_1BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_1bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_3_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_2_1BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_1bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_2_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_1_1BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_1bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_1_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_0_1BIT_INT_STATUSf_GET(r) (((r).rx_x1_ecc_intr_sts_1bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_0_1BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_1bit[0]=(((r).rx_x1_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X1_ECC_INTR_STS_1BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_STS_1BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr,(_r._rx_x1_ecc_intr_sts_1bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_STS_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr,(_r._rx_x1_ecc_intr_sts_1bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_STS_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr,(_r._rx_x1_ecc_intr_sts_1bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr
#define RX_X1_ECC_INTR_STS_1BITr_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_t RX_X1_ECC_INTR_STS_1BITr_t;
#define RX_X1_ECC_INTR_STS_1BITr_CLR BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CLR
#define RX_X1_ECC_INTR_STS_1BITr_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_SET
#define RX_X1_ECC_INTR_STS_1BITr_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_GET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_3_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_3_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_3_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_3_1BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_2_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_2_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_2_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_2_1BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_1_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_1_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_1_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_1_1BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_0_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_0_1BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_0_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr_FEC_MEM_0_1BIT_INT_STATUSf_SET
#define READ_RX_X1_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_STS_1BITr
#define WRITE_RX_X1_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_STS_1BITr
#define MODIFY_RX_X1_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_STS_1BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_1BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_INTR_STS_2BIT
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x9239
 * DESC:     ECC 2-bit interrupt status register (Physical lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     FEC_MEM_0_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     FEC_MEM_1_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     FEC_MEM_2_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     FEC_MEM_3_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     CL91_FEC_RAM1_LO_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     CL91_FEC_RAM1_HI_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     CL91_FEC_RAM2_LO_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     CL91_FEC_RAM2_HI_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr (0x00109239 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_INTR_STS_2BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_intr_sts_2bit[1];
	uint32_t _rx_x1_ecc_intr_sts_2bit;
} BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CLR(r) (r).rx_x1_ecc_intr_sts_2bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_SET(r,d) (r).rx_x1_ecc_intr_sts_2bit[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_GET(r) (r).rx_x1_ecc_intr_sts_2bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_2bit[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_2bit[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_2bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_2bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_3_2BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_2bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_3_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_2_2BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_2bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_2_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_1_2BIT_INT_STATUSf_GET(r) ((((r).rx_x1_ecc_intr_sts_2bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_1_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_0_2BIT_INT_STATUSf_GET(r) (((r).rx_x1_ecc_intr_sts_2bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_0_2BIT_INT_STATUSf_SET(r,f) (r).rx_x1_ecc_intr_sts_2bit[0]=(((r).rx_x1_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X1_ECC_INTR_STS_2BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_STS_2BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr,(_r._rx_x1_ecc_intr_sts_2bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_STS_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr,(_r._rx_x1_ecc_intr_sts_2bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_STS_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr,(_r._rx_x1_ecc_intr_sts_2bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr
#define RX_X1_ECC_INTR_STS_2BITr_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_t RX_X1_ECC_INTR_STS_2BITr_t;
#define RX_X1_ECC_INTR_STS_2BITr_CLR BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CLR
#define RX_X1_ECC_INTR_STS_2BITr_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_SET
#define RX_X1_ECC_INTR_STS_2BITr_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_GET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_3_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_3_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_3_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_3_2BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_2_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_2_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_2_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_2_2BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_1_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_1_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_1_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_1_2BIT_INT_STATUSf_SET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_0_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_0_2BIT_INT_STATUSf_GET
#define RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_0_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr_FEC_MEM_0_2BIT_INT_STATUSf_SET
#define READ_RX_X1_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_STS_2BITr
#define WRITE_RX_X1_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_STS_2BITr
#define MODIFY_RX_X1_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_STS_2BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_INTR_STS_2BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_INTR_EN_1BIT
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x923a
 * DESC:     ECC 1-bit interrupt enable register (Physical lane based)
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_MEM_0_1BIT_INT_EN Enable for correctable error interrupt
 *     FEC_MEM_1_1BIT_INT_EN Enable for correctable error interrupt
 *     FEC_MEM_2_1BIT_INT_EN Enable for correctable error interrupt
 *     FEC_MEM_3_1BIT_INT_EN Enable for correctable error interrupt
 *     CL91_FEC_RAM1_LO_1BIT_INT_EN Enable for correctable error interrupt
 *     CL91_FEC_RAM1_HI_1BIT_INT_EN Enable for correctable error interrupt
 *     CL91_FEC_RAM2_LO_1BIT_INT_EN Enable for correctable error interrupt
 *     CL91_FEC_RAM2_HI_1BIT_INT_EN Enable for correctable error interrupt
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr (0x0010923a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_INTR_EN_1BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_intr_en_1bit[1];
	uint32_t _rx_x1_ecc_intr_en_1bit;
} BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CLR(r) (r).rx_x1_ecc_intr_en_1bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_SET(r,d) (r).rx_x1_ecc_intr_en_1bit[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_GET(r) (r).rx_x1_ecc_intr_en_1bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_1bit[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_1bit[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_1bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_1bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_3_1BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_1bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_3_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_2_1BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_1bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_2_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_1_1BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_1bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_1_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_0_1BIT_INT_ENf_GET(r) (((r).rx_x1_ecc_intr_en_1bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_0_1BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_1bit[0]=(((r).rx_x1_ecc_intr_en_1bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X1_ECC_INTR_EN_1BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_EN_1BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr,(_r._rx_x1_ecc_intr_en_1bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_EN_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr,(_r._rx_x1_ecc_intr_en_1bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_EN_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr,(_r._rx_x1_ecc_intr_en_1bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr
#define RX_X1_ECC_INTR_EN_1BITr_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_t RX_X1_ECC_INTR_EN_1BITr_t;
#define RX_X1_ECC_INTR_EN_1BITr_CLR BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CLR
#define RX_X1_ECC_INTR_EN_1BITr_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_SET
#define RX_X1_ECC_INTR_EN_1BITr_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_GET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_HI_1BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM2_LO_1BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_HI_1BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_CL91_FEC_RAM1_LO_1BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_3_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_3_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_3_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_3_1BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_2_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_2_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_2_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_2_1BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_1_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_1_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_1_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_1_1BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_0_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_0_1BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_0_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr_FEC_MEM_0_1BIT_INT_ENf_SET
#define READ_RX_X1_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_EN_1BITr
#define WRITE_RX_X1_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_EN_1BITr
#define MODIFY_RX_X1_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_EN_1BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_1BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_INTR_EN_2BIT
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x923b
 * DESC:     ECC 2-bit interrupt enable register (Physical lane based)
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_MEM_0_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     FEC_MEM_1_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     FEC_MEM_2_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     FEC_MEM_3_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     CL91_FEC_RAM1_LO_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     CL91_FEC_RAM1_HI_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     CL91_FEC_RAM2_LO_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     CL91_FEC_RAM2_HI_2BIT_INT_EN Enable for uncorrectable error interrupt
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr (0x0010923b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_INTR_EN_2BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_intr_en_2bit[1];
	uint32_t _rx_x1_ecc_intr_en_2bit;
} BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CLR(r) (r).rx_x1_ecc_intr_en_2bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_SET(r,d) (r).rx_x1_ecc_intr_en_2bit[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_GET(r) (r).rx_x1_ecc_intr_en_2bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_2bit[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_2bit[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_2bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_2bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_3_2BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_2bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_3_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_2_2BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_2bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_2_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_1_2BIT_INT_ENf_GET(r) ((((r).rx_x1_ecc_intr_en_2bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_1_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_0_2BIT_INT_ENf_GET(r) (((r).rx_x1_ecc_intr_en_2bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_0_2BIT_INT_ENf_SET(r,f) (r).rx_x1_ecc_intr_en_2bit[0]=(((r).rx_x1_ecc_intr_en_2bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X1_ECC_INTR_EN_2BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_EN_2BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr,(_r._rx_x1_ecc_intr_en_2bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_EN_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr,(_r._rx_x1_ecc_intr_en_2bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_EN_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr,(_r._rx_x1_ecc_intr_en_2bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr
#define RX_X1_ECC_INTR_EN_2BITr_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_t RX_X1_ECC_INTR_EN_2BITr_t;
#define RX_X1_ECC_INTR_EN_2BITr_CLR BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CLR
#define RX_X1_ECC_INTR_EN_2BITr_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_SET
#define RX_X1_ECC_INTR_EN_2BITr_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_GET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_HI_2BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM2_LO_2BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_HI_2BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_CL91_FEC_RAM1_LO_2BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_3_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_3_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_3_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_3_2BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_2_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_2_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_2_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_2_2BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_1_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_1_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_1_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_1_2BIT_INT_ENf_SET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_0_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_0_2BIT_INT_ENf_GET
#define RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_0_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr_FEC_MEM_0_2BIT_INT_ENf_SET
#define READ_RX_X1_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_READ_RX_X1_ECC_INTR_EN_2BITr
#define WRITE_RX_X1_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_INTR_EN_2BITr
#define MODIFY_RX_X1_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_INTR_EN_2BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_INTR_EN_2BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_DIS_ECC_MEM
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x923c
 * DESC:     Disable ECC register (Physical lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DISABLE_ECC_FEC_MEM_0 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_FEC_MEM_1 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_FEC_MEM_2 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_FEC_MEM_3 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_CL91_FEC_RAM1_LO disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_CL91_FEC_RAM1_HI disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_CL91_FEC_RAM2_LO disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_CL91_FEC_RAM2_HI disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr (0x0010923c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_DIS_ECC_MEM.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_dis_ecc_mem[1];
	uint32_t _rx_x1_ecc_dis_ecc_mem;
} BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_CLR(r) (r).rx_x1_ecc_dis_ecc_mem[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_SET(r,d) (r).rx_x1_ecc_dis_ecc_mem[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_GET(r) (r).rx_x1_ecc_dis_ecc_mem[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_HIf_GET(r) ((((r).rx_x1_ecc_dis_ecc_mem[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_HIf_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_LOf_GET(r) ((((r).rx_x1_ecc_dis_ecc_mem[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_LOf_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_HIf_GET(r) ((((r).rx_x1_ecc_dis_ecc_mem[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_HIf_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_LOf_GET(r) ((((r).rx_x1_ecc_dis_ecc_mem[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_LOf_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_3f_GET(r) ((((r).rx_x1_ecc_dis_ecc_mem[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_3f_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_2f_GET(r) ((((r).rx_x1_ecc_dis_ecc_mem[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_2f_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_1f_GET(r) ((((r).rx_x1_ecc_dis_ecc_mem[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_1f_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_0f_GET(r) (((r).rx_x1_ecc_dis_ecc_mem[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_0f_SET(r,f) (r).rx_x1_ecc_dis_ecc_mem[0]=(((r).rx_x1_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X1_ECC_DIS_ECC_MEM.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_DIS_ECC_MEMr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr,(_r._rx_x1_ecc_dis_ecc_mem))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_DIS_ECC_MEMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr,(_r._rx_x1_ecc_dis_ecc_mem)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_DIS_ECC_MEMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr,(_r._rx_x1_ecc_dis_ecc_mem))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr
#define RX_X1_ECC_DIS_ECC_MEMr_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_t RX_X1_ECC_DIS_ECC_MEMr_t;
#define RX_X1_ECC_DIS_ECC_MEMr_CLR BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_CLR
#define RX_X1_ECC_DIS_ECC_MEMr_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_SET
#define RX_X1_ECC_DIS_ECC_MEMr_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_HIf_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_HIf_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_HIf_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_HIf_SET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_LOf_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_LOf_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_LOf_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM2_LOf_SET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_HIf_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_HIf_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_HIf_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_HIf_SET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_LOf_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_LOf_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_LOf_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_FEC_RAM1_LOf_SET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_3f_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_3f_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_3f_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_3f_SET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_2f_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_2f_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_2f_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_2f_SET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_1f_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_1f_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_1f_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_1f_SET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_0f_GET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_0f_GET
#define RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_0f_SET BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr_DISABLE_ECC_FEC_MEM_0f_SET
#define READ_RX_X1_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_READ_RX_X1_ECC_DIS_ECC_MEMr
#define WRITE_RX_X1_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_DIS_ECC_MEMr
#define MODIFY_RX_X1_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_DIS_ECC_MEMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_DIS_ECC_MEMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_ECC_CORRUPT0
 * BLOCKS:   RX_X1_ECC
 * REGADDR:  0x923d
 * DESC:     Corrupt ECC register (Physical lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPT_ECC_FEC_MEM_0 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_FEC_MEM_1 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_FEC_MEM_2 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_FEC_MEM_3 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_CL91_FEC_RAM1_LO ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_CL91_FEC_RAM1_HI ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_CL91_FEC_RAM2_LO ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_CL91_FEC_RAM2_HI ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r (0x0010923d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_ECC_CORRUPT0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_s {
	uint32_t v[1];
	uint32_t rx_x1_ecc_corrupt0[1];
	uint32_t _rx_x1_ecc_corrupt0;
} BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_t;

#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CLR(r) (r).rx_x1_ecc_corrupt0[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_SET(r,d) (r).rx_x1_ecc_corrupt0[0] = d
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_GET(r) (r).rx_x1_ecc_corrupt0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_HIf_GET(r) ((((r).rx_x1_ecc_corrupt0[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_HIf_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_LOf_GET(r) ((((r).rx_x1_ecc_corrupt0[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_LOf_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_HIf_GET(r) ((((r).rx_x1_ecc_corrupt0[0]) >> 10) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_HIf_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_LOf_GET(r) ((((r).rx_x1_ecc_corrupt0[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_LOf_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_3f_GET(r) ((((r).rx_x1_ecc_corrupt0[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_3f_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_2f_GET(r) ((((r).rx_x1_ecc_corrupt0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_2f_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_1f_GET(r) ((((r).rx_x1_ecc_corrupt0[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_1f_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_0f_GET(r) (((r).rx_x1_ecc_corrupt0[0]) & 0x3)
#define BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_0f_SET(r,f) (r).rx_x1_ecc_corrupt0[0]=(((r).rx_x1_ecc_corrupt0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X1_ECC_CORRUPT0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_ECC_CORRUPT0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r,(_r._rx_x1_ecc_corrupt0))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_CORRUPT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r,(_r._rx_x1_ecc_corrupt0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_CORRUPT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r,(_r._rx_x1_ecc_corrupt0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_ECC_CORRUPT0r BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r
#define RX_X1_ECC_CORRUPT0r_SIZE BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_t RX_X1_ECC_CORRUPT0r_t;
#define RX_X1_ECC_CORRUPT0r_CLR BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CLR
#define RX_X1_ECC_CORRUPT0r_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_SET
#define RX_X1_ECC_CORRUPT0r_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_HIf_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_HIf_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_HIf_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_HIf_SET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_LOf_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_LOf_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_LOf_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM2_LOf_SET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_HIf_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_HIf_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_HIf_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_HIf_SET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_LOf_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_LOf_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_LOf_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_CL91_FEC_RAM1_LOf_SET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_3f_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_3f_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_3f_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_3f_SET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_2f_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_2f_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_2f_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_2f_SET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_1f_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_1f_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_1f_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_1f_SET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_0f_GET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_0f_GET
#define RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_0f_SET BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r_CORRUPT_ECC_FEC_MEM_0f_SET
#define READ_RX_X1_ECC_CORRUPT0r BCMI_TSCD_XGXS_READ_RX_X1_ECC_CORRUPT0r
#define WRITE_RX_X1_ECC_CORRUPT0r BCMI_TSCD_XGXS_WRITE_RX_X1_ECC_CORRUPT0r
#define MODIFY_RX_X1_ECC_CORRUPT0r BCMI_TSCD_XGXS_MODIFY_RX_X1_ECC_CORRUPT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_ECC_CORRUPT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_OUI_UPR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9240
 * DESC:     OUI UPPER BITS REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OUI_UPPER_DATA   UPPER 8 BITS OF OUI FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_OUI_UPRr (0x00109240 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_OUI_UPR.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_s {
	uint32_t v[1];
	uint32_t an_x1_oui_upr[1];
	uint32_t _an_x1_oui_upr;
} BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_t;

#define BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_CLR(r) (r).an_x1_oui_upr[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_SET(r,d) (r).an_x1_oui_upr[0] = d
#define BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_GET(r) (r).an_x1_oui_upr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET(r) (((r).an_x1_oui_upr[0]) & 0xff)
#define BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET(r,f) (r).an_x1_oui_upr[0]=(((r).an_x1_oui_upr[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_X1_OUI_UPR.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_OUI_UPRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_OUI_UPRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_OUI_UPRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_OUI_UPRr,(_r._an_x1_oui_upr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_OUI_UPRr BCMI_TSCD_XGXS_AN_X1_OUI_UPRr
#define AN_X1_OUI_UPRr_SIZE BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_t AN_X1_OUI_UPRr_t;
#define AN_X1_OUI_UPRr_CLR BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_CLR
#define AN_X1_OUI_UPRr_SET BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_SET
#define AN_X1_OUI_UPRr_GET BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_GET
#define AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_GET
#define AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET BCMI_TSCD_XGXS_AN_X1_OUI_UPRr_OUI_UPPER_DATAf_SET
#define READ_AN_X1_OUI_UPRr BCMI_TSCD_XGXS_READ_AN_X1_OUI_UPRr
#define WRITE_AN_X1_OUI_UPRr BCMI_TSCD_XGXS_WRITE_AN_X1_OUI_UPRr
#define MODIFY_AN_X1_OUI_UPRr BCMI_TSCD_XGXS_MODIFY_AN_X1_OUI_UPRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_OUI_UPRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_OUI_LWR
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9241
 * DESC:     OUI LOWEr BITS REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OUI_LOWER_DATA   LOWER 16 BITS OF OUI FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_OUI_LWRr (0x00109241 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_OUI_LWR.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_s {
	uint32_t v[1];
	uint32_t an_x1_oui_lwr[1];
	uint32_t _an_x1_oui_lwr;
} BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_t;

#define BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_CLR(r) (r).an_x1_oui_lwr[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_SET(r,d) (r).an_x1_oui_lwr[0] = d
#define BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_GET(r) (r).an_x1_oui_lwr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET(r) (((r).an_x1_oui_lwr[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET(r,f) (r).an_x1_oui_lwr[0]=(((r).an_x1_oui_lwr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_OUI_LWR.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_OUI_LWRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_OUI_LWRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_OUI_LWRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_OUI_LWRr,(_r._an_x1_oui_lwr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_OUI_LWRr BCMI_TSCD_XGXS_AN_X1_OUI_LWRr
#define AN_X1_OUI_LWRr_SIZE BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_t AN_X1_OUI_LWRr_t;
#define AN_X1_OUI_LWRr_CLR BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_CLR
#define AN_X1_OUI_LWRr_SET BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_SET
#define AN_X1_OUI_LWRr_GET BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_GET
#define AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_GET
#define AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET BCMI_TSCD_XGXS_AN_X1_OUI_LWRr_OUI_LOWER_DATAf_SET
#define READ_AN_X1_OUI_LWRr BCMI_TSCD_XGXS_READ_AN_X1_OUI_LWRr
#define WRITE_AN_X1_OUI_LWRr BCMI_TSCD_XGXS_WRITE_AN_X1_OUI_LWRr
#define MODIFY_AN_X1_OUI_LWRr BCMI_TSCD_XGXS_MODIFY_AN_X1_OUI_LWRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_OUI_LWRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI0
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9242
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_100G_CR4 HCD PRIORITY OVERRIDE FOR PRIORITY 100G_CR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_100G_HG2_CR4 HCD PRIORITY OVERRIDE FOR PRIORITY 100G_HG2_CR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_100G_KR4 HCD PRIORITY OVERRIDE FOR PRIORITY 100G_KR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_100G_HG2_KR4 HCD PRIORITY OVERRIDE FOR PRIORITY 100G_HG2_KR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40G_CR4 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_CR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40G_HG2_CR4 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_HG2_CR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40G_KR4 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_KR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40G_HG2_KR4 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_HG2_KR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r (0x00109242 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI0.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri0[1];
	uint32_t _an_x1_bam_spd_pri0;
} BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_t;

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_CLR(r) (r).an_x1_bam_spd_pri0[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_SET(r,d) (r).an_x1_bam_spd_pri0[0] = d
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_GET(r) (r).an_x1_bam_spd_pri0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_KR4f_GET(r) ((((r).an_x1_bam_spd_pri0[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_KR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_KR4f_GET(r) ((((r).an_x1_bam_spd_pri0[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_KR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_CR4f_GET(r) ((((r).an_x1_bam_spd_pri0[0]) >> 10) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_CR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_CR4f_GET(r) ((((r).an_x1_bam_spd_pri0[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_CR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_KR4f_GET(r) ((((r).an_x1_bam_spd_pri0[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_KR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_KR4f_GET(r) ((((r).an_x1_bam_spd_pri0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_KR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_CR4f_GET(r) ((((r).an_x1_bam_spd_pri0[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_CR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_CR4f_GET(r) (((r).an_x1_bam_spd_pri0[0]) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_CR4f_SET(r,f) (r).an_x1_bam_spd_pri0[0]=(((r).an_x1_bam_spd_pri0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI0.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r,(_r._an_x1_bam_spd_pri0))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r,(_r._an_x1_bam_spd_pri0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r,(_r._an_x1_bam_spd_pri0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI0r BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r
#define AN_X1_BAM_SPD_PRI0r_SIZE BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_t AN_X1_BAM_SPD_PRI0r_t;
#define AN_X1_BAM_SPD_PRI0r_CLR BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_CLR
#define AN_X1_BAM_SPD_PRI0r_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_SET
#define AN_X1_BAM_SPD_PRI0r_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_KR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_KR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_KR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_KR4f_SET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_KR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_KR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_KR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_KR4f_SET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_CR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_CR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_CR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_HG2_CR4f_SET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_CR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_CR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_CR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_40G_CR4f_SET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_KR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_KR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_KR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_KR4f_SET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_KR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_KR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_KR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_KR4f_SET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_CR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_CR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_CR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_HG2_CR4f_SET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_CR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_CR4f_GET
#define AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_CR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r_AN_PRIORITY_100G_CR4f_SET
#define READ_AN_X1_BAM_SPD_PRI0r BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI0r
#define WRITE_AN_X1_BAM_SPD_PRI0r BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI0r
#define MODIFY_AN_X1_BAM_SPD_PRI0r BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI1
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9243
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_50G_CR4 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_CR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_50G_HG2_CR4 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_HG2_CR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_50G_KR4 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_KR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_50G_HG2_KR4 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_HG2_KR4 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_50G_CR2 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_CR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_50G_HG2_CR2 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_HG2_CR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_50G_KR2 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_KR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_50G_HG2_KR2 HCD PRIORITY OVERRIDE FOR PRIORITY 50G_HG2_KR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r (0x00109243 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri1[1];
	uint32_t _an_x1_bam_spd_pri1;
} BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_t;

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_CLR(r) (r).an_x1_bam_spd_pri1[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_SET(r,d) (r).an_x1_bam_spd_pri1[0] = d
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_GET(r) (r).an_x1_bam_spd_pri1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR2f_GET(r) ((((r).an_x1_bam_spd_pri1[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR2f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR2f_GET(r) ((((r).an_x1_bam_spd_pri1[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR2f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR2f_GET(r) ((((r).an_x1_bam_spd_pri1[0]) >> 10) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR2f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR2f_GET(r) ((((r).an_x1_bam_spd_pri1[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR2f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR4f_GET(r) ((((r).an_x1_bam_spd_pri1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR4f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR4f_GET(r) ((((r).an_x1_bam_spd_pri1[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR4f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR4f_GET(r) ((((r).an_x1_bam_spd_pri1[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR4f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR4f_GET(r) (((r).an_x1_bam_spd_pri1[0]) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR4f_SET(r,f) (r).an_x1_bam_spd_pri1[0]=(((r).an_x1_bam_spd_pri1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r,(_r._an_x1_bam_spd_pri1))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r,(_r._an_x1_bam_spd_pri1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r,(_r._an_x1_bam_spd_pri1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI1r BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r
#define AN_X1_BAM_SPD_PRI1r_SIZE BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_t AN_X1_BAM_SPD_PRI1r_t;
#define AN_X1_BAM_SPD_PRI1r_CLR BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_CLR
#define AN_X1_BAM_SPD_PRI1r_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_SET
#define AN_X1_BAM_SPD_PRI1r_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR2f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR2f_SET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR2f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR2f_SET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR2f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR2f_SET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR2f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR2f_SET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR4f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_KR4f_SET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR4f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_KR4f_SET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR4f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_HG2_CR4f_SET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR4f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR4f_GET
#define AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR4f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r_AN_PRIORITY_50G_CR4f_SET
#define READ_AN_X1_BAM_SPD_PRI1r BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI1r
#define WRITE_AN_X1_BAM_SPD_PRI1r BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI1r
#define MODIFY_AN_X1_BAM_SPD_PRI1r BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI2
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9244
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_40G_CR2 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_CR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40G_HG2_CR2 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_HG2_CR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40G_KR2 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_KR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_40G_HG2_KR2 HCD PRIORITY OVERRIDE FOR PRIORITY 40G_HG2_KR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_25G_CR1 HCD PRIORITY OVERRIDE FOR PRIORITY 25G_CR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_25G_HG2_CR1 HCD PRIORITY OVERRIDE FOR PRIORITY 25G_HG2_CR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_25G_KR1 HCD PRIORITY OVERRIDE FOR PRIORITY 25G_KR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_25G_HG2_KR1 HCD PRIORITY OVERRIDE FOR PRIORITY 25G_HG2_KR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r (0x00109244 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI2.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri2[1];
	uint32_t _an_x1_bam_spd_pri2;
} BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_t;

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_CLR(r) (r).an_x1_bam_spd_pri2[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_SET(r,d) (r).an_x1_bam_spd_pri2[0] = d
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_GET(r) (r).an_x1_bam_spd_pri2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_KR1f_GET(r) ((((r).an_x1_bam_spd_pri2[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_KR1f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_KR1f_GET(r) ((((r).an_x1_bam_spd_pri2[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_KR1f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_CR1f_GET(r) ((((r).an_x1_bam_spd_pri2[0]) >> 10) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_CR1f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_CR1f_GET(r) ((((r).an_x1_bam_spd_pri2[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_CR1f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_KR2f_GET(r) ((((r).an_x1_bam_spd_pri2[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_KR2f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_KR2f_GET(r) ((((r).an_x1_bam_spd_pri2[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_KR2f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_CR2f_GET(r) ((((r).an_x1_bam_spd_pri2[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_CR2f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_CR2f_GET(r) (((r).an_x1_bam_spd_pri2[0]) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_CR2f_SET(r,f) (r).an_x1_bam_spd_pri2[0]=(((r).an_x1_bam_spd_pri2[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI2.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r,(_r._an_x1_bam_spd_pri2))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r,(_r._an_x1_bam_spd_pri2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r,(_r._an_x1_bam_spd_pri2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI2r BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r
#define AN_X1_BAM_SPD_PRI2r_SIZE BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_t AN_X1_BAM_SPD_PRI2r_t;
#define AN_X1_BAM_SPD_PRI2r_CLR BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_CLR
#define AN_X1_BAM_SPD_PRI2r_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_SET
#define AN_X1_BAM_SPD_PRI2r_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_KR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_KR1f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_KR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_KR1f_SET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_KR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_KR1f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_KR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_KR1f_SET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_CR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_CR1f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_CR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_HG2_CR1f_SET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_CR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_CR1f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_CR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_25G_CR1f_SET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_KR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_KR2f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_KR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_KR2f_SET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_KR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_KR2f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_KR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_KR2f_SET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_CR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_CR2f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_CR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_HG2_CR2f_SET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_CR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_CR2f_GET
#define AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_CR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r_AN_PRIORITY_40G_CR2f_SET
#define READ_AN_X1_BAM_SPD_PRI2r BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI2r
#define WRITE_AN_X1_BAM_SPD_PRI2r BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI2r
#define MODIFY_AN_X1_BAM_SPD_PRI2r BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI3
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9245
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_20G_CR1 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_CR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20G_HG2_CR1 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_HG2_CR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20G_KR1 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_KR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20G_HG2_KR1 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_HG2_KR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20G_CR2 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_CR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20G_HG2_CR2 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_HG2_CR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20G_KR2 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_KR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_20G_HG2_KR2 HCD PRIORITY OVERRIDE FOR PRIORITY 20G_HG2_KR2 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r (0x00109245 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI3.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri3[1];
	uint32_t _an_x1_bam_spd_pri3;
} BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_t;

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_CLR(r) (r).an_x1_bam_spd_pri3[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_SET(r,d) (r).an_x1_bam_spd_pri3[0] = d
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_GET(r) (r).an_x1_bam_spd_pri3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR2f_GET(r) ((((r).an_x1_bam_spd_pri3[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR2f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR2f_GET(r) ((((r).an_x1_bam_spd_pri3[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR2f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR2f_GET(r) ((((r).an_x1_bam_spd_pri3[0]) >> 10) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR2f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR2f_GET(r) ((((r).an_x1_bam_spd_pri3[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR2f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR1f_GET(r) ((((r).an_x1_bam_spd_pri3[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR1f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR1f_GET(r) ((((r).an_x1_bam_spd_pri3[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR1f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR1f_GET(r) ((((r).an_x1_bam_spd_pri3[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR1f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR1f_GET(r) (((r).an_x1_bam_spd_pri3[0]) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR1f_SET(r,f) (r).an_x1_bam_spd_pri3[0]=(((r).an_x1_bam_spd_pri3[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI3.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r,(_r._an_x1_bam_spd_pri3))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r,(_r._an_x1_bam_spd_pri3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r,(_r._an_x1_bam_spd_pri3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI3r BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r
#define AN_X1_BAM_SPD_PRI3r_SIZE BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_t AN_X1_BAM_SPD_PRI3r_t;
#define AN_X1_BAM_SPD_PRI3r_CLR BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_CLR
#define AN_X1_BAM_SPD_PRI3r_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_SET
#define AN_X1_BAM_SPD_PRI3r_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR2f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR2f_SET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR2f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR2f_SET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR2f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR2f_SET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR2f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR2f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR2f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR2f_SET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR1f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_KR1f_SET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR1f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_KR1f_SET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR1f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_HG2_CR1f_SET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR1f_GET
#define AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r_AN_PRIORITY_20G_CR1f_SET
#define READ_AN_X1_BAM_SPD_PRI3r BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI3r
#define WRITE_AN_X1_BAM_SPD_PRI3r BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI3r
#define MODIFY_AN_X1_BAM_SPD_PRI3r BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_BAM_SPD_PRI4
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9246
 * DESC:     REMAP PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_10G_KR1 HCD PRIORITY OVERRIDE FOR PRIORITY 10G_KR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_10G_HG2_KR1 HCD PRIORITY OVERRIDE FOR PRIORITY 10G_HG2_KR1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_1G_KX1 HCD PRIORITY OVERRIDE FOR PRIORITY 1G_KX1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_2P5G_KX1 HCD PRIORITY OVERRIDE FOR PRIORITY 2P5G_X1 SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_5G_KR1 HCD PRIORITY OVERRIDE FOR PRIORITY 2P5G_X1 SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r (0x00109246 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_BAM_SPD_PRI4.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_s {
	uint32_t v[1];
	uint32_t an_x1_bam_spd_pri4[1];
	uint32_t _an_x1_bam_spd_pri4;
} BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_t;

#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_CLR(r) (r).an_x1_bam_spd_pri4[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_SET(r,d) (r).an_x1_bam_spd_pri4[0] = d
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_GET(r) (r).an_x1_bam_spd_pri4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_5G_KR1f_GET(r) ((((r).an_x1_bam_spd_pri4[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_5G_KR1f_SET(r,f) (r).an_x1_bam_spd_pri4[0]=(((r).an_x1_bam_spd_pri4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_2P5G_KX1f_GET(r) ((((r).an_x1_bam_spd_pri4[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_2P5G_KX1f_SET(r,f) (r).an_x1_bam_spd_pri4[0]=(((r).an_x1_bam_spd_pri4[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_1G_KX1f_GET(r) ((((r).an_x1_bam_spd_pri4[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_1G_KX1f_SET(r,f) (r).an_x1_bam_spd_pri4[0]=(((r).an_x1_bam_spd_pri4[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_HG2_KR1f_GET(r) ((((r).an_x1_bam_spd_pri4[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_HG2_KR1f_SET(r,f) (r).an_x1_bam_spd_pri4[0]=(((r).an_x1_bam_spd_pri4[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_KR1f_GET(r) (((r).an_x1_bam_spd_pri4[0]) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_KR1f_SET(r,f) (r).an_x1_bam_spd_pri4[0]=(((r).an_x1_bam_spd_pri4[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_BAM_SPD_PRI4.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r,(_r._an_x1_bam_spd_pri4))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r,(_r._an_x1_bam_spd_pri4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r,(_r._an_x1_bam_spd_pri4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_BAM_SPD_PRI4r BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r
#define AN_X1_BAM_SPD_PRI4r_SIZE BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_t AN_X1_BAM_SPD_PRI4r_t;
#define AN_X1_BAM_SPD_PRI4r_CLR BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_CLR
#define AN_X1_BAM_SPD_PRI4r_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_SET
#define AN_X1_BAM_SPD_PRI4r_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_GET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_5G_KR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_5G_KR1f_GET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_5G_KR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_5G_KR1f_SET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_2P5G_KX1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_2P5G_KX1f_GET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_2P5G_KX1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_2P5G_KX1f_SET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_1G_KX1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_1G_KX1f_GET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_1G_KX1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_1G_KX1f_SET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_HG2_KR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_HG2_KR1f_GET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_HG2_KR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_HG2_KR1f_SET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_KR1f_GET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_KR1f_GET
#define AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_KR1f_SET BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r_AN_PRIORITY_10G_KR1f_SET
#define READ_AN_X1_BAM_SPD_PRI4r BCMI_TSCD_XGXS_READ_AN_X1_BAM_SPD_PRI4r
#define WRITE_AN_X1_BAM_SPD_PRI4r BCMI_TSCD_XGXS_WRITE_AN_X1_BAM_SPD_PRI4r
#define MODIFY_AN_X1_BAM_SPD_PRI4r BCMI_TSCD_XGXS_MODIFY_AN_X1_BAM_SPD_PRI4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_BAM_SPD_PRI4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_IEEE_SPD_PRI1
 * BLOCKS:   AN_X1_CONTROL
 * REGADDR:  0x9247
 * DESC:     IEEE Speed PRIORITY REGISTER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_PRIORITY_25G_CR1_IEEE HCD PRIORITY OVERRIDE FOR PRIORITY 25G_CR1_IEEE SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_25G_CRS1_IEEE HCD PRIORITY OVERRIDE FOR PRIORITY 25G_CRS1_IEEE SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_25G_KR1_IEEE HCD PRIORITY OVERRIDE FOR PRIORITY 25G_KR1_IEEE SPEED.  ZERO MEANS USE HW PRIORITY
 *     AN_PRIORITY_25G_KRS1_IEEE HCD PRIORITY OVERRIDE FOR PRIORITY 25G_KRS1_IEEE SPEED.  ZERO MEANS USE HW PRIORITY
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r (0x00109247 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_IEEE_SPD_PRI1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_s {
	uint32_t v[1];
	uint32_t an_x1_ieee_spd_pri1[1];
	uint32_t _an_x1_ieee_spd_pri1;
} BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_t;

#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_CLR(r) (r).an_x1_ieee_spd_pri1[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_SET(r,d) (r).an_x1_ieee_spd_pri1[0] = d
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_GET(r) (r).an_x1_ieee_spd_pri1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KRS1_IEEEf_GET(r) ((((r).an_x1_ieee_spd_pri1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KRS1_IEEEf_SET(r,f) (r).an_x1_ieee_spd_pri1[0]=(((r).an_x1_ieee_spd_pri1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KR1_IEEEf_GET(r) ((((r).an_x1_ieee_spd_pri1[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KR1_IEEEf_SET(r,f) (r).an_x1_ieee_spd_pri1[0]=(((r).an_x1_ieee_spd_pri1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CRS1_IEEEf_GET(r) ((((r).an_x1_ieee_spd_pri1[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CRS1_IEEEf_SET(r,f) (r).an_x1_ieee_spd_pri1[0]=(((r).an_x1_ieee_spd_pri1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CR1_IEEEf_GET(r) (((r).an_x1_ieee_spd_pri1[0]) & 0x3)
#define BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CR1_IEEEf_SET(r,f) (r).an_x1_ieee_spd_pri1[0]=(((r).an_x1_ieee_spd_pri1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X1_IEEE_SPD_PRI1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_IEEE_SPD_PRI1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r,(_r._an_x1_ieee_spd_pri1))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_IEEE_SPD_PRI1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r,(_r._an_x1_ieee_spd_pri1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_IEEE_SPD_PRI1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r,(_r._an_x1_ieee_spd_pri1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_IEEE_SPD_PRI1r BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r
#define AN_X1_IEEE_SPD_PRI1r_SIZE BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_t AN_X1_IEEE_SPD_PRI1r_t;
#define AN_X1_IEEE_SPD_PRI1r_CLR BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_CLR
#define AN_X1_IEEE_SPD_PRI1r_SET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_SET
#define AN_X1_IEEE_SPD_PRI1r_GET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_GET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KRS1_IEEEf_GET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KRS1_IEEEf_GET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KRS1_IEEEf_SET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KRS1_IEEEf_SET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KR1_IEEEf_GET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KR1_IEEEf_GET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KR1_IEEEf_SET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_KR1_IEEEf_SET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CRS1_IEEEf_GET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CRS1_IEEEf_GET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CRS1_IEEEf_SET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CRS1_IEEEf_SET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CR1_IEEEf_GET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CR1_IEEEf_GET
#define AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CR1_IEEEf_SET BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r_AN_PRIORITY_25G_CR1_IEEEf_SET
#define READ_AN_X1_IEEE_SPD_PRI1r BCMI_TSCD_XGXS_READ_AN_X1_IEEE_SPD_PRI1r
#define WRITE_AN_X1_IEEE_SPD_PRI1r BCMI_TSCD_XGXS_WRITE_AN_X1_IEEE_SPD_PRI1r
#define MODIFY_AN_X1_IEEE_SPD_PRI1r BCMI_TSCD_XGXS_MODIFY_AN_X1_IEEE_SPD_PRI1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_IEEE_SPD_PRI1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_CL73_BRK_LNK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9250
 * DESC:     CL73 AUTO-NEG BREAK-LINK TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_BREAK_TIMER_PERIOD Period/range is 60 tosingle copyCL73 auto-neg break-link timer.  Timer for the amount of time to disable transmission in order to assure that the link parner enters a Link Fail state.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr (0x00109250 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_BRK_LNK.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_brk_lnk[1];
	uint32_t _an_x1_cl73_brk_lnk;
} BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_t;

#define BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_CLR(r) (r).an_x1_cl73_brk_lnk[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_SET(r,d) (r).an_x1_cl73_brk_lnk[0] = d
#define BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_GET(r) (r).an_x1_cl73_brk_lnk[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_brk_lnk[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_brk_lnk[0]=(((r).an_x1_cl73_brk_lnk[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_BRK_LNK.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_CL73_BRK_LNKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr,(_r._an_x1_cl73_brk_lnk))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_BRK_LNKr BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr
#define AN_X1_CL73_BRK_LNKr_SIZE BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_t AN_X1_CL73_BRK_LNKr_t;
#define AN_X1_CL73_BRK_LNKr_CLR BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_CLR
#define AN_X1_CL73_BRK_LNKr_SET BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_SET
#define AN_X1_CL73_BRK_LNKr_GET BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_GET
#define AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_GET BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_GET
#define AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_SET BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr_CL73_BREAK_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_BRK_LNKr BCMI_TSCD_XGXS_READ_AN_X1_CL73_BRK_LNKr
#define WRITE_AN_X1_CL73_BRK_LNKr BCMI_TSCD_XGXS_WRITE_AN_X1_CL73_BRK_LNKr
#define MODIFY_AN_X1_CL73_BRK_LNKr BCMI_TSCD_XGXS_MODIFY_AN_X1_CL73_BRK_LNKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_CL73_BRK_LNKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_CL73_ERR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9251
 * DESC:     CL73 AUTO-NEG TIMEOUT-ERROR TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_ERROR_TIMER_PERIOD Period/range is 20.6 mssingle copyCL73 auto-neg timeout-error timer Timer for the amout ot time to wait to receive a page from the link partner.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_CL73_ERRr (0x00109251 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_ERR.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_err[1];
	uint32_t _an_x1_cl73_err;
} BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_t;

#define BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_CLR(r) (r).an_x1_cl73_err[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_SET(r,d) (r).an_x1_cl73_err[0] = d
#define BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_GET(r) (r).an_x1_cl73_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_err[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_err[0]=(((r).an_x1_cl73_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_ERR.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_CL73_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_CL73_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_CL73_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_ERRr,(_r._an_x1_cl73_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_ERRr BCMI_TSCD_XGXS_AN_X1_CL73_ERRr
#define AN_X1_CL73_ERRr_SIZE BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_t AN_X1_CL73_ERRr_t;
#define AN_X1_CL73_ERRr_CLR BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_CLR
#define AN_X1_CL73_ERRr_SET BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_SET
#define AN_X1_CL73_ERRr_GET BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_GET
#define AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_GET
#define AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET BCMI_TSCD_XGXS_AN_X1_CL73_ERRr_CL73_ERROR_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_ERRr BCMI_TSCD_XGXS_READ_AN_X1_CL73_ERRr
#define WRITE_AN_X1_CL73_ERRr BCMI_TSCD_XGXS_WRITE_AN_X1_CL73_ERRr
#define MODIFY_AN_X1_CL73_ERRr BCMI_TSCD_XGXS_MODIFY_AN_X1_CL73_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_CL73_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_CL73_DME_LOCK
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9252
 * DESC:     CL73 PARALLEL-DETECT DME-CLOCK TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_DME_LOCK_TIMER_PERIOD Period/range is 25 tosingle copyCL73 parallel-detect DME-clock timer Timer for the amount of time to wait before evaluating the DME_locked signal.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr (0x00109252 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_CL73_DME_LOCK.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_s {
	uint32_t v[1];
	uint32_t an_x1_cl73_dme_lock[1];
	uint32_t _an_x1_cl73_dme_lock;
} BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_t;

#define BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_CLR(r) (r).an_x1_cl73_dme_lock[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_SET(r,d) (r).an_x1_cl73_dme_lock[0] = d
#define BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_GET(r) (r).an_x1_cl73_dme_lock[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET(r) (((r).an_x1_cl73_dme_lock[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET(r,f) (r).an_x1_cl73_dme_lock[0]=(((r).an_x1_cl73_dme_lock[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_CL73_DME_LOCK.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_CL73_DME_LOCKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr,(_r._an_x1_cl73_dme_lock))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_CL73_DME_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr,(_r._an_x1_cl73_dme_lock)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_CL73_DME_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr,(_r._an_x1_cl73_dme_lock))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_CL73_DME_LOCKr BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr
#define AN_X1_CL73_DME_LOCKr_SIZE BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_t AN_X1_CL73_DME_LOCKr_t;
#define AN_X1_CL73_DME_LOCKr_CLR BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_CLR
#define AN_X1_CL73_DME_LOCKr_SET BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_SET
#define AN_X1_CL73_DME_LOCKr_GET BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_GET
#define AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_GET
#define AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr_PD_DME_LOCK_TIMER_PERIODf_SET
#define READ_AN_X1_CL73_DME_LOCKr BCMI_TSCD_XGXS_READ_AN_X1_CL73_DME_LOCKr
#define WRITE_AN_X1_CL73_DME_LOCKr BCMI_TSCD_XGXS_WRITE_AN_X1_CL73_DME_LOCKr
#define MODIFY_AN_X1_CL73_DME_LOCKr BCMI_TSCD_XGXS_MODIFY_AN_X1_CL73_DME_LOCKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_CL73_DME_LOCKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_PD_SD_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9253
 * DESC:     PARALLEL-DETECT SIGNAL DETECT TIMER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_SD_TIMER_PERIOD single copyParallel-Detect Signal Detect timer.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr (0x00109253 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_PD_SD_TMR.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_pd_sd_tmr[1];
	uint32_t _an_x1_pd_sd_tmr;
} BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_t;

#define BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_CLR(r) (r).an_x1_pd_sd_tmr[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_SET(r,d) (r).an_x1_pd_sd_tmr[0] = d
#define BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_GET(r) (r).an_x1_pd_sd_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_GET(r) (((r).an_x1_pd_sd_tmr[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_SET(r,f) (r).an_x1_pd_sd_tmr[0]=(((r).an_x1_pd_sd_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_PD_SD_TMR.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_PD_SD_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr,(_r._an_x1_pd_sd_tmr))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_PD_SD_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr,(_r._an_x1_pd_sd_tmr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_PD_SD_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr,(_r._an_x1_pd_sd_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_PD_SD_TMRr BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr
#define AN_X1_PD_SD_TMRr_SIZE BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_t AN_X1_PD_SD_TMRr_t;
#define AN_X1_PD_SD_TMRr_CLR BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_CLR
#define AN_X1_PD_SD_TMRr_SET BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_SET
#define AN_X1_PD_SD_TMRr_GET BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_GET
#define AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_GET BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_GET
#define AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_SET BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr_PD_SD_TIMER_PERIODf_SET
#define READ_AN_X1_PD_SD_TMRr BCMI_TSCD_XGXS_READ_AN_X1_PD_SD_TMRr
#define WRITE_AN_X1_PD_SD_TMRr BCMI_TSCD_XGXS_WRITE_AN_X1_PD_SD_TMRr
#define MODIFY_AN_X1_PD_SD_TMRr BCMI_TSCD_XGXS_MODIFY_AN_X1_PD_SD_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_PD_SD_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_IGNORE_LNK_TMR
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9254
 * DESC:     PERIOD TO IGNORE THE LINK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     IGNORE_LINK_TIMER_PERIOD Period is in tickssingle copyPeriod to ignore the link while CL73 and possibly CL72 are running
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr (0x00109254 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_IGNORE_LNK_TMR.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_s {
	uint32_t v[1];
	uint32_t an_x1_ignore_lnk_tmr[1];
	uint32_t _an_x1_ignore_lnk_tmr;
} BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_t;

#define BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_CLR(r) (r).an_x1_ignore_lnk_tmr[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_SET(r,d) (r).an_x1_ignore_lnk_tmr[0] = d
#define BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_GET(r) (r).an_x1_ignore_lnk_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET(r) (((r).an_x1_ignore_lnk_tmr[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET(r,f) (r).an_x1_ignore_lnk_tmr[0]=(((r).an_x1_ignore_lnk_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_IGNORE_LNK_TMR.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr,(_r._an_x1_ignore_lnk_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_IGNORE_LNK_TMRr BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr
#define AN_X1_IGNORE_LNK_TMRr_SIZE BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_t AN_X1_IGNORE_LNK_TMRr_t;
#define AN_X1_IGNORE_LNK_TMRr_CLR BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_CLR
#define AN_X1_IGNORE_LNK_TMRr_SET BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_SET
#define AN_X1_IGNORE_LNK_TMRr_GET BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_GET
#define AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_GET
#define AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr_IGNORE_LINK_TIMER_PERIODf_SET
#define READ_AN_X1_IGNORE_LNK_TMRr BCMI_TSCD_XGXS_READ_AN_X1_IGNORE_LNK_TMRr
#define WRITE_AN_X1_IGNORE_LNK_TMRr BCMI_TSCD_XGXS_WRITE_AN_X1_IGNORE_LNK_TMRr
#define MODIFY_AN_X1_IGNORE_LNK_TMRr BCMI_TSCD_XGXS_MODIFY_AN_X1_IGNORE_LNK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_IGNORE_LNK_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9255
 * DESC:     TIMER FOR QUALIFYING A LINK_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_CL72_PERIOD Period/range is typically 500mssingle copyTimer for qualifying a link_status==FAIL indication or a link_status==OK indication when a link is first being established and cl72 training is being run.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r (0x00109255 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_CL72.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_cl72[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_cl72;
} BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t;

#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0] = d
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_cl72[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_cl72[0]=(((r).an_x1_lnk_fail_inhbt_tmr_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_CL72.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_cl72))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t AN_X1_LNK_FAIL_INHBT_TMR_CL72r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r_LINK_FAIL_INHIBIT_TIMER_CL72_PERIODf_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCD_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCD_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_CL72r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r BCMI_TSCD_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_CL72r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_CL72r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9256
 * DESC:     Timer FOR QUALIFYING A LINK_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LINK_FAIL_INHIBIT_TIMER_NCL72_PERIOD Period/range is typically 40mssingle copyTimer for qualifying a link_status==FAIL indication or a link_status==OK indication when a link is first being established and cl72 training is not being run.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r (0x00109256 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_s {
	uint32_t v[1];
	uint32_t an_x1_lnk_fail_inhbt_tmr_not_cl72[1];
	uint32_t _an_x1_lnk_fail_inhbt_tmr_not_cl72;
} BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t;

#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET(r,d) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] = d
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET(r) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET(r) (((r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET(r,f) (r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0]=(((r).an_x1_lnk_fail_inhbt_tmr_not_cl72[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r,(_r._an_x1_lnk_fail_inhbt_tmr_not_cl72))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_t;
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_CLR
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_SET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_GET
#define AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r_LINK_FAIL_INHIBIT_TIMER_NCL72_PERIODf_SET
#define READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCD_XGXS_READ_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCD_XGXS_WRITE_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r
#define MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r BCMI_TSCD_XGXS_MODIFY_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_LNK_FAIL_INHBT_TMR_NOT_CL72r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_DME_PAGE_TMR_TYPE
 * BLOCKS:   AN_X1_TIMERS
 * REGADDR:  0x9257
 * DESC:     DME PAGE TIMERS
 * RESETVAL: 0x3b5f (15199)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_PAGE_TEST_MIN_TIMER Specifies the minimum length of a CL73 DME page.  Units are 8 samples.  Each sample represents 0.4 ns
 *     CL73_PAGE_TEST_MAX_TIMER Specifies the maximum length of a CL73 DME page.  Units are 8 samples.  Each sample represents 0.4 ns
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr (0x00109257 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_DME_PAGE_TMR_TYPE.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_s {
	uint32_t v[1];
	uint32_t an_x1_dme_page_tmr_type[1];
	uint32_t _an_x1_dme_page_tmr_type;
} BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_t;

#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CLR(r) (r).an_x1_dme_page_tmr_type[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SET(r,d) (r).an_x1_dme_page_tmr_type[0] = d
#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_GET(r) (r).an_x1_dme_page_tmr_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_GET(r) ((((r).an_x1_dme_page_tmr_type[0]) >> 7) & 0x7f)
#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_SET(r,f) (r).an_x1_dme_page_tmr_type[0]=(((r).an_x1_dme_page_tmr_type[0] & ~((uint32_t)0x7f << 7)) | ((((uint32_t)f) & 0x7f) << 7)) | (127 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_GET(r) (((r).an_x1_dme_page_tmr_type[0]) & 0x7f)
#define BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_SET(r,f) (r).an_x1_dme_page_tmr_type[0]=(((r).an_x1_dme_page_tmr_type[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access AN_X1_DME_PAGE_TMR_TYPE.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_DME_PAGE_TMR_TYPEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr,(_r._an_x1_dme_page_tmr_type))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_DME_PAGE_TMR_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr,(_r._an_x1_dme_page_tmr_type)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_DME_PAGE_TMR_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr,(_r._an_x1_dme_page_tmr_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr
#define AN_X1_DME_PAGE_TMR_TYPEr_SIZE BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_t AN_X1_DME_PAGE_TMR_TYPEr_t;
#define AN_X1_DME_PAGE_TMR_TYPEr_CLR BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CLR
#define AN_X1_DME_PAGE_TMR_TYPEr_SET BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_SET
#define AN_X1_DME_PAGE_TMR_TYPEr_GET BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_GET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_GET BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_GET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_SET BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MAX_TIMERf_SET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_GET BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_GET
#define AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_SET BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr_CL73_PAGE_TEST_MIN_TIMERf_SET
#define READ_AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCD_XGXS_READ_AN_X1_DME_PAGE_TMR_TYPEr
#define WRITE_AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCD_XGXS_WRITE_AN_X1_DME_PAGE_TMR_TYPEr
#define MODIFY_AN_X1_DME_PAGE_TMR_TYPEr BCMI_TSCD_XGXS_MODIFY_AN_X1_DME_PAGE_TMR_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_DME_PAGE_TMR_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_PLL_LOCK_TMR
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9260
 * DESC:     PLL lock timeout period
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_TIMER_PERIOD Period/range is XXX msTimer for the maximin amount of time required for PLL to lockIf PLL is not locked during this period of time,the Speed Control logic will report an error and go to Initial state.The Speed Control logic can be restarted after that by SW or AN.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr (0x00109260 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PLL_LOCK_TMR.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_s {
	uint32_t v[1];
	uint32_t sc_x1_pll_lock_tmr[1];
	uint32_t _sc_x1_pll_lock_tmr;
} BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_t;

#define BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_CLR(r) (r).sc_x1_pll_lock_tmr[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_SET(r,d) (r).sc_x1_pll_lock_tmr[0] = d
#define BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_GET(r) (r).sc_x1_pll_lock_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET(r) (((r).sc_x1_pll_lock_tmr[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET(r,f) (r).sc_x1_pll_lock_tmr[0]=(((r).sc_x1_pll_lock_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_PLL_LOCK_TMR.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_PLL_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_PLL_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_PLL_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr,(_r._sc_x1_pll_lock_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PLL_LOCK_TMRr BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr
#define SC_X1_PLL_LOCK_TMRr_SIZE BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_t SC_X1_PLL_LOCK_TMRr_t;
#define SC_X1_PLL_LOCK_TMRr_CLR BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_CLR
#define SC_X1_PLL_LOCK_TMRr_SET BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_SET
#define SC_X1_PLL_LOCK_TMRr_GET BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_GET
#define SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_GET
#define SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr_PLL_LOCK_TIMER_PERIODf_SET
#define READ_SC_X1_PLL_LOCK_TMRr BCMI_TSCD_XGXS_READ_SC_X1_PLL_LOCK_TMRr
#define WRITE_SC_X1_PLL_LOCK_TMRr BCMI_TSCD_XGXS_WRITE_SC_X1_PLL_LOCK_TMRr
#define MODIFY_SC_X1_PLL_LOCK_TMRr BCMI_TSCD_XGXS_MODIFY_SC_X1_PLL_LOCK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_PLL_LOCK_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_PMD_LOCK_TMR
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9261
 * DESC:     PMD lock timeout period
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LOCK_TIMER_PERIOD Period/range is XXX msTimer for the maximin amount of time required for PMD RX to lockIf PMD RX is not locked during this period of time,the Speed Control logic will report an error and go to Initial state.The Speed Control logic can be restarted after that by SW or AN.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr (0x00109261 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PMD_LOCK_TMR.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_s {
	uint32_t v[1];
	uint32_t sc_x1_pmd_lock_tmr[1];
	uint32_t _sc_x1_pmd_lock_tmr;
} BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_t;

#define BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_CLR(r) (r).sc_x1_pmd_lock_tmr[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_SET(r,d) (r).sc_x1_pmd_lock_tmr[0] = d
#define BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_GET(r) (r).sc_x1_pmd_lock_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET(r) (((r).sc_x1_pmd_lock_tmr[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET(r,f) (r).sc_x1_pmd_lock_tmr[0]=(((r).sc_x1_pmd_lock_tmr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_PMD_LOCK_TMR.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_PMD_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_PMD_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_PMD_LOCK_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr,(_r._sc_x1_pmd_lock_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PMD_LOCK_TMRr BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr
#define SC_X1_PMD_LOCK_TMRr_SIZE BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_t SC_X1_PMD_LOCK_TMRr_t;
#define SC_X1_PMD_LOCK_TMRr_CLR BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_CLR
#define SC_X1_PMD_LOCK_TMRr_SET BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_SET
#define SC_X1_PMD_LOCK_TMRr_GET BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_GET
#define SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_GET
#define SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr_PMD_LOCK_TIMER_PERIODf_SET
#define READ_SC_X1_PMD_LOCK_TMRr BCMI_TSCD_XGXS_READ_SC_X1_PMD_LOCK_TMRr
#define WRITE_SC_X1_PMD_LOCK_TMRr BCMI_TSCD_XGXS_WRITE_SC_X1_PMD_LOCK_TMRr
#define MODIFY_SC_X1_PMD_LOCK_TMRr BCMI_TSCD_XGXS_MODIFY_SC_X1_PMD_LOCK_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_PMD_LOCK_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_PIPE_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9262
 * DESC:     Pipeline reset count
 * RESETVAL: 0xff (255)
 * ACCESS:   R/W
 * FIELDS:
 *     PIPELINE_RESET_COUNT period in clock cyclesCounter for amount of time to keep pipeline in resetduring speed change process
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr (0x00109262 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_PIPE_RST_CNT.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_pipe_rst_cnt[1];
	uint32_t _sc_x1_pipe_rst_cnt;
} BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_t;

#define BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_CLR(r) (r).sc_x1_pipe_rst_cnt[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_SET(r,d) (r).sc_x1_pipe_rst_cnt[0] = d
#define BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_GET(r) (r).sc_x1_pipe_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET(r) (((r).sc_x1_pipe_rst_cnt[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET(r,f) (r).sc_x1_pipe_rst_cnt[0]=(((r).sc_x1_pipe_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_PIPE_RST_CNT.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr,(_r._sc_x1_pipe_rst_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_PIPE_RST_CNTr BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr
#define SC_X1_PIPE_RST_CNTr_SIZE BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_t SC_X1_PIPE_RST_CNTr_t;
#define SC_X1_PIPE_RST_CNTr_CLR BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_CLR
#define SC_X1_PIPE_RST_CNTr_SET BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_SET
#define SC_X1_PIPE_RST_CNTr_GET BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_GET
#define SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr_PIPELINE_RESET_COUNTf_SET
#define READ_SC_X1_PIPE_RST_CNTr BCMI_TSCD_XGXS_READ_SC_X1_PIPE_RST_CNTr
#define WRITE_SC_X1_PIPE_RST_CNTr BCMI_TSCD_XGXS_WRITE_SC_X1_PIPE_RST_CNTr
#define MODIFY_SC_X1_PIPE_RST_CNTr BCMI_TSCD_XGXS_MODIFY_SC_X1_PIPE_RST_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_PIPE_RST_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_TX_RST_CNT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9263
 * DESC:     TX pipeline reset count
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_RESET_COUNT   period in clock cyclesCounter for amount of time to keep txp in reset after pll is lockedduring speed change process
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr (0x00109263 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_TX_RST_CNT.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_s {
	uint32_t v[1];
	uint32_t sc_x1_tx_rst_cnt[1];
	uint32_t _sc_x1_tx_rst_cnt;
} BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_t;

#define BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_CLR(r) (r).sc_x1_tx_rst_cnt[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_SET(r,d) (r).sc_x1_tx_rst_cnt[0] = d
#define BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_GET(r) (r).sc_x1_tx_rst_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET(r) (((r).sc_x1_tx_rst_cnt[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET(r,f) (r).sc_x1_tx_rst_cnt[0]=(((r).sc_x1_tx_rst_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X1_TX_RST_CNT.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_TX_RST_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr,(_r._sc_x1_tx_rst_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_TX_RST_CNTr BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr
#define SC_X1_TX_RST_CNTr_SIZE BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_t SC_X1_TX_RST_CNTr_t;
#define SC_X1_TX_RST_CNTr_CLR BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_CLR
#define SC_X1_TX_RST_CNTr_SET BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_SET
#define SC_X1_TX_RST_CNTr_GET BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_GET
#define SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr_TX_RESET_COUNTf_SET
#define READ_SC_X1_TX_RST_CNTr BCMI_TSCD_XGXS_READ_SC_X1_TX_RST_CNTr
#define WRITE_SC_X1_TX_RST_CNTr BCMI_TSCD_XGXS_WRITE_SC_X1_TX_RST_CNTr
#define MODIFY_SC_X1_TX_RST_CNTr BCMI_TSCD_XGXS_MODIFY_SC_X1_TX_RST_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_TX_RST_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_STS
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9264
 * DESC:     Status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESOLVED_PORT_MODE resolved port mode
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_STSr (0x00109264 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_STSr_s {
	uint32_t v[1];
	uint32_t sc_x1_sts[1];
	uint32_t _sc_x1_sts;
} BCMI_TSCD_XGXS_SC_X1_STSr_t;

#define BCMI_TSCD_XGXS_SC_X1_STSr_CLR(r) (r).sc_x1_sts[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_STSr_SET(r,d) (r).sc_x1_sts[0] = d
#define BCMI_TSCD_XGXS_SC_X1_STSr_GET(r) (r).sc_x1_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_GET(r) (((r).sc_x1_sts[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_SET(r,f) (r).sc_x1_sts[0]=(((r).sc_x1_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_STSr,(_r._sc_x1_sts))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_STSr,(_r._sc_x1_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_STSr,(_r._sc_x1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_STSr BCMI_TSCD_XGXS_SC_X1_STSr
#define SC_X1_STSr_SIZE BCMI_TSCD_XGXS_SC_X1_STSr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_STSr_t SC_X1_STSr_t;
#define SC_X1_STSr_CLR BCMI_TSCD_XGXS_SC_X1_STSr_CLR
#define SC_X1_STSr_SET BCMI_TSCD_XGXS_SC_X1_STSr_SET
#define SC_X1_STSr_GET BCMI_TSCD_XGXS_SC_X1_STSr_GET
#define SC_X1_STSr_RESOLVED_PORT_MODEf_GET BCMI_TSCD_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_GET
#define SC_X1_STSr_RESOLVED_PORT_MODEf_SET BCMI_TSCD_XGXS_SC_X1_STSr_RESOLVED_PORT_MODEf_SET
#define READ_SC_X1_STSr BCMI_TSCD_XGXS_READ_SC_X1_STSr
#define WRITE_SC_X1_STSr BCMI_TSCD_XGXS_WRITE_SC_X1_STSr
#define MODIFY_SC_X1_STSr BCMI_TSCD_XGXS_MODIFY_SC_X1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_ECC_ERR_STS
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9265
 * DESC:     Speed Config Memory ECC Error Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     ERR_EVENT_ADDRESS_SPEED_CFG ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_SPEED_CFG 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_SPEED_CFG 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr (0x00109265 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_ECC_ERR_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_s {
	uint32_t v[1];
	uint32_t sc_x1_ecc_err_sts[1];
	uint32_t _sc_x1_ecc_err_sts;
} BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_t;

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_CLR(r) (r).sc_x1_ecc_err_sts[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_SET(r,d) (r).sc_x1_ecc_err_sts[0] = d
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_GET(r) (r).sc_x1_ecc_err_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_TWO_BIT_ERR_EVENT_SPEED_CFGf_GET(r) ((((r).sc_x1_ecc_err_sts[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_TWO_BIT_ERR_EVENT_SPEED_CFGf_SET(r,f) (r).sc_x1_ecc_err_sts[0]=(((r).sc_x1_ecc_err_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ONE_BIT_ERR_EVENT_SPEED_CFGf_GET(r) ((((r).sc_x1_ecc_err_sts[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ONE_BIT_ERR_EVENT_SPEED_CFGf_SET(r,f) (r).sc_x1_ecc_err_sts[0]=(((r).sc_x1_ecc_err_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ERR_EVENT_ADDRESS_SPEED_CFGf_GET(r) (((r).sc_x1_ecc_err_sts[0]) & 0x3f)
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ERR_EVENT_ADDRESS_SPEED_CFGf_SET(r,f) (r).sc_x1_ecc_err_sts[0]=(((r).sc_x1_ecc_err_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_ECC_ERR_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr,(_r._sc_x1_ecc_err_sts))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr,(_r._sc_x1_ecc_err_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr,(_r._sc_x1_ecc_err_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_ECC_ERR_STSr BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr
#define SC_X1_ECC_ERR_STSr_SIZE BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_t SC_X1_ECC_ERR_STSr_t;
#define SC_X1_ECC_ERR_STSr_CLR BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_CLR
#define SC_X1_ECC_ERR_STSr_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_SET
#define SC_X1_ECC_ERR_STSr_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_GET
#define SC_X1_ECC_ERR_STSr_TWO_BIT_ERR_EVENT_SPEED_CFGf_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_TWO_BIT_ERR_EVENT_SPEED_CFGf_GET
#define SC_X1_ECC_ERR_STSr_TWO_BIT_ERR_EVENT_SPEED_CFGf_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_TWO_BIT_ERR_EVENT_SPEED_CFGf_SET
#define SC_X1_ECC_ERR_STSr_ONE_BIT_ERR_EVENT_SPEED_CFGf_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ONE_BIT_ERR_EVENT_SPEED_CFGf_GET
#define SC_X1_ECC_ERR_STSr_ONE_BIT_ERR_EVENT_SPEED_CFGf_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ONE_BIT_ERR_EVENT_SPEED_CFGf_SET
#define SC_X1_ECC_ERR_STSr_ERR_EVENT_ADDRESS_SPEED_CFGf_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ERR_EVENT_ADDRESS_SPEED_CFGf_GET
#define SC_X1_ECC_ERR_STSr_ERR_EVENT_ADDRESS_SPEED_CFGf_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr_ERR_EVENT_ADDRESS_SPEED_CFGf_SET
#define READ_SC_X1_ECC_ERR_STSr BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_STSr
#define WRITE_SC_X1_ECC_ERR_STSr BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_STSr
#define MODIFY_SC_X1_ECC_ERR_STSr BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_ECC_ERR_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_ECC_ERR_INT_1BIT_STS
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9266
 * DESC:     Speed Config Memory ECC 1bit Error Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SPEED_CFG_1BIT_INT_STATUS Single bit, correctable error detected. Reading this register will clear the interrupt status.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr (0x00109266 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_ECC_ERR_INT_1BIT_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_s {
	uint32_t v[1];
	uint32_t sc_x1_ecc_err_int_1bit_sts[1];
	uint32_t _sc_x1_ecc_err_int_1bit_sts;
} BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_t;

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_CLR(r) (r).sc_x1_ecc_err_int_1bit_sts[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SET(r,d) (r).sc_x1_ecc_err_int_1bit_sts[0] = d
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_GET(r) (r).sc_x1_ecc_err_int_1bit_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SPEED_CFG_1BIT_INT_STATUSf_GET(r) (((r).sc_x1_ecc_err_int_1bit_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SPEED_CFG_1BIT_INT_STATUSf_SET(r,f) (r).sc_x1_ecc_err_int_1bit_sts[0]=(((r).sc_x1_ecc_err_int_1bit_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_ECC_ERR_INT_1BIT_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_1BIT_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr,(_r._sc_x1_ecc_err_int_1bit_sts))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_1BIT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr,(_r._sc_x1_ecc_err_int_1bit_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_1BIT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr,(_r._sc_x1_ecc_err_int_1bit_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_ECC_ERR_INT_1BIT_STSr BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr
#define SC_X1_ECC_ERR_INT_1BIT_STSr_SIZE BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_t SC_X1_ECC_ERR_INT_1BIT_STSr_t;
#define SC_X1_ECC_ERR_INT_1BIT_STSr_CLR BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_CLR
#define SC_X1_ECC_ERR_INT_1BIT_STSr_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SET
#define SC_X1_ECC_ERR_INT_1BIT_STSr_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_GET
#define SC_X1_ECC_ERR_INT_1BIT_STSr_SPEED_CFG_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SPEED_CFG_1BIT_INT_STATUSf_GET
#define SC_X1_ECC_ERR_INT_1BIT_STSr_SPEED_CFG_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr_SPEED_CFG_1BIT_INT_STATUSf_SET
#define READ_SC_X1_ECC_ERR_INT_1BIT_STSr BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_1BIT_STSr
#define WRITE_SC_X1_ECC_ERR_INT_1BIT_STSr BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_1BIT_STSr
#define MODIFY_SC_X1_ECC_ERR_INT_1BIT_STSr BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_1BIT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_1BIT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_ECC_ERR_INT_2BIT_STS
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9267
 * DESC:     Speed Config Memory ECC 1bit Error Interrupt Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SPEED_CFG_2BIT_INT_STATUS Two bit, uncorrectable error detected. Reading this register will clear the interrupt status.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr (0x00109267 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_ECC_ERR_INT_2BIT_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_s {
	uint32_t v[1];
	uint32_t sc_x1_ecc_err_int_2bit_sts[1];
	uint32_t _sc_x1_ecc_err_int_2bit_sts;
} BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_t;

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_CLR(r) (r).sc_x1_ecc_err_int_2bit_sts[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SET(r,d) (r).sc_x1_ecc_err_int_2bit_sts[0] = d
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_GET(r) (r).sc_x1_ecc_err_int_2bit_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SPEED_CFG_2BIT_INT_STATUSf_GET(r) (((r).sc_x1_ecc_err_int_2bit_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SPEED_CFG_2BIT_INT_STATUSf_SET(r,f) (r).sc_x1_ecc_err_int_2bit_sts[0]=(((r).sc_x1_ecc_err_int_2bit_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_ECC_ERR_INT_2BIT_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_2BIT_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr,(_r._sc_x1_ecc_err_int_2bit_sts))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_2BIT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr,(_r._sc_x1_ecc_err_int_2bit_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_2BIT_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr,(_r._sc_x1_ecc_err_int_2bit_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_ECC_ERR_INT_2BIT_STSr BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr
#define SC_X1_ECC_ERR_INT_2BIT_STSr_SIZE BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_t SC_X1_ECC_ERR_INT_2BIT_STSr_t;
#define SC_X1_ECC_ERR_INT_2BIT_STSr_CLR BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_CLR
#define SC_X1_ECC_ERR_INT_2BIT_STSr_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SET
#define SC_X1_ECC_ERR_INT_2BIT_STSr_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_GET
#define SC_X1_ECC_ERR_INT_2BIT_STSr_SPEED_CFG_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SPEED_CFG_2BIT_INT_STATUSf_GET
#define SC_X1_ECC_ERR_INT_2BIT_STSr_SPEED_CFG_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr_SPEED_CFG_2BIT_INT_STATUSf_SET
#define READ_SC_X1_ECC_ERR_INT_2BIT_STSr BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_2BIT_STSr
#define WRITE_SC_X1_ECC_ERR_INT_2BIT_STSr BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_2BIT_STSr
#define MODIFY_SC_X1_ECC_ERR_INT_2BIT_STSr BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_2BIT_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_2BIT_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_ECC_ERR_INT_EN_1BIT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9268
 * DESC:     Speed Config Memory ECC 1bit Error Interrupt Enable
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG_1BIT_INT_EN Enable for correctable error interrupt
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr (0x00109268 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_ECC_ERR_INT_EN_1BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_s {
	uint32_t v[1];
	uint32_t sc_x1_ecc_err_int_en_1bit[1];
	uint32_t _sc_x1_ecc_err_int_en_1bit;
} BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_t;

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_CLR(r) (r).sc_x1_ecc_err_int_en_1bit[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SET(r,d) (r).sc_x1_ecc_err_int_en_1bit[0] = d
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_GET(r) (r).sc_x1_ecc_err_int_en_1bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SPEED_CFG_1BIT_INT_ENf_GET(r) (((r).sc_x1_ecc_err_int_en_1bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SPEED_CFG_1BIT_INT_ENf_SET(r,f) (r).sc_x1_ecc_err_int_en_1bit[0]=(((r).sc_x1_ecc_err_int_en_1bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_ECC_ERR_INT_EN_1BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_EN_1BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr,(_r._sc_x1_ecc_err_int_en_1bit))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_EN_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr,(_r._sc_x1_ecc_err_int_en_1bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_EN_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr,(_r._sc_x1_ecc_err_int_en_1bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_ECC_ERR_INT_EN_1BITr BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr
#define SC_X1_ECC_ERR_INT_EN_1BITr_SIZE BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_t SC_X1_ECC_ERR_INT_EN_1BITr_t;
#define SC_X1_ECC_ERR_INT_EN_1BITr_CLR BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_CLR
#define SC_X1_ECC_ERR_INT_EN_1BITr_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SET
#define SC_X1_ECC_ERR_INT_EN_1BITr_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_GET
#define SC_X1_ECC_ERR_INT_EN_1BITr_SPEED_CFG_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SPEED_CFG_1BIT_INT_ENf_GET
#define SC_X1_ECC_ERR_INT_EN_1BITr_SPEED_CFG_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr_SPEED_CFG_1BIT_INT_ENf_SET
#define READ_SC_X1_ECC_ERR_INT_EN_1BITr BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_EN_1BITr
#define WRITE_SC_X1_ECC_ERR_INT_EN_1BITr BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_EN_1BITr
#define MODIFY_SC_X1_ECC_ERR_INT_EN_1BITr BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_EN_1BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_1BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_ECC_ERR_INT_EN_2BIT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x9269
 * DESC:     Speed Config Memory ECC 1bit Error Interrupt Enable
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG_2BIT_INT_EN Enable for uncorrectable error interrupt
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr (0x00109269 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_ECC_ERR_INT_EN_2BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_s {
	uint32_t v[1];
	uint32_t sc_x1_ecc_err_int_en_2bit[1];
	uint32_t _sc_x1_ecc_err_int_en_2bit;
} BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_t;

#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_CLR(r) (r).sc_x1_ecc_err_int_en_2bit[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SET(r,d) (r).sc_x1_ecc_err_int_en_2bit[0] = d
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_GET(r) (r).sc_x1_ecc_err_int_en_2bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SPEED_CFG_2BIT_INT_ENf_GET(r) (((r).sc_x1_ecc_err_int_en_2bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SPEED_CFG_2BIT_INT_ENf_SET(r,f) (r).sc_x1_ecc_err_int_en_2bit[0]=(((r).sc_x1_ecc_err_int_en_2bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_ECC_ERR_INT_EN_2BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_EN_2BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr,(_r._sc_x1_ecc_err_int_en_2bit))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_EN_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr,(_r._sc_x1_ecc_err_int_en_2bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_EN_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr,(_r._sc_x1_ecc_err_int_en_2bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_ECC_ERR_INT_EN_2BITr BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr
#define SC_X1_ECC_ERR_INT_EN_2BITr_SIZE BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_t SC_X1_ECC_ERR_INT_EN_2BITr_t;
#define SC_X1_ECC_ERR_INT_EN_2BITr_CLR BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_CLR
#define SC_X1_ECC_ERR_INT_EN_2BITr_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SET
#define SC_X1_ECC_ERR_INT_EN_2BITr_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_GET
#define SC_X1_ECC_ERR_INT_EN_2BITr_SPEED_CFG_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SPEED_CFG_2BIT_INT_ENf_GET
#define SC_X1_ECC_ERR_INT_EN_2BITr_SPEED_CFG_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr_SPEED_CFG_2BIT_INT_ENf_SET
#define READ_SC_X1_ECC_ERR_INT_EN_2BITr BCMI_TSCD_XGXS_READ_SC_X1_ECC_ERR_INT_EN_2BITr
#define WRITE_SC_X1_ECC_ERR_INT_EN_2BITr BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_ERR_INT_EN_2BITr
#define MODIFY_SC_X1_ECC_ERR_INT_EN_2BITr BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_ERR_INT_EN_2BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_ECC_ERR_INT_EN_2BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_ECC_DIS
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x926a
 * DESC:     Speed Config Memory ECC 1bit Error Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG_DISABLE_ECC disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_ECC_DISr (0x0010926a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_ECC_DIS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_ECC_DISr_s {
	uint32_t v[1];
	uint32_t sc_x1_ecc_dis[1];
	uint32_t _sc_x1_ecc_dis;
} BCMI_TSCD_XGXS_SC_X1_ECC_DISr_t;

#define BCMI_TSCD_XGXS_SC_X1_ECC_DISr_CLR(r) (r).sc_x1_ecc_dis[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SET(r,d) (r).sc_x1_ecc_dis[0] = d
#define BCMI_TSCD_XGXS_SC_X1_ECC_DISr_GET(r) (r).sc_x1_ecc_dis[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SPEED_CFG_DISABLE_ECCf_GET(r) (((r).sc_x1_ecc_dis[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SPEED_CFG_DISABLE_ECCf_SET(r,f) (r).sc_x1_ecc_dis[0]=(((r).sc_x1_ecc_dis[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_ECC_DIS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_ECC_DISr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_DISr,(_r._sc_x1_ecc_dis))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_DISr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_DISr,(_r._sc_x1_ecc_dis)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_DISr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_DISr,(_r._sc_x1_ecc_dis))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_ECC_DISr BCMI_TSCD_XGXS_SC_X1_ECC_DISr
#define SC_X1_ECC_DISr_SIZE BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_ECC_DISr_t SC_X1_ECC_DISr_t;
#define SC_X1_ECC_DISr_CLR BCMI_TSCD_XGXS_SC_X1_ECC_DISr_CLR
#define SC_X1_ECC_DISr_SET BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SET
#define SC_X1_ECC_DISr_GET BCMI_TSCD_XGXS_SC_X1_ECC_DISr_GET
#define SC_X1_ECC_DISr_SPEED_CFG_DISABLE_ECCf_GET BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SPEED_CFG_DISABLE_ECCf_GET
#define SC_X1_ECC_DISr_SPEED_CFG_DISABLE_ECCf_SET BCMI_TSCD_XGXS_SC_X1_ECC_DISr_SPEED_CFG_DISABLE_ECCf_SET
#define READ_SC_X1_ECC_DISr BCMI_TSCD_XGXS_READ_SC_X1_ECC_DISr
#define WRITE_SC_X1_ECC_DISr BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_DISr
#define MODIFY_SC_X1_ECC_DISr BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_DISr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_ECC_DISr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_ECC_CORRUPT
 * BLOCKS:   SC_X1_CONTROL
 * REGADDR:  0x926b
 * DESC:     Speed Config Memory ECC Corrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPT_ECC_SPEED_CFG ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     SPEED_CFG_MEM_TM Speed config memory TM
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr (0x0010926b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_ECC_CORRUPT.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_s {
	uint32_t v[1];
	uint32_t sc_x1_ecc_corrupt[1];
	uint32_t _sc_x1_ecc_corrupt;
} BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_t;

#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_CLR(r) (r).sc_x1_ecc_corrupt[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SET(r,d) (r).sc_x1_ecc_corrupt[0] = d
#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_GET(r) (r).sc_x1_ecc_corrupt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SPEED_CFG_MEM_TMf_GET(r) ((((r).sc_x1_ecc_corrupt[0]) >> 2) & 0xfff)
#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SPEED_CFG_MEM_TMf_SET(r,f) (r).sc_x1_ecc_corrupt[0]=(((r).sc_x1_ecc_corrupt[0] & ~((uint32_t)0xfff << 2)) | ((((uint32_t)f) & 0xfff) << 2)) | (4095 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_CORRUPT_ECC_SPEED_CFGf_GET(r) (((r).sc_x1_ecc_corrupt[0]) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_CORRUPT_ECC_SPEED_CFGf_SET(r,f) (r).sc_x1_ecc_corrupt[0]=(((r).sc_x1_ecc_corrupt[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access SC_X1_ECC_CORRUPT.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr,(_r._sc_x1_ecc_corrupt))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr,(_r._sc_x1_ecc_corrupt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr,(_r._sc_x1_ecc_corrupt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_ECC_CORRUPTr BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr
#define SC_X1_ECC_CORRUPTr_SIZE BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_t SC_X1_ECC_CORRUPTr_t;
#define SC_X1_ECC_CORRUPTr_CLR BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_CLR
#define SC_X1_ECC_CORRUPTr_SET BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SET
#define SC_X1_ECC_CORRUPTr_GET BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_GET
#define SC_X1_ECC_CORRUPTr_SPEED_CFG_MEM_TMf_GET BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SPEED_CFG_MEM_TMf_GET
#define SC_X1_ECC_CORRUPTr_SPEED_CFG_MEM_TMf_SET BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_SPEED_CFG_MEM_TMf_SET
#define SC_X1_ECC_CORRUPTr_CORRUPT_ECC_SPEED_CFGf_GET BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_CORRUPT_ECC_SPEED_CFGf_GET
#define SC_X1_ECC_CORRUPTr_CORRUPT_ECC_SPEED_CFGf_SET BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr_CORRUPT_ECC_SPEED_CFGf_SET
#define READ_SC_X1_ECC_CORRUPTr BCMI_TSCD_XGXS_READ_SC_X1_ECC_CORRUPTr
#define WRITE_SC_X1_ECC_CORRUPTr BCMI_TSCD_XGXS_WRITE_SC_X1_ECC_CORRUPTr
#define MODIFY_SC_X1_ECC_CORRUPTr BCMI_TSCD_XGXS_MODIFY_SC_X1_ECC_CORRUPTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_ECC_CORRUPTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9270
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes for override configuration0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes
 *     T_PMA_40B_MODE   1'b0 - 66-bit data write in t_pma.1'b1 - 40-bit data write in t_pma.
 *     CL36TX_EN        Per logical lane: cl36 TX pipeline: 1=enabled , 0=disabled
 *     CL36RX_EN        Per logical lane: cl36 RX pipeline: 1=enabled , 0=disabled
 *     CL36RX_10BIT_PMD_DATA_EN Per logical lane: Enables CL36 Rx Pipeline to use all 10-bits of PMD Rx data.This bit should be enabled in OS8.25 mode or 2.5G speed.
 *     SPEED            Actual speed set by SW
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr (0x00109270 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_SPD.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_spd[1];
	uint32_t _sc_x1_spd_ovrr0_spd;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CLR(r) (r).sc_x1_spd_ovrr0_spd[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SET(r,d) (r).sc_x1_spd_ovrr0_spd[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_GET(r) (r).sc_x1_spd_ovrr0_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr0_spd[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_spd[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_spd[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36TX_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_spd[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36TX_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_T_PMA_40B_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_spd[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_T_PMA_40B_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr0_spd[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr0_spd[0]=(((r).sc_x1_spd_ovrr0_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_SPD.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr,(_r._sc_x1_spd_ovrr0_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_SPDr BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr
#define SC_X1_SPD_OVRR0_SPDr_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_t SC_X1_SPD_OVRR0_SPDr_t;
#define SC_X1_SPD_OVRR0_SPDr_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CLR
#define SC_X1_SPD_OVRR0_SPDr_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SET
#define SC_X1_SPD_OVRR0_SPDr_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_GET
#define SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR0_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET
#define SC_X1_SPD_OVRR0_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET
#define SC_X1_SPD_OVRR0_SPDr_CL36RX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_ENf_GET
#define SC_X1_SPD_OVRR0_SPDr_CL36RX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36RX_ENf_SET
#define SC_X1_SPD_OVRR0_SPDr_CL36TX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36TX_ENf_GET
#define SC_X1_SPD_OVRR0_SPDr_CL36TX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_CL36TX_ENf_SET
#define SC_X1_SPD_OVRR0_SPDr_T_PMA_40B_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_T_PMA_40B_MODEf_GET
#define SC_X1_SPD_OVRR0_SPDr_T_PMA_40B_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_T_PMA_40B_MODEf_SET
#define SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR0_SPDr BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_SPDr
#define WRITE_SC_X1_SPD_OVRR0_SPDr BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_SPDr
#define MODIFY_SC_X1_SPD_OVRR0_SPDr BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9272
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SCR_MODE         
 *     T_PMA_BTMX_MODE  Number of PCS lanes bitmuxed
 *     T_HG2_ENABLE     Enables HG2 support for PCS
 *     T_ENC_MODE       
 *     T_FIFO_MODE      T_FIFO stage control field
 *     OS_MODE          
 *     CL72_EN          Enables cl72
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r (0x00109272 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_0[1];
	uint32_t _sc_x1_spd_ovrr0_0;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_CLR(r) (r).sc_x1_spd_ovrr0_0[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SET(r,d) (r).sc_x1_spd_ovrr0_0[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_GET(r) (r).sc_x1_spd_ovrr0_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 11) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_FIFO_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_FIFO_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_ENC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_ENC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_PMA_BTMX_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_PMA_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_0[0]) >> 1) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_0[0]=(((r).sc_x1_spd_ovrr0_0[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r,(_r._sc_x1_spd_ovrr0_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_0r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r
#define SC_X1_SPD_OVRR0_0r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_t SC_X1_SPD_OVRR0_0r_t;
#define SC_X1_SPD_OVRR0_0r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_CLR
#define SC_X1_SPD_OVRR0_0r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SET
#define SC_X1_SPD_OVRR0_0r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_GET
#define SC_X1_SPD_OVRR0_0r_CL72_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENf_GET
#define SC_X1_SPD_OVRR0_0r_CL72_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_CL72_ENf_SET
#define SC_X1_SPD_OVRR0_0r_OS_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_OS_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR0_0r_T_FIFO_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_FIFO_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_T_FIFO_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_FIFO_MODEf_SET
#define SC_X1_SPD_OVRR0_0r_T_ENC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_ENC_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_T_ENC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_ENC_MODEf_SET
#define SC_X1_SPD_OVRR0_0r_T_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR0_0r_T_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR0_0r_T_PMA_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_PMA_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_T_PMA_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_T_PMA_BTMX_MODEf_SET
#define SC_X1_SPD_OVRR0_0r_SCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR0_0r_SCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r_SCR_MODEf_SET
#define READ_SC_X1_SPD_OVRR0_0r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_0r
#define WRITE_SC_X1_SPD_OVRR0_0r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_0r
#define MODIFY_SC_X1_SPD_OVRR0_0r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9273
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BS_BTMX_MODE     Bit-mux mode: Indicates the format of incoming data on a physical lane.
 *     BS_DIST_MODE     Block to lane distribution mode.BS_DIST_MODE_5_LANE_TDM - 5 lane TDM. Each block distributed in turn over output pseudo-logical lanes 0-4BS_DIST_MODE_2_LANE_TDM_2_VLANE - 2 lane TDM for 2 virtual lanes.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.Virtual Lane 1 output is ping-ponged over pseudo-logical lanes 1,3.BS_DIST_MODE_2_LANE_TDM_1_VLANE - 2 lane TDM for 1 virtual lane.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.BS_DIST_MODE_NO_TDM - No TDM. Virtual Lane output is sent directly to corresponding pseudo-logical lane.
 *     BS_SYNC_EN       Enable block synchronization: If enabled, block sync sm will attempt to slip data until sync is achieved.
 *     BS_SM_SYNC_MODE  Block Sync Mode: When bs_sync_en==1, this bit indicates if cl49 or cl82 state machine operation is used.1'b0 - Clause 821'b1 - Clause 49
 *     DEC_FSM_MODE     
 *     DESKEW_MODE      
 *     DEC_TL_MODE      
 *     DESCR_MODE       
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r (0x00109273 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_1[1];
	uint32_t _sc_x1_spd_ovrr0_1;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_CLR(r) (r).sc_x1_spd_ovrr0_1[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_SET(r,d) (r).sc_x1_spd_ovrr0_1[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_GET(r) (r).sc_x1_spd_ovrr0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_TL_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_TL_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESKEW_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESKEW_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SM_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SM_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SYNC_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SYNC_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_DIST_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_1[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_DIST_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_BTMX_MODEf_GET(r) (((r).sc_x1_spd_ovrr0_1[0]) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_1[0]=(((r).sc_x1_spd_ovrr0_1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r,(_r._sc_x1_spd_ovrr0_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_1r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r
#define SC_X1_SPD_OVRR0_1r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_t SC_X1_SPD_OVRR0_1r_t;
#define SC_X1_SPD_OVRR0_1r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_CLR
#define SC_X1_SPD_OVRR0_1r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_SET
#define SC_X1_SPD_OVRR0_1r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_GET
#define SC_X1_SPD_OVRR0_1r_DESCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESCR_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_DESCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESCR_MODEf_SET
#define SC_X1_SPD_OVRR0_1r_DEC_TL_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_TL_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_DEC_TL_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_TL_MODEf_SET
#define SC_X1_SPD_OVRR0_1r_DESKEW_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESKEW_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_DESKEW_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DESKEW_MODEf_SET
#define SC_X1_SPD_OVRR0_1r_DEC_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_FSM_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_DEC_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_DEC_FSM_MODEf_SET
#define SC_X1_SPD_OVRR0_1r_BS_SM_SYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SM_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_BS_SM_SYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SM_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR0_1r_BS_SYNC_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SYNC_ENf_GET
#define SC_X1_SPD_OVRR0_1r_BS_SYNC_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_SYNC_ENf_SET
#define SC_X1_SPD_OVRR0_1r_BS_DIST_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_DIST_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_BS_DIST_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_DIST_MODEf_SET
#define SC_X1_SPD_OVRR0_1r_BS_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR0_1r_BS_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r_BS_BTMX_MODEf_SET
#define READ_SC_X1_SPD_OVRR0_1r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_1r
#define WRITE_SC_X1_SPD_OVRR0_1r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_1r
#define MODIFY_SC_X1_SPD_OVRR0_1r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9274
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r (0x00109274 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_2[1];
	uint32_t _sc_x1_spd_ovrr0_2;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_CLR(r) (r).sc_x1_spd_ovrr0_2[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_SET(r,d) (r).sc_x1_spd_ovrr0_2[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_GET(r) (r).sc_x1_spd_ovrr0_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr0_2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_2[0]=(((r).sc_x1_spd_ovrr0_2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r,(_r._sc_x1_spd_ovrr0_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_2r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r
#define SC_X1_SPD_OVRR0_2r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_t SC_X1_SPD_OVRR0_2r_t;
#define SC_X1_SPD_OVRR0_2r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_CLR
#define SC_X1_SPD_OVRR0_2r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_SET
#define SC_X1_SPD_OVRR0_2r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_GET
#define SC_X1_SPD_OVRR0_2r_CLOCKCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR0_2r_CLOCKCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR0_2r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_2r
#define WRITE_SC_X1_SPD_OVRR0_2r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_2r
#define MODIFY_SC_X1_SPD_OVRR0_2r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9275
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r (0x00109275 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_3[1];
	uint32_t _sc_x1_spd_ovrr0_3;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_CLR(r) (r).sc_x1_spd_ovrr0_3[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_SET(r,d) (r).sc_x1_spd_ovrr0_3[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_GET(r) (r).sc_x1_spd_ovrr0_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr0_3[0]) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr0_3[0]=(((r).sc_x1_spd_ovrr0_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r,(_r._sc_x1_spd_ovrr0_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_3r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r
#define SC_X1_SPD_OVRR0_3r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_t SC_X1_SPD_OVRR0_3r_t;
#define SC_X1_SPD_OVRR0_3r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_CLR
#define SC_X1_SPD_OVRR0_3r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_SET
#define SC_X1_SPD_OVRR0_3r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_GET
#define SC_X1_SPD_OVRR0_3r_CLOCKCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR0_3r_CLOCKCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR0_3r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_3r
#define WRITE_SC_X1_SPD_OVRR0_3r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_3r
#define MODIFY_SC_X1_SPD_OVRR0_3r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9276
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r (0x00109276 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_4[1];
	uint32_t _sc_x1_spd_ovrr0_4;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_CLR(r) (r).sc_x1_spd_ovrr0_4[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_SET(r,d) (r).sc_x1_spd_ovrr0_4[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_GET(r) (r).sc_x1_spd_ovrr0_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr0_4[0]) >> 6) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr0_4[0]=(((r).sc_x1_spd_ovrr0_4[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr0_4[0]) & 0x3f)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr0_4[0]=(((r).sc_x1_spd_ovrr0_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r,(_r._sc_x1_spd_ovrr0_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_4r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r
#define SC_X1_SPD_OVRR0_4r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_t SC_X1_SPD_OVRR0_4r_t;
#define SC_X1_SPD_OVRR0_4r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_CLR
#define SC_X1_SPD_OVRR0_4r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_SET
#define SC_X1_SPD_OVRR0_4r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_GET
#define SC_X1_SPD_OVRR0_4r_LOOPCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR0_4r_LOOPCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR0_4r_LOOPCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR0_4r_LOOPCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR0_4r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_4r
#define WRITE_SC_X1_SPD_OVRR0_4r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_4r
#define MODIFY_SC_X1_SPD_OVRR0_4r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9277
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r (0x00109277 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_5[1];
	uint32_t _sc_x1_spd_ovrr0_5;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_CLR(r) (r).sc_x1_spd_ovrr0_5[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_SET(r,d) (r).sc_x1_spd_ovrr0_5[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_GET(r) (r).sc_x1_spd_ovrr0_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr0_5[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr0_5[0]=(((r).sc_x1_spd_ovrr0_5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r,(_r._sc_x1_spd_ovrr0_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_5r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r
#define SC_X1_SPD_OVRR0_5r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_t SC_X1_SPD_OVRR0_5r_t;
#define SC_X1_SPD_OVRR0_5r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_CLR
#define SC_X1_SPD_OVRR0_5r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_SET
#define SC_X1_SPD_OVRR0_5r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_GET
#define SC_X1_SPD_OVRR0_5r_MAC_CREDITGENCNTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR0_5r_MAC_CREDITGENCNTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR0_5r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_5r
#define WRITE_SC_X1_SPD_OVRR0_5r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_5r
#define MODIFY_SC_X1_SPD_OVRR0_5r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9278
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     T_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword should be scrambled or not. It should be set to 1 in FC mode.
 *     T_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     T_PMA_CL91_MUX_SEL T_PMA MUX CL91 select.
 *     T_PMA_WATERMARK  T_PMA FIFO watermark. In units of 66-bit blocks.
 *     T_PMA_BITMUX_DELAY T_PMA FIFO delay after watermark is reached (in units of cycles)
 *     AM_SPACING_MUL   
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r (0x00109278 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_6[1];
	uint32_t _sc_x1_spd_ovrr0_6;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_CLR(r) (r).sc_x1_spd_ovrr0_6[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_SET(r,d) (r).sc_x1_spd_ovrr0_6[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_GET(r) (r).sc_x1_spd_ovrr0_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_AM_SPACING_MULf_GET(r) ((((r).sc_x1_spd_ovrr0_6[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_AM_SPACING_MULf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_BITMUX_DELAYf_GET(r) ((((r).sc_x1_spd_ovrr0_6[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_BITMUX_DELAYf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_WATERMARKf_GET(r) ((((r).sc_x1_spd_ovrr0_6[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_WATERMARKf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_CL91_MUX_SELf_GET(r) ((((r).sc_x1_spd_ovrr0_6[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_CL91_MUX_SELf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_6[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_CL91_CW_SCRAMBLEf_GET(r) (((r).sc_x1_spd_ovrr0_6[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr0_6[0]=(((r).sc_x1_spd_ovrr0_6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r,(_r._sc_x1_spd_ovrr0_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_6r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r
#define SC_X1_SPD_OVRR0_6r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_t SC_X1_SPD_OVRR0_6r_t;
#define SC_X1_SPD_OVRR0_6r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_CLR
#define SC_X1_SPD_OVRR0_6r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_SET
#define SC_X1_SPD_OVRR0_6r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_GET
#define SC_X1_SPD_OVRR0_6r_AM_SPACING_MULf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_AM_SPACING_MULf_GET
#define SC_X1_SPD_OVRR0_6r_AM_SPACING_MULf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_AM_SPACING_MULf_SET
#define SC_X1_SPD_OVRR0_6r_T_PMA_BITMUX_DELAYf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_BITMUX_DELAYf_GET
#define SC_X1_SPD_OVRR0_6r_T_PMA_BITMUX_DELAYf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_BITMUX_DELAYf_SET
#define SC_X1_SPD_OVRR0_6r_T_PMA_WATERMARKf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_WATERMARKf_GET
#define SC_X1_SPD_OVRR0_6r_T_PMA_WATERMARKf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_WATERMARKf_SET
#define SC_X1_SPD_OVRR0_6r_T_PMA_CL91_MUX_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_CL91_MUX_SELf_GET
#define SC_X1_SPD_OVRR0_6r_T_PMA_CL91_MUX_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_PMA_CL91_MUX_SELf_SET
#define SC_X1_SPD_OVRR0_6r_T_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR0_6r_T_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR0_6r_T_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR0_6r_T_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r_T_CL91_CW_SCRAMBLEf_SET
#define READ_SC_X1_SPD_OVRR0_6r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_6r
#define WRITE_SC_X1_SPD_OVRR0_6r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_6r
#define MODIFY_SC_X1_SPD_OVRR0_6r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x9279
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_BLKSYNC_MODE 
 *     R_MERGE_MODE     
 *     R_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword needs to be descrambled. Should be enabled for FC mode.
 *     R_TC_IN_MODE     Indicates whether CL91 is turned ON for the port or not.
 *     R_TC_MODE        
 *     R_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     R_TC_OUT_MODE    
 *     R_HG2_ENABLE     Enables HG2 support for PCS
 *     R_AM_LOCK_FSM_MODE 1'b1 - AM lock extension mode is enabled.1'b0 - AM lock extension mode is disabled..
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r (0x00109279 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_7[1];
	uint32_t _sc_x1_spd_ovrr0_7;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_CLR(r) (r).sc_x1_spd_ovrr0_7[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_SET(r,d) (r).sc_x1_spd_ovrr0_7[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_GET(r) (r).sc_x1_spd_ovrr0_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_AM_LOCK_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_AM_LOCK_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_OUT_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_OUT_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_IN_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_IN_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_CL91_CW_SCRAMBLEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_MERGE_MODEf_GET(r) ((((r).sc_x1_spd_ovrr0_7[0]) >> 3) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_MERGE_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_CL91_BLKSYNC_MODEf_GET(r) (((r).sc_x1_spd_ovrr0_7[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_CL91_BLKSYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr0_7[0]=(((r).sc_x1_spd_ovrr0_7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r,(_r._sc_x1_spd_ovrr0_7))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r,(_r._sc_x1_spd_ovrr0_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r,(_r._sc_x1_spd_ovrr0_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_7r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r
#define SC_X1_SPD_OVRR0_7r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_t SC_X1_SPD_OVRR0_7r_t;
#define SC_X1_SPD_OVRR0_7r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_CLR
#define SC_X1_SPD_OVRR0_7r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_SET
#define SC_X1_SPD_OVRR0_7r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_GET
#define SC_X1_SPD_OVRR0_7r_R_AM_LOCK_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_AM_LOCK_FSM_MODEf_GET
#define SC_X1_SPD_OVRR0_7r_R_AM_LOCK_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_AM_LOCK_FSM_MODEf_SET
#define SC_X1_SPD_OVRR0_7r_R_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR0_7r_R_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR0_7r_R_TC_OUT_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_OUT_MODEf_GET
#define SC_X1_SPD_OVRR0_7r_R_TC_OUT_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_OUT_MODEf_SET
#define SC_X1_SPD_OVRR0_7r_R_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR0_7r_R_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR0_7r_R_TC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_MODEf_GET
#define SC_X1_SPD_OVRR0_7r_R_TC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_MODEf_SET
#define SC_X1_SPD_OVRR0_7r_R_TC_IN_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_IN_MODEf_GET
#define SC_X1_SPD_OVRR0_7r_R_TC_IN_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_TC_IN_MODEf_SET
#define SC_X1_SPD_OVRR0_7r_R_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR0_7r_R_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_CL91_CW_SCRAMBLEf_SET
#define SC_X1_SPD_OVRR0_7r_R_MERGE_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_MERGE_MODEf_GET
#define SC_X1_SPD_OVRR0_7r_R_MERGE_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_R_MERGE_MODEf_SET
#define SC_X1_SPD_OVRR0_7r_CL91_BLKSYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_CL91_BLKSYNC_MODEf_GET
#define SC_X1_SPD_OVRR0_7r_CL91_BLKSYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r_CL91_BLKSYNC_MODEf_SET
#define READ_SC_X1_SPD_OVRR0_7r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_7r
#define WRITE_SC_X1_SPD_OVRR0_7r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_7r
#define MODIFY_SC_X1_SPD_OVRR0_7r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR0_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE0
 * REGADDR:  0x927a
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPT_2ND_GROUP Corrupt 2nd group of codeward
 *     CORRUPT_6TH_GROUP Corrupt 6th group of codeward
 *     CL74_SHCORRUPT   Sync Header Corruption for CL74 FEC Error (uncorrectable).0: Only 5 SH, 1: All SH corrupted.
 *     BER_COUNT_SEL    0: select count based on cl49 else based on cl82
 *     BER_WINDOW_SEL   0: select window based on cl49 else based on cl82
 *     USE_100G_AM0     AM0 will be taken from 100G AM
 *     USE_100G_AM123   AM 1, 2, 3 will be taken from 100G AMs
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r (0x0010927a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR0_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr0_8[1];
	uint32_t _sc_x1_spd_ovrr0_8;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CLR(r) (r).sc_x1_spd_ovrr0_8[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_SET(r,d) (r).sc_x1_spd_ovrr0_8[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_GET(r) (r).sc_x1_spd_ovrr0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM123f_GET(r) ((((r).sc_x1_spd_ovrr0_8[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM123f_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM0f_GET(r) ((((r).sc_x1_spd_ovrr0_8[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM0f_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_WINDOW_SELf_GET(r) ((((r).sc_x1_spd_ovrr0_8[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_WINDOW_SELf_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_COUNT_SELf_GET(r) ((((r).sc_x1_spd_ovrr0_8[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_COUNT_SELf_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CL74_SHCORRUPTf_GET(r) ((((r).sc_x1_spd_ovrr0_8[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CL74_SHCORRUPTf_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_6TH_GROUPf_GET(r) ((((r).sc_x1_spd_ovrr0_8[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_6TH_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_2ND_GROUPf_GET(r) (((r).sc_x1_spd_ovrr0_8[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_2ND_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr0_8[0]=(((r).sc_x1_spd_ovrr0_8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR0_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r,(_r._sc_x1_spd_ovrr0_8))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r,(_r._sc_x1_spd_ovrr0_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r,(_r._sc_x1_spd_ovrr0_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR0_8r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r
#define SC_X1_SPD_OVRR0_8r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_t SC_X1_SPD_OVRR0_8r_t;
#define SC_X1_SPD_OVRR0_8r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CLR
#define SC_X1_SPD_OVRR0_8r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_SET
#define SC_X1_SPD_OVRR0_8r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_GET
#define SC_X1_SPD_OVRR0_8r_USE_100G_AM123f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM123f_GET
#define SC_X1_SPD_OVRR0_8r_USE_100G_AM123f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM123f_SET
#define SC_X1_SPD_OVRR0_8r_USE_100G_AM0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM0f_GET
#define SC_X1_SPD_OVRR0_8r_USE_100G_AM0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_USE_100G_AM0f_SET
#define SC_X1_SPD_OVRR0_8r_BER_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_WINDOW_SELf_GET
#define SC_X1_SPD_OVRR0_8r_BER_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_WINDOW_SELf_SET
#define SC_X1_SPD_OVRR0_8r_BER_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_COUNT_SELf_GET
#define SC_X1_SPD_OVRR0_8r_BER_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_BER_COUNT_SELf_SET
#define SC_X1_SPD_OVRR0_8r_CL74_SHCORRUPTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CL74_SHCORRUPTf_GET
#define SC_X1_SPD_OVRR0_8r_CL74_SHCORRUPTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CL74_SHCORRUPTf_SET
#define SC_X1_SPD_OVRR0_8r_CORRUPT_6TH_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_6TH_GROUPf_GET
#define SC_X1_SPD_OVRR0_8r_CORRUPT_6TH_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_6TH_GROUPf_SET
#define SC_X1_SPD_OVRR0_8r_CORRUPT_2ND_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_2ND_GROUPf_GET
#define SC_X1_SPD_OVRR0_8r_CORRUPT_2ND_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r_CORRUPT_2ND_GROUPf_SET
#define READ_SC_X1_SPD_OVRR0_8r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR0_8r
#define WRITE_SC_X1_SPD_OVRR0_8r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR0_8r
#define MODIFY_SC_X1_SPD_OVRR0_8r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR0_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9280
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes for override configuration0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes
 *     T_PMA_40B_MODE   1'b0 - 66-bit data write in t_pma.1'b1 - 40-bit data write in t_pma.
 *     CL36TX_EN        Per logical lane: cl36 TX pipeline: 1=enabled , 0=disabled
 *     CL36RX_EN        Per logical lane: cl36 RX pipeline: 1=enabled , 0=disabled
 *     CL36RX_10BIT_PMD_DATA_EN Per logical lane: Enables CL36 Rx Pipeline to use all 10-bits of PMD Rx data.This bit should be enabled in OS8.25 mode or 2.5G speed.
 *     SPEED            Actual speed set by SW
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr (0x00109280 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_SPD.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_spd[1];
	uint32_t _sc_x1_spd_ovrr1_spd;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CLR(r) (r).sc_x1_spd_ovrr1_spd[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SET(r,d) (r).sc_x1_spd_ovrr1_spd[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_GET(r) (r).sc_x1_spd_ovrr1_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr1_spd[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_spd[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_spd[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36TX_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_spd[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36TX_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_T_PMA_40B_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_spd[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_T_PMA_40B_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr1_spd[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr1_spd[0]=(((r).sc_x1_spd_ovrr1_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_SPD.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr,(_r._sc_x1_spd_ovrr1_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_SPDr BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr
#define SC_X1_SPD_OVRR1_SPDr_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_t SC_X1_SPD_OVRR1_SPDr_t;
#define SC_X1_SPD_OVRR1_SPDr_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CLR
#define SC_X1_SPD_OVRR1_SPDr_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SET
#define SC_X1_SPD_OVRR1_SPDr_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_GET
#define SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR1_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET
#define SC_X1_SPD_OVRR1_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET
#define SC_X1_SPD_OVRR1_SPDr_CL36RX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_ENf_GET
#define SC_X1_SPD_OVRR1_SPDr_CL36RX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36RX_ENf_SET
#define SC_X1_SPD_OVRR1_SPDr_CL36TX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36TX_ENf_GET
#define SC_X1_SPD_OVRR1_SPDr_CL36TX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_CL36TX_ENf_SET
#define SC_X1_SPD_OVRR1_SPDr_T_PMA_40B_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_T_PMA_40B_MODEf_GET
#define SC_X1_SPD_OVRR1_SPDr_T_PMA_40B_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_T_PMA_40B_MODEf_SET
#define SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR1_SPDr BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_SPDr
#define WRITE_SC_X1_SPD_OVRR1_SPDr BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_SPDr
#define MODIFY_SC_X1_SPD_OVRR1_SPDr BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9282
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SCR_MODE         
 *     T_PMA_BTMX_MODE  Number of PCS lanes bitmuxed
 *     T_HG2_ENABLE     Enables HG2 support for PCS
 *     T_ENC_MODE       
 *     T_FIFO_MODE      T_FIFO stage control field
 *     OS_MODE          
 *     CL72_EN          Enables cl72
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r (0x00109282 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_0[1];
	uint32_t _sc_x1_spd_ovrr1_0;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_CLR(r) (r).sc_x1_spd_ovrr1_0[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SET(r,d) (r).sc_x1_spd_ovrr1_0[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_GET(r) (r).sc_x1_spd_ovrr1_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 11) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_FIFO_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_FIFO_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_ENC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_ENC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_PMA_BTMX_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_PMA_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_0[0]) >> 1) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_0[0]=(((r).sc_x1_spd_ovrr1_0[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r,(_r._sc_x1_spd_ovrr1_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_0r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r
#define SC_X1_SPD_OVRR1_0r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_t SC_X1_SPD_OVRR1_0r_t;
#define SC_X1_SPD_OVRR1_0r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_CLR
#define SC_X1_SPD_OVRR1_0r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SET
#define SC_X1_SPD_OVRR1_0r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_GET
#define SC_X1_SPD_OVRR1_0r_CL72_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENf_GET
#define SC_X1_SPD_OVRR1_0r_CL72_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_CL72_ENf_SET
#define SC_X1_SPD_OVRR1_0r_OS_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_OS_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR1_0r_T_FIFO_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_FIFO_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_T_FIFO_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_FIFO_MODEf_SET
#define SC_X1_SPD_OVRR1_0r_T_ENC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_ENC_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_T_ENC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_ENC_MODEf_SET
#define SC_X1_SPD_OVRR1_0r_T_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR1_0r_T_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR1_0r_T_PMA_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_PMA_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_T_PMA_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_T_PMA_BTMX_MODEf_SET
#define SC_X1_SPD_OVRR1_0r_SCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR1_0r_SCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r_SCR_MODEf_SET
#define READ_SC_X1_SPD_OVRR1_0r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_0r
#define WRITE_SC_X1_SPD_OVRR1_0r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_0r
#define MODIFY_SC_X1_SPD_OVRR1_0r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9283
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BS_BTMX_MODE     Bit-mux mode: Indicates the format of incoming data on a physical lane.
 *     BS_DIST_MODE     Block to lane distribution mode.BS_DIST_MODE_5_LANE_TDM - 5 lane TDM. Each block distributed in turn over output pseudo-logical lanes 0-4BS_DIST_MODE_2_LANE_TDM_2_VLANE - 2 lane TDM for 2 virtual lanes.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.Virtual Lane 1 output is ping-ponged over pseudo-logical lanes 1,3.BS_DIST_MODE_2_LANE_TDM_1_VLANE - 2 lane TDM for 1 virtual lane.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.BS_DIST_MODE_NO_TDM - No TDM. Virtual Lane output is sent directly to corresponding pseudo-logical lane.
 *     BS_SYNC_EN       Enable block synchronization: If enabled, block sync sm will attempt to slip data until sync is achieved.
 *     BS_SM_SYNC_MODE  Block Sync Mode: When bs_sync_en==1, this bit indicates if cl49 or cl82 state machine operation is used.1'b0 - Clause 821'b1 - Clause 49
 *     DEC_FSM_MODE     
 *     DESKEW_MODE      
 *     DEC_TL_MODE      
 *     DESCR_MODE       
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r (0x00109283 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_1[1];
	uint32_t _sc_x1_spd_ovrr1_1;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_CLR(r) (r).sc_x1_spd_ovrr1_1[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_SET(r,d) (r).sc_x1_spd_ovrr1_1[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_GET(r) (r).sc_x1_spd_ovrr1_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_TL_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_TL_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESKEW_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESKEW_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SM_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SM_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SYNC_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SYNC_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_DIST_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_1[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_DIST_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_BTMX_MODEf_GET(r) (((r).sc_x1_spd_ovrr1_1[0]) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_1[0]=(((r).sc_x1_spd_ovrr1_1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r,(_r._sc_x1_spd_ovrr1_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_1r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r
#define SC_X1_SPD_OVRR1_1r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_t SC_X1_SPD_OVRR1_1r_t;
#define SC_X1_SPD_OVRR1_1r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_CLR
#define SC_X1_SPD_OVRR1_1r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_SET
#define SC_X1_SPD_OVRR1_1r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_GET
#define SC_X1_SPD_OVRR1_1r_DESCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESCR_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_DESCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESCR_MODEf_SET
#define SC_X1_SPD_OVRR1_1r_DEC_TL_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_TL_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_DEC_TL_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_TL_MODEf_SET
#define SC_X1_SPD_OVRR1_1r_DESKEW_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESKEW_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_DESKEW_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DESKEW_MODEf_SET
#define SC_X1_SPD_OVRR1_1r_DEC_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_FSM_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_DEC_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_DEC_FSM_MODEf_SET
#define SC_X1_SPD_OVRR1_1r_BS_SM_SYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SM_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_BS_SM_SYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SM_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR1_1r_BS_SYNC_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SYNC_ENf_GET
#define SC_X1_SPD_OVRR1_1r_BS_SYNC_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_SYNC_ENf_SET
#define SC_X1_SPD_OVRR1_1r_BS_DIST_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_DIST_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_BS_DIST_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_DIST_MODEf_SET
#define SC_X1_SPD_OVRR1_1r_BS_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR1_1r_BS_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r_BS_BTMX_MODEf_SET
#define READ_SC_X1_SPD_OVRR1_1r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_1r
#define WRITE_SC_X1_SPD_OVRR1_1r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_1r
#define MODIFY_SC_X1_SPD_OVRR1_1r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9284
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r (0x00109284 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_2[1];
	uint32_t _sc_x1_spd_ovrr1_2;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_CLR(r) (r).sc_x1_spd_ovrr1_2[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_SET(r,d) (r).sc_x1_spd_ovrr1_2[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_GET(r) (r).sc_x1_spd_ovrr1_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr1_2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_2[0]=(((r).sc_x1_spd_ovrr1_2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r,(_r._sc_x1_spd_ovrr1_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_2r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r
#define SC_X1_SPD_OVRR1_2r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_t SC_X1_SPD_OVRR1_2r_t;
#define SC_X1_SPD_OVRR1_2r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_CLR
#define SC_X1_SPD_OVRR1_2r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_SET
#define SC_X1_SPD_OVRR1_2r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_GET
#define SC_X1_SPD_OVRR1_2r_CLOCKCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR1_2r_CLOCKCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR1_2r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_2r
#define WRITE_SC_X1_SPD_OVRR1_2r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_2r
#define MODIFY_SC_X1_SPD_OVRR1_2r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9285
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r (0x00109285 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_3[1];
	uint32_t _sc_x1_spd_ovrr1_3;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_CLR(r) (r).sc_x1_spd_ovrr1_3[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_SET(r,d) (r).sc_x1_spd_ovrr1_3[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_GET(r) (r).sc_x1_spd_ovrr1_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr1_3[0]) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr1_3[0]=(((r).sc_x1_spd_ovrr1_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r,(_r._sc_x1_spd_ovrr1_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_3r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r
#define SC_X1_SPD_OVRR1_3r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_t SC_X1_SPD_OVRR1_3r_t;
#define SC_X1_SPD_OVRR1_3r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_CLR
#define SC_X1_SPD_OVRR1_3r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_SET
#define SC_X1_SPD_OVRR1_3r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_GET
#define SC_X1_SPD_OVRR1_3r_CLOCKCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR1_3r_CLOCKCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR1_3r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_3r
#define WRITE_SC_X1_SPD_OVRR1_3r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_3r
#define MODIFY_SC_X1_SPD_OVRR1_3r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9286
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r (0x00109286 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_4[1];
	uint32_t _sc_x1_spd_ovrr1_4;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_CLR(r) (r).sc_x1_spd_ovrr1_4[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_SET(r,d) (r).sc_x1_spd_ovrr1_4[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_GET(r) (r).sc_x1_spd_ovrr1_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr1_4[0]) >> 6) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr1_4[0]=(((r).sc_x1_spd_ovrr1_4[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr1_4[0]) & 0x3f)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr1_4[0]=(((r).sc_x1_spd_ovrr1_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r,(_r._sc_x1_spd_ovrr1_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_4r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r
#define SC_X1_SPD_OVRR1_4r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_t SC_X1_SPD_OVRR1_4r_t;
#define SC_X1_SPD_OVRR1_4r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_CLR
#define SC_X1_SPD_OVRR1_4r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_SET
#define SC_X1_SPD_OVRR1_4r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_GET
#define SC_X1_SPD_OVRR1_4r_LOOPCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR1_4r_LOOPCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR1_4r_LOOPCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR1_4r_LOOPCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR1_4r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_4r
#define WRITE_SC_X1_SPD_OVRR1_4r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_4r
#define MODIFY_SC_X1_SPD_OVRR1_4r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9287
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r (0x00109287 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_5[1];
	uint32_t _sc_x1_spd_ovrr1_5;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_CLR(r) (r).sc_x1_spd_ovrr1_5[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_SET(r,d) (r).sc_x1_spd_ovrr1_5[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_GET(r) (r).sc_x1_spd_ovrr1_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr1_5[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr1_5[0]=(((r).sc_x1_spd_ovrr1_5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r,(_r._sc_x1_spd_ovrr1_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_5r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r
#define SC_X1_SPD_OVRR1_5r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_t SC_X1_SPD_OVRR1_5r_t;
#define SC_X1_SPD_OVRR1_5r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_CLR
#define SC_X1_SPD_OVRR1_5r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_SET
#define SC_X1_SPD_OVRR1_5r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_GET
#define SC_X1_SPD_OVRR1_5r_MAC_CREDITGENCNTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR1_5r_MAC_CREDITGENCNTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR1_5r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_5r
#define WRITE_SC_X1_SPD_OVRR1_5r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_5r
#define MODIFY_SC_X1_SPD_OVRR1_5r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9288
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     T_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword should be scrambled or not. It should be set to 1 in FC mode.
 *     T_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     T_PMA_CL91_MUX_SEL T_PMA MUX CL91 select.
 *     T_PMA_WATERMARK  T_PMA FIFO watermark. In units of 66-bit blocks.
 *     T_PMA_BITMUX_DELAY T_PMA FIFO delay after watermark is reached (in units of cycles)
 *     AM_SPACING_MUL   
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r (0x00109288 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_6[1];
	uint32_t _sc_x1_spd_ovrr1_6;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_CLR(r) (r).sc_x1_spd_ovrr1_6[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_SET(r,d) (r).sc_x1_spd_ovrr1_6[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_GET(r) (r).sc_x1_spd_ovrr1_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_AM_SPACING_MULf_GET(r) ((((r).sc_x1_spd_ovrr1_6[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_AM_SPACING_MULf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_BITMUX_DELAYf_GET(r) ((((r).sc_x1_spd_ovrr1_6[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_BITMUX_DELAYf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_WATERMARKf_GET(r) ((((r).sc_x1_spd_ovrr1_6[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_WATERMARKf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_CL91_MUX_SELf_GET(r) ((((r).sc_x1_spd_ovrr1_6[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_CL91_MUX_SELf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_6[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_CL91_CW_SCRAMBLEf_GET(r) (((r).sc_x1_spd_ovrr1_6[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr1_6[0]=(((r).sc_x1_spd_ovrr1_6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r,(_r._sc_x1_spd_ovrr1_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_6r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r
#define SC_X1_SPD_OVRR1_6r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_t SC_X1_SPD_OVRR1_6r_t;
#define SC_X1_SPD_OVRR1_6r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_CLR
#define SC_X1_SPD_OVRR1_6r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_SET
#define SC_X1_SPD_OVRR1_6r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_GET
#define SC_X1_SPD_OVRR1_6r_AM_SPACING_MULf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_AM_SPACING_MULf_GET
#define SC_X1_SPD_OVRR1_6r_AM_SPACING_MULf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_AM_SPACING_MULf_SET
#define SC_X1_SPD_OVRR1_6r_T_PMA_BITMUX_DELAYf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_BITMUX_DELAYf_GET
#define SC_X1_SPD_OVRR1_6r_T_PMA_BITMUX_DELAYf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_BITMUX_DELAYf_SET
#define SC_X1_SPD_OVRR1_6r_T_PMA_WATERMARKf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_WATERMARKf_GET
#define SC_X1_SPD_OVRR1_6r_T_PMA_WATERMARKf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_WATERMARKf_SET
#define SC_X1_SPD_OVRR1_6r_T_PMA_CL91_MUX_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_CL91_MUX_SELf_GET
#define SC_X1_SPD_OVRR1_6r_T_PMA_CL91_MUX_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_PMA_CL91_MUX_SELf_SET
#define SC_X1_SPD_OVRR1_6r_T_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR1_6r_T_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR1_6r_T_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR1_6r_T_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r_T_CL91_CW_SCRAMBLEf_SET
#define READ_SC_X1_SPD_OVRR1_6r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_6r
#define WRITE_SC_X1_SPD_OVRR1_6r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_6r
#define MODIFY_SC_X1_SPD_OVRR1_6r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x9289
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_BLKSYNC_MODE 
 *     R_MERGE_MODE     
 *     R_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword needs to be descrambled. Should be enabled for FC mode.
 *     R_TC_IN_MODE     Indicates whether CL91 is turned ON for the port or not.
 *     R_TC_MODE        
 *     R_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     R_TC_OUT_MODE    
 *     R_HG2_ENABLE     Enables HG2 support for PCS
 *     R_AM_LOCK_FSM_MODE 1'b1 - AM lock extension mode is enabled.1'b0 - AM lock extension mode is disabled..
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r (0x00109289 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_7[1];
	uint32_t _sc_x1_spd_ovrr1_7;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_CLR(r) (r).sc_x1_spd_ovrr1_7[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_SET(r,d) (r).sc_x1_spd_ovrr1_7[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_GET(r) (r).sc_x1_spd_ovrr1_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_AM_LOCK_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_AM_LOCK_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_OUT_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_OUT_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_IN_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_IN_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_CL91_CW_SCRAMBLEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_MERGE_MODEf_GET(r) ((((r).sc_x1_spd_ovrr1_7[0]) >> 3) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_MERGE_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_CL91_BLKSYNC_MODEf_GET(r) (((r).sc_x1_spd_ovrr1_7[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_CL91_BLKSYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr1_7[0]=(((r).sc_x1_spd_ovrr1_7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r,(_r._sc_x1_spd_ovrr1_7))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r,(_r._sc_x1_spd_ovrr1_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r,(_r._sc_x1_spd_ovrr1_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_7r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r
#define SC_X1_SPD_OVRR1_7r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_t SC_X1_SPD_OVRR1_7r_t;
#define SC_X1_SPD_OVRR1_7r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_CLR
#define SC_X1_SPD_OVRR1_7r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_SET
#define SC_X1_SPD_OVRR1_7r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_GET
#define SC_X1_SPD_OVRR1_7r_R_AM_LOCK_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_AM_LOCK_FSM_MODEf_GET
#define SC_X1_SPD_OVRR1_7r_R_AM_LOCK_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_AM_LOCK_FSM_MODEf_SET
#define SC_X1_SPD_OVRR1_7r_R_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR1_7r_R_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR1_7r_R_TC_OUT_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_OUT_MODEf_GET
#define SC_X1_SPD_OVRR1_7r_R_TC_OUT_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_OUT_MODEf_SET
#define SC_X1_SPD_OVRR1_7r_R_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR1_7r_R_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR1_7r_R_TC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_MODEf_GET
#define SC_X1_SPD_OVRR1_7r_R_TC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_MODEf_SET
#define SC_X1_SPD_OVRR1_7r_R_TC_IN_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_IN_MODEf_GET
#define SC_X1_SPD_OVRR1_7r_R_TC_IN_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_TC_IN_MODEf_SET
#define SC_X1_SPD_OVRR1_7r_R_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR1_7r_R_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_CL91_CW_SCRAMBLEf_SET
#define SC_X1_SPD_OVRR1_7r_R_MERGE_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_MERGE_MODEf_GET
#define SC_X1_SPD_OVRR1_7r_R_MERGE_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_R_MERGE_MODEf_SET
#define SC_X1_SPD_OVRR1_7r_CL91_BLKSYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_CL91_BLKSYNC_MODEf_GET
#define SC_X1_SPD_OVRR1_7r_CL91_BLKSYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r_CL91_BLKSYNC_MODEf_SET
#define READ_SC_X1_SPD_OVRR1_7r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_7r
#define WRITE_SC_X1_SPD_OVRR1_7r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_7r
#define MODIFY_SC_X1_SPD_OVRR1_7r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR1_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE1
 * REGADDR:  0x928a
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPT_2ND_GROUP Corrupt 2nd group of codeward
 *     CORRUPT_6TH_GROUP Corrupt 6th group of codeward
 *     CL74_SHCORRUPT   Sync Header Corruption for CL74 FEC Error (uncorrectable).0: Only 5 SH, 1: All SH corrupted.
 *     BER_COUNT_SEL    0: select count based on cl49 else based on cl82
 *     BER_WINDOW_SEL   0: select window based on cl49 else based on cl82
 *     USE_100G_AM0     AM0 will be taken from 100G AM
 *     USE_100G_AM123   AM 1, 2, 3 will be taken from 100G AMs
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r (0x0010928a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR1_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr1_8[1];
	uint32_t _sc_x1_spd_ovrr1_8;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CLR(r) (r).sc_x1_spd_ovrr1_8[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_SET(r,d) (r).sc_x1_spd_ovrr1_8[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_GET(r) (r).sc_x1_spd_ovrr1_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM123f_GET(r) ((((r).sc_x1_spd_ovrr1_8[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM123f_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM0f_GET(r) ((((r).sc_x1_spd_ovrr1_8[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM0f_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_WINDOW_SELf_GET(r) ((((r).sc_x1_spd_ovrr1_8[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_WINDOW_SELf_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_COUNT_SELf_GET(r) ((((r).sc_x1_spd_ovrr1_8[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_COUNT_SELf_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CL74_SHCORRUPTf_GET(r) ((((r).sc_x1_spd_ovrr1_8[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CL74_SHCORRUPTf_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_6TH_GROUPf_GET(r) ((((r).sc_x1_spd_ovrr1_8[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_6TH_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_2ND_GROUPf_GET(r) (((r).sc_x1_spd_ovrr1_8[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_2ND_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr1_8[0]=(((r).sc_x1_spd_ovrr1_8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR1_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r,(_r._sc_x1_spd_ovrr1_8))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r,(_r._sc_x1_spd_ovrr1_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r,(_r._sc_x1_spd_ovrr1_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR1_8r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r
#define SC_X1_SPD_OVRR1_8r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_t SC_X1_SPD_OVRR1_8r_t;
#define SC_X1_SPD_OVRR1_8r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CLR
#define SC_X1_SPD_OVRR1_8r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_SET
#define SC_X1_SPD_OVRR1_8r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_GET
#define SC_X1_SPD_OVRR1_8r_USE_100G_AM123f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM123f_GET
#define SC_X1_SPD_OVRR1_8r_USE_100G_AM123f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM123f_SET
#define SC_X1_SPD_OVRR1_8r_USE_100G_AM0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM0f_GET
#define SC_X1_SPD_OVRR1_8r_USE_100G_AM0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_USE_100G_AM0f_SET
#define SC_X1_SPD_OVRR1_8r_BER_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_WINDOW_SELf_GET
#define SC_X1_SPD_OVRR1_8r_BER_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_WINDOW_SELf_SET
#define SC_X1_SPD_OVRR1_8r_BER_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_COUNT_SELf_GET
#define SC_X1_SPD_OVRR1_8r_BER_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_BER_COUNT_SELf_SET
#define SC_X1_SPD_OVRR1_8r_CL74_SHCORRUPTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CL74_SHCORRUPTf_GET
#define SC_X1_SPD_OVRR1_8r_CL74_SHCORRUPTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CL74_SHCORRUPTf_SET
#define SC_X1_SPD_OVRR1_8r_CORRUPT_6TH_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_6TH_GROUPf_GET
#define SC_X1_SPD_OVRR1_8r_CORRUPT_6TH_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_6TH_GROUPf_SET
#define SC_X1_SPD_OVRR1_8r_CORRUPT_2ND_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_2ND_GROUPf_GET
#define SC_X1_SPD_OVRR1_8r_CORRUPT_2ND_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r_CORRUPT_2ND_GROUPf_SET
#define READ_SC_X1_SPD_OVRR1_8r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR1_8r
#define WRITE_SC_X1_SPD_OVRR1_8r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR1_8r
#define MODIFY_SC_X1_SPD_OVRR1_8r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR1_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR1_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9290
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes for override configuration0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes
 *     T_PMA_40B_MODE   1'b0 - 66-bit data write in t_pma.1'b1 - 40-bit data write in t_pma.
 *     CL36TX_EN        Per logical lane: cl36 TX pipeline: 1=enabled , 0=disabled
 *     CL36RX_EN        Per logical lane: cl36 RX pipeline: 1=enabled , 0=disabled
 *     CL36RX_10BIT_PMD_DATA_EN Per logical lane: Enables CL36 Rx Pipeline to use all 10-bits of PMD Rx data.This bit should be enabled in OS8.25 mode or 2.5G speed.
 *     SPEED            Actual speed set by SW
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr (0x00109290 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_SPD.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_spd[1];
	uint32_t _sc_x1_spd_ovrr2_spd;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CLR(r) (r).sc_x1_spd_ovrr2_spd[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SET(r,d) (r).sc_x1_spd_ovrr2_spd[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_GET(r) (r).sc_x1_spd_ovrr2_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr2_spd[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_spd[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_spd[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36TX_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_spd[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36TX_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_T_PMA_40B_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_spd[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_T_PMA_40B_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr2_spd[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr2_spd[0]=(((r).sc_x1_spd_ovrr2_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_SPD.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr,(_r._sc_x1_spd_ovrr2_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_SPDr BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr
#define SC_X1_SPD_OVRR2_SPDr_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_t SC_X1_SPD_OVRR2_SPDr_t;
#define SC_X1_SPD_OVRR2_SPDr_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CLR
#define SC_X1_SPD_OVRR2_SPDr_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SET
#define SC_X1_SPD_OVRR2_SPDr_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_GET
#define SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR2_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET
#define SC_X1_SPD_OVRR2_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET
#define SC_X1_SPD_OVRR2_SPDr_CL36RX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_ENf_GET
#define SC_X1_SPD_OVRR2_SPDr_CL36RX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36RX_ENf_SET
#define SC_X1_SPD_OVRR2_SPDr_CL36TX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36TX_ENf_GET
#define SC_X1_SPD_OVRR2_SPDr_CL36TX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_CL36TX_ENf_SET
#define SC_X1_SPD_OVRR2_SPDr_T_PMA_40B_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_T_PMA_40B_MODEf_GET
#define SC_X1_SPD_OVRR2_SPDr_T_PMA_40B_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_T_PMA_40B_MODEf_SET
#define SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR2_SPDr BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_SPDr
#define WRITE_SC_X1_SPD_OVRR2_SPDr BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_SPDr
#define MODIFY_SC_X1_SPD_OVRR2_SPDr BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9292
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SCR_MODE         
 *     T_PMA_BTMX_MODE  Number of PCS lanes bitmuxed
 *     T_HG2_ENABLE     Enables HG2 support for PCS
 *     T_ENC_MODE       
 *     T_FIFO_MODE      T_FIFO stage control field
 *     OS_MODE          
 *     CL72_EN          Enables cl72
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r (0x00109292 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_0[1];
	uint32_t _sc_x1_spd_ovrr2_0;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_CLR(r) (r).sc_x1_spd_ovrr2_0[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SET(r,d) (r).sc_x1_spd_ovrr2_0[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_GET(r) (r).sc_x1_spd_ovrr2_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 11) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_FIFO_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_FIFO_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_ENC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_ENC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_PMA_BTMX_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_PMA_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_0[0]) >> 1) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_0[0]=(((r).sc_x1_spd_ovrr2_0[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r,(_r._sc_x1_spd_ovrr2_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_0r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r
#define SC_X1_SPD_OVRR2_0r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_t SC_X1_SPD_OVRR2_0r_t;
#define SC_X1_SPD_OVRR2_0r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_CLR
#define SC_X1_SPD_OVRR2_0r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SET
#define SC_X1_SPD_OVRR2_0r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_GET
#define SC_X1_SPD_OVRR2_0r_CL72_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENf_GET
#define SC_X1_SPD_OVRR2_0r_CL72_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_CL72_ENf_SET
#define SC_X1_SPD_OVRR2_0r_OS_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_OS_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR2_0r_T_FIFO_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_FIFO_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_T_FIFO_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_FIFO_MODEf_SET
#define SC_X1_SPD_OVRR2_0r_T_ENC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_ENC_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_T_ENC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_ENC_MODEf_SET
#define SC_X1_SPD_OVRR2_0r_T_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR2_0r_T_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR2_0r_T_PMA_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_PMA_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_T_PMA_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_T_PMA_BTMX_MODEf_SET
#define SC_X1_SPD_OVRR2_0r_SCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR2_0r_SCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r_SCR_MODEf_SET
#define READ_SC_X1_SPD_OVRR2_0r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_0r
#define WRITE_SC_X1_SPD_OVRR2_0r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_0r
#define MODIFY_SC_X1_SPD_OVRR2_0r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9293
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BS_BTMX_MODE     Bit-mux mode: Indicates the format of incoming data on a physical lane.
 *     BS_DIST_MODE     Block to lane distribution mode.BS_DIST_MODE_5_LANE_TDM - 5 lane TDM. Each block distributed in turn over output pseudo-logical lanes 0-4BS_DIST_MODE_2_LANE_TDM_2_VLANE - 2 lane TDM for 2 virtual lanes.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.Virtual Lane 1 output is ping-ponged over pseudo-logical lanes 1,3.BS_DIST_MODE_2_LANE_TDM_1_VLANE - 2 lane TDM for 1 virtual lane.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.BS_DIST_MODE_NO_TDM - No TDM. Virtual Lane output is sent directly to corresponding pseudo-logical lane.
 *     BS_SYNC_EN       Enable block synchronization: If enabled, block sync sm will attempt to slip data until sync is achieved.
 *     BS_SM_SYNC_MODE  Block Sync Mode: When bs_sync_en==1, this bit indicates if cl49 or cl82 state machine operation is used.1'b0 - Clause 821'b1 - Clause 49
 *     DEC_FSM_MODE     
 *     DESKEW_MODE      
 *     DEC_TL_MODE      
 *     DESCR_MODE       
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r (0x00109293 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_1[1];
	uint32_t _sc_x1_spd_ovrr2_1;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_CLR(r) (r).sc_x1_spd_ovrr2_1[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_SET(r,d) (r).sc_x1_spd_ovrr2_1[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_GET(r) (r).sc_x1_spd_ovrr2_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_TL_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_TL_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESKEW_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESKEW_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SM_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SM_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SYNC_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SYNC_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_DIST_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_1[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_DIST_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_BTMX_MODEf_GET(r) (((r).sc_x1_spd_ovrr2_1[0]) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_1[0]=(((r).sc_x1_spd_ovrr2_1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r,(_r._sc_x1_spd_ovrr2_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_1r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r
#define SC_X1_SPD_OVRR2_1r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_t SC_X1_SPD_OVRR2_1r_t;
#define SC_X1_SPD_OVRR2_1r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_CLR
#define SC_X1_SPD_OVRR2_1r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_SET
#define SC_X1_SPD_OVRR2_1r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_GET
#define SC_X1_SPD_OVRR2_1r_DESCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESCR_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_DESCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESCR_MODEf_SET
#define SC_X1_SPD_OVRR2_1r_DEC_TL_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_TL_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_DEC_TL_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_TL_MODEf_SET
#define SC_X1_SPD_OVRR2_1r_DESKEW_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESKEW_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_DESKEW_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DESKEW_MODEf_SET
#define SC_X1_SPD_OVRR2_1r_DEC_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_FSM_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_DEC_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_DEC_FSM_MODEf_SET
#define SC_X1_SPD_OVRR2_1r_BS_SM_SYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SM_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_BS_SM_SYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SM_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR2_1r_BS_SYNC_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SYNC_ENf_GET
#define SC_X1_SPD_OVRR2_1r_BS_SYNC_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_SYNC_ENf_SET
#define SC_X1_SPD_OVRR2_1r_BS_DIST_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_DIST_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_BS_DIST_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_DIST_MODEf_SET
#define SC_X1_SPD_OVRR2_1r_BS_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR2_1r_BS_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r_BS_BTMX_MODEf_SET
#define READ_SC_X1_SPD_OVRR2_1r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_1r
#define WRITE_SC_X1_SPD_OVRR2_1r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_1r
#define MODIFY_SC_X1_SPD_OVRR2_1r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9294
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r (0x00109294 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_2[1];
	uint32_t _sc_x1_spd_ovrr2_2;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_CLR(r) (r).sc_x1_spd_ovrr2_2[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_SET(r,d) (r).sc_x1_spd_ovrr2_2[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_GET(r) (r).sc_x1_spd_ovrr2_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr2_2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_2[0]=(((r).sc_x1_spd_ovrr2_2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r,(_r._sc_x1_spd_ovrr2_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_2r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r
#define SC_X1_SPD_OVRR2_2r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_t SC_X1_SPD_OVRR2_2r_t;
#define SC_X1_SPD_OVRR2_2r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_CLR
#define SC_X1_SPD_OVRR2_2r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_SET
#define SC_X1_SPD_OVRR2_2r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_GET
#define SC_X1_SPD_OVRR2_2r_CLOCKCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR2_2r_CLOCKCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR2_2r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_2r
#define WRITE_SC_X1_SPD_OVRR2_2r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_2r
#define MODIFY_SC_X1_SPD_OVRR2_2r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9295
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r (0x00109295 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_3[1];
	uint32_t _sc_x1_spd_ovrr2_3;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_CLR(r) (r).sc_x1_spd_ovrr2_3[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_SET(r,d) (r).sc_x1_spd_ovrr2_3[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_GET(r) (r).sc_x1_spd_ovrr2_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr2_3[0]) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr2_3[0]=(((r).sc_x1_spd_ovrr2_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r,(_r._sc_x1_spd_ovrr2_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_3r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r
#define SC_X1_SPD_OVRR2_3r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_t SC_X1_SPD_OVRR2_3r_t;
#define SC_X1_SPD_OVRR2_3r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_CLR
#define SC_X1_SPD_OVRR2_3r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_SET
#define SC_X1_SPD_OVRR2_3r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_GET
#define SC_X1_SPD_OVRR2_3r_CLOCKCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR2_3r_CLOCKCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR2_3r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_3r
#define WRITE_SC_X1_SPD_OVRR2_3r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_3r
#define MODIFY_SC_X1_SPD_OVRR2_3r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9296
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r (0x00109296 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_4[1];
	uint32_t _sc_x1_spd_ovrr2_4;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_CLR(r) (r).sc_x1_spd_ovrr2_4[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_SET(r,d) (r).sc_x1_spd_ovrr2_4[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_GET(r) (r).sc_x1_spd_ovrr2_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr2_4[0]) >> 6) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr2_4[0]=(((r).sc_x1_spd_ovrr2_4[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr2_4[0]) & 0x3f)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr2_4[0]=(((r).sc_x1_spd_ovrr2_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r,(_r._sc_x1_spd_ovrr2_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_4r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r
#define SC_X1_SPD_OVRR2_4r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_t SC_X1_SPD_OVRR2_4r_t;
#define SC_X1_SPD_OVRR2_4r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_CLR
#define SC_X1_SPD_OVRR2_4r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_SET
#define SC_X1_SPD_OVRR2_4r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_GET
#define SC_X1_SPD_OVRR2_4r_LOOPCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR2_4r_LOOPCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR2_4r_LOOPCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR2_4r_LOOPCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR2_4r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_4r
#define WRITE_SC_X1_SPD_OVRR2_4r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_4r
#define MODIFY_SC_X1_SPD_OVRR2_4r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9297
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r (0x00109297 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_5[1];
	uint32_t _sc_x1_spd_ovrr2_5;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_CLR(r) (r).sc_x1_spd_ovrr2_5[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_SET(r,d) (r).sc_x1_spd_ovrr2_5[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_GET(r) (r).sc_x1_spd_ovrr2_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr2_5[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr2_5[0]=(((r).sc_x1_spd_ovrr2_5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r,(_r._sc_x1_spd_ovrr2_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_5r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r
#define SC_X1_SPD_OVRR2_5r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_t SC_X1_SPD_OVRR2_5r_t;
#define SC_X1_SPD_OVRR2_5r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_CLR
#define SC_X1_SPD_OVRR2_5r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_SET
#define SC_X1_SPD_OVRR2_5r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_GET
#define SC_X1_SPD_OVRR2_5r_MAC_CREDITGENCNTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR2_5r_MAC_CREDITGENCNTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR2_5r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_5r
#define WRITE_SC_X1_SPD_OVRR2_5r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_5r
#define MODIFY_SC_X1_SPD_OVRR2_5r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9298
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     T_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword should be scrambled or not. It should be set to 1 in FC mode.
 *     T_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     T_PMA_CL91_MUX_SEL T_PMA MUX CL91 select.
 *     T_PMA_WATERMARK  T_PMA FIFO watermark. In units of 66-bit blocks.
 *     T_PMA_BITMUX_DELAY T_PMA FIFO delay after watermark is reached (in units of cycles)
 *     AM_SPACING_MUL   
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r (0x00109298 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_6[1];
	uint32_t _sc_x1_spd_ovrr2_6;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_CLR(r) (r).sc_x1_spd_ovrr2_6[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_SET(r,d) (r).sc_x1_spd_ovrr2_6[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_GET(r) (r).sc_x1_spd_ovrr2_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_AM_SPACING_MULf_GET(r) ((((r).sc_x1_spd_ovrr2_6[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_AM_SPACING_MULf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_BITMUX_DELAYf_GET(r) ((((r).sc_x1_spd_ovrr2_6[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_BITMUX_DELAYf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_WATERMARKf_GET(r) ((((r).sc_x1_spd_ovrr2_6[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_WATERMARKf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_CL91_MUX_SELf_GET(r) ((((r).sc_x1_spd_ovrr2_6[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_CL91_MUX_SELf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_6[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_CL91_CW_SCRAMBLEf_GET(r) (((r).sc_x1_spd_ovrr2_6[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr2_6[0]=(((r).sc_x1_spd_ovrr2_6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r,(_r._sc_x1_spd_ovrr2_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_6r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r
#define SC_X1_SPD_OVRR2_6r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_t SC_X1_SPD_OVRR2_6r_t;
#define SC_X1_SPD_OVRR2_6r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_CLR
#define SC_X1_SPD_OVRR2_6r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_SET
#define SC_X1_SPD_OVRR2_6r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_GET
#define SC_X1_SPD_OVRR2_6r_AM_SPACING_MULf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_AM_SPACING_MULf_GET
#define SC_X1_SPD_OVRR2_6r_AM_SPACING_MULf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_AM_SPACING_MULf_SET
#define SC_X1_SPD_OVRR2_6r_T_PMA_BITMUX_DELAYf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_BITMUX_DELAYf_GET
#define SC_X1_SPD_OVRR2_6r_T_PMA_BITMUX_DELAYf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_BITMUX_DELAYf_SET
#define SC_X1_SPD_OVRR2_6r_T_PMA_WATERMARKf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_WATERMARKf_GET
#define SC_X1_SPD_OVRR2_6r_T_PMA_WATERMARKf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_WATERMARKf_SET
#define SC_X1_SPD_OVRR2_6r_T_PMA_CL91_MUX_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_CL91_MUX_SELf_GET
#define SC_X1_SPD_OVRR2_6r_T_PMA_CL91_MUX_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_PMA_CL91_MUX_SELf_SET
#define SC_X1_SPD_OVRR2_6r_T_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR2_6r_T_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR2_6r_T_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR2_6r_T_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r_T_CL91_CW_SCRAMBLEf_SET
#define READ_SC_X1_SPD_OVRR2_6r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_6r
#define WRITE_SC_X1_SPD_OVRR2_6r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_6r
#define MODIFY_SC_X1_SPD_OVRR2_6r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x9299
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_BLKSYNC_MODE 
 *     R_MERGE_MODE     
 *     R_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword needs to be descrambled. Should be enabled for FC mode.
 *     R_TC_IN_MODE     Indicates whether CL91 is turned ON for the port or not.
 *     R_TC_MODE        
 *     R_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     R_TC_OUT_MODE    
 *     R_HG2_ENABLE     Enables HG2 support for PCS
 *     R_AM_LOCK_FSM_MODE 1'b1 - AM lock extension mode is enabled.1'b0 - AM lock extension mode is disabled..
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r (0x00109299 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_7[1];
	uint32_t _sc_x1_spd_ovrr2_7;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_CLR(r) (r).sc_x1_spd_ovrr2_7[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_SET(r,d) (r).sc_x1_spd_ovrr2_7[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_GET(r) (r).sc_x1_spd_ovrr2_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_AM_LOCK_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_AM_LOCK_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_OUT_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_OUT_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_IN_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_IN_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_CL91_CW_SCRAMBLEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_MERGE_MODEf_GET(r) ((((r).sc_x1_spd_ovrr2_7[0]) >> 3) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_MERGE_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_CL91_BLKSYNC_MODEf_GET(r) (((r).sc_x1_spd_ovrr2_7[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_CL91_BLKSYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr2_7[0]=(((r).sc_x1_spd_ovrr2_7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r,(_r._sc_x1_spd_ovrr2_7))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r,(_r._sc_x1_spd_ovrr2_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r,(_r._sc_x1_spd_ovrr2_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_7r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r
#define SC_X1_SPD_OVRR2_7r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_t SC_X1_SPD_OVRR2_7r_t;
#define SC_X1_SPD_OVRR2_7r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_CLR
#define SC_X1_SPD_OVRR2_7r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_SET
#define SC_X1_SPD_OVRR2_7r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_GET
#define SC_X1_SPD_OVRR2_7r_R_AM_LOCK_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_AM_LOCK_FSM_MODEf_GET
#define SC_X1_SPD_OVRR2_7r_R_AM_LOCK_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_AM_LOCK_FSM_MODEf_SET
#define SC_X1_SPD_OVRR2_7r_R_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR2_7r_R_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR2_7r_R_TC_OUT_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_OUT_MODEf_GET
#define SC_X1_SPD_OVRR2_7r_R_TC_OUT_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_OUT_MODEf_SET
#define SC_X1_SPD_OVRR2_7r_R_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR2_7r_R_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR2_7r_R_TC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_MODEf_GET
#define SC_X1_SPD_OVRR2_7r_R_TC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_MODEf_SET
#define SC_X1_SPD_OVRR2_7r_R_TC_IN_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_IN_MODEf_GET
#define SC_X1_SPD_OVRR2_7r_R_TC_IN_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_TC_IN_MODEf_SET
#define SC_X1_SPD_OVRR2_7r_R_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR2_7r_R_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_CL91_CW_SCRAMBLEf_SET
#define SC_X1_SPD_OVRR2_7r_R_MERGE_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_MERGE_MODEf_GET
#define SC_X1_SPD_OVRR2_7r_R_MERGE_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_R_MERGE_MODEf_SET
#define SC_X1_SPD_OVRR2_7r_CL91_BLKSYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_CL91_BLKSYNC_MODEf_GET
#define SC_X1_SPD_OVRR2_7r_CL91_BLKSYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r_CL91_BLKSYNC_MODEf_SET
#define READ_SC_X1_SPD_OVRR2_7r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_7r
#define WRITE_SC_X1_SPD_OVRR2_7r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_7r
#define MODIFY_SC_X1_SPD_OVRR2_7r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR2_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE2
 * REGADDR:  0x929a
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPT_2ND_GROUP Corrupt 2nd group of codeward
 *     CORRUPT_6TH_GROUP Corrupt 6th group of codeward
 *     CL74_SHCORRUPT   Sync Header Corruption for CL74 FEC Error (uncorrectable).0: Only 5 SH, 1: All SH corrupted.
 *     BER_COUNT_SEL    0: select count based on cl49 else based on cl82
 *     BER_WINDOW_SEL   0: select window based on cl49 else based on cl82
 *     USE_100G_AM0     AM0 will be taken from 100G AM
 *     USE_100G_AM123   AM 1, 2, 3 will be taken from 100G AMs
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r (0x0010929a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR2_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr2_8[1];
	uint32_t _sc_x1_spd_ovrr2_8;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CLR(r) (r).sc_x1_spd_ovrr2_8[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_SET(r,d) (r).sc_x1_spd_ovrr2_8[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_GET(r) (r).sc_x1_spd_ovrr2_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM123f_GET(r) ((((r).sc_x1_spd_ovrr2_8[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM123f_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM0f_GET(r) ((((r).sc_x1_spd_ovrr2_8[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM0f_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_WINDOW_SELf_GET(r) ((((r).sc_x1_spd_ovrr2_8[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_WINDOW_SELf_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_COUNT_SELf_GET(r) ((((r).sc_x1_spd_ovrr2_8[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_COUNT_SELf_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CL74_SHCORRUPTf_GET(r) ((((r).sc_x1_spd_ovrr2_8[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CL74_SHCORRUPTf_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_6TH_GROUPf_GET(r) ((((r).sc_x1_spd_ovrr2_8[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_6TH_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_2ND_GROUPf_GET(r) (((r).sc_x1_spd_ovrr2_8[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_2ND_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr2_8[0]=(((r).sc_x1_spd_ovrr2_8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR2_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r,(_r._sc_x1_spd_ovrr2_8))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r,(_r._sc_x1_spd_ovrr2_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r,(_r._sc_x1_spd_ovrr2_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR2_8r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r
#define SC_X1_SPD_OVRR2_8r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_t SC_X1_SPD_OVRR2_8r_t;
#define SC_X1_SPD_OVRR2_8r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CLR
#define SC_X1_SPD_OVRR2_8r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_SET
#define SC_X1_SPD_OVRR2_8r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_GET
#define SC_X1_SPD_OVRR2_8r_USE_100G_AM123f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM123f_GET
#define SC_X1_SPD_OVRR2_8r_USE_100G_AM123f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM123f_SET
#define SC_X1_SPD_OVRR2_8r_USE_100G_AM0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM0f_GET
#define SC_X1_SPD_OVRR2_8r_USE_100G_AM0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_USE_100G_AM0f_SET
#define SC_X1_SPD_OVRR2_8r_BER_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_WINDOW_SELf_GET
#define SC_X1_SPD_OVRR2_8r_BER_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_WINDOW_SELf_SET
#define SC_X1_SPD_OVRR2_8r_BER_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_COUNT_SELf_GET
#define SC_X1_SPD_OVRR2_8r_BER_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_BER_COUNT_SELf_SET
#define SC_X1_SPD_OVRR2_8r_CL74_SHCORRUPTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CL74_SHCORRUPTf_GET
#define SC_X1_SPD_OVRR2_8r_CL74_SHCORRUPTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CL74_SHCORRUPTf_SET
#define SC_X1_SPD_OVRR2_8r_CORRUPT_6TH_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_6TH_GROUPf_GET
#define SC_X1_SPD_OVRR2_8r_CORRUPT_6TH_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_6TH_GROUPf_SET
#define SC_X1_SPD_OVRR2_8r_CORRUPT_2ND_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_2ND_GROUPf_GET
#define SC_X1_SPD_OVRR2_8r_CORRUPT_2ND_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r_CORRUPT_2ND_GROUPf_SET
#define READ_SC_X1_SPD_OVRR2_8r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR2_8r
#define WRITE_SC_X1_SPD_OVRR2_8r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR2_8r
#define MODIFY_SC_X1_SPD_OVRR2_8r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR2_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR2_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_SPD
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a0
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES        Number of lanes for override configuration0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes
 *     T_PMA_40B_MODE   1'b0 - 66-bit data write in t_pma.1'b1 - 40-bit data write in t_pma.
 *     CL36TX_EN        Per logical lane: cl36 TX pipeline: 1=enabled , 0=disabled
 *     CL36RX_EN        Per logical lane: cl36 RX pipeline: 1=enabled , 0=disabled
 *     CL36RX_10BIT_PMD_DATA_EN Per logical lane: Enables CL36 Rx Pipeline to use all 10-bits of PMD Rx data.This bit should be enabled in OS8.25 mode or 2.5G speed.
 *     SPEED            Actual speed set by SW
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr (0x001092a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_SPD.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_spd[1];
	uint32_t _sc_x1_spd_ovrr3_spd;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CLR(r) (r).sc_x1_spd_ovrr3_spd[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SET(r,d) (r).sc_x1_spd_ovrr3_spd[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_GET(r) (r).sc_x1_spd_ovrr3_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET(r) ((((r).sc_x1_spd_ovrr3_spd[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_spd[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_spd[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36TX_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_spd[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36TX_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_T_PMA_40B_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_spd[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_T_PMA_40B_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_GET(r) (((r).sc_x1_spd_ovrr3_spd[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_SET(r,f) (r).sc_x1_spd_ovrr3_spd[0]=(((r).sc_x1_spd_ovrr3_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_SPD.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr,(_r._sc_x1_spd_ovrr3_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_SPDr BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr
#define SC_X1_SPD_OVRR3_SPDr_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_t SC_X1_SPD_OVRR3_SPDr_t;
#define SC_X1_SPD_OVRR3_SPDr_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CLR
#define SC_X1_SPD_OVRR3_SPDr_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SET
#define SC_X1_SPD_OVRR3_SPDr_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_GET
#define SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_GET
#define SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_SPEEDf_SET
#define SC_X1_SPD_OVRR3_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET
#define SC_X1_SPD_OVRR3_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET
#define SC_X1_SPD_OVRR3_SPDr_CL36RX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_ENf_GET
#define SC_X1_SPD_OVRR3_SPDr_CL36RX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36RX_ENf_SET
#define SC_X1_SPD_OVRR3_SPDr_CL36TX_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36TX_ENf_GET
#define SC_X1_SPD_OVRR3_SPDr_CL36TX_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_CL36TX_ENf_SET
#define SC_X1_SPD_OVRR3_SPDr_T_PMA_40B_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_T_PMA_40B_MODEf_GET
#define SC_X1_SPD_OVRR3_SPDr_T_PMA_40B_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_T_PMA_40B_MODEf_SET
#define SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_GET
#define SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr_NUM_LANESf_SET
#define READ_SC_X1_SPD_OVRR3_SPDr BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_SPDr
#define WRITE_SC_X1_SPD_OVRR3_SPDr BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_SPDr
#define MODIFY_SC_X1_SPD_OVRR3_SPDr BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_0
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a2
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SCR_MODE         
 *     T_PMA_BTMX_MODE  Number of PCS lanes bitmuxed
 *     T_HG2_ENABLE     Enables HG2 support for PCS
 *     T_ENC_MODE       
 *     T_FIFO_MODE      T_FIFO stage control field
 *     OS_MODE          
 *     CL72_EN          Enables cl72
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r (0x001092a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_0[1];
	uint32_t _sc_x1_spd_ovrr3_0;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_CLR(r) (r).sc_x1_spd_ovrr3_0[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SET(r,d) (r).sc_x1_spd_ovrr3_0[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_GET(r) (r).sc_x1_spd_ovrr3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 11) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_FIFO_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_FIFO_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_ENC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_ENC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_PMA_BTMX_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_PMA_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_0[0]) >> 1) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_0[0]=(((r).sc_x1_spd_ovrr3_0[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r,(_r._sc_x1_spd_ovrr3_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_0r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r
#define SC_X1_SPD_OVRR3_0r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_t SC_X1_SPD_OVRR3_0r_t;
#define SC_X1_SPD_OVRR3_0r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_CLR
#define SC_X1_SPD_OVRR3_0r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SET
#define SC_X1_SPD_OVRR3_0r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_GET
#define SC_X1_SPD_OVRR3_0r_CL72_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENf_GET
#define SC_X1_SPD_OVRR3_0r_CL72_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_CL72_ENf_SET
#define SC_X1_SPD_OVRR3_0r_OS_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_OS_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_OS_MODEf_SET
#define SC_X1_SPD_OVRR3_0r_T_FIFO_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_FIFO_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_T_FIFO_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_FIFO_MODEf_SET
#define SC_X1_SPD_OVRR3_0r_T_ENC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_ENC_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_T_ENC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_ENC_MODEf_SET
#define SC_X1_SPD_OVRR3_0r_T_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR3_0r_T_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR3_0r_T_PMA_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_PMA_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_T_PMA_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_T_PMA_BTMX_MODEf_SET
#define SC_X1_SPD_OVRR3_0r_SCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_GET
#define SC_X1_SPD_OVRR3_0r_SCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r_SCR_MODEf_SET
#define READ_SC_X1_SPD_OVRR3_0r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_0r
#define WRITE_SC_X1_SPD_OVRR3_0r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_0r
#define MODIFY_SC_X1_SPD_OVRR3_0r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_1
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a3
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BS_BTMX_MODE     Bit-mux mode: Indicates the format of incoming data on a physical lane.
 *     BS_DIST_MODE     Block to lane distribution mode.BS_DIST_MODE_5_LANE_TDM - 5 lane TDM. Each block distributed in turn over output pseudo-logical lanes 0-4BS_DIST_MODE_2_LANE_TDM_2_VLANE - 2 lane TDM for 2 virtual lanes.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.Virtual Lane 1 output is ping-ponged over pseudo-logical lanes 1,3.BS_DIST_MODE_2_LANE_TDM_1_VLANE - 2 lane TDM for 1 virtual lane.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.BS_DIST_MODE_NO_TDM - No TDM. Virtual Lane output is sent directly to corresponding pseudo-logical lane.
 *     BS_SYNC_EN       Enable block synchronization: If enabled, block sync sm will attempt to slip data until sync is achieved.
 *     BS_SM_SYNC_MODE  Block Sync Mode: When bs_sync_en==1, this bit indicates if cl49 or cl82 state machine operation is used.1'b0 - Clause 821'b1 - Clause 49
 *     DEC_FSM_MODE     
 *     DESKEW_MODE      
 *     DEC_TL_MODE      
 *     DESCR_MODE       
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r (0x001092a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_1[1];
	uint32_t _sc_x1_spd_ovrr3_1;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_CLR(r) (r).sc_x1_spd_ovrr3_1[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_SET(r,d) (r).sc_x1_spd_ovrr3_1[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_GET(r) (r).sc_x1_spd_ovrr3_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESCR_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESCR_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_TL_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_TL_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESKEW_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESKEW_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SM_SYNC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SM_SYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SYNC_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SYNC_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_DIST_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_1[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_DIST_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_BTMX_MODEf_GET(r) (((r).sc_x1_spd_ovrr3_1[0]) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_BTMX_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_1[0]=(((r).sc_x1_spd_ovrr3_1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r,(_r._sc_x1_spd_ovrr3_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_1r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r
#define SC_X1_SPD_OVRR3_1r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_t SC_X1_SPD_OVRR3_1r_t;
#define SC_X1_SPD_OVRR3_1r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_CLR
#define SC_X1_SPD_OVRR3_1r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_SET
#define SC_X1_SPD_OVRR3_1r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_GET
#define SC_X1_SPD_OVRR3_1r_DESCR_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESCR_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_DESCR_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESCR_MODEf_SET
#define SC_X1_SPD_OVRR3_1r_DEC_TL_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_TL_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_DEC_TL_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_TL_MODEf_SET
#define SC_X1_SPD_OVRR3_1r_DESKEW_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESKEW_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_DESKEW_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DESKEW_MODEf_SET
#define SC_X1_SPD_OVRR3_1r_DEC_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_FSM_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_DEC_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_DEC_FSM_MODEf_SET
#define SC_X1_SPD_OVRR3_1r_BS_SM_SYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SM_SYNC_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_BS_SM_SYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SM_SYNC_MODEf_SET
#define SC_X1_SPD_OVRR3_1r_BS_SYNC_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SYNC_ENf_GET
#define SC_X1_SPD_OVRR3_1r_BS_SYNC_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_SYNC_ENf_SET
#define SC_X1_SPD_OVRR3_1r_BS_DIST_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_DIST_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_BS_DIST_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_DIST_MODEf_SET
#define SC_X1_SPD_OVRR3_1r_BS_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_BTMX_MODEf_GET
#define SC_X1_SPD_OVRR3_1r_BS_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r_BS_BTMX_MODEf_SET
#define READ_SC_X1_SPD_OVRR3_1r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_1r
#define WRITE_SC_X1_SPD_OVRR3_1r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_1r
#define MODIFY_SC_X1_SPD_OVRR3_1r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_2
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a4
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r (0x001092a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_2[1];
	uint32_t _sc_x1_spd_ovrr3_2;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_CLR(r) (r).sc_x1_spd_ovrr3_2[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_SET(r,d) (r).sc_x1_spd_ovrr3_2[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_GET(r) (r).sc_x1_spd_ovrr3_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT0f_GET(r) (((r).sc_x1_spd_ovrr3_2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_2[0]=(((r).sc_x1_spd_ovrr3_2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r,(_r._sc_x1_spd_ovrr3_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_2r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r
#define SC_X1_SPD_OVRR3_2r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_t SC_X1_SPD_OVRR3_2r_t;
#define SC_X1_SPD_OVRR3_2r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_CLR
#define SC_X1_SPD_OVRR3_2r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_SET
#define SC_X1_SPD_OVRR3_2r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_GET
#define SC_X1_SPD_OVRR3_2r_CLOCKCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT0f_GET
#define SC_X1_SPD_OVRR3_2r_CLOCKCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r_CLOCKCNT0f_SET
#define READ_SC_X1_SPD_OVRR3_2r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_2r
#define WRITE_SC_X1_SPD_OVRR3_2r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_2r
#define MODIFY_SC_X1_SPD_OVRR3_2r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_3
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a5
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r (0x001092a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_3[1];
	uint32_t _sc_x1_spd_ovrr3_3;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_CLR(r) (r).sc_x1_spd_ovrr3_3[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_SET(r,d) (r).sc_x1_spd_ovrr3_3[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_GET(r) (r).sc_x1_spd_ovrr3_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT1f_GET(r) (((r).sc_x1_spd_ovrr3_3[0]) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT1f_SET(r,f) (r).sc_x1_spd_ovrr3_3[0]=(((r).sc_x1_spd_ovrr3_3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r,(_r._sc_x1_spd_ovrr3_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_3r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r
#define SC_X1_SPD_OVRR3_3r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_t SC_X1_SPD_OVRR3_3r_t;
#define SC_X1_SPD_OVRR3_3r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_CLR
#define SC_X1_SPD_OVRR3_3r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_SET
#define SC_X1_SPD_OVRR3_3r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_GET
#define SC_X1_SPD_OVRR3_3r_CLOCKCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT1f_GET
#define SC_X1_SPD_OVRR3_3r_CLOCKCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r_CLOCKCNT1f_SET
#define READ_SC_X1_SPD_OVRR3_3r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_3r
#define WRITE_SC_X1_SPD_OVRR3_3r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_3r
#define MODIFY_SC_X1_SPD_OVRR3_3r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_4
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a6
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r (0x001092a6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_4[1];
	uint32_t _sc_x1_spd_ovrr3_4;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_CLR(r) (r).sc_x1_spd_ovrr3_4[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_SET(r,d) (r).sc_x1_spd_ovrr3_4[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_GET(r) (r).sc_x1_spd_ovrr3_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT0f_GET(r) ((((r).sc_x1_spd_ovrr3_4[0]) >> 6) & 0xff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT0f_SET(r,f) (r).sc_x1_spd_ovrr3_4[0]=(((r).sc_x1_spd_ovrr3_4[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT1f_GET(r) (((r).sc_x1_spd_ovrr3_4[0]) & 0x3f)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT1f_SET(r,f) (r).sc_x1_spd_ovrr3_4[0]=(((r).sc_x1_spd_ovrr3_4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r,(_r._sc_x1_spd_ovrr3_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_4r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r
#define SC_X1_SPD_OVRR3_4r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_t SC_X1_SPD_OVRR3_4r_t;
#define SC_X1_SPD_OVRR3_4r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_CLR
#define SC_X1_SPD_OVRR3_4r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_SET
#define SC_X1_SPD_OVRR3_4r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_GET
#define SC_X1_SPD_OVRR3_4r_LOOPCNT0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT0f_GET
#define SC_X1_SPD_OVRR3_4r_LOOPCNT0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT0f_SET
#define SC_X1_SPD_OVRR3_4r_LOOPCNT1f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT1f_GET
#define SC_X1_SPD_OVRR3_4r_LOOPCNT1f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r_LOOPCNT1f_SET
#define READ_SC_X1_SPD_OVRR3_4r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_4r
#define WRITE_SC_X1_SPD_OVRR3_4r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_4r
#define MODIFY_SC_X1_SPD_OVRR3_4r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_5
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a7
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r (0x001092a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_5[1];
	uint32_t _sc_x1_spd_ovrr3_5;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_CLR(r) (r).sc_x1_spd_ovrr3_5[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_SET(r,d) (r).sc_x1_spd_ovrr3_5[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_GET(r) (r).sc_x1_spd_ovrr3_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x1_spd_ovrr3_5[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x1_spd_ovrr3_5[0]=(((r).sc_x1_spd_ovrr3_5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r,(_r._sc_x1_spd_ovrr3_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_5r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r
#define SC_X1_SPD_OVRR3_5r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_t SC_X1_SPD_OVRR3_5r_t;
#define SC_X1_SPD_OVRR3_5r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_CLR
#define SC_X1_SPD_OVRR3_5r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_SET
#define SC_X1_SPD_OVRR3_5r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_GET
#define SC_X1_SPD_OVRR3_5r_MAC_CREDITGENCNTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_MAC_CREDITGENCNTf_GET
#define SC_X1_SPD_OVRR3_5r_MAC_CREDITGENCNTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r_MAC_CREDITGENCNTf_SET
#define READ_SC_X1_SPD_OVRR3_5r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_5r
#define WRITE_SC_X1_SPD_OVRR3_5r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_5r
#define MODIFY_SC_X1_SPD_OVRR3_5r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_6
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a8
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     T_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword should be scrambled or not. It should be set to 1 in FC mode.
 *     T_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     T_PMA_CL91_MUX_SEL T_PMA MUX CL91 select.
 *     T_PMA_WATERMARK  T_PMA FIFO watermark. In units of 66-bit blocks.
 *     T_PMA_BITMUX_DELAY T_PMA FIFO delay after watermark is reached (in units of cycles)
 *     AM_SPACING_MUL   
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r (0x001092a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_6[1];
	uint32_t _sc_x1_spd_ovrr3_6;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_CLR(r) (r).sc_x1_spd_ovrr3_6[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_SET(r,d) (r).sc_x1_spd_ovrr3_6[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_GET(r) (r).sc_x1_spd_ovrr3_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_AM_SPACING_MULf_GET(r) ((((r).sc_x1_spd_ovrr3_6[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_AM_SPACING_MULf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_BITMUX_DELAYf_GET(r) ((((r).sc_x1_spd_ovrr3_6[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_BITMUX_DELAYf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_WATERMARKf_GET(r) ((((r).sc_x1_spd_ovrr3_6[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_WATERMARKf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_CL91_MUX_SELf_GET(r) ((((r).sc_x1_spd_ovrr3_6[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_CL91_MUX_SELf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_6[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_CL91_CW_SCRAMBLEf_GET(r) (((r).sc_x1_spd_ovrr3_6[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr3_6[0]=(((r).sc_x1_spd_ovrr3_6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r,(_r._sc_x1_spd_ovrr3_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_6r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r
#define SC_X1_SPD_OVRR3_6r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_t SC_X1_SPD_OVRR3_6r_t;
#define SC_X1_SPD_OVRR3_6r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_CLR
#define SC_X1_SPD_OVRR3_6r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_SET
#define SC_X1_SPD_OVRR3_6r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_GET
#define SC_X1_SPD_OVRR3_6r_AM_SPACING_MULf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_AM_SPACING_MULf_GET
#define SC_X1_SPD_OVRR3_6r_AM_SPACING_MULf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_AM_SPACING_MULf_SET
#define SC_X1_SPD_OVRR3_6r_T_PMA_BITMUX_DELAYf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_BITMUX_DELAYf_GET
#define SC_X1_SPD_OVRR3_6r_T_PMA_BITMUX_DELAYf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_BITMUX_DELAYf_SET
#define SC_X1_SPD_OVRR3_6r_T_PMA_WATERMARKf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_WATERMARKf_GET
#define SC_X1_SPD_OVRR3_6r_T_PMA_WATERMARKf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_WATERMARKf_SET
#define SC_X1_SPD_OVRR3_6r_T_PMA_CL91_MUX_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_CL91_MUX_SELf_GET
#define SC_X1_SPD_OVRR3_6r_T_PMA_CL91_MUX_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_PMA_CL91_MUX_SELf_SET
#define SC_X1_SPD_OVRR3_6r_T_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR3_6r_T_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR3_6r_T_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR3_6r_T_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r_T_CL91_CW_SCRAMBLEf_SET
#define READ_SC_X1_SPD_OVRR3_6r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_6r
#define WRITE_SC_X1_SPD_OVRR3_6r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_6r
#define MODIFY_SC_X1_SPD_OVRR3_6r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_7
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92a9
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_BLKSYNC_MODE 
 *     R_MERGE_MODE     
 *     R_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword needs to be descrambled. Should be enabled for FC mode.
 *     R_TC_IN_MODE     Indicates whether CL91 is turned ON for the port or not.
 *     R_TC_MODE        
 *     R_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     R_TC_OUT_MODE    
 *     R_HG2_ENABLE     Enables HG2 support for PCS
 *     R_AM_LOCK_FSM_MODE 1'b1 - AM lock extension mode is enabled.1'b0 - AM lock extension mode is disabled..
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r (0x001092a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_7[1];
	uint32_t _sc_x1_spd_ovrr3_7;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_CLR(r) (r).sc_x1_spd_ovrr3_7[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_SET(r,d) (r).sc_x1_spd_ovrr3_7[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_GET(r) (r).sc_x1_spd_ovrr3_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_AM_LOCK_FSM_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_AM_LOCK_FSM_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_HG2_ENABLEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_HG2_ENABLEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_OUT_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_OUT_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_IN_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_IN_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_CL91_CW_SCRAMBLEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_MERGE_MODEf_GET(r) ((((r).sc_x1_spd_ovrr3_7[0]) >> 3) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_MERGE_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_CL91_BLKSYNC_MODEf_GET(r) (((r).sc_x1_spd_ovrr3_7[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_CL91_BLKSYNC_MODEf_SET(r,f) (r).sc_x1_spd_ovrr3_7[0]=(((r).sc_x1_spd_ovrr3_7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r,(_r._sc_x1_spd_ovrr3_7))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r,(_r._sc_x1_spd_ovrr3_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r,(_r._sc_x1_spd_ovrr3_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_7r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r
#define SC_X1_SPD_OVRR3_7r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_t SC_X1_SPD_OVRR3_7r_t;
#define SC_X1_SPD_OVRR3_7r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_CLR
#define SC_X1_SPD_OVRR3_7r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_SET
#define SC_X1_SPD_OVRR3_7r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_GET
#define SC_X1_SPD_OVRR3_7r_R_AM_LOCK_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_AM_LOCK_FSM_MODEf_GET
#define SC_X1_SPD_OVRR3_7r_R_AM_LOCK_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_AM_LOCK_FSM_MODEf_SET
#define SC_X1_SPD_OVRR3_7r_R_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_HG2_ENABLEf_GET
#define SC_X1_SPD_OVRR3_7r_R_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_HG2_ENABLEf_SET
#define SC_X1_SPD_OVRR3_7r_R_TC_OUT_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_OUT_MODEf_GET
#define SC_X1_SPD_OVRR3_7r_R_TC_OUT_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_OUT_MODEf_SET
#define SC_X1_SPD_OVRR3_7r_R_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_FIVE_BIT_XOR_ENf_GET
#define SC_X1_SPD_OVRR3_7r_R_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_FIVE_BIT_XOR_ENf_SET
#define SC_X1_SPD_OVRR3_7r_R_TC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_MODEf_GET
#define SC_X1_SPD_OVRR3_7r_R_TC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_MODEf_SET
#define SC_X1_SPD_OVRR3_7r_R_TC_IN_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_IN_MODEf_GET
#define SC_X1_SPD_OVRR3_7r_R_TC_IN_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_TC_IN_MODEf_SET
#define SC_X1_SPD_OVRR3_7r_R_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_CL91_CW_SCRAMBLEf_GET
#define SC_X1_SPD_OVRR3_7r_R_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_CL91_CW_SCRAMBLEf_SET
#define SC_X1_SPD_OVRR3_7r_R_MERGE_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_MERGE_MODEf_GET
#define SC_X1_SPD_OVRR3_7r_R_MERGE_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_R_MERGE_MODEf_SET
#define SC_X1_SPD_OVRR3_7r_CL91_BLKSYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_CL91_BLKSYNC_MODEf_GET
#define SC_X1_SPD_OVRR3_7r_CL91_BLKSYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r_CL91_BLKSYNC_MODEf_SET
#define READ_SC_X1_SPD_OVRR3_7r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_7r
#define WRITE_SC_X1_SPD_OVRR3_7r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_7r
#define MODIFY_SC_X1_SPD_OVRR3_7r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X1_SPD_OVRR3_8
 * BLOCKS:   SC_X1_SPEED_OVERRIDE3
 * REGADDR:  0x92aa
 * DESC:     Override speed specification for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPT_2ND_GROUP Corrupt 2nd group of codeward
 *     CORRUPT_6TH_GROUP Corrupt 6th group of codeward
 *     CL74_SHCORRUPT   Sync Header Corruption for CL74 FEC Error (uncorrectable).0: Only 5 SH, 1: All SH corrupted.
 *     BER_COUNT_SEL    0: select count based on cl49 else based on cl82
 *     BER_WINDOW_SEL   0: select window based on cl49 else based on cl82
 *     USE_100G_AM0     AM0 will be taken from 100G AM
 *     USE_100G_AM123   AM 1, 2, 3 will be taken from 100G AMs
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r (0x001092aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X1_SPD_OVRR3_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_s {
	uint32_t v[1];
	uint32_t sc_x1_spd_ovrr3_8[1];
	uint32_t _sc_x1_spd_ovrr3_8;
} BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_t;

#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CLR(r) (r).sc_x1_spd_ovrr3_8[0] = 0
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_SET(r,d) (r).sc_x1_spd_ovrr3_8[0] = d
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_GET(r) (r).sc_x1_spd_ovrr3_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM123f_GET(r) ((((r).sc_x1_spd_ovrr3_8[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM123f_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM0f_GET(r) ((((r).sc_x1_spd_ovrr3_8[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM0f_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_WINDOW_SELf_GET(r) ((((r).sc_x1_spd_ovrr3_8[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_WINDOW_SELf_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_COUNT_SELf_GET(r) ((((r).sc_x1_spd_ovrr3_8[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_COUNT_SELf_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CL74_SHCORRUPTf_GET(r) ((((r).sc_x1_spd_ovrr3_8[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CL74_SHCORRUPTf_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_6TH_GROUPf_GET(r) ((((r).sc_x1_spd_ovrr3_8[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_6TH_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_2ND_GROUPf_GET(r) (((r).sc_x1_spd_ovrr3_8[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_2ND_GROUPf_SET(r,f) (r).sc_x1_spd_ovrr3_8[0]=(((r).sc_x1_spd_ovrr3_8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X1_SPD_OVRR3_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r,(_r._sc_x1_spd_ovrr3_8))
#define BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r,(_r._sc_x1_spd_ovrr3_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r,(_r._sc_x1_spd_ovrr3_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X1_SPD_OVRR3_8r BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r
#define SC_X1_SPD_OVRR3_8r_SIZE BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_SIZE
typedef BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_t SC_X1_SPD_OVRR3_8r_t;
#define SC_X1_SPD_OVRR3_8r_CLR BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CLR
#define SC_X1_SPD_OVRR3_8r_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_SET
#define SC_X1_SPD_OVRR3_8r_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_GET
#define SC_X1_SPD_OVRR3_8r_USE_100G_AM123f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM123f_GET
#define SC_X1_SPD_OVRR3_8r_USE_100G_AM123f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM123f_SET
#define SC_X1_SPD_OVRR3_8r_USE_100G_AM0f_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM0f_GET
#define SC_X1_SPD_OVRR3_8r_USE_100G_AM0f_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_USE_100G_AM0f_SET
#define SC_X1_SPD_OVRR3_8r_BER_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_WINDOW_SELf_GET
#define SC_X1_SPD_OVRR3_8r_BER_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_WINDOW_SELf_SET
#define SC_X1_SPD_OVRR3_8r_BER_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_COUNT_SELf_GET
#define SC_X1_SPD_OVRR3_8r_BER_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_BER_COUNT_SELf_SET
#define SC_X1_SPD_OVRR3_8r_CL74_SHCORRUPTf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CL74_SHCORRUPTf_GET
#define SC_X1_SPD_OVRR3_8r_CL74_SHCORRUPTf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CL74_SHCORRUPTf_SET
#define SC_X1_SPD_OVRR3_8r_CORRUPT_6TH_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_6TH_GROUPf_GET
#define SC_X1_SPD_OVRR3_8r_CORRUPT_6TH_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_6TH_GROUPf_SET
#define SC_X1_SPD_OVRR3_8r_CORRUPT_2ND_GROUPf_GET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_2ND_GROUPf_GET
#define SC_X1_SPD_OVRR3_8r_CORRUPT_2ND_GROUPf_SET BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r_CORRUPT_2ND_GROUPf_SET
#define READ_SC_X1_SPD_OVRR3_8r BCMI_TSCD_XGXS_READ_SC_X1_SPD_OVRR3_8r
#define WRITE_SC_X1_SPD_OVRR3_8r BCMI_TSCD_XGXS_WRITE_SC_X1_SPD_OVRR3_8r
#define MODIFY_SC_X1_SPD_OVRR3_8r BCMI_TSCD_XGXS_MODIFY_SC_X1_SPD_OVRR3_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X1_SPD_OVRR3_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_STS_CL91_FEC_RAM1_LO
 * BLOCKS:   RX_X1_STATUS0
 * REGADDR:  0x92b0
 * DESC:     ECC status register for CL91 FEC RAM1 containing lower 90 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_CL91_FEC_RAM1_LO ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_LO 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_LO 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr (0x001092b0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_STS_CL91_FEC_RAM1_LO.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_s {
	uint32_t v[1];
	uint32_t rx_x1_sts_cl91_fec_ram1_lo[1];
	uint32_t _rx_x1_sts_cl91_fec_ram1_lo;
} BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_t;

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_CLR(r) (r).rx_x1_sts_cl91_fec_ram1_lo[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_SET(r,d) (r).rx_x1_sts_cl91_fec_ram1_lo[0] = d
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_GET(r) (r).rx_x1_sts_cl91_fec_ram1_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram1_lo[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram1_lo[0]=(((r).rx_x1_sts_cl91_fec_ram1_lo[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram1_lo[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram1_lo[0]=(((r).rx_x1_sts_cl91_fec_ram1_lo[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_LOf_GET(r) (((r).rx_x1_sts_cl91_fec_ram1_lo[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_LOf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram1_lo[0]=(((r).rx_x1_sts_cl91_fec_ram1_lo[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_STS_CL91_FEC_RAM1_LO.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM1_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr,(_r._rx_x1_sts_cl91_fec_ram1_lo))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM1_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr,(_r._rx_x1_sts_cl91_fec_ram1_lo)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM1_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr,(_r._rx_x1_sts_cl91_fec_ram1_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_STS_CL91_FEC_RAM1_LOr BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr
#define RX_X1_STS_CL91_FEC_RAM1_LOr_SIZE BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_t RX_X1_STS_CL91_FEC_RAM1_LOr_t;
#define RX_X1_STS_CL91_FEC_RAM1_LOr_CLR BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_CLR
#define RX_X1_STS_CL91_FEC_RAM1_LOr_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_SET
#define RX_X1_STS_CL91_FEC_RAM1_LOr_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_GET
#define RX_X1_STS_CL91_FEC_RAM1_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_GET
#define RX_X1_STS_CL91_FEC_RAM1_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_SET
#define RX_X1_STS_CL91_FEC_RAM1_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_GET
#define RX_X1_STS_CL91_FEC_RAM1_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_LOf_SET
#define RX_X1_STS_CL91_FEC_RAM1_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_LOf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_LOf_GET
#define RX_X1_STS_CL91_FEC_RAM1_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_LOf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_LOf_SET
#define READ_RX_X1_STS_CL91_FEC_RAM1_LOr BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM1_LOr
#define WRITE_RX_X1_STS_CL91_FEC_RAM1_LOr BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM1_LOr
#define MODIFY_RX_X1_STS_CL91_FEC_RAM1_LOr BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM1_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_STS_CL91_FEC_RAM1_HI
 * BLOCKS:   RX_X1_STATUS0
 * REGADDR:  0x92b1
 * DESC:     ECC status register for CL91 FEC RAM1 containing upper 90 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_CL91_FEC_RAM1_HI ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_HI 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_HI 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr (0x001092b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_STS_CL91_FEC_RAM1_HI.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_s {
	uint32_t v[1];
	uint32_t rx_x1_sts_cl91_fec_ram1_hi[1];
	uint32_t _rx_x1_sts_cl91_fec_ram1_hi;
} BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_t;

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_CLR(r) (r).rx_x1_sts_cl91_fec_ram1_hi[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_SET(r,d) (r).rx_x1_sts_cl91_fec_ram1_hi[0] = d
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_GET(r) (r).rx_x1_sts_cl91_fec_ram1_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram1_hi[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram1_hi[0]=(((r).rx_x1_sts_cl91_fec_ram1_hi[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram1_hi[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram1_hi[0]=(((r).rx_x1_sts_cl91_fec_ram1_hi[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_HIf_GET(r) (((r).rx_x1_sts_cl91_fec_ram1_hi[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_HIf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram1_hi[0]=(((r).rx_x1_sts_cl91_fec_ram1_hi[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_STS_CL91_FEC_RAM1_HI.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM1_HIr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr,(_r._rx_x1_sts_cl91_fec_ram1_hi))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM1_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr,(_r._rx_x1_sts_cl91_fec_ram1_hi)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM1_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr,(_r._rx_x1_sts_cl91_fec_ram1_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_STS_CL91_FEC_RAM1_HIr BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr
#define RX_X1_STS_CL91_FEC_RAM1_HIr_SIZE BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_t RX_X1_STS_CL91_FEC_RAM1_HIr_t;
#define RX_X1_STS_CL91_FEC_RAM1_HIr_CLR BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_CLR
#define RX_X1_STS_CL91_FEC_RAM1_HIr_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_SET
#define RX_X1_STS_CL91_FEC_RAM1_HIr_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_GET
#define RX_X1_STS_CL91_FEC_RAM1_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_GET
#define RX_X1_STS_CL91_FEC_RAM1_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_SET
#define RX_X1_STS_CL91_FEC_RAM1_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_GET
#define RX_X1_STS_CL91_FEC_RAM1_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM1_HIf_SET
#define RX_X1_STS_CL91_FEC_RAM1_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_HIf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_HIf_GET
#define RX_X1_STS_CL91_FEC_RAM1_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_HIf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM1_HIf_SET
#define READ_RX_X1_STS_CL91_FEC_RAM1_HIr BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM1_HIr
#define WRITE_RX_X1_STS_CL91_FEC_RAM1_HIr BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM1_HIr
#define MODIFY_RX_X1_STS_CL91_FEC_RAM1_HIr BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM1_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM1_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_STS_CL91_FEC_RAM2_LO
 * BLOCKS:   RX_X1_STATUS0
 * REGADDR:  0x92b2
 * DESC:     ECC status register for CL91 FEC RAM2 containing lower 90 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_CL91_FEC_RAM2_LO ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_LO 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_LO 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr (0x001092b2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_STS_CL91_FEC_RAM2_LO.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_s {
	uint32_t v[1];
	uint32_t rx_x1_sts_cl91_fec_ram2_lo[1];
	uint32_t _rx_x1_sts_cl91_fec_ram2_lo;
} BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_t;

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_CLR(r) (r).rx_x1_sts_cl91_fec_ram2_lo[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_SET(r,d) (r).rx_x1_sts_cl91_fec_ram2_lo[0] = d
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_GET(r) (r).rx_x1_sts_cl91_fec_ram2_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram2_lo[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram2_lo[0]=(((r).rx_x1_sts_cl91_fec_ram2_lo[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram2_lo[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram2_lo[0]=(((r).rx_x1_sts_cl91_fec_ram2_lo[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_LOf_GET(r) (((r).rx_x1_sts_cl91_fec_ram2_lo[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_LOf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram2_lo[0]=(((r).rx_x1_sts_cl91_fec_ram2_lo[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_STS_CL91_FEC_RAM2_LO.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM2_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr,(_r._rx_x1_sts_cl91_fec_ram2_lo))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM2_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr,(_r._rx_x1_sts_cl91_fec_ram2_lo)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM2_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr,(_r._rx_x1_sts_cl91_fec_ram2_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_STS_CL91_FEC_RAM2_LOr BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr
#define RX_X1_STS_CL91_FEC_RAM2_LOr_SIZE BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_t RX_X1_STS_CL91_FEC_RAM2_LOr_t;
#define RX_X1_STS_CL91_FEC_RAM2_LOr_CLR BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_CLR
#define RX_X1_STS_CL91_FEC_RAM2_LOr_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_SET
#define RX_X1_STS_CL91_FEC_RAM2_LOr_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_GET
#define RX_X1_STS_CL91_FEC_RAM2_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_GET
#define RX_X1_STS_CL91_FEC_RAM2_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_SET
#define RX_X1_STS_CL91_FEC_RAM2_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_GET
#define RX_X1_STS_CL91_FEC_RAM2_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_LOf_SET
#define RX_X1_STS_CL91_FEC_RAM2_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_LOf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_LOf_GET
#define RX_X1_STS_CL91_FEC_RAM2_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_LOf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_LOf_SET
#define READ_RX_X1_STS_CL91_FEC_RAM2_LOr BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM2_LOr
#define WRITE_RX_X1_STS_CL91_FEC_RAM2_LOr BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM2_LOr
#define MODIFY_RX_X1_STS_CL91_FEC_RAM2_LOr BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM2_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X1_STS_CL91_FEC_RAM2_HI
 * BLOCKS:   RX_X1_STATUS0
 * REGADDR:  0x92b3
 * DESC:     ECC status register for CL91 FEC RAM2 containing upper 90 bits
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_CL91_FEC_RAM2_HI ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_HI 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_HI 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr (0x001092b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_SIZE 4

/*
 * This structure should be used to declare and program RX_X1_STS_CL91_FEC_RAM2_HI.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_s {
	uint32_t v[1];
	uint32_t rx_x1_sts_cl91_fec_ram2_hi[1];
	uint32_t _rx_x1_sts_cl91_fec_ram2_hi;
} BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_t;

#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_CLR(r) (r).rx_x1_sts_cl91_fec_ram2_hi[0] = 0
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_SET(r,d) (r).rx_x1_sts_cl91_fec_ram2_hi[0] = d
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_GET(r) (r).rx_x1_sts_cl91_fec_ram2_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram2_hi[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram2_hi[0]=(((r).rx_x1_sts_cl91_fec_ram2_hi[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_GET(r) ((((r).rx_x1_sts_cl91_fec_ram2_hi[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram2_hi[0]=(((r).rx_x1_sts_cl91_fec_ram2_hi[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_HIf_GET(r) (((r).rx_x1_sts_cl91_fec_ram2_hi[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_HIf_SET(r,f) (r).rx_x1_sts_cl91_fec_ram2_hi[0]=(((r).rx_x1_sts_cl91_fec_ram2_hi[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X1_STS_CL91_FEC_RAM2_HI.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM2_HIr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr,(_r._rx_x1_sts_cl91_fec_ram2_hi))
#define BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM2_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr,(_r._rx_x1_sts_cl91_fec_ram2_hi)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM2_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr,(_r._rx_x1_sts_cl91_fec_ram2_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X1_STS_CL91_FEC_RAM2_HIr BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr
#define RX_X1_STS_CL91_FEC_RAM2_HIr_SIZE BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_SIZE
typedef BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_t RX_X1_STS_CL91_FEC_RAM2_HIr_t;
#define RX_X1_STS_CL91_FEC_RAM2_HIr_CLR BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_CLR
#define RX_X1_STS_CL91_FEC_RAM2_HIr_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_SET
#define RX_X1_STS_CL91_FEC_RAM2_HIr_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_GET
#define RX_X1_STS_CL91_FEC_RAM2_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_GET
#define RX_X1_STS_CL91_FEC_RAM2_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_TWO_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_SET
#define RX_X1_STS_CL91_FEC_RAM2_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_GET
#define RX_X1_STS_CL91_FEC_RAM2_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ONE_BIT_ERR_EVENT_CL91_FEC_RAM2_HIf_SET
#define RX_X1_STS_CL91_FEC_RAM2_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_HIf_GET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_HIf_GET
#define RX_X1_STS_CL91_FEC_RAM2_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_HIf_SET BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr_ERR_EVENT_ADDRESS_CL91_FEC_RAM2_HIf_SET
#define READ_RX_X1_STS_CL91_FEC_RAM2_HIr BCMI_TSCD_XGXS_READ_RX_X1_STS_CL91_FEC_RAM2_HIr
#define WRITE_RX_X1_STS_CL91_FEC_RAM2_HIr BCMI_TSCD_XGXS_WRITE_RX_X1_STS_CL91_FEC_RAM2_HIr
#define MODIFY_RX_X1_STS_CL91_FEC_RAM2_HIr BCMI_TSCD_XGXS_MODIFY_RX_X1_STS_CL91_FEC_RAM2_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X1_STS_CL91_FEC_RAM2_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_GLB_INT
 * BLOCKS:   AN_X1_SW_MGMT
 * REGADDR:  0x92c0
 * DESC:     SW AN Global Interrupt
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     INT_PORT0        Interrupt indication from port 0 - OR of the all 3 events from port 0 S/W AN
 *     INT_PORT1        Interrupt indication from port 1 - OR of the all 3 events from port 1 S/W AN
 *     INT_PORT2        Interrupt indication from port 2 - OR of the all 3 events from port 2 S/W AN
 *     INT_PORT3        Interrupt indication from port 3 - OR of the all 3 events from port 3 S/W AN
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr (0x001092c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_GLB_INT.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_GLB_INTr_s {
	uint32_t v[1];
	uint32_t an_x1_glb_int[1];
	uint32_t _an_x1_glb_int;
} BCMI_TSCD_XGXS_AN_X1_GLB_INTr_t;

#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_CLR(r) (r).an_x1_glb_int[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_SET(r,d) (r).an_x1_glb_int[0] = d
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_GET(r) (r).an_x1_glb_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT3f_GET(r) ((((r).an_x1_glb_int[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT3f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT2f_GET(r) ((((r).an_x1_glb_int[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT2f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT1f_GET(r) ((((r).an_x1_glb_int[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT1f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT0f_GET(r) (((r).an_x1_glb_int[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT0f_SET(r,f) (r).an_x1_glb_int[0]=(((r).an_x1_glb_int[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X1_GLB_INT.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_GLB_INTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_GLB_INTr,(_r._an_x1_glb_int))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_GLB_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_GLB_INTr,(_r._an_x1_glb_int)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_GLB_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_GLB_INTr,(_r._an_x1_glb_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_GLB_INTr BCMI_TSCD_XGXS_AN_X1_GLB_INTr
#define AN_X1_GLB_INTr_SIZE BCMI_TSCD_XGXS_AN_X1_GLB_INTr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_GLB_INTr_t AN_X1_GLB_INTr_t;
#define AN_X1_GLB_INTr_CLR BCMI_TSCD_XGXS_AN_X1_GLB_INTr_CLR
#define AN_X1_GLB_INTr_SET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_SET
#define AN_X1_GLB_INTr_GET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_GET
#define AN_X1_GLB_INTr_INT_PORT3f_GET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT3f_GET
#define AN_X1_GLB_INTr_INT_PORT3f_SET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT3f_SET
#define AN_X1_GLB_INTr_INT_PORT2f_GET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT2f_GET
#define AN_X1_GLB_INTr_INT_PORT2f_SET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT2f_SET
#define AN_X1_GLB_INTr_INT_PORT1f_GET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT1f_GET
#define AN_X1_GLB_INTr_INT_PORT1f_SET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT1f_SET
#define AN_X1_GLB_INTr_INT_PORT0f_GET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT0f_GET
#define AN_X1_GLB_INTr_INT_PORT0f_SET BCMI_TSCD_XGXS_AN_X1_GLB_INTr_INT_PORT0f_SET
#define READ_AN_X1_GLB_INTr BCMI_TSCD_XGXS_READ_AN_X1_GLB_INTr
#define WRITE_AN_X1_GLB_INTr BCMI_TSCD_XGXS_WRITE_AN_X1_GLB_INTr
#define MODIFY_AN_X1_GLB_INTr BCMI_TSCD_XGXS_MODIFY_AN_X1_GLB_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_GLB_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X1_GLB_MASK
 * BLOCKS:   AN_X1_SW_MGMT
 * REGADDR:  0x92c1
 * DESC:     SW AN Per Port Global Interrupt Enable Mask
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     INT_PORT0_MASK   Write 1 to enable interrupt indication from port 0
 *     INT_PORT1_MASK   Write 1 to enable interrupt indication from port 1
 *     INT_PORT2_MASK   Write 1 to enable interrupt indication from port 2
 *     INT_PORT3_MASK   Write 1 to enable interrupt indication from port 3
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr (0x001092c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_SIZE 4

/*
 * This structure should be used to declare and program AN_X1_GLB_MASK.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_s {
	uint32_t v[1];
	uint32_t an_x1_glb_mask[1];
	uint32_t _an_x1_glb_mask;
} BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_t;

#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_CLR(r) (r).an_x1_glb_mask[0] = 0
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_SET(r,d) (r).an_x1_glb_mask[0] = d
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_GET(r) (r).an_x1_glb_mask[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_GET(r) ((((r).an_x1_glb_mask[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_GET(r) ((((r).an_x1_glb_mask[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_GET(r) ((((r).an_x1_glb_mask[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_GET(r) (((r).an_x1_glb_mask[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_SET(r,f) (r).an_x1_glb_mask[0]=(((r).an_x1_glb_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X1_GLB_MASK.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X1_GLB_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X1_GLB_MASKr,(_r._an_x1_glb_mask))
#define BCMI_TSCD_XGXS_WRITE_AN_X1_GLB_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_GLB_MASKr,(_r._an_x1_glb_mask)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X1_GLB_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X1_GLB_MASKr,(_r._an_x1_glb_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X1_GLB_MASKr BCMI_TSCD_XGXS_AN_X1_GLB_MASKr
#define AN_X1_GLB_MASKr_SIZE BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_SIZE
typedef BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_t AN_X1_GLB_MASKr_t;
#define AN_X1_GLB_MASKr_CLR BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_CLR
#define AN_X1_GLB_MASKr_SET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_SET
#define AN_X1_GLB_MASKr_GET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_GET
#define AN_X1_GLB_MASKr_INT_PORT3_MASKf_GET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT3_MASKf_SET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT3_MASKf_SET
#define AN_X1_GLB_MASKr_INT_PORT2_MASKf_GET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT2_MASKf_SET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT2_MASKf_SET
#define AN_X1_GLB_MASKr_INT_PORT1_MASKf_GET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT1_MASKf_SET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT1_MASKf_SET
#define AN_X1_GLB_MASKr_INT_PORT0_MASKf_GET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_GET
#define AN_X1_GLB_MASKr_INT_PORT0_MASKf_SET BCMI_TSCD_XGXS_AN_X1_GLB_MASKr_INT_PORT0_MASKf_SET
#define READ_AN_X1_GLB_MASKr BCMI_TSCD_XGXS_READ_AN_X1_GLB_MASKr
#define WRITE_AN_X1_GLB_MASKr BCMI_TSCD_XGXS_WRITE_AN_X1_GLB_MASKr
#define MODIFY_AN_X1_GLB_MASKr BCMI_TSCD_XGXS_MODIFY_AN_X1_GLB_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X1_GLB_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9300
 * DESC:     Serdes Config Index 0 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_0r (0x00109300 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_0[1];
	uint32_t _serdes_cfg_0_0;
} BCMI_TSCD_XGXS_SERDES_CFG_0_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_0r_CLR(r) (r).serdes_cfg_0_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SET(r,d) (r).serdes_cfg_0_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_0r_GET(r) (r).serdes_cfg_0_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_0[0]=(((r).serdes_cfg_0_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_0r,(_r._serdes_cfg_0_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_0r,(_r._serdes_cfg_0_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_0r,(_r._serdes_cfg_0_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_0r BCMI_TSCD_XGXS_SERDES_CFG_0_0r
#define SERDES_CFG_0_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_0r_t SERDES_CFG_0_0r_t;
#define SERDES_CFG_0_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_0r_CLR
#define SERDES_CFG_0_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SET
#define SERDES_CFG_0_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_0r_GET
#define SERDES_CFG_0_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SPEED_CFGf_GET
#define SERDES_CFG_0_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_0r
#define WRITE_SERDES_CFG_0_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_0r
#define MODIFY_SERDES_CFG_0_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9301
 * DESC:     Serdes Config Index 0 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_1r (0x00109301 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_1[1];
	uint32_t _serdes_cfg_0_1;
} BCMI_TSCD_XGXS_SERDES_CFG_0_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_1r_CLR(r) (r).serdes_cfg_0_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SET(r,d) (r).serdes_cfg_0_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_1r_GET(r) (r).serdes_cfg_0_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_1[0]=(((r).serdes_cfg_0_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_1r,(_r._serdes_cfg_0_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_1r,(_r._serdes_cfg_0_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_1r,(_r._serdes_cfg_0_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_1r BCMI_TSCD_XGXS_SERDES_CFG_0_1r
#define SERDES_CFG_0_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_1r_t SERDES_CFG_0_1r_t;
#define SERDES_CFG_0_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_1r_CLR
#define SERDES_CFG_0_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SET
#define SERDES_CFG_0_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_1r_GET
#define SERDES_CFG_0_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SPEED_CFGf_GET
#define SERDES_CFG_0_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_1r
#define WRITE_SERDES_CFG_0_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_1r
#define MODIFY_SERDES_CFG_0_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9302
 * DESC:     Serdes Config Index 0 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_2r (0x00109302 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_2[1];
	uint32_t _serdes_cfg_0_2;
} BCMI_TSCD_XGXS_SERDES_CFG_0_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_2r_CLR(r) (r).serdes_cfg_0_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SET(r,d) (r).serdes_cfg_0_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_2r_GET(r) (r).serdes_cfg_0_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_2[0]=(((r).serdes_cfg_0_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_2r,(_r._serdes_cfg_0_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_2r,(_r._serdes_cfg_0_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_2r,(_r._serdes_cfg_0_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_2r BCMI_TSCD_XGXS_SERDES_CFG_0_2r
#define SERDES_CFG_0_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_2r_t SERDES_CFG_0_2r_t;
#define SERDES_CFG_0_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_2r_CLR
#define SERDES_CFG_0_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SET
#define SERDES_CFG_0_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_2r_GET
#define SERDES_CFG_0_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SPEED_CFGf_GET
#define SERDES_CFG_0_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_2r
#define WRITE_SERDES_CFG_0_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_2r
#define MODIFY_SERDES_CFG_0_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9303
 * DESC:     Serdes Config Index 0 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_3r (0x00109303 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_3[1];
	uint32_t _serdes_cfg_0_3;
} BCMI_TSCD_XGXS_SERDES_CFG_0_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_3r_CLR(r) (r).serdes_cfg_0_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SET(r,d) (r).serdes_cfg_0_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_3r_GET(r) (r).serdes_cfg_0_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_3[0]=(((r).serdes_cfg_0_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_3r,(_r._serdes_cfg_0_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_3r,(_r._serdes_cfg_0_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_3r,(_r._serdes_cfg_0_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_3r BCMI_TSCD_XGXS_SERDES_CFG_0_3r
#define SERDES_CFG_0_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_3r_t SERDES_CFG_0_3r_t;
#define SERDES_CFG_0_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_3r_CLR
#define SERDES_CFG_0_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SET
#define SERDES_CFG_0_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_3r_GET
#define SERDES_CFG_0_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SPEED_CFGf_GET
#define SERDES_CFG_0_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_3r
#define WRITE_SERDES_CFG_0_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_3r
#define MODIFY_SERDES_CFG_0_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9304
 * DESC:     Serdes Config Index 0 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_4r (0x00109304 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_4[1];
	uint32_t _serdes_cfg_0_4;
} BCMI_TSCD_XGXS_SERDES_CFG_0_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_4r_CLR(r) (r).serdes_cfg_0_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SET(r,d) (r).serdes_cfg_0_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_4r_GET(r) (r).serdes_cfg_0_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_4[0]=(((r).serdes_cfg_0_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_4r,(_r._serdes_cfg_0_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_4r,(_r._serdes_cfg_0_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_4r,(_r._serdes_cfg_0_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_4r BCMI_TSCD_XGXS_SERDES_CFG_0_4r
#define SERDES_CFG_0_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_4r_t SERDES_CFG_0_4r_t;
#define SERDES_CFG_0_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_4r_CLR
#define SERDES_CFG_0_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SET
#define SERDES_CFG_0_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_4r_GET
#define SERDES_CFG_0_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SPEED_CFGf_GET
#define SERDES_CFG_0_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_4r
#define WRITE_SERDES_CFG_0_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_4r
#define MODIFY_SERDES_CFG_0_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9305
 * DESC:     Serdes Config Index 0 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_5r (0x00109305 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_5[1];
	uint32_t _serdes_cfg_0_5;
} BCMI_TSCD_XGXS_SERDES_CFG_0_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_5r_CLR(r) (r).serdes_cfg_0_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SET(r,d) (r).serdes_cfg_0_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_5r_GET(r) (r).serdes_cfg_0_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_5[0]=(((r).serdes_cfg_0_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_5r,(_r._serdes_cfg_0_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_5r,(_r._serdes_cfg_0_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_5r,(_r._serdes_cfg_0_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_5r BCMI_TSCD_XGXS_SERDES_CFG_0_5r
#define SERDES_CFG_0_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_5r_t SERDES_CFG_0_5r_t;
#define SERDES_CFG_0_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_5r_CLR
#define SERDES_CFG_0_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SET
#define SERDES_CFG_0_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_5r_GET
#define SERDES_CFG_0_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SPEED_CFGf_GET
#define SERDES_CFG_0_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_5r
#define WRITE_SERDES_CFG_0_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_5r
#define MODIFY_SERDES_CFG_0_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9306
 * DESC:     Serdes Config Index 0 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_6r (0x00109306 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_6[1];
	uint32_t _serdes_cfg_0_6;
} BCMI_TSCD_XGXS_SERDES_CFG_0_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_6r_CLR(r) (r).serdes_cfg_0_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SET(r,d) (r).serdes_cfg_0_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_6r_GET(r) (r).serdes_cfg_0_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_6[0]=(((r).serdes_cfg_0_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_6r,(_r._serdes_cfg_0_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_6r,(_r._serdes_cfg_0_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_6r,(_r._serdes_cfg_0_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_6r BCMI_TSCD_XGXS_SERDES_CFG_0_6r
#define SERDES_CFG_0_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_6r_t SERDES_CFG_0_6r_t;
#define SERDES_CFG_0_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_6r_CLR
#define SERDES_CFG_0_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SET
#define SERDES_CFG_0_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_6r_GET
#define SERDES_CFG_0_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SPEED_CFGf_GET
#define SERDES_CFG_0_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_6r
#define WRITE_SERDES_CFG_0_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_6r
#define MODIFY_SERDES_CFG_0_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9307
 * DESC:     Serdes Config Index 0 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_7r (0x00109307 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_7[1];
	uint32_t _serdes_cfg_0_7;
} BCMI_TSCD_XGXS_SERDES_CFG_0_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_7r_CLR(r) (r).serdes_cfg_0_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SET(r,d) (r).serdes_cfg_0_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_7r_GET(r) (r).serdes_cfg_0_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_7[0]=(((r).serdes_cfg_0_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_7r,(_r._serdes_cfg_0_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_7r,(_r._serdes_cfg_0_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_7r,(_r._serdes_cfg_0_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_7r BCMI_TSCD_XGXS_SERDES_CFG_0_7r
#define SERDES_CFG_0_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_7r_t SERDES_CFG_0_7r_t;
#define SERDES_CFG_0_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_7r_CLR
#define SERDES_CFG_0_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SET
#define SERDES_CFG_0_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_7r_GET
#define SERDES_CFG_0_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SPEED_CFGf_GET
#define SERDES_CFG_0_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_7r
#define WRITE_SERDES_CFG_0_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_7r
#define MODIFY_SERDES_CFG_0_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9308
 * DESC:     Serdes Config Index 0 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_8r (0x00109308 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_8[1];
	uint32_t _serdes_cfg_0_8;
} BCMI_TSCD_XGXS_SERDES_CFG_0_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_8r_CLR(r) (r).serdes_cfg_0_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SET(r,d) (r).serdes_cfg_0_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_8r_GET(r) (r).serdes_cfg_0_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_8[0]=(((r).serdes_cfg_0_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_8r,(_r._serdes_cfg_0_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_8r,(_r._serdes_cfg_0_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_8r,(_r._serdes_cfg_0_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_8r BCMI_TSCD_XGXS_SERDES_CFG_0_8r
#define SERDES_CFG_0_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_8r_t SERDES_CFG_0_8r_t;
#define SERDES_CFG_0_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_8r_CLR
#define SERDES_CFG_0_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SET
#define SERDES_CFG_0_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_8r_GET
#define SERDES_CFG_0_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SPEED_CFGf_GET
#define SERDES_CFG_0_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_8r
#define WRITE_SERDES_CFG_0_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_8r
#define MODIFY_SERDES_CFG_0_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9309
 * DESC:     Serdes Config Index 0 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_9r (0x00109309 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_9[1];
	uint32_t _serdes_cfg_0_9;
} BCMI_TSCD_XGXS_SERDES_CFG_0_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_9r_CLR(r) (r).serdes_cfg_0_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SET(r,d) (r).serdes_cfg_0_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_9r_GET(r) (r).serdes_cfg_0_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_9[0]=(((r).serdes_cfg_0_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_9r,(_r._serdes_cfg_0_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_9r,(_r._serdes_cfg_0_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_9r,(_r._serdes_cfg_0_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_9r BCMI_TSCD_XGXS_SERDES_CFG_0_9r
#define SERDES_CFG_0_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_9r_t SERDES_CFG_0_9r_t;
#define SERDES_CFG_0_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_9r_CLR
#define SERDES_CFG_0_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SET
#define SERDES_CFG_0_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_9r_GET
#define SERDES_CFG_0_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SPEED_CFGf_GET
#define SERDES_CFG_0_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_9r
#define WRITE_SERDES_CFG_0_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_9r
#define MODIFY_SERDES_CFG_0_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x930a
 * DESC:     Serdes Config Index 0 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_10r (0x0010930a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_10[1];
	uint32_t _serdes_cfg_0_10;
} BCMI_TSCD_XGXS_SERDES_CFG_0_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_10r_CLR(r) (r).serdes_cfg_0_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SET(r,d) (r).serdes_cfg_0_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_10r_GET(r) (r).serdes_cfg_0_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_10[0]=(((r).serdes_cfg_0_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_10r,(_r._serdes_cfg_0_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_10r,(_r._serdes_cfg_0_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_10r,(_r._serdes_cfg_0_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_10r BCMI_TSCD_XGXS_SERDES_CFG_0_10r
#define SERDES_CFG_0_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_10r_t SERDES_CFG_0_10r_t;
#define SERDES_CFG_0_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_10r_CLR
#define SERDES_CFG_0_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SET
#define SERDES_CFG_0_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_10r_GET
#define SERDES_CFG_0_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SPEED_CFGf_GET
#define SERDES_CFG_0_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_10r
#define WRITE_SERDES_CFG_0_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_10r
#define MODIFY_SERDES_CFG_0_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x930b
 * DESC:     Serdes Config Index 0 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_11r (0x0010930b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_11[1];
	uint32_t _serdes_cfg_0_11;
} BCMI_TSCD_XGXS_SERDES_CFG_0_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_11r_CLR(r) (r).serdes_cfg_0_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SET(r,d) (r).serdes_cfg_0_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_11r_GET(r) (r).serdes_cfg_0_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_11[0]=(((r).serdes_cfg_0_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_11r,(_r._serdes_cfg_0_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_11r,(_r._serdes_cfg_0_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_11r,(_r._serdes_cfg_0_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_11r BCMI_TSCD_XGXS_SERDES_CFG_0_11r
#define SERDES_CFG_0_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_11r_t SERDES_CFG_0_11r_t;
#define SERDES_CFG_0_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_11r_CLR
#define SERDES_CFG_0_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SET
#define SERDES_CFG_0_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_11r_GET
#define SERDES_CFG_0_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SPEED_CFGf_GET
#define SERDES_CFG_0_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_11r
#define WRITE_SERDES_CFG_0_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_11r
#define MODIFY_SERDES_CFG_0_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x930c
 * DESC:     Serdes Config Index 0 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_12r (0x0010930c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_12[1];
	uint32_t _serdes_cfg_0_12;
} BCMI_TSCD_XGXS_SERDES_CFG_0_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_12r_CLR(r) (r).serdes_cfg_0_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SET(r,d) (r).serdes_cfg_0_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_12r_GET(r) (r).serdes_cfg_0_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_12[0]=(((r).serdes_cfg_0_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_12r,(_r._serdes_cfg_0_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_12r,(_r._serdes_cfg_0_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_12r,(_r._serdes_cfg_0_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_12r BCMI_TSCD_XGXS_SERDES_CFG_0_12r
#define SERDES_CFG_0_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_12r_t SERDES_CFG_0_12r_t;
#define SERDES_CFG_0_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_12r_CLR
#define SERDES_CFG_0_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SET
#define SERDES_CFG_0_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_12r_GET
#define SERDES_CFG_0_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SPEED_CFGf_GET
#define SERDES_CFG_0_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_12r
#define WRITE_SERDES_CFG_0_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_12r
#define MODIFY_SERDES_CFG_0_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x930d
 * DESC:     Serdes Config Index 0 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_13r (0x0010930d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_13[1];
	uint32_t _serdes_cfg_0_13;
} BCMI_TSCD_XGXS_SERDES_CFG_0_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_13r_CLR(r) (r).serdes_cfg_0_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SET(r,d) (r).serdes_cfg_0_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_13r_GET(r) (r).serdes_cfg_0_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_13[0]=(((r).serdes_cfg_0_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_13r,(_r._serdes_cfg_0_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_13r,(_r._serdes_cfg_0_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_13r,(_r._serdes_cfg_0_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_13r BCMI_TSCD_XGXS_SERDES_CFG_0_13r
#define SERDES_CFG_0_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_13r_t SERDES_CFG_0_13r_t;
#define SERDES_CFG_0_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_13r_CLR
#define SERDES_CFG_0_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SET
#define SERDES_CFG_0_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_13r_GET
#define SERDES_CFG_0_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SPEED_CFGf_GET
#define SERDES_CFG_0_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_13r
#define WRITE_SERDES_CFG_0_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_13r
#define MODIFY_SERDES_CFG_0_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x930e
 * DESC:     Serdes Config Index 0 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_14r (0x0010930e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_14[1];
	uint32_t _serdes_cfg_0_14;
} BCMI_TSCD_XGXS_SERDES_CFG_0_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_14r_CLR(r) (r).serdes_cfg_0_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SET(r,d) (r).serdes_cfg_0_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_14r_GET(r) (r).serdes_cfg_0_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_14[0]=(((r).serdes_cfg_0_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_14r,(_r._serdes_cfg_0_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_14r,(_r._serdes_cfg_0_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_14r,(_r._serdes_cfg_0_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_14r BCMI_TSCD_XGXS_SERDES_CFG_0_14r
#define SERDES_CFG_0_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_14r_t SERDES_CFG_0_14r_t;
#define SERDES_CFG_0_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_14r_CLR
#define SERDES_CFG_0_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SET
#define SERDES_CFG_0_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_14r_GET
#define SERDES_CFG_0_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SPEED_CFGf_GET
#define SERDES_CFG_0_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_14r
#define WRITE_SERDES_CFG_0_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_14r
#define MODIFY_SERDES_CFG_0_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x930f
 * DESC:     Serdes Config Index 0 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_15r (0x0010930f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_15[1];
	uint32_t _serdes_cfg_0_15;
} BCMI_TSCD_XGXS_SERDES_CFG_0_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_15r_CLR(r) (r).serdes_cfg_0_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SET(r,d) (r).serdes_cfg_0_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_15r_GET(r) (r).serdes_cfg_0_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_15[0]=(((r).serdes_cfg_0_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_15r,(_r._serdes_cfg_0_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_15r,(_r._serdes_cfg_0_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_15r,(_r._serdes_cfg_0_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_15r BCMI_TSCD_XGXS_SERDES_CFG_0_15r
#define SERDES_CFG_0_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_15r_t SERDES_CFG_0_15r_t;
#define SERDES_CFG_0_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_15r_CLR
#define SERDES_CFG_0_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SET
#define SERDES_CFG_0_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_15r_GET
#define SERDES_CFG_0_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SPEED_CFGf_GET
#define SERDES_CFG_0_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_15r
#define WRITE_SERDES_CFG_0_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_15r
#define MODIFY_SERDES_CFG_0_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9310
 * DESC:     Serdes Config Index 0 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_16r (0x00109310 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_16[1];
	uint32_t _serdes_cfg_0_16;
} BCMI_TSCD_XGXS_SERDES_CFG_0_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_16r_CLR(r) (r).serdes_cfg_0_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SET(r,d) (r).serdes_cfg_0_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_16r_GET(r) (r).serdes_cfg_0_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_16[0]=(((r).serdes_cfg_0_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_16r,(_r._serdes_cfg_0_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_16r,(_r._serdes_cfg_0_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_16r,(_r._serdes_cfg_0_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_16r BCMI_TSCD_XGXS_SERDES_CFG_0_16r
#define SERDES_CFG_0_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_16r_t SERDES_CFG_0_16r_t;
#define SERDES_CFG_0_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_16r_CLR
#define SERDES_CFG_0_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SET
#define SERDES_CFG_0_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_16r_GET
#define SERDES_CFG_0_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SPEED_CFGf_GET
#define SERDES_CFG_0_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_16r
#define WRITE_SERDES_CFG_0_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_16r
#define MODIFY_SERDES_CFG_0_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9311
 * DESC:     Serdes Config Index 0 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_17r (0x00109311 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_17[1];
	uint32_t _serdes_cfg_0_17;
} BCMI_TSCD_XGXS_SERDES_CFG_0_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_17r_CLR(r) (r).serdes_cfg_0_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SET(r,d) (r).serdes_cfg_0_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_17r_GET(r) (r).serdes_cfg_0_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_17[0]=(((r).serdes_cfg_0_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_17r,(_r._serdes_cfg_0_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_17r,(_r._serdes_cfg_0_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_17r,(_r._serdes_cfg_0_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_17r BCMI_TSCD_XGXS_SERDES_CFG_0_17r
#define SERDES_CFG_0_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_17r_t SERDES_CFG_0_17r_t;
#define SERDES_CFG_0_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_17r_CLR
#define SERDES_CFG_0_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SET
#define SERDES_CFG_0_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_17r_GET
#define SERDES_CFG_0_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SPEED_CFGf_GET
#define SERDES_CFG_0_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_17r
#define WRITE_SERDES_CFG_0_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_17r
#define MODIFY_SERDES_CFG_0_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9312
 * DESC:     Serdes Config Index 0 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_18r (0x00109312 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_18[1];
	uint32_t _serdes_cfg_0_18;
} BCMI_TSCD_XGXS_SERDES_CFG_0_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_18r_CLR(r) (r).serdes_cfg_0_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SET(r,d) (r).serdes_cfg_0_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_18r_GET(r) (r).serdes_cfg_0_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_18[0]=(((r).serdes_cfg_0_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_18r,(_r._serdes_cfg_0_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_18r,(_r._serdes_cfg_0_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_18r,(_r._serdes_cfg_0_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_18r BCMI_TSCD_XGXS_SERDES_CFG_0_18r
#define SERDES_CFG_0_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_18r_t SERDES_CFG_0_18r_t;
#define SERDES_CFG_0_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_18r_CLR
#define SERDES_CFG_0_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SET
#define SERDES_CFG_0_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_18r_GET
#define SERDES_CFG_0_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SPEED_CFGf_GET
#define SERDES_CFG_0_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_18r
#define WRITE_SERDES_CFG_0_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_18r
#define MODIFY_SERDES_CFG_0_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9313
 * DESC:     Serdes Config Index 0 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_19r (0x00109313 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_19[1];
	uint32_t _serdes_cfg_0_19;
} BCMI_TSCD_XGXS_SERDES_CFG_0_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_19r_CLR(r) (r).serdes_cfg_0_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SET(r,d) (r).serdes_cfg_0_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_19r_GET(r) (r).serdes_cfg_0_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_19[0]=(((r).serdes_cfg_0_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_19r,(_r._serdes_cfg_0_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_19r,(_r._serdes_cfg_0_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_19r,(_r._serdes_cfg_0_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_19r BCMI_TSCD_XGXS_SERDES_CFG_0_19r
#define SERDES_CFG_0_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_19r_t SERDES_CFG_0_19r_t;
#define SERDES_CFG_0_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_19r_CLR
#define SERDES_CFG_0_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SET
#define SERDES_CFG_0_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_19r_GET
#define SERDES_CFG_0_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SPEED_CFGf_GET
#define SERDES_CFG_0_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_19r
#define WRITE_SERDES_CFG_0_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_19r
#define MODIFY_SERDES_CFG_0_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9314
 * DESC:     Serdes Config Index 0 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_20r (0x00109314 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_20[1];
	uint32_t _serdes_cfg_0_20;
} BCMI_TSCD_XGXS_SERDES_CFG_0_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_20r_CLR(r) (r).serdes_cfg_0_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SET(r,d) (r).serdes_cfg_0_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_20r_GET(r) (r).serdes_cfg_0_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_0_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_0_20[0]=(((r).serdes_cfg_0_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_0_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_20r,(_r._serdes_cfg_0_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_20r,(_r._serdes_cfg_0_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_20r,(_r._serdes_cfg_0_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_20r BCMI_TSCD_XGXS_SERDES_CFG_0_20r
#define SERDES_CFG_0_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_20r_t SERDES_CFG_0_20r_t;
#define SERDES_CFG_0_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_20r_CLR
#define SERDES_CFG_0_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SET
#define SERDES_CFG_0_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_20r_GET
#define SERDES_CFG_0_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SPEED_CFGf_GET
#define SERDES_CFG_0_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_0_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_20r
#define WRITE_SERDES_CFG_0_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_20r
#define MODIFY_SERDES_CFG_0_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9315
 * DESC:     Serdes Config Index 0 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_21r (0x00109315 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_21[1];
	uint32_t _serdes_cfg_0_21;
} BCMI_TSCD_XGXS_SERDES_CFG_0_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_21r_CLR(r) (r).serdes_cfg_0_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_21r_SET(r,d) (r).serdes_cfg_0_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_21r_GET(r) (r).serdes_cfg_0_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_0_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_0_21[0]=(((r).serdes_cfg_0_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_0_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_21r,(_r._serdes_cfg_0_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_21r,(_r._serdes_cfg_0_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_21r,(_r._serdes_cfg_0_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_21r BCMI_TSCD_XGXS_SERDES_CFG_0_21r
#define SERDES_CFG_0_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_21r_t SERDES_CFG_0_21r_t;
#define SERDES_CFG_0_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_21r_CLR
#define SERDES_CFG_0_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_21r_SET
#define SERDES_CFG_0_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_21r_GET
#define SERDES_CFG_0_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_21r_FCLK_PERIODf_GET
#define SERDES_CFG_0_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_0_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_21r
#define WRITE_SERDES_CFG_0_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_21r
#define MODIFY_SERDES_CFG_0_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9316
 * DESC:     Serdes Config Index 0 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r (0x00109316 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_22[1];
	uint32_t _serdes_cfg_0_22;
} BCMI_TSCD_XGXS_SERDES_CFG_0_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_CLR(r) (r).serdes_cfg_0_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SET(r,d) (r).serdes_cfg_0_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_GET(r) (r).serdes_cfg_0_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SPAREf_GET(r) ((((r).serdes_cfg_0_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SPAREf_SET(r,f) (r).serdes_cfg_0_22[0]=(((r).serdes_cfg_0_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_0_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_0_22[0]=(((r).serdes_cfg_0_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_0_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_22r,(_r._serdes_cfg_0_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_22r,(_r._serdes_cfg_0_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_22r,(_r._serdes_cfg_0_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_22r BCMI_TSCD_XGXS_SERDES_CFG_0_22r
#define SERDES_CFG_0_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_22r_t SERDES_CFG_0_22r_t;
#define SERDES_CFG_0_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_22r_CLR
#define SERDES_CFG_0_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SET
#define SERDES_CFG_0_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_22r_GET
#define SERDES_CFG_0_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SPAREf_GET
#define SERDES_CFG_0_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_22r_SPAREf_SET
#define SERDES_CFG_0_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_22r_RX_LOSVREFf_GET
#define SERDES_CFG_0_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_0_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_22r
#define WRITE_SERDES_CFG_0_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_22r
#define MODIFY_SERDES_CFG_0_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_0_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9317
 * DESC:     Serdes Config Index 0 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r (0x00109317 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_0_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_0_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_0_23[1];
	uint32_t _serdes_cfg_0_23;
} BCMI_TSCD_XGXS_SERDES_CFG_0_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_CLR(r) (r).serdes_cfg_0_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_SET(r,d) (r).serdes_cfg_0_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_GET(r) (r).serdes_cfg_0_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_0_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_0_23[0]=(((r).serdes_cfg_0_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_0_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_0_23[0]=(((r).serdes_cfg_0_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_0_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_0_23[0]=(((r).serdes_cfg_0_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_RATESELf_GET(r) ((((r).serdes_cfg_0_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_RATESELf_SET(r,f) (r).serdes_cfg_0_23[0]=(((r).serdes_cfg_0_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_0_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_0_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_0_23[0]=(((r).serdes_cfg_0_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_0_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_0_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_23r,(_r._serdes_cfg_0_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_23r,(_r._serdes_cfg_0_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_0_23r,(_r._serdes_cfg_0_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_0_23r BCMI_TSCD_XGXS_SERDES_CFG_0_23r
#define SERDES_CFG_0_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_0_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_0_23r_t SERDES_CFG_0_23r_t;
#define SERDES_CFG_0_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_0_23r_CLR
#define SERDES_CFG_0_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_SET
#define SERDES_CFG_0_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_GET
#define SERDES_CFG_0_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_0_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_0_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODEf_GET
#define SERDES_CFG_0_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_TRAINING_MODEf_SET
#define SERDES_CFG_0_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_WORDMODEf_GET
#define SERDES_CFG_0_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_WORDMODEf_SET
#define SERDES_CFG_0_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_RATESELf_GET
#define SERDES_CFG_0_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_RATESELf_SET
#define SERDES_CFG_0_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_0_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_0_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_0_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_0_23r
#define WRITE_SERDES_CFG_0_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_0_23r
#define MODIFY_SERDES_CFG_0_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_0_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_0_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9320
 * DESC:     Serdes Config Index 1 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_0r (0x00109320 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_0[1];
	uint32_t _serdes_cfg_1_0;
} BCMI_TSCD_XGXS_SERDES_CFG_1_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_0r_CLR(r) (r).serdes_cfg_1_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SET(r,d) (r).serdes_cfg_1_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_0r_GET(r) (r).serdes_cfg_1_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_0[0]=(((r).serdes_cfg_1_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_0r,(_r._serdes_cfg_1_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_0r,(_r._serdes_cfg_1_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_0r,(_r._serdes_cfg_1_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_0r BCMI_TSCD_XGXS_SERDES_CFG_1_0r
#define SERDES_CFG_1_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_0r_t SERDES_CFG_1_0r_t;
#define SERDES_CFG_1_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_0r_CLR
#define SERDES_CFG_1_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SET
#define SERDES_CFG_1_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_0r_GET
#define SERDES_CFG_1_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SPEED_CFGf_GET
#define SERDES_CFG_1_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_0r
#define WRITE_SERDES_CFG_1_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_0r
#define MODIFY_SERDES_CFG_1_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9321
 * DESC:     Serdes Config Index 1 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_1r (0x00109321 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_1[1];
	uint32_t _serdes_cfg_1_1;
} BCMI_TSCD_XGXS_SERDES_CFG_1_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_1r_CLR(r) (r).serdes_cfg_1_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SET(r,d) (r).serdes_cfg_1_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_1r_GET(r) (r).serdes_cfg_1_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_1[0]=(((r).serdes_cfg_1_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_1r,(_r._serdes_cfg_1_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_1r,(_r._serdes_cfg_1_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_1r,(_r._serdes_cfg_1_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_1r BCMI_TSCD_XGXS_SERDES_CFG_1_1r
#define SERDES_CFG_1_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_1r_t SERDES_CFG_1_1r_t;
#define SERDES_CFG_1_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_1r_CLR
#define SERDES_CFG_1_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SET
#define SERDES_CFG_1_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_1r_GET
#define SERDES_CFG_1_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SPEED_CFGf_GET
#define SERDES_CFG_1_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_1r
#define WRITE_SERDES_CFG_1_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_1r
#define MODIFY_SERDES_CFG_1_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9322
 * DESC:     Serdes Config Index 1 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_2r (0x00109322 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_2[1];
	uint32_t _serdes_cfg_1_2;
} BCMI_TSCD_XGXS_SERDES_CFG_1_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_2r_CLR(r) (r).serdes_cfg_1_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SET(r,d) (r).serdes_cfg_1_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_2r_GET(r) (r).serdes_cfg_1_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_2[0]=(((r).serdes_cfg_1_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_2r,(_r._serdes_cfg_1_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_2r,(_r._serdes_cfg_1_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_2r,(_r._serdes_cfg_1_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_2r BCMI_TSCD_XGXS_SERDES_CFG_1_2r
#define SERDES_CFG_1_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_2r_t SERDES_CFG_1_2r_t;
#define SERDES_CFG_1_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_2r_CLR
#define SERDES_CFG_1_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SET
#define SERDES_CFG_1_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_2r_GET
#define SERDES_CFG_1_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SPEED_CFGf_GET
#define SERDES_CFG_1_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_2r
#define WRITE_SERDES_CFG_1_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_2r
#define MODIFY_SERDES_CFG_1_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9323
 * DESC:     Serdes Config Index 1 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_3r (0x00109323 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_3[1];
	uint32_t _serdes_cfg_1_3;
} BCMI_TSCD_XGXS_SERDES_CFG_1_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_3r_CLR(r) (r).serdes_cfg_1_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SET(r,d) (r).serdes_cfg_1_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_3r_GET(r) (r).serdes_cfg_1_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_3[0]=(((r).serdes_cfg_1_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_3r,(_r._serdes_cfg_1_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_3r,(_r._serdes_cfg_1_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_3r,(_r._serdes_cfg_1_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_3r BCMI_TSCD_XGXS_SERDES_CFG_1_3r
#define SERDES_CFG_1_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_3r_t SERDES_CFG_1_3r_t;
#define SERDES_CFG_1_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_3r_CLR
#define SERDES_CFG_1_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SET
#define SERDES_CFG_1_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_3r_GET
#define SERDES_CFG_1_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SPEED_CFGf_GET
#define SERDES_CFG_1_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_3r
#define WRITE_SERDES_CFG_1_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_3r
#define MODIFY_SERDES_CFG_1_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9324
 * DESC:     Serdes Config Index 1 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_4r (0x00109324 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_4[1];
	uint32_t _serdes_cfg_1_4;
} BCMI_TSCD_XGXS_SERDES_CFG_1_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_4r_CLR(r) (r).serdes_cfg_1_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SET(r,d) (r).serdes_cfg_1_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_4r_GET(r) (r).serdes_cfg_1_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_4[0]=(((r).serdes_cfg_1_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_4r,(_r._serdes_cfg_1_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_4r,(_r._serdes_cfg_1_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_4r,(_r._serdes_cfg_1_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_4r BCMI_TSCD_XGXS_SERDES_CFG_1_4r
#define SERDES_CFG_1_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_4r_t SERDES_CFG_1_4r_t;
#define SERDES_CFG_1_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_4r_CLR
#define SERDES_CFG_1_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SET
#define SERDES_CFG_1_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_4r_GET
#define SERDES_CFG_1_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SPEED_CFGf_GET
#define SERDES_CFG_1_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_4r
#define WRITE_SERDES_CFG_1_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_4r
#define MODIFY_SERDES_CFG_1_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9325
 * DESC:     Serdes Config Index 1 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_5r (0x00109325 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_5[1];
	uint32_t _serdes_cfg_1_5;
} BCMI_TSCD_XGXS_SERDES_CFG_1_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_5r_CLR(r) (r).serdes_cfg_1_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SET(r,d) (r).serdes_cfg_1_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_5r_GET(r) (r).serdes_cfg_1_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_5[0]=(((r).serdes_cfg_1_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_5r,(_r._serdes_cfg_1_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_5r,(_r._serdes_cfg_1_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_5r,(_r._serdes_cfg_1_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_5r BCMI_TSCD_XGXS_SERDES_CFG_1_5r
#define SERDES_CFG_1_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_5r_t SERDES_CFG_1_5r_t;
#define SERDES_CFG_1_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_5r_CLR
#define SERDES_CFG_1_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SET
#define SERDES_CFG_1_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_5r_GET
#define SERDES_CFG_1_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SPEED_CFGf_GET
#define SERDES_CFG_1_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_5r
#define WRITE_SERDES_CFG_1_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_5r
#define MODIFY_SERDES_CFG_1_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9326
 * DESC:     Serdes Config Index 1 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_6r (0x00109326 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_6[1];
	uint32_t _serdes_cfg_1_6;
} BCMI_TSCD_XGXS_SERDES_CFG_1_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_6r_CLR(r) (r).serdes_cfg_1_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SET(r,d) (r).serdes_cfg_1_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_6r_GET(r) (r).serdes_cfg_1_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_6[0]=(((r).serdes_cfg_1_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_6r,(_r._serdes_cfg_1_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_6r,(_r._serdes_cfg_1_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_6r,(_r._serdes_cfg_1_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_6r BCMI_TSCD_XGXS_SERDES_CFG_1_6r
#define SERDES_CFG_1_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_6r_t SERDES_CFG_1_6r_t;
#define SERDES_CFG_1_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_6r_CLR
#define SERDES_CFG_1_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SET
#define SERDES_CFG_1_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_6r_GET
#define SERDES_CFG_1_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SPEED_CFGf_GET
#define SERDES_CFG_1_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_6r
#define WRITE_SERDES_CFG_1_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_6r
#define MODIFY_SERDES_CFG_1_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9327
 * DESC:     Serdes Config Index 1 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_7r (0x00109327 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_7[1];
	uint32_t _serdes_cfg_1_7;
} BCMI_TSCD_XGXS_SERDES_CFG_1_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_7r_CLR(r) (r).serdes_cfg_1_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SET(r,d) (r).serdes_cfg_1_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_7r_GET(r) (r).serdes_cfg_1_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_7[0]=(((r).serdes_cfg_1_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_7r,(_r._serdes_cfg_1_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_7r,(_r._serdes_cfg_1_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_7r,(_r._serdes_cfg_1_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_7r BCMI_TSCD_XGXS_SERDES_CFG_1_7r
#define SERDES_CFG_1_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_7r_t SERDES_CFG_1_7r_t;
#define SERDES_CFG_1_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_7r_CLR
#define SERDES_CFG_1_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SET
#define SERDES_CFG_1_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_7r_GET
#define SERDES_CFG_1_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SPEED_CFGf_GET
#define SERDES_CFG_1_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_7r
#define WRITE_SERDES_CFG_1_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_7r
#define MODIFY_SERDES_CFG_1_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9328
 * DESC:     Serdes Config Index 1 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_8r (0x00109328 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_8[1];
	uint32_t _serdes_cfg_1_8;
} BCMI_TSCD_XGXS_SERDES_CFG_1_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_8r_CLR(r) (r).serdes_cfg_1_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SET(r,d) (r).serdes_cfg_1_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_8r_GET(r) (r).serdes_cfg_1_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_8[0]=(((r).serdes_cfg_1_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_8r,(_r._serdes_cfg_1_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_8r,(_r._serdes_cfg_1_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_8r,(_r._serdes_cfg_1_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_8r BCMI_TSCD_XGXS_SERDES_CFG_1_8r
#define SERDES_CFG_1_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_8r_t SERDES_CFG_1_8r_t;
#define SERDES_CFG_1_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_8r_CLR
#define SERDES_CFG_1_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SET
#define SERDES_CFG_1_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_8r_GET
#define SERDES_CFG_1_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SPEED_CFGf_GET
#define SERDES_CFG_1_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_8r
#define WRITE_SERDES_CFG_1_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_8r
#define MODIFY_SERDES_CFG_1_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9329
 * DESC:     Serdes Config Index 1 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_9r (0x00109329 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_9[1];
	uint32_t _serdes_cfg_1_9;
} BCMI_TSCD_XGXS_SERDES_CFG_1_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_9r_CLR(r) (r).serdes_cfg_1_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SET(r,d) (r).serdes_cfg_1_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_9r_GET(r) (r).serdes_cfg_1_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_9[0]=(((r).serdes_cfg_1_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_9r,(_r._serdes_cfg_1_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_9r,(_r._serdes_cfg_1_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_9r,(_r._serdes_cfg_1_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_9r BCMI_TSCD_XGXS_SERDES_CFG_1_9r
#define SERDES_CFG_1_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_9r_t SERDES_CFG_1_9r_t;
#define SERDES_CFG_1_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_9r_CLR
#define SERDES_CFG_1_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SET
#define SERDES_CFG_1_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_9r_GET
#define SERDES_CFG_1_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SPEED_CFGf_GET
#define SERDES_CFG_1_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_9r
#define WRITE_SERDES_CFG_1_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_9r
#define MODIFY_SERDES_CFG_1_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x932a
 * DESC:     Serdes Config Index 1 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_10r (0x0010932a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_10[1];
	uint32_t _serdes_cfg_1_10;
} BCMI_TSCD_XGXS_SERDES_CFG_1_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_10r_CLR(r) (r).serdes_cfg_1_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SET(r,d) (r).serdes_cfg_1_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_10r_GET(r) (r).serdes_cfg_1_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_10[0]=(((r).serdes_cfg_1_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_10r,(_r._serdes_cfg_1_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_10r,(_r._serdes_cfg_1_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_10r,(_r._serdes_cfg_1_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_10r BCMI_TSCD_XGXS_SERDES_CFG_1_10r
#define SERDES_CFG_1_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_10r_t SERDES_CFG_1_10r_t;
#define SERDES_CFG_1_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_10r_CLR
#define SERDES_CFG_1_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SET
#define SERDES_CFG_1_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_10r_GET
#define SERDES_CFG_1_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SPEED_CFGf_GET
#define SERDES_CFG_1_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_10r
#define WRITE_SERDES_CFG_1_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_10r
#define MODIFY_SERDES_CFG_1_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x932b
 * DESC:     Serdes Config Index 1 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_11r (0x0010932b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_11[1];
	uint32_t _serdes_cfg_1_11;
} BCMI_TSCD_XGXS_SERDES_CFG_1_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_11r_CLR(r) (r).serdes_cfg_1_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SET(r,d) (r).serdes_cfg_1_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_11r_GET(r) (r).serdes_cfg_1_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_11[0]=(((r).serdes_cfg_1_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_11r,(_r._serdes_cfg_1_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_11r,(_r._serdes_cfg_1_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_11r,(_r._serdes_cfg_1_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_11r BCMI_TSCD_XGXS_SERDES_CFG_1_11r
#define SERDES_CFG_1_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_11r_t SERDES_CFG_1_11r_t;
#define SERDES_CFG_1_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_11r_CLR
#define SERDES_CFG_1_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SET
#define SERDES_CFG_1_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_11r_GET
#define SERDES_CFG_1_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SPEED_CFGf_GET
#define SERDES_CFG_1_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_11r
#define WRITE_SERDES_CFG_1_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_11r
#define MODIFY_SERDES_CFG_1_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x932c
 * DESC:     Serdes Config Index 1 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_12r (0x0010932c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_12[1];
	uint32_t _serdes_cfg_1_12;
} BCMI_TSCD_XGXS_SERDES_CFG_1_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_12r_CLR(r) (r).serdes_cfg_1_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SET(r,d) (r).serdes_cfg_1_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_12r_GET(r) (r).serdes_cfg_1_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_12[0]=(((r).serdes_cfg_1_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_12r,(_r._serdes_cfg_1_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_12r,(_r._serdes_cfg_1_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_12r,(_r._serdes_cfg_1_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_12r BCMI_TSCD_XGXS_SERDES_CFG_1_12r
#define SERDES_CFG_1_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_12r_t SERDES_CFG_1_12r_t;
#define SERDES_CFG_1_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_12r_CLR
#define SERDES_CFG_1_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SET
#define SERDES_CFG_1_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_12r_GET
#define SERDES_CFG_1_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SPEED_CFGf_GET
#define SERDES_CFG_1_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_12r
#define WRITE_SERDES_CFG_1_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_12r
#define MODIFY_SERDES_CFG_1_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x932d
 * DESC:     Serdes Config Index 1 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_13r (0x0010932d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_13[1];
	uint32_t _serdes_cfg_1_13;
} BCMI_TSCD_XGXS_SERDES_CFG_1_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_13r_CLR(r) (r).serdes_cfg_1_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SET(r,d) (r).serdes_cfg_1_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_13r_GET(r) (r).serdes_cfg_1_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_13[0]=(((r).serdes_cfg_1_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_13r,(_r._serdes_cfg_1_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_13r,(_r._serdes_cfg_1_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_13r,(_r._serdes_cfg_1_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_13r BCMI_TSCD_XGXS_SERDES_CFG_1_13r
#define SERDES_CFG_1_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_13r_t SERDES_CFG_1_13r_t;
#define SERDES_CFG_1_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_13r_CLR
#define SERDES_CFG_1_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SET
#define SERDES_CFG_1_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_13r_GET
#define SERDES_CFG_1_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SPEED_CFGf_GET
#define SERDES_CFG_1_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_13r
#define WRITE_SERDES_CFG_1_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_13r
#define MODIFY_SERDES_CFG_1_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x932e
 * DESC:     Serdes Config Index 1 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_14r (0x0010932e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_14[1];
	uint32_t _serdes_cfg_1_14;
} BCMI_TSCD_XGXS_SERDES_CFG_1_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_14r_CLR(r) (r).serdes_cfg_1_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SET(r,d) (r).serdes_cfg_1_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_14r_GET(r) (r).serdes_cfg_1_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_14[0]=(((r).serdes_cfg_1_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_14r,(_r._serdes_cfg_1_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_14r,(_r._serdes_cfg_1_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_14r,(_r._serdes_cfg_1_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_14r BCMI_TSCD_XGXS_SERDES_CFG_1_14r
#define SERDES_CFG_1_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_14r_t SERDES_CFG_1_14r_t;
#define SERDES_CFG_1_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_14r_CLR
#define SERDES_CFG_1_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SET
#define SERDES_CFG_1_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_14r_GET
#define SERDES_CFG_1_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SPEED_CFGf_GET
#define SERDES_CFG_1_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_14r
#define WRITE_SERDES_CFG_1_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_14r
#define MODIFY_SERDES_CFG_1_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x932f
 * DESC:     Serdes Config Index 1 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_15r (0x0010932f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_15[1];
	uint32_t _serdes_cfg_1_15;
} BCMI_TSCD_XGXS_SERDES_CFG_1_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_15r_CLR(r) (r).serdes_cfg_1_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SET(r,d) (r).serdes_cfg_1_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_15r_GET(r) (r).serdes_cfg_1_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_15[0]=(((r).serdes_cfg_1_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_15r,(_r._serdes_cfg_1_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_15r,(_r._serdes_cfg_1_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_15r,(_r._serdes_cfg_1_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_15r BCMI_TSCD_XGXS_SERDES_CFG_1_15r
#define SERDES_CFG_1_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_15r_t SERDES_CFG_1_15r_t;
#define SERDES_CFG_1_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_15r_CLR
#define SERDES_CFG_1_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SET
#define SERDES_CFG_1_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_15r_GET
#define SERDES_CFG_1_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SPEED_CFGf_GET
#define SERDES_CFG_1_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_15r
#define WRITE_SERDES_CFG_1_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_15r
#define MODIFY_SERDES_CFG_1_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9330
 * DESC:     Serdes Config Index 1 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_16r (0x00109330 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_16[1];
	uint32_t _serdes_cfg_1_16;
} BCMI_TSCD_XGXS_SERDES_CFG_1_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_16r_CLR(r) (r).serdes_cfg_1_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SET(r,d) (r).serdes_cfg_1_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_16r_GET(r) (r).serdes_cfg_1_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_16[0]=(((r).serdes_cfg_1_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_16r,(_r._serdes_cfg_1_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_16r,(_r._serdes_cfg_1_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_16r,(_r._serdes_cfg_1_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_16r BCMI_TSCD_XGXS_SERDES_CFG_1_16r
#define SERDES_CFG_1_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_16r_t SERDES_CFG_1_16r_t;
#define SERDES_CFG_1_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_16r_CLR
#define SERDES_CFG_1_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SET
#define SERDES_CFG_1_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_16r_GET
#define SERDES_CFG_1_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SPEED_CFGf_GET
#define SERDES_CFG_1_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_16r
#define WRITE_SERDES_CFG_1_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_16r
#define MODIFY_SERDES_CFG_1_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9331
 * DESC:     Serdes Config Index 1 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_17r (0x00109331 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_17[1];
	uint32_t _serdes_cfg_1_17;
} BCMI_TSCD_XGXS_SERDES_CFG_1_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_17r_CLR(r) (r).serdes_cfg_1_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SET(r,d) (r).serdes_cfg_1_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_17r_GET(r) (r).serdes_cfg_1_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_17[0]=(((r).serdes_cfg_1_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_17r,(_r._serdes_cfg_1_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_17r,(_r._serdes_cfg_1_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_17r,(_r._serdes_cfg_1_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_17r BCMI_TSCD_XGXS_SERDES_CFG_1_17r
#define SERDES_CFG_1_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_17r_t SERDES_CFG_1_17r_t;
#define SERDES_CFG_1_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_17r_CLR
#define SERDES_CFG_1_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SET
#define SERDES_CFG_1_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_17r_GET
#define SERDES_CFG_1_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SPEED_CFGf_GET
#define SERDES_CFG_1_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_17r
#define WRITE_SERDES_CFG_1_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_17r
#define MODIFY_SERDES_CFG_1_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9332
 * DESC:     Serdes Config Index 1 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_18r (0x00109332 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_18[1];
	uint32_t _serdes_cfg_1_18;
} BCMI_TSCD_XGXS_SERDES_CFG_1_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_18r_CLR(r) (r).serdes_cfg_1_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SET(r,d) (r).serdes_cfg_1_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_18r_GET(r) (r).serdes_cfg_1_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_18[0]=(((r).serdes_cfg_1_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_18r,(_r._serdes_cfg_1_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_18r,(_r._serdes_cfg_1_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_18r,(_r._serdes_cfg_1_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_18r BCMI_TSCD_XGXS_SERDES_CFG_1_18r
#define SERDES_CFG_1_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_18r_t SERDES_CFG_1_18r_t;
#define SERDES_CFG_1_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_18r_CLR
#define SERDES_CFG_1_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SET
#define SERDES_CFG_1_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_18r_GET
#define SERDES_CFG_1_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SPEED_CFGf_GET
#define SERDES_CFG_1_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_18r
#define WRITE_SERDES_CFG_1_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_18r
#define MODIFY_SERDES_CFG_1_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9333
 * DESC:     Serdes Config Index 1 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_19r (0x00109333 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_19[1];
	uint32_t _serdes_cfg_1_19;
} BCMI_TSCD_XGXS_SERDES_CFG_1_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_19r_CLR(r) (r).serdes_cfg_1_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SET(r,d) (r).serdes_cfg_1_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_19r_GET(r) (r).serdes_cfg_1_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_19[0]=(((r).serdes_cfg_1_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_19r,(_r._serdes_cfg_1_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_19r,(_r._serdes_cfg_1_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_19r,(_r._serdes_cfg_1_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_19r BCMI_TSCD_XGXS_SERDES_CFG_1_19r
#define SERDES_CFG_1_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_19r_t SERDES_CFG_1_19r_t;
#define SERDES_CFG_1_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_19r_CLR
#define SERDES_CFG_1_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SET
#define SERDES_CFG_1_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_19r_GET
#define SERDES_CFG_1_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SPEED_CFGf_GET
#define SERDES_CFG_1_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_19r
#define WRITE_SERDES_CFG_1_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_19r
#define MODIFY_SERDES_CFG_1_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9334
 * DESC:     Serdes Config Index 1 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_20r (0x00109334 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_20[1];
	uint32_t _serdes_cfg_1_20;
} BCMI_TSCD_XGXS_SERDES_CFG_1_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_20r_CLR(r) (r).serdes_cfg_1_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SET(r,d) (r).serdes_cfg_1_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_20r_GET(r) (r).serdes_cfg_1_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_1_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_1_20[0]=(((r).serdes_cfg_1_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_1_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_20r,(_r._serdes_cfg_1_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_20r,(_r._serdes_cfg_1_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_20r,(_r._serdes_cfg_1_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_20r BCMI_TSCD_XGXS_SERDES_CFG_1_20r
#define SERDES_CFG_1_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_20r_t SERDES_CFG_1_20r_t;
#define SERDES_CFG_1_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_20r_CLR
#define SERDES_CFG_1_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SET
#define SERDES_CFG_1_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_20r_GET
#define SERDES_CFG_1_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SPEED_CFGf_GET
#define SERDES_CFG_1_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_1_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_20r
#define WRITE_SERDES_CFG_1_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_20r
#define MODIFY_SERDES_CFG_1_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9335
 * DESC:     Serdes Config Index 1 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_21r (0x00109335 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_21[1];
	uint32_t _serdes_cfg_1_21;
} BCMI_TSCD_XGXS_SERDES_CFG_1_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_21r_CLR(r) (r).serdes_cfg_1_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_21r_SET(r,d) (r).serdes_cfg_1_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_21r_GET(r) (r).serdes_cfg_1_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_1_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_1_21[0]=(((r).serdes_cfg_1_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_1_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_21r,(_r._serdes_cfg_1_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_21r,(_r._serdes_cfg_1_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_21r,(_r._serdes_cfg_1_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_21r BCMI_TSCD_XGXS_SERDES_CFG_1_21r
#define SERDES_CFG_1_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_21r_t SERDES_CFG_1_21r_t;
#define SERDES_CFG_1_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_21r_CLR
#define SERDES_CFG_1_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_21r_SET
#define SERDES_CFG_1_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_21r_GET
#define SERDES_CFG_1_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_21r_FCLK_PERIODf_GET
#define SERDES_CFG_1_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_1_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_21r
#define WRITE_SERDES_CFG_1_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_21r
#define MODIFY_SERDES_CFG_1_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9336
 * DESC:     Serdes Config Index 1 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r (0x00109336 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_22[1];
	uint32_t _serdes_cfg_1_22;
} BCMI_TSCD_XGXS_SERDES_CFG_1_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_CLR(r) (r).serdes_cfg_1_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SET(r,d) (r).serdes_cfg_1_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_GET(r) (r).serdes_cfg_1_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SPAREf_GET(r) ((((r).serdes_cfg_1_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SPAREf_SET(r,f) (r).serdes_cfg_1_22[0]=(((r).serdes_cfg_1_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_1_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_1_22[0]=(((r).serdes_cfg_1_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_1_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_22r,(_r._serdes_cfg_1_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_22r,(_r._serdes_cfg_1_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_22r,(_r._serdes_cfg_1_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_22r BCMI_TSCD_XGXS_SERDES_CFG_1_22r
#define SERDES_CFG_1_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_22r_t SERDES_CFG_1_22r_t;
#define SERDES_CFG_1_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_22r_CLR
#define SERDES_CFG_1_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SET
#define SERDES_CFG_1_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_22r_GET
#define SERDES_CFG_1_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SPAREf_GET
#define SERDES_CFG_1_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_22r_SPAREf_SET
#define SERDES_CFG_1_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_22r_RX_LOSVREFf_GET
#define SERDES_CFG_1_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_1_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_22r
#define WRITE_SERDES_CFG_1_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_22r
#define MODIFY_SERDES_CFG_1_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_1_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9337
 * DESC:     Serdes Config Index 1 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r (0x00109337 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_1_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_1_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_1_23[1];
	uint32_t _serdes_cfg_1_23;
} BCMI_TSCD_XGXS_SERDES_CFG_1_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_CLR(r) (r).serdes_cfg_1_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_SET(r,d) (r).serdes_cfg_1_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_GET(r) (r).serdes_cfg_1_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_1_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_1_23[0]=(((r).serdes_cfg_1_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_1_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_1_23[0]=(((r).serdes_cfg_1_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_1_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_1_23[0]=(((r).serdes_cfg_1_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_RATESELf_GET(r) ((((r).serdes_cfg_1_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_RATESELf_SET(r,f) (r).serdes_cfg_1_23[0]=(((r).serdes_cfg_1_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_1_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_1_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_1_23[0]=(((r).serdes_cfg_1_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_1_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_1_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_23r,(_r._serdes_cfg_1_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_23r,(_r._serdes_cfg_1_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_1_23r,(_r._serdes_cfg_1_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_1_23r BCMI_TSCD_XGXS_SERDES_CFG_1_23r
#define SERDES_CFG_1_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_1_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_1_23r_t SERDES_CFG_1_23r_t;
#define SERDES_CFG_1_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_1_23r_CLR
#define SERDES_CFG_1_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_SET
#define SERDES_CFG_1_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_GET
#define SERDES_CFG_1_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_1_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_1_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODEf_GET
#define SERDES_CFG_1_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_TRAINING_MODEf_SET
#define SERDES_CFG_1_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_WORDMODEf_GET
#define SERDES_CFG_1_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_WORDMODEf_SET
#define SERDES_CFG_1_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_RATESELf_GET
#define SERDES_CFG_1_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_RATESELf_SET
#define SERDES_CFG_1_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_1_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_1_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_1_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_1_23r
#define WRITE_SERDES_CFG_1_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_1_23r
#define MODIFY_SERDES_CFG_1_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_1_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_1_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9340
 * DESC:     Serdes Config Index 2 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_0r (0x00109340 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_0[1];
	uint32_t _serdes_cfg_2_0;
} BCMI_TSCD_XGXS_SERDES_CFG_2_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_0r_CLR(r) (r).serdes_cfg_2_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SET(r,d) (r).serdes_cfg_2_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_0r_GET(r) (r).serdes_cfg_2_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_0[0]=(((r).serdes_cfg_2_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_0r,(_r._serdes_cfg_2_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_0r,(_r._serdes_cfg_2_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_0r,(_r._serdes_cfg_2_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_0r BCMI_TSCD_XGXS_SERDES_CFG_2_0r
#define SERDES_CFG_2_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_0r_t SERDES_CFG_2_0r_t;
#define SERDES_CFG_2_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_0r_CLR
#define SERDES_CFG_2_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SET
#define SERDES_CFG_2_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_0r_GET
#define SERDES_CFG_2_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SPEED_CFGf_GET
#define SERDES_CFG_2_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_0r
#define WRITE_SERDES_CFG_2_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_0r
#define MODIFY_SERDES_CFG_2_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9341
 * DESC:     Serdes Config Index 2 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_1r (0x00109341 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_1[1];
	uint32_t _serdes_cfg_2_1;
} BCMI_TSCD_XGXS_SERDES_CFG_2_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_1r_CLR(r) (r).serdes_cfg_2_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SET(r,d) (r).serdes_cfg_2_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_1r_GET(r) (r).serdes_cfg_2_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_1[0]=(((r).serdes_cfg_2_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_1r,(_r._serdes_cfg_2_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_1r,(_r._serdes_cfg_2_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_1r,(_r._serdes_cfg_2_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_1r BCMI_TSCD_XGXS_SERDES_CFG_2_1r
#define SERDES_CFG_2_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_1r_t SERDES_CFG_2_1r_t;
#define SERDES_CFG_2_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_1r_CLR
#define SERDES_CFG_2_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SET
#define SERDES_CFG_2_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_1r_GET
#define SERDES_CFG_2_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SPEED_CFGf_GET
#define SERDES_CFG_2_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_1r
#define WRITE_SERDES_CFG_2_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_1r
#define MODIFY_SERDES_CFG_2_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9342
 * DESC:     Serdes Config Index 2 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_2r (0x00109342 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_2[1];
	uint32_t _serdes_cfg_2_2;
} BCMI_TSCD_XGXS_SERDES_CFG_2_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_2r_CLR(r) (r).serdes_cfg_2_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SET(r,d) (r).serdes_cfg_2_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_2r_GET(r) (r).serdes_cfg_2_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_2[0]=(((r).serdes_cfg_2_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_2r,(_r._serdes_cfg_2_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_2r,(_r._serdes_cfg_2_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_2r,(_r._serdes_cfg_2_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_2r BCMI_TSCD_XGXS_SERDES_CFG_2_2r
#define SERDES_CFG_2_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_2r_t SERDES_CFG_2_2r_t;
#define SERDES_CFG_2_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_2r_CLR
#define SERDES_CFG_2_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SET
#define SERDES_CFG_2_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_2r_GET
#define SERDES_CFG_2_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SPEED_CFGf_GET
#define SERDES_CFG_2_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_2r
#define WRITE_SERDES_CFG_2_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_2r
#define MODIFY_SERDES_CFG_2_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9343
 * DESC:     Serdes Config Index 2 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_3r (0x00109343 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_3[1];
	uint32_t _serdes_cfg_2_3;
} BCMI_TSCD_XGXS_SERDES_CFG_2_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_3r_CLR(r) (r).serdes_cfg_2_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SET(r,d) (r).serdes_cfg_2_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_3r_GET(r) (r).serdes_cfg_2_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_3[0]=(((r).serdes_cfg_2_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_3r,(_r._serdes_cfg_2_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_3r,(_r._serdes_cfg_2_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_3r,(_r._serdes_cfg_2_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_3r BCMI_TSCD_XGXS_SERDES_CFG_2_3r
#define SERDES_CFG_2_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_3r_t SERDES_CFG_2_3r_t;
#define SERDES_CFG_2_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_3r_CLR
#define SERDES_CFG_2_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SET
#define SERDES_CFG_2_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_3r_GET
#define SERDES_CFG_2_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SPEED_CFGf_GET
#define SERDES_CFG_2_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_3r
#define WRITE_SERDES_CFG_2_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_3r
#define MODIFY_SERDES_CFG_2_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9344
 * DESC:     Serdes Config Index 2 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_4r (0x00109344 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_4[1];
	uint32_t _serdes_cfg_2_4;
} BCMI_TSCD_XGXS_SERDES_CFG_2_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_4r_CLR(r) (r).serdes_cfg_2_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SET(r,d) (r).serdes_cfg_2_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_4r_GET(r) (r).serdes_cfg_2_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_4[0]=(((r).serdes_cfg_2_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_4r,(_r._serdes_cfg_2_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_4r,(_r._serdes_cfg_2_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_4r,(_r._serdes_cfg_2_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_4r BCMI_TSCD_XGXS_SERDES_CFG_2_4r
#define SERDES_CFG_2_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_4r_t SERDES_CFG_2_4r_t;
#define SERDES_CFG_2_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_4r_CLR
#define SERDES_CFG_2_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SET
#define SERDES_CFG_2_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_4r_GET
#define SERDES_CFG_2_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SPEED_CFGf_GET
#define SERDES_CFG_2_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_4r
#define WRITE_SERDES_CFG_2_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_4r
#define MODIFY_SERDES_CFG_2_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9345
 * DESC:     Serdes Config Index 2 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_5r (0x00109345 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_5[1];
	uint32_t _serdes_cfg_2_5;
} BCMI_TSCD_XGXS_SERDES_CFG_2_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_5r_CLR(r) (r).serdes_cfg_2_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SET(r,d) (r).serdes_cfg_2_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_5r_GET(r) (r).serdes_cfg_2_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_5[0]=(((r).serdes_cfg_2_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_5r,(_r._serdes_cfg_2_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_5r,(_r._serdes_cfg_2_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_5r,(_r._serdes_cfg_2_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_5r BCMI_TSCD_XGXS_SERDES_CFG_2_5r
#define SERDES_CFG_2_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_5r_t SERDES_CFG_2_5r_t;
#define SERDES_CFG_2_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_5r_CLR
#define SERDES_CFG_2_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SET
#define SERDES_CFG_2_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_5r_GET
#define SERDES_CFG_2_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SPEED_CFGf_GET
#define SERDES_CFG_2_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_5r
#define WRITE_SERDES_CFG_2_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_5r
#define MODIFY_SERDES_CFG_2_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9346
 * DESC:     Serdes Config Index 2 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_6r (0x00109346 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_6[1];
	uint32_t _serdes_cfg_2_6;
} BCMI_TSCD_XGXS_SERDES_CFG_2_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_6r_CLR(r) (r).serdes_cfg_2_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SET(r,d) (r).serdes_cfg_2_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_6r_GET(r) (r).serdes_cfg_2_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_6[0]=(((r).serdes_cfg_2_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_6r,(_r._serdes_cfg_2_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_6r,(_r._serdes_cfg_2_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_6r,(_r._serdes_cfg_2_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_6r BCMI_TSCD_XGXS_SERDES_CFG_2_6r
#define SERDES_CFG_2_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_6r_t SERDES_CFG_2_6r_t;
#define SERDES_CFG_2_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_6r_CLR
#define SERDES_CFG_2_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SET
#define SERDES_CFG_2_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_6r_GET
#define SERDES_CFG_2_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SPEED_CFGf_GET
#define SERDES_CFG_2_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_6r
#define WRITE_SERDES_CFG_2_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_6r
#define MODIFY_SERDES_CFG_2_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9347
 * DESC:     Serdes Config Index 2 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_7r (0x00109347 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_7[1];
	uint32_t _serdes_cfg_2_7;
} BCMI_TSCD_XGXS_SERDES_CFG_2_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_7r_CLR(r) (r).serdes_cfg_2_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SET(r,d) (r).serdes_cfg_2_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_7r_GET(r) (r).serdes_cfg_2_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_7[0]=(((r).serdes_cfg_2_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_7r,(_r._serdes_cfg_2_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_7r,(_r._serdes_cfg_2_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_7r,(_r._serdes_cfg_2_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_7r BCMI_TSCD_XGXS_SERDES_CFG_2_7r
#define SERDES_CFG_2_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_7r_t SERDES_CFG_2_7r_t;
#define SERDES_CFG_2_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_7r_CLR
#define SERDES_CFG_2_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SET
#define SERDES_CFG_2_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_7r_GET
#define SERDES_CFG_2_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SPEED_CFGf_GET
#define SERDES_CFG_2_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_7r
#define WRITE_SERDES_CFG_2_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_7r
#define MODIFY_SERDES_CFG_2_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9348
 * DESC:     Serdes Config Index 2 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_8r (0x00109348 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_8[1];
	uint32_t _serdes_cfg_2_8;
} BCMI_TSCD_XGXS_SERDES_CFG_2_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_8r_CLR(r) (r).serdes_cfg_2_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SET(r,d) (r).serdes_cfg_2_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_8r_GET(r) (r).serdes_cfg_2_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_8[0]=(((r).serdes_cfg_2_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_8r,(_r._serdes_cfg_2_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_8r,(_r._serdes_cfg_2_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_8r,(_r._serdes_cfg_2_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_8r BCMI_TSCD_XGXS_SERDES_CFG_2_8r
#define SERDES_CFG_2_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_8r_t SERDES_CFG_2_8r_t;
#define SERDES_CFG_2_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_8r_CLR
#define SERDES_CFG_2_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SET
#define SERDES_CFG_2_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_8r_GET
#define SERDES_CFG_2_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SPEED_CFGf_GET
#define SERDES_CFG_2_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_8r
#define WRITE_SERDES_CFG_2_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_8r
#define MODIFY_SERDES_CFG_2_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9349
 * DESC:     Serdes Config Index 2 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_9r (0x00109349 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_9[1];
	uint32_t _serdes_cfg_2_9;
} BCMI_TSCD_XGXS_SERDES_CFG_2_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_9r_CLR(r) (r).serdes_cfg_2_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SET(r,d) (r).serdes_cfg_2_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_9r_GET(r) (r).serdes_cfg_2_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_9[0]=(((r).serdes_cfg_2_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_9r,(_r._serdes_cfg_2_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_9r,(_r._serdes_cfg_2_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_9r,(_r._serdes_cfg_2_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_9r BCMI_TSCD_XGXS_SERDES_CFG_2_9r
#define SERDES_CFG_2_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_9r_t SERDES_CFG_2_9r_t;
#define SERDES_CFG_2_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_9r_CLR
#define SERDES_CFG_2_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SET
#define SERDES_CFG_2_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_9r_GET
#define SERDES_CFG_2_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SPEED_CFGf_GET
#define SERDES_CFG_2_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_9r
#define WRITE_SERDES_CFG_2_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_9r
#define MODIFY_SERDES_CFG_2_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x934a
 * DESC:     Serdes Config Index 2 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_10r (0x0010934a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_10[1];
	uint32_t _serdes_cfg_2_10;
} BCMI_TSCD_XGXS_SERDES_CFG_2_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_10r_CLR(r) (r).serdes_cfg_2_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SET(r,d) (r).serdes_cfg_2_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_10r_GET(r) (r).serdes_cfg_2_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_10[0]=(((r).serdes_cfg_2_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_10r,(_r._serdes_cfg_2_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_10r,(_r._serdes_cfg_2_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_10r,(_r._serdes_cfg_2_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_10r BCMI_TSCD_XGXS_SERDES_CFG_2_10r
#define SERDES_CFG_2_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_10r_t SERDES_CFG_2_10r_t;
#define SERDES_CFG_2_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_10r_CLR
#define SERDES_CFG_2_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SET
#define SERDES_CFG_2_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_10r_GET
#define SERDES_CFG_2_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SPEED_CFGf_GET
#define SERDES_CFG_2_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_10r
#define WRITE_SERDES_CFG_2_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_10r
#define MODIFY_SERDES_CFG_2_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x934b
 * DESC:     Serdes Config Index 2 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_11r (0x0010934b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_11[1];
	uint32_t _serdes_cfg_2_11;
} BCMI_TSCD_XGXS_SERDES_CFG_2_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_11r_CLR(r) (r).serdes_cfg_2_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SET(r,d) (r).serdes_cfg_2_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_11r_GET(r) (r).serdes_cfg_2_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_11[0]=(((r).serdes_cfg_2_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_11r,(_r._serdes_cfg_2_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_11r,(_r._serdes_cfg_2_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_11r,(_r._serdes_cfg_2_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_11r BCMI_TSCD_XGXS_SERDES_CFG_2_11r
#define SERDES_CFG_2_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_11r_t SERDES_CFG_2_11r_t;
#define SERDES_CFG_2_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_11r_CLR
#define SERDES_CFG_2_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SET
#define SERDES_CFG_2_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_11r_GET
#define SERDES_CFG_2_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SPEED_CFGf_GET
#define SERDES_CFG_2_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_11r
#define WRITE_SERDES_CFG_2_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_11r
#define MODIFY_SERDES_CFG_2_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x934c
 * DESC:     Serdes Config Index 2 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_12r (0x0010934c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_12[1];
	uint32_t _serdes_cfg_2_12;
} BCMI_TSCD_XGXS_SERDES_CFG_2_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_12r_CLR(r) (r).serdes_cfg_2_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SET(r,d) (r).serdes_cfg_2_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_12r_GET(r) (r).serdes_cfg_2_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_12[0]=(((r).serdes_cfg_2_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_12r,(_r._serdes_cfg_2_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_12r,(_r._serdes_cfg_2_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_12r,(_r._serdes_cfg_2_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_12r BCMI_TSCD_XGXS_SERDES_CFG_2_12r
#define SERDES_CFG_2_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_12r_t SERDES_CFG_2_12r_t;
#define SERDES_CFG_2_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_12r_CLR
#define SERDES_CFG_2_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SET
#define SERDES_CFG_2_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_12r_GET
#define SERDES_CFG_2_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SPEED_CFGf_GET
#define SERDES_CFG_2_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_12r
#define WRITE_SERDES_CFG_2_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_12r
#define MODIFY_SERDES_CFG_2_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x934d
 * DESC:     Serdes Config Index 2 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_13r (0x0010934d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_13[1];
	uint32_t _serdes_cfg_2_13;
} BCMI_TSCD_XGXS_SERDES_CFG_2_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_13r_CLR(r) (r).serdes_cfg_2_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SET(r,d) (r).serdes_cfg_2_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_13r_GET(r) (r).serdes_cfg_2_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_13[0]=(((r).serdes_cfg_2_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_13r,(_r._serdes_cfg_2_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_13r,(_r._serdes_cfg_2_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_13r,(_r._serdes_cfg_2_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_13r BCMI_TSCD_XGXS_SERDES_CFG_2_13r
#define SERDES_CFG_2_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_13r_t SERDES_CFG_2_13r_t;
#define SERDES_CFG_2_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_13r_CLR
#define SERDES_CFG_2_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SET
#define SERDES_CFG_2_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_13r_GET
#define SERDES_CFG_2_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SPEED_CFGf_GET
#define SERDES_CFG_2_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_13r
#define WRITE_SERDES_CFG_2_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_13r
#define MODIFY_SERDES_CFG_2_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x934e
 * DESC:     Serdes Config Index 2 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_14r (0x0010934e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_14[1];
	uint32_t _serdes_cfg_2_14;
} BCMI_TSCD_XGXS_SERDES_CFG_2_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_14r_CLR(r) (r).serdes_cfg_2_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SET(r,d) (r).serdes_cfg_2_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_14r_GET(r) (r).serdes_cfg_2_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_14[0]=(((r).serdes_cfg_2_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_14r,(_r._serdes_cfg_2_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_14r,(_r._serdes_cfg_2_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_14r,(_r._serdes_cfg_2_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_14r BCMI_TSCD_XGXS_SERDES_CFG_2_14r
#define SERDES_CFG_2_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_14r_t SERDES_CFG_2_14r_t;
#define SERDES_CFG_2_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_14r_CLR
#define SERDES_CFG_2_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SET
#define SERDES_CFG_2_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_14r_GET
#define SERDES_CFG_2_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SPEED_CFGf_GET
#define SERDES_CFG_2_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_14r
#define WRITE_SERDES_CFG_2_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_14r
#define MODIFY_SERDES_CFG_2_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x934f
 * DESC:     Serdes Config Index 2 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_15r (0x0010934f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_15[1];
	uint32_t _serdes_cfg_2_15;
} BCMI_TSCD_XGXS_SERDES_CFG_2_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_15r_CLR(r) (r).serdes_cfg_2_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SET(r,d) (r).serdes_cfg_2_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_15r_GET(r) (r).serdes_cfg_2_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_15[0]=(((r).serdes_cfg_2_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_15r,(_r._serdes_cfg_2_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_15r,(_r._serdes_cfg_2_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_15r,(_r._serdes_cfg_2_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_15r BCMI_TSCD_XGXS_SERDES_CFG_2_15r
#define SERDES_CFG_2_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_15r_t SERDES_CFG_2_15r_t;
#define SERDES_CFG_2_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_15r_CLR
#define SERDES_CFG_2_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SET
#define SERDES_CFG_2_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_15r_GET
#define SERDES_CFG_2_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SPEED_CFGf_GET
#define SERDES_CFG_2_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_15r
#define WRITE_SERDES_CFG_2_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_15r
#define MODIFY_SERDES_CFG_2_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9350
 * DESC:     Serdes Config Index 2 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_16r (0x00109350 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_16[1];
	uint32_t _serdes_cfg_2_16;
} BCMI_TSCD_XGXS_SERDES_CFG_2_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_16r_CLR(r) (r).serdes_cfg_2_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SET(r,d) (r).serdes_cfg_2_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_16r_GET(r) (r).serdes_cfg_2_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_16[0]=(((r).serdes_cfg_2_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_16r,(_r._serdes_cfg_2_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_16r,(_r._serdes_cfg_2_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_16r,(_r._serdes_cfg_2_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_16r BCMI_TSCD_XGXS_SERDES_CFG_2_16r
#define SERDES_CFG_2_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_16r_t SERDES_CFG_2_16r_t;
#define SERDES_CFG_2_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_16r_CLR
#define SERDES_CFG_2_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SET
#define SERDES_CFG_2_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_16r_GET
#define SERDES_CFG_2_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SPEED_CFGf_GET
#define SERDES_CFG_2_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_16r
#define WRITE_SERDES_CFG_2_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_16r
#define MODIFY_SERDES_CFG_2_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9351
 * DESC:     Serdes Config Index 2 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_17r (0x00109351 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_17[1];
	uint32_t _serdes_cfg_2_17;
} BCMI_TSCD_XGXS_SERDES_CFG_2_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_17r_CLR(r) (r).serdes_cfg_2_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SET(r,d) (r).serdes_cfg_2_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_17r_GET(r) (r).serdes_cfg_2_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_17[0]=(((r).serdes_cfg_2_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_17r,(_r._serdes_cfg_2_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_17r,(_r._serdes_cfg_2_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_17r,(_r._serdes_cfg_2_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_17r BCMI_TSCD_XGXS_SERDES_CFG_2_17r
#define SERDES_CFG_2_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_17r_t SERDES_CFG_2_17r_t;
#define SERDES_CFG_2_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_17r_CLR
#define SERDES_CFG_2_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SET
#define SERDES_CFG_2_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_17r_GET
#define SERDES_CFG_2_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SPEED_CFGf_GET
#define SERDES_CFG_2_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_17r
#define WRITE_SERDES_CFG_2_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_17r
#define MODIFY_SERDES_CFG_2_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9352
 * DESC:     Serdes Config Index 2 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_18r (0x00109352 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_18[1];
	uint32_t _serdes_cfg_2_18;
} BCMI_TSCD_XGXS_SERDES_CFG_2_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_18r_CLR(r) (r).serdes_cfg_2_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SET(r,d) (r).serdes_cfg_2_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_18r_GET(r) (r).serdes_cfg_2_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_18[0]=(((r).serdes_cfg_2_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_18r,(_r._serdes_cfg_2_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_18r,(_r._serdes_cfg_2_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_18r,(_r._serdes_cfg_2_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_18r BCMI_TSCD_XGXS_SERDES_CFG_2_18r
#define SERDES_CFG_2_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_18r_t SERDES_CFG_2_18r_t;
#define SERDES_CFG_2_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_18r_CLR
#define SERDES_CFG_2_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SET
#define SERDES_CFG_2_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_18r_GET
#define SERDES_CFG_2_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SPEED_CFGf_GET
#define SERDES_CFG_2_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_18r
#define WRITE_SERDES_CFG_2_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_18r
#define MODIFY_SERDES_CFG_2_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9353
 * DESC:     Serdes Config Index 2 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_19r (0x00109353 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_19[1];
	uint32_t _serdes_cfg_2_19;
} BCMI_TSCD_XGXS_SERDES_CFG_2_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_19r_CLR(r) (r).serdes_cfg_2_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SET(r,d) (r).serdes_cfg_2_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_19r_GET(r) (r).serdes_cfg_2_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_19[0]=(((r).serdes_cfg_2_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_19r,(_r._serdes_cfg_2_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_19r,(_r._serdes_cfg_2_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_19r,(_r._serdes_cfg_2_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_19r BCMI_TSCD_XGXS_SERDES_CFG_2_19r
#define SERDES_CFG_2_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_19r_t SERDES_CFG_2_19r_t;
#define SERDES_CFG_2_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_19r_CLR
#define SERDES_CFG_2_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SET
#define SERDES_CFG_2_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_19r_GET
#define SERDES_CFG_2_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SPEED_CFGf_GET
#define SERDES_CFG_2_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_19r
#define WRITE_SERDES_CFG_2_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_19r
#define MODIFY_SERDES_CFG_2_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9354
 * DESC:     Serdes Config Index 2 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_20r (0x00109354 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_20[1];
	uint32_t _serdes_cfg_2_20;
} BCMI_TSCD_XGXS_SERDES_CFG_2_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_20r_CLR(r) (r).serdes_cfg_2_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SET(r,d) (r).serdes_cfg_2_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_20r_GET(r) (r).serdes_cfg_2_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_2_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_2_20[0]=(((r).serdes_cfg_2_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_2_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_20r,(_r._serdes_cfg_2_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_20r,(_r._serdes_cfg_2_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_20r,(_r._serdes_cfg_2_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_20r BCMI_TSCD_XGXS_SERDES_CFG_2_20r
#define SERDES_CFG_2_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_20r_t SERDES_CFG_2_20r_t;
#define SERDES_CFG_2_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_20r_CLR
#define SERDES_CFG_2_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SET
#define SERDES_CFG_2_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_20r_GET
#define SERDES_CFG_2_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SPEED_CFGf_GET
#define SERDES_CFG_2_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_2_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_20r
#define WRITE_SERDES_CFG_2_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_20r
#define MODIFY_SERDES_CFG_2_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9355
 * DESC:     Serdes Config Index 2 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_21r (0x00109355 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_21[1];
	uint32_t _serdes_cfg_2_21;
} BCMI_TSCD_XGXS_SERDES_CFG_2_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_21r_CLR(r) (r).serdes_cfg_2_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_21r_SET(r,d) (r).serdes_cfg_2_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_21r_GET(r) (r).serdes_cfg_2_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_2_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_2_21[0]=(((r).serdes_cfg_2_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_2_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_21r,(_r._serdes_cfg_2_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_21r,(_r._serdes_cfg_2_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_21r,(_r._serdes_cfg_2_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_21r BCMI_TSCD_XGXS_SERDES_CFG_2_21r
#define SERDES_CFG_2_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_21r_t SERDES_CFG_2_21r_t;
#define SERDES_CFG_2_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_21r_CLR
#define SERDES_CFG_2_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_21r_SET
#define SERDES_CFG_2_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_21r_GET
#define SERDES_CFG_2_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_21r_FCLK_PERIODf_GET
#define SERDES_CFG_2_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_2_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_21r
#define WRITE_SERDES_CFG_2_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_21r
#define MODIFY_SERDES_CFG_2_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9356
 * DESC:     Serdes Config Index 2 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r (0x00109356 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_22[1];
	uint32_t _serdes_cfg_2_22;
} BCMI_TSCD_XGXS_SERDES_CFG_2_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_CLR(r) (r).serdes_cfg_2_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SET(r,d) (r).serdes_cfg_2_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_GET(r) (r).serdes_cfg_2_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SPAREf_GET(r) ((((r).serdes_cfg_2_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SPAREf_SET(r,f) (r).serdes_cfg_2_22[0]=(((r).serdes_cfg_2_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_2_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_2_22[0]=(((r).serdes_cfg_2_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_2_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_22r,(_r._serdes_cfg_2_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_22r,(_r._serdes_cfg_2_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_22r,(_r._serdes_cfg_2_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_22r BCMI_TSCD_XGXS_SERDES_CFG_2_22r
#define SERDES_CFG_2_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_22r_t SERDES_CFG_2_22r_t;
#define SERDES_CFG_2_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_22r_CLR
#define SERDES_CFG_2_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SET
#define SERDES_CFG_2_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_22r_GET
#define SERDES_CFG_2_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SPAREf_GET
#define SERDES_CFG_2_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_22r_SPAREf_SET
#define SERDES_CFG_2_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_22r_RX_LOSVREFf_GET
#define SERDES_CFG_2_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_2_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_22r
#define WRITE_SERDES_CFG_2_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_22r
#define MODIFY_SERDES_CFG_2_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_2_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9357
 * DESC:     Serdes Config Index 2 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r (0x00109357 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_2_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_2_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_2_23[1];
	uint32_t _serdes_cfg_2_23;
} BCMI_TSCD_XGXS_SERDES_CFG_2_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_CLR(r) (r).serdes_cfg_2_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_SET(r,d) (r).serdes_cfg_2_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_GET(r) (r).serdes_cfg_2_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_2_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_2_23[0]=(((r).serdes_cfg_2_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_2_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_2_23[0]=(((r).serdes_cfg_2_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_2_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_2_23[0]=(((r).serdes_cfg_2_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_RATESELf_GET(r) ((((r).serdes_cfg_2_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_RATESELf_SET(r,f) (r).serdes_cfg_2_23[0]=(((r).serdes_cfg_2_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_2_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_2_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_2_23[0]=(((r).serdes_cfg_2_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_2_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_2_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_23r,(_r._serdes_cfg_2_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_23r,(_r._serdes_cfg_2_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_2_23r,(_r._serdes_cfg_2_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_2_23r BCMI_TSCD_XGXS_SERDES_CFG_2_23r
#define SERDES_CFG_2_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_2_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_2_23r_t SERDES_CFG_2_23r_t;
#define SERDES_CFG_2_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_2_23r_CLR
#define SERDES_CFG_2_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_SET
#define SERDES_CFG_2_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_GET
#define SERDES_CFG_2_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_2_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_2_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODEf_GET
#define SERDES_CFG_2_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_TRAINING_MODEf_SET
#define SERDES_CFG_2_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_WORDMODEf_GET
#define SERDES_CFG_2_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_WORDMODEf_SET
#define SERDES_CFG_2_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_RATESELf_GET
#define SERDES_CFG_2_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_RATESELf_SET
#define SERDES_CFG_2_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_2_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_2_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_2_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_2_23r
#define WRITE_SERDES_CFG_2_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_2_23r
#define MODIFY_SERDES_CFG_2_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_2_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_2_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9360
 * DESC:     Serdes Config Index 3 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_0r (0x00109360 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_0[1];
	uint32_t _serdes_cfg_3_0;
} BCMI_TSCD_XGXS_SERDES_CFG_3_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_0r_CLR(r) (r).serdes_cfg_3_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SET(r,d) (r).serdes_cfg_3_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_0r_GET(r) (r).serdes_cfg_3_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_0[0]=(((r).serdes_cfg_3_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_0r,(_r._serdes_cfg_3_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_0r,(_r._serdes_cfg_3_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_0r,(_r._serdes_cfg_3_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_0r BCMI_TSCD_XGXS_SERDES_CFG_3_0r
#define SERDES_CFG_3_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_0r_t SERDES_CFG_3_0r_t;
#define SERDES_CFG_3_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_0r_CLR
#define SERDES_CFG_3_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SET
#define SERDES_CFG_3_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_0r_GET
#define SERDES_CFG_3_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SPEED_CFGf_GET
#define SERDES_CFG_3_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_0r
#define WRITE_SERDES_CFG_3_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_0r
#define MODIFY_SERDES_CFG_3_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9361
 * DESC:     Serdes Config Index 3 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_1r (0x00109361 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_1[1];
	uint32_t _serdes_cfg_3_1;
} BCMI_TSCD_XGXS_SERDES_CFG_3_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_1r_CLR(r) (r).serdes_cfg_3_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SET(r,d) (r).serdes_cfg_3_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_1r_GET(r) (r).serdes_cfg_3_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_1[0]=(((r).serdes_cfg_3_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_1r,(_r._serdes_cfg_3_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_1r,(_r._serdes_cfg_3_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_1r,(_r._serdes_cfg_3_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_1r BCMI_TSCD_XGXS_SERDES_CFG_3_1r
#define SERDES_CFG_3_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_1r_t SERDES_CFG_3_1r_t;
#define SERDES_CFG_3_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_1r_CLR
#define SERDES_CFG_3_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SET
#define SERDES_CFG_3_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_1r_GET
#define SERDES_CFG_3_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SPEED_CFGf_GET
#define SERDES_CFG_3_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_1r
#define WRITE_SERDES_CFG_3_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_1r
#define MODIFY_SERDES_CFG_3_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9362
 * DESC:     Serdes Config Index 3 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_2r (0x00109362 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_2[1];
	uint32_t _serdes_cfg_3_2;
} BCMI_TSCD_XGXS_SERDES_CFG_3_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_2r_CLR(r) (r).serdes_cfg_3_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SET(r,d) (r).serdes_cfg_3_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_2r_GET(r) (r).serdes_cfg_3_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_2[0]=(((r).serdes_cfg_3_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_2r,(_r._serdes_cfg_3_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_2r,(_r._serdes_cfg_3_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_2r,(_r._serdes_cfg_3_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_2r BCMI_TSCD_XGXS_SERDES_CFG_3_2r
#define SERDES_CFG_3_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_2r_t SERDES_CFG_3_2r_t;
#define SERDES_CFG_3_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_2r_CLR
#define SERDES_CFG_3_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SET
#define SERDES_CFG_3_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_2r_GET
#define SERDES_CFG_3_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SPEED_CFGf_GET
#define SERDES_CFG_3_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_2r
#define WRITE_SERDES_CFG_3_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_2r
#define MODIFY_SERDES_CFG_3_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9363
 * DESC:     Serdes Config Index 3 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_3r (0x00109363 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_3[1];
	uint32_t _serdes_cfg_3_3;
} BCMI_TSCD_XGXS_SERDES_CFG_3_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_3r_CLR(r) (r).serdes_cfg_3_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SET(r,d) (r).serdes_cfg_3_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_3r_GET(r) (r).serdes_cfg_3_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_3[0]=(((r).serdes_cfg_3_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_3r,(_r._serdes_cfg_3_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_3r,(_r._serdes_cfg_3_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_3r,(_r._serdes_cfg_3_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_3r BCMI_TSCD_XGXS_SERDES_CFG_3_3r
#define SERDES_CFG_3_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_3r_t SERDES_CFG_3_3r_t;
#define SERDES_CFG_3_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_3r_CLR
#define SERDES_CFG_3_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SET
#define SERDES_CFG_3_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_3r_GET
#define SERDES_CFG_3_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SPEED_CFGf_GET
#define SERDES_CFG_3_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_3r
#define WRITE_SERDES_CFG_3_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_3r
#define MODIFY_SERDES_CFG_3_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9364
 * DESC:     Serdes Config Index 3 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_4r (0x00109364 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_4[1];
	uint32_t _serdes_cfg_3_4;
} BCMI_TSCD_XGXS_SERDES_CFG_3_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_4r_CLR(r) (r).serdes_cfg_3_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SET(r,d) (r).serdes_cfg_3_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_4r_GET(r) (r).serdes_cfg_3_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_4[0]=(((r).serdes_cfg_3_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_4r,(_r._serdes_cfg_3_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_4r,(_r._serdes_cfg_3_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_4r,(_r._serdes_cfg_3_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_4r BCMI_TSCD_XGXS_SERDES_CFG_3_4r
#define SERDES_CFG_3_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_4r_t SERDES_CFG_3_4r_t;
#define SERDES_CFG_3_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_4r_CLR
#define SERDES_CFG_3_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SET
#define SERDES_CFG_3_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_4r_GET
#define SERDES_CFG_3_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SPEED_CFGf_GET
#define SERDES_CFG_3_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_4r
#define WRITE_SERDES_CFG_3_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_4r
#define MODIFY_SERDES_CFG_3_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9365
 * DESC:     Serdes Config Index 3 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_5r (0x00109365 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_5[1];
	uint32_t _serdes_cfg_3_5;
} BCMI_TSCD_XGXS_SERDES_CFG_3_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_5r_CLR(r) (r).serdes_cfg_3_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SET(r,d) (r).serdes_cfg_3_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_5r_GET(r) (r).serdes_cfg_3_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_5[0]=(((r).serdes_cfg_3_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_5r,(_r._serdes_cfg_3_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_5r,(_r._serdes_cfg_3_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_5r,(_r._serdes_cfg_3_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_5r BCMI_TSCD_XGXS_SERDES_CFG_3_5r
#define SERDES_CFG_3_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_5r_t SERDES_CFG_3_5r_t;
#define SERDES_CFG_3_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_5r_CLR
#define SERDES_CFG_3_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SET
#define SERDES_CFG_3_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_5r_GET
#define SERDES_CFG_3_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SPEED_CFGf_GET
#define SERDES_CFG_3_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_5r
#define WRITE_SERDES_CFG_3_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_5r
#define MODIFY_SERDES_CFG_3_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9366
 * DESC:     Serdes Config Index 3 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_6r (0x00109366 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_6[1];
	uint32_t _serdes_cfg_3_6;
} BCMI_TSCD_XGXS_SERDES_CFG_3_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_6r_CLR(r) (r).serdes_cfg_3_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SET(r,d) (r).serdes_cfg_3_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_6r_GET(r) (r).serdes_cfg_3_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_6[0]=(((r).serdes_cfg_3_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_6r,(_r._serdes_cfg_3_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_6r,(_r._serdes_cfg_3_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_6r,(_r._serdes_cfg_3_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_6r BCMI_TSCD_XGXS_SERDES_CFG_3_6r
#define SERDES_CFG_3_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_6r_t SERDES_CFG_3_6r_t;
#define SERDES_CFG_3_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_6r_CLR
#define SERDES_CFG_3_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SET
#define SERDES_CFG_3_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_6r_GET
#define SERDES_CFG_3_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SPEED_CFGf_GET
#define SERDES_CFG_3_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_6r
#define WRITE_SERDES_CFG_3_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_6r
#define MODIFY_SERDES_CFG_3_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9367
 * DESC:     Serdes Config Index 3 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_7r (0x00109367 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_7[1];
	uint32_t _serdes_cfg_3_7;
} BCMI_TSCD_XGXS_SERDES_CFG_3_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_7r_CLR(r) (r).serdes_cfg_3_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SET(r,d) (r).serdes_cfg_3_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_7r_GET(r) (r).serdes_cfg_3_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_7[0]=(((r).serdes_cfg_3_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_7r,(_r._serdes_cfg_3_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_7r,(_r._serdes_cfg_3_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_7r,(_r._serdes_cfg_3_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_7r BCMI_TSCD_XGXS_SERDES_CFG_3_7r
#define SERDES_CFG_3_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_7r_t SERDES_CFG_3_7r_t;
#define SERDES_CFG_3_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_7r_CLR
#define SERDES_CFG_3_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SET
#define SERDES_CFG_3_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_7r_GET
#define SERDES_CFG_3_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SPEED_CFGf_GET
#define SERDES_CFG_3_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_7r
#define WRITE_SERDES_CFG_3_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_7r
#define MODIFY_SERDES_CFG_3_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9368
 * DESC:     Serdes Config Index 3 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_8r (0x00109368 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_8[1];
	uint32_t _serdes_cfg_3_8;
} BCMI_TSCD_XGXS_SERDES_CFG_3_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_8r_CLR(r) (r).serdes_cfg_3_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SET(r,d) (r).serdes_cfg_3_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_8r_GET(r) (r).serdes_cfg_3_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_8[0]=(((r).serdes_cfg_3_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_8r,(_r._serdes_cfg_3_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_8r,(_r._serdes_cfg_3_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_8r,(_r._serdes_cfg_3_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_8r BCMI_TSCD_XGXS_SERDES_CFG_3_8r
#define SERDES_CFG_3_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_8r_t SERDES_CFG_3_8r_t;
#define SERDES_CFG_3_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_8r_CLR
#define SERDES_CFG_3_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SET
#define SERDES_CFG_3_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_8r_GET
#define SERDES_CFG_3_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SPEED_CFGf_GET
#define SERDES_CFG_3_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_8r
#define WRITE_SERDES_CFG_3_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_8r
#define MODIFY_SERDES_CFG_3_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9369
 * DESC:     Serdes Config Index 3 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_9r (0x00109369 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_9[1];
	uint32_t _serdes_cfg_3_9;
} BCMI_TSCD_XGXS_SERDES_CFG_3_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_9r_CLR(r) (r).serdes_cfg_3_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SET(r,d) (r).serdes_cfg_3_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_9r_GET(r) (r).serdes_cfg_3_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_9[0]=(((r).serdes_cfg_3_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_9r,(_r._serdes_cfg_3_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_9r,(_r._serdes_cfg_3_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_9r,(_r._serdes_cfg_3_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_9r BCMI_TSCD_XGXS_SERDES_CFG_3_9r
#define SERDES_CFG_3_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_9r_t SERDES_CFG_3_9r_t;
#define SERDES_CFG_3_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_9r_CLR
#define SERDES_CFG_3_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SET
#define SERDES_CFG_3_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_9r_GET
#define SERDES_CFG_3_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SPEED_CFGf_GET
#define SERDES_CFG_3_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_9r
#define WRITE_SERDES_CFG_3_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_9r
#define MODIFY_SERDES_CFG_3_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x936a
 * DESC:     Serdes Config Index 3 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_10r (0x0010936a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_10[1];
	uint32_t _serdes_cfg_3_10;
} BCMI_TSCD_XGXS_SERDES_CFG_3_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_10r_CLR(r) (r).serdes_cfg_3_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SET(r,d) (r).serdes_cfg_3_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_10r_GET(r) (r).serdes_cfg_3_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_10[0]=(((r).serdes_cfg_3_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_10r,(_r._serdes_cfg_3_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_10r,(_r._serdes_cfg_3_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_10r,(_r._serdes_cfg_3_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_10r BCMI_TSCD_XGXS_SERDES_CFG_3_10r
#define SERDES_CFG_3_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_10r_t SERDES_CFG_3_10r_t;
#define SERDES_CFG_3_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_10r_CLR
#define SERDES_CFG_3_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SET
#define SERDES_CFG_3_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_10r_GET
#define SERDES_CFG_3_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SPEED_CFGf_GET
#define SERDES_CFG_3_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_10r
#define WRITE_SERDES_CFG_3_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_10r
#define MODIFY_SERDES_CFG_3_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x936b
 * DESC:     Serdes Config Index 3 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_11r (0x0010936b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_11[1];
	uint32_t _serdes_cfg_3_11;
} BCMI_TSCD_XGXS_SERDES_CFG_3_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_11r_CLR(r) (r).serdes_cfg_3_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SET(r,d) (r).serdes_cfg_3_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_11r_GET(r) (r).serdes_cfg_3_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_11[0]=(((r).serdes_cfg_3_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_11r,(_r._serdes_cfg_3_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_11r,(_r._serdes_cfg_3_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_11r,(_r._serdes_cfg_3_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_11r BCMI_TSCD_XGXS_SERDES_CFG_3_11r
#define SERDES_CFG_3_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_11r_t SERDES_CFG_3_11r_t;
#define SERDES_CFG_3_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_11r_CLR
#define SERDES_CFG_3_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SET
#define SERDES_CFG_3_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_11r_GET
#define SERDES_CFG_3_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SPEED_CFGf_GET
#define SERDES_CFG_3_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_11r
#define WRITE_SERDES_CFG_3_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_11r
#define MODIFY_SERDES_CFG_3_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x936c
 * DESC:     Serdes Config Index 3 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_12r (0x0010936c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_12[1];
	uint32_t _serdes_cfg_3_12;
} BCMI_TSCD_XGXS_SERDES_CFG_3_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_12r_CLR(r) (r).serdes_cfg_3_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SET(r,d) (r).serdes_cfg_3_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_12r_GET(r) (r).serdes_cfg_3_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_12[0]=(((r).serdes_cfg_3_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_12r,(_r._serdes_cfg_3_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_12r,(_r._serdes_cfg_3_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_12r,(_r._serdes_cfg_3_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_12r BCMI_TSCD_XGXS_SERDES_CFG_3_12r
#define SERDES_CFG_3_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_12r_t SERDES_CFG_3_12r_t;
#define SERDES_CFG_3_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_12r_CLR
#define SERDES_CFG_3_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SET
#define SERDES_CFG_3_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_12r_GET
#define SERDES_CFG_3_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SPEED_CFGf_GET
#define SERDES_CFG_3_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_12r
#define WRITE_SERDES_CFG_3_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_12r
#define MODIFY_SERDES_CFG_3_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x936d
 * DESC:     Serdes Config Index 3 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_13r (0x0010936d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_13[1];
	uint32_t _serdes_cfg_3_13;
} BCMI_TSCD_XGXS_SERDES_CFG_3_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_13r_CLR(r) (r).serdes_cfg_3_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SET(r,d) (r).serdes_cfg_3_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_13r_GET(r) (r).serdes_cfg_3_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_13[0]=(((r).serdes_cfg_3_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_13r,(_r._serdes_cfg_3_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_13r,(_r._serdes_cfg_3_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_13r,(_r._serdes_cfg_3_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_13r BCMI_TSCD_XGXS_SERDES_CFG_3_13r
#define SERDES_CFG_3_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_13r_t SERDES_CFG_3_13r_t;
#define SERDES_CFG_3_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_13r_CLR
#define SERDES_CFG_3_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SET
#define SERDES_CFG_3_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_13r_GET
#define SERDES_CFG_3_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SPEED_CFGf_GET
#define SERDES_CFG_3_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_13r
#define WRITE_SERDES_CFG_3_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_13r
#define MODIFY_SERDES_CFG_3_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x936e
 * DESC:     Serdes Config Index 3 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_14r (0x0010936e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_14[1];
	uint32_t _serdes_cfg_3_14;
} BCMI_TSCD_XGXS_SERDES_CFG_3_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_14r_CLR(r) (r).serdes_cfg_3_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SET(r,d) (r).serdes_cfg_3_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_14r_GET(r) (r).serdes_cfg_3_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_14[0]=(((r).serdes_cfg_3_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_14r,(_r._serdes_cfg_3_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_14r,(_r._serdes_cfg_3_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_14r,(_r._serdes_cfg_3_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_14r BCMI_TSCD_XGXS_SERDES_CFG_3_14r
#define SERDES_CFG_3_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_14r_t SERDES_CFG_3_14r_t;
#define SERDES_CFG_3_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_14r_CLR
#define SERDES_CFG_3_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SET
#define SERDES_CFG_3_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_14r_GET
#define SERDES_CFG_3_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SPEED_CFGf_GET
#define SERDES_CFG_3_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_14r
#define WRITE_SERDES_CFG_3_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_14r
#define MODIFY_SERDES_CFG_3_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x936f
 * DESC:     Serdes Config Index 3 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_15r (0x0010936f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_15[1];
	uint32_t _serdes_cfg_3_15;
} BCMI_TSCD_XGXS_SERDES_CFG_3_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_15r_CLR(r) (r).serdes_cfg_3_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SET(r,d) (r).serdes_cfg_3_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_15r_GET(r) (r).serdes_cfg_3_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_15[0]=(((r).serdes_cfg_3_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_15r,(_r._serdes_cfg_3_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_15r,(_r._serdes_cfg_3_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_15r,(_r._serdes_cfg_3_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_15r BCMI_TSCD_XGXS_SERDES_CFG_3_15r
#define SERDES_CFG_3_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_15r_t SERDES_CFG_3_15r_t;
#define SERDES_CFG_3_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_15r_CLR
#define SERDES_CFG_3_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SET
#define SERDES_CFG_3_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_15r_GET
#define SERDES_CFG_3_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SPEED_CFGf_GET
#define SERDES_CFG_3_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_15r
#define WRITE_SERDES_CFG_3_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_15r
#define MODIFY_SERDES_CFG_3_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9370
 * DESC:     Serdes Config Index 3 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_16r (0x00109370 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_16[1];
	uint32_t _serdes_cfg_3_16;
} BCMI_TSCD_XGXS_SERDES_CFG_3_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_16r_CLR(r) (r).serdes_cfg_3_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SET(r,d) (r).serdes_cfg_3_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_16r_GET(r) (r).serdes_cfg_3_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_16[0]=(((r).serdes_cfg_3_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_16r,(_r._serdes_cfg_3_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_16r,(_r._serdes_cfg_3_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_16r,(_r._serdes_cfg_3_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_16r BCMI_TSCD_XGXS_SERDES_CFG_3_16r
#define SERDES_CFG_3_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_16r_t SERDES_CFG_3_16r_t;
#define SERDES_CFG_3_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_16r_CLR
#define SERDES_CFG_3_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SET
#define SERDES_CFG_3_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_16r_GET
#define SERDES_CFG_3_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SPEED_CFGf_GET
#define SERDES_CFG_3_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_16r
#define WRITE_SERDES_CFG_3_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_16r
#define MODIFY_SERDES_CFG_3_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9371
 * DESC:     Serdes Config Index 3 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_17r (0x00109371 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_17[1];
	uint32_t _serdes_cfg_3_17;
} BCMI_TSCD_XGXS_SERDES_CFG_3_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_17r_CLR(r) (r).serdes_cfg_3_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SET(r,d) (r).serdes_cfg_3_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_17r_GET(r) (r).serdes_cfg_3_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_17[0]=(((r).serdes_cfg_3_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_17r,(_r._serdes_cfg_3_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_17r,(_r._serdes_cfg_3_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_17r,(_r._serdes_cfg_3_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_17r BCMI_TSCD_XGXS_SERDES_CFG_3_17r
#define SERDES_CFG_3_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_17r_t SERDES_CFG_3_17r_t;
#define SERDES_CFG_3_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_17r_CLR
#define SERDES_CFG_3_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SET
#define SERDES_CFG_3_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_17r_GET
#define SERDES_CFG_3_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SPEED_CFGf_GET
#define SERDES_CFG_3_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_17r
#define WRITE_SERDES_CFG_3_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_17r
#define MODIFY_SERDES_CFG_3_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9372
 * DESC:     Serdes Config Index 3 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_18r (0x00109372 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_18[1];
	uint32_t _serdes_cfg_3_18;
} BCMI_TSCD_XGXS_SERDES_CFG_3_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_18r_CLR(r) (r).serdes_cfg_3_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SET(r,d) (r).serdes_cfg_3_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_18r_GET(r) (r).serdes_cfg_3_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_18[0]=(((r).serdes_cfg_3_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_18r,(_r._serdes_cfg_3_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_18r,(_r._serdes_cfg_3_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_18r,(_r._serdes_cfg_3_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_18r BCMI_TSCD_XGXS_SERDES_CFG_3_18r
#define SERDES_CFG_3_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_18r_t SERDES_CFG_3_18r_t;
#define SERDES_CFG_3_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_18r_CLR
#define SERDES_CFG_3_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SET
#define SERDES_CFG_3_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_18r_GET
#define SERDES_CFG_3_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SPEED_CFGf_GET
#define SERDES_CFG_3_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_18r
#define WRITE_SERDES_CFG_3_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_18r
#define MODIFY_SERDES_CFG_3_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9373
 * DESC:     Serdes Config Index 3 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_19r (0x00109373 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_19[1];
	uint32_t _serdes_cfg_3_19;
} BCMI_TSCD_XGXS_SERDES_CFG_3_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_19r_CLR(r) (r).serdes_cfg_3_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SET(r,d) (r).serdes_cfg_3_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_19r_GET(r) (r).serdes_cfg_3_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_19[0]=(((r).serdes_cfg_3_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_19r,(_r._serdes_cfg_3_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_19r,(_r._serdes_cfg_3_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_19r,(_r._serdes_cfg_3_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_19r BCMI_TSCD_XGXS_SERDES_CFG_3_19r
#define SERDES_CFG_3_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_19r_t SERDES_CFG_3_19r_t;
#define SERDES_CFG_3_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_19r_CLR
#define SERDES_CFG_3_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SET
#define SERDES_CFG_3_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_19r_GET
#define SERDES_CFG_3_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SPEED_CFGf_GET
#define SERDES_CFG_3_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_19r
#define WRITE_SERDES_CFG_3_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_19r
#define MODIFY_SERDES_CFG_3_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9374
 * DESC:     Serdes Config Index 3 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_20r (0x00109374 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_20[1];
	uint32_t _serdes_cfg_3_20;
} BCMI_TSCD_XGXS_SERDES_CFG_3_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_20r_CLR(r) (r).serdes_cfg_3_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SET(r,d) (r).serdes_cfg_3_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_20r_GET(r) (r).serdes_cfg_3_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_3_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_3_20[0]=(((r).serdes_cfg_3_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_3_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_20r,(_r._serdes_cfg_3_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_20r,(_r._serdes_cfg_3_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_20r,(_r._serdes_cfg_3_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_20r BCMI_TSCD_XGXS_SERDES_CFG_3_20r
#define SERDES_CFG_3_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_20r_t SERDES_CFG_3_20r_t;
#define SERDES_CFG_3_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_20r_CLR
#define SERDES_CFG_3_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SET
#define SERDES_CFG_3_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_20r_GET
#define SERDES_CFG_3_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SPEED_CFGf_GET
#define SERDES_CFG_3_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_3_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_20r
#define WRITE_SERDES_CFG_3_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_20r
#define MODIFY_SERDES_CFG_3_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9375
 * DESC:     Serdes Config Index 3 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_21r (0x00109375 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_21[1];
	uint32_t _serdes_cfg_3_21;
} BCMI_TSCD_XGXS_SERDES_CFG_3_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_21r_CLR(r) (r).serdes_cfg_3_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_21r_SET(r,d) (r).serdes_cfg_3_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_21r_GET(r) (r).serdes_cfg_3_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_3_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_3_21[0]=(((r).serdes_cfg_3_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_3_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_21r,(_r._serdes_cfg_3_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_21r,(_r._serdes_cfg_3_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_21r,(_r._serdes_cfg_3_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_21r BCMI_TSCD_XGXS_SERDES_CFG_3_21r
#define SERDES_CFG_3_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_21r_t SERDES_CFG_3_21r_t;
#define SERDES_CFG_3_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_21r_CLR
#define SERDES_CFG_3_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_21r_SET
#define SERDES_CFG_3_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_21r_GET
#define SERDES_CFG_3_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_21r_FCLK_PERIODf_GET
#define SERDES_CFG_3_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_3_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_21r
#define WRITE_SERDES_CFG_3_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_21r
#define MODIFY_SERDES_CFG_3_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9376
 * DESC:     Serdes Config Index 3 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r (0x00109376 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_22[1];
	uint32_t _serdes_cfg_3_22;
} BCMI_TSCD_XGXS_SERDES_CFG_3_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_CLR(r) (r).serdes_cfg_3_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SET(r,d) (r).serdes_cfg_3_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_GET(r) (r).serdes_cfg_3_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SPAREf_GET(r) ((((r).serdes_cfg_3_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SPAREf_SET(r,f) (r).serdes_cfg_3_22[0]=(((r).serdes_cfg_3_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_3_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_3_22[0]=(((r).serdes_cfg_3_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_3_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_22r,(_r._serdes_cfg_3_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_22r,(_r._serdes_cfg_3_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_22r,(_r._serdes_cfg_3_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_22r BCMI_TSCD_XGXS_SERDES_CFG_3_22r
#define SERDES_CFG_3_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_22r_t SERDES_CFG_3_22r_t;
#define SERDES_CFG_3_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_22r_CLR
#define SERDES_CFG_3_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SET
#define SERDES_CFG_3_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_22r_GET
#define SERDES_CFG_3_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SPAREf_GET
#define SERDES_CFG_3_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_22r_SPAREf_SET
#define SERDES_CFG_3_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_22r_RX_LOSVREFf_GET
#define SERDES_CFG_3_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_3_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_22r
#define WRITE_SERDES_CFG_3_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_22r
#define MODIFY_SERDES_CFG_3_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_3_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9377
 * DESC:     Serdes Config Index 3 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r (0x00109377 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_3_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_3_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_3_23[1];
	uint32_t _serdes_cfg_3_23;
} BCMI_TSCD_XGXS_SERDES_CFG_3_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_CLR(r) (r).serdes_cfg_3_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_SET(r,d) (r).serdes_cfg_3_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_GET(r) (r).serdes_cfg_3_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_3_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_3_23[0]=(((r).serdes_cfg_3_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_3_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_3_23[0]=(((r).serdes_cfg_3_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_3_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_3_23[0]=(((r).serdes_cfg_3_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_RATESELf_GET(r) ((((r).serdes_cfg_3_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_RATESELf_SET(r,f) (r).serdes_cfg_3_23[0]=(((r).serdes_cfg_3_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_3_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_3_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_3_23[0]=(((r).serdes_cfg_3_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_3_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_3_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_23r,(_r._serdes_cfg_3_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_23r,(_r._serdes_cfg_3_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_3_23r,(_r._serdes_cfg_3_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_3_23r BCMI_TSCD_XGXS_SERDES_CFG_3_23r
#define SERDES_CFG_3_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_3_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_3_23r_t SERDES_CFG_3_23r_t;
#define SERDES_CFG_3_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_3_23r_CLR
#define SERDES_CFG_3_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_SET
#define SERDES_CFG_3_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_GET
#define SERDES_CFG_3_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_3_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_3_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODEf_GET
#define SERDES_CFG_3_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_TRAINING_MODEf_SET
#define SERDES_CFG_3_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_WORDMODEf_GET
#define SERDES_CFG_3_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_WORDMODEf_SET
#define SERDES_CFG_3_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_RATESELf_GET
#define SERDES_CFG_3_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_RATESELf_SET
#define SERDES_CFG_3_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_3_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_3_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_3_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_3_23r
#define WRITE_SERDES_CFG_3_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_3_23r
#define MODIFY_SERDES_CFG_3_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_3_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_3_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9380
 * DESC:     Serdes Config Index 4 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_0r (0x00109380 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_0[1];
	uint32_t _serdes_cfg_4_0;
} BCMI_TSCD_XGXS_SERDES_CFG_4_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_0r_CLR(r) (r).serdes_cfg_4_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SET(r,d) (r).serdes_cfg_4_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_0r_GET(r) (r).serdes_cfg_4_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_0[0]=(((r).serdes_cfg_4_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_0r,(_r._serdes_cfg_4_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_0r,(_r._serdes_cfg_4_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_0r,(_r._serdes_cfg_4_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_0r BCMI_TSCD_XGXS_SERDES_CFG_4_0r
#define SERDES_CFG_4_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_0r_t SERDES_CFG_4_0r_t;
#define SERDES_CFG_4_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_0r_CLR
#define SERDES_CFG_4_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SET
#define SERDES_CFG_4_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_0r_GET
#define SERDES_CFG_4_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SPEED_CFGf_GET
#define SERDES_CFG_4_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_0r
#define WRITE_SERDES_CFG_4_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_0r
#define MODIFY_SERDES_CFG_4_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9381
 * DESC:     Serdes Config Index 4 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_1r (0x00109381 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_1[1];
	uint32_t _serdes_cfg_4_1;
} BCMI_TSCD_XGXS_SERDES_CFG_4_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_1r_CLR(r) (r).serdes_cfg_4_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SET(r,d) (r).serdes_cfg_4_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_1r_GET(r) (r).serdes_cfg_4_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_1[0]=(((r).serdes_cfg_4_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_1r,(_r._serdes_cfg_4_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_1r,(_r._serdes_cfg_4_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_1r,(_r._serdes_cfg_4_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_1r BCMI_TSCD_XGXS_SERDES_CFG_4_1r
#define SERDES_CFG_4_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_1r_t SERDES_CFG_4_1r_t;
#define SERDES_CFG_4_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_1r_CLR
#define SERDES_CFG_4_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SET
#define SERDES_CFG_4_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_1r_GET
#define SERDES_CFG_4_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SPEED_CFGf_GET
#define SERDES_CFG_4_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_1r
#define WRITE_SERDES_CFG_4_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_1r
#define MODIFY_SERDES_CFG_4_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9382
 * DESC:     Serdes Config Index 4 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_2r (0x00109382 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_2[1];
	uint32_t _serdes_cfg_4_2;
} BCMI_TSCD_XGXS_SERDES_CFG_4_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_2r_CLR(r) (r).serdes_cfg_4_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SET(r,d) (r).serdes_cfg_4_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_2r_GET(r) (r).serdes_cfg_4_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_2[0]=(((r).serdes_cfg_4_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_2r,(_r._serdes_cfg_4_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_2r,(_r._serdes_cfg_4_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_2r,(_r._serdes_cfg_4_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_2r BCMI_TSCD_XGXS_SERDES_CFG_4_2r
#define SERDES_CFG_4_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_2r_t SERDES_CFG_4_2r_t;
#define SERDES_CFG_4_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_2r_CLR
#define SERDES_CFG_4_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SET
#define SERDES_CFG_4_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_2r_GET
#define SERDES_CFG_4_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SPEED_CFGf_GET
#define SERDES_CFG_4_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_2r
#define WRITE_SERDES_CFG_4_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_2r
#define MODIFY_SERDES_CFG_4_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9383
 * DESC:     Serdes Config Index 4 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_3r (0x00109383 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_3[1];
	uint32_t _serdes_cfg_4_3;
} BCMI_TSCD_XGXS_SERDES_CFG_4_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_3r_CLR(r) (r).serdes_cfg_4_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SET(r,d) (r).serdes_cfg_4_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_3r_GET(r) (r).serdes_cfg_4_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_3[0]=(((r).serdes_cfg_4_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_3r,(_r._serdes_cfg_4_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_3r,(_r._serdes_cfg_4_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_3r,(_r._serdes_cfg_4_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_3r BCMI_TSCD_XGXS_SERDES_CFG_4_3r
#define SERDES_CFG_4_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_3r_t SERDES_CFG_4_3r_t;
#define SERDES_CFG_4_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_3r_CLR
#define SERDES_CFG_4_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SET
#define SERDES_CFG_4_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_3r_GET
#define SERDES_CFG_4_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SPEED_CFGf_GET
#define SERDES_CFG_4_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_3r
#define WRITE_SERDES_CFG_4_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_3r
#define MODIFY_SERDES_CFG_4_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9384
 * DESC:     Serdes Config Index 4 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_4r (0x00109384 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_4[1];
	uint32_t _serdes_cfg_4_4;
} BCMI_TSCD_XGXS_SERDES_CFG_4_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_4r_CLR(r) (r).serdes_cfg_4_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SET(r,d) (r).serdes_cfg_4_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_4r_GET(r) (r).serdes_cfg_4_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_4[0]=(((r).serdes_cfg_4_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_4r,(_r._serdes_cfg_4_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_4r,(_r._serdes_cfg_4_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_4r,(_r._serdes_cfg_4_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_4r BCMI_TSCD_XGXS_SERDES_CFG_4_4r
#define SERDES_CFG_4_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_4r_t SERDES_CFG_4_4r_t;
#define SERDES_CFG_4_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_4r_CLR
#define SERDES_CFG_4_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SET
#define SERDES_CFG_4_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_4r_GET
#define SERDES_CFG_4_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SPEED_CFGf_GET
#define SERDES_CFG_4_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_4r
#define WRITE_SERDES_CFG_4_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_4r
#define MODIFY_SERDES_CFG_4_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9385
 * DESC:     Serdes Config Index 4 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_5r (0x00109385 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_5[1];
	uint32_t _serdes_cfg_4_5;
} BCMI_TSCD_XGXS_SERDES_CFG_4_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_5r_CLR(r) (r).serdes_cfg_4_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SET(r,d) (r).serdes_cfg_4_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_5r_GET(r) (r).serdes_cfg_4_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_5[0]=(((r).serdes_cfg_4_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_5r,(_r._serdes_cfg_4_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_5r,(_r._serdes_cfg_4_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_5r,(_r._serdes_cfg_4_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_5r BCMI_TSCD_XGXS_SERDES_CFG_4_5r
#define SERDES_CFG_4_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_5r_t SERDES_CFG_4_5r_t;
#define SERDES_CFG_4_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_5r_CLR
#define SERDES_CFG_4_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SET
#define SERDES_CFG_4_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_5r_GET
#define SERDES_CFG_4_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SPEED_CFGf_GET
#define SERDES_CFG_4_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_5r
#define WRITE_SERDES_CFG_4_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_5r
#define MODIFY_SERDES_CFG_4_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9386
 * DESC:     Serdes Config Index 4 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_6r (0x00109386 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_6[1];
	uint32_t _serdes_cfg_4_6;
} BCMI_TSCD_XGXS_SERDES_CFG_4_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_6r_CLR(r) (r).serdes_cfg_4_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SET(r,d) (r).serdes_cfg_4_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_6r_GET(r) (r).serdes_cfg_4_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_6[0]=(((r).serdes_cfg_4_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_6r,(_r._serdes_cfg_4_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_6r,(_r._serdes_cfg_4_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_6r,(_r._serdes_cfg_4_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_6r BCMI_TSCD_XGXS_SERDES_CFG_4_6r
#define SERDES_CFG_4_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_6r_t SERDES_CFG_4_6r_t;
#define SERDES_CFG_4_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_6r_CLR
#define SERDES_CFG_4_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SET
#define SERDES_CFG_4_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_6r_GET
#define SERDES_CFG_4_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SPEED_CFGf_GET
#define SERDES_CFG_4_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_6r
#define WRITE_SERDES_CFG_4_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_6r
#define MODIFY_SERDES_CFG_4_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9387
 * DESC:     Serdes Config Index 4 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_7r (0x00109387 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_7[1];
	uint32_t _serdes_cfg_4_7;
} BCMI_TSCD_XGXS_SERDES_CFG_4_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_7r_CLR(r) (r).serdes_cfg_4_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SET(r,d) (r).serdes_cfg_4_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_7r_GET(r) (r).serdes_cfg_4_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_7[0]=(((r).serdes_cfg_4_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_7r,(_r._serdes_cfg_4_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_7r,(_r._serdes_cfg_4_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_7r,(_r._serdes_cfg_4_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_7r BCMI_TSCD_XGXS_SERDES_CFG_4_7r
#define SERDES_CFG_4_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_7r_t SERDES_CFG_4_7r_t;
#define SERDES_CFG_4_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_7r_CLR
#define SERDES_CFG_4_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SET
#define SERDES_CFG_4_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_7r_GET
#define SERDES_CFG_4_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SPEED_CFGf_GET
#define SERDES_CFG_4_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_7r
#define WRITE_SERDES_CFG_4_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_7r
#define MODIFY_SERDES_CFG_4_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9388
 * DESC:     Serdes Config Index 4 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_8r (0x00109388 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_8[1];
	uint32_t _serdes_cfg_4_8;
} BCMI_TSCD_XGXS_SERDES_CFG_4_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_8r_CLR(r) (r).serdes_cfg_4_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SET(r,d) (r).serdes_cfg_4_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_8r_GET(r) (r).serdes_cfg_4_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_8[0]=(((r).serdes_cfg_4_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_8r,(_r._serdes_cfg_4_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_8r,(_r._serdes_cfg_4_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_8r,(_r._serdes_cfg_4_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_8r BCMI_TSCD_XGXS_SERDES_CFG_4_8r
#define SERDES_CFG_4_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_8r_t SERDES_CFG_4_8r_t;
#define SERDES_CFG_4_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_8r_CLR
#define SERDES_CFG_4_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SET
#define SERDES_CFG_4_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_8r_GET
#define SERDES_CFG_4_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SPEED_CFGf_GET
#define SERDES_CFG_4_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_8r
#define WRITE_SERDES_CFG_4_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_8r
#define MODIFY_SERDES_CFG_4_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9389
 * DESC:     Serdes Config Index 4 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_9r (0x00109389 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_9[1];
	uint32_t _serdes_cfg_4_9;
} BCMI_TSCD_XGXS_SERDES_CFG_4_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_9r_CLR(r) (r).serdes_cfg_4_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SET(r,d) (r).serdes_cfg_4_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_9r_GET(r) (r).serdes_cfg_4_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_9[0]=(((r).serdes_cfg_4_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_9r,(_r._serdes_cfg_4_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_9r,(_r._serdes_cfg_4_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_9r,(_r._serdes_cfg_4_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_9r BCMI_TSCD_XGXS_SERDES_CFG_4_9r
#define SERDES_CFG_4_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_9r_t SERDES_CFG_4_9r_t;
#define SERDES_CFG_4_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_9r_CLR
#define SERDES_CFG_4_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SET
#define SERDES_CFG_4_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_9r_GET
#define SERDES_CFG_4_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SPEED_CFGf_GET
#define SERDES_CFG_4_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_9r
#define WRITE_SERDES_CFG_4_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_9r
#define MODIFY_SERDES_CFG_4_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x938a
 * DESC:     Serdes Config Index 4 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_10r (0x0010938a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_10[1];
	uint32_t _serdes_cfg_4_10;
} BCMI_TSCD_XGXS_SERDES_CFG_4_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_10r_CLR(r) (r).serdes_cfg_4_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SET(r,d) (r).serdes_cfg_4_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_10r_GET(r) (r).serdes_cfg_4_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_10[0]=(((r).serdes_cfg_4_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_10r,(_r._serdes_cfg_4_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_10r,(_r._serdes_cfg_4_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_10r,(_r._serdes_cfg_4_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_10r BCMI_TSCD_XGXS_SERDES_CFG_4_10r
#define SERDES_CFG_4_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_10r_t SERDES_CFG_4_10r_t;
#define SERDES_CFG_4_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_10r_CLR
#define SERDES_CFG_4_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SET
#define SERDES_CFG_4_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_10r_GET
#define SERDES_CFG_4_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SPEED_CFGf_GET
#define SERDES_CFG_4_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_10r
#define WRITE_SERDES_CFG_4_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_10r
#define MODIFY_SERDES_CFG_4_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x938b
 * DESC:     Serdes Config Index 4 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_11r (0x0010938b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_11[1];
	uint32_t _serdes_cfg_4_11;
} BCMI_TSCD_XGXS_SERDES_CFG_4_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_11r_CLR(r) (r).serdes_cfg_4_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SET(r,d) (r).serdes_cfg_4_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_11r_GET(r) (r).serdes_cfg_4_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_11[0]=(((r).serdes_cfg_4_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_11r,(_r._serdes_cfg_4_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_11r,(_r._serdes_cfg_4_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_11r,(_r._serdes_cfg_4_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_11r BCMI_TSCD_XGXS_SERDES_CFG_4_11r
#define SERDES_CFG_4_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_11r_t SERDES_CFG_4_11r_t;
#define SERDES_CFG_4_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_11r_CLR
#define SERDES_CFG_4_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SET
#define SERDES_CFG_4_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_11r_GET
#define SERDES_CFG_4_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SPEED_CFGf_GET
#define SERDES_CFG_4_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_11r
#define WRITE_SERDES_CFG_4_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_11r
#define MODIFY_SERDES_CFG_4_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x938c
 * DESC:     Serdes Config Index 4 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_12r (0x0010938c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_12[1];
	uint32_t _serdes_cfg_4_12;
} BCMI_TSCD_XGXS_SERDES_CFG_4_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_12r_CLR(r) (r).serdes_cfg_4_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SET(r,d) (r).serdes_cfg_4_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_12r_GET(r) (r).serdes_cfg_4_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_12[0]=(((r).serdes_cfg_4_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_12r,(_r._serdes_cfg_4_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_12r,(_r._serdes_cfg_4_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_12r,(_r._serdes_cfg_4_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_12r BCMI_TSCD_XGXS_SERDES_CFG_4_12r
#define SERDES_CFG_4_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_12r_t SERDES_CFG_4_12r_t;
#define SERDES_CFG_4_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_12r_CLR
#define SERDES_CFG_4_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SET
#define SERDES_CFG_4_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_12r_GET
#define SERDES_CFG_4_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SPEED_CFGf_GET
#define SERDES_CFG_4_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_12r
#define WRITE_SERDES_CFG_4_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_12r
#define MODIFY_SERDES_CFG_4_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x938d
 * DESC:     Serdes Config Index 4 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_13r (0x0010938d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_13[1];
	uint32_t _serdes_cfg_4_13;
} BCMI_TSCD_XGXS_SERDES_CFG_4_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_13r_CLR(r) (r).serdes_cfg_4_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SET(r,d) (r).serdes_cfg_4_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_13r_GET(r) (r).serdes_cfg_4_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_13[0]=(((r).serdes_cfg_4_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_13r,(_r._serdes_cfg_4_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_13r,(_r._serdes_cfg_4_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_13r,(_r._serdes_cfg_4_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_13r BCMI_TSCD_XGXS_SERDES_CFG_4_13r
#define SERDES_CFG_4_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_13r_t SERDES_CFG_4_13r_t;
#define SERDES_CFG_4_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_13r_CLR
#define SERDES_CFG_4_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SET
#define SERDES_CFG_4_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_13r_GET
#define SERDES_CFG_4_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SPEED_CFGf_GET
#define SERDES_CFG_4_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_13r
#define WRITE_SERDES_CFG_4_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_13r
#define MODIFY_SERDES_CFG_4_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x938e
 * DESC:     Serdes Config Index 4 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_14r (0x0010938e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_14[1];
	uint32_t _serdes_cfg_4_14;
} BCMI_TSCD_XGXS_SERDES_CFG_4_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_14r_CLR(r) (r).serdes_cfg_4_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SET(r,d) (r).serdes_cfg_4_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_14r_GET(r) (r).serdes_cfg_4_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_14[0]=(((r).serdes_cfg_4_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_14r,(_r._serdes_cfg_4_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_14r,(_r._serdes_cfg_4_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_14r,(_r._serdes_cfg_4_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_14r BCMI_TSCD_XGXS_SERDES_CFG_4_14r
#define SERDES_CFG_4_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_14r_t SERDES_CFG_4_14r_t;
#define SERDES_CFG_4_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_14r_CLR
#define SERDES_CFG_4_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SET
#define SERDES_CFG_4_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_14r_GET
#define SERDES_CFG_4_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SPEED_CFGf_GET
#define SERDES_CFG_4_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_14r
#define WRITE_SERDES_CFG_4_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_14r
#define MODIFY_SERDES_CFG_4_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x938f
 * DESC:     Serdes Config Index 4 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_15r (0x0010938f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_15[1];
	uint32_t _serdes_cfg_4_15;
} BCMI_TSCD_XGXS_SERDES_CFG_4_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_15r_CLR(r) (r).serdes_cfg_4_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SET(r,d) (r).serdes_cfg_4_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_15r_GET(r) (r).serdes_cfg_4_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_15[0]=(((r).serdes_cfg_4_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_15r,(_r._serdes_cfg_4_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_15r,(_r._serdes_cfg_4_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_15r,(_r._serdes_cfg_4_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_15r BCMI_TSCD_XGXS_SERDES_CFG_4_15r
#define SERDES_CFG_4_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_15r_t SERDES_CFG_4_15r_t;
#define SERDES_CFG_4_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_15r_CLR
#define SERDES_CFG_4_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SET
#define SERDES_CFG_4_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_15r_GET
#define SERDES_CFG_4_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SPEED_CFGf_GET
#define SERDES_CFG_4_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_15r
#define WRITE_SERDES_CFG_4_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_15r
#define MODIFY_SERDES_CFG_4_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9390
 * DESC:     Serdes Config Index 4 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_16r (0x00109390 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_16[1];
	uint32_t _serdes_cfg_4_16;
} BCMI_TSCD_XGXS_SERDES_CFG_4_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_16r_CLR(r) (r).serdes_cfg_4_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SET(r,d) (r).serdes_cfg_4_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_16r_GET(r) (r).serdes_cfg_4_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_16[0]=(((r).serdes_cfg_4_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_16r,(_r._serdes_cfg_4_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_16r,(_r._serdes_cfg_4_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_16r,(_r._serdes_cfg_4_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_16r BCMI_TSCD_XGXS_SERDES_CFG_4_16r
#define SERDES_CFG_4_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_16r_t SERDES_CFG_4_16r_t;
#define SERDES_CFG_4_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_16r_CLR
#define SERDES_CFG_4_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SET
#define SERDES_CFG_4_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_16r_GET
#define SERDES_CFG_4_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SPEED_CFGf_GET
#define SERDES_CFG_4_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_16r
#define WRITE_SERDES_CFG_4_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_16r
#define MODIFY_SERDES_CFG_4_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9391
 * DESC:     Serdes Config Index 4 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_17r (0x00109391 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_17[1];
	uint32_t _serdes_cfg_4_17;
} BCMI_TSCD_XGXS_SERDES_CFG_4_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_17r_CLR(r) (r).serdes_cfg_4_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SET(r,d) (r).serdes_cfg_4_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_17r_GET(r) (r).serdes_cfg_4_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_17[0]=(((r).serdes_cfg_4_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_17r,(_r._serdes_cfg_4_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_17r,(_r._serdes_cfg_4_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_17r,(_r._serdes_cfg_4_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_17r BCMI_TSCD_XGXS_SERDES_CFG_4_17r
#define SERDES_CFG_4_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_17r_t SERDES_CFG_4_17r_t;
#define SERDES_CFG_4_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_17r_CLR
#define SERDES_CFG_4_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SET
#define SERDES_CFG_4_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_17r_GET
#define SERDES_CFG_4_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SPEED_CFGf_GET
#define SERDES_CFG_4_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_17r
#define WRITE_SERDES_CFG_4_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_17r
#define MODIFY_SERDES_CFG_4_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9392
 * DESC:     Serdes Config Index 4 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_18r (0x00109392 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_18[1];
	uint32_t _serdes_cfg_4_18;
} BCMI_TSCD_XGXS_SERDES_CFG_4_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_18r_CLR(r) (r).serdes_cfg_4_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SET(r,d) (r).serdes_cfg_4_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_18r_GET(r) (r).serdes_cfg_4_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_18[0]=(((r).serdes_cfg_4_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_18r,(_r._serdes_cfg_4_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_18r,(_r._serdes_cfg_4_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_18r,(_r._serdes_cfg_4_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_18r BCMI_TSCD_XGXS_SERDES_CFG_4_18r
#define SERDES_CFG_4_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_18r_t SERDES_CFG_4_18r_t;
#define SERDES_CFG_4_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_18r_CLR
#define SERDES_CFG_4_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SET
#define SERDES_CFG_4_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_18r_GET
#define SERDES_CFG_4_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SPEED_CFGf_GET
#define SERDES_CFG_4_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_18r
#define WRITE_SERDES_CFG_4_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_18r
#define MODIFY_SERDES_CFG_4_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9393
 * DESC:     Serdes Config Index 4 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_19r (0x00109393 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_19[1];
	uint32_t _serdes_cfg_4_19;
} BCMI_TSCD_XGXS_SERDES_CFG_4_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_19r_CLR(r) (r).serdes_cfg_4_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SET(r,d) (r).serdes_cfg_4_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_19r_GET(r) (r).serdes_cfg_4_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_19[0]=(((r).serdes_cfg_4_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_19r,(_r._serdes_cfg_4_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_19r,(_r._serdes_cfg_4_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_19r,(_r._serdes_cfg_4_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_19r BCMI_TSCD_XGXS_SERDES_CFG_4_19r
#define SERDES_CFG_4_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_19r_t SERDES_CFG_4_19r_t;
#define SERDES_CFG_4_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_19r_CLR
#define SERDES_CFG_4_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SET
#define SERDES_CFG_4_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_19r_GET
#define SERDES_CFG_4_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SPEED_CFGf_GET
#define SERDES_CFG_4_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_19r
#define WRITE_SERDES_CFG_4_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_19r
#define MODIFY_SERDES_CFG_4_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9394
 * DESC:     Serdes Config Index 4 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_20r (0x00109394 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_20[1];
	uint32_t _serdes_cfg_4_20;
} BCMI_TSCD_XGXS_SERDES_CFG_4_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_20r_CLR(r) (r).serdes_cfg_4_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SET(r,d) (r).serdes_cfg_4_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_20r_GET(r) (r).serdes_cfg_4_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_4_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_4_20[0]=(((r).serdes_cfg_4_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_4_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_20r,(_r._serdes_cfg_4_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_20r,(_r._serdes_cfg_4_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_20r,(_r._serdes_cfg_4_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_20r BCMI_TSCD_XGXS_SERDES_CFG_4_20r
#define SERDES_CFG_4_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_20r_t SERDES_CFG_4_20r_t;
#define SERDES_CFG_4_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_20r_CLR
#define SERDES_CFG_4_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SET
#define SERDES_CFG_4_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_20r_GET
#define SERDES_CFG_4_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SPEED_CFGf_GET
#define SERDES_CFG_4_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_4_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_20r
#define WRITE_SERDES_CFG_4_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_20r
#define MODIFY_SERDES_CFG_4_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9395
 * DESC:     Serdes Config Index 4 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_21r (0x00109395 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_21[1];
	uint32_t _serdes_cfg_4_21;
} BCMI_TSCD_XGXS_SERDES_CFG_4_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_21r_CLR(r) (r).serdes_cfg_4_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_21r_SET(r,d) (r).serdes_cfg_4_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_21r_GET(r) (r).serdes_cfg_4_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_4_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_4_21[0]=(((r).serdes_cfg_4_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_4_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_21r,(_r._serdes_cfg_4_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_21r,(_r._serdes_cfg_4_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_21r,(_r._serdes_cfg_4_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_21r BCMI_TSCD_XGXS_SERDES_CFG_4_21r
#define SERDES_CFG_4_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_21r_t SERDES_CFG_4_21r_t;
#define SERDES_CFG_4_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_21r_CLR
#define SERDES_CFG_4_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_21r_SET
#define SERDES_CFG_4_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_21r_GET
#define SERDES_CFG_4_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_21r_FCLK_PERIODf_GET
#define SERDES_CFG_4_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_4_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_21r
#define WRITE_SERDES_CFG_4_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_21r
#define MODIFY_SERDES_CFG_4_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9396
 * DESC:     Serdes Config Index 4 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r (0x00109396 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_22[1];
	uint32_t _serdes_cfg_4_22;
} BCMI_TSCD_XGXS_SERDES_CFG_4_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_CLR(r) (r).serdes_cfg_4_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SET(r,d) (r).serdes_cfg_4_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_GET(r) (r).serdes_cfg_4_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SPAREf_GET(r) ((((r).serdes_cfg_4_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SPAREf_SET(r,f) (r).serdes_cfg_4_22[0]=(((r).serdes_cfg_4_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_4_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_4_22[0]=(((r).serdes_cfg_4_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_4_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_22r,(_r._serdes_cfg_4_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_22r,(_r._serdes_cfg_4_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_22r,(_r._serdes_cfg_4_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_22r BCMI_TSCD_XGXS_SERDES_CFG_4_22r
#define SERDES_CFG_4_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_22r_t SERDES_CFG_4_22r_t;
#define SERDES_CFG_4_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_22r_CLR
#define SERDES_CFG_4_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SET
#define SERDES_CFG_4_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_22r_GET
#define SERDES_CFG_4_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SPAREf_GET
#define SERDES_CFG_4_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_22r_SPAREf_SET
#define SERDES_CFG_4_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_22r_RX_LOSVREFf_GET
#define SERDES_CFG_4_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_4_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_22r
#define WRITE_SERDES_CFG_4_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_22r
#define MODIFY_SERDES_CFG_4_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_4_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9397
 * DESC:     Serdes Config Index 4 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r (0x00109397 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_4_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_4_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_4_23[1];
	uint32_t _serdes_cfg_4_23;
} BCMI_TSCD_XGXS_SERDES_CFG_4_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_CLR(r) (r).serdes_cfg_4_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_SET(r,d) (r).serdes_cfg_4_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_GET(r) (r).serdes_cfg_4_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_4_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_4_23[0]=(((r).serdes_cfg_4_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_4_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_4_23[0]=(((r).serdes_cfg_4_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_4_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_4_23[0]=(((r).serdes_cfg_4_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_RATESELf_GET(r) ((((r).serdes_cfg_4_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_RATESELf_SET(r,f) (r).serdes_cfg_4_23[0]=(((r).serdes_cfg_4_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_4_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_4_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_4_23[0]=(((r).serdes_cfg_4_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_4_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_4_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_23r,(_r._serdes_cfg_4_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_23r,(_r._serdes_cfg_4_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_4_23r,(_r._serdes_cfg_4_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_4_23r BCMI_TSCD_XGXS_SERDES_CFG_4_23r
#define SERDES_CFG_4_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_4_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_4_23r_t SERDES_CFG_4_23r_t;
#define SERDES_CFG_4_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_4_23r_CLR
#define SERDES_CFG_4_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_SET
#define SERDES_CFG_4_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_GET
#define SERDES_CFG_4_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_4_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_4_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODEf_GET
#define SERDES_CFG_4_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_TRAINING_MODEf_SET
#define SERDES_CFG_4_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_WORDMODEf_GET
#define SERDES_CFG_4_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_WORDMODEf_SET
#define SERDES_CFG_4_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_RATESELf_GET
#define SERDES_CFG_4_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_RATESELf_SET
#define SERDES_CFG_4_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_4_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_4_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_4_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_4_23r
#define WRITE_SERDES_CFG_4_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_4_23r
#define MODIFY_SERDES_CFG_4_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_4_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_4_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a0
 * DESC:     Serdes Config Index 5 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_0r (0x001093a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_0[1];
	uint32_t _serdes_cfg_5_0;
} BCMI_TSCD_XGXS_SERDES_CFG_5_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_0r_CLR(r) (r).serdes_cfg_5_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SET(r,d) (r).serdes_cfg_5_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_0r_GET(r) (r).serdes_cfg_5_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_0[0]=(((r).serdes_cfg_5_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_0r,(_r._serdes_cfg_5_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_0r,(_r._serdes_cfg_5_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_0r,(_r._serdes_cfg_5_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_0r BCMI_TSCD_XGXS_SERDES_CFG_5_0r
#define SERDES_CFG_5_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_0r_t SERDES_CFG_5_0r_t;
#define SERDES_CFG_5_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_0r_CLR
#define SERDES_CFG_5_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SET
#define SERDES_CFG_5_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_0r_GET
#define SERDES_CFG_5_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SPEED_CFGf_GET
#define SERDES_CFG_5_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_0r
#define WRITE_SERDES_CFG_5_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_0r
#define MODIFY_SERDES_CFG_5_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a1
 * DESC:     Serdes Config Index 5 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_1r (0x001093a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_1[1];
	uint32_t _serdes_cfg_5_1;
} BCMI_TSCD_XGXS_SERDES_CFG_5_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_1r_CLR(r) (r).serdes_cfg_5_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SET(r,d) (r).serdes_cfg_5_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_1r_GET(r) (r).serdes_cfg_5_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_1[0]=(((r).serdes_cfg_5_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_1r,(_r._serdes_cfg_5_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_1r,(_r._serdes_cfg_5_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_1r,(_r._serdes_cfg_5_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_1r BCMI_TSCD_XGXS_SERDES_CFG_5_1r
#define SERDES_CFG_5_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_1r_t SERDES_CFG_5_1r_t;
#define SERDES_CFG_5_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_1r_CLR
#define SERDES_CFG_5_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SET
#define SERDES_CFG_5_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_1r_GET
#define SERDES_CFG_5_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SPEED_CFGf_GET
#define SERDES_CFG_5_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_1r
#define WRITE_SERDES_CFG_5_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_1r
#define MODIFY_SERDES_CFG_5_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a2
 * DESC:     Serdes Config Index 5 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_2r (0x001093a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_2[1];
	uint32_t _serdes_cfg_5_2;
} BCMI_TSCD_XGXS_SERDES_CFG_5_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_2r_CLR(r) (r).serdes_cfg_5_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SET(r,d) (r).serdes_cfg_5_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_2r_GET(r) (r).serdes_cfg_5_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_2[0]=(((r).serdes_cfg_5_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_2r,(_r._serdes_cfg_5_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_2r,(_r._serdes_cfg_5_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_2r,(_r._serdes_cfg_5_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_2r BCMI_TSCD_XGXS_SERDES_CFG_5_2r
#define SERDES_CFG_5_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_2r_t SERDES_CFG_5_2r_t;
#define SERDES_CFG_5_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_2r_CLR
#define SERDES_CFG_5_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SET
#define SERDES_CFG_5_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_2r_GET
#define SERDES_CFG_5_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SPEED_CFGf_GET
#define SERDES_CFG_5_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_2r
#define WRITE_SERDES_CFG_5_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_2r
#define MODIFY_SERDES_CFG_5_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a3
 * DESC:     Serdes Config Index 5 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_3r (0x001093a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_3[1];
	uint32_t _serdes_cfg_5_3;
} BCMI_TSCD_XGXS_SERDES_CFG_5_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_3r_CLR(r) (r).serdes_cfg_5_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SET(r,d) (r).serdes_cfg_5_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_3r_GET(r) (r).serdes_cfg_5_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_3[0]=(((r).serdes_cfg_5_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_3r,(_r._serdes_cfg_5_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_3r,(_r._serdes_cfg_5_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_3r,(_r._serdes_cfg_5_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_3r BCMI_TSCD_XGXS_SERDES_CFG_5_3r
#define SERDES_CFG_5_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_3r_t SERDES_CFG_5_3r_t;
#define SERDES_CFG_5_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_3r_CLR
#define SERDES_CFG_5_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SET
#define SERDES_CFG_5_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_3r_GET
#define SERDES_CFG_5_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SPEED_CFGf_GET
#define SERDES_CFG_5_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_3r
#define WRITE_SERDES_CFG_5_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_3r
#define MODIFY_SERDES_CFG_5_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a4
 * DESC:     Serdes Config Index 5 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_4r (0x001093a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_4[1];
	uint32_t _serdes_cfg_5_4;
} BCMI_TSCD_XGXS_SERDES_CFG_5_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_4r_CLR(r) (r).serdes_cfg_5_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SET(r,d) (r).serdes_cfg_5_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_4r_GET(r) (r).serdes_cfg_5_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_4[0]=(((r).serdes_cfg_5_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_4r,(_r._serdes_cfg_5_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_4r,(_r._serdes_cfg_5_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_4r,(_r._serdes_cfg_5_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_4r BCMI_TSCD_XGXS_SERDES_CFG_5_4r
#define SERDES_CFG_5_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_4r_t SERDES_CFG_5_4r_t;
#define SERDES_CFG_5_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_4r_CLR
#define SERDES_CFG_5_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SET
#define SERDES_CFG_5_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_4r_GET
#define SERDES_CFG_5_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SPEED_CFGf_GET
#define SERDES_CFG_5_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_4r
#define WRITE_SERDES_CFG_5_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_4r
#define MODIFY_SERDES_CFG_5_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a5
 * DESC:     Serdes Config Index 5 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_5r (0x001093a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_5[1];
	uint32_t _serdes_cfg_5_5;
} BCMI_TSCD_XGXS_SERDES_CFG_5_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_5r_CLR(r) (r).serdes_cfg_5_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SET(r,d) (r).serdes_cfg_5_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_5r_GET(r) (r).serdes_cfg_5_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_5[0]=(((r).serdes_cfg_5_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_5r,(_r._serdes_cfg_5_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_5r,(_r._serdes_cfg_5_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_5r,(_r._serdes_cfg_5_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_5r BCMI_TSCD_XGXS_SERDES_CFG_5_5r
#define SERDES_CFG_5_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_5r_t SERDES_CFG_5_5r_t;
#define SERDES_CFG_5_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_5r_CLR
#define SERDES_CFG_5_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SET
#define SERDES_CFG_5_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_5r_GET
#define SERDES_CFG_5_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SPEED_CFGf_GET
#define SERDES_CFG_5_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_5r
#define WRITE_SERDES_CFG_5_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_5r
#define MODIFY_SERDES_CFG_5_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a6
 * DESC:     Serdes Config Index 5 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_6r (0x001093a6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_6[1];
	uint32_t _serdes_cfg_5_6;
} BCMI_TSCD_XGXS_SERDES_CFG_5_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_6r_CLR(r) (r).serdes_cfg_5_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SET(r,d) (r).serdes_cfg_5_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_6r_GET(r) (r).serdes_cfg_5_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_6[0]=(((r).serdes_cfg_5_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_6r,(_r._serdes_cfg_5_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_6r,(_r._serdes_cfg_5_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_6r,(_r._serdes_cfg_5_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_6r BCMI_TSCD_XGXS_SERDES_CFG_5_6r
#define SERDES_CFG_5_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_6r_t SERDES_CFG_5_6r_t;
#define SERDES_CFG_5_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_6r_CLR
#define SERDES_CFG_5_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SET
#define SERDES_CFG_5_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_6r_GET
#define SERDES_CFG_5_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SPEED_CFGf_GET
#define SERDES_CFG_5_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_6r
#define WRITE_SERDES_CFG_5_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_6r
#define MODIFY_SERDES_CFG_5_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a7
 * DESC:     Serdes Config Index 5 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_7r (0x001093a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_7[1];
	uint32_t _serdes_cfg_5_7;
} BCMI_TSCD_XGXS_SERDES_CFG_5_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_7r_CLR(r) (r).serdes_cfg_5_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SET(r,d) (r).serdes_cfg_5_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_7r_GET(r) (r).serdes_cfg_5_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_7[0]=(((r).serdes_cfg_5_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_7r,(_r._serdes_cfg_5_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_7r,(_r._serdes_cfg_5_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_7r,(_r._serdes_cfg_5_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_7r BCMI_TSCD_XGXS_SERDES_CFG_5_7r
#define SERDES_CFG_5_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_7r_t SERDES_CFG_5_7r_t;
#define SERDES_CFG_5_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_7r_CLR
#define SERDES_CFG_5_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SET
#define SERDES_CFG_5_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_7r_GET
#define SERDES_CFG_5_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SPEED_CFGf_GET
#define SERDES_CFG_5_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_7r
#define WRITE_SERDES_CFG_5_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_7r
#define MODIFY_SERDES_CFG_5_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a8
 * DESC:     Serdes Config Index 5 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_8r (0x001093a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_8[1];
	uint32_t _serdes_cfg_5_8;
} BCMI_TSCD_XGXS_SERDES_CFG_5_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_8r_CLR(r) (r).serdes_cfg_5_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SET(r,d) (r).serdes_cfg_5_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_8r_GET(r) (r).serdes_cfg_5_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_8[0]=(((r).serdes_cfg_5_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_8r,(_r._serdes_cfg_5_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_8r,(_r._serdes_cfg_5_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_8r,(_r._serdes_cfg_5_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_8r BCMI_TSCD_XGXS_SERDES_CFG_5_8r
#define SERDES_CFG_5_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_8r_t SERDES_CFG_5_8r_t;
#define SERDES_CFG_5_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_8r_CLR
#define SERDES_CFG_5_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SET
#define SERDES_CFG_5_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_8r_GET
#define SERDES_CFG_5_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SPEED_CFGf_GET
#define SERDES_CFG_5_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_8r
#define WRITE_SERDES_CFG_5_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_8r
#define MODIFY_SERDES_CFG_5_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93a9
 * DESC:     Serdes Config Index 5 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_9r (0x001093a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_9[1];
	uint32_t _serdes_cfg_5_9;
} BCMI_TSCD_XGXS_SERDES_CFG_5_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_9r_CLR(r) (r).serdes_cfg_5_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SET(r,d) (r).serdes_cfg_5_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_9r_GET(r) (r).serdes_cfg_5_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_9[0]=(((r).serdes_cfg_5_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_9r,(_r._serdes_cfg_5_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_9r,(_r._serdes_cfg_5_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_9r,(_r._serdes_cfg_5_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_9r BCMI_TSCD_XGXS_SERDES_CFG_5_9r
#define SERDES_CFG_5_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_9r_t SERDES_CFG_5_9r_t;
#define SERDES_CFG_5_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_9r_CLR
#define SERDES_CFG_5_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SET
#define SERDES_CFG_5_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_9r_GET
#define SERDES_CFG_5_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SPEED_CFGf_GET
#define SERDES_CFG_5_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_9r
#define WRITE_SERDES_CFG_5_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_9r
#define MODIFY_SERDES_CFG_5_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93aa
 * DESC:     Serdes Config Index 5 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_10r (0x001093aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_10[1];
	uint32_t _serdes_cfg_5_10;
} BCMI_TSCD_XGXS_SERDES_CFG_5_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_10r_CLR(r) (r).serdes_cfg_5_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SET(r,d) (r).serdes_cfg_5_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_10r_GET(r) (r).serdes_cfg_5_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_10[0]=(((r).serdes_cfg_5_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_10r,(_r._serdes_cfg_5_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_10r,(_r._serdes_cfg_5_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_10r,(_r._serdes_cfg_5_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_10r BCMI_TSCD_XGXS_SERDES_CFG_5_10r
#define SERDES_CFG_5_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_10r_t SERDES_CFG_5_10r_t;
#define SERDES_CFG_5_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_10r_CLR
#define SERDES_CFG_5_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SET
#define SERDES_CFG_5_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_10r_GET
#define SERDES_CFG_5_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SPEED_CFGf_GET
#define SERDES_CFG_5_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_10r
#define WRITE_SERDES_CFG_5_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_10r
#define MODIFY_SERDES_CFG_5_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ab
 * DESC:     Serdes Config Index 5 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_11r (0x001093ab | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_11[1];
	uint32_t _serdes_cfg_5_11;
} BCMI_TSCD_XGXS_SERDES_CFG_5_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_11r_CLR(r) (r).serdes_cfg_5_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SET(r,d) (r).serdes_cfg_5_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_11r_GET(r) (r).serdes_cfg_5_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_11[0]=(((r).serdes_cfg_5_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_11r,(_r._serdes_cfg_5_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_11r,(_r._serdes_cfg_5_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_11r,(_r._serdes_cfg_5_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_11r BCMI_TSCD_XGXS_SERDES_CFG_5_11r
#define SERDES_CFG_5_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_11r_t SERDES_CFG_5_11r_t;
#define SERDES_CFG_5_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_11r_CLR
#define SERDES_CFG_5_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SET
#define SERDES_CFG_5_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_11r_GET
#define SERDES_CFG_5_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SPEED_CFGf_GET
#define SERDES_CFG_5_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_11r
#define WRITE_SERDES_CFG_5_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_11r
#define MODIFY_SERDES_CFG_5_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ac
 * DESC:     Serdes Config Index 5 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_12r (0x001093ac | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_12[1];
	uint32_t _serdes_cfg_5_12;
} BCMI_TSCD_XGXS_SERDES_CFG_5_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_12r_CLR(r) (r).serdes_cfg_5_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SET(r,d) (r).serdes_cfg_5_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_12r_GET(r) (r).serdes_cfg_5_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_12[0]=(((r).serdes_cfg_5_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_12r,(_r._serdes_cfg_5_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_12r,(_r._serdes_cfg_5_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_12r,(_r._serdes_cfg_5_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_12r BCMI_TSCD_XGXS_SERDES_CFG_5_12r
#define SERDES_CFG_5_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_12r_t SERDES_CFG_5_12r_t;
#define SERDES_CFG_5_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_12r_CLR
#define SERDES_CFG_5_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SET
#define SERDES_CFG_5_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_12r_GET
#define SERDES_CFG_5_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SPEED_CFGf_GET
#define SERDES_CFG_5_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_12r
#define WRITE_SERDES_CFG_5_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_12r
#define MODIFY_SERDES_CFG_5_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ad
 * DESC:     Serdes Config Index 5 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_13r (0x001093ad | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_13[1];
	uint32_t _serdes_cfg_5_13;
} BCMI_TSCD_XGXS_SERDES_CFG_5_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_13r_CLR(r) (r).serdes_cfg_5_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SET(r,d) (r).serdes_cfg_5_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_13r_GET(r) (r).serdes_cfg_5_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_13[0]=(((r).serdes_cfg_5_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_13r,(_r._serdes_cfg_5_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_13r,(_r._serdes_cfg_5_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_13r,(_r._serdes_cfg_5_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_13r BCMI_TSCD_XGXS_SERDES_CFG_5_13r
#define SERDES_CFG_5_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_13r_t SERDES_CFG_5_13r_t;
#define SERDES_CFG_5_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_13r_CLR
#define SERDES_CFG_5_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SET
#define SERDES_CFG_5_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_13r_GET
#define SERDES_CFG_5_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SPEED_CFGf_GET
#define SERDES_CFG_5_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_13r
#define WRITE_SERDES_CFG_5_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_13r
#define MODIFY_SERDES_CFG_5_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ae
 * DESC:     Serdes Config Index 5 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_14r (0x001093ae | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_14[1];
	uint32_t _serdes_cfg_5_14;
} BCMI_TSCD_XGXS_SERDES_CFG_5_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_14r_CLR(r) (r).serdes_cfg_5_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SET(r,d) (r).serdes_cfg_5_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_14r_GET(r) (r).serdes_cfg_5_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_14[0]=(((r).serdes_cfg_5_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_14r,(_r._serdes_cfg_5_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_14r,(_r._serdes_cfg_5_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_14r,(_r._serdes_cfg_5_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_14r BCMI_TSCD_XGXS_SERDES_CFG_5_14r
#define SERDES_CFG_5_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_14r_t SERDES_CFG_5_14r_t;
#define SERDES_CFG_5_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_14r_CLR
#define SERDES_CFG_5_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SET
#define SERDES_CFG_5_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_14r_GET
#define SERDES_CFG_5_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SPEED_CFGf_GET
#define SERDES_CFG_5_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_14r
#define WRITE_SERDES_CFG_5_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_14r
#define MODIFY_SERDES_CFG_5_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93af
 * DESC:     Serdes Config Index 5 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_15r (0x001093af | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_15[1];
	uint32_t _serdes_cfg_5_15;
} BCMI_TSCD_XGXS_SERDES_CFG_5_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_15r_CLR(r) (r).serdes_cfg_5_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SET(r,d) (r).serdes_cfg_5_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_15r_GET(r) (r).serdes_cfg_5_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_15[0]=(((r).serdes_cfg_5_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_15r,(_r._serdes_cfg_5_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_15r,(_r._serdes_cfg_5_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_15r,(_r._serdes_cfg_5_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_15r BCMI_TSCD_XGXS_SERDES_CFG_5_15r
#define SERDES_CFG_5_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_15r_t SERDES_CFG_5_15r_t;
#define SERDES_CFG_5_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_15r_CLR
#define SERDES_CFG_5_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SET
#define SERDES_CFG_5_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_15r_GET
#define SERDES_CFG_5_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SPEED_CFGf_GET
#define SERDES_CFG_5_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_15r
#define WRITE_SERDES_CFG_5_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_15r
#define MODIFY_SERDES_CFG_5_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b0
 * DESC:     Serdes Config Index 5 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_16r (0x001093b0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_16[1];
	uint32_t _serdes_cfg_5_16;
} BCMI_TSCD_XGXS_SERDES_CFG_5_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_16r_CLR(r) (r).serdes_cfg_5_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SET(r,d) (r).serdes_cfg_5_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_16r_GET(r) (r).serdes_cfg_5_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_16[0]=(((r).serdes_cfg_5_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_16r,(_r._serdes_cfg_5_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_16r,(_r._serdes_cfg_5_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_16r,(_r._serdes_cfg_5_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_16r BCMI_TSCD_XGXS_SERDES_CFG_5_16r
#define SERDES_CFG_5_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_16r_t SERDES_CFG_5_16r_t;
#define SERDES_CFG_5_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_16r_CLR
#define SERDES_CFG_5_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SET
#define SERDES_CFG_5_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_16r_GET
#define SERDES_CFG_5_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SPEED_CFGf_GET
#define SERDES_CFG_5_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_16r
#define WRITE_SERDES_CFG_5_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_16r
#define MODIFY_SERDES_CFG_5_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b1
 * DESC:     Serdes Config Index 5 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_17r (0x001093b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_17[1];
	uint32_t _serdes_cfg_5_17;
} BCMI_TSCD_XGXS_SERDES_CFG_5_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_17r_CLR(r) (r).serdes_cfg_5_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SET(r,d) (r).serdes_cfg_5_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_17r_GET(r) (r).serdes_cfg_5_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_17[0]=(((r).serdes_cfg_5_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_17r,(_r._serdes_cfg_5_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_17r,(_r._serdes_cfg_5_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_17r,(_r._serdes_cfg_5_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_17r BCMI_TSCD_XGXS_SERDES_CFG_5_17r
#define SERDES_CFG_5_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_17r_t SERDES_CFG_5_17r_t;
#define SERDES_CFG_5_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_17r_CLR
#define SERDES_CFG_5_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SET
#define SERDES_CFG_5_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_17r_GET
#define SERDES_CFG_5_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SPEED_CFGf_GET
#define SERDES_CFG_5_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_17r
#define WRITE_SERDES_CFG_5_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_17r
#define MODIFY_SERDES_CFG_5_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b2
 * DESC:     Serdes Config Index 5 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_18r (0x001093b2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_18[1];
	uint32_t _serdes_cfg_5_18;
} BCMI_TSCD_XGXS_SERDES_CFG_5_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_18r_CLR(r) (r).serdes_cfg_5_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SET(r,d) (r).serdes_cfg_5_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_18r_GET(r) (r).serdes_cfg_5_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_18[0]=(((r).serdes_cfg_5_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_18r,(_r._serdes_cfg_5_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_18r,(_r._serdes_cfg_5_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_18r,(_r._serdes_cfg_5_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_18r BCMI_TSCD_XGXS_SERDES_CFG_5_18r
#define SERDES_CFG_5_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_18r_t SERDES_CFG_5_18r_t;
#define SERDES_CFG_5_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_18r_CLR
#define SERDES_CFG_5_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SET
#define SERDES_CFG_5_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_18r_GET
#define SERDES_CFG_5_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SPEED_CFGf_GET
#define SERDES_CFG_5_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_18r
#define WRITE_SERDES_CFG_5_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_18r
#define MODIFY_SERDES_CFG_5_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b3
 * DESC:     Serdes Config Index 5 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_19r (0x001093b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_19[1];
	uint32_t _serdes_cfg_5_19;
} BCMI_TSCD_XGXS_SERDES_CFG_5_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_19r_CLR(r) (r).serdes_cfg_5_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SET(r,d) (r).serdes_cfg_5_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_19r_GET(r) (r).serdes_cfg_5_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_19[0]=(((r).serdes_cfg_5_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_19r,(_r._serdes_cfg_5_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_19r,(_r._serdes_cfg_5_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_19r,(_r._serdes_cfg_5_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_19r BCMI_TSCD_XGXS_SERDES_CFG_5_19r
#define SERDES_CFG_5_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_19r_t SERDES_CFG_5_19r_t;
#define SERDES_CFG_5_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_19r_CLR
#define SERDES_CFG_5_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SET
#define SERDES_CFG_5_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_19r_GET
#define SERDES_CFG_5_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SPEED_CFGf_GET
#define SERDES_CFG_5_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_19r
#define WRITE_SERDES_CFG_5_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_19r
#define MODIFY_SERDES_CFG_5_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b4
 * DESC:     Serdes Config Index 5 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_20r (0x001093b4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_20[1];
	uint32_t _serdes_cfg_5_20;
} BCMI_TSCD_XGXS_SERDES_CFG_5_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_20r_CLR(r) (r).serdes_cfg_5_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SET(r,d) (r).serdes_cfg_5_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_20r_GET(r) (r).serdes_cfg_5_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_5_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_5_20[0]=(((r).serdes_cfg_5_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_5_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_20r,(_r._serdes_cfg_5_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_20r,(_r._serdes_cfg_5_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_20r,(_r._serdes_cfg_5_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_20r BCMI_TSCD_XGXS_SERDES_CFG_5_20r
#define SERDES_CFG_5_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_20r_t SERDES_CFG_5_20r_t;
#define SERDES_CFG_5_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_20r_CLR
#define SERDES_CFG_5_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SET
#define SERDES_CFG_5_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_20r_GET
#define SERDES_CFG_5_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SPEED_CFGf_GET
#define SERDES_CFG_5_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_5_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_20r
#define WRITE_SERDES_CFG_5_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_20r
#define MODIFY_SERDES_CFG_5_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b5
 * DESC:     Serdes Config Index 5 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_21r (0x001093b5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_21[1];
	uint32_t _serdes_cfg_5_21;
} BCMI_TSCD_XGXS_SERDES_CFG_5_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_21r_CLR(r) (r).serdes_cfg_5_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_21r_SET(r,d) (r).serdes_cfg_5_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_21r_GET(r) (r).serdes_cfg_5_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_5_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_5_21[0]=(((r).serdes_cfg_5_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_5_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_21r,(_r._serdes_cfg_5_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_21r,(_r._serdes_cfg_5_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_21r,(_r._serdes_cfg_5_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_21r BCMI_TSCD_XGXS_SERDES_CFG_5_21r
#define SERDES_CFG_5_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_21r_t SERDES_CFG_5_21r_t;
#define SERDES_CFG_5_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_21r_CLR
#define SERDES_CFG_5_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_21r_SET
#define SERDES_CFG_5_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_21r_GET
#define SERDES_CFG_5_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_21r_FCLK_PERIODf_GET
#define SERDES_CFG_5_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_5_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_21r
#define WRITE_SERDES_CFG_5_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_21r
#define MODIFY_SERDES_CFG_5_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b6
 * DESC:     Serdes Config Index 5 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r (0x001093b6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_22[1];
	uint32_t _serdes_cfg_5_22;
} BCMI_TSCD_XGXS_SERDES_CFG_5_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_CLR(r) (r).serdes_cfg_5_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SET(r,d) (r).serdes_cfg_5_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_GET(r) (r).serdes_cfg_5_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SPAREf_GET(r) ((((r).serdes_cfg_5_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SPAREf_SET(r,f) (r).serdes_cfg_5_22[0]=(((r).serdes_cfg_5_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_5_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_5_22[0]=(((r).serdes_cfg_5_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_5_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_22r,(_r._serdes_cfg_5_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_22r,(_r._serdes_cfg_5_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_22r,(_r._serdes_cfg_5_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_22r BCMI_TSCD_XGXS_SERDES_CFG_5_22r
#define SERDES_CFG_5_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_22r_t SERDES_CFG_5_22r_t;
#define SERDES_CFG_5_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_22r_CLR
#define SERDES_CFG_5_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SET
#define SERDES_CFG_5_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_22r_GET
#define SERDES_CFG_5_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SPAREf_GET
#define SERDES_CFG_5_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_22r_SPAREf_SET
#define SERDES_CFG_5_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_22r_RX_LOSVREFf_GET
#define SERDES_CFG_5_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_5_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_22r
#define WRITE_SERDES_CFG_5_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_22r
#define MODIFY_SERDES_CFG_5_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_5_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93b7
 * DESC:     Serdes Config Index 5 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r (0x001093b7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_5_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_5_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_5_23[1];
	uint32_t _serdes_cfg_5_23;
} BCMI_TSCD_XGXS_SERDES_CFG_5_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_CLR(r) (r).serdes_cfg_5_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_SET(r,d) (r).serdes_cfg_5_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_GET(r) (r).serdes_cfg_5_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_5_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_5_23[0]=(((r).serdes_cfg_5_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_5_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_5_23[0]=(((r).serdes_cfg_5_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_5_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_5_23[0]=(((r).serdes_cfg_5_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_RATESELf_GET(r) ((((r).serdes_cfg_5_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_RATESELf_SET(r,f) (r).serdes_cfg_5_23[0]=(((r).serdes_cfg_5_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_5_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_5_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_5_23[0]=(((r).serdes_cfg_5_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_5_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_5_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_23r,(_r._serdes_cfg_5_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_23r,(_r._serdes_cfg_5_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_5_23r,(_r._serdes_cfg_5_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_5_23r BCMI_TSCD_XGXS_SERDES_CFG_5_23r
#define SERDES_CFG_5_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_5_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_5_23r_t SERDES_CFG_5_23r_t;
#define SERDES_CFG_5_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_5_23r_CLR
#define SERDES_CFG_5_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_SET
#define SERDES_CFG_5_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_GET
#define SERDES_CFG_5_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_5_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_5_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODEf_GET
#define SERDES_CFG_5_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_TRAINING_MODEf_SET
#define SERDES_CFG_5_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_WORDMODEf_GET
#define SERDES_CFG_5_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_WORDMODEf_SET
#define SERDES_CFG_5_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_RATESELf_GET
#define SERDES_CFG_5_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_RATESELf_SET
#define SERDES_CFG_5_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_5_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_5_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_5_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_5_23r
#define WRITE_SERDES_CFG_5_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_5_23r
#define MODIFY_SERDES_CFG_5_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_5_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_5_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c0
 * DESC:     Serdes Config Index 6 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_0r (0x001093c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_0[1];
	uint32_t _serdes_cfg_6_0;
} BCMI_TSCD_XGXS_SERDES_CFG_6_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_0r_CLR(r) (r).serdes_cfg_6_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SET(r,d) (r).serdes_cfg_6_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_0r_GET(r) (r).serdes_cfg_6_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_0[0]=(((r).serdes_cfg_6_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_0r,(_r._serdes_cfg_6_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_0r,(_r._serdes_cfg_6_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_0r,(_r._serdes_cfg_6_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_0r BCMI_TSCD_XGXS_SERDES_CFG_6_0r
#define SERDES_CFG_6_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_0r_t SERDES_CFG_6_0r_t;
#define SERDES_CFG_6_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_0r_CLR
#define SERDES_CFG_6_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SET
#define SERDES_CFG_6_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_0r_GET
#define SERDES_CFG_6_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SPEED_CFGf_GET
#define SERDES_CFG_6_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_0r
#define WRITE_SERDES_CFG_6_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_0r
#define MODIFY_SERDES_CFG_6_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c1
 * DESC:     Serdes Config Index 6 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_1r (0x001093c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_1[1];
	uint32_t _serdes_cfg_6_1;
} BCMI_TSCD_XGXS_SERDES_CFG_6_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_1r_CLR(r) (r).serdes_cfg_6_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SET(r,d) (r).serdes_cfg_6_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_1r_GET(r) (r).serdes_cfg_6_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_1[0]=(((r).serdes_cfg_6_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_1r,(_r._serdes_cfg_6_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_1r,(_r._serdes_cfg_6_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_1r,(_r._serdes_cfg_6_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_1r BCMI_TSCD_XGXS_SERDES_CFG_6_1r
#define SERDES_CFG_6_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_1r_t SERDES_CFG_6_1r_t;
#define SERDES_CFG_6_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_1r_CLR
#define SERDES_CFG_6_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SET
#define SERDES_CFG_6_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_1r_GET
#define SERDES_CFG_6_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SPEED_CFGf_GET
#define SERDES_CFG_6_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_1r
#define WRITE_SERDES_CFG_6_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_1r
#define MODIFY_SERDES_CFG_6_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c2
 * DESC:     Serdes Config Index 6 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_2r (0x001093c2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_2[1];
	uint32_t _serdes_cfg_6_2;
} BCMI_TSCD_XGXS_SERDES_CFG_6_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_2r_CLR(r) (r).serdes_cfg_6_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SET(r,d) (r).serdes_cfg_6_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_2r_GET(r) (r).serdes_cfg_6_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_2[0]=(((r).serdes_cfg_6_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_2r,(_r._serdes_cfg_6_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_2r,(_r._serdes_cfg_6_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_2r,(_r._serdes_cfg_6_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_2r BCMI_TSCD_XGXS_SERDES_CFG_6_2r
#define SERDES_CFG_6_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_2r_t SERDES_CFG_6_2r_t;
#define SERDES_CFG_6_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_2r_CLR
#define SERDES_CFG_6_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SET
#define SERDES_CFG_6_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_2r_GET
#define SERDES_CFG_6_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SPEED_CFGf_GET
#define SERDES_CFG_6_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_2r
#define WRITE_SERDES_CFG_6_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_2r
#define MODIFY_SERDES_CFG_6_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c3
 * DESC:     Serdes Config Index 6 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_3r (0x001093c3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_3[1];
	uint32_t _serdes_cfg_6_3;
} BCMI_TSCD_XGXS_SERDES_CFG_6_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_3r_CLR(r) (r).serdes_cfg_6_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SET(r,d) (r).serdes_cfg_6_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_3r_GET(r) (r).serdes_cfg_6_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_3[0]=(((r).serdes_cfg_6_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_3r,(_r._serdes_cfg_6_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_3r,(_r._serdes_cfg_6_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_3r,(_r._serdes_cfg_6_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_3r BCMI_TSCD_XGXS_SERDES_CFG_6_3r
#define SERDES_CFG_6_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_3r_t SERDES_CFG_6_3r_t;
#define SERDES_CFG_6_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_3r_CLR
#define SERDES_CFG_6_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SET
#define SERDES_CFG_6_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_3r_GET
#define SERDES_CFG_6_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SPEED_CFGf_GET
#define SERDES_CFG_6_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_3r
#define WRITE_SERDES_CFG_6_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_3r
#define MODIFY_SERDES_CFG_6_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c4
 * DESC:     Serdes Config Index 6 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_4r (0x001093c4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_4[1];
	uint32_t _serdes_cfg_6_4;
} BCMI_TSCD_XGXS_SERDES_CFG_6_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_4r_CLR(r) (r).serdes_cfg_6_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SET(r,d) (r).serdes_cfg_6_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_4r_GET(r) (r).serdes_cfg_6_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_4[0]=(((r).serdes_cfg_6_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_4r,(_r._serdes_cfg_6_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_4r,(_r._serdes_cfg_6_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_4r,(_r._serdes_cfg_6_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_4r BCMI_TSCD_XGXS_SERDES_CFG_6_4r
#define SERDES_CFG_6_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_4r_t SERDES_CFG_6_4r_t;
#define SERDES_CFG_6_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_4r_CLR
#define SERDES_CFG_6_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SET
#define SERDES_CFG_6_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_4r_GET
#define SERDES_CFG_6_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SPEED_CFGf_GET
#define SERDES_CFG_6_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_4r
#define WRITE_SERDES_CFG_6_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_4r
#define MODIFY_SERDES_CFG_6_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c5
 * DESC:     Serdes Config Index 6 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_5r (0x001093c5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_5[1];
	uint32_t _serdes_cfg_6_5;
} BCMI_TSCD_XGXS_SERDES_CFG_6_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_5r_CLR(r) (r).serdes_cfg_6_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SET(r,d) (r).serdes_cfg_6_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_5r_GET(r) (r).serdes_cfg_6_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_5[0]=(((r).serdes_cfg_6_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_5r,(_r._serdes_cfg_6_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_5r,(_r._serdes_cfg_6_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_5r,(_r._serdes_cfg_6_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_5r BCMI_TSCD_XGXS_SERDES_CFG_6_5r
#define SERDES_CFG_6_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_5r_t SERDES_CFG_6_5r_t;
#define SERDES_CFG_6_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_5r_CLR
#define SERDES_CFG_6_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SET
#define SERDES_CFG_6_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_5r_GET
#define SERDES_CFG_6_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SPEED_CFGf_GET
#define SERDES_CFG_6_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_5r
#define WRITE_SERDES_CFG_6_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_5r
#define MODIFY_SERDES_CFG_6_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c6
 * DESC:     Serdes Config Index 6 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_6r (0x001093c6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_6[1];
	uint32_t _serdes_cfg_6_6;
} BCMI_TSCD_XGXS_SERDES_CFG_6_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_6r_CLR(r) (r).serdes_cfg_6_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SET(r,d) (r).serdes_cfg_6_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_6r_GET(r) (r).serdes_cfg_6_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_6[0]=(((r).serdes_cfg_6_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_6r,(_r._serdes_cfg_6_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_6r,(_r._serdes_cfg_6_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_6r,(_r._serdes_cfg_6_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_6r BCMI_TSCD_XGXS_SERDES_CFG_6_6r
#define SERDES_CFG_6_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_6r_t SERDES_CFG_6_6r_t;
#define SERDES_CFG_6_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_6r_CLR
#define SERDES_CFG_6_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SET
#define SERDES_CFG_6_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_6r_GET
#define SERDES_CFG_6_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SPEED_CFGf_GET
#define SERDES_CFG_6_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_6r
#define WRITE_SERDES_CFG_6_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_6r
#define MODIFY_SERDES_CFG_6_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c7
 * DESC:     Serdes Config Index 6 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_7r (0x001093c7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_7[1];
	uint32_t _serdes_cfg_6_7;
} BCMI_TSCD_XGXS_SERDES_CFG_6_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_7r_CLR(r) (r).serdes_cfg_6_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SET(r,d) (r).serdes_cfg_6_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_7r_GET(r) (r).serdes_cfg_6_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_7[0]=(((r).serdes_cfg_6_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_7r,(_r._serdes_cfg_6_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_7r,(_r._serdes_cfg_6_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_7r,(_r._serdes_cfg_6_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_7r BCMI_TSCD_XGXS_SERDES_CFG_6_7r
#define SERDES_CFG_6_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_7r_t SERDES_CFG_6_7r_t;
#define SERDES_CFG_6_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_7r_CLR
#define SERDES_CFG_6_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SET
#define SERDES_CFG_6_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_7r_GET
#define SERDES_CFG_6_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SPEED_CFGf_GET
#define SERDES_CFG_6_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_7r
#define WRITE_SERDES_CFG_6_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_7r
#define MODIFY_SERDES_CFG_6_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c8
 * DESC:     Serdes Config Index 6 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_8r (0x001093c8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_8[1];
	uint32_t _serdes_cfg_6_8;
} BCMI_TSCD_XGXS_SERDES_CFG_6_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_8r_CLR(r) (r).serdes_cfg_6_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SET(r,d) (r).serdes_cfg_6_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_8r_GET(r) (r).serdes_cfg_6_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_8[0]=(((r).serdes_cfg_6_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_8r,(_r._serdes_cfg_6_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_8r,(_r._serdes_cfg_6_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_8r,(_r._serdes_cfg_6_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_8r BCMI_TSCD_XGXS_SERDES_CFG_6_8r
#define SERDES_CFG_6_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_8r_t SERDES_CFG_6_8r_t;
#define SERDES_CFG_6_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_8r_CLR
#define SERDES_CFG_6_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SET
#define SERDES_CFG_6_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_8r_GET
#define SERDES_CFG_6_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SPEED_CFGf_GET
#define SERDES_CFG_6_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_8r
#define WRITE_SERDES_CFG_6_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_8r
#define MODIFY_SERDES_CFG_6_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93c9
 * DESC:     Serdes Config Index 6 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_9r (0x001093c9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_9[1];
	uint32_t _serdes_cfg_6_9;
} BCMI_TSCD_XGXS_SERDES_CFG_6_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_9r_CLR(r) (r).serdes_cfg_6_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SET(r,d) (r).serdes_cfg_6_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_9r_GET(r) (r).serdes_cfg_6_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_9[0]=(((r).serdes_cfg_6_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_9r,(_r._serdes_cfg_6_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_9r,(_r._serdes_cfg_6_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_9r,(_r._serdes_cfg_6_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_9r BCMI_TSCD_XGXS_SERDES_CFG_6_9r
#define SERDES_CFG_6_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_9r_t SERDES_CFG_6_9r_t;
#define SERDES_CFG_6_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_9r_CLR
#define SERDES_CFG_6_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SET
#define SERDES_CFG_6_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_9r_GET
#define SERDES_CFG_6_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SPEED_CFGf_GET
#define SERDES_CFG_6_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_9r
#define WRITE_SERDES_CFG_6_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_9r
#define MODIFY_SERDES_CFG_6_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ca
 * DESC:     Serdes Config Index 6 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_10r (0x001093ca | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_10[1];
	uint32_t _serdes_cfg_6_10;
} BCMI_TSCD_XGXS_SERDES_CFG_6_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_10r_CLR(r) (r).serdes_cfg_6_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SET(r,d) (r).serdes_cfg_6_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_10r_GET(r) (r).serdes_cfg_6_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_10[0]=(((r).serdes_cfg_6_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_10r,(_r._serdes_cfg_6_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_10r,(_r._serdes_cfg_6_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_10r,(_r._serdes_cfg_6_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_10r BCMI_TSCD_XGXS_SERDES_CFG_6_10r
#define SERDES_CFG_6_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_10r_t SERDES_CFG_6_10r_t;
#define SERDES_CFG_6_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_10r_CLR
#define SERDES_CFG_6_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SET
#define SERDES_CFG_6_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_10r_GET
#define SERDES_CFG_6_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SPEED_CFGf_GET
#define SERDES_CFG_6_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_10r
#define WRITE_SERDES_CFG_6_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_10r
#define MODIFY_SERDES_CFG_6_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93cb
 * DESC:     Serdes Config Index 6 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_11r (0x001093cb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_11[1];
	uint32_t _serdes_cfg_6_11;
} BCMI_TSCD_XGXS_SERDES_CFG_6_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_11r_CLR(r) (r).serdes_cfg_6_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SET(r,d) (r).serdes_cfg_6_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_11r_GET(r) (r).serdes_cfg_6_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_11[0]=(((r).serdes_cfg_6_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_11r,(_r._serdes_cfg_6_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_11r,(_r._serdes_cfg_6_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_11r,(_r._serdes_cfg_6_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_11r BCMI_TSCD_XGXS_SERDES_CFG_6_11r
#define SERDES_CFG_6_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_11r_t SERDES_CFG_6_11r_t;
#define SERDES_CFG_6_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_11r_CLR
#define SERDES_CFG_6_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SET
#define SERDES_CFG_6_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_11r_GET
#define SERDES_CFG_6_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SPEED_CFGf_GET
#define SERDES_CFG_6_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_11r
#define WRITE_SERDES_CFG_6_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_11r
#define MODIFY_SERDES_CFG_6_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93cc
 * DESC:     Serdes Config Index 6 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_12r (0x001093cc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_12[1];
	uint32_t _serdes_cfg_6_12;
} BCMI_TSCD_XGXS_SERDES_CFG_6_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_12r_CLR(r) (r).serdes_cfg_6_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SET(r,d) (r).serdes_cfg_6_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_12r_GET(r) (r).serdes_cfg_6_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_12[0]=(((r).serdes_cfg_6_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_12r,(_r._serdes_cfg_6_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_12r,(_r._serdes_cfg_6_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_12r,(_r._serdes_cfg_6_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_12r BCMI_TSCD_XGXS_SERDES_CFG_6_12r
#define SERDES_CFG_6_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_12r_t SERDES_CFG_6_12r_t;
#define SERDES_CFG_6_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_12r_CLR
#define SERDES_CFG_6_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SET
#define SERDES_CFG_6_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_12r_GET
#define SERDES_CFG_6_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SPEED_CFGf_GET
#define SERDES_CFG_6_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_12r
#define WRITE_SERDES_CFG_6_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_12r
#define MODIFY_SERDES_CFG_6_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93cd
 * DESC:     Serdes Config Index 6 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_13r (0x001093cd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_13[1];
	uint32_t _serdes_cfg_6_13;
} BCMI_TSCD_XGXS_SERDES_CFG_6_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_13r_CLR(r) (r).serdes_cfg_6_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SET(r,d) (r).serdes_cfg_6_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_13r_GET(r) (r).serdes_cfg_6_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_13[0]=(((r).serdes_cfg_6_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_13r,(_r._serdes_cfg_6_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_13r,(_r._serdes_cfg_6_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_13r,(_r._serdes_cfg_6_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_13r BCMI_TSCD_XGXS_SERDES_CFG_6_13r
#define SERDES_CFG_6_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_13r_t SERDES_CFG_6_13r_t;
#define SERDES_CFG_6_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_13r_CLR
#define SERDES_CFG_6_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SET
#define SERDES_CFG_6_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_13r_GET
#define SERDES_CFG_6_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SPEED_CFGf_GET
#define SERDES_CFG_6_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_13r
#define WRITE_SERDES_CFG_6_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_13r
#define MODIFY_SERDES_CFG_6_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ce
 * DESC:     Serdes Config Index 6 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_14r (0x001093ce | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_14[1];
	uint32_t _serdes_cfg_6_14;
} BCMI_TSCD_XGXS_SERDES_CFG_6_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_14r_CLR(r) (r).serdes_cfg_6_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SET(r,d) (r).serdes_cfg_6_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_14r_GET(r) (r).serdes_cfg_6_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_14[0]=(((r).serdes_cfg_6_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_14r,(_r._serdes_cfg_6_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_14r,(_r._serdes_cfg_6_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_14r,(_r._serdes_cfg_6_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_14r BCMI_TSCD_XGXS_SERDES_CFG_6_14r
#define SERDES_CFG_6_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_14r_t SERDES_CFG_6_14r_t;
#define SERDES_CFG_6_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_14r_CLR
#define SERDES_CFG_6_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SET
#define SERDES_CFG_6_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_14r_GET
#define SERDES_CFG_6_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SPEED_CFGf_GET
#define SERDES_CFG_6_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_14r
#define WRITE_SERDES_CFG_6_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_14r
#define MODIFY_SERDES_CFG_6_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93cf
 * DESC:     Serdes Config Index 6 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_15r (0x001093cf | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_15[1];
	uint32_t _serdes_cfg_6_15;
} BCMI_TSCD_XGXS_SERDES_CFG_6_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_15r_CLR(r) (r).serdes_cfg_6_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SET(r,d) (r).serdes_cfg_6_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_15r_GET(r) (r).serdes_cfg_6_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_15[0]=(((r).serdes_cfg_6_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_15r,(_r._serdes_cfg_6_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_15r,(_r._serdes_cfg_6_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_15r,(_r._serdes_cfg_6_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_15r BCMI_TSCD_XGXS_SERDES_CFG_6_15r
#define SERDES_CFG_6_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_15r_t SERDES_CFG_6_15r_t;
#define SERDES_CFG_6_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_15r_CLR
#define SERDES_CFG_6_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SET
#define SERDES_CFG_6_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_15r_GET
#define SERDES_CFG_6_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SPEED_CFGf_GET
#define SERDES_CFG_6_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_15r
#define WRITE_SERDES_CFG_6_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_15r
#define MODIFY_SERDES_CFG_6_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d0
 * DESC:     Serdes Config Index 6 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_16r (0x001093d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_16[1];
	uint32_t _serdes_cfg_6_16;
} BCMI_TSCD_XGXS_SERDES_CFG_6_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_16r_CLR(r) (r).serdes_cfg_6_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SET(r,d) (r).serdes_cfg_6_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_16r_GET(r) (r).serdes_cfg_6_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_16[0]=(((r).serdes_cfg_6_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_16r,(_r._serdes_cfg_6_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_16r,(_r._serdes_cfg_6_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_16r,(_r._serdes_cfg_6_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_16r BCMI_TSCD_XGXS_SERDES_CFG_6_16r
#define SERDES_CFG_6_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_16r_t SERDES_CFG_6_16r_t;
#define SERDES_CFG_6_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_16r_CLR
#define SERDES_CFG_6_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SET
#define SERDES_CFG_6_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_16r_GET
#define SERDES_CFG_6_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SPEED_CFGf_GET
#define SERDES_CFG_6_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_16r
#define WRITE_SERDES_CFG_6_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_16r
#define MODIFY_SERDES_CFG_6_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d1
 * DESC:     Serdes Config Index 6 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_17r (0x001093d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_17[1];
	uint32_t _serdes_cfg_6_17;
} BCMI_TSCD_XGXS_SERDES_CFG_6_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_17r_CLR(r) (r).serdes_cfg_6_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SET(r,d) (r).serdes_cfg_6_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_17r_GET(r) (r).serdes_cfg_6_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_17[0]=(((r).serdes_cfg_6_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_17r,(_r._serdes_cfg_6_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_17r,(_r._serdes_cfg_6_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_17r,(_r._serdes_cfg_6_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_17r BCMI_TSCD_XGXS_SERDES_CFG_6_17r
#define SERDES_CFG_6_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_17r_t SERDES_CFG_6_17r_t;
#define SERDES_CFG_6_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_17r_CLR
#define SERDES_CFG_6_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SET
#define SERDES_CFG_6_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_17r_GET
#define SERDES_CFG_6_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SPEED_CFGf_GET
#define SERDES_CFG_6_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_17r
#define WRITE_SERDES_CFG_6_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_17r
#define MODIFY_SERDES_CFG_6_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d2
 * DESC:     Serdes Config Index 6 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_18r (0x001093d2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_18[1];
	uint32_t _serdes_cfg_6_18;
} BCMI_TSCD_XGXS_SERDES_CFG_6_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_18r_CLR(r) (r).serdes_cfg_6_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SET(r,d) (r).serdes_cfg_6_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_18r_GET(r) (r).serdes_cfg_6_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_18[0]=(((r).serdes_cfg_6_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_18r,(_r._serdes_cfg_6_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_18r,(_r._serdes_cfg_6_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_18r,(_r._serdes_cfg_6_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_18r BCMI_TSCD_XGXS_SERDES_CFG_6_18r
#define SERDES_CFG_6_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_18r_t SERDES_CFG_6_18r_t;
#define SERDES_CFG_6_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_18r_CLR
#define SERDES_CFG_6_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SET
#define SERDES_CFG_6_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_18r_GET
#define SERDES_CFG_6_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SPEED_CFGf_GET
#define SERDES_CFG_6_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_18r
#define WRITE_SERDES_CFG_6_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_18r
#define MODIFY_SERDES_CFG_6_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d3
 * DESC:     Serdes Config Index 6 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_19r (0x001093d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_19[1];
	uint32_t _serdes_cfg_6_19;
} BCMI_TSCD_XGXS_SERDES_CFG_6_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_19r_CLR(r) (r).serdes_cfg_6_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SET(r,d) (r).serdes_cfg_6_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_19r_GET(r) (r).serdes_cfg_6_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_19[0]=(((r).serdes_cfg_6_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_19r,(_r._serdes_cfg_6_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_19r,(_r._serdes_cfg_6_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_19r,(_r._serdes_cfg_6_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_19r BCMI_TSCD_XGXS_SERDES_CFG_6_19r
#define SERDES_CFG_6_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_19r_t SERDES_CFG_6_19r_t;
#define SERDES_CFG_6_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_19r_CLR
#define SERDES_CFG_6_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SET
#define SERDES_CFG_6_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_19r_GET
#define SERDES_CFG_6_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SPEED_CFGf_GET
#define SERDES_CFG_6_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_19r
#define WRITE_SERDES_CFG_6_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_19r
#define MODIFY_SERDES_CFG_6_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d4
 * DESC:     Serdes Config Index 6 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_20r (0x001093d4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_20[1];
	uint32_t _serdes_cfg_6_20;
} BCMI_TSCD_XGXS_SERDES_CFG_6_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_20r_CLR(r) (r).serdes_cfg_6_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SET(r,d) (r).serdes_cfg_6_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_20r_GET(r) (r).serdes_cfg_6_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_6_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_6_20[0]=(((r).serdes_cfg_6_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_6_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_20r,(_r._serdes_cfg_6_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_20r,(_r._serdes_cfg_6_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_20r,(_r._serdes_cfg_6_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_20r BCMI_TSCD_XGXS_SERDES_CFG_6_20r
#define SERDES_CFG_6_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_20r_t SERDES_CFG_6_20r_t;
#define SERDES_CFG_6_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_20r_CLR
#define SERDES_CFG_6_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SET
#define SERDES_CFG_6_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_20r_GET
#define SERDES_CFG_6_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SPEED_CFGf_GET
#define SERDES_CFG_6_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_6_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_20r
#define WRITE_SERDES_CFG_6_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_20r
#define MODIFY_SERDES_CFG_6_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d5
 * DESC:     Serdes Config Index 6 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_21r (0x001093d5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_21[1];
	uint32_t _serdes_cfg_6_21;
} BCMI_TSCD_XGXS_SERDES_CFG_6_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_21r_CLR(r) (r).serdes_cfg_6_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_21r_SET(r,d) (r).serdes_cfg_6_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_21r_GET(r) (r).serdes_cfg_6_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_6_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_6_21[0]=(((r).serdes_cfg_6_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_6_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_21r,(_r._serdes_cfg_6_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_21r,(_r._serdes_cfg_6_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_21r,(_r._serdes_cfg_6_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_21r BCMI_TSCD_XGXS_SERDES_CFG_6_21r
#define SERDES_CFG_6_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_21r_t SERDES_CFG_6_21r_t;
#define SERDES_CFG_6_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_21r_CLR
#define SERDES_CFG_6_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_21r_SET
#define SERDES_CFG_6_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_21r_GET
#define SERDES_CFG_6_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_21r_FCLK_PERIODf_GET
#define SERDES_CFG_6_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_6_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_21r
#define WRITE_SERDES_CFG_6_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_21r
#define MODIFY_SERDES_CFG_6_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d6
 * DESC:     Serdes Config Index 6 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r (0x001093d6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_22[1];
	uint32_t _serdes_cfg_6_22;
} BCMI_TSCD_XGXS_SERDES_CFG_6_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_CLR(r) (r).serdes_cfg_6_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SET(r,d) (r).serdes_cfg_6_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_GET(r) (r).serdes_cfg_6_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SPAREf_GET(r) ((((r).serdes_cfg_6_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SPAREf_SET(r,f) (r).serdes_cfg_6_22[0]=(((r).serdes_cfg_6_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_6_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_6_22[0]=(((r).serdes_cfg_6_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_6_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_22r,(_r._serdes_cfg_6_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_22r,(_r._serdes_cfg_6_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_22r,(_r._serdes_cfg_6_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_22r BCMI_TSCD_XGXS_SERDES_CFG_6_22r
#define SERDES_CFG_6_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_22r_t SERDES_CFG_6_22r_t;
#define SERDES_CFG_6_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_22r_CLR
#define SERDES_CFG_6_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SET
#define SERDES_CFG_6_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_22r_GET
#define SERDES_CFG_6_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SPAREf_GET
#define SERDES_CFG_6_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_22r_SPAREf_SET
#define SERDES_CFG_6_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_22r_RX_LOSVREFf_GET
#define SERDES_CFG_6_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_6_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_22r
#define WRITE_SERDES_CFG_6_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_22r
#define MODIFY_SERDES_CFG_6_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_6_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93d7
 * DESC:     Serdes Config Index 6 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r (0x001093d7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_6_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_6_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_6_23[1];
	uint32_t _serdes_cfg_6_23;
} BCMI_TSCD_XGXS_SERDES_CFG_6_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_CLR(r) (r).serdes_cfg_6_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_SET(r,d) (r).serdes_cfg_6_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_GET(r) (r).serdes_cfg_6_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_6_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_6_23[0]=(((r).serdes_cfg_6_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_6_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_6_23[0]=(((r).serdes_cfg_6_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_6_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_6_23[0]=(((r).serdes_cfg_6_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_RATESELf_GET(r) ((((r).serdes_cfg_6_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_RATESELf_SET(r,f) (r).serdes_cfg_6_23[0]=(((r).serdes_cfg_6_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_6_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_6_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_6_23[0]=(((r).serdes_cfg_6_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_6_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_6_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_23r,(_r._serdes_cfg_6_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_23r,(_r._serdes_cfg_6_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_6_23r,(_r._serdes_cfg_6_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_6_23r BCMI_TSCD_XGXS_SERDES_CFG_6_23r
#define SERDES_CFG_6_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_6_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_6_23r_t SERDES_CFG_6_23r_t;
#define SERDES_CFG_6_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_6_23r_CLR
#define SERDES_CFG_6_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_SET
#define SERDES_CFG_6_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_GET
#define SERDES_CFG_6_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_6_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_6_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODEf_GET
#define SERDES_CFG_6_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_TRAINING_MODEf_SET
#define SERDES_CFG_6_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_WORDMODEf_GET
#define SERDES_CFG_6_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_WORDMODEf_SET
#define SERDES_CFG_6_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_RATESELf_GET
#define SERDES_CFG_6_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_RATESELf_SET
#define SERDES_CFG_6_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_6_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_6_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_6_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_6_23r
#define WRITE_SERDES_CFG_6_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_6_23r
#define MODIFY_SERDES_CFG_6_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_6_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_6_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e0
 * DESC:     Serdes Config Index 7 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_0r (0x001093e0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_0[1];
	uint32_t _serdes_cfg_7_0;
} BCMI_TSCD_XGXS_SERDES_CFG_7_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_0r_CLR(r) (r).serdes_cfg_7_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SET(r,d) (r).serdes_cfg_7_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_0r_GET(r) (r).serdes_cfg_7_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_0[0]=(((r).serdes_cfg_7_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_0r,(_r._serdes_cfg_7_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_0r,(_r._serdes_cfg_7_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_0r,(_r._serdes_cfg_7_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_0r BCMI_TSCD_XGXS_SERDES_CFG_7_0r
#define SERDES_CFG_7_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_0r_t SERDES_CFG_7_0r_t;
#define SERDES_CFG_7_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_0r_CLR
#define SERDES_CFG_7_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SET
#define SERDES_CFG_7_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_0r_GET
#define SERDES_CFG_7_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SPEED_CFGf_GET
#define SERDES_CFG_7_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_0r
#define WRITE_SERDES_CFG_7_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_0r
#define MODIFY_SERDES_CFG_7_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e1
 * DESC:     Serdes Config Index 7 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_1r (0x001093e1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_1[1];
	uint32_t _serdes_cfg_7_1;
} BCMI_TSCD_XGXS_SERDES_CFG_7_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_1r_CLR(r) (r).serdes_cfg_7_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SET(r,d) (r).serdes_cfg_7_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_1r_GET(r) (r).serdes_cfg_7_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_1[0]=(((r).serdes_cfg_7_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_1r,(_r._serdes_cfg_7_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_1r,(_r._serdes_cfg_7_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_1r,(_r._serdes_cfg_7_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_1r BCMI_TSCD_XGXS_SERDES_CFG_7_1r
#define SERDES_CFG_7_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_1r_t SERDES_CFG_7_1r_t;
#define SERDES_CFG_7_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_1r_CLR
#define SERDES_CFG_7_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SET
#define SERDES_CFG_7_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_1r_GET
#define SERDES_CFG_7_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SPEED_CFGf_GET
#define SERDES_CFG_7_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_1r
#define WRITE_SERDES_CFG_7_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_1r
#define MODIFY_SERDES_CFG_7_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e2
 * DESC:     Serdes Config Index 7 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_2r (0x001093e2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_2[1];
	uint32_t _serdes_cfg_7_2;
} BCMI_TSCD_XGXS_SERDES_CFG_7_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_2r_CLR(r) (r).serdes_cfg_7_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SET(r,d) (r).serdes_cfg_7_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_2r_GET(r) (r).serdes_cfg_7_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_2[0]=(((r).serdes_cfg_7_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_2r,(_r._serdes_cfg_7_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_2r,(_r._serdes_cfg_7_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_2r,(_r._serdes_cfg_7_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_2r BCMI_TSCD_XGXS_SERDES_CFG_7_2r
#define SERDES_CFG_7_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_2r_t SERDES_CFG_7_2r_t;
#define SERDES_CFG_7_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_2r_CLR
#define SERDES_CFG_7_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SET
#define SERDES_CFG_7_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_2r_GET
#define SERDES_CFG_7_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SPEED_CFGf_GET
#define SERDES_CFG_7_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_2r
#define WRITE_SERDES_CFG_7_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_2r
#define MODIFY_SERDES_CFG_7_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e3
 * DESC:     Serdes Config Index 7 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_3r (0x001093e3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_3[1];
	uint32_t _serdes_cfg_7_3;
} BCMI_TSCD_XGXS_SERDES_CFG_7_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_3r_CLR(r) (r).serdes_cfg_7_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SET(r,d) (r).serdes_cfg_7_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_3r_GET(r) (r).serdes_cfg_7_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_3[0]=(((r).serdes_cfg_7_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_3r,(_r._serdes_cfg_7_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_3r,(_r._serdes_cfg_7_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_3r,(_r._serdes_cfg_7_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_3r BCMI_TSCD_XGXS_SERDES_CFG_7_3r
#define SERDES_CFG_7_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_3r_t SERDES_CFG_7_3r_t;
#define SERDES_CFG_7_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_3r_CLR
#define SERDES_CFG_7_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SET
#define SERDES_CFG_7_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_3r_GET
#define SERDES_CFG_7_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SPEED_CFGf_GET
#define SERDES_CFG_7_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_3r
#define WRITE_SERDES_CFG_7_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_3r
#define MODIFY_SERDES_CFG_7_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e4
 * DESC:     Serdes Config Index 7 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_4r (0x001093e4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_4[1];
	uint32_t _serdes_cfg_7_4;
} BCMI_TSCD_XGXS_SERDES_CFG_7_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_4r_CLR(r) (r).serdes_cfg_7_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SET(r,d) (r).serdes_cfg_7_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_4r_GET(r) (r).serdes_cfg_7_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_4[0]=(((r).serdes_cfg_7_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_4r,(_r._serdes_cfg_7_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_4r,(_r._serdes_cfg_7_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_4r,(_r._serdes_cfg_7_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_4r BCMI_TSCD_XGXS_SERDES_CFG_7_4r
#define SERDES_CFG_7_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_4r_t SERDES_CFG_7_4r_t;
#define SERDES_CFG_7_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_4r_CLR
#define SERDES_CFG_7_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SET
#define SERDES_CFG_7_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_4r_GET
#define SERDES_CFG_7_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SPEED_CFGf_GET
#define SERDES_CFG_7_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_4r
#define WRITE_SERDES_CFG_7_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_4r
#define MODIFY_SERDES_CFG_7_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e5
 * DESC:     Serdes Config Index 7 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_5r (0x001093e5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_5[1];
	uint32_t _serdes_cfg_7_5;
} BCMI_TSCD_XGXS_SERDES_CFG_7_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_5r_CLR(r) (r).serdes_cfg_7_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SET(r,d) (r).serdes_cfg_7_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_5r_GET(r) (r).serdes_cfg_7_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_5[0]=(((r).serdes_cfg_7_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_5r,(_r._serdes_cfg_7_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_5r,(_r._serdes_cfg_7_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_5r,(_r._serdes_cfg_7_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_5r BCMI_TSCD_XGXS_SERDES_CFG_7_5r
#define SERDES_CFG_7_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_5r_t SERDES_CFG_7_5r_t;
#define SERDES_CFG_7_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_5r_CLR
#define SERDES_CFG_7_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SET
#define SERDES_CFG_7_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_5r_GET
#define SERDES_CFG_7_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SPEED_CFGf_GET
#define SERDES_CFG_7_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_5r
#define WRITE_SERDES_CFG_7_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_5r
#define MODIFY_SERDES_CFG_7_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e6
 * DESC:     Serdes Config Index 7 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_6r (0x001093e6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_6[1];
	uint32_t _serdes_cfg_7_6;
} BCMI_TSCD_XGXS_SERDES_CFG_7_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_6r_CLR(r) (r).serdes_cfg_7_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SET(r,d) (r).serdes_cfg_7_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_6r_GET(r) (r).serdes_cfg_7_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_6[0]=(((r).serdes_cfg_7_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_6r,(_r._serdes_cfg_7_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_6r,(_r._serdes_cfg_7_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_6r,(_r._serdes_cfg_7_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_6r BCMI_TSCD_XGXS_SERDES_CFG_7_6r
#define SERDES_CFG_7_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_6r_t SERDES_CFG_7_6r_t;
#define SERDES_CFG_7_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_6r_CLR
#define SERDES_CFG_7_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SET
#define SERDES_CFG_7_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_6r_GET
#define SERDES_CFG_7_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SPEED_CFGf_GET
#define SERDES_CFG_7_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_6r
#define WRITE_SERDES_CFG_7_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_6r
#define MODIFY_SERDES_CFG_7_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e7
 * DESC:     Serdes Config Index 7 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_7r (0x001093e7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_7[1];
	uint32_t _serdes_cfg_7_7;
} BCMI_TSCD_XGXS_SERDES_CFG_7_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_7r_CLR(r) (r).serdes_cfg_7_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SET(r,d) (r).serdes_cfg_7_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_7r_GET(r) (r).serdes_cfg_7_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_7[0]=(((r).serdes_cfg_7_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_7r,(_r._serdes_cfg_7_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_7r,(_r._serdes_cfg_7_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_7r,(_r._serdes_cfg_7_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_7r BCMI_TSCD_XGXS_SERDES_CFG_7_7r
#define SERDES_CFG_7_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_7r_t SERDES_CFG_7_7r_t;
#define SERDES_CFG_7_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_7r_CLR
#define SERDES_CFG_7_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SET
#define SERDES_CFG_7_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_7r_GET
#define SERDES_CFG_7_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SPEED_CFGf_GET
#define SERDES_CFG_7_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_7r
#define WRITE_SERDES_CFG_7_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_7r
#define MODIFY_SERDES_CFG_7_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e8
 * DESC:     Serdes Config Index 7 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_8r (0x001093e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_8[1];
	uint32_t _serdes_cfg_7_8;
} BCMI_TSCD_XGXS_SERDES_CFG_7_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_8r_CLR(r) (r).serdes_cfg_7_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SET(r,d) (r).serdes_cfg_7_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_8r_GET(r) (r).serdes_cfg_7_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_8[0]=(((r).serdes_cfg_7_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_8r,(_r._serdes_cfg_7_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_8r,(_r._serdes_cfg_7_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_8r,(_r._serdes_cfg_7_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_8r BCMI_TSCD_XGXS_SERDES_CFG_7_8r
#define SERDES_CFG_7_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_8r_t SERDES_CFG_7_8r_t;
#define SERDES_CFG_7_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_8r_CLR
#define SERDES_CFG_7_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SET
#define SERDES_CFG_7_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_8r_GET
#define SERDES_CFG_7_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SPEED_CFGf_GET
#define SERDES_CFG_7_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_8r
#define WRITE_SERDES_CFG_7_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_8r
#define MODIFY_SERDES_CFG_7_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93e9
 * DESC:     Serdes Config Index 7 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_9r (0x001093e9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_9[1];
	uint32_t _serdes_cfg_7_9;
} BCMI_TSCD_XGXS_SERDES_CFG_7_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_9r_CLR(r) (r).serdes_cfg_7_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SET(r,d) (r).serdes_cfg_7_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_9r_GET(r) (r).serdes_cfg_7_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_9[0]=(((r).serdes_cfg_7_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_9r,(_r._serdes_cfg_7_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_9r,(_r._serdes_cfg_7_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_9r,(_r._serdes_cfg_7_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_9r BCMI_TSCD_XGXS_SERDES_CFG_7_9r
#define SERDES_CFG_7_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_9r_t SERDES_CFG_7_9r_t;
#define SERDES_CFG_7_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_9r_CLR
#define SERDES_CFG_7_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SET
#define SERDES_CFG_7_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_9r_GET
#define SERDES_CFG_7_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SPEED_CFGf_GET
#define SERDES_CFG_7_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_9r
#define WRITE_SERDES_CFG_7_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_9r
#define MODIFY_SERDES_CFG_7_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ea
 * DESC:     Serdes Config Index 7 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_10r (0x001093ea | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_10[1];
	uint32_t _serdes_cfg_7_10;
} BCMI_TSCD_XGXS_SERDES_CFG_7_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_10r_CLR(r) (r).serdes_cfg_7_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SET(r,d) (r).serdes_cfg_7_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_10r_GET(r) (r).serdes_cfg_7_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_10[0]=(((r).serdes_cfg_7_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_10r,(_r._serdes_cfg_7_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_10r,(_r._serdes_cfg_7_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_10r,(_r._serdes_cfg_7_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_10r BCMI_TSCD_XGXS_SERDES_CFG_7_10r
#define SERDES_CFG_7_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_10r_t SERDES_CFG_7_10r_t;
#define SERDES_CFG_7_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_10r_CLR
#define SERDES_CFG_7_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SET
#define SERDES_CFG_7_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_10r_GET
#define SERDES_CFG_7_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SPEED_CFGf_GET
#define SERDES_CFG_7_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_10r
#define WRITE_SERDES_CFG_7_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_10r
#define MODIFY_SERDES_CFG_7_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93eb
 * DESC:     Serdes Config Index 7 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_11r (0x001093eb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_11[1];
	uint32_t _serdes_cfg_7_11;
} BCMI_TSCD_XGXS_SERDES_CFG_7_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_11r_CLR(r) (r).serdes_cfg_7_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SET(r,d) (r).serdes_cfg_7_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_11r_GET(r) (r).serdes_cfg_7_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_11[0]=(((r).serdes_cfg_7_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_11r,(_r._serdes_cfg_7_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_11r,(_r._serdes_cfg_7_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_11r,(_r._serdes_cfg_7_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_11r BCMI_TSCD_XGXS_SERDES_CFG_7_11r
#define SERDES_CFG_7_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_11r_t SERDES_CFG_7_11r_t;
#define SERDES_CFG_7_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_11r_CLR
#define SERDES_CFG_7_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SET
#define SERDES_CFG_7_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_11r_GET
#define SERDES_CFG_7_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SPEED_CFGf_GET
#define SERDES_CFG_7_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_11r
#define WRITE_SERDES_CFG_7_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_11r
#define MODIFY_SERDES_CFG_7_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ec
 * DESC:     Serdes Config Index 7 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_12r (0x001093ec | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_12[1];
	uint32_t _serdes_cfg_7_12;
} BCMI_TSCD_XGXS_SERDES_CFG_7_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_12r_CLR(r) (r).serdes_cfg_7_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SET(r,d) (r).serdes_cfg_7_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_12r_GET(r) (r).serdes_cfg_7_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_12[0]=(((r).serdes_cfg_7_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_12r,(_r._serdes_cfg_7_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_12r,(_r._serdes_cfg_7_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_12r,(_r._serdes_cfg_7_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_12r BCMI_TSCD_XGXS_SERDES_CFG_7_12r
#define SERDES_CFG_7_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_12r_t SERDES_CFG_7_12r_t;
#define SERDES_CFG_7_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_12r_CLR
#define SERDES_CFG_7_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SET
#define SERDES_CFG_7_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_12r_GET
#define SERDES_CFG_7_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SPEED_CFGf_GET
#define SERDES_CFG_7_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_12r
#define WRITE_SERDES_CFG_7_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_12r
#define MODIFY_SERDES_CFG_7_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ed
 * DESC:     Serdes Config Index 7 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_13r (0x001093ed | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_13[1];
	uint32_t _serdes_cfg_7_13;
} BCMI_TSCD_XGXS_SERDES_CFG_7_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_13r_CLR(r) (r).serdes_cfg_7_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SET(r,d) (r).serdes_cfg_7_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_13r_GET(r) (r).serdes_cfg_7_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_13[0]=(((r).serdes_cfg_7_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_13r,(_r._serdes_cfg_7_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_13r,(_r._serdes_cfg_7_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_13r,(_r._serdes_cfg_7_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_13r BCMI_TSCD_XGXS_SERDES_CFG_7_13r
#define SERDES_CFG_7_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_13r_t SERDES_CFG_7_13r_t;
#define SERDES_CFG_7_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_13r_CLR
#define SERDES_CFG_7_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SET
#define SERDES_CFG_7_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_13r_GET
#define SERDES_CFG_7_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SPEED_CFGf_GET
#define SERDES_CFG_7_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_13r
#define WRITE_SERDES_CFG_7_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_13r
#define MODIFY_SERDES_CFG_7_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ee
 * DESC:     Serdes Config Index 7 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_14r (0x001093ee | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_14[1];
	uint32_t _serdes_cfg_7_14;
} BCMI_TSCD_XGXS_SERDES_CFG_7_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_14r_CLR(r) (r).serdes_cfg_7_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SET(r,d) (r).serdes_cfg_7_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_14r_GET(r) (r).serdes_cfg_7_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_14[0]=(((r).serdes_cfg_7_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_14r,(_r._serdes_cfg_7_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_14r,(_r._serdes_cfg_7_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_14r,(_r._serdes_cfg_7_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_14r BCMI_TSCD_XGXS_SERDES_CFG_7_14r
#define SERDES_CFG_7_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_14r_t SERDES_CFG_7_14r_t;
#define SERDES_CFG_7_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_14r_CLR
#define SERDES_CFG_7_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SET
#define SERDES_CFG_7_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_14r_GET
#define SERDES_CFG_7_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SPEED_CFGf_GET
#define SERDES_CFG_7_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_14r
#define WRITE_SERDES_CFG_7_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_14r
#define MODIFY_SERDES_CFG_7_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93ef
 * DESC:     Serdes Config Index 7 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_15r (0x001093ef | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_15[1];
	uint32_t _serdes_cfg_7_15;
} BCMI_TSCD_XGXS_SERDES_CFG_7_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_15r_CLR(r) (r).serdes_cfg_7_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SET(r,d) (r).serdes_cfg_7_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_15r_GET(r) (r).serdes_cfg_7_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_15[0]=(((r).serdes_cfg_7_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_15r,(_r._serdes_cfg_7_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_15r,(_r._serdes_cfg_7_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_15r,(_r._serdes_cfg_7_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_15r BCMI_TSCD_XGXS_SERDES_CFG_7_15r
#define SERDES_CFG_7_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_15r_t SERDES_CFG_7_15r_t;
#define SERDES_CFG_7_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_15r_CLR
#define SERDES_CFG_7_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SET
#define SERDES_CFG_7_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_15r_GET
#define SERDES_CFG_7_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SPEED_CFGf_GET
#define SERDES_CFG_7_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_15r
#define WRITE_SERDES_CFG_7_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_15r
#define MODIFY_SERDES_CFG_7_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f0
 * DESC:     Serdes Config Index 7 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_16r (0x001093f0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_16[1];
	uint32_t _serdes_cfg_7_16;
} BCMI_TSCD_XGXS_SERDES_CFG_7_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_16r_CLR(r) (r).serdes_cfg_7_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SET(r,d) (r).serdes_cfg_7_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_16r_GET(r) (r).serdes_cfg_7_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_16[0]=(((r).serdes_cfg_7_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_16r,(_r._serdes_cfg_7_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_16r,(_r._serdes_cfg_7_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_16r,(_r._serdes_cfg_7_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_16r BCMI_TSCD_XGXS_SERDES_CFG_7_16r
#define SERDES_CFG_7_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_16r_t SERDES_CFG_7_16r_t;
#define SERDES_CFG_7_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_16r_CLR
#define SERDES_CFG_7_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SET
#define SERDES_CFG_7_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_16r_GET
#define SERDES_CFG_7_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SPEED_CFGf_GET
#define SERDES_CFG_7_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_16r
#define WRITE_SERDES_CFG_7_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_16r
#define MODIFY_SERDES_CFG_7_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f1
 * DESC:     Serdes Config Index 7 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_17r (0x001093f1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_17[1];
	uint32_t _serdes_cfg_7_17;
} BCMI_TSCD_XGXS_SERDES_CFG_7_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_17r_CLR(r) (r).serdes_cfg_7_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SET(r,d) (r).serdes_cfg_7_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_17r_GET(r) (r).serdes_cfg_7_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_17[0]=(((r).serdes_cfg_7_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_17r,(_r._serdes_cfg_7_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_17r,(_r._serdes_cfg_7_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_17r,(_r._serdes_cfg_7_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_17r BCMI_TSCD_XGXS_SERDES_CFG_7_17r
#define SERDES_CFG_7_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_17r_t SERDES_CFG_7_17r_t;
#define SERDES_CFG_7_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_17r_CLR
#define SERDES_CFG_7_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SET
#define SERDES_CFG_7_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_17r_GET
#define SERDES_CFG_7_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SPEED_CFGf_GET
#define SERDES_CFG_7_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_17r
#define WRITE_SERDES_CFG_7_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_17r
#define MODIFY_SERDES_CFG_7_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f2
 * DESC:     Serdes Config Index 7 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_18r (0x001093f2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_18[1];
	uint32_t _serdes_cfg_7_18;
} BCMI_TSCD_XGXS_SERDES_CFG_7_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_18r_CLR(r) (r).serdes_cfg_7_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SET(r,d) (r).serdes_cfg_7_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_18r_GET(r) (r).serdes_cfg_7_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_18[0]=(((r).serdes_cfg_7_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_18r,(_r._serdes_cfg_7_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_18r,(_r._serdes_cfg_7_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_18r,(_r._serdes_cfg_7_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_18r BCMI_TSCD_XGXS_SERDES_CFG_7_18r
#define SERDES_CFG_7_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_18r_t SERDES_CFG_7_18r_t;
#define SERDES_CFG_7_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_18r_CLR
#define SERDES_CFG_7_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SET
#define SERDES_CFG_7_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_18r_GET
#define SERDES_CFG_7_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SPEED_CFGf_GET
#define SERDES_CFG_7_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_18r
#define WRITE_SERDES_CFG_7_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_18r
#define MODIFY_SERDES_CFG_7_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f3
 * DESC:     Serdes Config Index 7 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_19r (0x001093f3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_19[1];
	uint32_t _serdes_cfg_7_19;
} BCMI_TSCD_XGXS_SERDES_CFG_7_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_19r_CLR(r) (r).serdes_cfg_7_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SET(r,d) (r).serdes_cfg_7_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_19r_GET(r) (r).serdes_cfg_7_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_19[0]=(((r).serdes_cfg_7_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_19r,(_r._serdes_cfg_7_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_19r,(_r._serdes_cfg_7_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_19r,(_r._serdes_cfg_7_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_19r BCMI_TSCD_XGXS_SERDES_CFG_7_19r
#define SERDES_CFG_7_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_19r_t SERDES_CFG_7_19r_t;
#define SERDES_CFG_7_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_19r_CLR
#define SERDES_CFG_7_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SET
#define SERDES_CFG_7_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_19r_GET
#define SERDES_CFG_7_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SPEED_CFGf_GET
#define SERDES_CFG_7_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_19r
#define WRITE_SERDES_CFG_7_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_19r
#define MODIFY_SERDES_CFG_7_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f4
 * DESC:     Serdes Config Index 7 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_20r (0x001093f4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_20[1];
	uint32_t _serdes_cfg_7_20;
} BCMI_TSCD_XGXS_SERDES_CFG_7_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_20r_CLR(r) (r).serdes_cfg_7_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SET(r,d) (r).serdes_cfg_7_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_20r_GET(r) (r).serdes_cfg_7_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_7_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_7_20[0]=(((r).serdes_cfg_7_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_7_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_20r,(_r._serdes_cfg_7_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_20r,(_r._serdes_cfg_7_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_20r,(_r._serdes_cfg_7_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_20r BCMI_TSCD_XGXS_SERDES_CFG_7_20r
#define SERDES_CFG_7_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_20r_t SERDES_CFG_7_20r_t;
#define SERDES_CFG_7_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_20r_CLR
#define SERDES_CFG_7_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SET
#define SERDES_CFG_7_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_20r_GET
#define SERDES_CFG_7_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SPEED_CFGf_GET
#define SERDES_CFG_7_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_7_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_20r
#define WRITE_SERDES_CFG_7_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_20r
#define MODIFY_SERDES_CFG_7_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f5
 * DESC:     Serdes Config Index 7 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_21r (0x001093f5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_21[1];
	uint32_t _serdes_cfg_7_21;
} BCMI_TSCD_XGXS_SERDES_CFG_7_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_21r_CLR(r) (r).serdes_cfg_7_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_21r_SET(r,d) (r).serdes_cfg_7_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_21r_GET(r) (r).serdes_cfg_7_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_7_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_7_21[0]=(((r).serdes_cfg_7_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_7_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_21r,(_r._serdes_cfg_7_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_21r,(_r._serdes_cfg_7_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_21r,(_r._serdes_cfg_7_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_21r BCMI_TSCD_XGXS_SERDES_CFG_7_21r
#define SERDES_CFG_7_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_21r_t SERDES_CFG_7_21r_t;
#define SERDES_CFG_7_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_21r_CLR
#define SERDES_CFG_7_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_21r_SET
#define SERDES_CFG_7_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_21r_GET
#define SERDES_CFG_7_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_21r_FCLK_PERIODf_GET
#define SERDES_CFG_7_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_7_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_21r
#define WRITE_SERDES_CFG_7_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_21r
#define MODIFY_SERDES_CFG_7_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f6
 * DESC:     Serdes Config Index 7 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r (0x001093f6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_22[1];
	uint32_t _serdes_cfg_7_22;
} BCMI_TSCD_XGXS_SERDES_CFG_7_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_CLR(r) (r).serdes_cfg_7_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SET(r,d) (r).serdes_cfg_7_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_GET(r) (r).serdes_cfg_7_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SPAREf_GET(r) ((((r).serdes_cfg_7_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SPAREf_SET(r,f) (r).serdes_cfg_7_22[0]=(((r).serdes_cfg_7_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_7_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_7_22[0]=(((r).serdes_cfg_7_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_7_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_22r,(_r._serdes_cfg_7_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_22r,(_r._serdes_cfg_7_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_22r,(_r._serdes_cfg_7_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_22r BCMI_TSCD_XGXS_SERDES_CFG_7_22r
#define SERDES_CFG_7_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_22r_t SERDES_CFG_7_22r_t;
#define SERDES_CFG_7_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_22r_CLR
#define SERDES_CFG_7_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SET
#define SERDES_CFG_7_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_22r_GET
#define SERDES_CFG_7_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SPAREf_GET
#define SERDES_CFG_7_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_22r_SPAREf_SET
#define SERDES_CFG_7_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_22r_RX_LOSVREFf_GET
#define SERDES_CFG_7_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_7_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_22r
#define WRITE_SERDES_CFG_7_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_22r
#define MODIFY_SERDES_CFG_7_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_7_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x93f7
 * DESC:     Serdes Config Index 7 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r (0x001093f7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_7_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_7_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_7_23[1];
	uint32_t _serdes_cfg_7_23;
} BCMI_TSCD_XGXS_SERDES_CFG_7_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_CLR(r) (r).serdes_cfg_7_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_SET(r,d) (r).serdes_cfg_7_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_GET(r) (r).serdes_cfg_7_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_7_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_7_23[0]=(((r).serdes_cfg_7_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_7_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_7_23[0]=(((r).serdes_cfg_7_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_7_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_7_23[0]=(((r).serdes_cfg_7_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_RATESELf_GET(r) ((((r).serdes_cfg_7_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_RATESELf_SET(r,f) (r).serdes_cfg_7_23[0]=(((r).serdes_cfg_7_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_7_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_7_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_7_23[0]=(((r).serdes_cfg_7_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_7_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_7_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_23r,(_r._serdes_cfg_7_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_23r,(_r._serdes_cfg_7_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_7_23r,(_r._serdes_cfg_7_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_7_23r BCMI_TSCD_XGXS_SERDES_CFG_7_23r
#define SERDES_CFG_7_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_7_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_7_23r_t SERDES_CFG_7_23r_t;
#define SERDES_CFG_7_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_7_23r_CLR
#define SERDES_CFG_7_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_SET
#define SERDES_CFG_7_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_GET
#define SERDES_CFG_7_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_7_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_7_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODEf_GET
#define SERDES_CFG_7_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_TRAINING_MODEf_SET
#define SERDES_CFG_7_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_WORDMODEf_GET
#define SERDES_CFG_7_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_WORDMODEf_SET
#define SERDES_CFG_7_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_RATESELf_GET
#define SERDES_CFG_7_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_RATESELf_SET
#define SERDES_CFG_7_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_7_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_7_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_7_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_7_23r
#define WRITE_SERDES_CFG_7_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_7_23r
#define MODIFY_SERDES_CFG_7_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_7_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_7_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9400
 * DESC:     Serdes Config Index 8 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_0r (0x00109400 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_0[1];
	uint32_t _serdes_cfg_8_0;
} BCMI_TSCD_XGXS_SERDES_CFG_8_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_0r_CLR(r) (r).serdes_cfg_8_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SET(r,d) (r).serdes_cfg_8_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_0r_GET(r) (r).serdes_cfg_8_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_0[0]=(((r).serdes_cfg_8_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_0r,(_r._serdes_cfg_8_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_0r,(_r._serdes_cfg_8_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_0r,(_r._serdes_cfg_8_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_0r BCMI_TSCD_XGXS_SERDES_CFG_8_0r
#define SERDES_CFG_8_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_0r_t SERDES_CFG_8_0r_t;
#define SERDES_CFG_8_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_0r_CLR
#define SERDES_CFG_8_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SET
#define SERDES_CFG_8_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_0r_GET
#define SERDES_CFG_8_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SPEED_CFGf_GET
#define SERDES_CFG_8_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_0r
#define WRITE_SERDES_CFG_8_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_0r
#define MODIFY_SERDES_CFG_8_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9401
 * DESC:     Serdes Config Index 8 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_1r (0x00109401 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_1[1];
	uint32_t _serdes_cfg_8_1;
} BCMI_TSCD_XGXS_SERDES_CFG_8_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_1r_CLR(r) (r).serdes_cfg_8_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SET(r,d) (r).serdes_cfg_8_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_1r_GET(r) (r).serdes_cfg_8_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_1[0]=(((r).serdes_cfg_8_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_1r,(_r._serdes_cfg_8_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_1r,(_r._serdes_cfg_8_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_1r,(_r._serdes_cfg_8_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_1r BCMI_TSCD_XGXS_SERDES_CFG_8_1r
#define SERDES_CFG_8_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_1r_t SERDES_CFG_8_1r_t;
#define SERDES_CFG_8_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_1r_CLR
#define SERDES_CFG_8_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SET
#define SERDES_CFG_8_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_1r_GET
#define SERDES_CFG_8_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SPEED_CFGf_GET
#define SERDES_CFG_8_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_1r
#define WRITE_SERDES_CFG_8_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_1r
#define MODIFY_SERDES_CFG_8_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9402
 * DESC:     Serdes Config Index 8 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_2r (0x00109402 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_2[1];
	uint32_t _serdes_cfg_8_2;
} BCMI_TSCD_XGXS_SERDES_CFG_8_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_2r_CLR(r) (r).serdes_cfg_8_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SET(r,d) (r).serdes_cfg_8_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_2r_GET(r) (r).serdes_cfg_8_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_2[0]=(((r).serdes_cfg_8_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_2r,(_r._serdes_cfg_8_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_2r,(_r._serdes_cfg_8_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_2r,(_r._serdes_cfg_8_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_2r BCMI_TSCD_XGXS_SERDES_CFG_8_2r
#define SERDES_CFG_8_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_2r_t SERDES_CFG_8_2r_t;
#define SERDES_CFG_8_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_2r_CLR
#define SERDES_CFG_8_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SET
#define SERDES_CFG_8_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_2r_GET
#define SERDES_CFG_8_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SPEED_CFGf_GET
#define SERDES_CFG_8_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_2r
#define WRITE_SERDES_CFG_8_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_2r
#define MODIFY_SERDES_CFG_8_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9403
 * DESC:     Serdes Config Index 8 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_3r (0x00109403 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_3[1];
	uint32_t _serdes_cfg_8_3;
} BCMI_TSCD_XGXS_SERDES_CFG_8_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_3r_CLR(r) (r).serdes_cfg_8_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SET(r,d) (r).serdes_cfg_8_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_3r_GET(r) (r).serdes_cfg_8_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_3[0]=(((r).serdes_cfg_8_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_3r,(_r._serdes_cfg_8_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_3r,(_r._serdes_cfg_8_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_3r,(_r._serdes_cfg_8_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_3r BCMI_TSCD_XGXS_SERDES_CFG_8_3r
#define SERDES_CFG_8_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_3r_t SERDES_CFG_8_3r_t;
#define SERDES_CFG_8_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_3r_CLR
#define SERDES_CFG_8_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SET
#define SERDES_CFG_8_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_3r_GET
#define SERDES_CFG_8_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SPEED_CFGf_GET
#define SERDES_CFG_8_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_3r
#define WRITE_SERDES_CFG_8_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_3r
#define MODIFY_SERDES_CFG_8_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9404
 * DESC:     Serdes Config Index 8 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_4r (0x00109404 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_4[1];
	uint32_t _serdes_cfg_8_4;
} BCMI_TSCD_XGXS_SERDES_CFG_8_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_4r_CLR(r) (r).serdes_cfg_8_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SET(r,d) (r).serdes_cfg_8_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_4r_GET(r) (r).serdes_cfg_8_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_4[0]=(((r).serdes_cfg_8_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_4r,(_r._serdes_cfg_8_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_4r,(_r._serdes_cfg_8_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_4r,(_r._serdes_cfg_8_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_4r BCMI_TSCD_XGXS_SERDES_CFG_8_4r
#define SERDES_CFG_8_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_4r_t SERDES_CFG_8_4r_t;
#define SERDES_CFG_8_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_4r_CLR
#define SERDES_CFG_8_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SET
#define SERDES_CFG_8_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_4r_GET
#define SERDES_CFG_8_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SPEED_CFGf_GET
#define SERDES_CFG_8_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_4r
#define WRITE_SERDES_CFG_8_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_4r
#define MODIFY_SERDES_CFG_8_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9405
 * DESC:     Serdes Config Index 8 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_5r (0x00109405 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_5[1];
	uint32_t _serdes_cfg_8_5;
} BCMI_TSCD_XGXS_SERDES_CFG_8_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_5r_CLR(r) (r).serdes_cfg_8_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SET(r,d) (r).serdes_cfg_8_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_5r_GET(r) (r).serdes_cfg_8_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_5[0]=(((r).serdes_cfg_8_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_5r,(_r._serdes_cfg_8_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_5r,(_r._serdes_cfg_8_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_5r,(_r._serdes_cfg_8_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_5r BCMI_TSCD_XGXS_SERDES_CFG_8_5r
#define SERDES_CFG_8_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_5r_t SERDES_CFG_8_5r_t;
#define SERDES_CFG_8_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_5r_CLR
#define SERDES_CFG_8_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SET
#define SERDES_CFG_8_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_5r_GET
#define SERDES_CFG_8_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SPEED_CFGf_GET
#define SERDES_CFG_8_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_5r
#define WRITE_SERDES_CFG_8_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_5r
#define MODIFY_SERDES_CFG_8_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9406
 * DESC:     Serdes Config Index 8 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_6r (0x00109406 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_6[1];
	uint32_t _serdes_cfg_8_6;
} BCMI_TSCD_XGXS_SERDES_CFG_8_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_6r_CLR(r) (r).serdes_cfg_8_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SET(r,d) (r).serdes_cfg_8_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_6r_GET(r) (r).serdes_cfg_8_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_6[0]=(((r).serdes_cfg_8_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_6r,(_r._serdes_cfg_8_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_6r,(_r._serdes_cfg_8_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_6r,(_r._serdes_cfg_8_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_6r BCMI_TSCD_XGXS_SERDES_CFG_8_6r
#define SERDES_CFG_8_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_6r_t SERDES_CFG_8_6r_t;
#define SERDES_CFG_8_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_6r_CLR
#define SERDES_CFG_8_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SET
#define SERDES_CFG_8_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_6r_GET
#define SERDES_CFG_8_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SPEED_CFGf_GET
#define SERDES_CFG_8_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_6r
#define WRITE_SERDES_CFG_8_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_6r
#define MODIFY_SERDES_CFG_8_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9407
 * DESC:     Serdes Config Index 8 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_7r (0x00109407 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_7[1];
	uint32_t _serdes_cfg_8_7;
} BCMI_TSCD_XGXS_SERDES_CFG_8_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_7r_CLR(r) (r).serdes_cfg_8_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SET(r,d) (r).serdes_cfg_8_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_7r_GET(r) (r).serdes_cfg_8_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_7[0]=(((r).serdes_cfg_8_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_7r,(_r._serdes_cfg_8_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_7r,(_r._serdes_cfg_8_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_7r,(_r._serdes_cfg_8_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_7r BCMI_TSCD_XGXS_SERDES_CFG_8_7r
#define SERDES_CFG_8_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_7r_t SERDES_CFG_8_7r_t;
#define SERDES_CFG_8_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_7r_CLR
#define SERDES_CFG_8_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SET
#define SERDES_CFG_8_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_7r_GET
#define SERDES_CFG_8_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SPEED_CFGf_GET
#define SERDES_CFG_8_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_7r
#define WRITE_SERDES_CFG_8_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_7r
#define MODIFY_SERDES_CFG_8_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9408
 * DESC:     Serdes Config Index 8 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_8r (0x00109408 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_8[1];
	uint32_t _serdes_cfg_8_8;
} BCMI_TSCD_XGXS_SERDES_CFG_8_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_8r_CLR(r) (r).serdes_cfg_8_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SET(r,d) (r).serdes_cfg_8_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_8r_GET(r) (r).serdes_cfg_8_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_8[0]=(((r).serdes_cfg_8_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_8r,(_r._serdes_cfg_8_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_8r,(_r._serdes_cfg_8_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_8r,(_r._serdes_cfg_8_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_8r BCMI_TSCD_XGXS_SERDES_CFG_8_8r
#define SERDES_CFG_8_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_8r_t SERDES_CFG_8_8r_t;
#define SERDES_CFG_8_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_8r_CLR
#define SERDES_CFG_8_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SET
#define SERDES_CFG_8_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_8r_GET
#define SERDES_CFG_8_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SPEED_CFGf_GET
#define SERDES_CFG_8_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_8r
#define WRITE_SERDES_CFG_8_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_8r
#define MODIFY_SERDES_CFG_8_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9409
 * DESC:     Serdes Config Index 8 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_9r (0x00109409 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_9[1];
	uint32_t _serdes_cfg_8_9;
} BCMI_TSCD_XGXS_SERDES_CFG_8_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_9r_CLR(r) (r).serdes_cfg_8_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SET(r,d) (r).serdes_cfg_8_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_9r_GET(r) (r).serdes_cfg_8_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_9[0]=(((r).serdes_cfg_8_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_9r,(_r._serdes_cfg_8_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_9r,(_r._serdes_cfg_8_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_9r,(_r._serdes_cfg_8_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_9r BCMI_TSCD_XGXS_SERDES_CFG_8_9r
#define SERDES_CFG_8_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_9r_t SERDES_CFG_8_9r_t;
#define SERDES_CFG_8_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_9r_CLR
#define SERDES_CFG_8_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SET
#define SERDES_CFG_8_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_9r_GET
#define SERDES_CFG_8_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SPEED_CFGf_GET
#define SERDES_CFG_8_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_9r
#define WRITE_SERDES_CFG_8_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_9r
#define MODIFY_SERDES_CFG_8_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x940a
 * DESC:     Serdes Config Index 8 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_10r (0x0010940a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_10[1];
	uint32_t _serdes_cfg_8_10;
} BCMI_TSCD_XGXS_SERDES_CFG_8_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_10r_CLR(r) (r).serdes_cfg_8_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SET(r,d) (r).serdes_cfg_8_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_10r_GET(r) (r).serdes_cfg_8_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_10[0]=(((r).serdes_cfg_8_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_10r,(_r._serdes_cfg_8_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_10r,(_r._serdes_cfg_8_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_10r,(_r._serdes_cfg_8_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_10r BCMI_TSCD_XGXS_SERDES_CFG_8_10r
#define SERDES_CFG_8_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_10r_t SERDES_CFG_8_10r_t;
#define SERDES_CFG_8_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_10r_CLR
#define SERDES_CFG_8_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SET
#define SERDES_CFG_8_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_10r_GET
#define SERDES_CFG_8_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SPEED_CFGf_GET
#define SERDES_CFG_8_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_10r
#define WRITE_SERDES_CFG_8_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_10r
#define MODIFY_SERDES_CFG_8_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x940b
 * DESC:     Serdes Config Index 8 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_11r (0x0010940b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_11[1];
	uint32_t _serdes_cfg_8_11;
} BCMI_TSCD_XGXS_SERDES_CFG_8_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_11r_CLR(r) (r).serdes_cfg_8_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SET(r,d) (r).serdes_cfg_8_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_11r_GET(r) (r).serdes_cfg_8_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_11[0]=(((r).serdes_cfg_8_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_11r,(_r._serdes_cfg_8_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_11r,(_r._serdes_cfg_8_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_11r,(_r._serdes_cfg_8_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_11r BCMI_TSCD_XGXS_SERDES_CFG_8_11r
#define SERDES_CFG_8_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_11r_t SERDES_CFG_8_11r_t;
#define SERDES_CFG_8_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_11r_CLR
#define SERDES_CFG_8_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SET
#define SERDES_CFG_8_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_11r_GET
#define SERDES_CFG_8_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SPEED_CFGf_GET
#define SERDES_CFG_8_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_11r
#define WRITE_SERDES_CFG_8_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_11r
#define MODIFY_SERDES_CFG_8_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x940c
 * DESC:     Serdes Config Index 8 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_12r (0x0010940c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_12[1];
	uint32_t _serdes_cfg_8_12;
} BCMI_TSCD_XGXS_SERDES_CFG_8_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_12r_CLR(r) (r).serdes_cfg_8_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SET(r,d) (r).serdes_cfg_8_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_12r_GET(r) (r).serdes_cfg_8_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_12[0]=(((r).serdes_cfg_8_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_12r,(_r._serdes_cfg_8_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_12r,(_r._serdes_cfg_8_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_12r,(_r._serdes_cfg_8_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_12r BCMI_TSCD_XGXS_SERDES_CFG_8_12r
#define SERDES_CFG_8_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_12r_t SERDES_CFG_8_12r_t;
#define SERDES_CFG_8_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_12r_CLR
#define SERDES_CFG_8_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SET
#define SERDES_CFG_8_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_12r_GET
#define SERDES_CFG_8_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SPEED_CFGf_GET
#define SERDES_CFG_8_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_12r
#define WRITE_SERDES_CFG_8_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_12r
#define MODIFY_SERDES_CFG_8_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x940d
 * DESC:     Serdes Config Index 8 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_13r (0x0010940d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_13[1];
	uint32_t _serdes_cfg_8_13;
} BCMI_TSCD_XGXS_SERDES_CFG_8_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_13r_CLR(r) (r).serdes_cfg_8_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SET(r,d) (r).serdes_cfg_8_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_13r_GET(r) (r).serdes_cfg_8_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_13[0]=(((r).serdes_cfg_8_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_13r,(_r._serdes_cfg_8_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_13r,(_r._serdes_cfg_8_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_13r,(_r._serdes_cfg_8_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_13r BCMI_TSCD_XGXS_SERDES_CFG_8_13r
#define SERDES_CFG_8_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_13r_t SERDES_CFG_8_13r_t;
#define SERDES_CFG_8_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_13r_CLR
#define SERDES_CFG_8_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SET
#define SERDES_CFG_8_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_13r_GET
#define SERDES_CFG_8_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SPEED_CFGf_GET
#define SERDES_CFG_8_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_13r
#define WRITE_SERDES_CFG_8_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_13r
#define MODIFY_SERDES_CFG_8_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x940e
 * DESC:     Serdes Config Index 8 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_14r (0x0010940e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_14[1];
	uint32_t _serdes_cfg_8_14;
} BCMI_TSCD_XGXS_SERDES_CFG_8_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_14r_CLR(r) (r).serdes_cfg_8_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SET(r,d) (r).serdes_cfg_8_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_14r_GET(r) (r).serdes_cfg_8_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_14[0]=(((r).serdes_cfg_8_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_14r,(_r._serdes_cfg_8_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_14r,(_r._serdes_cfg_8_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_14r,(_r._serdes_cfg_8_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_14r BCMI_TSCD_XGXS_SERDES_CFG_8_14r
#define SERDES_CFG_8_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_14r_t SERDES_CFG_8_14r_t;
#define SERDES_CFG_8_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_14r_CLR
#define SERDES_CFG_8_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SET
#define SERDES_CFG_8_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_14r_GET
#define SERDES_CFG_8_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SPEED_CFGf_GET
#define SERDES_CFG_8_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_14r
#define WRITE_SERDES_CFG_8_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_14r
#define MODIFY_SERDES_CFG_8_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x940f
 * DESC:     Serdes Config Index 8 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_15r (0x0010940f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_15[1];
	uint32_t _serdes_cfg_8_15;
} BCMI_TSCD_XGXS_SERDES_CFG_8_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_15r_CLR(r) (r).serdes_cfg_8_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SET(r,d) (r).serdes_cfg_8_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_15r_GET(r) (r).serdes_cfg_8_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_15[0]=(((r).serdes_cfg_8_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_15r,(_r._serdes_cfg_8_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_15r,(_r._serdes_cfg_8_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_15r,(_r._serdes_cfg_8_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_15r BCMI_TSCD_XGXS_SERDES_CFG_8_15r
#define SERDES_CFG_8_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_15r_t SERDES_CFG_8_15r_t;
#define SERDES_CFG_8_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_15r_CLR
#define SERDES_CFG_8_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SET
#define SERDES_CFG_8_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_15r_GET
#define SERDES_CFG_8_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SPEED_CFGf_GET
#define SERDES_CFG_8_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_15r
#define WRITE_SERDES_CFG_8_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_15r
#define MODIFY_SERDES_CFG_8_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9410
 * DESC:     Serdes Config Index 8 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_16r (0x00109410 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_16[1];
	uint32_t _serdes_cfg_8_16;
} BCMI_TSCD_XGXS_SERDES_CFG_8_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_16r_CLR(r) (r).serdes_cfg_8_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SET(r,d) (r).serdes_cfg_8_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_16r_GET(r) (r).serdes_cfg_8_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_16[0]=(((r).serdes_cfg_8_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_16r,(_r._serdes_cfg_8_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_16r,(_r._serdes_cfg_8_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_16r,(_r._serdes_cfg_8_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_16r BCMI_TSCD_XGXS_SERDES_CFG_8_16r
#define SERDES_CFG_8_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_16r_t SERDES_CFG_8_16r_t;
#define SERDES_CFG_8_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_16r_CLR
#define SERDES_CFG_8_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SET
#define SERDES_CFG_8_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_16r_GET
#define SERDES_CFG_8_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SPEED_CFGf_GET
#define SERDES_CFG_8_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_16r
#define WRITE_SERDES_CFG_8_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_16r
#define MODIFY_SERDES_CFG_8_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9411
 * DESC:     Serdes Config Index 8 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_17r (0x00109411 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_17[1];
	uint32_t _serdes_cfg_8_17;
} BCMI_TSCD_XGXS_SERDES_CFG_8_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_17r_CLR(r) (r).serdes_cfg_8_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SET(r,d) (r).serdes_cfg_8_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_17r_GET(r) (r).serdes_cfg_8_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_17[0]=(((r).serdes_cfg_8_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_17r,(_r._serdes_cfg_8_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_17r,(_r._serdes_cfg_8_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_17r,(_r._serdes_cfg_8_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_17r BCMI_TSCD_XGXS_SERDES_CFG_8_17r
#define SERDES_CFG_8_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_17r_t SERDES_CFG_8_17r_t;
#define SERDES_CFG_8_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_17r_CLR
#define SERDES_CFG_8_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SET
#define SERDES_CFG_8_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_17r_GET
#define SERDES_CFG_8_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SPEED_CFGf_GET
#define SERDES_CFG_8_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_17r
#define WRITE_SERDES_CFG_8_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_17r
#define MODIFY_SERDES_CFG_8_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9412
 * DESC:     Serdes Config Index 8 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_18r (0x00109412 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_18[1];
	uint32_t _serdes_cfg_8_18;
} BCMI_TSCD_XGXS_SERDES_CFG_8_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_18r_CLR(r) (r).serdes_cfg_8_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SET(r,d) (r).serdes_cfg_8_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_18r_GET(r) (r).serdes_cfg_8_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_18[0]=(((r).serdes_cfg_8_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_18r,(_r._serdes_cfg_8_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_18r,(_r._serdes_cfg_8_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_18r,(_r._serdes_cfg_8_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_18r BCMI_TSCD_XGXS_SERDES_CFG_8_18r
#define SERDES_CFG_8_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_18r_t SERDES_CFG_8_18r_t;
#define SERDES_CFG_8_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_18r_CLR
#define SERDES_CFG_8_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SET
#define SERDES_CFG_8_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_18r_GET
#define SERDES_CFG_8_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SPEED_CFGf_GET
#define SERDES_CFG_8_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_18r
#define WRITE_SERDES_CFG_8_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_18r
#define MODIFY_SERDES_CFG_8_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9413
 * DESC:     Serdes Config Index 8 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_19r (0x00109413 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_19[1];
	uint32_t _serdes_cfg_8_19;
} BCMI_TSCD_XGXS_SERDES_CFG_8_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_19r_CLR(r) (r).serdes_cfg_8_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SET(r,d) (r).serdes_cfg_8_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_19r_GET(r) (r).serdes_cfg_8_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_19[0]=(((r).serdes_cfg_8_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_19r,(_r._serdes_cfg_8_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_19r,(_r._serdes_cfg_8_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_19r,(_r._serdes_cfg_8_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_19r BCMI_TSCD_XGXS_SERDES_CFG_8_19r
#define SERDES_CFG_8_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_19r_t SERDES_CFG_8_19r_t;
#define SERDES_CFG_8_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_19r_CLR
#define SERDES_CFG_8_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SET
#define SERDES_CFG_8_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_19r_GET
#define SERDES_CFG_8_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SPEED_CFGf_GET
#define SERDES_CFG_8_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_19r
#define WRITE_SERDES_CFG_8_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_19r
#define MODIFY_SERDES_CFG_8_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9414
 * DESC:     Serdes Config Index 8 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_20r (0x00109414 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_20[1];
	uint32_t _serdes_cfg_8_20;
} BCMI_TSCD_XGXS_SERDES_CFG_8_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_20r_CLR(r) (r).serdes_cfg_8_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SET(r,d) (r).serdes_cfg_8_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_20r_GET(r) (r).serdes_cfg_8_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_8_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_8_20[0]=(((r).serdes_cfg_8_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_8_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_20r,(_r._serdes_cfg_8_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_20r,(_r._serdes_cfg_8_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_20r,(_r._serdes_cfg_8_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_20r BCMI_TSCD_XGXS_SERDES_CFG_8_20r
#define SERDES_CFG_8_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_20r_t SERDES_CFG_8_20r_t;
#define SERDES_CFG_8_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_20r_CLR
#define SERDES_CFG_8_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SET
#define SERDES_CFG_8_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_20r_GET
#define SERDES_CFG_8_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SPEED_CFGf_GET
#define SERDES_CFG_8_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_8_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_20r
#define WRITE_SERDES_CFG_8_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_20r
#define MODIFY_SERDES_CFG_8_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9415
 * DESC:     Serdes Config Index 8 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_21r (0x00109415 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_21[1];
	uint32_t _serdes_cfg_8_21;
} BCMI_TSCD_XGXS_SERDES_CFG_8_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_21r_CLR(r) (r).serdes_cfg_8_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_21r_SET(r,d) (r).serdes_cfg_8_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_21r_GET(r) (r).serdes_cfg_8_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_8_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_8_21[0]=(((r).serdes_cfg_8_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_8_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_21r,(_r._serdes_cfg_8_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_21r,(_r._serdes_cfg_8_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_21r,(_r._serdes_cfg_8_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_21r BCMI_TSCD_XGXS_SERDES_CFG_8_21r
#define SERDES_CFG_8_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_21r_t SERDES_CFG_8_21r_t;
#define SERDES_CFG_8_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_21r_CLR
#define SERDES_CFG_8_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_21r_SET
#define SERDES_CFG_8_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_21r_GET
#define SERDES_CFG_8_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_21r_FCLK_PERIODf_GET
#define SERDES_CFG_8_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_8_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_21r
#define WRITE_SERDES_CFG_8_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_21r
#define MODIFY_SERDES_CFG_8_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9416
 * DESC:     Serdes Config Index 8 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r (0x00109416 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_22[1];
	uint32_t _serdes_cfg_8_22;
} BCMI_TSCD_XGXS_SERDES_CFG_8_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_CLR(r) (r).serdes_cfg_8_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SET(r,d) (r).serdes_cfg_8_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_GET(r) (r).serdes_cfg_8_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SPAREf_GET(r) ((((r).serdes_cfg_8_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SPAREf_SET(r,f) (r).serdes_cfg_8_22[0]=(((r).serdes_cfg_8_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_8_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_8_22[0]=(((r).serdes_cfg_8_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_8_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_22r,(_r._serdes_cfg_8_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_22r,(_r._serdes_cfg_8_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_22r,(_r._serdes_cfg_8_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_22r BCMI_TSCD_XGXS_SERDES_CFG_8_22r
#define SERDES_CFG_8_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_22r_t SERDES_CFG_8_22r_t;
#define SERDES_CFG_8_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_22r_CLR
#define SERDES_CFG_8_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SET
#define SERDES_CFG_8_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_22r_GET
#define SERDES_CFG_8_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SPAREf_GET
#define SERDES_CFG_8_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_22r_SPAREf_SET
#define SERDES_CFG_8_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_22r_RX_LOSVREFf_GET
#define SERDES_CFG_8_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_8_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_22r
#define WRITE_SERDES_CFG_8_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_22r
#define MODIFY_SERDES_CFG_8_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_8_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9417
 * DESC:     Serdes Config Index 8 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r (0x00109417 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_8_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_8_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_8_23[1];
	uint32_t _serdes_cfg_8_23;
} BCMI_TSCD_XGXS_SERDES_CFG_8_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_CLR(r) (r).serdes_cfg_8_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_SET(r,d) (r).serdes_cfg_8_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_GET(r) (r).serdes_cfg_8_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_8_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_8_23[0]=(((r).serdes_cfg_8_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_8_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_8_23[0]=(((r).serdes_cfg_8_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_8_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_8_23[0]=(((r).serdes_cfg_8_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_RATESELf_GET(r) ((((r).serdes_cfg_8_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_RATESELf_SET(r,f) (r).serdes_cfg_8_23[0]=(((r).serdes_cfg_8_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_8_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_8_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_8_23[0]=(((r).serdes_cfg_8_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_8_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_8_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_23r,(_r._serdes_cfg_8_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_23r,(_r._serdes_cfg_8_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_8_23r,(_r._serdes_cfg_8_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_8_23r BCMI_TSCD_XGXS_SERDES_CFG_8_23r
#define SERDES_CFG_8_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_8_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_8_23r_t SERDES_CFG_8_23r_t;
#define SERDES_CFG_8_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_8_23r_CLR
#define SERDES_CFG_8_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_SET
#define SERDES_CFG_8_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_GET
#define SERDES_CFG_8_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_8_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_8_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODEf_GET
#define SERDES_CFG_8_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_TRAINING_MODEf_SET
#define SERDES_CFG_8_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_WORDMODEf_GET
#define SERDES_CFG_8_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_WORDMODEf_SET
#define SERDES_CFG_8_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_RATESELf_GET
#define SERDES_CFG_8_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_RATESELf_SET
#define SERDES_CFG_8_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_8_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_8_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_8_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_8_23r
#define WRITE_SERDES_CFG_8_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_8_23r
#define MODIFY_SERDES_CFG_8_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_8_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_8_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_0
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9420
 * DESC:     Serdes Config Index 9 offset 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 15:0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_0r (0x00109420 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_0.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_0r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_0[1];
	uint32_t _serdes_cfg_9_0;
} BCMI_TSCD_XGXS_SERDES_CFG_9_0r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_0r_CLR(r) (r).serdes_cfg_9_0[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SET(r,d) (r).serdes_cfg_9_0[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_0r_GET(r) (r).serdes_cfg_9_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_0[0]=(((r).serdes_cfg_9_0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_0r,(_r._serdes_cfg_9_0))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_0r,(_r._serdes_cfg_9_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_0r,(_r._serdes_cfg_9_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_0r BCMI_TSCD_XGXS_SERDES_CFG_9_0r
#define SERDES_CFG_9_0r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_0r_t SERDES_CFG_9_0r_t;
#define SERDES_CFG_9_0r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_0r_CLR
#define SERDES_CFG_9_0r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SET
#define SERDES_CFG_9_0r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_0r_GET
#define SERDES_CFG_9_0r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SPEED_CFGf_GET
#define SERDES_CFG_9_0r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_0r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_0r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_0r
#define WRITE_SERDES_CFG_9_0r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_0r
#define MODIFY_SERDES_CFG_9_0r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_1
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9421
 * DESC:     Serdes Config Index 9 offset 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 31:16
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_1r (0x00109421 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_1.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_1r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_1[1];
	uint32_t _serdes_cfg_9_1;
} BCMI_TSCD_XGXS_SERDES_CFG_9_1r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_1r_CLR(r) (r).serdes_cfg_9_1[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SET(r,d) (r).serdes_cfg_9_1[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_1r_GET(r) (r).serdes_cfg_9_1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_1[0]=(((r).serdes_cfg_9_1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_1r,(_r._serdes_cfg_9_1))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_1r,(_r._serdes_cfg_9_1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_1r,(_r._serdes_cfg_9_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_1r BCMI_TSCD_XGXS_SERDES_CFG_9_1r
#define SERDES_CFG_9_1r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_1r_t SERDES_CFG_9_1r_t;
#define SERDES_CFG_9_1r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_1r_CLR
#define SERDES_CFG_9_1r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SET
#define SERDES_CFG_9_1r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_1r_GET
#define SERDES_CFG_9_1r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SPEED_CFGf_GET
#define SERDES_CFG_9_1r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_1r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_1r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_1r
#define WRITE_SERDES_CFG_9_1r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_1r
#define MODIFY_SERDES_CFG_9_1r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_2
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9422
 * DESC:     Serdes Config Index 9 offset 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 47:32
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_2r (0x00109422 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_2.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_2r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_2[1];
	uint32_t _serdes_cfg_9_2;
} BCMI_TSCD_XGXS_SERDES_CFG_9_2r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_2r_CLR(r) (r).serdes_cfg_9_2[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SET(r,d) (r).serdes_cfg_9_2[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_2r_GET(r) (r).serdes_cfg_9_2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_2[0]=(((r).serdes_cfg_9_2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_2r,(_r._serdes_cfg_9_2))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_2r,(_r._serdes_cfg_9_2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_2r,(_r._serdes_cfg_9_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_2r BCMI_TSCD_XGXS_SERDES_CFG_9_2r
#define SERDES_CFG_9_2r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_2r_t SERDES_CFG_9_2r_t;
#define SERDES_CFG_9_2r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_2r_CLR
#define SERDES_CFG_9_2r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SET
#define SERDES_CFG_9_2r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_2r_GET
#define SERDES_CFG_9_2r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SPEED_CFGf_GET
#define SERDES_CFG_9_2r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_2r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_2r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_2r
#define WRITE_SERDES_CFG_9_2r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_2r
#define MODIFY_SERDES_CFG_9_2r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_3
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9423
 * DESC:     Serdes Config Index 9 offset 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 63:48
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_3r (0x00109423 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_3.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_3r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_3[1];
	uint32_t _serdes_cfg_9_3;
} BCMI_TSCD_XGXS_SERDES_CFG_9_3r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_3r_CLR(r) (r).serdes_cfg_9_3[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SET(r,d) (r).serdes_cfg_9_3[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_3r_GET(r) (r).serdes_cfg_9_3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_3[0]=(((r).serdes_cfg_9_3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_3r,(_r._serdes_cfg_9_3))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_3r,(_r._serdes_cfg_9_3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_3r,(_r._serdes_cfg_9_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_3r BCMI_TSCD_XGXS_SERDES_CFG_9_3r
#define SERDES_CFG_9_3r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_3r_t SERDES_CFG_9_3r_t;
#define SERDES_CFG_9_3r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_3r_CLR
#define SERDES_CFG_9_3r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SET
#define SERDES_CFG_9_3r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_3r_GET
#define SERDES_CFG_9_3r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SPEED_CFGf_GET
#define SERDES_CFG_9_3r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_3r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_3r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_3r
#define WRITE_SERDES_CFG_9_3r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_3r
#define MODIFY_SERDES_CFG_9_3r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_4
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9424
 * DESC:     Serdes Config Index 9 offset 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 79:64
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_4r (0x00109424 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_4.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_4r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_4[1];
	uint32_t _serdes_cfg_9_4;
} BCMI_TSCD_XGXS_SERDES_CFG_9_4r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_4r_CLR(r) (r).serdes_cfg_9_4[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SET(r,d) (r).serdes_cfg_9_4[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_4r_GET(r) (r).serdes_cfg_9_4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_4[0]=(((r).serdes_cfg_9_4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_4r,(_r._serdes_cfg_9_4))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_4r,(_r._serdes_cfg_9_4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_4r,(_r._serdes_cfg_9_4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_4r BCMI_TSCD_XGXS_SERDES_CFG_9_4r
#define SERDES_CFG_9_4r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_4r_t SERDES_CFG_9_4r_t;
#define SERDES_CFG_9_4r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_4r_CLR
#define SERDES_CFG_9_4r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SET
#define SERDES_CFG_9_4r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_4r_GET
#define SERDES_CFG_9_4r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SPEED_CFGf_GET
#define SERDES_CFG_9_4r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_4r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_4r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_4r
#define WRITE_SERDES_CFG_9_4r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_4r
#define MODIFY_SERDES_CFG_9_4r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_5
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9425
 * DESC:     Serdes Config Index 9 offset 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 95:80
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_5r (0x00109425 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_5.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_5r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_5[1];
	uint32_t _serdes_cfg_9_5;
} BCMI_TSCD_XGXS_SERDES_CFG_9_5r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_5r_CLR(r) (r).serdes_cfg_9_5[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SET(r,d) (r).serdes_cfg_9_5[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_5r_GET(r) (r).serdes_cfg_9_5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_5[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_5[0]=(((r).serdes_cfg_9_5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_5r,(_r._serdes_cfg_9_5))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_5r,(_r._serdes_cfg_9_5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_5r,(_r._serdes_cfg_9_5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_5r BCMI_TSCD_XGXS_SERDES_CFG_9_5r
#define SERDES_CFG_9_5r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_5r_t SERDES_CFG_9_5r_t;
#define SERDES_CFG_9_5r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_5r_CLR
#define SERDES_CFG_9_5r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SET
#define SERDES_CFG_9_5r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_5r_GET
#define SERDES_CFG_9_5r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SPEED_CFGf_GET
#define SERDES_CFG_9_5r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_5r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_5r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_5r
#define WRITE_SERDES_CFG_9_5r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_5r
#define MODIFY_SERDES_CFG_9_5r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_6
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9426
 * DESC:     Serdes Config Index 9 offset 6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 111:96
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_6r (0x00109426 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_6.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_6r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_6[1];
	uint32_t _serdes_cfg_9_6;
} BCMI_TSCD_XGXS_SERDES_CFG_9_6r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_6r_CLR(r) (r).serdes_cfg_9_6[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SET(r,d) (r).serdes_cfg_9_6[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_6r_GET(r) (r).serdes_cfg_9_6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_6[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_6[0]=(((r).serdes_cfg_9_6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_6r,(_r._serdes_cfg_9_6))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_6r,(_r._serdes_cfg_9_6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_6r,(_r._serdes_cfg_9_6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_6r BCMI_TSCD_XGXS_SERDES_CFG_9_6r
#define SERDES_CFG_9_6r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_6r_t SERDES_CFG_9_6r_t;
#define SERDES_CFG_9_6r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_6r_CLR
#define SERDES_CFG_9_6r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SET
#define SERDES_CFG_9_6r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_6r_GET
#define SERDES_CFG_9_6r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SPEED_CFGf_GET
#define SERDES_CFG_9_6r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_6r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_6r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_6r
#define WRITE_SERDES_CFG_9_6r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_6r
#define MODIFY_SERDES_CFG_9_6r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_7
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9427
 * DESC:     Serdes Config Index 9 offset 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 127:112
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_7r (0x00109427 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_7.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_7r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_7[1];
	uint32_t _serdes_cfg_9_7;
} BCMI_TSCD_XGXS_SERDES_CFG_9_7r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_7r_CLR(r) (r).serdes_cfg_9_7[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SET(r,d) (r).serdes_cfg_9_7[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_7r_GET(r) (r).serdes_cfg_9_7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_7[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_7[0]=(((r).serdes_cfg_9_7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_7r,(_r._serdes_cfg_9_7))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_7r,(_r._serdes_cfg_9_7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_7r,(_r._serdes_cfg_9_7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_7r BCMI_TSCD_XGXS_SERDES_CFG_9_7r
#define SERDES_CFG_9_7r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_7r_t SERDES_CFG_9_7r_t;
#define SERDES_CFG_9_7r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_7r_CLR
#define SERDES_CFG_9_7r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SET
#define SERDES_CFG_9_7r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_7r_GET
#define SERDES_CFG_9_7r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SPEED_CFGf_GET
#define SERDES_CFG_9_7r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_7r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_7r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_7r
#define WRITE_SERDES_CFG_9_7r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_7r
#define MODIFY_SERDES_CFG_9_7r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_8
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9428
 * DESC:     Serdes Config Index 9 offset 8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 143:128
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_8r (0x00109428 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_8.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_8r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_8[1];
	uint32_t _serdes_cfg_9_8;
} BCMI_TSCD_XGXS_SERDES_CFG_9_8r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_8r_CLR(r) (r).serdes_cfg_9_8[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SET(r,d) (r).serdes_cfg_9_8[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_8r_GET(r) (r).serdes_cfg_9_8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_8[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_8[0]=(((r).serdes_cfg_9_8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_8r,(_r._serdes_cfg_9_8))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_8r,(_r._serdes_cfg_9_8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_8r,(_r._serdes_cfg_9_8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_8r BCMI_TSCD_XGXS_SERDES_CFG_9_8r
#define SERDES_CFG_9_8r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_8r_t SERDES_CFG_9_8r_t;
#define SERDES_CFG_9_8r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_8r_CLR
#define SERDES_CFG_9_8r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SET
#define SERDES_CFG_9_8r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_8r_GET
#define SERDES_CFG_9_8r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SPEED_CFGf_GET
#define SERDES_CFG_9_8r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_8r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_8r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_8r
#define WRITE_SERDES_CFG_9_8r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_8r
#define MODIFY_SERDES_CFG_9_8r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_9
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9429
 * DESC:     Serdes Config Index 9 offset 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 159:144
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_9r (0x00109429 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_9.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_9r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_9[1];
	uint32_t _serdes_cfg_9_9;
} BCMI_TSCD_XGXS_SERDES_CFG_9_9r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_9r_CLR(r) (r).serdes_cfg_9_9[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SET(r,d) (r).serdes_cfg_9_9[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_9r_GET(r) (r).serdes_cfg_9_9[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_9[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_9[0]=(((r).serdes_cfg_9_9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_9.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_9r,(_r._serdes_cfg_9_9))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_9r,(_r._serdes_cfg_9_9)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_9r,(_r._serdes_cfg_9_9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_9r BCMI_TSCD_XGXS_SERDES_CFG_9_9r
#define SERDES_CFG_9_9r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_9r_t SERDES_CFG_9_9r_t;
#define SERDES_CFG_9_9r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_9r_CLR
#define SERDES_CFG_9_9r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SET
#define SERDES_CFG_9_9r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_9r_GET
#define SERDES_CFG_9_9r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SPEED_CFGf_GET
#define SERDES_CFG_9_9r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_9r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_9r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_9r
#define WRITE_SERDES_CFG_9_9r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_9r
#define MODIFY_SERDES_CFG_9_9r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_9r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_10
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x942a
 * DESC:     Serdes Config Index 9 offset 10
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 175:160
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_10r (0x0010942a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_10.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_10r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_10[1];
	uint32_t _serdes_cfg_9_10;
} BCMI_TSCD_XGXS_SERDES_CFG_9_10r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_10r_CLR(r) (r).serdes_cfg_9_10[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SET(r,d) (r).serdes_cfg_9_10[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_10r_GET(r) (r).serdes_cfg_9_10[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_10[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_10[0]=(((r).serdes_cfg_9_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_10.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_10r,(_r._serdes_cfg_9_10))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_10r,(_r._serdes_cfg_9_10)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_10r,(_r._serdes_cfg_9_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_10r BCMI_TSCD_XGXS_SERDES_CFG_9_10r
#define SERDES_CFG_9_10r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_10r_t SERDES_CFG_9_10r_t;
#define SERDES_CFG_9_10r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_10r_CLR
#define SERDES_CFG_9_10r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SET
#define SERDES_CFG_9_10r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_10r_GET
#define SERDES_CFG_9_10r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SPEED_CFGf_GET
#define SERDES_CFG_9_10r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_10r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_10r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_10r
#define WRITE_SERDES_CFG_9_10r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_10r
#define MODIFY_SERDES_CFG_9_10r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_11
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x942b
 * DESC:     Serdes Config Index 9 offset 11
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 191:176
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_11r (0x0010942b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_11.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_11r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_11[1];
	uint32_t _serdes_cfg_9_11;
} BCMI_TSCD_XGXS_SERDES_CFG_9_11r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_11r_CLR(r) (r).serdes_cfg_9_11[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SET(r,d) (r).serdes_cfg_9_11[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_11r_GET(r) (r).serdes_cfg_9_11[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_11[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_11[0]=(((r).serdes_cfg_9_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_11.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_11r,(_r._serdes_cfg_9_11))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_11r,(_r._serdes_cfg_9_11)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_11r,(_r._serdes_cfg_9_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_11r BCMI_TSCD_XGXS_SERDES_CFG_9_11r
#define SERDES_CFG_9_11r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_11r_t SERDES_CFG_9_11r_t;
#define SERDES_CFG_9_11r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_11r_CLR
#define SERDES_CFG_9_11r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SET
#define SERDES_CFG_9_11r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_11r_GET
#define SERDES_CFG_9_11r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SPEED_CFGf_GET
#define SERDES_CFG_9_11r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_11r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_11r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_11r
#define WRITE_SERDES_CFG_9_11r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_11r
#define MODIFY_SERDES_CFG_9_11r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_12
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x942c
 * DESC:     Serdes Config Index 9 offset 12
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 207:192
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_12r (0x0010942c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_12.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_12r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_12[1];
	uint32_t _serdes_cfg_9_12;
} BCMI_TSCD_XGXS_SERDES_CFG_9_12r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_12r_CLR(r) (r).serdes_cfg_9_12[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SET(r,d) (r).serdes_cfg_9_12[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_12r_GET(r) (r).serdes_cfg_9_12[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_12[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_12[0]=(((r).serdes_cfg_9_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_12.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_12r,(_r._serdes_cfg_9_12))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_12r,(_r._serdes_cfg_9_12)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_12r,(_r._serdes_cfg_9_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_12r BCMI_TSCD_XGXS_SERDES_CFG_9_12r
#define SERDES_CFG_9_12r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_12r_t SERDES_CFG_9_12r_t;
#define SERDES_CFG_9_12r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_12r_CLR
#define SERDES_CFG_9_12r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SET
#define SERDES_CFG_9_12r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_12r_GET
#define SERDES_CFG_9_12r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SPEED_CFGf_GET
#define SERDES_CFG_9_12r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_12r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_12r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_12r
#define WRITE_SERDES_CFG_9_12r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_12r
#define MODIFY_SERDES_CFG_9_12r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_13
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x942d
 * DESC:     Serdes Config Index 9 offset 13
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 223:208
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_13r (0x0010942d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_13.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_13r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_13[1];
	uint32_t _serdes_cfg_9_13;
} BCMI_TSCD_XGXS_SERDES_CFG_9_13r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_13r_CLR(r) (r).serdes_cfg_9_13[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SET(r,d) (r).serdes_cfg_9_13[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_13r_GET(r) (r).serdes_cfg_9_13[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_13[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_13[0]=(((r).serdes_cfg_9_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_13.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_13r,(_r._serdes_cfg_9_13))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_13r,(_r._serdes_cfg_9_13)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_13r,(_r._serdes_cfg_9_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_13r BCMI_TSCD_XGXS_SERDES_CFG_9_13r
#define SERDES_CFG_9_13r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_13r_t SERDES_CFG_9_13r_t;
#define SERDES_CFG_9_13r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_13r_CLR
#define SERDES_CFG_9_13r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SET
#define SERDES_CFG_9_13r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_13r_GET
#define SERDES_CFG_9_13r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SPEED_CFGf_GET
#define SERDES_CFG_9_13r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_13r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_13r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_13r
#define WRITE_SERDES_CFG_9_13r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_13r
#define MODIFY_SERDES_CFG_9_13r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_14
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x942e
 * DESC:     Serdes Config Index 9 offset 14
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 239:224
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_14r (0x0010942e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_14.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_14r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_14[1];
	uint32_t _serdes_cfg_9_14;
} BCMI_TSCD_XGXS_SERDES_CFG_9_14r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_14r_CLR(r) (r).serdes_cfg_9_14[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SET(r,d) (r).serdes_cfg_9_14[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_14r_GET(r) (r).serdes_cfg_9_14[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_14[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_14[0]=(((r).serdes_cfg_9_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_14.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_14r,(_r._serdes_cfg_9_14))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_14r,(_r._serdes_cfg_9_14)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_14r,(_r._serdes_cfg_9_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_14r BCMI_TSCD_XGXS_SERDES_CFG_9_14r
#define SERDES_CFG_9_14r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_14r_t SERDES_CFG_9_14r_t;
#define SERDES_CFG_9_14r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_14r_CLR
#define SERDES_CFG_9_14r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SET
#define SERDES_CFG_9_14r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_14r_GET
#define SERDES_CFG_9_14r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SPEED_CFGf_GET
#define SERDES_CFG_9_14r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_14r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_14r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_14r
#define WRITE_SERDES_CFG_9_14r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_14r
#define MODIFY_SERDES_CFG_9_14r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_15
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x942f
 * DESC:     Serdes Config Index 9 offset 15
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 255:240
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_15r (0x0010942f | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_15.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_15r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_15[1];
	uint32_t _serdes_cfg_9_15;
} BCMI_TSCD_XGXS_SERDES_CFG_9_15r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_15r_CLR(r) (r).serdes_cfg_9_15[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SET(r,d) (r).serdes_cfg_9_15[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_15r_GET(r) (r).serdes_cfg_9_15[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_15[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_15[0]=(((r).serdes_cfg_9_15[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_15.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_15r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_15r,(_r._serdes_cfg_9_15))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_15r,(_r._serdes_cfg_9_15)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_15r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_15r,(_r._serdes_cfg_9_15))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_15r BCMI_TSCD_XGXS_SERDES_CFG_9_15r
#define SERDES_CFG_9_15r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_15r_t SERDES_CFG_9_15r_t;
#define SERDES_CFG_9_15r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_15r_CLR
#define SERDES_CFG_9_15r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SET
#define SERDES_CFG_9_15r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_15r_GET
#define SERDES_CFG_9_15r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SPEED_CFGf_GET
#define SERDES_CFG_9_15r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_15r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_15r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_15r
#define WRITE_SERDES_CFG_9_15r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_15r
#define MODIFY_SERDES_CFG_9_15r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_15r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_16
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9430
 * DESC:     Serdes Config Index 9 offset 16
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 271:256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_16r (0x00109430 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_16.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_16r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_16[1];
	uint32_t _serdes_cfg_9_16;
} BCMI_TSCD_XGXS_SERDES_CFG_9_16r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_16r_CLR(r) (r).serdes_cfg_9_16[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SET(r,d) (r).serdes_cfg_9_16[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_16r_GET(r) (r).serdes_cfg_9_16[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_16[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_16[0]=(((r).serdes_cfg_9_16[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_16.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_16r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_16r,(_r._serdes_cfg_9_16))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_16r,(_r._serdes_cfg_9_16)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_16r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_16r,(_r._serdes_cfg_9_16))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_16r BCMI_TSCD_XGXS_SERDES_CFG_9_16r
#define SERDES_CFG_9_16r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_16r_t SERDES_CFG_9_16r_t;
#define SERDES_CFG_9_16r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_16r_CLR
#define SERDES_CFG_9_16r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SET
#define SERDES_CFG_9_16r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_16r_GET
#define SERDES_CFG_9_16r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SPEED_CFGf_GET
#define SERDES_CFG_9_16r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_16r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_16r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_16r
#define WRITE_SERDES_CFG_9_16r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_16r
#define MODIFY_SERDES_CFG_9_16r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_16r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_17
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9431
 * DESC:     Serdes Config Index 9 offset 17
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 287:272
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_17r (0x00109431 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_17.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_17r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_17[1];
	uint32_t _serdes_cfg_9_17;
} BCMI_TSCD_XGXS_SERDES_CFG_9_17r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_17r_CLR(r) (r).serdes_cfg_9_17[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SET(r,d) (r).serdes_cfg_9_17[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_17r_GET(r) (r).serdes_cfg_9_17[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_17[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_17[0]=(((r).serdes_cfg_9_17[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_17.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_17r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_17r,(_r._serdes_cfg_9_17))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_17r,(_r._serdes_cfg_9_17)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_17r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_17r,(_r._serdes_cfg_9_17))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_17r BCMI_TSCD_XGXS_SERDES_CFG_9_17r
#define SERDES_CFG_9_17r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_17r_t SERDES_CFG_9_17r_t;
#define SERDES_CFG_9_17r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_17r_CLR
#define SERDES_CFG_9_17r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SET
#define SERDES_CFG_9_17r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_17r_GET
#define SERDES_CFG_9_17r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SPEED_CFGf_GET
#define SERDES_CFG_9_17r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_17r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_17r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_17r
#define WRITE_SERDES_CFG_9_17r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_17r
#define MODIFY_SERDES_CFG_9_17r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_17r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_18
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9432
 * DESC:     Serdes Config Index 9 offset 18
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 303:288
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_18r (0x00109432 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_18.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_18r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_18[1];
	uint32_t _serdes_cfg_9_18;
} BCMI_TSCD_XGXS_SERDES_CFG_9_18r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_18r_CLR(r) (r).serdes_cfg_9_18[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SET(r,d) (r).serdes_cfg_9_18[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_18r_GET(r) (r).serdes_cfg_9_18[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_18[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_18[0]=(((r).serdes_cfg_9_18[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_18.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_18r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_18r,(_r._serdes_cfg_9_18))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_18r,(_r._serdes_cfg_9_18)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_18r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_18r,(_r._serdes_cfg_9_18))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_18r BCMI_TSCD_XGXS_SERDES_CFG_9_18r
#define SERDES_CFG_9_18r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_18r_t SERDES_CFG_9_18r_t;
#define SERDES_CFG_9_18r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_18r_CLR
#define SERDES_CFG_9_18r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SET
#define SERDES_CFG_9_18r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_18r_GET
#define SERDES_CFG_9_18r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SPEED_CFGf_GET
#define SERDES_CFG_9_18r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_18r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_18r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_18r
#define WRITE_SERDES_CFG_9_18r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_18r
#define MODIFY_SERDES_CFG_9_18r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_18r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_19
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9433
 * DESC:     Serdes Config Index 9 offset 19
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 319:304
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_19r (0x00109433 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_19.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_19r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_19[1];
	uint32_t _serdes_cfg_9_19;
} BCMI_TSCD_XGXS_SERDES_CFG_9_19r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_19r_CLR(r) (r).serdes_cfg_9_19[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SET(r,d) (r).serdes_cfg_9_19[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_19r_GET(r) (r).serdes_cfg_9_19[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_19[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_19[0]=(((r).serdes_cfg_9_19[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_19.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_19r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_19r,(_r._serdes_cfg_9_19))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_19r,(_r._serdes_cfg_9_19)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_19r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_19r,(_r._serdes_cfg_9_19))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_19r BCMI_TSCD_XGXS_SERDES_CFG_9_19r
#define SERDES_CFG_9_19r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_19r_t SERDES_CFG_9_19r_t;
#define SERDES_CFG_9_19r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_19r_CLR
#define SERDES_CFG_9_19r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SET
#define SERDES_CFG_9_19r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_19r_GET
#define SERDES_CFG_9_19r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SPEED_CFGf_GET
#define SERDES_CFG_9_19r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_19r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_19r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_19r
#define WRITE_SERDES_CFG_9_19r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_19r
#define MODIFY_SERDES_CFG_9_19r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_19r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_20
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9434
 * DESC:     Serdes Config Index 9 offset 20
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED_CFG        D5 Serdes config 323:320
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_20r (0x00109434 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_20.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_20r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_20[1];
	uint32_t _serdes_cfg_9_20;
} BCMI_TSCD_XGXS_SERDES_CFG_9_20r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_20r_CLR(r) (r).serdes_cfg_9_20[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SET(r,d) (r).serdes_cfg_9_20[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_20r_GET(r) (r).serdes_cfg_9_20[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SPEED_CFGf_GET(r) (((r).serdes_cfg_9_20[0]) & 0xf)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SPEED_CFGf_SET(r,f) (r).serdes_cfg_9_20[0]=(((r).serdes_cfg_9_20[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access SERDES_CFG_9_20.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_20r,(_r._serdes_cfg_9_20))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_20r,(_r._serdes_cfg_9_20)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_20r,(_r._serdes_cfg_9_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_20r BCMI_TSCD_XGXS_SERDES_CFG_9_20r
#define SERDES_CFG_9_20r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_20r_t SERDES_CFG_9_20r_t;
#define SERDES_CFG_9_20r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_20r_CLR
#define SERDES_CFG_9_20r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SET
#define SERDES_CFG_9_20r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_20r_GET
#define SERDES_CFG_9_20r_SPEED_CFGf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SPEED_CFGf_GET
#define SERDES_CFG_9_20r_SPEED_CFGf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_20r_SPEED_CFGf_SET
#define READ_SERDES_CFG_9_20r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_20r
#define WRITE_SERDES_CFG_9_20r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_20r
#define MODIFY_SERDES_CFG_9_20r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_21
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9435
 * DESC:     Serdes Config Index 9 offset 21
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FCLK_PERIOD      Fast Clock period for speed selected.D5 Serdes config 351:336
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_21r (0x00109435 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_21r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_21.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_21r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_21[1];
	uint32_t _serdes_cfg_9_21;
} BCMI_TSCD_XGXS_SERDES_CFG_9_21r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_21r_CLR(r) (r).serdes_cfg_9_21[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_21r_SET(r,d) (r).serdes_cfg_9_21[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_21r_GET(r) (r).serdes_cfg_9_21[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_21r_FCLK_PERIODf_GET(r) (((r).serdes_cfg_9_21[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_21r_FCLK_PERIODf_SET(r,f) (r).serdes_cfg_9_21[0]=(((r).serdes_cfg_9_21[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SERDES_CFG_9_21.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_21r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_21r,(_r._serdes_cfg_9_21))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_21r,(_r._serdes_cfg_9_21)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_21r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_21r,(_r._serdes_cfg_9_21))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_21r BCMI_TSCD_XGXS_SERDES_CFG_9_21r
#define SERDES_CFG_9_21r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_21r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_21r_t SERDES_CFG_9_21r_t;
#define SERDES_CFG_9_21r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_21r_CLR
#define SERDES_CFG_9_21r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_21r_SET
#define SERDES_CFG_9_21r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_21r_GET
#define SERDES_CFG_9_21r_FCLK_PERIODf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_21r_FCLK_PERIODf_GET
#define SERDES_CFG_9_21r_FCLK_PERIODf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_21r_FCLK_PERIODf_SET
#define READ_SERDES_CFG_9_21r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_21r
#define WRITE_SERDES_CFG_9_21r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_21r
#define MODIFY_SERDES_CFG_9_21r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_21r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_22
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9436
 * DESC:     Serdes Config Index 9 offset 22
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOSVREF       D5 Serdes config 366:352D5 Serdes RX LOS VREF[4:0]
 *     SPARE            D5 Serdes config 367:357
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r (0x00109436 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_22.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_22r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_22[1];
	uint32_t _serdes_cfg_9_22;
} BCMI_TSCD_XGXS_SERDES_CFG_9_22r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_CLR(r) (r).serdes_cfg_9_22[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SET(r,d) (r).serdes_cfg_9_22[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_GET(r) (r).serdes_cfg_9_22[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SPAREf_GET(r) ((((r).serdes_cfg_9_22[0]) >> 5) & 0x7ff)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SPAREf_SET(r,f) (r).serdes_cfg_9_22[0]=(((r).serdes_cfg_9_22[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))
#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_RX_LOSVREFf_GET(r) (((r).serdes_cfg_9_22[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_22r_RX_LOSVREFf_SET(r,f) (r).serdes_cfg_9_22[0]=(((r).serdes_cfg_9_22[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_9_22.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_22r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_22r,(_r._serdes_cfg_9_22))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_22r,(_r._serdes_cfg_9_22)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_22r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_22r,(_r._serdes_cfg_9_22))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_22r BCMI_TSCD_XGXS_SERDES_CFG_9_22r
#define SERDES_CFG_9_22r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_22r_t SERDES_CFG_9_22r_t;
#define SERDES_CFG_9_22r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_22r_CLR
#define SERDES_CFG_9_22r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SET
#define SERDES_CFG_9_22r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_22r_GET
#define SERDES_CFG_9_22r_SPAREf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SPAREf_GET
#define SERDES_CFG_9_22r_SPAREf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_22r_SPAREf_SET
#define SERDES_CFG_9_22r_RX_LOSVREFf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_22r_RX_LOSVREFf_GET
#define SERDES_CFG_9_22r_RX_LOSVREFf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_22r_RX_LOSVREFf_SET
#define READ_SERDES_CFG_9_22r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_22r
#define WRITE_SERDES_CFG_9_22r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_22r
#define MODIFY_SERDES_CFG_9_22r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_22r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SERDES_CFG_9_23
 * BLOCKS:   SERDESCFG
 * REGADDR:  0x9437
 * DESC:     Serdes Config Index 9 offset 23
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     APPLICATION_MODE D5 Serdes config 372:368D5 Serdes application_mode[4:0]
 *     RATESEL          D5 Serdes config 376:374D5 Serdes ratesel[2:0]
 *     WORDMODE         D5 Serdes config 379:377D5 Serdes wordmode[2:0]
 *     TRAINING_MODE    D5 Serdes config 380:380Tranining Mode enable for CL72 and CL92
 *     TRAINING_MODE_LN D5 Serdes config 382:381Tranining Mode enable for CL72 and CL92, lane number to use for random number generation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r (0x00109437 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_SIZE 4

/*
 * This structure should be used to declare and program SERDES_CFG_9_23.
 *
 */
typedef union BCMI_TSCD_XGXS_SERDES_CFG_9_23r_s {
	uint32_t v[1];
	uint32_t serdes_cfg_9_23[1];
	uint32_t _serdes_cfg_9_23;
} BCMI_TSCD_XGXS_SERDES_CFG_9_23r_t;

#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_CLR(r) (r).serdes_cfg_9_23[0] = 0
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_SET(r,d) (r).serdes_cfg_9_23[0] = d
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_GET(r) (r).serdes_cfg_9_23[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODE_LNf_GET(r) ((((r).serdes_cfg_9_23[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODE_LNf_SET(r,f) (r).serdes_cfg_9_23[0]=(((r).serdes_cfg_9_23[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODEf_GET(r) ((((r).serdes_cfg_9_23[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODEf_SET(r,f) (r).serdes_cfg_9_23[0]=(((r).serdes_cfg_9_23[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_WORDMODEf_GET(r) ((((r).serdes_cfg_9_23[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_WORDMODEf_SET(r,f) (r).serdes_cfg_9_23[0]=(((r).serdes_cfg_9_23[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_RATESELf_GET(r) ((((r).serdes_cfg_9_23[0]) >> 6) & 0x7)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_RATESELf_SET(r,f) (r).serdes_cfg_9_23[0]=(((r).serdes_cfg_9_23[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_APPLICATION_MODEf_GET(r) (((r).serdes_cfg_9_23[0]) & 0x1f)
#define BCMI_TSCD_XGXS_SERDES_CFG_9_23r_APPLICATION_MODEf_SET(r,f) (r).serdes_cfg_9_23[0]=(((r).serdes_cfg_9_23[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SERDES_CFG_9_23.
 *
 */
#define BCMI_TSCD_XGXS_READ_SERDES_CFG_9_23r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_23r,(_r._serdes_cfg_9_23))
#define BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_23r,(_r._serdes_cfg_9_23)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_23r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SERDES_CFG_9_23r,(_r._serdes_cfg_9_23))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SERDES_CFG_9_23r BCMI_TSCD_XGXS_SERDES_CFG_9_23r
#define SERDES_CFG_9_23r_SIZE BCMI_TSCD_XGXS_SERDES_CFG_9_23r_SIZE
typedef BCMI_TSCD_XGXS_SERDES_CFG_9_23r_t SERDES_CFG_9_23r_t;
#define SERDES_CFG_9_23r_CLR BCMI_TSCD_XGXS_SERDES_CFG_9_23r_CLR
#define SERDES_CFG_9_23r_SET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_SET
#define SERDES_CFG_9_23r_GET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_GET
#define SERDES_CFG_9_23r_TRAINING_MODE_LNf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODE_LNf_GET
#define SERDES_CFG_9_23r_TRAINING_MODE_LNf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODE_LNf_SET
#define SERDES_CFG_9_23r_TRAINING_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODEf_GET
#define SERDES_CFG_9_23r_TRAINING_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_TRAINING_MODEf_SET
#define SERDES_CFG_9_23r_WORDMODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_WORDMODEf_GET
#define SERDES_CFG_9_23r_WORDMODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_WORDMODEf_SET
#define SERDES_CFG_9_23r_RATESELf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_RATESELf_GET
#define SERDES_CFG_9_23r_RATESELf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_RATESELf_SET
#define SERDES_CFG_9_23r_APPLICATION_MODEf_GET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_APPLICATION_MODEf_GET
#define SERDES_CFG_9_23r_APPLICATION_MODEf_SET BCMI_TSCD_XGXS_SERDES_CFG_9_23r_APPLICATION_MODEf_SET
#define READ_SERDES_CFG_9_23r BCMI_TSCD_XGXS_READ_SERDES_CFG_9_23r
#define WRITE_SERDES_CFG_9_23r BCMI_TSCD_XGXS_WRITE_SERDES_CFG_9_23r
#define MODIFY_SERDES_CFG_9_23r BCMI_TSCD_XGXS_MODIFY_SERDES_CFG_9_23r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SERDES_CFG_9_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X2_CL82_0
 * BLOCKS:   TX_X2_CONTROL0
 * REGADDR:  0xa002
 * DESC:     CL82 register
 * RESETVAL: 0x70 (112)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_TX_RF_ENABLE If this bit is a one, RFs are passed from the RS LAYER to the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the PCS.For CL82 only.
 *     CL82_TX_LF_ENABLE If this bit is a one, LFs are passed from the RS LAYER to the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the PCS.For CL82 only.
 *     CL82_TX_LI_ENABLE If this bit is a one, LIs (Link Interrupt) are passed thru to the RS LAYER.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the RS LAYER.For CL82 only.
 *     CL82_BYPASS_TXSM Bypass cl82 transmit state machine1 = Bypass cl82 txsm :- force TX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r (0x0020a002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL82_0.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X2_CL82_0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl82_0[1];
	uint32_t _tx_x2_cl82_0;
} BCMI_TSCD_XGXS_TX_X2_CL82_0r_t;

#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CLR(r) (r).tx_x2_cl82_0[0] = 0
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_SET(r,d) (r).tx_x2_cl82_0[0] = d
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_GET(r) (r).tx_x2_cl82_0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET(r) ((((r).tx_x2_cl82_0[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET(r,f) (r).tx_x2_cl82_0[0]=(((r).tx_x2_cl82_0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access TX_X2_CL82_0.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0))
#define BCMI_TSCD_XGXS_WRITE_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_0r,(_r._tx_x2_cl82_0))
#define BCMI_TSCD_XGXS_READLN_TX_X2_CL82_0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_0))
#define BCMI_TSCD_XGXS_WRITELN_TX_X2_CL82_0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_0))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X2_CL82_0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_cl82_0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL82_0r BCMI_TSCD_XGXS_TX_X2_CL82_0r
#define TX_X2_CL82_0r_SIZE BCMI_TSCD_XGXS_TX_X2_CL82_0r_SIZE
typedef BCMI_TSCD_XGXS_TX_X2_CL82_0r_t TX_X2_CL82_0r_t;
#define TX_X2_CL82_0r_CLR BCMI_TSCD_XGXS_TX_X2_CL82_0r_CLR
#define TX_X2_CL82_0r_SET BCMI_TSCD_XGXS_TX_X2_CL82_0r_SET
#define TX_X2_CL82_0r_GET BCMI_TSCD_XGXS_TX_X2_CL82_0r_GET
#define TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_GET
#define TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_BYPASS_TXSMf_SET
#define TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LI_ENABLEf_SET
#define TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_LF_ENABLEf_SET
#define TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_GET
#define TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET BCMI_TSCD_XGXS_TX_X2_CL82_0r_CL82_TX_RF_ENABLEf_SET
#define READ_TX_X2_CL82_0r BCMI_TSCD_XGXS_READ_TX_X2_CL82_0r
#define WRITE_TX_X2_CL82_0r BCMI_TSCD_XGXS_WRITE_TX_X2_CL82_0r
#define MODIFY_TX_X2_CL82_0r BCMI_TSCD_XGXS_MODIFY_TX_X2_CL82_0r
#define READLN_TX_X2_CL82_0r BCMI_TSCD_XGXS_READLN_TX_X2_CL82_0r
#define WRITELN_TX_X2_CL82_0r BCMI_TSCD_XGXS_WRITELN_TX_X2_CL82_0r
#define WRITEALL_TX_X2_CL82_0r BCMI_TSCD_XGXS_WRITEALL_TX_X2_CL82_0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X2_CL82_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X2_CL82_TX_STS0
 * BLOCKS:   TX_X2_STATUS0
 * REGADDR:  0xa011
 * DESC:     CL82 Status 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TXSM_STATE       CL82 Transmit SM - current state
 *     T_TYPE_CODED     CL82 Transmit SM - current t_type
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r (0x0020a011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL82_TX_STS0.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl82_tx_sts0[1];
	uint32_t _tx_x2_cl82_tx_sts0;
} BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_t;

#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_CLR(r) (r).tx_x2_cl82_tx_sts0[0] = 0
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_SET(r,d) (r).tx_x2_cl82_tx_sts0[0] = d
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_GET(r) (r).tx_x2_cl82_tx_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_GET(r) ((((r).tx_x2_cl82_tx_sts0[0]) >> 3) & 0x7)
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_SET(r,f) (r).tx_x2_cl82_tx_sts0[0]=(((r).tx_x2_cl82_tx_sts0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_GET(r) (((r).tx_x2_cl82_tx_sts0[0]) & 0x7)
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_SET(r,f) (r).tx_x2_cl82_tx_sts0[0]=(((r).tx_x2_cl82_tx_sts0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TX_X2_CL82_TX_STS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r,(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCD_XGXS_WRITE_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r,(_r._tx_x2_cl82_tx_sts0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r,(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCD_XGXS_READLN_TX_X2_CL82_TX_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCD_XGXS_WRITELN_TX_X2_CL82_TX_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_tx_sts0))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X2_CL82_TX_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_cl82_tx_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL82_TX_STS0r BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r
#define TX_X2_CL82_TX_STS0r_SIZE BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_SIZE
typedef BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_t TX_X2_CL82_TX_STS0r_t;
#define TX_X2_CL82_TX_STS0r_CLR BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_CLR
#define TX_X2_CL82_TX_STS0r_SET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_SET
#define TX_X2_CL82_TX_STS0r_GET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_GET
#define TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_GET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_GET
#define TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_SET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_T_TYPE_CODEDf_SET
#define TX_X2_CL82_TX_STS0r_TXSM_STATEf_GET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_GET
#define TX_X2_CL82_TX_STS0r_TXSM_STATEf_SET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r_TXSM_STATEf_SET
#define READ_TX_X2_CL82_TX_STS0r BCMI_TSCD_XGXS_READ_TX_X2_CL82_TX_STS0r
#define WRITE_TX_X2_CL82_TX_STS0r BCMI_TSCD_XGXS_WRITE_TX_X2_CL82_TX_STS0r
#define MODIFY_TX_X2_CL82_TX_STS0r BCMI_TSCD_XGXS_MODIFY_TX_X2_CL82_TX_STS0r
#define READLN_TX_X2_CL82_TX_STS0r BCMI_TSCD_XGXS_READLN_TX_X2_CL82_TX_STS0r
#define WRITELN_TX_X2_CL82_TX_STS0r BCMI_TSCD_XGXS_WRITELN_TX_X2_CL82_TX_STS0r
#define WRITEALL_TX_X2_CL82_TX_STS0r BCMI_TSCD_XGXS_WRITEALL_TX_X2_CL82_TX_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X2_CL82_TX_STS1
 * BLOCKS:   TX_X2_STATUS0
 * REGADDR:  0xa012
 * DESC:     CL82 Status 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LTXSM_STATE      CL82 Transmit SM - latched states - latched on entry
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r (0x0020a012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X2_CL82_TX_STS1.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_s {
	uint32_t v[1];
	uint32_t tx_x2_cl82_tx_sts1[1];
	uint32_t _tx_x2_cl82_tx_sts1;
} BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_t;

#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_CLR(r) (r).tx_x2_cl82_tx_sts1[0] = 0
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_SET(r,d) (r).tx_x2_cl82_tx_sts1[0] = d
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_GET(r) (r).tx_x2_cl82_tx_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_LTXSM_STATEf_GET(r) (((r).tx_x2_cl82_tx_sts1[0]) & 0x7f)
#define BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_LTXSM_STATEf_SET(r,f) (r).tx_x2_cl82_tx_sts1[0]=(((r).tx_x2_cl82_tx_sts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TX_X2_CL82_TX_STS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X2_CL82_TX_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r,(_r._tx_x2_cl82_tx_sts1))
#define BCMI_TSCD_XGXS_WRITE_TX_X2_CL82_TX_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r,(_r._tx_x2_cl82_tx_sts1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X2_CL82_TX_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r,(_r._tx_x2_cl82_tx_sts1))
#define BCMI_TSCD_XGXS_READLN_TX_X2_CL82_TX_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_tx_sts1))
#define BCMI_TSCD_XGXS_WRITELN_TX_X2_CL82_TX_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x2_cl82_tx_sts1))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X2_CL82_TX_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x2_cl82_tx_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X2_CL82_TX_STS1r BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r
#define TX_X2_CL82_TX_STS1r_SIZE BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_SIZE
typedef BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_t TX_X2_CL82_TX_STS1r_t;
#define TX_X2_CL82_TX_STS1r_CLR BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_CLR
#define TX_X2_CL82_TX_STS1r_SET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_SET
#define TX_X2_CL82_TX_STS1r_GET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_GET
#define TX_X2_CL82_TX_STS1r_LTXSM_STATEf_GET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_LTXSM_STATEf_GET
#define TX_X2_CL82_TX_STS1r_LTXSM_STATEf_SET BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r_LTXSM_STATEf_SET
#define READ_TX_X2_CL82_TX_STS1r BCMI_TSCD_XGXS_READ_TX_X2_CL82_TX_STS1r
#define WRITE_TX_X2_CL82_TX_STS1r BCMI_TSCD_XGXS_WRITE_TX_X2_CL82_TX_STS1r
#define MODIFY_TX_X2_CL82_TX_STS1r BCMI_TSCD_XGXS_MODIFY_TX_X2_CL82_TX_STS1r
#define READLN_TX_X2_CL82_TX_STS1r BCMI_TSCD_XGXS_READLN_TX_X2_CL82_TX_STS1r
#define WRITELN_TX_X2_CL82_TX_STS1r BCMI_TSCD_XGXS_WRITELN_TX_X2_CL82_TX_STS1r
#define WRITEALL_TX_X2_CL82_TX_STS1r BCMI_TSCD_XGXS_WRITEALL_TX_X2_CL82_TX_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X2_CL82_TX_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X2_MISC0
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa023
 * DESC:     misc 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BYPASS_CL82RXSM  Bypass cl82 receive state machine1 = Bypass cl82 rxsm :- force RX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *     DIS_CL82_BERMON  Disable cl82 BER monitor state machine1 = Disable bermon fsm, force BER_MT_INIT state0 = Enable (default)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X2_MISC0r (0x0020a023 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X2_MISC0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_MISC0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X2_MISC0r_s {
	uint32_t v[1];
	uint32_t rx_x2_misc0[1];
	uint32_t _rx_x2_misc0;
} BCMI_TSCD_XGXS_RX_X2_MISC0r_t;

#define BCMI_TSCD_XGXS_RX_X2_MISC0r_CLR(r) (r).rx_x2_misc0[0] = 0
#define BCMI_TSCD_XGXS_RX_X2_MISC0r_SET(r,d) (r).rx_x2_misc0[0] = d
#define BCMI_TSCD_XGXS_RX_X2_MISC0r_GET(r) (r).rx_x2_misc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_GET(r) ((((r).rx_x2_misc0[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_SET(r,f) (r).rx_x2_misc0[0]=(((r).rx_x2_misc0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_GET(r) (((r).rx_x2_misc0[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_SET(r,f) (r).rx_x2_misc0[0]=(((r).rx_x2_misc0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X2_MISC0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X2_MISC0r,(_r._rx_x2_misc0))
#define BCMI_TSCD_XGXS_WRITE_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC0r,(_r._rx_x2_misc0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC0r,(_r._rx_x2_misc0))
#define BCMI_TSCD_XGXS_READLN_RX_X2_MISC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X2_MISC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X2_MISC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X2_MISC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_misc0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_MISC0r BCMI_TSCD_XGXS_RX_X2_MISC0r
#define RX_X2_MISC0r_SIZE BCMI_TSCD_XGXS_RX_X2_MISC0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X2_MISC0r_t RX_X2_MISC0r_t;
#define RX_X2_MISC0r_CLR BCMI_TSCD_XGXS_RX_X2_MISC0r_CLR
#define RX_X2_MISC0r_SET BCMI_TSCD_XGXS_RX_X2_MISC0r_SET
#define RX_X2_MISC0r_GET BCMI_TSCD_XGXS_RX_X2_MISC0r_GET
#define RX_X2_MISC0r_DIS_CL82_BERMONf_GET BCMI_TSCD_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_GET
#define RX_X2_MISC0r_DIS_CL82_BERMONf_SET BCMI_TSCD_XGXS_RX_X2_MISC0r_DIS_CL82_BERMONf_SET
#define RX_X2_MISC0r_BYPASS_CL82RXSMf_GET BCMI_TSCD_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_GET
#define RX_X2_MISC0r_BYPASS_CL82RXSMf_SET BCMI_TSCD_XGXS_RX_X2_MISC0r_BYPASS_CL82RXSMf_SET
#define READ_RX_X2_MISC0r BCMI_TSCD_XGXS_READ_RX_X2_MISC0r
#define WRITE_RX_X2_MISC0r BCMI_TSCD_XGXS_WRITE_RX_X2_MISC0r
#define MODIFY_RX_X2_MISC0r BCMI_TSCD_XGXS_MODIFY_RX_X2_MISC0r
#define READLN_RX_X2_MISC0r BCMI_TSCD_XGXS_READLN_RX_X2_MISC0r
#define WRITELN_RX_X2_MISC0r BCMI_TSCD_XGXS_WRITELN_RX_X2_MISC0r
#define WRITEALL_RX_X2_MISC0r BCMI_TSCD_XGXS_WRITEALL_RX_X2_MISC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X2_MISC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X2_MISC1
 * BLOCKS:   RX_X2_CONTROL0
 * REGADDR:  0xa024
 * DESC:     misc 1 register
 * RESETVAL: 0x203 (515)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_RX_RF_ENABLE If this bit is a one, RFs are passed to the RS layer from the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the RS layer.For CL82 only.
 *     CL82_RX_LF_ENABLE If this bit is a one, LFs are passed to the RS layer from the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the RS layer.For CL82 only.
 *     CL82_RX_LI_ENABLE If this bit is a one, LI (Link Interrupt) codes are passed thru to the PCS.If this bit is a zero, LI are replaced by IDLEs which are then passedto the PCS.For CL82 only.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X2_MISC1r (0x0020a024 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X2_MISC1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_MISC1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X2_MISC1r_s {
	uint32_t v[1];
	uint32_t rx_x2_misc1[1];
	uint32_t _rx_x2_misc1;
} BCMI_TSCD_XGXS_RX_X2_MISC1r_t;

#define BCMI_TSCD_XGXS_RX_X2_MISC1r_CLR(r) (r).rx_x2_misc1[0] = 0
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_SET(r,d) (r).rx_x2_misc1[0] = d
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_GET(r) (r).rx_x2_misc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_GET(r) ((((r).rx_x2_misc1[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_GET(r) ((((r).rx_x2_misc1[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_GET(r) (((r).rx_x2_misc1[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_SET(r,f) (r).rx_x2_misc1[0]=(((r).rx_x2_misc1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X2_MISC1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X2_MISC1r,(_r._rx_x2_misc1))
#define BCMI_TSCD_XGXS_WRITE_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC1r,(_r._rx_x2_misc1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC1r,(_r._rx_x2_misc1))
#define BCMI_TSCD_XGXS_READLN_RX_X2_MISC1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X2_MISC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X2_MISC1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_misc1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X2_MISC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_MISC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_misc1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_MISC1r BCMI_TSCD_XGXS_RX_X2_MISC1r
#define RX_X2_MISC1r_SIZE BCMI_TSCD_XGXS_RX_X2_MISC1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X2_MISC1r_t RX_X2_MISC1r_t;
#define RX_X2_MISC1r_CLR BCMI_TSCD_XGXS_RX_X2_MISC1r_CLR
#define RX_X2_MISC1r_SET BCMI_TSCD_XGXS_RX_X2_MISC1r_SET
#define RX_X2_MISC1r_GET BCMI_TSCD_XGXS_RX_X2_MISC1r_GET
#define RX_X2_MISC1r_CL82_RX_LI_ENABLEf_GET BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_GET
#define RX_X2_MISC1r_CL82_RX_LI_ENABLEf_SET BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LI_ENABLEf_SET
#define RX_X2_MISC1r_CL82_RX_LF_ENABLEf_GET BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_GET
#define RX_X2_MISC1r_CL82_RX_LF_ENABLEf_SET BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_LF_ENABLEf_SET
#define RX_X2_MISC1r_CL82_RX_RF_ENABLEf_GET BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_GET
#define RX_X2_MISC1r_CL82_RX_RF_ENABLEf_SET BCMI_TSCD_XGXS_RX_X2_MISC1r_CL82_RX_RF_ENABLEf_SET
#define READ_RX_X2_MISC1r BCMI_TSCD_XGXS_READ_RX_X2_MISC1r
#define WRITE_RX_X2_MISC1r BCMI_TSCD_XGXS_WRITE_RX_X2_MISC1r
#define MODIFY_RX_X2_MISC1r BCMI_TSCD_XGXS_MODIFY_RX_X2_MISC1r
#define READLN_RX_X2_MISC1r BCMI_TSCD_XGXS_READLN_RX_X2_MISC1r
#define WRITELN_RX_X2_MISC1r BCMI_TSCD_XGXS_WRITELN_RX_X2_MISC1r
#define WRITEALL_RX_X2_MISC1r BCMI_TSCD_XGXS_WRITEALL_RX_X2_MISC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X2_MISC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X2_CL82_SCRIDLE_TEST_ERR
 * BLOCKS:   RX_X2_STATUS0
 * REGADDR:  0xa030
 * DESC:     CL82 Scrambled IDLE test Error register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL82_SCRIDLE_TEST_ERR CL82 Scrambled IDLE Test Error counter
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr (0x0020a030 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X2_CL82_SCRIDLE_TEST_ERR.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_s {
	uint32_t v[1];
	uint32_t rx_x2_cl82_scridle_test_err[1];
	uint32_t _rx_x2_cl82_scridle_test_err;
} BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_t;

#define BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_CLR(r) (r).rx_x2_cl82_scridle_test_err[0] = 0
#define BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_SET(r,d) (r).rx_x2_cl82_scridle_test_err[0] = d
#define BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_GET(r) (r).rx_x2_cl82_scridle_test_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_GET(r) (((r).rx_x2_cl82_scridle_test_err[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_SET(r,f) (r).rx_x2_cl82_scridle_test_err[0]=(((r).rx_x2_cl82_scridle_test_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X2_CL82_SCRIDLE_TEST_ERR.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X2_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr,(_r._rx_x2_cl82_scridle_test_err))
#define BCMI_TSCD_XGXS_WRITE_RX_X2_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr,(_r._rx_x2_cl82_scridle_test_err)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X2_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr,(_r._rx_x2_cl82_scridle_test_err))
#define BCMI_TSCD_XGXS_READLN_RX_X2_CL82_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_cl82_scridle_test_err))
#define BCMI_TSCD_XGXS_WRITELN_RX_X2_CL82_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x2_cl82_scridle_test_err))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X2_CL82_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x2_cl82_scridle_test_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X2_CL82_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr
#define RX_X2_CL82_SCRIDLE_TEST_ERRr_SIZE BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_SIZE
typedef BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_t RX_X2_CL82_SCRIDLE_TEST_ERRr_t;
#define RX_X2_CL82_SCRIDLE_TEST_ERRr_CLR BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_CLR
#define RX_X2_CL82_SCRIDLE_TEST_ERRr_SET BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_SET
#define RX_X2_CL82_SCRIDLE_TEST_ERRr_GET BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_GET
#define RX_X2_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_GET BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_GET
#define RX_X2_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_SET BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr_CL82_SCRIDLE_TEST_ERRf_SET
#define READ_RX_X2_CL82_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_READ_RX_X2_CL82_SCRIDLE_TEST_ERRr
#define WRITE_RX_X2_CL82_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_WRITE_RX_X2_CL82_SCRIDLE_TEST_ERRr
#define MODIFY_RX_X2_CL82_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_MODIFY_RX_X2_CL82_SCRIDLE_TEST_ERRr
#define READLN_RX_X2_CL82_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_READLN_RX_X2_CL82_SCRIDLE_TEST_ERRr
#define WRITELN_RX_X2_CL82_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_WRITELN_RX_X2_CL82_SCRIDLE_TEST_ERRr
#define WRITEALL_RX_X2_CL82_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_WRITEALL_RX_X2_CL82_SCRIDLE_TEST_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X2_CL82_SCRIDLE_TEST_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_RX_LIVE_STS
 * BLOCKS:   CL82
 * REGADDR:  0xa080
 * DESC:     cl82 rx live deskew and decoder status register
 * RESETVAL: 0x2000 (8192)
 * ACCESS:   R/O
 * FIELDS:
 *     CURRENT_RXSM_STATE CL82 Recieve fsm - current state
 *     R_TYPE_CODED     CL82 Receive SM - current r_type
 *     DESKEW_STATE     Deskew current statesbit 1  - ALIGN_ACQUIREDbit 0  - LOSS_OF_ALIGNMENT
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr (0x0020a080 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_LIVE_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_s {
	uint32_t v[1];
	uint32_t cl82_rx_live_sts[1];
	uint32_t _cl82_rx_live_sts;
} BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_t;

#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_CLR(r) (r).cl82_rx_live_sts[0] = 0
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_SET(r,d) (r).cl82_rx_live_sts[0] = d
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_GET(r) (r).cl82_rx_live_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_DESKEW_STATEf_GET(r) ((((r).cl82_rx_live_sts[0]) >> 13) & 0x3)
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_DESKEW_STATEf_SET(r,f) (r).cl82_rx_live_sts[0]=(((r).cl82_rx_live_sts[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_R_TYPE_CODEDf_GET(r) ((((r).cl82_rx_live_sts[0]) >> 7) & 0x3f)
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_R_TYPE_CODEDf_SET(r,f) (r).cl82_rx_live_sts[0]=(((r).cl82_rx_live_sts[0] & ~((uint32_t)0x3f << 7)) | ((((uint32_t)f) & 0x3f) << 7)) | (63 << (16 + 7))
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_CURRENT_RXSM_STATEf_GET(r) (((r).cl82_rx_live_sts[0]) & 0x7f)
#define BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_CURRENT_RXSM_STATEf_SET(r,f) (r).cl82_rx_live_sts[0]=(((r).cl82_rx_live_sts[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access CL82_RX_LIVE_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_RX_LIVE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr,(_r._cl82_rx_live_sts))
#define BCMI_TSCD_XGXS_WRITE_CL82_RX_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr,(_r._cl82_rx_live_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_RX_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr,(_r._cl82_rx_live_sts))
#define BCMI_TSCD_XGXS_READLN_CL82_RX_LIVE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_live_sts))
#define BCMI_TSCD_XGXS_WRITELN_CL82_RX_LIVE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_live_sts))
#define BCMI_TSCD_XGXS_WRITEALL_CL82_RX_LIVE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_rx_live_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_LIVE_STSr BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr
#define CL82_RX_LIVE_STSr_SIZE BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_SIZE
typedef BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_t CL82_RX_LIVE_STSr_t;
#define CL82_RX_LIVE_STSr_CLR BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_CLR
#define CL82_RX_LIVE_STSr_SET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_SET
#define CL82_RX_LIVE_STSr_GET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_GET
#define CL82_RX_LIVE_STSr_DESKEW_STATEf_GET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_DESKEW_STATEf_GET
#define CL82_RX_LIVE_STSr_DESKEW_STATEf_SET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_DESKEW_STATEf_SET
#define CL82_RX_LIVE_STSr_R_TYPE_CODEDf_GET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_R_TYPE_CODEDf_GET
#define CL82_RX_LIVE_STSr_R_TYPE_CODEDf_SET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_R_TYPE_CODEDf_SET
#define CL82_RX_LIVE_STSr_CURRENT_RXSM_STATEf_GET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_CURRENT_RXSM_STATEf_GET
#define CL82_RX_LIVE_STSr_CURRENT_RXSM_STATEf_SET BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr_CURRENT_RXSM_STATEf_SET
#define READ_CL82_RX_LIVE_STSr BCMI_TSCD_XGXS_READ_CL82_RX_LIVE_STSr
#define WRITE_CL82_RX_LIVE_STSr BCMI_TSCD_XGXS_WRITE_CL82_RX_LIVE_STSr
#define MODIFY_CL82_RX_LIVE_STSr BCMI_TSCD_XGXS_MODIFY_CL82_RX_LIVE_STSr
#define READLN_CL82_RX_LIVE_STSr BCMI_TSCD_XGXS_READLN_CL82_RX_LIVE_STSr
#define WRITELN_CL82_RX_LIVE_STSr BCMI_TSCD_XGXS_WRITELN_CL82_RX_LIVE_STSr
#define WRITEALL_CL82_RX_LIVE_STSr BCMI_TSCD_XGXS_WRITEALL_CL82_RX_LIVE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_RX_LIVE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_RX_LATCH_STS
 * BLOCKS:   CL82
 * REGADDR:  0xa081
 * DESC:     cl82 rx latched deskew and decoder status register
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     DESKEW_HIS_STATE Deskew history statesclear on read
 *     HISTORY_RXSM_STATE Recieve fsm - latched history state
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr (0x0020a081 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL82_RX_LATCH_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t cl82_rx_latch_sts[1];
	uint32_t _cl82_rx_latch_sts;
} BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_t;

#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_CLR(r) (r).cl82_rx_latch_sts[0] = 0
#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_SET(r,d) (r).cl82_rx_latch_sts[0] = d
#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_GET(r) (r).cl82_rx_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_HISTORY_RXSM_STATEf_GET(r) ((((r).cl82_rx_latch_sts[0]) >> 2) & 0x7f)
#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_HISTORY_RXSM_STATEf_SET(r,f) (r).cl82_rx_latch_sts[0]=(((r).cl82_rx_latch_sts[0] & ~((uint32_t)0x7f << 2)) | ((((uint32_t)f) & 0x7f) << 2)) | (127 << (16 + 2))
#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_DESKEW_HIS_STATEf_GET(r) (((r).cl82_rx_latch_sts[0]) & 0x3)
#define BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_DESKEW_HIS_STATEf_SET(r,f) (r).cl82_rx_latch_sts[0]=(((r).cl82_rx_latch_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access CL82_RX_LATCH_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_RX_LATCH_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr,(_r._cl82_rx_latch_sts))
#define BCMI_TSCD_XGXS_WRITE_CL82_RX_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr,(_r._cl82_rx_latch_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_RX_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr,(_r._cl82_rx_latch_sts))
#define BCMI_TSCD_XGXS_READLN_CL82_RX_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_latch_sts))
#define BCMI_TSCD_XGXS_WRITELN_CL82_RX_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_rx_latch_sts))
#define BCMI_TSCD_XGXS_WRITEALL_CL82_RX_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_rx_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_RX_LATCH_STSr BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr
#define CL82_RX_LATCH_STSr_SIZE BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_SIZE
typedef BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_t CL82_RX_LATCH_STSr_t;
#define CL82_RX_LATCH_STSr_CLR BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_CLR
#define CL82_RX_LATCH_STSr_SET BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_SET
#define CL82_RX_LATCH_STSr_GET BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_GET
#define CL82_RX_LATCH_STSr_HISTORY_RXSM_STATEf_GET BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_HISTORY_RXSM_STATEf_GET
#define CL82_RX_LATCH_STSr_HISTORY_RXSM_STATEf_SET BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_HISTORY_RXSM_STATEf_SET
#define CL82_RX_LATCH_STSr_DESKEW_HIS_STATEf_GET BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_DESKEW_HIS_STATEf_GET
#define CL82_RX_LATCH_STSr_DESKEW_HIS_STATEf_SET BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr_DESKEW_HIS_STATEf_SET
#define READ_CL82_RX_LATCH_STSr BCMI_TSCD_XGXS_READ_CL82_RX_LATCH_STSr
#define WRITE_CL82_RX_LATCH_STSr BCMI_TSCD_XGXS_WRITE_CL82_RX_LATCH_STSr
#define MODIFY_CL82_RX_LATCH_STSr BCMI_TSCD_XGXS_MODIFY_CL82_RX_LATCH_STSr
#define READLN_CL82_RX_LATCH_STSr BCMI_TSCD_XGXS_READLN_CL82_RX_LATCH_STSr
#define WRITELN_CL82_RX_LATCH_STSr BCMI_TSCD_XGXS_WRITELN_CL82_RX_LATCH_STSr
#define WRITEALL_CL82_RX_LATCH_STSr BCMI_TSCD_XGXS_WRITEALL_CL82_RX_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_RX_LATCH_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_BER_LO
 * BLOCKS:   CL82
 * REGADDR:  0xa082
 * DESC:     CL82 BER LOWER ORDER bits register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BER_LO           Lower 8 bits of CL82 BER count.It counts the number of times BER_BAD_SH state is entered.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_BER_LOr (0x0020a082 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_BER_LOr_SIZE 4

/*
 * This structure should be used to declare and program CL82_BER_LO.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_BER_LOr_s {
	uint32_t v[1];
	uint32_t cl82_ber_lo[1];
	uint32_t _cl82_ber_lo;
} BCMI_TSCD_XGXS_CL82_BER_LOr_t;

#define BCMI_TSCD_XGXS_CL82_BER_LOr_CLR(r) (r).cl82_ber_lo[0] = 0
#define BCMI_TSCD_XGXS_CL82_BER_LOr_SET(r,d) (r).cl82_ber_lo[0] = d
#define BCMI_TSCD_XGXS_CL82_BER_LOr_GET(r) (r).cl82_ber_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_BER_LOr_BER_LOf_GET(r) (((r).cl82_ber_lo[0]) & 0xff)
#define BCMI_TSCD_XGXS_CL82_BER_LOr_BER_LOf_SET(r,f) (r).cl82_ber_lo[0]=(((r).cl82_ber_lo[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access CL82_BER_LO.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_BER_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_BER_LOr,(_r._cl82_ber_lo))
#define BCMI_TSCD_XGXS_WRITE_CL82_BER_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_LOr,(_r._cl82_ber_lo)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_BER_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_LOr,(_r._cl82_ber_lo))
#define BCMI_TSCD_XGXS_READLN_CL82_BER_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_BER_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_ber_lo))
#define BCMI_TSCD_XGXS_WRITELN_CL82_BER_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_ber_lo))
#define BCMI_TSCD_XGXS_WRITEALL_CL82_BER_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_ber_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_BER_LOr BCMI_TSCD_XGXS_CL82_BER_LOr
#define CL82_BER_LOr_SIZE BCMI_TSCD_XGXS_CL82_BER_LOr_SIZE
typedef BCMI_TSCD_XGXS_CL82_BER_LOr_t CL82_BER_LOr_t;
#define CL82_BER_LOr_CLR BCMI_TSCD_XGXS_CL82_BER_LOr_CLR
#define CL82_BER_LOr_SET BCMI_TSCD_XGXS_CL82_BER_LOr_SET
#define CL82_BER_LOr_GET BCMI_TSCD_XGXS_CL82_BER_LOr_GET
#define CL82_BER_LOr_BER_LOf_GET BCMI_TSCD_XGXS_CL82_BER_LOr_BER_LOf_GET
#define CL82_BER_LOr_BER_LOf_SET BCMI_TSCD_XGXS_CL82_BER_LOr_BER_LOf_SET
#define READ_CL82_BER_LOr BCMI_TSCD_XGXS_READ_CL82_BER_LOr
#define WRITE_CL82_BER_LOr BCMI_TSCD_XGXS_WRITE_CL82_BER_LOr
#define MODIFY_CL82_BER_LOr BCMI_TSCD_XGXS_MODIFY_CL82_BER_LOr
#define READLN_CL82_BER_LOr BCMI_TSCD_XGXS_READLN_CL82_BER_LOr
#define WRITELN_CL82_BER_LOr BCMI_TSCD_XGXS_WRITELN_CL82_BER_LOr
#define WRITEALL_CL82_BER_LOr BCMI_TSCD_XGXS_WRITEALL_CL82_BER_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_BER_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_BER_HO
 * BLOCKS:   CL82
 * REGADDR:  0xa083
 * DESC:     CL82 BER HIGH ORDER bits register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BER_HO           Upper 14 bits of CL82 BER count.It counts the number of times BER_BAD_SH state is entered.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_BER_HOr (0x0020a083 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_BER_HOr_SIZE 4

/*
 * This structure should be used to declare and program CL82_BER_HO.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_BER_HOr_s {
	uint32_t v[1];
	uint32_t cl82_ber_ho[1];
	uint32_t _cl82_ber_ho;
} BCMI_TSCD_XGXS_CL82_BER_HOr_t;

#define BCMI_TSCD_XGXS_CL82_BER_HOr_CLR(r) (r).cl82_ber_ho[0] = 0
#define BCMI_TSCD_XGXS_CL82_BER_HOr_SET(r,d) (r).cl82_ber_ho[0] = d
#define BCMI_TSCD_XGXS_CL82_BER_HOr_GET(r) (r).cl82_ber_ho[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_BER_HOr_BER_HOf_GET(r) (((r).cl82_ber_ho[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_CL82_BER_HOr_BER_HOf_SET(r,f) (r).cl82_ber_ho[0]=(((r).cl82_ber_ho[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access CL82_BER_HO.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_BER_HOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_BER_HOr,(_r._cl82_ber_ho))
#define BCMI_TSCD_XGXS_WRITE_CL82_BER_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_HOr,(_r._cl82_ber_ho)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_BER_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_HOr,(_r._cl82_ber_ho))
#define BCMI_TSCD_XGXS_READLN_CL82_BER_HOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_BER_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_ber_ho))
#define BCMI_TSCD_XGXS_WRITELN_CL82_BER_HOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_ber_ho))
#define BCMI_TSCD_XGXS_WRITEALL_CL82_BER_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_BER_HOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_ber_ho))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_BER_HOr BCMI_TSCD_XGXS_CL82_BER_HOr
#define CL82_BER_HOr_SIZE BCMI_TSCD_XGXS_CL82_BER_HOr_SIZE
typedef BCMI_TSCD_XGXS_CL82_BER_HOr_t CL82_BER_HOr_t;
#define CL82_BER_HOr_CLR BCMI_TSCD_XGXS_CL82_BER_HOr_CLR
#define CL82_BER_HOr_SET BCMI_TSCD_XGXS_CL82_BER_HOr_SET
#define CL82_BER_HOr_GET BCMI_TSCD_XGXS_CL82_BER_HOr_GET
#define CL82_BER_HOr_BER_HOf_GET BCMI_TSCD_XGXS_CL82_BER_HOr_BER_HOf_GET
#define CL82_BER_HOr_BER_HOf_SET BCMI_TSCD_XGXS_CL82_BER_HOr_BER_HOf_SET
#define READ_CL82_BER_HOr BCMI_TSCD_XGXS_READ_CL82_BER_HOr
#define WRITE_CL82_BER_HOr BCMI_TSCD_XGXS_WRITE_CL82_BER_HOr
#define MODIFY_CL82_BER_HOr BCMI_TSCD_XGXS_MODIFY_CL82_BER_HOr
#define READLN_CL82_BER_HOr BCMI_TSCD_XGXS_READLN_CL82_BER_HOr
#define WRITELN_CL82_BER_HOr BCMI_TSCD_XGXS_WRITELN_CL82_BER_HOr
#define WRITEALL_CL82_BER_HOr BCMI_TSCD_XGXS_WRITEALL_CL82_BER_HOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_BER_HOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  CL82_ERRED_BLKS_HO
 * BLOCKS:   CL82
 * REGADDR:  0xa084
 * DESC:     40G/100GBASE-R Errored blocks high order counter
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     ERRORED_BLOCKS_HO Error blocks counter high order bits for cl82 - CR/NRBits 21:8 of the Error blocks  counter
 *     ERRORED_BLOCKS_HO_PRESENT Error blocks counter high order bits present - ROAlways reads as 1 if this registers is implemented
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr (0x0020a084 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_SIZE 4

/*
 * This structure should be used to declare and program CL82_ERRED_BLKS_HO.
 *
 */
typedef union BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_s {
	uint32_t v[1];
	uint32_t cl82_erred_blks_ho[1];
	uint32_t _cl82_erred_blks_ho;
} BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_t;

#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_CLR(r) (r).cl82_erred_blks_ho[0] = 0
#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_SET(r,d) (r).cl82_erred_blks_ho[0] = d
#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_GET(r) (r).cl82_erred_blks_ho[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET(r) ((((r).cl82_erred_blks_ho[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET(r,f) (r).cl82_erred_blks_ho[0]=(((r).cl82_erred_blks_ho[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET(r) (((r).cl82_erred_blks_ho[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET(r,f) (r).cl82_erred_blks_ho[0]=(((r).cl82_erred_blks_ho[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access CL82_ERRED_BLKS_HO.
 *
 */
#define BCMI_TSCD_XGXS_READ_CL82_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr,(_r._cl82_erred_blks_ho))
#define BCMI_TSCD_XGXS_WRITE_CL82_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr,(_r._cl82_erred_blks_ho)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_CL82_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr,(_r._cl82_erred_blks_ho))
#define BCMI_TSCD_XGXS_READLN_CL82_ERRED_BLKS_HOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_erred_blks_ho))
#define BCMI_TSCD_XGXS_WRITELN_CL82_ERRED_BLKS_HOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl82_erred_blks_ho))
#define BCMI_TSCD_XGXS_WRITEALL_CL82_ERRED_BLKS_HOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl82_erred_blks_ho))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL82_ERRED_BLKS_HOr BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr
#define CL82_ERRED_BLKS_HOr_SIZE BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_SIZE
typedef BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_t CL82_ERRED_BLKS_HOr_t;
#define CL82_ERRED_BLKS_HOr_CLR BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_CLR
#define CL82_ERRED_BLKS_HOr_SET BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_SET
#define CL82_ERRED_BLKS_HOr_GET BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_GET
#define CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_GET
#define CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HO_PRESENTf_SET
#define CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_GET
#define CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr_ERRORED_BLOCKS_HOf_SET
#define READ_CL82_ERRED_BLKS_HOr BCMI_TSCD_XGXS_READ_CL82_ERRED_BLKS_HOr
#define WRITE_CL82_ERRED_BLKS_HOr BCMI_TSCD_XGXS_WRITE_CL82_ERRED_BLKS_HOr
#define MODIFY_CL82_ERRED_BLKS_HOr BCMI_TSCD_XGXS_MODIFY_CL82_ERRED_BLKS_HOr
#define READLN_CL82_ERRED_BLKS_HOr BCMI_TSCD_XGXS_READLN_CL82_ERRED_BLKS_HOr
#define WRITELN_CL82_ERRED_BLKS_HOr BCMI_TSCD_XGXS_WRITELN_CL82_ERRED_BLKS_HOr
#define WRITEALL_CL82_ERRED_BLKS_HOr BCMI_TSCD_XGXS_WRITEALL_CL82_ERRED_BLKS_HOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_CL82_ERRED_BLKS_HOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_CTL
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc010
 * DESC:     PMD lane reset controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_DP_H_RSTB     PMD lane datapath reset override valueOnly used for Speed Control bypass operation
 *     LN_H_RSTB        Reset all lane logic: data path and registers
 *     LN_TX_H_PWRDN    Lane power down, TX direction
 *     LN_RX_H_PWRDN    Lane power down, RX direction
 *     TX_DISABLE       Set to squelch the transmit signal for laneOnly used for Speed Control bypass operation and local loopback
 *     OSR_MODE         OSR mode. In current implementation only OSR mode 1 is usedOnly used for Speed Control bypass operation
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_CTLr (0x0000c010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ctl[1];
	uint32_t _pmd_x4_ctl;
} BCMI_TSCD_XGXS_PMD_X4_CTLr_t;

#define BCMI_TSCD_XGXS_PMD_X4_CTLr_CLR(r) (r).pmd_x4_ctl[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_SET(r,d) (r).pmd_x4_ctl[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_GET(r) (r).pmd_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_OSR_MODEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 9) & 0xf)
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_OSR_MODEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0xf << 9)) | ((((uint32_t)f) & 0xf) << 9)) | (15 << (16 + 9))
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET(r) ((((r).pmd_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET(r) ((((r).pmd_x4_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_H_RSTBf_GET(r) ((((r).pmd_x4_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_GET(r) (((r).pmd_x4_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_SET(r,f) (r).pmd_x4_ctl[0]=(((r).pmd_x4_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_CTLr,(_r._pmd_x4_ctl))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_CTLr BCMI_TSCD_XGXS_PMD_X4_CTLr
#define PMD_X4_CTLr_SIZE BCMI_TSCD_XGXS_PMD_X4_CTLr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_CTLr_t PMD_X4_CTLr_t;
#define PMD_X4_CTLr_CLR BCMI_TSCD_XGXS_PMD_X4_CTLr_CLR
#define PMD_X4_CTLr_SET BCMI_TSCD_XGXS_PMD_X4_CTLr_SET
#define PMD_X4_CTLr_GET BCMI_TSCD_XGXS_PMD_X4_CTLr_GET
#define PMD_X4_CTLr_OSR_MODEf_GET BCMI_TSCD_XGXS_PMD_X4_CTLr_OSR_MODEf_GET
#define PMD_X4_CTLr_OSR_MODEf_SET BCMI_TSCD_XGXS_PMD_X4_CTLr_OSR_MODEf_SET
#define PMD_X4_CTLr_TX_DISABLEf_GET BCMI_TSCD_XGXS_PMD_X4_CTLr_TX_DISABLEf_GET
#define PMD_X4_CTLr_TX_DISABLEf_SET BCMI_TSCD_XGXS_PMD_X4_CTLr_TX_DISABLEf_SET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_GET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_RX_H_PWRDNf_SET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_RX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_GET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_GET
#define PMD_X4_CTLr_LN_TX_H_PWRDNf_SET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_TX_H_PWRDNf_SET
#define PMD_X4_CTLr_LN_H_RSTBf_GET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_H_RSTBf_GET
#define PMD_X4_CTLr_LN_H_RSTBf_SET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_H_RSTBf_SET
#define PMD_X4_CTLr_LN_DP_H_RSTBf_GET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_GET
#define PMD_X4_CTLr_LN_DP_H_RSTBf_SET BCMI_TSCD_XGXS_PMD_X4_CTLr_LN_DP_H_RSTBf_SET
#define READ_PMD_X4_CTLr BCMI_TSCD_XGXS_READ_PMD_X4_CTLr
#define WRITE_PMD_X4_CTLr BCMI_TSCD_XGXS_WRITE_PMD_X4_CTLr
#define MODIFY_PMD_X4_CTLr BCMI_TSCD_XGXS_MODIFY_PMD_X4_CTLr
#define READLN_PMD_X4_CTLr BCMI_TSCD_XGXS_READLN_PMD_X4_CTLr
#define WRITELN_PMD_X4_CTLr BCMI_TSCD_XGXS_WRITELN_PMD_X4_CTLr
#define WRITEALL_PMD_X4_CTLr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_MODE
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc011
 * DESC:     PMD lane mode configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_MODE        Lane modeOnly used for Speed Control bypass operationBits 15:11 - Reserved.Bit  10    - cl72_en.Bit   9    - scrambler_disabled.Bit   8    - eee_mode_en.Bits  7:0  - speed_id.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_MODEr (0x0000c011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_MODEr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_MODE.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_MODEr_s {
	uint32_t v[1];
	uint32_t pmd_x4_mode[1];
	uint32_t _pmd_x4_mode;
} BCMI_TSCD_XGXS_PMD_X4_MODEr_t;

#define BCMI_TSCD_XGXS_PMD_X4_MODEr_CLR(r) (r).pmd_x4_mode[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_MODEr_SET(r,d) (r).pmd_x4_mode[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_MODEr_GET(r) (r).pmd_x4_mode[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_MODEr_LANE_MODEf_GET(r) (((r).pmd_x4_mode[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PMD_X4_MODEr_LANE_MODEf_SET(r,f) (r).pmd_x4_mode[0]=(((r).pmd_x4_mode[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X4_MODE.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_MODEr,(_r._pmd_x4_mode))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_MODEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_MODEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_mode))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_MODEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_MODEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_mode))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_MODEr BCMI_TSCD_XGXS_PMD_X4_MODEr
#define PMD_X4_MODEr_SIZE BCMI_TSCD_XGXS_PMD_X4_MODEr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_MODEr_t PMD_X4_MODEr_t;
#define PMD_X4_MODEr_CLR BCMI_TSCD_XGXS_PMD_X4_MODEr_CLR
#define PMD_X4_MODEr_SET BCMI_TSCD_XGXS_PMD_X4_MODEr_SET
#define PMD_X4_MODEr_GET BCMI_TSCD_XGXS_PMD_X4_MODEr_GET
#define PMD_X4_MODEr_LANE_MODEf_GET BCMI_TSCD_XGXS_PMD_X4_MODEr_LANE_MODEf_GET
#define PMD_X4_MODEr_LANE_MODEf_SET BCMI_TSCD_XGXS_PMD_X4_MODEr_LANE_MODEf_SET
#define READ_PMD_X4_MODEr BCMI_TSCD_XGXS_READ_PMD_X4_MODEr
#define WRITE_PMD_X4_MODEr BCMI_TSCD_XGXS_WRITE_PMD_X4_MODEr
#define MODIFY_PMD_X4_MODEr BCMI_TSCD_XGXS_MODIFY_PMD_X4_MODEr
#define READLN_PMD_X4_MODEr BCMI_TSCD_XGXS_READLN_PMD_X4_MODEr
#define WRITELN_PMD_X4_MODEr BCMI_TSCD_XGXS_WRITELN_PMD_X4_MODEr
#define WRITEALL_PMD_X4_MODEr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_MODEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc012
 * DESC:     PMD lane status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_LOCK_STS      DSC RX lock indication from PMD
 *     SIGNAL_DETECT_STS Signal Detect indication from PMD
 *     RX_CLK_VLD_STS   rx_clk_vld indication from PMD
 *     TX_CLK_VLD_STS   tx_clk_vld indication from PMD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_STSr (0x0000c012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_sts[1];
	uint32_t _pmd_x4_sts;
} BCMI_TSCD_XGXS_PMD_X4_STSr_t;

#define BCMI_TSCD_XGXS_PMD_X4_STSr_CLR(r) (r).pmd_x4_sts[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_STSr_SET(r,d) (r).pmd_x4_sts[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_STSr_GET(r) (r).pmd_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET(r) ((((r).pmd_x4_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET(r) (((r).pmd_x4_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET(r,f) (r).pmd_x4_sts[0]=(((r).pmd_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_STSr,(_r._pmd_x4_sts))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_sts))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_STSr BCMI_TSCD_XGXS_PMD_X4_STSr
#define PMD_X4_STSr_SIZE BCMI_TSCD_XGXS_PMD_X4_STSr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_STSr_t PMD_X4_STSr_t;
#define PMD_X4_STSr_CLR BCMI_TSCD_XGXS_PMD_X4_STSr_CLR
#define PMD_X4_STSr_SET BCMI_TSCD_XGXS_PMD_X4_STSr_SET
#define PMD_X4_STSr_GET BCMI_TSCD_XGXS_PMD_X4_STSr_GET
#define PMD_X4_STSr_TX_CLK_VLD_STSf_GET BCMI_TSCD_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_GET
#define PMD_X4_STSr_TX_CLK_VLD_STSf_SET BCMI_TSCD_XGXS_PMD_X4_STSr_TX_CLK_VLD_STSf_SET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_GET BCMI_TSCD_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_GET
#define PMD_X4_STSr_RX_CLK_VLD_STSf_SET BCMI_TSCD_XGXS_PMD_X4_STSr_RX_CLK_VLD_STSf_SET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_GET BCMI_TSCD_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_GET
#define PMD_X4_STSr_SIGNAL_DETECT_STSf_SET BCMI_TSCD_XGXS_PMD_X4_STSr_SIGNAL_DETECT_STSf_SET
#define PMD_X4_STSr_RX_LOCK_STSf_GET BCMI_TSCD_XGXS_PMD_X4_STSr_RX_LOCK_STSf_GET
#define PMD_X4_STSr_RX_LOCK_STSf_SET BCMI_TSCD_XGXS_PMD_X4_STSr_RX_LOCK_STSf_SET
#define READ_PMD_X4_STSr BCMI_TSCD_XGXS_READ_PMD_X4_STSr
#define WRITE_PMD_X4_STSr BCMI_TSCD_XGXS_WRITE_PMD_X4_STSr
#define MODIFY_PMD_X4_STSr BCMI_TSCD_XGXS_MODIFY_PMD_X4_STSr
#define READLN_PMD_X4_STSr BCMI_TSCD_XGXS_READLN_PMD_X4_STSr
#define WRITELN_PMD_X4_STSr BCMI_TSCD_XGXS_WRITELN_PMD_X4_STSr
#define WRITEALL_PMD_X4_STSr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_LATCH_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc013
 * DESC:     PMD lane latched status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOCK_LL       DSC RX lock indication from PMD negedge detected
 *     RX_LOCK_LH       DSC RX lock indication from PMD posedge detected
 *     SIGNAL_DETECT_LL Signal Detect indication from PMD negedge detected
 *     SIGNAL_DETECT_LH Signal Detect indication from PMD posedge detected
 *     RX_CLK_VLD_LL    rx_clk_vld indication from PMD negedge detected
 *     RX_CLK_VLD_LH    rx_clk_vld indication from PMD posedge detected
 *     RX_LOCK_LIVE     DSC RX lock live indication from PMDSame as the pmd_x4_status register field.
 *     SIGNAL_DETECT_LIVE Signal Detect live indication from PMDSame as the pmd_x4_status register field.
 *     RX_CLK_VLD_LIVE  rx_clk_vld live indication from PMDSame as the pmd_x4_status register field.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr (0x0000c013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_LATCH_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_latch_sts[1];
	uint32_t _pmd_x4_latch_sts;
} BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_t;

#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_CLR(r) (r).pmd_x4_latch_sts[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SET(r,d) (r).pmd_x4_latch_sts[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_GET(r) (r).pmd_x4_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET(r) ((((r).pmd_x4_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET(r) (((r).pmd_x4_latch_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET(r,f) (r).pmd_x4_latch_sts[0]=(((r).pmd_x4_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_LATCH_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr,(_r._pmd_x4_latch_sts))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_latch_sts))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_LATCH_STSr BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr
#define PMD_X4_LATCH_STSr_SIZE BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_t PMD_X4_LATCH_STSr_t;
#define PMD_X4_LATCH_STSr_CLR BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_CLR
#define PMD_X4_LATCH_STSr_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SET
#define PMD_X4_LATCH_STSr_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LIVEf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LIVEf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LIVEf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LHf_SET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_GET
#define PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_CLK_VLD_LLf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LHf_SET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_GET
#define PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_SIGNAL_DETECT_LLf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LHf_SET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_GET
#define PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr_RX_LOCK_LLf_SET
#define READ_PMD_X4_LATCH_STSr BCMI_TSCD_XGXS_READ_PMD_X4_LATCH_STSr
#define WRITE_PMD_X4_LATCH_STSr BCMI_TSCD_XGXS_WRITE_PMD_X4_LATCH_STSr
#define MODIFY_PMD_X4_LATCH_STSr BCMI_TSCD_XGXS_MODIFY_PMD_X4_LATCH_STSr
#define READLN_PMD_X4_LATCH_STSr BCMI_TSCD_XGXS_READLN_PMD_X4_LATCH_STSr
#define WRITELN_PMD_X4_LATCH_STSr BCMI_TSCD_XGXS_WRITELN_PMD_X4_LATCH_STSr
#define WRITEALL_PMD_X4_LATCH_STSr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_LATCH_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_OVRR
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc014
 * DESC:     PMD lane override
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LOCK_OVRD     Override for DSC RX lock indication from PMD
 *     SIGNAL_DETECT_OVRD Override for Signal Detect indication from PMD
 *     RX_CLK_VLD_OVRD  Override rx_clk_vld indication from PMD
 *     LANE_MODE_OEN    Lane mode override enable
 *     OSR_MODE_OEN     OSR mode, overrideOnly used for Speed Control bypass operation
 *     TX_DISABLE_OEN   tx_disable override enableOnly used for Speed Control bypass operation and local loopback.
 *     LN_DP_H_RSTB_OEN PMD Lane Datapath reset override enableOnly used for Speed Control bypass operation
 *     TX_CLK_VLD_OVRD  Override tx_clk_vld indication from PMD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr (0x0000c014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_OVRR.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_OVRRr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ovrr[1];
	uint32_t _pmd_x4_ovrr;
} BCMI_TSCD_XGXS_PMD_X4_OVRRr_t;

#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_CLR(r) (r).pmd_x4_ovrr[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_SET(r,d) (r).pmd_x4_ovrr[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_GET(r) (r).pmd_x4_ovrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET(r) ((((r).pmd_x4_ovrr[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET(r) (((r).pmd_x4_ovrr[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET(r,f) (r).pmd_x4_ovrr[0]=(((r).pmd_x4_ovrr[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_OVRR.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_OVRRr,(_r._pmd_x4_ovrr))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_OVRRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_OVRRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ovrr))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_OVRRr BCMI_TSCD_XGXS_PMD_X4_OVRRr
#define PMD_X4_OVRRr_SIZE BCMI_TSCD_XGXS_PMD_X4_OVRRr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_OVRRr_t PMD_X4_OVRRr_t;
#define PMD_X4_OVRRr_CLR BCMI_TSCD_XGXS_PMD_X4_OVRRr_CLR
#define PMD_X4_OVRRr_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_SET
#define PMD_X4_OVRRr_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_GET
#define PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_GET
#define PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_CLK_VLD_OVRDf_SET
#define PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_GET
#define PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_LN_DP_H_RSTB_OENf_SET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_GET
#define PMD_X4_OVRRr_TX_DISABLE_OENf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_TX_DISABLE_OENf_SET
#define PMD_X4_OVRRr_OSR_MODE_OENf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_GET
#define PMD_X4_OVRRr_OSR_MODE_OENf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_OSR_MODE_OENf_SET
#define PMD_X4_OVRRr_LANE_MODE_OENf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_GET
#define PMD_X4_OVRRr_LANE_MODE_OENf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_LANE_MODE_OENf_SET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_GET
#define PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_CLK_VLD_OVRDf_SET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_GET
#define PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_SIGNAL_DETECT_OVRDf_SET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_GET BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_GET
#define PMD_X4_OVRRr_RX_LOCK_OVRDf_SET BCMI_TSCD_XGXS_PMD_X4_OVRRr_RX_LOCK_OVRDf_SET
#define READ_PMD_X4_OVRRr BCMI_TSCD_XGXS_READ_PMD_X4_OVRRr
#define WRITE_PMD_X4_OVRRr BCMI_TSCD_XGXS_WRITE_PMD_X4_OVRRr
#define MODIFY_PMD_X4_OVRRr BCMI_TSCD_XGXS_MODIFY_PMD_X4_OVRRr
#define READLN_PMD_X4_OVRRr BCMI_TSCD_XGXS_READLN_PMD_X4_OVRRr
#define WRITELN_PMD_X4_OVRRr BCMI_TSCD_XGXS_WRITELN_PMD_X4_OVRRr
#define WRITEALL_PMD_X4_OVRRr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_OVRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_EEE_CTL
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc018
 * DESC:     PMD lane eee controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_MODE          EEE tx low power modeEEE low power operation is not supported by TSC
 *     RX_MODE          EEE rx low power modeEEE low power operation is not supported by TSC
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr (0x0000c018 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_EEE_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_s {
	uint32_t v[1];
	uint32_t pmd_x4_eee_ctl[1];
	uint32_t _pmd_x4_eee_ctl;
} BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_t;

#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_CLR(r) (r).pmd_x4_eee_ctl[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_SET(r,d) (r).pmd_x4_eee_ctl[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_GET(r) (r).pmd_x4_eee_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_GET(r) ((((r).pmd_x4_eee_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_SET(r,f) (r).pmd_x4_eee_ctl[0]=(((r).pmd_x4_eee_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_GET(r) (((r).pmd_x4_eee_ctl[0]) & 0x3)
#define BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_SET(r,f) (r).pmd_x4_eee_ctl[0]=(((r).pmd_x4_eee_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access PMD_X4_EEE_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr,(_r._pmd_x4_eee_ctl))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_EEE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_ctl))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_EEE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_EEE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_eee_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_EEE_CTLr BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr
#define PMD_X4_EEE_CTLr_SIZE BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_t PMD_X4_EEE_CTLr_t;
#define PMD_X4_EEE_CTLr_CLR BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_CLR
#define PMD_X4_EEE_CTLr_SET BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_SET
#define PMD_X4_EEE_CTLr_GET BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_GET
#define PMD_X4_EEE_CTLr_RX_MODEf_GET BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_GET
#define PMD_X4_EEE_CTLr_RX_MODEf_SET BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_RX_MODEf_SET
#define PMD_X4_EEE_CTLr_TX_MODEf_GET BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_GET
#define PMD_X4_EEE_CTLr_TX_MODEf_SET BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr_TX_MODEf_SET
#define READ_PMD_X4_EEE_CTLr BCMI_TSCD_XGXS_READ_PMD_X4_EEE_CTLr
#define WRITE_PMD_X4_EEE_CTLr BCMI_TSCD_XGXS_WRITE_PMD_X4_EEE_CTLr
#define MODIFY_PMD_X4_EEE_CTLr BCMI_TSCD_XGXS_MODIFY_PMD_X4_EEE_CTLr
#define READLN_PMD_X4_EEE_CTLr BCMI_TSCD_XGXS_READLN_PMD_X4_EEE_CTLr
#define WRITELN_PMD_X4_EEE_CTLr BCMI_TSCD_XGXS_WRITELN_PMD_X4_EEE_CTLr
#define WRITEALL_PMD_X4_EEE_CTLr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_EEE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_EEE_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_EEE_STS
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc019
 * DESC:     PMD lane eee status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     ENERGY_DETECT    EEE Energy detection indication from PMDEEE low power operation is not supported by TSC
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_EEE_STSr (0x0000c019 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_EEE_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_s {
	uint32_t v[1];
	uint32_t pmd_x4_eee_sts[1];
	uint32_t _pmd_x4_eee_sts;
} BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_t;

#define BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_CLR(r) (r).pmd_x4_eee_sts[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_SET(r,d) (r).pmd_x4_eee_sts[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_GET(r) (r).pmd_x4_eee_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_GET(r) (((r).pmd_x4_eee_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_SET(r,f) (r).pmd_x4_eee_sts[0]=(((r).pmd_x4_eee_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PMD_X4_EEE_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_STSr,(_r._pmd_x4_eee_sts))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_EEE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_sts))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_EEE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_eee_sts))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_EEE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_EEE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_eee_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_EEE_STSr BCMI_TSCD_XGXS_PMD_X4_EEE_STSr
#define PMD_X4_EEE_STSr_SIZE BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_t PMD_X4_EEE_STSr_t;
#define PMD_X4_EEE_STSr_CLR BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_CLR
#define PMD_X4_EEE_STSr_SET BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_SET
#define PMD_X4_EEE_STSr_GET BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_GET
#define PMD_X4_EEE_STSr_ENERGY_DETECTf_GET BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_GET
#define PMD_X4_EEE_STSr_ENERGY_DETECTf_SET BCMI_TSCD_XGXS_PMD_X4_EEE_STSr_ENERGY_DETECTf_SET
#define READ_PMD_X4_EEE_STSr BCMI_TSCD_XGXS_READ_PMD_X4_EEE_STSr
#define WRITE_PMD_X4_EEE_STSr BCMI_TSCD_XGXS_WRITE_PMD_X4_EEE_STSr
#define MODIFY_PMD_X4_EEE_STSr BCMI_TSCD_XGXS_MODIFY_PMD_X4_EEE_STSr
#define READLN_PMD_X4_EEE_STSr BCMI_TSCD_XGXS_READLN_PMD_X4_EEE_STSr
#define WRITELN_PMD_X4_EEE_STSr BCMI_TSCD_XGXS_WRITELN_PMD_X4_EEE_STSr
#define WRITEALL_PMD_X4_EEE_STSr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_EEE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_EEE_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_UI_VALUE_HI
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc01a
 * DESC:     PMD lane bit-time in fractional nanoseconds, upper.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UI_FRAC_M1_TO_M16 PMD lane bit-time in fractional nanoseconds, upper bitsMost significant 16 bits. 2^ minus1 down to 2^ minus16bit 15 is 0.5, bit 14 is 0.25 and so on.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr (0x0000c01a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_UI_VALUE_HI.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ui_value_hi[1];
	uint32_t _pmd_x4_ui_value_hi;
} BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_t;

#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_CLR(r) (r).pmd_x4_ui_value_hi[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_SET(r,d) (r).pmd_x4_ui_value_hi[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_GET(r) (r).pmd_x4_ui_value_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_GET(r) (((r).pmd_x4_ui_value_hi[0]) & 0xffff)
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_SET(r,f) (r).pmd_x4_ui_value_hi[0]=(((r).pmd_x4_ui_value_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PMD_X4_UI_VALUE_HI.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr,(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr,(_r._pmd_x4_ui_value_hi)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr,(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_UI_VALUE_HIr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_UI_VALUE_HIr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_hi))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_UI_VALUE_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ui_value_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_UI_VALUE_HIr BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr
#define PMD_X4_UI_VALUE_HIr_SIZE BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_t PMD_X4_UI_VALUE_HIr_t;
#define PMD_X4_UI_VALUE_HIr_CLR BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_CLR
#define PMD_X4_UI_VALUE_HIr_SET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_SET
#define PMD_X4_UI_VALUE_HIr_GET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_GET
#define PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_GET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_GET
#define PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_SET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr_UI_FRAC_M1_TO_M16f_SET
#define READ_PMD_X4_UI_VALUE_HIr BCMI_TSCD_XGXS_READ_PMD_X4_UI_VALUE_HIr
#define WRITE_PMD_X4_UI_VALUE_HIr BCMI_TSCD_XGXS_WRITE_PMD_X4_UI_VALUE_HIr
#define MODIFY_PMD_X4_UI_VALUE_HIr BCMI_TSCD_XGXS_MODIFY_PMD_X4_UI_VALUE_HIr
#define READLN_PMD_X4_UI_VALUE_HIr BCMI_TSCD_XGXS_READLN_PMD_X4_UI_VALUE_HIr
#define WRITELN_PMD_X4_UI_VALUE_HIr BCMI_TSCD_XGXS_WRITELN_PMD_X4_UI_VALUE_HIr
#define WRITEALL_PMD_X4_UI_VALUE_HIr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_UI_VALUE_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_UI_VALUE_LO
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc01b
 * DESC:     PMD lane bit-time in fractional nanoseconds, lower.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UI_FRAC_M17_TO_M25 PMD lane bit-time in fractional nanoseconds, lower bitsLeast significant 7 bits.bit 15 is 2^ minus17, bit 7 is 2^ minus25.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr (0x0000c01b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_UI_VALUE_LO.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_s {
	uint32_t v[1];
	uint32_t pmd_x4_ui_value_lo[1];
	uint32_t _pmd_x4_ui_value_lo;
} BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_t;

#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_CLR(r) (r).pmd_x4_ui_value_lo[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_SET(r,d) (r).pmd_x4_ui_value_lo[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_GET(r) (r).pmd_x4_ui_value_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M25f_GET(r) ((((r).pmd_x4_ui_value_lo[0]) >> 7) & 0x1ff)
#define BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M25f_SET(r,f) (r).pmd_x4_ui_value_lo[0]=(((r).pmd_x4_ui_value_lo[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))

/*
 * These macros can be used to access PMD_X4_UI_VALUE_LO.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr,(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr,(_r._pmd_x4_ui_value_lo)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr,(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_UI_VALUE_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_UI_VALUE_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_ui_value_lo))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_UI_VALUE_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_ui_value_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_UI_VALUE_LOr BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr
#define PMD_X4_UI_VALUE_LOr_SIZE BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_t PMD_X4_UI_VALUE_LOr_t;
#define PMD_X4_UI_VALUE_LOr_CLR BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_CLR
#define PMD_X4_UI_VALUE_LOr_SET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_SET
#define PMD_X4_UI_VALUE_LOr_GET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_GET
#define PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M25f_GET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M25f_GET
#define PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M25f_SET BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr_UI_FRAC_M17_TO_M25f_SET
#define READ_PMD_X4_UI_VALUE_LOr BCMI_TSCD_XGXS_READ_PMD_X4_UI_VALUE_LOr
#define WRITE_PMD_X4_UI_VALUE_LOr BCMI_TSCD_XGXS_WRITE_PMD_X4_UI_VALUE_LOr
#define MODIFY_PMD_X4_UI_VALUE_LOr BCMI_TSCD_XGXS_MODIFY_PMD_X4_UI_VALUE_LOr
#define READLN_PMD_X4_UI_VALUE_LOr BCMI_TSCD_XGXS_READLN_PMD_X4_UI_VALUE_LOr
#define WRITELN_PMD_X4_UI_VALUE_LOr BCMI_TSCD_XGXS_WRITELN_PMD_X4_UI_VALUE_LOr
#define WRITEALL_PMD_X4_UI_VALUE_LOr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_UI_VALUE_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_UI_VALUE_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_PMD_TX_FIXED_LATENCY
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc01c
 * DESC:     PMD Transmit Fixed Latency value in nanoseconds
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_TX_LATENCY_FRAC_NS Fractional Part of PMA transmit Fixed latency in nanoseconds(i.e PMD tx latency(frac_ns) + Tx Skew adjustment(frac_ns))..Signed 2s complement value as an extension of pmd_tx_latency_int_ns.bit 9 represents 2^minus1, bit 8 represents 2^minus2 and so on.In CL82 & CL48 speeds, this register can also be used to program the Tx skew adjustment for the lane, after accounting for lane swap.In Functional Tx PMA Snapshot mode, after determining the tx skew adjustment for each lane based on the reference lane,the S/W can program the Sub_Ns part of tx skew adjustmentin this register to align the timestamping point to the earliest or latest transmit lane.
 *     PMD_TX_LATENCY_INT_NS Integral Part of PMA transmit Fixed latency in nanoseconds(i.e PMD tx latency(integer) + Tx Skew adjustment(integer)).Signed 2s complement value needed. HW will sign-extend to 48 bits.The scheme of adjusting the Transmit Timestamp based on the Tx skew is OPTIONAL.In CL82 & CL48 speeds, this register can also be used to program the Tx skew adjustment for the lane, after accounting for lane swap.In Functional Tx PMA Snapshot mode: GlasTest_ActData_0_type provides the PMA bit count and GlasTest_ActAdj[7:0] has the Glas Adjust value.For Lane i, Tx_PMA_Count[i] = {GlasTest_ActData_0_type[i], GlasTest_ActAdj[i]};The absolute value of Tx PMA Count in terms of Nano-seconds and Sub-Ns is determined by the following formula.For Lane i, Tx_PMA_lane_abs_dly[i] = (GlasTest_ActData_0_type[i] * UI) +  (GlasTest_ActAdj[i] * fclk_period) ;Described below is the SW Algorithm for deriving Tx skew adjustment of 1588 TX timestamp.----------------------------------------------------------------------------------------Tx Lane PMA Count{GlasTest_ActData_0_type, GlasTest_ActAdj[7:0]} in terms of Ns and Sub-NsThe lane having the highest PMA Count is the earliest transmit lane and vice-versa----------------------------------------------------------------------------------------REFERENCE lane Selection..The reference_lane could be Earliest or Latest.----------------------------------------------------------------------------------------Tx Skew DELTA calculation.....In CL82 and CL48 modes,..For lane i, tx_skew_delta[i] = Tx_PMA_lane_abs_dly[i] - Tx_PMA_lane_abs_dly[reference_lane].If tx_skew_delta > 2048UI[in terms of (ns, Sub-ns)], then it indiacates Tx_PMA_lane_abs_dly[reference_lane] has rolled over,so add 4096UI(ns, sub-ns) to the Tx_PMA_lane_abs_dly[reference_lane] entry to find the deltaIf tx_skew_delta < -2048UI[in terms of (ns, Sub-ns)], then it indicates Tx_PMA_lane_abs_dly[i] has rolled over,so add 4096UI(ns, sub-ns) to the Tx_PMA_lane_abs_dly[i] entry to find the delta.----------------------------------------------------------------------------------------Tx Skew Adjustment calculation......In CL82 and CL48 modes, the tx skew adjustment is in terms of Ns and Sub_Ns,....for lane i, tx skew adjustment is the tx_skew_value[i] represented in 2's format to be added to PMD tx latency number--------------------------------------------------------------------------------------------The S/W can then program the Ns part of the tx skew adjustmentin this register to align the timestamping point to the earliest or latest transmit lane.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr (0x0000c01c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_PMD_TX_FIXED_LATENCY.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_s {
	uint32_t v[1];
	uint32_t pmd_x4_pmd_tx_fixed_latency[1];
	uint32_t _pmd_x4_pmd_tx_fixed_latency;
} BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_t;

#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_CLR(r) (r).pmd_x4_pmd_tx_fixed_latency[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_SET(r,d) (r).pmd_x4_pmd_tx_fixed_latency[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_GET(r) (r).pmd_x4_pmd_tx_fixed_latency[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_INT_NSf_GET(r) ((((r).pmd_x4_pmd_tx_fixed_latency[0]) >> 4) & 0xfff)
#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_INT_NSf_SET(r,f) (r).pmd_x4_pmd_tx_fixed_latency[0]=(((r).pmd_x4_pmd_tx_fixed_latency[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_FRAC_NSf_GET(r) (((r).pmd_x4_pmd_tx_fixed_latency[0]) & 0xf)
#define BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_FRAC_NSf_SET(r,f) (r).pmd_x4_pmd_tx_fixed_latency[0]=(((r).pmd_x4_pmd_tx_fixed_latency[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access PMD_X4_PMD_TX_FIXED_LATENCY.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_PMD_TX_FIXED_LATENCYr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr,(_r._pmd_x4_pmd_tx_fixed_latency))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_PMD_TX_FIXED_LATENCYr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr,(_r._pmd_x4_pmd_tx_fixed_latency)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_PMD_TX_FIXED_LATENCYr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr,(_r._pmd_x4_pmd_tx_fixed_latency))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_PMD_TX_FIXED_LATENCYr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_pmd_tx_fixed_latency))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_PMD_TX_FIXED_LATENCYr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_pmd_tx_fixed_latency))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_PMD_TX_FIXED_LATENCYr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_pmd_tx_fixed_latency))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_PMD_TX_FIXED_LATENCYr BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr
#define PMD_X4_PMD_TX_FIXED_LATENCYr_SIZE BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_t PMD_X4_PMD_TX_FIXED_LATENCYr_t;
#define PMD_X4_PMD_TX_FIXED_LATENCYr_CLR BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_CLR
#define PMD_X4_PMD_TX_FIXED_LATENCYr_SET BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_SET
#define PMD_X4_PMD_TX_FIXED_LATENCYr_GET BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_GET
#define PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_INT_NSf_GET BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_INT_NSf_GET
#define PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_INT_NSf_SET BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_INT_NSf_SET
#define PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_FRAC_NSf_GET BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_FRAC_NSf_GET
#define PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_FRAC_NSf_SET BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr_PMD_TX_LATENCY_FRAC_NSf_SET
#define READ_PMD_X4_PMD_TX_FIXED_LATENCYr BCMI_TSCD_XGXS_READ_PMD_X4_PMD_TX_FIXED_LATENCYr
#define WRITE_PMD_X4_PMD_TX_FIXED_LATENCYr BCMI_TSCD_XGXS_WRITE_PMD_X4_PMD_TX_FIXED_LATENCYr
#define MODIFY_PMD_X4_PMD_TX_FIXED_LATENCYr BCMI_TSCD_XGXS_MODIFY_PMD_X4_PMD_TX_FIXED_LATENCYr
#define READLN_PMD_X4_PMD_TX_FIXED_LATENCYr BCMI_TSCD_XGXS_READLN_PMD_X4_PMD_TX_FIXED_LATENCYr
#define WRITELN_PMD_X4_PMD_TX_FIXED_LATENCYr BCMI_TSCD_XGXS_WRITELN_PMD_X4_PMD_TX_FIXED_LATENCYr
#define WRITEALL_PMD_X4_PMD_TX_FIXED_LATENCYr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_PMD_TX_FIXED_LATENCYr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_PMD_TX_FIXED_LATENCYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_PMD_RX_FIXED_LATENCY_INT
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc01d
 * DESC:     PMD Receive Fixed Latency value(Integral Part) in nanoseconds
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DP_INT_NS    PMD RX fixed latency in nanoseconds. Signed 2s complement value. HW will sign-extend to 48 bits.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr (0x0000c01d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_PMD_RX_FIXED_LATENCY_INT.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_s {
	uint32_t v[1];
	uint32_t pmd_x4_pmd_rx_fixed_latency_int[1];
	uint32_t _pmd_x4_pmd_rx_fixed_latency_int;
} BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_t;

#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_CLR(r) (r).pmd_x4_pmd_rx_fixed_latency_int[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_SET(r,d) (r).pmd_x4_pmd_rx_fixed_latency_int[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_GET(r) (r).pmd_x4_pmd_rx_fixed_latency_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_TAB_DP_INT_NSf_GET(r) (((r).pmd_x4_pmd_rx_fixed_latency_int[0]) & 0xfff)
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_TAB_DP_INT_NSf_SET(r,f) (r).pmd_x4_pmd_rx_fixed_latency_int[0]=(((r).pmd_x4_pmd_rx_fixed_latency_int[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access PMD_X4_PMD_RX_FIXED_LATENCY_INT.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_PMD_RX_FIXED_LATENCY_INTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr,(_r._pmd_x4_pmd_rx_fixed_latency_int))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_PMD_RX_FIXED_LATENCY_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr,(_r._pmd_x4_pmd_rx_fixed_latency_int)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_PMD_RX_FIXED_LATENCY_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr,(_r._pmd_x4_pmd_rx_fixed_latency_int))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_PMD_RX_FIXED_LATENCY_INTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_pmd_rx_fixed_latency_int))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_PMD_RX_FIXED_LATENCY_INTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_pmd_rx_fixed_latency_int))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_PMD_RX_FIXED_LATENCY_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_pmd_rx_fixed_latency_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_PMD_RX_FIXED_LATENCY_INTr BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr
#define PMD_X4_PMD_RX_FIXED_LATENCY_INTr_SIZE BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_t PMD_X4_PMD_RX_FIXED_LATENCY_INTr_t;
#define PMD_X4_PMD_RX_FIXED_LATENCY_INTr_CLR BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_CLR
#define PMD_X4_PMD_RX_FIXED_LATENCY_INTr_SET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_SET
#define PMD_X4_PMD_RX_FIXED_LATENCY_INTr_GET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_GET
#define PMD_X4_PMD_RX_FIXED_LATENCY_INTr_TAB_DP_INT_NSf_GET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_TAB_DP_INT_NSf_GET
#define PMD_X4_PMD_RX_FIXED_LATENCY_INTr_TAB_DP_INT_NSf_SET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr_TAB_DP_INT_NSf_SET
#define READ_PMD_X4_PMD_RX_FIXED_LATENCY_INTr BCMI_TSCD_XGXS_READ_PMD_X4_PMD_RX_FIXED_LATENCY_INTr
#define WRITE_PMD_X4_PMD_RX_FIXED_LATENCY_INTr BCMI_TSCD_XGXS_WRITE_PMD_X4_PMD_RX_FIXED_LATENCY_INTr
#define MODIFY_PMD_X4_PMD_RX_FIXED_LATENCY_INTr BCMI_TSCD_XGXS_MODIFY_PMD_X4_PMD_RX_FIXED_LATENCY_INTr
#define READLN_PMD_X4_PMD_RX_FIXED_LATENCY_INTr BCMI_TSCD_XGXS_READLN_PMD_X4_PMD_RX_FIXED_LATENCY_INTr
#define WRITELN_PMD_X4_PMD_RX_FIXED_LATENCY_INTr BCMI_TSCD_XGXS_WRITELN_PMD_X4_PMD_RX_FIXED_LATENCY_INTr
#define WRITEALL_PMD_X4_PMD_RX_FIXED_LATENCY_INTr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_PMD_RX_FIXED_LATENCY_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  PMD_X4_PMD_RX_FIXED_LATENCY_FRAC
 * BLOCKS:   PMD_X4
 * REGADDR:  0xc01e
 * DESC:     PMD Receive Fixed Latency value(Fractional Part) in nanoseconds
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DP_FRAC_NS   PMD RX fixed latency in fractional nanoseconds. Signed 2s complement value as an extension of PMD RX latencyspecified through tab_dp_int_ns field.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr (0x0000c01e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_SIZE 4

/*
 * This structure should be used to declare and program PMD_X4_PMD_RX_FIXED_LATENCY_FRAC.
 *
 */
typedef union BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_s {
	uint32_t v[1];
	uint32_t pmd_x4_pmd_rx_fixed_latency_frac[1];
	uint32_t _pmd_x4_pmd_rx_fixed_latency_frac;
} BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_t;

#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_CLR(r) (r).pmd_x4_pmd_rx_fixed_latency_frac[0] = 0
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_SET(r,d) (r).pmd_x4_pmd_rx_fixed_latency_frac[0] = d
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_GET(r) (r).pmd_x4_pmd_rx_fixed_latency_frac[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_TAB_DP_FRAC_NSf_GET(r) ((((r).pmd_x4_pmd_rx_fixed_latency_frac[0]) >> 6) & 0x3ff)
#define BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_TAB_DP_FRAC_NSf_SET(r,f) (r).pmd_x4_pmd_rx_fixed_latency_frac[0]=(((r).pmd_x4_pmd_rx_fixed_latency_frac[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access PMD_X4_PMD_RX_FIXED_LATENCY_FRAC.
 *
 */
#define BCMI_TSCD_XGXS_READ_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr,(_r._pmd_x4_pmd_rx_fixed_latency_frac))
#define BCMI_TSCD_XGXS_WRITE_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr,(_r._pmd_x4_pmd_rx_fixed_latency_frac)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr,(_r._pmd_x4_pmd_rx_fixed_latency_frac))
#define BCMI_TSCD_XGXS_READLN_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_pmd_rx_fixed_latency_frac))
#define BCMI_TSCD_XGXS_WRITELN_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pmd_x4_pmd_rx_fixed_latency_frac))
#define BCMI_TSCD_XGXS_WRITEALL_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pmd_x4_pmd_rx_fixed_latency_frac))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PMD_X4_PMD_RX_FIXED_LATENCY_FRACr BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr
#define PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_SIZE BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_SIZE
typedef BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_t PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_t;
#define PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_CLR BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_CLR
#define PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_SET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_SET
#define PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_GET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_GET
#define PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_TAB_DP_FRAC_NSf_GET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_TAB_DP_FRAC_NSf_GET
#define PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_TAB_DP_FRAC_NSf_SET BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr_TAB_DP_FRAC_NSf_SET
#define READ_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr BCMI_TSCD_XGXS_READ_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr
#define WRITE_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr BCMI_TSCD_XGXS_WRITE_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr
#define MODIFY_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr BCMI_TSCD_XGXS_MODIFY_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr
#define READLN_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr BCMI_TSCD_XGXS_READLN_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr
#define WRITELN_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr BCMI_TSCD_XGXS_WRITELN_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr
#define WRITEALL_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr BCMI_TSCD_XGXS_WRITEALL_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_PMD_X4_PMD_RX_FIXED_LATENCY_FRACr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_CTL
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc050
 * DESC:     SW speed change control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPEED            
 *     SW_SPEED_CHANGE  Start SW speed change.HW will detect possedge of this field and start or restart the speed change logic.To restart speed change logic SW must write 0 to this bit and then write 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_CTLr (0x0000c050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_CTLr_s {
	uint32_t v[1];
	uint32_t sc_x4_ctl[1];
	uint32_t _sc_x4_ctl;
} BCMI_TSCD_XGXS_SC_X4_CTLr_t;

#define BCMI_TSCD_XGXS_SC_X4_CTLr_CLR(r) (r).sc_x4_ctl[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_CTLr_SET(r,d) (r).sc_x4_ctl[0] = d
#define BCMI_TSCD_XGXS_SC_X4_CTLr_GET(r) (r).sc_x4_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET(r) ((((r).sc_x4_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_CTLr_SPEEDf_GET(r) (((r).sc_x4_ctl[0]) & 0xff)
#define BCMI_TSCD_XGXS_SC_X4_CTLr_SPEEDf_SET(r,f) (r).sc_x4_ctl[0]=(((r).sc_x4_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X4_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_CTLr,(_r._sc_x4_ctl))
#define BCMI_TSCD_XGXS_READLN_SC_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_CTLr BCMI_TSCD_XGXS_SC_X4_CTLr
#define SC_X4_CTLr_SIZE BCMI_TSCD_XGXS_SC_X4_CTLr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_CTLr_t SC_X4_CTLr_t;
#define SC_X4_CTLr_CLR BCMI_TSCD_XGXS_SC_X4_CTLr_CLR
#define SC_X4_CTLr_SET BCMI_TSCD_XGXS_SC_X4_CTLr_SET
#define SC_X4_CTLr_GET BCMI_TSCD_XGXS_SC_X4_CTLr_GET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_GET BCMI_TSCD_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_GET
#define SC_X4_CTLr_SW_SPEED_CHANGEf_SET BCMI_TSCD_XGXS_SC_X4_CTLr_SW_SPEED_CHANGEf_SET
#define SC_X4_CTLr_SPEEDf_GET BCMI_TSCD_XGXS_SC_X4_CTLr_SPEEDf_GET
#define SC_X4_CTLr_SPEEDf_SET BCMI_TSCD_XGXS_SC_X4_CTLr_SPEEDf_SET
#define READ_SC_X4_CTLr BCMI_TSCD_XGXS_READ_SC_X4_CTLr
#define WRITE_SC_X4_CTLr BCMI_TSCD_XGXS_WRITE_SC_X4_CTLr
#define MODIFY_SC_X4_CTLr BCMI_TSCD_XGXS_MODIFY_SC_X4_CTLr
#define READLN_SC_X4_CTLr BCMI_TSCD_XGXS_READLN_SC_X4_CTLr
#define WRITELN_SC_X4_CTLr BCMI_TSCD_XGXS_WRITELN_SC_X4_CTLr
#define WRITEALL_SC_X4_CTLr BCMI_TSCD_XGXS_WRITEALL_SC_X4_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_STS
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc051
 * DESC:     SW speed change status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_SPEED_CHANGE_DONE Read clear bit indicating that SW initiated speed change completed
 *     SW_SPEED_CONFIG_VLD Read clear bit indicating that resolved speed configuration in stutus registers can be read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_STSr (0x0000c051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_STSr_s {
	uint32_t v[1];
	uint32_t sc_x4_sts[1];
	uint32_t _sc_x4_sts;
} BCMI_TSCD_XGXS_SC_X4_STSr_t;

#define BCMI_TSCD_XGXS_SC_X4_STSr_CLR(r) (r).sc_x4_sts[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_STSr_SET(r,d) (r).sc_x4_sts[0] = d
#define BCMI_TSCD_XGXS_SC_X4_STSr_GET(r) (r).sc_x4_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET(r) ((((r).sc_x4_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET(r) (((r).sc_x4_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET(r,f) (r).sc_x4_sts[0]=(((r).sc_x4_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_STSr,(_r._sc_x4_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_STSr,(_r._sc_x4_sts))
#define BCMI_TSCD_XGXS_READLN_SC_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sts))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_STSr BCMI_TSCD_XGXS_SC_X4_STSr
#define SC_X4_STSr_SIZE BCMI_TSCD_XGXS_SC_X4_STSr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_STSr_t SC_X4_STSr_t;
#define SC_X4_STSr_CLR BCMI_TSCD_XGXS_SC_X4_STSr_CLR
#define SC_X4_STSr_SET BCMI_TSCD_XGXS_SC_X4_STSr_SET
#define SC_X4_STSr_GET BCMI_TSCD_XGXS_SC_X4_STSr_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_GET
#define SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CONFIG_VLDf_SET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_GET
#define SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET BCMI_TSCD_XGXS_SC_X4_STSr_SW_SPEED_CHANGE_DONEf_SET
#define READ_SC_X4_STSr BCMI_TSCD_XGXS_READ_SC_X4_STSr
#define WRITE_SC_X4_STSr BCMI_TSCD_XGXS_WRITE_SC_X4_STSr
#define MODIFY_SC_X4_STSr BCMI_TSCD_XGXS_MODIFY_SC_X4_STSr
#define READLN_SC_X4_STSr BCMI_TSCD_XGXS_READLN_SC_X4_STSr
#define WRITELN_SC_X4_STSr BCMI_TSCD_XGXS_WRITELN_SC_X4_STSr
#define WRITEALL_SC_X4_STSr BCMI_TSCD_XGXS_WRITEALL_SC_X4_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_ERR
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc052
 * DESC:     Speed control error indication
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_TIMED_OUT Indication of timeout during PLL lock
 *     PMD_LOCK_TIMED_OUT Indication of timeout during PMD RX lock
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_ERRr (0x0000c052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_ERRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_ERR.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_ERRr_s {
	uint32_t v[1];
	uint32_t sc_x4_err[1];
	uint32_t _sc_x4_err;
} BCMI_TSCD_XGXS_SC_X4_ERRr_t;

#define BCMI_TSCD_XGXS_SC_X4_ERRr_CLR(r) (r).sc_x4_err[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_ERRr_SET(r,d) (r).sc_x4_err[0] = d
#define BCMI_TSCD_XGXS_SC_X4_ERRr_GET(r) (r).sc_x4_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET(r) ((((r).sc_x4_err[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET(r,f) (r).sc_x4_err[0]=(((r).sc_x4_err[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET(r) (((r).sc_x4_err[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET(r,f) (r).sc_x4_err[0]=(((r).sc_x4_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_ERR.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_ERRr,(_r._sc_x4_err))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_ERRr,(_r._sc_x4_err)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_ERRr,(_r._sc_x4_err))
#define BCMI_TSCD_XGXS_READLN_SC_X4_ERRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_err))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_ERRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_err))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_ERRr BCMI_TSCD_XGXS_SC_X4_ERRr
#define SC_X4_ERRr_SIZE BCMI_TSCD_XGXS_SC_X4_ERRr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_ERRr_t SC_X4_ERRr_t;
#define SC_X4_ERRr_CLR BCMI_TSCD_XGXS_SC_X4_ERRr_CLR
#define SC_X4_ERRr_SET BCMI_TSCD_XGXS_SC_X4_ERRr_SET
#define SC_X4_ERRr_GET BCMI_TSCD_XGXS_SC_X4_ERRr_GET
#define SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET BCMI_TSCD_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_GET
#define SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET BCMI_TSCD_XGXS_SC_X4_ERRr_PMD_LOCK_TIMED_OUTf_SET
#define SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET BCMI_TSCD_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_GET
#define SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET BCMI_TSCD_XGXS_SC_X4_ERRr_PLL_LOCK_TIMED_OUTf_SET
#define READ_SC_X4_ERRr BCMI_TSCD_XGXS_READ_SC_X4_ERRr
#define WRITE_SC_X4_ERRr BCMI_TSCD_XGXS_WRITE_SC_X4_ERRr
#define MODIFY_SC_X4_ERRr BCMI_TSCD_XGXS_MODIFY_SC_X4_ERRr
#define READLN_SC_X4_ERRr BCMI_TSCD_XGXS_READLN_SC_X4_ERRr
#define WRITELN_SC_X4_ERRr BCMI_TSCD_XGXS_WRITELN_SC_X4_ERRr
#define WRITEALL_SC_X4_ERRr BCMI_TSCD_XGXS_WRITEALL_SC_X4_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_MSA_25G_50G_CTL
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc053
 * DESC:     MSA 25 and 50G control register
 * RESETVAL: 0x30c (780)
 * ACCESS:   R/W
 * FIELDS:
 *     CL74_SHCORRUPT_25GMSA This bit will choose whether to corrupt all SH or only 5 SH for 25G MSA Speed0: Only 5 SH1: all SH
 *     CL74_SHCORRUPT_50GMSA This bit will choose whether to corrupt all SH or only 5 SH for 50G MSA Speed0: Only 5 SH1: all SH
 *     MSA_COUNT_SEL    This bit will select between 16 (cl49) and 97 (cl82) count for BER for MSA 25G and 50G Speeds.0: select cl49 register1: select cl82 register
 *     MSA_WINDOW_SEL   This bit will select between cl49 window and cl82 window count for BER for MSA 25G and 50G Speeds.0: select cl49 window1: select cl82 window
 *     MSA_25G_AM123_FORMAT this bit will select TX AM0 format for MSA 25G.0: select 40G AM1231: select 100G AM123
 *     MSA_25G_AM0_FORMAT this bit will select TX AM0 format for MSA 25G.0: select 40G AM01: select 100G AM0
 *     MSA_50G_AM123_FORMAT this bit will select TX AM0 format for MSA 25G.0: select 40G AM1231: select 100G AM123
 *     MSA_50G_AM0_FORMAT this bit will select TX AM0 format for MSA 25G.0: select 40G AM01: select 100G AM0
 *     MSA_25G_AM_EN    Disable AM TX and RX.1: AM is enabled0: AM is disabled
 *     MSA_25G_5BIT_XOR Enable disable 5 bit XOR for MSA 25G0: Disabled1: Enabled
 *     MSA_25G_CWSCR_EN Pre/Post code word scranmbler enable/disable.0: DISABLED1: ENABLED
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr (0x0000c053 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_MSA_25G_50G_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_s {
	uint32_t v[1];
	uint32_t sc_x4_msa_25g_50g_ctl[1];
	uint32_t _sc_x4_msa_25g_50g_ctl;
} BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_t;

#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CLR(r) (r).sc_x4_msa_25g_50g_ctl[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_SET(r,d) (r).sc_x4_msa_25g_50g_ctl[0] = d
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_GET(r) (r).sc_x4_msa_25g_50g_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_CWSCR_ENf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_CWSCR_ENf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_5BIT_XORf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_5BIT_XORf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM_ENf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM_ENf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM0_FORMATf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM0_FORMATf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM123_FORMATf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM123_FORMATf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM0_FORMATf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM0_FORMATf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM123_FORMATf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM123_FORMATf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_WINDOW_SELf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_WINDOW_SELf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_COUNT_SELf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_COUNT_SELf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_50GMSAf_GET(r) ((((r).sc_x4_msa_25g_50g_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_50GMSAf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_25GMSAf_GET(r) (((r).sc_x4_msa_25g_50g_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_25GMSAf_SET(r,f) (r).sc_x4_msa_25g_50g_ctl[0]=(((r).sc_x4_msa_25g_50g_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_MSA_25G_50G_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_MSA_25G_50G_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr,(_r._sc_x4_msa_25g_50g_ctl))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_MSA_25G_50G_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr,(_r._sc_x4_msa_25g_50g_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_MSA_25G_50G_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr,(_r._sc_x4_msa_25g_50g_ctl))
#define BCMI_TSCD_XGXS_READLN_SC_X4_MSA_25G_50G_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_msa_25g_50g_ctl))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_MSA_25G_50G_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_msa_25g_50g_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_MSA_25G_50G_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_msa_25g_50g_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_MSA_25G_50G_CTLr BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr
#define SC_X4_MSA_25G_50G_CTLr_SIZE BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_t SC_X4_MSA_25G_50G_CTLr_t;
#define SC_X4_MSA_25G_50G_CTLr_CLR BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CLR
#define SC_X4_MSA_25G_50G_CTLr_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_SET
#define SC_X4_MSA_25G_50G_CTLr_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_CWSCR_ENf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_CWSCR_ENf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_CWSCR_ENf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_CWSCR_ENf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_5BIT_XORf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_5BIT_XORf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_5BIT_XORf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_5BIT_XORf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM_ENf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM_ENf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM_ENf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM_ENf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM0_FORMATf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM0_FORMATf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM0_FORMATf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM0_FORMATf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM123_FORMATf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM123_FORMATf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM123_FORMATf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_50G_AM123_FORMATf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM0_FORMATf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM0_FORMATf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM0_FORMATf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM0_FORMATf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM123_FORMATf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM123_FORMATf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM123_FORMATf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_25G_AM123_FORMATf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_WINDOW_SELf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_WINDOW_SELf_SET
#define SC_X4_MSA_25G_50G_CTLr_MSA_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_COUNT_SELf_GET
#define SC_X4_MSA_25G_50G_CTLr_MSA_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_MSA_COUNT_SELf_SET
#define SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_50GMSAf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_50GMSAf_GET
#define SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_50GMSAf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_50GMSAf_SET
#define SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_25GMSAf_GET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_25GMSAf_GET
#define SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_25GMSAf_SET BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr_CL74_SHCORRUPT_25GMSAf_SET
#define READ_SC_X4_MSA_25G_50G_CTLr BCMI_TSCD_XGXS_READ_SC_X4_MSA_25G_50G_CTLr
#define WRITE_SC_X4_MSA_25G_50G_CTLr BCMI_TSCD_XGXS_WRITE_SC_X4_MSA_25G_50G_CTLr
#define MODIFY_SC_X4_MSA_25G_50G_CTLr BCMI_TSCD_XGXS_MODIFY_SC_X4_MSA_25G_50G_CTLr
#define READLN_SC_X4_MSA_25G_50G_CTLr BCMI_TSCD_XGXS_READLN_SC_X4_MSA_25G_50G_CTLr
#define WRITELN_SC_X4_MSA_25G_50G_CTLr BCMI_TSCD_XGXS_WRITELN_SC_X4_MSA_25G_50G_CTLr
#define WRITEALL_SC_X4_MSA_25G_50G_CTLr BCMI_TSCD_XGXS_WRITEALL_SC_X4_MSA_25G_50G_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_MSA_25G_50G_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_DBG
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc054
 * DESC:     Speed control debug information
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     SC_FSM_STATUS    Speed Control logic FSM debug information16'h8000 - START16'h4000 - RESET_PCS16'h2000 - RESET_PMD_LANE16'h1000 - RESET_PMD_PLL16'h0800 - APPLY_SPEED_CFG16'h0400 - WAIT_CFG_DONE16'h0200 - ACTIVATE_PMD16'h0100 - WAIT_PLL_RESET16'h0080 - PLL_LOCK_FAIL16'h0040 - ACTIVATE_TX16'h0020 - WAIT_PMD_LOCK16'h0010 - ACTIVATE_RX16'h0008 - PMD_LOCK_FAIL16'h0004 - DONE16'h0002 - STOP16'h0001 - BYPASS
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_DBGr (0x0000c054 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_DBGr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_DBG.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_DBGr_s {
	uint32_t v[1];
	uint32_t sc_x4_dbg[1];
	uint32_t _sc_x4_dbg;
} BCMI_TSCD_XGXS_SC_X4_DBGr_t;

#define BCMI_TSCD_XGXS_SC_X4_DBGr_CLR(r) (r).sc_x4_dbg[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_DBGr_SET(r,d) (r).sc_x4_dbg[0] = d
#define BCMI_TSCD_XGXS_SC_X4_DBGr_GET(r) (r).sc_x4_dbg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET(r) (((r).sc_x4_dbg[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET(r,f) (r).sc_x4_dbg[0]=(((r).sc_x4_dbg[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X4_DBG.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_DBGr,(_r._sc_x4_dbg))
#define BCMI_TSCD_XGXS_READLN_SC_X4_DBGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_DBGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_dbg))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_DBGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_dbg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_DBGr BCMI_TSCD_XGXS_SC_X4_DBGr
#define SC_X4_DBGr_SIZE BCMI_TSCD_XGXS_SC_X4_DBGr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_DBGr_t SC_X4_DBGr_t;
#define SC_X4_DBGr_CLR BCMI_TSCD_XGXS_SC_X4_DBGr_CLR
#define SC_X4_DBGr_SET BCMI_TSCD_XGXS_SC_X4_DBGr_SET
#define SC_X4_DBGr_GET BCMI_TSCD_XGXS_SC_X4_DBGr_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_GET BCMI_TSCD_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_GET
#define SC_X4_DBGr_SC_FSM_STATUSf_SET BCMI_TSCD_XGXS_SC_X4_DBGr_SC_FSM_STATUSf_SET
#define READ_SC_X4_DBGr BCMI_TSCD_XGXS_READ_SC_X4_DBGr
#define WRITE_SC_X4_DBGr BCMI_TSCD_XGXS_WRITE_SC_X4_DBGr
#define MODIFY_SC_X4_DBGr BCMI_TSCD_XGXS_MODIFY_SC_X4_DBGr
#define READLN_SC_X4_DBGr BCMI_TSCD_XGXS_READLN_SC_X4_DBGr
#define WRITELN_SC_X4_DBGr BCMI_TSCD_XGXS_WRITELN_SC_X4_DBGr
#define WRITEALL_SC_X4_DBGr BCMI_TSCD_XGXS_WRITEALL_SC_X4_DBGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_DBGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_SC_X4_OVRR
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc055
 * DESC:     Number of lanes for override configuration
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     NUM_LANES_OVERRIDE_VALUE Number of lanes for override configuration0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes
 *     AN_FEC_SEL_OVERRIDE Valid only when AN resolves to 25G, 50G (over 2 lanes), 100G speeds.
 *     CORRUPT_2ND_GROUP Global over-ride value for corrupt_2nd_group
 *     CORRUPT_6TH_GROUP Global over-ride value for corrupt_6th_group
 *     CL74_SHCORRUPT   Global over-ride value for cl74_shcorrupt
 *     BER_COUNT_SEL    Global over-ride value for ber_count_sel
 *     BER_WINDOW_SEL   Global over-ride value for ber_window_sel
 *     USE_100G_AM0     Global over-ride value for use_100G_am0
 *     USE_100G_AM123   Global over-ride value for use_100G_am123
 *     AM_LOCK_FSM_MODE_EXT Global over-ride value AM lock FSM value for extension mode.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr (0x0000c055 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_SC_X4_OVRR.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_s {
	uint32_t v[1];
	uint32_t sc_x4_sc_x4_ovrr[1];
	uint32_t _sc_x4_sc_x4_ovrr;
} BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_t;

#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CLR(r) (r).sc_x4_sc_x4_ovrr[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_SET(r,d) (r).sc_x4_sc_x4_ovrr[0] = d
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_GET(r) (r).sc_x4_sc_x4_ovrr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AM_LOCK_FSM_MODE_EXTf_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AM_LOCK_FSM_MODE_EXTf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM123f_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM123f_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM0f_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM0f_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_WINDOW_SELf_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_WINDOW_SELf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_COUNT_SELf_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_COUNT_SELf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CL74_SHCORRUPTf_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CL74_SHCORRUPTf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_6TH_GROUPf_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_6TH_GROUPf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_2ND_GROUPf_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_2ND_GROUPf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AN_FEC_SEL_OVERRIDEf_GET(r) ((((r).sc_x4_sc_x4_ovrr[0]) >> 3) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AN_FEC_SEL_OVERRIDEf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_NUM_LANES_OVERRIDE_VALUEf_GET(r) (((r).sc_x4_sc_x4_ovrr[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_NUM_LANES_OVERRIDE_VALUEf_SET(r,f) (r).sc_x4_sc_x4_ovrr[0]=(((r).sc_x4_sc_x4_ovrr[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X4_SC_X4_OVRR.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_SC_X4_OVRRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr,(_r._sc_x4_sc_x4_ovrr))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_SC_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr,(_r._sc_x4_sc_x4_ovrr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_SC_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr,(_r._sc_x4_sc_x4_ovrr))
#define BCMI_TSCD_XGXS_READLN_SC_X4_SC_X4_OVRRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sc_x4_ovrr))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_SC_X4_OVRRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_sc_x4_ovrr))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_SC_X4_OVRRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_sc_x4_ovrr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_SC_X4_OVRRr BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr
#define SC_X4_SC_X4_OVRRr_SIZE BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_t SC_X4_SC_X4_OVRRr_t;
#define SC_X4_SC_X4_OVRRr_CLR BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CLR
#define SC_X4_SC_X4_OVRRr_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_SET
#define SC_X4_SC_X4_OVRRr_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_GET
#define SC_X4_SC_X4_OVRRr_AM_LOCK_FSM_MODE_EXTf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AM_LOCK_FSM_MODE_EXTf_GET
#define SC_X4_SC_X4_OVRRr_AM_LOCK_FSM_MODE_EXTf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AM_LOCK_FSM_MODE_EXTf_SET
#define SC_X4_SC_X4_OVRRr_USE_100G_AM123f_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM123f_GET
#define SC_X4_SC_X4_OVRRr_USE_100G_AM123f_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM123f_SET
#define SC_X4_SC_X4_OVRRr_USE_100G_AM0f_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM0f_GET
#define SC_X4_SC_X4_OVRRr_USE_100G_AM0f_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_USE_100G_AM0f_SET
#define SC_X4_SC_X4_OVRRr_BER_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_WINDOW_SELf_GET
#define SC_X4_SC_X4_OVRRr_BER_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_WINDOW_SELf_SET
#define SC_X4_SC_X4_OVRRr_BER_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_COUNT_SELf_GET
#define SC_X4_SC_X4_OVRRr_BER_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_BER_COUNT_SELf_SET
#define SC_X4_SC_X4_OVRRr_CL74_SHCORRUPTf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CL74_SHCORRUPTf_GET
#define SC_X4_SC_X4_OVRRr_CL74_SHCORRUPTf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CL74_SHCORRUPTf_SET
#define SC_X4_SC_X4_OVRRr_CORRUPT_6TH_GROUPf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_6TH_GROUPf_GET
#define SC_X4_SC_X4_OVRRr_CORRUPT_6TH_GROUPf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_6TH_GROUPf_SET
#define SC_X4_SC_X4_OVRRr_CORRUPT_2ND_GROUPf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_2ND_GROUPf_GET
#define SC_X4_SC_X4_OVRRr_CORRUPT_2ND_GROUPf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_CORRUPT_2ND_GROUPf_SET
#define SC_X4_SC_X4_OVRRr_AN_FEC_SEL_OVERRIDEf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AN_FEC_SEL_OVERRIDEf_GET
#define SC_X4_SC_X4_OVRRr_AN_FEC_SEL_OVERRIDEf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_AN_FEC_SEL_OVERRIDEf_SET
#define SC_X4_SC_X4_OVRRr_NUM_LANES_OVERRIDE_VALUEf_GET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_NUM_LANES_OVERRIDE_VALUEf_GET
#define SC_X4_SC_X4_OVRRr_NUM_LANES_OVERRIDE_VALUEf_SET BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr_NUM_LANES_OVERRIDE_VALUEf_SET
#define READ_SC_X4_SC_X4_OVRRr BCMI_TSCD_XGXS_READ_SC_X4_SC_X4_OVRRr
#define WRITE_SC_X4_SC_X4_OVRRr BCMI_TSCD_XGXS_WRITE_SC_X4_SC_X4_OVRRr
#define MODIFY_SC_X4_SC_X4_OVRRr BCMI_TSCD_XGXS_MODIFY_SC_X4_SC_X4_OVRRr
#define READLN_SC_X4_SC_X4_OVRRr BCMI_TSCD_XGXS_READLN_SC_X4_SC_X4_OVRRr
#define WRITELN_SC_X4_SC_X4_OVRRr BCMI_TSCD_XGXS_WRITELN_SC_X4_SC_X4_OVRRr
#define WRITEALL_SC_X4_SC_X4_OVRRr BCMI_TSCD_XGXS_WRITEALL_SC_X4_SC_X4_OVRRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_SC_X4_OVRRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_IEEE_25G_CTL
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc056
 * DESC:     IEEE 25G control register
 * RESETVAL: 0x66 (102)
 * ACCESS:   R/W
 * FIELDS:
 *     CL74_SHCORRUPT_25IEEE This bit will choose whether to corrupt all SH or only 5 SH for 25G IEEE speed0: Only 5 SH1: all SH
 *     IEEE_COUNT_SEL   This bit will select between 16 (cl49) and 97 (cl82) count for BER for IEEE 25G.0: select 161: select 97
 *     IEEE_WINDOW_SEL  This bit will select between cl49 window and cl82 window count for BER for IEEE 25G.0: select cl49 window1: select cl82 window
 *     IEEE_25G_AM123_FORMAT this bit will select TX AM0 format for IEEE 25G.0: select 40G AM01: select 100G AM0
 *     IEEE_25G_AM0_FORMAT this bit will select RX AM0 format for IEEE 25G.0: select 40G AM01: select 100G AM0
 *     IEEE_25G_AM_EN   Disable AM TX and RX.1: AM is enabled0: AM is disabled
 *     IEEE_25G_5BIT_XOR Enable disable 5 bit XOR for IEEE 25G0: Disabled1: Enabled
 *     IEEE_25G_CWSCR_EN Pre/Post code word scranmbler enable/disable.0: DISABLED1: ENABLED
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr (0x0000c056 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_IEEE_25G_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_s {
	uint32_t v[1];
	uint32_t sc_x4_ieee_25g_ctl[1];
	uint32_t _sc_x4_ieee_25g_ctl;
} BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_t;

#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_CLR(r) (r).sc_x4_ieee_25g_ctl[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_SET(r,d) (r).sc_x4_ieee_25g_ctl[0] = d
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_GET(r) (r).sc_x4_ieee_25g_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_CWSCR_ENf_GET(r) ((((r).sc_x4_ieee_25g_ctl[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_CWSCR_ENf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_5BIT_XORf_GET(r) ((((r).sc_x4_ieee_25g_ctl[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_5BIT_XORf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM_ENf_GET(r) ((((r).sc_x4_ieee_25g_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM_ENf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM0_FORMATf_GET(r) ((((r).sc_x4_ieee_25g_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM0_FORMATf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM123_FORMATf_GET(r) ((((r).sc_x4_ieee_25g_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM123_FORMATf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_WINDOW_SELf_GET(r) ((((r).sc_x4_ieee_25g_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_WINDOW_SELf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_COUNT_SELf_GET(r) ((((r).sc_x4_ieee_25g_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_COUNT_SELf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_CL74_SHCORRUPT_25IEEEf_GET(r) (((r).sc_x4_ieee_25g_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_CL74_SHCORRUPT_25IEEEf_SET(r,f) (r).sc_x4_ieee_25g_ctl[0]=(((r).sc_x4_ieee_25g_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_IEEE_25G_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_IEEE_25G_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr,(_r._sc_x4_ieee_25g_ctl))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_IEEE_25G_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr,(_r._sc_x4_ieee_25g_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_IEEE_25G_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr,(_r._sc_x4_ieee_25g_ctl))
#define BCMI_TSCD_XGXS_READLN_SC_X4_IEEE_25G_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ieee_25g_ctl))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_IEEE_25G_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_ieee_25g_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_IEEE_25G_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_ieee_25g_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_IEEE_25G_CTLr BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr
#define SC_X4_IEEE_25G_CTLr_SIZE BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_t SC_X4_IEEE_25G_CTLr_t;
#define SC_X4_IEEE_25G_CTLr_CLR BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_CLR
#define SC_X4_IEEE_25G_CTLr_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_SET
#define SC_X4_IEEE_25G_CTLr_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_CWSCR_ENf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_CWSCR_ENf_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_CWSCR_ENf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_CWSCR_ENf_SET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_5BIT_XORf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_5BIT_XORf_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_5BIT_XORf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_5BIT_XORf_SET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_AM_ENf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM_ENf_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_AM_ENf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM_ENf_SET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_AM0_FORMATf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM0_FORMATf_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_AM0_FORMATf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM0_FORMATf_SET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_AM123_FORMATf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM123_FORMATf_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_25G_AM123_FORMATf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_25G_AM123_FORMATf_SET
#define SC_X4_IEEE_25G_CTLr_IEEE_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_WINDOW_SELf_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_WINDOW_SELf_SET
#define SC_X4_IEEE_25G_CTLr_IEEE_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_COUNT_SELf_GET
#define SC_X4_IEEE_25G_CTLr_IEEE_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_IEEE_COUNT_SELf_SET
#define SC_X4_IEEE_25G_CTLr_CL74_SHCORRUPT_25IEEEf_GET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_CL74_SHCORRUPT_25IEEEf_GET
#define SC_X4_IEEE_25G_CTLr_CL74_SHCORRUPT_25IEEEf_SET BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr_CL74_SHCORRUPT_25IEEEf_SET
#define READ_SC_X4_IEEE_25G_CTLr BCMI_TSCD_XGXS_READ_SC_X4_IEEE_25G_CTLr
#define WRITE_SC_X4_IEEE_25G_CTLr BCMI_TSCD_XGXS_WRITE_SC_X4_IEEE_25G_CTLr
#define MODIFY_SC_X4_IEEE_25G_CTLr BCMI_TSCD_XGXS_MODIFY_SC_X4_IEEE_25G_CTLr
#define READLN_SC_X4_IEEE_25G_CTLr BCMI_TSCD_XGXS_READLN_SC_X4_IEEE_25G_CTLr
#define WRITELN_SC_X4_IEEE_25G_CTLr BCMI_TSCD_XGXS_WRITELN_SC_X4_IEEE_25G_CTLr
#define WRITEALL_SC_X4_IEEE_25G_CTLr BCMI_TSCD_XGXS_WRITEALL_SC_X4_IEEE_25G_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_IEEE_25G_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_BYPASS
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc058
 * DESC:     Speed control bypass enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SC_BYPASS        Disable speed control logic
 *     SC_IGNORE_TX_DATA_VLD Do not wait for tx_data_vld indication from PMD before taking TX pipe out of reset
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_BYPASSr (0x0000c058 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_BYPASS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_BYPASSr_s {
	uint32_t v[1];
	uint32_t sc_x4_bypass[1];
	uint32_t _sc_x4_bypass;
} BCMI_TSCD_XGXS_SC_X4_BYPASSr_t;

#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_CLR(r) (r).sc_x4_bypass[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_SET(r,d) (r).sc_x4_bypass[0] = d
#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_GET(r) (r).sc_x4_bypass[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET(r) ((((r).sc_x4_bypass[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET(r,f) (r).sc_x4_bypass[0]=(((r).sc_x4_bypass[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_BYPASSf_GET(r) (((r).sc_x4_bypass[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_BYPASSf_SET(r,f) (r).sc_x4_bypass[0]=(((r).sc_x4_bypass[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_BYPASS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_BYPASSr,(_r._sc_x4_bypass))
#define BCMI_TSCD_XGXS_READLN_SC_X4_BYPASSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_bypass))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_BYPASSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_bypass))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_BYPASSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_BYPASSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_bypass))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_BYPASSr BCMI_TSCD_XGXS_SC_X4_BYPASSr
#define SC_X4_BYPASSr_SIZE BCMI_TSCD_XGXS_SC_X4_BYPASSr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_BYPASSr_t SC_X4_BYPASSr_t;
#define SC_X4_BYPASSr_CLR BCMI_TSCD_XGXS_SC_X4_BYPASSr_CLR
#define SC_X4_BYPASSr_SET BCMI_TSCD_XGXS_SC_X4_BYPASSr_SET
#define SC_X4_BYPASSr_GET BCMI_TSCD_XGXS_SC_X4_BYPASSr_GET
#define SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_GET
#define SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_IGNORE_TX_DATA_VLDf_SET
#define SC_X4_BYPASSr_SC_BYPASSf_GET BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_BYPASSf_GET
#define SC_X4_BYPASSr_SC_BYPASSf_SET BCMI_TSCD_XGXS_SC_X4_BYPASSr_SC_BYPASSf_SET
#define READ_SC_X4_BYPASSr BCMI_TSCD_XGXS_READ_SC_X4_BYPASSr
#define WRITE_SC_X4_BYPASSr BCMI_TSCD_XGXS_WRITE_SC_X4_BYPASSr
#define MODIFY_SC_X4_BYPASSr BCMI_TSCD_XGXS_MODIFY_SC_X4_BYPASSr
#define READLN_SC_X4_BYPASSr BCMI_TSCD_XGXS_READLN_SC_X4_BYPASSr
#define WRITELN_SC_X4_BYPASSr BCMI_TSCD_XGXS_WRITELN_SC_X4_BYPASSr
#define WRITEALL_SC_X4_BYPASSr BCMI_TSCD_XGXS_WRITEALL_SC_X4_BYPASSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_BYPASSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_SPARE0
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc05d
 * DESC:     spare 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPARE0           Spare register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_SPARE0r (0x0000c05d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_SPARE0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_SPARE0.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_SPARE0r_s {
	uint32_t v[1];
	uint32_t sc_x4_spare0[1];
	uint32_t _sc_x4_spare0;
} BCMI_TSCD_XGXS_SC_X4_SPARE0r_t;

#define BCMI_TSCD_XGXS_SC_X4_SPARE0r_CLR(r) (r).sc_x4_spare0[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_SPARE0r_SET(r,d) (r).sc_x4_spare0[0] = d
#define BCMI_TSCD_XGXS_SC_X4_SPARE0r_GET(r) (r).sc_x4_spare0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_SPARE0r_SPARE0f_GET(r) (((r).sc_x4_spare0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SC_X4_SPARE0r_SPARE0f_SET(r,f) (r).sc_x4_spare0[0]=(((r).sc_x4_spare0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X4_SPARE0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_SPARE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE0r,(_r._sc_x4_spare0))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_SPARE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE0r,(_r._sc_x4_spare0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_SPARE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE0r,(_r._sc_x4_spare0))
#define BCMI_TSCD_XGXS_READLN_SC_X4_SPARE0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_spare0))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_SPARE0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_spare0))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_SPARE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_spare0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_SPARE0r BCMI_TSCD_XGXS_SC_X4_SPARE0r
#define SC_X4_SPARE0r_SIZE BCMI_TSCD_XGXS_SC_X4_SPARE0r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_SPARE0r_t SC_X4_SPARE0r_t;
#define SC_X4_SPARE0r_CLR BCMI_TSCD_XGXS_SC_X4_SPARE0r_CLR
#define SC_X4_SPARE0r_SET BCMI_TSCD_XGXS_SC_X4_SPARE0r_SET
#define SC_X4_SPARE0r_GET BCMI_TSCD_XGXS_SC_X4_SPARE0r_GET
#define SC_X4_SPARE0r_SPARE0f_GET BCMI_TSCD_XGXS_SC_X4_SPARE0r_SPARE0f_GET
#define SC_X4_SPARE0r_SPARE0f_SET BCMI_TSCD_XGXS_SC_X4_SPARE0r_SPARE0f_SET
#define READ_SC_X4_SPARE0r BCMI_TSCD_XGXS_READ_SC_X4_SPARE0r
#define WRITE_SC_X4_SPARE0r BCMI_TSCD_XGXS_WRITE_SC_X4_SPARE0r
#define MODIFY_SC_X4_SPARE0r BCMI_TSCD_XGXS_MODIFY_SC_X4_SPARE0r
#define READLN_SC_X4_SPARE0r BCMI_TSCD_XGXS_READLN_SC_X4_SPARE0r
#define WRITELN_SC_X4_SPARE0r BCMI_TSCD_XGXS_WRITELN_SC_X4_SPARE0r
#define WRITEALL_SC_X4_SPARE0r BCMI_TSCD_XGXS_WRITEALL_SC_X4_SPARE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_SPARE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_SPARE1
 * BLOCKS:   SC_X4_CONTROL
 * REGADDR:  0xc05e
 * DESC:     spare 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SPARE1           Spare register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_SPARE1r (0x0000c05e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_SPARE1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_SPARE1.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_SPARE1r_s {
	uint32_t v[1];
	uint32_t sc_x4_spare1[1];
	uint32_t _sc_x4_spare1;
} BCMI_TSCD_XGXS_SC_X4_SPARE1r_t;

#define BCMI_TSCD_XGXS_SC_X4_SPARE1r_CLR(r) (r).sc_x4_spare1[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_SPARE1r_SET(r,d) (r).sc_x4_spare1[0] = d
#define BCMI_TSCD_XGXS_SC_X4_SPARE1r_GET(r) (r).sc_x4_spare1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_SPARE1r_SPARE1f_GET(r) (((r).sc_x4_spare1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_SC_X4_SPARE1r_SPARE1f_SET(r,f) (r).sc_x4_spare1[0]=(((r).sc_x4_spare1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access SC_X4_SPARE1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_SPARE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE1r,(_r._sc_x4_spare1))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_SPARE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE1r,(_r._sc_x4_spare1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_SPARE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE1r,(_r._sc_x4_spare1))
#define BCMI_TSCD_XGXS_READLN_SC_X4_SPARE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_spare1))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_SPARE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_spare1))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_SPARE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_SPARE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_spare1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_SPARE1r BCMI_TSCD_XGXS_SC_X4_SPARE1r
#define SC_X4_SPARE1r_SIZE BCMI_TSCD_XGXS_SC_X4_SPARE1r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_SPARE1r_t SC_X4_SPARE1r_t;
#define SC_X4_SPARE1r_CLR BCMI_TSCD_XGXS_SC_X4_SPARE1r_CLR
#define SC_X4_SPARE1r_SET BCMI_TSCD_XGXS_SC_X4_SPARE1r_SET
#define SC_X4_SPARE1r_GET BCMI_TSCD_XGXS_SC_X4_SPARE1r_GET
#define SC_X4_SPARE1r_SPARE1f_GET BCMI_TSCD_XGXS_SC_X4_SPARE1r_SPARE1f_GET
#define SC_X4_SPARE1r_SPARE1f_SET BCMI_TSCD_XGXS_SC_X4_SPARE1r_SPARE1f_SET
#define READ_SC_X4_SPARE1r BCMI_TSCD_XGXS_READ_SC_X4_SPARE1r
#define WRITE_SC_X4_SPARE1r BCMI_TSCD_XGXS_WRITE_SC_X4_SPARE1r
#define MODIFY_SC_X4_SPARE1r BCMI_TSCD_XGXS_MODIFY_SC_X4_SPARE1r
#define READLN_SC_X4_SPARE1r BCMI_TSCD_XGXS_READLN_SC_X4_SPARE1r
#define WRITELN_SC_X4_SPARE1r BCMI_TSCD_XGXS_WRITELN_SC_X4_SPARE1r
#define WRITEALL_SC_X4_SPARE1r BCMI_TSCD_XGXS_WRITEALL_SC_X4_SPARE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_SPARE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_FLD_OVRR_EN0_TYPE
 * BLOCKS:   SC_X4_FIELD_OVERRIDE_ENABLE
 * REGADDR:  0xc060
 * DESC:     Enable override of individual fields
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36RX_EN_OEN    The hardware/software table field named cl36rx_en is overriden with the value from the register rx_x4_control0-cl36rx_en.
 *     CL36TX_EN_OEN    The hardware/software table field named cl36tx_en is overriden with the value from the register tx_x4_control0-cl36tx_en.
 *     T_PMA_40B_MODE_OEN The hardware/software table field named t_pma_40b_mode is overriden with the value from the register tx_x4_control0-t_pma_40b_mode.
 *     DEC_FSM_MODE_OEN The hardware/software table field named dec_fsm_mode is overriden with the value from the register rx_x4_control0-dec_fsm_mode.
 *     DESKEW_MODE_OEN  The hardware/software table field named deskew_mode is overriden with the value from the register rx_x4_control0-deskew_mode.
 *     DEC_TL_MODE_OEN  The hardware/software table field named dec_tl_mode is overriden with the value from the register rx_x4_control0-dec_tl_mode.
 *     DESCR_MODE_OEN   The hardware/software table field named descr_mode is overriden with the value from the register rx_x4_control0-descr_mode.
 *     CL72_EN_OEN      The hardware/software table field named cl72_en is overriden with the value from the register main0-cl72_en.
 *     SCR_MODE_OEN     The hardware/software table field named scr_mode is overriden with the value from the register tx_x4_control0-scr_mode.
 *     T_PMA_BTMX_MODE_OEN The hardware/software table field named t_pma_btmx_mode is overriden with the value from the register tx_x4_control0-t_pma_btmx_mode.
 *     T_HG2_ENABLE_OEN The hardware/software table field named t_HG2_ENABLE is overriden with the value from the register tx_x4_control0-HG2_ENABLE.
 *     T_ENC_MODE_OEN   The hardware/software table field named t_enc_mode is overriden with the value from the register tx_x4_control0-t_enc_mode.
 *     T_FIFO_MODE_OEN  The hardware/software table field named t_fifo_mode is overriden with the value from the register tx_x2_control0-t_fifo_mode.
 *     OS_MODE_OEN      The hardware/software table field named os_mode is overriden with the value from the register tx_x4_control0-os_mode.
 *     NUM_LANES_OEN    The hardware/software table field named num_lanes is overriden with the value from the register sc_x4_control-num_lanes_override_value.
 *     CL36RX_10BIT_PMD_DATA_EN_OEN The hardware/software table field named cl36rx_10bit_pmd_data_en is overriden with the value from the register rx_x4_control0-cl36rx_10bit_pmd_data_en.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr (0x0000c060 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FLD_OVRR_EN0_TYPE.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_s {
	uint32_t v[1];
	uint32_t sc_x4_fld_ovrr_en0_type[1];
	uint32_t _sc_x4_fld_ovrr_en0_type;
} BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_t;

#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLR(r) (r).sc_x4_fld_ovrr_en0_type[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SET(r,d) (r).sc_x4_fld_ovrr_en0_type[0] = d
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_GET(r) (r).sc_x4_fld_ovrr_en0_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_10BIT_PMD_DATA_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_10BIT_PMD_DATA_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_FIFO_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_FIFO_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_ENC_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_ENC_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_HG2_ENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_HG2_ENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_BTMX_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_BTMX_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL72_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL72_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCR_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCR_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_TL_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_TL_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEW_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEW_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_FSM_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_FSM_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_40B_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_40B_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36TX_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en0_type[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36TX_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_EN_OENf_GET(r) (((r).sc_x4_fld_ovrr_en0_type[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en0_type[0]=(((r).sc_x4_fld_ovrr_en0_type[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_FLD_OVRR_EN0_TYPE.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr,(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCD_XGXS_READLN_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en0_type))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fld_ovrr_en0_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr
#define SC_X4_FLD_OVRR_EN0_TYPEr_SIZE BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_t SC_X4_FLD_OVRR_EN0_TYPEr_t;
#define SC_X4_FLD_OVRR_EN0_TYPEr_CLR BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CLR
#define SC_X4_FLD_OVRR_EN0_TYPEr_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_10BIT_PMD_DATA_EN_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_10BIT_PMD_DATA_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_10BIT_PMD_DATA_EN_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_10BIT_PMD_DATA_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_NUM_LANES_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_OS_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_FIFO_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_FIFO_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_FIFO_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_FIFO_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_ENC_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_ENC_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_ENC_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_ENC_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_HG2_ENABLE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_HG2_ENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_HG2_ENABLE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_HG2_ENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_BTMX_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_BTMX_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_BTMX_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_BTMX_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_SCR_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL72_EN_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL72_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL72_EN_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL72_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESCR_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCR_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESCR_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESCR_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DEC_TL_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_TL_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DEC_TL_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_TL_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESKEW_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEW_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DESKEW_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DESKEW_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DEC_FSM_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_FSM_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_DEC_FSM_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_DEC_FSM_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_40B_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_40B_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_40B_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_T_PMA_40B_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36TX_EN_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36TX_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36TX_EN_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36TX_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_EN_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_EN_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr_CL36RX_EN_OENf_SET
#define READ_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCD_XGXS_READ_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITE_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCD_XGXS_WRITE_SC_X4_FLD_OVRR_EN0_TYPEr
#define MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCD_XGXS_MODIFY_SC_X4_FLD_OVRR_EN0_TYPEr
#define READLN_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCD_XGXS_READLN_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCD_XGXS_WRITELN_SC_X4_FLD_OVRR_EN0_TYPEr
#define WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr BCMI_TSCD_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN0_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN0_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_FLD_OVRR_EN1_TYPE
 * BLOCKS:   SC_X4_FIELD_OVERRIDE_ENABLE
 * REGADDR:  0xc061
 * DESC:     Enable override of individual fields
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     T_CL91_CW_SCRAMBLE_OEN The hardware/software table field named t_cl91_cw_scramble is overriden with the value from the register tx_x4_control0-cl91_cw_scramble.
 *     T_FIVE_BIT_XOR_EN_OEN The hardware/software table field named t_five_bit_xor_en is overriden with the value from the register tx_x4_control0-five_bit_xor_en.
 *     T_PMA_CL91_MUX_SEL_OEN The hardware/software table field named t_pma_cl91_mux_sel is overriden with the value from the register tx_x4_control0-t_pma_cl91_mux_sel.
 *     T_PMA_WATERMARK_OEN The hardware/software table field named t_pma_watermark is overriden with the value from the register tx_x4_control0-t_pma_watermark.
 *     T_PMA_BITMUX_DELAY_OEN The hardware/software table field named t_pma_bitmux_delay is overriden with the value from the register tx_x4_control0-t_pma_bitmux_delay.
 *     MAC_CREDITGENCNT_OEN The hardware/software table field named mac_creditgencnt is overriden with the value from the register tx_x4_credit_gen0-mac_creditgencnt.
 *     LOOPCNT1_OEN     The hardware/software table field named loopcnt1 is overriden with the value from the register tx_x4_credit_gen0-loopcnt1.
 *     LOOPCNT0_OEN     The hardware/software table field named loopcnt0 is overriden with the value from the register tx_x4_credit_gen0-loopcnt0.
 *     CLOCKCNT1_OEN    The hardware/software table field named clockcnt1 is overriden with the value from the register tx_x4_credit_gen0-clockcnt1.
 *     CLOCKCNT0_OEN    The hardware/software table field named clockcnt0 is overriden with the value from the register tx_x4_credit_gen0-clockcnt0.
 *     CREDITENABLE_OEN The hardware/software table field named creditenable is overriden with the value from the register tx_x4_credit_gen0-creditenable.
 *     BS_BTMX_MODE_OEN The hardware/software table field named bs_btmx_mode is overriden with the value from the register rx_x4_control0-bs_btmx_mode.
 *     BS_DIST_MODE_OEN The hardware/software table field named bs_dist_mode is overriden with the value from the register rx_x4_control0-bs_dist_mode.
 *     BS_SYNC_EN_OEN   The hardware/software table field named bs_sync_en is overriden with the value from the register rx_x4_control0-bs_sync_en.
 *     BS_SM_SYNC_MODE_OEN The hardware/software table field named bs_sm_sync_mode is overriden with the value from the register rx_x4_control0-bs_sm_sync_mode.
 *     R_HG2_ENABLE_OEN The hardware/software table field named r_HG2_ENABLE is overriden with the value from the register rx_x4_control0-HG2_ENABLE.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr (0x0000c061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FLD_OVRR_EN1_TYPE.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_s {
	uint32_t v[1];
	uint32_t sc_x4_fld_ovrr_en1_type[1];
	uint32_t _sc_x4_fld_ovrr_en1_type;
} BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_t;

#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLR(r) (r).sc_x4_fld_ovrr_en1_type[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SET(r,d) (r).sc_x4_fld_ovrr_en1_type[0] = d
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_GET(r) (r).sc_x4_fld_ovrr_en1_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_R_HG2_ENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_R_HG2_ENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SM_SYNC_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SM_SYNC_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SYNC_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SYNC_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_DIST_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_DIST_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_BTMX_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_BTMX_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_BITMUX_DELAY_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_BITMUX_DELAY_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_WATERMARK_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_WATERMARK_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_CL91_MUX_SEL_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_CL91_MUX_SEL_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_FIVE_BIT_XOR_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en1_type[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_FIVE_BIT_XOR_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_CL91_CW_SCRAMBLE_OENf_GET(r) (((r).sc_x4_fld_ovrr_en1_type[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_CL91_CW_SCRAMBLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en1_type[0]=(((r).sc_x4_fld_ovrr_en1_type[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_FLD_OVRR_EN1_TYPE.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr,(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr,(_r._sc_x4_fld_ovrr_en1_type)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr,(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCD_XGXS_READLN_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en1_type))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN1_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fld_ovrr_en1_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr
#define SC_X4_FLD_OVRR_EN1_TYPEr_SIZE BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_t SC_X4_FLD_OVRR_EN1_TYPEr_t;
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLR BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLR
#define SC_X4_FLD_OVRR_EN1_TYPEr_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_R_HG2_ENABLE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_R_HG2_ENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_R_HG2_ENABLE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_R_HG2_ENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_SM_SYNC_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SM_SYNC_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_SM_SYNC_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SM_SYNC_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_SYNC_EN_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SYNC_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_SYNC_EN_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_SYNC_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_DIST_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_DIST_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_DIST_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_DIST_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_BTMX_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_BTMX_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_BS_BTMX_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_BS_BTMX_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CREDITENABLE_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_CLOCKCNT1_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT0_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_LOOPCNT1_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_MAC_CREDITGENCNT_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_BITMUX_DELAY_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_BITMUX_DELAY_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_BITMUX_DELAY_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_BITMUX_DELAY_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_WATERMARK_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_WATERMARK_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_WATERMARK_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_WATERMARK_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_CL91_MUX_SEL_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_CL91_MUX_SEL_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_CL91_MUX_SEL_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_PMA_CL91_MUX_SEL_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_FIVE_BIT_XOR_EN_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_FIVE_BIT_XOR_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_FIVE_BIT_XOR_EN_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_FIVE_BIT_XOR_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_CL91_CW_SCRAMBLE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_CL91_CW_SCRAMBLE_OENf_GET
#define SC_X4_FLD_OVRR_EN1_TYPEr_T_CL91_CW_SCRAMBLE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr_T_CL91_CW_SCRAMBLE_OENf_SET
#define READ_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCD_XGXS_READ_SC_X4_FLD_OVRR_EN1_TYPEr
#define WRITE_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCD_XGXS_WRITE_SC_X4_FLD_OVRR_EN1_TYPEr
#define MODIFY_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCD_XGXS_MODIFY_SC_X4_FLD_OVRR_EN1_TYPEr
#define READLN_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCD_XGXS_READLN_SC_X4_FLD_OVRR_EN1_TYPEr
#define WRITELN_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCD_XGXS_WRITELN_SC_X4_FLD_OVRR_EN1_TYPEr
#define WRITEALL_SC_X4_FLD_OVRR_EN1_TYPEr BCMI_TSCD_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN1_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN1_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_FLD_OVRR_EN2_TYPE
 * BLOCKS:   SC_X4_FIELD_OVERRIDE_ENABLE
 * REGADDR:  0xc062
 * DESC:     Enable override of individual fields
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_SPACING_MUL_OEN The hardware/software table field named AM_spacing_mul is overriden with the value from the register tx_x4_control0-AM_spacing_mul.
 *     CL91_BLKSYNC_MODE_OEN The hardware/software table field named cl91_blksync_mode is overriden with the value from the register rx_x4_control0-cl91_blksync_mode.
 *     R_MERGE_MODE_OEN The hardware/software table field named r_merge_mode is overriden with the value from the register rx_x4_control0-r_merge_mode.
 *     R_CL91_CW_SCRAMBLE_OEN The hardware/software table field named r_cl91_cw_scramble is overriden with the value from the register rx_x4_control0-cl91_cw_scramble.
 *     R_TC_IN_MODE_OEN The hardware/software table field named r_tc_in_mode is overriden with the value from the register rx_x4_control0-r_tc_in_mode.
 *     R_TC_MODE_OEN    The hardware/software table field named r_tc_mode is overriden with the value from the register rx_x4_control0-r_tc_mode.
 *     R_FIVE_BIT_XOR_EN_OEN The hardware/software table field named r_five_bit_xor_en is overriden with the value from the register rx_x4_control0-five_bit_xor_en.
 *     R_TC_OUT_MODE_OEN The hardware/software table field named r_tc_out_mode is overriden with the value from the register rx_x4_control0-r_tc_out_mode.
 *     CORRUPT_2ND_GROUP The hardware/software table field named corrupt_2nd_group is overriden with the value from the register sc_x4_control-corrupt_2nd_group.
 *     CORRUPT_6TH_GROUP The hardware/software table field named corrupt_6th_group is overriden with the value from the register sc_x4_control-corrupt_6th_group.
 *     CL74_SHCORRUPT   The hardware/software table field named cl74_shcorrupt is overriden with the value from the register sc_x4_control-cl74_shcorrupt.
 *     BER_COUNT_SEL    The hardware/software table field named ber_count_sel is overriden with the value from the register sc_x4_control-ber_count_sel.
 *     BER_WINDOW_SEL   The hardware/software table field ber_window_sel is overriden with the value from the register sc_x4_control-ber_window_sel.
 *     USE_100G_AM0     The hardware/software table field named use_100G_am0 is overriden with the value from the register sc_x4_control-use_100G_am0.
 *     USE_100G_AM123   The hardware/software table field named use_100G_am123 is overriden with the value from the register sc_x4_control-use_100G_am123.
 *     AM_FSM_LOCK_EXT  The hardware/software table field named recieve am_lock_fsm extention is overriden with the value from the register sc_x4_control-am_lock_fsm_ext.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr (0x0000c062 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FLD_OVRR_EN2_TYPE.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_s {
	uint32_t v[1];
	uint32_t sc_x4_fld_ovrr_en2_type[1];
	uint32_t _sc_x4_fld_ovrr_en2_type;
} BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_t;

#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CLR(r) (r).sc_x4_fld_ovrr_en2_type[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_SET(r,d) (r).sc_x4_fld_ovrr_en2_type[0] = d
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_GET(r) (r).sc_x4_fld_ovrr_en2_type[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_FSM_LOCK_EXTf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_FSM_LOCK_EXTf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM123f_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM123f_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM0f_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM0f_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_WINDOW_SELf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_WINDOW_SELf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_COUNT_SELf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_COUNT_SELf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL74_SHCORRUPTf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL74_SHCORRUPTf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_6TH_GROUPf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_6TH_GROUPf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_2ND_GROUPf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_2ND_GROUPf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_OUT_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_OUT_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_FIVE_BIT_XOR_EN_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_FIVE_BIT_XOR_EN_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_IN_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_IN_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_CL91_CW_SCRAMBLE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_CL91_CW_SCRAMBLE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_MERGE_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_MERGE_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL91_BLKSYNC_MODE_OENf_GET(r) ((((r).sc_x4_fld_ovrr_en2_type[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL91_BLKSYNC_MODE_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_SPACING_MUL_OENf_GET(r) (((r).sc_x4_fld_ovrr_en2_type[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_SPACING_MUL_OENf_SET(r,f) (r).sc_x4_fld_ovrr_en2_type[0]=(((r).sc_x4_fld_ovrr_en2_type[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_FLD_OVRR_EN2_TYPE.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_FLD_OVRR_EN2_TYPEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr,(_r._sc_x4_fld_ovrr_en2_type))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_FLD_OVRR_EN2_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr,(_r._sc_x4_fld_ovrr_en2_type)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_FLD_OVRR_EN2_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr,(_r._sc_x4_fld_ovrr_en2_type))
#define BCMI_TSCD_XGXS_READLN_SC_X4_FLD_OVRR_EN2_TYPEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en2_type))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_FLD_OVRR_EN2_TYPEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fld_ovrr_en2_type))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN2_TYPEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fld_ovrr_en2_type))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FLD_OVRR_EN2_TYPEr BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr
#define SC_X4_FLD_OVRR_EN2_TYPEr_SIZE BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_t SC_X4_FLD_OVRR_EN2_TYPEr_t;
#define SC_X4_FLD_OVRR_EN2_TYPEr_CLR BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CLR
#define SC_X4_FLD_OVRR_EN2_TYPEr_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_AM_FSM_LOCK_EXTf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_FSM_LOCK_EXTf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_AM_FSM_LOCK_EXTf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_FSM_LOCK_EXTf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM123f_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM123f_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM123f_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM123f_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM0f_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM0f_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM0f_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_USE_100G_AM0f_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_BER_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_WINDOW_SELf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_BER_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_WINDOW_SELf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_BER_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_COUNT_SELf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_BER_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_BER_COUNT_SELf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CL74_SHCORRUPTf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL74_SHCORRUPTf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CL74_SHCORRUPTf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL74_SHCORRUPTf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_6TH_GROUPf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_6TH_GROUPf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_6TH_GROUPf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_6TH_GROUPf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_2ND_GROUPf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_2ND_GROUPf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_2ND_GROUPf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CORRUPT_2ND_GROUPf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_OUT_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_OUT_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_OUT_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_OUT_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_FIVE_BIT_XOR_EN_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_FIVE_BIT_XOR_EN_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_FIVE_BIT_XOR_EN_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_FIVE_BIT_XOR_EN_OENf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_IN_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_IN_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_IN_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_TC_IN_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_CL91_CW_SCRAMBLE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_CL91_CW_SCRAMBLE_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_CL91_CW_SCRAMBLE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_CL91_CW_SCRAMBLE_OENf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_MERGE_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_MERGE_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_R_MERGE_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_R_MERGE_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CL91_BLKSYNC_MODE_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL91_BLKSYNC_MODE_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_CL91_BLKSYNC_MODE_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_CL91_BLKSYNC_MODE_OENf_SET
#define SC_X4_FLD_OVRR_EN2_TYPEr_AM_SPACING_MUL_OENf_GET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_SPACING_MUL_OENf_GET
#define SC_X4_FLD_OVRR_EN2_TYPEr_AM_SPACING_MUL_OENf_SET BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr_AM_SPACING_MUL_OENf_SET
#define READ_SC_X4_FLD_OVRR_EN2_TYPEr BCMI_TSCD_XGXS_READ_SC_X4_FLD_OVRR_EN2_TYPEr
#define WRITE_SC_X4_FLD_OVRR_EN2_TYPEr BCMI_TSCD_XGXS_WRITE_SC_X4_FLD_OVRR_EN2_TYPEr
#define MODIFY_SC_X4_FLD_OVRR_EN2_TYPEr BCMI_TSCD_XGXS_MODIFY_SC_X4_FLD_OVRR_EN2_TYPEr
#define READLN_SC_X4_FLD_OVRR_EN2_TYPEr BCMI_TSCD_XGXS_READLN_SC_X4_FLD_OVRR_EN2_TYPEr
#define WRITELN_SC_X4_FLD_OVRR_EN2_TYPEr BCMI_TSCD_XGXS_WRITELN_SC_X4_FLD_OVRR_EN2_TYPEr
#define WRITEALL_SC_X4_FLD_OVRR_EN2_TYPEr BCMI_TSCD_XGXS_WRITEALL_SC_X4_FLD_OVRR_EN2_TYPEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_FLD_OVRR_EN2_TYPEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD_SPD
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc070
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/O
 * FIELDS:
 *     NUM_LANES        Number of lanes for override configuration0   : NUM_LANES_01 - use 1 lane1   : NUM_LANES_02 - use 2 lanes2   : NUM_LANES_04 - use 4 lanes
 *     T_PMA_40B_MODE   1'b0 - 66-bit data write in t_pma.1'b1 - 40-bit data write in t_pma.
 *     CL36TX_EN        Per logical lane: cl36 TX pipeline: 1=enabled , 0=disabled
 *     CL36RX_EN        Per logical lane: cl36 RX pipeline: 1=enabled , 0=disabled
 *     CL36RX_10BIT_PMD_DATA_EN Per logical lane: Enables CL36 Rx Pipeline to use all 10-bits of PMD Rx data.This bit should be enabled in OS8.25 mode or 2.5G speed.
 *     SPEED            Actual speed set by SW
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr (0x0000c070 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD_SPD.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd_spd[1];
	uint32_t _sc_x4_rslvd_spd;
} BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CLR(r) (r).sc_x4_rslvd_spd[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SET(r,d) (r).sc_x4_rslvd_spd[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_GET(r) (r).sc_x4_rslvd_spd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_GET(r) ((((r).sc_x4_rslvd_spd[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET(r) ((((r).sc_x4_rslvd_spd[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_ENf_GET(r) ((((r).sc_x4_rslvd_spd[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_ENf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36TX_ENf_GET(r) ((((r).sc_x4_rslvd_spd[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36TX_ENf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_T_PMA_40B_MODEf_GET(r) ((((r).sc_x4_rslvd_spd[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_T_PMA_40B_MODEf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_GET(r) (((r).sc_x4_rslvd_spd[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_SET(r,f) (r).sc_x4_rslvd_spd[0]=(((r).sc_x4_rslvd_spd[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD_SPD.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr,(_r._sc_x4_rslvd_spd))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD_SPDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd_spd))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD_SPDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd_spd))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD_SPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd_spd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD_SPDr BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr
#define SC_X4_RSLVD_SPDr_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_t SC_X4_RSLVD_SPDr_t;
#define SC_X4_RSLVD_SPDr_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CLR
#define SC_X4_RSLVD_SPDr_SET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SET
#define SC_X4_RSLVD_SPDr_GET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_GET
#define SC_X4_RSLVD_SPDr_SPEEDf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_GET
#define SC_X4_RSLVD_SPDr_SPEEDf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_SPEEDf_SET
#define SC_X4_RSLVD_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_10BIT_PMD_DATA_ENf_GET
#define SC_X4_RSLVD_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_10BIT_PMD_DATA_ENf_SET
#define SC_X4_RSLVD_SPDr_CL36RX_ENf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_ENf_GET
#define SC_X4_RSLVD_SPDr_CL36RX_ENf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36RX_ENf_SET
#define SC_X4_RSLVD_SPDr_CL36TX_ENf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36TX_ENf_GET
#define SC_X4_RSLVD_SPDr_CL36TX_ENf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_CL36TX_ENf_SET
#define SC_X4_RSLVD_SPDr_T_PMA_40B_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_T_PMA_40B_MODEf_GET
#define SC_X4_RSLVD_SPDr_T_PMA_40B_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_T_PMA_40B_MODEf_SET
#define SC_X4_RSLVD_SPDr_NUM_LANESf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_GET
#define SC_X4_RSLVD_SPDr_NUM_LANESf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr_NUM_LANESf_SET
#define READ_SC_X4_RSLVD_SPDr BCMI_TSCD_XGXS_READ_SC_X4_RSLVD_SPDr
#define WRITE_SC_X4_RSLVD_SPDr BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD_SPDr
#define MODIFY_SC_X4_RSLVD_SPDr BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD_SPDr
#define READLN_SC_X4_RSLVD_SPDr BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD_SPDr
#define WRITELN_SC_X4_RSLVD_SPDr BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD_SPDr
#define WRITEALL_SC_X4_RSLVD_SPDr BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD_SPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD_SPDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD0
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc072
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     SCR_MODE         
 *     T_PMA_BTMX_MODE  Number of PCS lanes bitmuxed
 *     T_HG2_ENABLE     Enables HG2 support for PCS
 *     T_ENC_MODE       
 *     T_FIFO_MODE      T_FIFO stage control field
 *     OS_MODE          
 *     CL72_EN          Enables cl72
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r (0x0000c072 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD0.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD0r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd0[1];
	uint32_t _sc_x4_rslvd0;
} BCMI_TSCD_XGXS_SC_X4_RSLVD0r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_CLR(r) (r).sc_x4_rslvd0[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SET(r,d) (r).sc_x4_rslvd0[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_GET(r) (r).sc_x4_rslvd0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_CL72_ENf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_CL72_ENf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_OS_MODEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 11) & 0xf)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_OS_MODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_FIFO_MODEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_FIFO_MODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_ENC_MODEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_ENC_MODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_HG2_ENABLEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_HG2_ENABLEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_PMA_BTMX_MODEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_PMA_BTMX_MODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SCR_MODEf_GET(r) ((((r).sc_x4_rslvd0[0]) >> 1) & 0x7)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SCR_MODEf_SET(r,f) (r).sc_x4_rslvd0[0]=(((r).sc_x4_rslvd0[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))

/*
 * These macros can be used to access SC_X4_RSLVD0.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD0r,(_r._sc_x4_rslvd0))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD0r,(_r._sc_x4_rslvd0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD0r,(_r._sc_x4_rslvd0))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd0))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd0))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD0r BCMI_TSCD_XGXS_SC_X4_RSLVD0r
#define SC_X4_RSLVD0r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD0r_t SC_X4_RSLVD0r_t;
#define SC_X4_RSLVD0r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD0r_CLR
#define SC_X4_RSLVD0r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SET
#define SC_X4_RSLVD0r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_GET
#define SC_X4_RSLVD0r_CL72_ENf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_CL72_ENf_GET
#define SC_X4_RSLVD0r_CL72_ENf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_CL72_ENf_SET
#define SC_X4_RSLVD0r_OS_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_OS_MODEf_GET
#define SC_X4_RSLVD0r_OS_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_OS_MODEf_SET
#define SC_X4_RSLVD0r_T_FIFO_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_FIFO_MODEf_GET
#define SC_X4_RSLVD0r_T_FIFO_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_FIFO_MODEf_SET
#define SC_X4_RSLVD0r_T_ENC_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_ENC_MODEf_GET
#define SC_X4_RSLVD0r_T_ENC_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_ENC_MODEf_SET
#define SC_X4_RSLVD0r_T_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_HG2_ENABLEf_GET
#define SC_X4_RSLVD0r_T_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_HG2_ENABLEf_SET
#define SC_X4_RSLVD0r_T_PMA_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_PMA_BTMX_MODEf_GET
#define SC_X4_RSLVD0r_T_PMA_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_T_PMA_BTMX_MODEf_SET
#define SC_X4_RSLVD0r_SCR_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SCR_MODEf_GET
#define SC_X4_RSLVD0r_SCR_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD0r_SCR_MODEf_SET
#define READ_SC_X4_RSLVD0r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD0r
#define WRITE_SC_X4_RSLVD0r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD0r
#define MODIFY_SC_X4_RSLVD0r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD0r
#define READLN_SC_X4_RSLVD0r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD0r
#define WRITELN_SC_X4_RSLVD0r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD0r
#define WRITEALL_SC_X4_RSLVD0r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD1
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc073
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BS_BTMX_MODE     Bit-mux mode: Indicates the format of incoming data on a physical lane.
 *     BS_DIST_MODE     Block to lane distribution mode.BS_DIST_MODE_5_LANE_TDM - 5 lane TDM. Each block distributed in turn over output pseudo-logical lanes 0-4BS_DIST_MODE_2_LANE_TDM_2_VLANE - 2 lane TDM for 2 virtual lanes.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.Virtual Lane 1 output is ping-ponged over pseudo-logical lanes 1,3.BS_DIST_MODE_2_LANE_TDM_1_VLANE - 2 lane TDM for 1 virtual lane.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.BS_DIST_MODE_NO_TDM - No TDM. Virtual Lane output is sent directly to corresponding pseudo-logical lane.
 *     BS_SYNC_EN       Enable block synchronization: If enabled, block sync sm will attempt to slip data until sync is achieved.
 *     BS_SM_SYNC_MODE  Block Sync Mode: When bs_sync_en==1, this bit indicates if cl49 or cl82 state machine operation is used.1'b0 - Clause 821'b1 - Clause 49
 *     DEC_FSM_MODE     
 *     DESKEW_MODE      
 *     DEC_TL_MODE      
 *     DESCR_MODE       
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r (0x0000c073 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD1.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD1r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd1[1];
	uint32_t _sc_x4_rslvd1;
} BCMI_TSCD_XGXS_SC_X4_RSLVD1r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_CLR(r) (r).sc_x4_rslvd1[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_SET(r,d) (r).sc_x4_rslvd1[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_GET(r) (r).sc_x4_rslvd1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESCR_MODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESCR_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_TL_MODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_TL_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESKEW_MODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESKEW_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_FSM_MODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_FSM_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SM_SYNC_MODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SM_SYNC_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SYNC_ENf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SYNC_ENf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_DIST_MODEf_GET(r) ((((r).sc_x4_rslvd1[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_DIST_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_BTMX_MODEf_GET(r) (((r).sc_x4_rslvd1[0]) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_BTMX_MODEf_SET(r,f) (r).sc_x4_rslvd1[0]=(((r).sc_x4_rslvd1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD1.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD1r,(_r._sc_x4_rslvd1))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD1r,(_r._sc_x4_rslvd1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD1r,(_r._sc_x4_rslvd1))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd1))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd1))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD1r BCMI_TSCD_XGXS_SC_X4_RSLVD1r
#define SC_X4_RSLVD1r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD1r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD1r_t SC_X4_RSLVD1r_t;
#define SC_X4_RSLVD1r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD1r_CLR
#define SC_X4_RSLVD1r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_SET
#define SC_X4_RSLVD1r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_GET
#define SC_X4_RSLVD1r_DESCR_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESCR_MODEf_GET
#define SC_X4_RSLVD1r_DESCR_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESCR_MODEf_SET
#define SC_X4_RSLVD1r_DEC_TL_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_TL_MODEf_GET
#define SC_X4_RSLVD1r_DEC_TL_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_TL_MODEf_SET
#define SC_X4_RSLVD1r_DESKEW_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESKEW_MODEf_GET
#define SC_X4_RSLVD1r_DESKEW_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DESKEW_MODEf_SET
#define SC_X4_RSLVD1r_DEC_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_FSM_MODEf_GET
#define SC_X4_RSLVD1r_DEC_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_DEC_FSM_MODEf_SET
#define SC_X4_RSLVD1r_BS_SM_SYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SM_SYNC_MODEf_GET
#define SC_X4_RSLVD1r_BS_SM_SYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SM_SYNC_MODEf_SET
#define SC_X4_RSLVD1r_BS_SYNC_ENf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SYNC_ENf_GET
#define SC_X4_RSLVD1r_BS_SYNC_ENf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_SYNC_ENf_SET
#define SC_X4_RSLVD1r_BS_DIST_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_DIST_MODEf_GET
#define SC_X4_RSLVD1r_BS_DIST_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_DIST_MODEf_SET
#define SC_X4_RSLVD1r_BS_BTMX_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_BTMX_MODEf_GET
#define SC_X4_RSLVD1r_BS_BTMX_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD1r_BS_BTMX_MODEf_SET
#define READ_SC_X4_RSLVD1r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD1r
#define WRITE_SC_X4_RSLVD1r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD1r
#define MODIFY_SC_X4_RSLVD1r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD1r
#define READLN_SC_X4_RSLVD1r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD1r
#define WRITELN_SC_X4_RSLVD1r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD1r
#define WRITEALL_SC_X4_RSLVD1r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD2
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc074
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD2r (0x0000c074 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD2r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD2.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD2r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd2[1];
	uint32_t _sc_x4_rslvd2;
} BCMI_TSCD_XGXS_SC_X4_RSLVD2r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD2r_CLR(r) (r).sc_x4_rslvd2[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD2r_SET(r,d) (r).sc_x4_rslvd2[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD2r_GET(r) (r).sc_x4_rslvd2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD2r_CLOCKCNT0f_GET(r) (((r).sc_x4_rslvd2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD2r_CLOCKCNT0f_SET(r,f) (r).sc_x4_rslvd2[0]=(((r).sc_x4_rslvd2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD2.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD2r,(_r._sc_x4_rslvd2))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD2r,(_r._sc_x4_rslvd2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD2r,(_r._sc_x4_rslvd2))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd2))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd2))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD2r BCMI_TSCD_XGXS_SC_X4_RSLVD2r
#define SC_X4_RSLVD2r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD2r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD2r_t SC_X4_RSLVD2r_t;
#define SC_X4_RSLVD2r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD2r_CLR
#define SC_X4_RSLVD2r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD2r_SET
#define SC_X4_RSLVD2r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD2r_GET
#define SC_X4_RSLVD2r_CLOCKCNT0f_GET BCMI_TSCD_XGXS_SC_X4_RSLVD2r_CLOCKCNT0f_GET
#define SC_X4_RSLVD2r_CLOCKCNT0f_SET BCMI_TSCD_XGXS_SC_X4_RSLVD2r_CLOCKCNT0f_SET
#define READ_SC_X4_RSLVD2r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD2r
#define WRITE_SC_X4_RSLVD2r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD2r
#define MODIFY_SC_X4_RSLVD2r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD2r
#define READLN_SC_X4_RSLVD2r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD2r
#define WRITELN_SC_X4_RSLVD2r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD2r
#define WRITEALL_SC_X4_RSLVD2r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD3
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc075
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD3r (0x0000c075 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD3r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD3.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD3r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd3[1];
	uint32_t _sc_x4_rslvd3;
} BCMI_TSCD_XGXS_SC_X4_RSLVD3r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD3r_CLR(r) (r).sc_x4_rslvd3[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD3r_SET(r,d) (r).sc_x4_rslvd3[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD3r_GET(r) (r).sc_x4_rslvd3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD3r_CLOCKCNT1f_GET(r) (((r).sc_x4_rslvd3[0]) & 0xff)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD3r_CLOCKCNT1f_SET(r,f) (r).sc_x4_rslvd3[0]=(((r).sc_x4_rslvd3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD3.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD3r,(_r._sc_x4_rslvd3))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD3r,(_r._sc_x4_rslvd3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD3r,(_r._sc_x4_rslvd3))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd3))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd3))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD3r BCMI_TSCD_XGXS_SC_X4_RSLVD3r
#define SC_X4_RSLVD3r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD3r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD3r_t SC_X4_RSLVD3r_t;
#define SC_X4_RSLVD3r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD3r_CLR
#define SC_X4_RSLVD3r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD3r_SET
#define SC_X4_RSLVD3r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD3r_GET
#define SC_X4_RSLVD3r_CLOCKCNT1f_GET BCMI_TSCD_XGXS_SC_X4_RSLVD3r_CLOCKCNT1f_GET
#define SC_X4_RSLVD3r_CLOCKCNT1f_SET BCMI_TSCD_XGXS_SC_X4_RSLVD3r_CLOCKCNT1f_SET
#define READ_SC_X4_RSLVD3r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD3r
#define WRITE_SC_X4_RSLVD3r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD3r
#define MODIFY_SC_X4_RSLVD3r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD3r
#define READLN_SC_X4_RSLVD3r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD3r
#define WRITELN_SC_X4_RSLVD3r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD3r
#define WRITEALL_SC_X4_RSLVD3r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD4
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc076
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r (0x0000c076 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD4.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD4r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd4[1];
	uint32_t _sc_x4_rslvd4;
} BCMI_TSCD_XGXS_SC_X4_RSLVD4r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_CLR(r) (r).sc_x4_rslvd4[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_SET(r,d) (r).sc_x4_rslvd4[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_GET(r) (r).sc_x4_rslvd4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT0f_GET(r) ((((r).sc_x4_rslvd4[0]) >> 6) & 0xff)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT0f_SET(r,f) (r).sc_x4_rslvd4[0]=(((r).sc_x4_rslvd4[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT1f_GET(r) (((r).sc_x4_rslvd4[0]) & 0x3f)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT1f_SET(r,f) (r).sc_x4_rslvd4[0]=(((r).sc_x4_rslvd4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access SC_X4_RSLVD4.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD4r,(_r._sc_x4_rslvd4))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD4r,(_r._sc_x4_rslvd4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD4r,(_r._sc_x4_rslvd4))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd4))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd4))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD4r BCMI_TSCD_XGXS_SC_X4_RSLVD4r
#define SC_X4_RSLVD4r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD4r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD4r_t SC_X4_RSLVD4r_t;
#define SC_X4_RSLVD4r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD4r_CLR
#define SC_X4_RSLVD4r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD4r_SET
#define SC_X4_RSLVD4r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD4r_GET
#define SC_X4_RSLVD4r_LOOPCNT0f_GET BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT0f_GET
#define SC_X4_RSLVD4r_LOOPCNT0f_SET BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT0f_SET
#define SC_X4_RSLVD4r_LOOPCNT1f_GET BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT1f_GET
#define SC_X4_RSLVD4r_LOOPCNT1f_SET BCMI_TSCD_XGXS_SC_X4_RSLVD4r_LOOPCNT1f_SET
#define READ_SC_X4_RSLVD4r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD4r
#define WRITE_SC_X4_RSLVD4r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD4r
#define MODIFY_SC_X4_RSLVD4r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD4r
#define READLN_SC_X4_RSLVD4r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD4r
#define WRITELN_SC_X4_RSLVD4r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD4r
#define WRITEALL_SC_X4_RSLVD4r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD5
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc077
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MAC_CREDITGENCNT CGC for mac credit generation, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD5r (0x0000c077 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD5r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD5.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD5r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd5[1];
	uint32_t _sc_x4_rslvd5;
} BCMI_TSCD_XGXS_SC_X4_RSLVD5r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD5r_CLR(r) (r).sc_x4_rslvd5[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD5r_SET(r,d) (r).sc_x4_rslvd5[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD5r_GET(r) (r).sc_x4_rslvd5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD5r_MAC_CREDITGENCNTf_GET(r) (((r).sc_x4_rslvd5[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD5r_MAC_CREDITGENCNTf_SET(r,f) (r).sc_x4_rslvd5[0]=(((r).sc_x4_rslvd5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access SC_X4_RSLVD5.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD5r,(_r._sc_x4_rslvd5))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD5r,(_r._sc_x4_rslvd5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD5r,(_r._sc_x4_rslvd5))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd5))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd5))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD5r BCMI_TSCD_XGXS_SC_X4_RSLVD5r
#define SC_X4_RSLVD5r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD5r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD5r_t SC_X4_RSLVD5r_t;
#define SC_X4_RSLVD5r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD5r_CLR
#define SC_X4_RSLVD5r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD5r_SET
#define SC_X4_RSLVD5r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD5r_GET
#define SC_X4_RSLVD5r_MAC_CREDITGENCNTf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD5r_MAC_CREDITGENCNTf_GET
#define SC_X4_RSLVD5r_MAC_CREDITGENCNTf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD5r_MAC_CREDITGENCNTf_SET
#define READ_SC_X4_RSLVD5r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD5r
#define WRITE_SC_X4_RSLVD5r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD5r
#define MODIFY_SC_X4_RSLVD5r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD5r
#define READLN_SC_X4_RSLVD5r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD5r
#define WRITELN_SC_X4_RSLVD5r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD5r
#define WRITEALL_SC_X4_RSLVD5r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_FEC_STS
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc078
 * DESC:     Final speed configuration for FEC
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     R_FEC_ENABLE     Receive CL74 FEC enable status
 *     T_FEC_ENABLE     Transmit CL74 FEC enable status
 *     R_CL91_FEC_MODE  
 *     T_CL91_FEC_MODE  
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr (0x0000c078 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_FEC_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_FEC_STSr_s {
	uint32_t v[1];
	uint32_t sc_x4_fec_sts[1];
	uint32_t _sc_x4_fec_sts;
} BCMI_TSCD_XGXS_SC_X4_FEC_STSr_t;

#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_CLR(r) (r).sc_x4_fec_sts[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_SET(r,d) (r).sc_x4_fec_sts[0] = d
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_GET(r) (r).sc_x4_fec_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_CL91_FEC_MODEf_GET(r) ((((r).sc_x4_fec_sts[0]) >> 5) & 0x7)
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_CL91_FEC_MODEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_CL91_FEC_MODEf_GET(r) ((((r).sc_x4_fec_sts[0]) >> 2) & 0x7)
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_CL91_FEC_MODEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_GET(r) ((((r).sc_x4_fec_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_GET(r) (((r).sc_x4_fec_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_SET(r,f) (r).sc_x4_fec_sts[0]=(((r).sc_x4_fec_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_FEC_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_FEC_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FEC_STSr,(_r._sc_x4_fec_sts))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_FEC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FEC_STSr,(_r._sc_x4_fec_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_FEC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FEC_STSr,(_r._sc_x4_fec_sts))
#define BCMI_TSCD_XGXS_READLN_SC_X4_FEC_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_FEC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fec_sts))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_FEC_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FEC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_fec_sts))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_FEC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_FEC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_fec_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_FEC_STSr BCMI_TSCD_XGXS_SC_X4_FEC_STSr
#define SC_X4_FEC_STSr_SIZE BCMI_TSCD_XGXS_SC_X4_FEC_STSr_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_FEC_STSr_t SC_X4_FEC_STSr_t;
#define SC_X4_FEC_STSr_CLR BCMI_TSCD_XGXS_SC_X4_FEC_STSr_CLR
#define SC_X4_FEC_STSr_SET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_SET
#define SC_X4_FEC_STSr_GET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_GET
#define SC_X4_FEC_STSr_T_CL91_FEC_MODEf_GET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_CL91_FEC_MODEf_GET
#define SC_X4_FEC_STSr_T_CL91_FEC_MODEf_SET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_CL91_FEC_MODEf_SET
#define SC_X4_FEC_STSr_R_CL91_FEC_MODEf_GET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_CL91_FEC_MODEf_GET
#define SC_X4_FEC_STSr_R_CL91_FEC_MODEf_SET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_CL91_FEC_MODEf_SET
#define SC_X4_FEC_STSr_T_FEC_ENABLEf_GET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_GET
#define SC_X4_FEC_STSr_T_FEC_ENABLEf_SET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_T_FEC_ENABLEf_SET
#define SC_X4_FEC_STSr_R_FEC_ENABLEf_GET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_GET
#define SC_X4_FEC_STSr_R_FEC_ENABLEf_SET BCMI_TSCD_XGXS_SC_X4_FEC_STSr_R_FEC_ENABLEf_SET
#define READ_SC_X4_FEC_STSr BCMI_TSCD_XGXS_READ_SC_X4_FEC_STSr
#define WRITE_SC_X4_FEC_STSr BCMI_TSCD_XGXS_WRITE_SC_X4_FEC_STSr
#define MODIFY_SC_X4_FEC_STSr BCMI_TSCD_XGXS_MODIFY_SC_X4_FEC_STSr
#define READLN_SC_X4_FEC_STSr BCMI_TSCD_XGXS_READLN_SC_X4_FEC_STSr
#define WRITELN_SC_X4_FEC_STSr BCMI_TSCD_XGXS_WRITELN_SC_X4_FEC_STSr
#define WRITEALL_SC_X4_FEC_STSr BCMI_TSCD_XGXS_WRITEALL_SC_X4_FEC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_FEC_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD6
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc079
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     T_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword should be scrambled or not. It should be set to 1 in FC mode.
 *     T_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     T_PMA_CL91_MUX_SEL T_PMA MUX CL91 select.
 *     T_PMA_WATERMARK  T_PMA FIFO watermark. In units of 66-bit blocks.
 *     T_PMA_BITMUX_DELAY T_PMA FIFO delay after watermark is reached (in units of cycles)
 *     AM_SPACING_MUL   
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r (0x0000c079 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD6.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD6r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd6[1];
	uint32_t _sc_x4_rslvd6;
} BCMI_TSCD_XGXS_SC_X4_RSLVD6r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_CLR(r) (r).sc_x4_rslvd6[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_SET(r,d) (r).sc_x4_rslvd6[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_GET(r) (r).sc_x4_rslvd6[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_AM_SPACING_MULf_GET(r) ((((r).sc_x4_rslvd6[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_AM_SPACING_MULf_SET(r,f) (r).sc_x4_rslvd6[0]=(((r).sc_x4_rslvd6[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_BITMUX_DELAYf_GET(r) ((((r).sc_x4_rslvd6[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_BITMUX_DELAYf_SET(r,f) (r).sc_x4_rslvd6[0]=(((r).sc_x4_rslvd6[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_WATERMARKf_GET(r) ((((r).sc_x4_rslvd6[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_WATERMARKf_SET(r,f) (r).sc_x4_rslvd6[0]=(((r).sc_x4_rslvd6[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_CL91_MUX_SELf_GET(r) ((((r).sc_x4_rslvd6[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_CL91_MUX_SELf_SET(r,f) (r).sc_x4_rslvd6[0]=(((r).sc_x4_rslvd6[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x4_rslvd6[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x4_rslvd6[0]=(((r).sc_x4_rslvd6[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_CL91_CW_SCRAMBLEf_GET(r) (((r).sc_x4_rslvd6[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x4_rslvd6[0]=(((r).sc_x4_rslvd6[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD6.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD6r,(_r._sc_x4_rslvd6))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD6r,(_r._sc_x4_rslvd6)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD6r,(_r._sc_x4_rslvd6))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd6))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd6))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD6r BCMI_TSCD_XGXS_SC_X4_RSLVD6r
#define SC_X4_RSLVD6r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD6r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD6r_t SC_X4_RSLVD6r_t;
#define SC_X4_RSLVD6r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD6r_CLR
#define SC_X4_RSLVD6r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_SET
#define SC_X4_RSLVD6r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_GET
#define SC_X4_RSLVD6r_AM_SPACING_MULf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_AM_SPACING_MULf_GET
#define SC_X4_RSLVD6r_AM_SPACING_MULf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_AM_SPACING_MULf_SET
#define SC_X4_RSLVD6r_T_PMA_BITMUX_DELAYf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_BITMUX_DELAYf_GET
#define SC_X4_RSLVD6r_T_PMA_BITMUX_DELAYf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_BITMUX_DELAYf_SET
#define SC_X4_RSLVD6r_T_PMA_WATERMARKf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_WATERMARKf_GET
#define SC_X4_RSLVD6r_T_PMA_WATERMARKf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_WATERMARKf_SET
#define SC_X4_RSLVD6r_T_PMA_CL91_MUX_SELf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_CL91_MUX_SELf_GET
#define SC_X4_RSLVD6r_T_PMA_CL91_MUX_SELf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_PMA_CL91_MUX_SELf_SET
#define SC_X4_RSLVD6r_T_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_FIVE_BIT_XOR_ENf_GET
#define SC_X4_RSLVD6r_T_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_FIVE_BIT_XOR_ENf_SET
#define SC_X4_RSLVD6r_T_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_CL91_CW_SCRAMBLEf_GET
#define SC_X4_RSLVD6r_T_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD6r_T_CL91_CW_SCRAMBLEf_SET
#define READ_SC_X4_RSLVD6r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD6r
#define WRITE_SC_X4_RSLVD6r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD6r
#define MODIFY_SC_X4_RSLVD6r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD6r
#define READLN_SC_X4_RSLVD6r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD6r
#define WRITELN_SC_X4_RSLVD6r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD6r
#define WRITEALL_SC_X4_RSLVD6r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD7
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc07a
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL91_BLKSYNC_MODE 
 *     R_MERGE_MODE     
 *     R_CL91_CW_SCRAMBLE Indicates whether the CL91 codeword needs to be descrambled. Should be enabled for FC mode.
 *     R_TC_IN_MODE     Indicates whether CL91 is turned ON for the port or not.
 *     R_TC_MODE        
 *     R_FIVE_BIT_XOR_EN 1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     R_TC_OUT_MODE    
 *     R_HG2_ENABLE     Enables HG2 support for PCS
 *     R_AM_LOCK_FSM_MODE 1'b1 - AM lock extension mode is enabled.1'b0 - AM lock extension mode is disabled..
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r (0x0000c07a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD7.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD7r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd7[1];
	uint32_t _sc_x4_rslvd7;
} BCMI_TSCD_XGXS_SC_X4_RSLVD7r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_CLR(r) (r).sc_x4_rslvd7[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_SET(r,d) (r).sc_x4_rslvd7[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_GET(r) (r).sc_x4_rslvd7[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_AM_LOCK_FSM_MODEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_AM_LOCK_FSM_MODEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_HG2_ENABLEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_HG2_ENABLEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_OUT_MODEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_OUT_MODEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_FIVE_BIT_XOR_ENf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_FIVE_BIT_XOR_ENf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_MODEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_MODEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_IN_MODEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_IN_MODEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_CL91_CW_SCRAMBLEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_CL91_CW_SCRAMBLEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_MERGE_MODEf_GET(r) ((((r).sc_x4_rslvd7[0]) >> 3) & 0x7)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_MERGE_MODEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_CL91_BLKSYNC_MODEf_GET(r) (((r).sc_x4_rslvd7[0]) & 0x7)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD7r_CL91_BLKSYNC_MODEf_SET(r,f) (r).sc_x4_rslvd7[0]=(((r).sc_x4_rslvd7[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD7.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD7r,(_r._sc_x4_rslvd7))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD7r,(_r._sc_x4_rslvd7)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD7r,(_r._sc_x4_rslvd7))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd7))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd7))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD7r BCMI_TSCD_XGXS_SC_X4_RSLVD7r
#define SC_X4_RSLVD7r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD7r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD7r_t SC_X4_RSLVD7r_t;
#define SC_X4_RSLVD7r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD7r_CLR
#define SC_X4_RSLVD7r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_SET
#define SC_X4_RSLVD7r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_GET
#define SC_X4_RSLVD7r_R_AM_LOCK_FSM_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_AM_LOCK_FSM_MODEf_GET
#define SC_X4_RSLVD7r_R_AM_LOCK_FSM_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_AM_LOCK_FSM_MODEf_SET
#define SC_X4_RSLVD7r_R_HG2_ENABLEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_HG2_ENABLEf_GET
#define SC_X4_RSLVD7r_R_HG2_ENABLEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_HG2_ENABLEf_SET
#define SC_X4_RSLVD7r_R_TC_OUT_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_OUT_MODEf_GET
#define SC_X4_RSLVD7r_R_TC_OUT_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_OUT_MODEf_SET
#define SC_X4_RSLVD7r_R_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_FIVE_BIT_XOR_ENf_GET
#define SC_X4_RSLVD7r_R_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_FIVE_BIT_XOR_ENf_SET
#define SC_X4_RSLVD7r_R_TC_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_MODEf_GET
#define SC_X4_RSLVD7r_R_TC_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_MODEf_SET
#define SC_X4_RSLVD7r_R_TC_IN_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_IN_MODEf_GET
#define SC_X4_RSLVD7r_R_TC_IN_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_TC_IN_MODEf_SET
#define SC_X4_RSLVD7r_R_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_CL91_CW_SCRAMBLEf_GET
#define SC_X4_RSLVD7r_R_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_CL91_CW_SCRAMBLEf_SET
#define SC_X4_RSLVD7r_R_MERGE_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_MERGE_MODEf_GET
#define SC_X4_RSLVD7r_R_MERGE_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_R_MERGE_MODEf_SET
#define SC_X4_RSLVD7r_CL91_BLKSYNC_MODEf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_CL91_BLKSYNC_MODEf_GET
#define SC_X4_RSLVD7r_CL91_BLKSYNC_MODEf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD7r_CL91_BLKSYNC_MODEf_SET
#define READ_SC_X4_RSLVD7r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD7r
#define WRITE_SC_X4_RSLVD7r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD7r
#define MODIFY_SC_X4_RSLVD7r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD7r
#define READLN_SC_X4_RSLVD7r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD7r
#define WRITELN_SC_X4_RSLVD7r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD7r
#define WRITEALL_SC_X4_RSLVD7r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  SC_X4_RSLVD8
 * BLOCKS:   SC_X4_FINAL_CONFIG_STATUS
 * REGADDR:  0xc07b
 * DESC:     Final speed configuration for PCS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CORRUPT_2ND_GROUP Corrupt 2nd group of codeward
 *     CORRUPT_6TH_GROUP Corrupt 6th group of codeward
 *     CL74_SHCORRUPT   Sync Header Corruption for CL74 FEC Error (uncorrectable).0: Only 5 SH, 1: All SH corrupted.
 *     BER_COUNT_SEL    0: select count based on cl49 else based on cl82
 *     BER_WINDOW_SEL   0: select window based on cl49 else based on cl82
 *     USE_100G_AM0     AM0 will be taken from 100G AM
 *     USE_100G_AM123   AM 1, 2, 3 will be taken from 100G AMs
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r (0x0000c07b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_SIZE 4

/*
 * This structure should be used to declare and program SC_X4_RSLVD8.
 *
 */
typedef union BCMI_TSCD_XGXS_SC_X4_RSLVD8r_s {
	uint32_t v[1];
	uint32_t sc_x4_rslvd8[1];
	uint32_t _sc_x4_rslvd8;
} BCMI_TSCD_XGXS_SC_X4_RSLVD8r_t;

#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CLR(r) (r).sc_x4_rslvd8[0] = 0
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_SET(r,d) (r).sc_x4_rslvd8[0] = d
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_GET(r) (r).sc_x4_rslvd8[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM123f_GET(r) ((((r).sc_x4_rslvd8[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM123f_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM0f_GET(r) ((((r).sc_x4_rslvd8[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM0f_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_WINDOW_SELf_GET(r) ((((r).sc_x4_rslvd8[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_WINDOW_SELf_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_COUNT_SELf_GET(r) ((((r).sc_x4_rslvd8[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_COUNT_SELf_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CL74_SHCORRUPTf_GET(r) ((((r).sc_x4_rslvd8[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CL74_SHCORRUPTf_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_6TH_GROUPf_GET(r) ((((r).sc_x4_rslvd8[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_6TH_GROUPf_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_2ND_GROUPf_GET(r) (((r).sc_x4_rslvd8[0]) & 0x1)
#define BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_2ND_GROUPf_SET(r,f) (r).sc_x4_rslvd8[0]=(((r).sc_x4_rslvd8[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SC_X4_RSLVD8.
 *
 */
#define BCMI_TSCD_XGXS_READ_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD8r,(_r._sc_x4_rslvd8))
#define BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD8r,(_r._sc_x4_rslvd8)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD8r,(_r._sc_x4_rslvd8))
#define BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd8))
#define BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sc_x4_rslvd8))
#define BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_SC_X4_RSLVD8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sc_x4_rslvd8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SC_X4_RSLVD8r BCMI_TSCD_XGXS_SC_X4_RSLVD8r
#define SC_X4_RSLVD8r_SIZE BCMI_TSCD_XGXS_SC_X4_RSLVD8r_SIZE
typedef BCMI_TSCD_XGXS_SC_X4_RSLVD8r_t SC_X4_RSLVD8r_t;
#define SC_X4_RSLVD8r_CLR BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CLR
#define SC_X4_RSLVD8r_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_SET
#define SC_X4_RSLVD8r_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_GET
#define SC_X4_RSLVD8r_USE_100G_AM123f_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM123f_GET
#define SC_X4_RSLVD8r_USE_100G_AM123f_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM123f_SET
#define SC_X4_RSLVD8r_USE_100G_AM0f_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM0f_GET
#define SC_X4_RSLVD8r_USE_100G_AM0f_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_USE_100G_AM0f_SET
#define SC_X4_RSLVD8r_BER_WINDOW_SELf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_WINDOW_SELf_GET
#define SC_X4_RSLVD8r_BER_WINDOW_SELf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_WINDOW_SELf_SET
#define SC_X4_RSLVD8r_BER_COUNT_SELf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_COUNT_SELf_GET
#define SC_X4_RSLVD8r_BER_COUNT_SELf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_BER_COUNT_SELf_SET
#define SC_X4_RSLVD8r_CL74_SHCORRUPTf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CL74_SHCORRUPTf_GET
#define SC_X4_RSLVD8r_CL74_SHCORRUPTf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CL74_SHCORRUPTf_SET
#define SC_X4_RSLVD8r_CORRUPT_6TH_GROUPf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_6TH_GROUPf_GET
#define SC_X4_RSLVD8r_CORRUPT_6TH_GROUPf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_6TH_GROUPf_SET
#define SC_X4_RSLVD8r_CORRUPT_2ND_GROUPf_GET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_2ND_GROUPf_GET
#define SC_X4_RSLVD8r_CORRUPT_2ND_GROUPf_SET BCMI_TSCD_XGXS_SC_X4_RSLVD8r_CORRUPT_2ND_GROUPf_SET
#define READ_SC_X4_RSLVD8r BCMI_TSCD_XGXS_READ_SC_X4_RSLVD8r
#define WRITE_SC_X4_RSLVD8r BCMI_TSCD_XGXS_WRITE_SC_X4_RSLVD8r
#define MODIFY_SC_X4_RSLVD8r BCMI_TSCD_XGXS_MODIFY_SC_X4_RSLVD8r
#define READLN_SC_X4_RSLVD8r BCMI_TSCD_XGXS_READLN_SC_X4_RSLVD8r
#define WRITELN_SC_X4_RSLVD8r BCMI_TSCD_XGXS_WRITELN_SC_X4_RSLVD8r
#define WRITEALL_SC_X4_RSLVD8r BCMI_TSCD_XGXS_WRITEALL_SC_X4_RSLVD8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_SC_X4_RSLVD8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_CRED0
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc100
 * DESC:     clock count 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT0        clock count 0 for credit programming, range 5 to 4125
 *     CREDITENABLE     Enables credits to be generated for the MAC.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_CRED0r (0x0000c100 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_CRED0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CRED0.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_CRED0r_s {
	uint32_t v[1];
	uint32_t tx_x4_cred0[1];
	uint32_t _tx_x4_cred0;
} BCMI_TSCD_XGXS_TX_X4_CRED0r_t;

#define BCMI_TSCD_XGXS_TX_X4_CRED0r_CLR(r) (r).tx_x4_cred0[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_CRED0r_SET(r,d) (r).tx_x4_cred0[0] = d
#define BCMI_TSCD_XGXS_TX_X4_CRED0r_GET(r) (r).tx_x4_cred0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_CRED0r_CREDITENABLEf_GET(r) ((((r).tx_x4_cred0[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_CRED0r_CREDITENABLEf_SET(r,f) (r).tx_x4_cred0[0]=(((r).tx_x4_cred0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_TX_X4_CRED0r_CLOCKCNT0f_GET(r) (((r).tx_x4_cred0[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_TX_X4_CRED0r_CLOCKCNT0f_SET(r,f) (r).tx_x4_cred0[0]=(((r).tx_x4_cred0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_X4_CRED0.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_CRED0r,(_r._tx_x4_cred0))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED0r,(_r._tx_x4_cred0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED0r,(_r._tx_x4_cred0))
#define BCMI_TSCD_XGXS_READLN_TX_X4_CRED0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred0))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_CRED0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred0))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_CRED0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_cred0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CRED0r BCMI_TSCD_XGXS_TX_X4_CRED0r
#define TX_X4_CRED0r_SIZE BCMI_TSCD_XGXS_TX_X4_CRED0r_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_CRED0r_t TX_X4_CRED0r_t;
#define TX_X4_CRED0r_CLR BCMI_TSCD_XGXS_TX_X4_CRED0r_CLR
#define TX_X4_CRED0r_SET BCMI_TSCD_XGXS_TX_X4_CRED0r_SET
#define TX_X4_CRED0r_GET BCMI_TSCD_XGXS_TX_X4_CRED0r_GET
#define TX_X4_CRED0r_CREDITENABLEf_GET BCMI_TSCD_XGXS_TX_X4_CRED0r_CREDITENABLEf_GET
#define TX_X4_CRED0r_CREDITENABLEf_SET BCMI_TSCD_XGXS_TX_X4_CRED0r_CREDITENABLEf_SET
#define TX_X4_CRED0r_CLOCKCNT0f_GET BCMI_TSCD_XGXS_TX_X4_CRED0r_CLOCKCNT0f_GET
#define TX_X4_CRED0r_CLOCKCNT0f_SET BCMI_TSCD_XGXS_TX_X4_CRED0r_CLOCKCNT0f_SET
#define READ_TX_X4_CRED0r BCMI_TSCD_XGXS_READ_TX_X4_CRED0r
#define WRITE_TX_X4_CRED0r BCMI_TSCD_XGXS_WRITE_TX_X4_CRED0r
#define MODIFY_TX_X4_CRED0r BCMI_TSCD_XGXS_MODIFY_TX_X4_CRED0r
#define READLN_TX_X4_CRED0r BCMI_TSCD_XGXS_READLN_TX_X4_CRED0r
#define WRITELN_TX_X4_CRED0r BCMI_TSCD_XGXS_WRITELN_TX_X4_CRED0r
#define WRITEALL_TX_X4_CRED0r BCMI_TSCD_XGXS_WRITEALL_TX_X4_CRED0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_CRED0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_CRED1
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc101
 * DESC:     clock count 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CLOCKCNT1        clock count 1 for credit programming, range 4 to 12
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_CRED1r (0x0000c101 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_CRED1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CRED1.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_CRED1r_s {
	uint32_t v[1];
	uint32_t tx_x4_cred1[1];
	uint32_t _tx_x4_cred1;
} BCMI_TSCD_XGXS_TX_X4_CRED1r_t;

#define BCMI_TSCD_XGXS_TX_X4_CRED1r_CLR(r) (r).tx_x4_cred1[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_CRED1r_SET(r,d) (r).tx_x4_cred1[0] = d
#define BCMI_TSCD_XGXS_TX_X4_CRED1r_GET(r) (r).tx_x4_cred1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_CRED1r_CLOCKCNT1f_GET(r) (((r).tx_x4_cred1[0]) & 0xff)
#define BCMI_TSCD_XGXS_TX_X4_CRED1r_CLOCKCNT1f_SET(r,f) (r).tx_x4_cred1[0]=(((r).tx_x4_cred1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X4_CRED1.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_CRED1r,(_r._tx_x4_cred1))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED1r,(_r._tx_x4_cred1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED1r,(_r._tx_x4_cred1))
#define BCMI_TSCD_XGXS_READLN_TX_X4_CRED1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred1))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_CRED1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cred1))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_CRED1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CRED1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_cred1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CRED1r BCMI_TSCD_XGXS_TX_X4_CRED1r
#define TX_X4_CRED1r_SIZE BCMI_TSCD_XGXS_TX_X4_CRED1r_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_CRED1r_t TX_X4_CRED1r_t;
#define TX_X4_CRED1r_CLR BCMI_TSCD_XGXS_TX_X4_CRED1r_CLR
#define TX_X4_CRED1r_SET BCMI_TSCD_XGXS_TX_X4_CRED1r_SET
#define TX_X4_CRED1r_GET BCMI_TSCD_XGXS_TX_X4_CRED1r_GET
#define TX_X4_CRED1r_CLOCKCNT1f_GET BCMI_TSCD_XGXS_TX_X4_CRED1r_CLOCKCNT1f_GET
#define TX_X4_CRED1r_CLOCKCNT1f_SET BCMI_TSCD_XGXS_TX_X4_CRED1r_CLOCKCNT1f_SET
#define READ_TX_X4_CRED1r BCMI_TSCD_XGXS_READ_TX_X4_CRED1r
#define WRITE_TX_X4_CRED1r BCMI_TSCD_XGXS_WRITE_TX_X4_CRED1r
#define MODIFY_TX_X4_CRED1r BCMI_TSCD_XGXS_MODIFY_TX_X4_CRED1r
#define READLN_TX_X4_CRED1r BCMI_TSCD_XGXS_READLN_TX_X4_CRED1r
#define WRITELN_TX_X4_CRED1r BCMI_TSCD_XGXS_WRITELN_TX_X4_CRED1r
#define WRITEALL_TX_X4_CRED1r BCMI_TSCD_XGXS_WRITEALL_TX_X4_CRED1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_CRED1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_LOOPCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc102
 * DESC:     loop count 1_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LOOPCNT1         loop count 1 for credit programming, range 2 to 18
 *     LOOPCNT0         loop count 0 for credit programming, range 1 to 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr (0x0000c102 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_LOOPCNT.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_loopcnt[1];
	uint32_t _tx_x4_loopcnt;
} BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_t;

#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_CLR(r) (r).tx_x4_loopcnt[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_SET(r,d) (r).tx_x4_loopcnt[0] = d
#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_GET(r) (r).tx_x4_loopcnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_GET(r) ((((r).tx_x4_loopcnt[0]) >> 6) & 0xff)
#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_SET(r,f) (r).tx_x4_loopcnt[0]=(((r).tx_x4_loopcnt[0] & ~((uint32_t)0xff << 6)) | ((((uint32_t)f) & 0xff) << 6)) | (255 << (16 + 6))
#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_GET(r) (((r).tx_x4_loopcnt[0]) & 0x3f)
#define BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_SET(r,f) (r).tx_x4_loopcnt[0]=(((r).tx_x4_loopcnt[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_X4_LOOPCNT.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_LOOPCNTr,(_r._tx_x4_loopcnt))
#define BCMI_TSCD_XGXS_READLN_TX_X4_LOOPCNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_loopcnt))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_LOOPCNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_loopcnt))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_LOOPCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_LOOPCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_loopcnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_LOOPCNTr BCMI_TSCD_XGXS_TX_X4_LOOPCNTr
#define TX_X4_LOOPCNTr_SIZE BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_t TX_X4_LOOPCNTr_t;
#define TX_X4_LOOPCNTr_CLR BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_CLR
#define TX_X4_LOOPCNTr_SET BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_SET
#define TX_X4_LOOPCNTr_GET BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_GET
#define TX_X4_LOOPCNTr_LOOPCNT0f_GET BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_GET
#define TX_X4_LOOPCNTr_LOOPCNT0f_SET BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT0f_SET
#define TX_X4_LOOPCNTr_LOOPCNT1f_GET BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_GET
#define TX_X4_LOOPCNTr_LOOPCNT1f_SET BCMI_TSCD_XGXS_TX_X4_LOOPCNTr_LOOPCNT1f_SET
#define READ_TX_X4_LOOPCNTr BCMI_TSCD_XGXS_READ_TX_X4_LOOPCNTr
#define WRITE_TX_X4_LOOPCNTr BCMI_TSCD_XGXS_WRITE_TX_X4_LOOPCNTr
#define MODIFY_TX_X4_LOOPCNTr BCMI_TSCD_XGXS_MODIFY_TX_X4_LOOPCNTr
#define READLN_TX_X4_LOOPCNTr BCMI_TSCD_XGXS_READLN_TX_X4_LOOPCNTr
#define WRITELN_TX_X4_LOOPCNTr BCMI_TSCD_XGXS_WRITELN_TX_X4_LOOPCNTr
#define WRITEALL_TX_X4_LOOPCNTr BCMI_TSCD_XGXS_WRITEALL_TX_X4_LOOPCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_LOOPCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_MAC_CREDGENCNT
 * BLOCKS:   TX_X4_CREDIT0
 * REGADDR:  0xc103
 * DESC:     credit gen count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MAC_CREDITGENCNT clock count 0 for credit programming, range 1 to 2063
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr (0x0000c103 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_MAC_CREDGENCNT.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_s {
	uint32_t v[1];
	uint32_t tx_x4_mac_credgencnt[1];
	uint32_t _tx_x4_mac_credgencnt;
} BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_t;

#define BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_CLR(r) (r).tx_x4_mac_credgencnt[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_SET(r,d) (r).tx_x4_mac_credgencnt[0] = d
#define BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_GET(r) (r).tx_x4_mac_credgencnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET(r) (((r).tx_x4_mac_credgencnt[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET(r,f) (r).tx_x4_mac_credgencnt[0]=(((r).tx_x4_mac_credgencnt[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access TX_X4_MAC_CREDGENCNT.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr,(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr,(_r._tx_x4_mac_credgencnt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr,(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCD_XGXS_READLN_TX_X4_MAC_CREDGENCNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_MAC_CREDGENCNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_mac_credgencnt))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_MAC_CREDGENCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_mac_credgencnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_MAC_CREDGENCNTr BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr
#define TX_X4_MAC_CREDGENCNTr_SIZE BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_t TX_X4_MAC_CREDGENCNTr_t;
#define TX_X4_MAC_CREDGENCNTr_CLR BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_CLR
#define TX_X4_MAC_CREDGENCNTr_SET BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_SET
#define TX_X4_MAC_CREDGENCNTr_GET BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_GET
#define TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_GET
#define TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr_MAC_CREDITGENCNTf_SET
#define READ_TX_X4_MAC_CREDGENCNTr BCMI_TSCD_XGXS_READ_TX_X4_MAC_CREDGENCNTr
#define WRITE_TX_X4_MAC_CREDGENCNTr BCMI_TSCD_XGXS_WRITE_TX_X4_MAC_CREDGENCNTr
#define MODIFY_TX_X4_MAC_CREDGENCNTr BCMI_TSCD_XGXS_MODIFY_TX_X4_MAC_CREDGENCNTr
#define READLN_TX_X4_MAC_CREDGENCNTr BCMI_TSCD_XGXS_READLN_TX_X4_MAC_CREDGENCNTr
#define WRITELN_TX_X4_MAC_CREDGENCNTr BCMI_TSCD_XGXS_WRITELN_TX_X4_MAC_CREDGENCNTr
#define WRITEALL_TX_X4_MAC_CREDGENCNTr BCMI_TSCD_XGXS_WRITEALL_TX_X4_MAC_CREDGENCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_MAC_CREDGENCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_ENC0
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc111
 * DESC:     Encode 0 register
 * RESETVAL: 0x1800 (6144)
 * ACCESS:   R/W
 * FIELDS:
 *     T_ENC_MODE       
 *     T_FIFO_MODE      T_FIFO stage control field
 *     AM_SPACING_MUL   
 *     CL49_TX_TL_MODE  2'b01 - Force encoder output to local faults.2'b10 - Force encoder output to idles.
 *     CL49_BYPASS_TXSM Bypass cl49 transmit state machine1 = Bypass cl49 txsm :- force TX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *     HG2_ENABLE       Enables HG2 support for PCS
 *     HG2_MESSAGE_INVALID_CODE_ENABLE Enables HG2 invalid message code support.
 *     HG2_CODEC        Enables HG2 extensions support for PCSSet this bit to enable HG2 messaging
 *     BLOCK_NON_FC_BLK_TYPES Convert the following block types to errors - 0x87, 0x99, 0xAA, 0xCC, 0xD2, 0xE1
 *     DIS_SCRAMBLER    Disable the TX scrambler
 *     TX_TEST_MODE_CFG Force cl82 encoder output to idles.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_ENC0r (0x0000c111 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_ENC0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENC0.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_ENC0r_s {
	uint32_t v[1];
	uint32_t tx_x4_enc0[1];
	uint32_t _tx_x4_enc0;
} BCMI_TSCD_XGXS_TX_X4_ENC0r_t;

#define BCMI_TSCD_XGXS_TX_X4_ENC0r_CLR(r) (r).tx_x4_enc0[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_SET(r,d) (r).tx_x4_enc0[0] = d
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_GET(r) (r).tx_x4_enc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_TX_TEST_MODE_CFGf_GET(r) ((((r).tx_x4_enc0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_TX_TEST_MODE_CFGf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_DIS_SCRAMBLERf_GET(r) ((((r).tx_x4_enc0[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_DIS_SCRAMBLERf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_BLOCK_NON_FC_BLK_TYPESf_GET(r) ((((r).tx_x4_enc0[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_BLOCK_NON_FC_BLK_TYPESf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_CODECf_GET(r) ((((r).tx_x4_enc0[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_CODECf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET(r) ((((r).tx_x4_enc0[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_ENABLEf_GET(r) ((((r).tx_x4_enc0[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_ENABLEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_GET(r) ((((r).tx_x4_enc0[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_GET(r) ((((r).tx_x4_enc0[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_AM_SPACING_MULf_GET(r) ((((r).tx_x4_enc0[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_AM_SPACING_MULf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_T_FIFO_MODEf_GET(r) ((((r).tx_x4_enc0[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_T_FIFO_MODEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_T_ENC_MODEf_GET(r) (((r).tx_x4_enc0[0]) & 0x3)
#define BCMI_TSCD_XGXS_TX_X4_ENC0r_T_ENC_MODEf_SET(r,f) (r).tx_x4_enc0[0]=(((r).tx_x4_enc0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TX_X4_ENC0.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_ENC0r,(_r._tx_x4_enc0))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC0r,(_r._tx_x4_enc0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC0r,(_r._tx_x4_enc0))
#define BCMI_TSCD_XGXS_READLN_TX_X4_ENC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_ENC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc0))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_ENC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc0))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_ENC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_enc0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENC0r BCMI_TSCD_XGXS_TX_X4_ENC0r
#define TX_X4_ENC0r_SIZE BCMI_TSCD_XGXS_TX_X4_ENC0r_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_ENC0r_t TX_X4_ENC0r_t;
#define TX_X4_ENC0r_CLR BCMI_TSCD_XGXS_TX_X4_ENC0r_CLR
#define TX_X4_ENC0r_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_SET
#define TX_X4_ENC0r_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_GET
#define TX_X4_ENC0r_TX_TEST_MODE_CFGf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_TX_TEST_MODE_CFGf_GET
#define TX_X4_ENC0r_TX_TEST_MODE_CFGf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_TX_TEST_MODE_CFGf_SET
#define TX_X4_ENC0r_DIS_SCRAMBLERf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_DIS_SCRAMBLERf_GET
#define TX_X4_ENC0r_DIS_SCRAMBLERf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_DIS_SCRAMBLERf_SET
#define TX_X4_ENC0r_BLOCK_NON_FC_BLK_TYPESf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_BLOCK_NON_FC_BLK_TYPESf_GET
#define TX_X4_ENC0r_BLOCK_NON_FC_BLK_TYPESf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_BLOCK_NON_FC_BLK_TYPESf_SET
#define TX_X4_ENC0r_HG2_CODECf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_CODECf_GET
#define TX_X4_ENC0r_HG2_CODECf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_CODECf_SET
#define TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET
#define TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET
#define TX_X4_ENC0r_HG2_ENABLEf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_ENABLEf_GET
#define TX_X4_ENC0r_HG2_ENABLEf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_HG2_ENABLEf_SET
#define TX_X4_ENC0r_CL49_BYPASS_TXSMf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_GET
#define TX_X4_ENC0r_CL49_BYPASS_TXSMf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_BYPASS_TXSMf_SET
#define TX_X4_ENC0r_CL49_TX_TL_MODEf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_GET
#define TX_X4_ENC0r_CL49_TX_TL_MODEf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_CL49_TX_TL_MODEf_SET
#define TX_X4_ENC0r_AM_SPACING_MULf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_AM_SPACING_MULf_GET
#define TX_X4_ENC0r_AM_SPACING_MULf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_AM_SPACING_MULf_SET
#define TX_X4_ENC0r_T_FIFO_MODEf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_T_FIFO_MODEf_GET
#define TX_X4_ENC0r_T_FIFO_MODEf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_T_FIFO_MODEf_SET
#define TX_X4_ENC0r_T_ENC_MODEf_GET BCMI_TSCD_XGXS_TX_X4_ENC0r_T_ENC_MODEf_GET
#define TX_X4_ENC0r_T_ENC_MODEf_SET BCMI_TSCD_XGXS_TX_X4_ENC0r_T_ENC_MODEf_SET
#define READ_TX_X4_ENC0r BCMI_TSCD_XGXS_READ_TX_X4_ENC0r
#define WRITE_TX_X4_ENC0r BCMI_TSCD_XGXS_WRITE_TX_X4_ENC0r
#define MODIFY_TX_X4_ENC0r BCMI_TSCD_XGXS_MODIFY_TX_X4_ENC0r
#define READLN_TX_X4_ENC0r BCMI_TSCD_XGXS_READLN_TX_X4_ENC0r
#define WRITELN_TX_X4_ENC0r BCMI_TSCD_XGXS_WRITELN_TX_X4_ENC0r
#define WRITEALL_TX_X4_ENC0r BCMI_TSCD_XGXS_WRITEALL_TX_X4_ENC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_ENC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_MISC
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc113
 * DESC:     Misc register
 * RESETVAL: 0x1c0 (448)
 * ACCESS:   R/W
 * FIELDS:
 *     ENABLE_TX_LANE   Per lane enable to allow DVs from MAC to enter TXP
 *     RSTB_TX_LANE     Low active reset for txp lanes
 *     OS_MODE          
 *     CL49_TX_RF_ENABLE If this bit is a one, RFs are passed from the RS LAYER to the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the PCS.For CL49 only.
 *     CL49_TX_LF_ENABLE If this bit is a one, LFs are passed from the RS LAYER to the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the PCS.For CL49 only.
 *     CL49_TX_LI_ENABLE If this bit is a one, LIs (Link Interrupt) are passed thru to the RS LAYER.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the RS LAYER.For CL49 only.
 *     T_PMA_40B_MODE   1'b0 - 66-bit data write in t_pma.1'b1 - 40-bit data write in t_pma.
 *     FEC_ENABLE       Enable Transmit FEC.
 *     T_PMA_BTMX_MODE  Number of PCS lanes bitmuxed
 *     SCR_MODE         
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_MISCr (0x0000c113 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_MISCr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_MISC.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_MISCr_s {
	uint32_t v[1];
	uint32_t tx_x4_misc[1];
	uint32_t _tx_x4_misc;
} BCMI_TSCD_XGXS_TX_X4_MISCr_t;

#define BCMI_TSCD_XGXS_TX_X4_MISCr_CLR(r) (r).tx_x4_misc[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_MISCr_SET(r,d) (r).tx_x4_misc[0] = d
#define BCMI_TSCD_XGXS_TX_X4_MISCr_GET(r) (r).tx_x4_misc[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_MISCr_SCR_MODEf_GET(r) ((((r).tx_x4_misc[0]) >> 13) & 0x7)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_SCR_MODEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_BTMX_MODEf_GET(r) ((((r).tx_x4_misc[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_BTMX_MODEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_FEC_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_FEC_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_40B_MODEf_GET(r) ((((r).tx_x4_misc[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_40B_MODEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET(r) ((((r).tx_x4_misc[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_OS_MODEf_GET(r) ((((r).tx_x4_misc[0]) >> 2) & 0xf)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_OS_MODEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET(r) ((((r).tx_x4_misc[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET(r) (((r).tx_x4_misc[0]) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET(r,f) (r).tx_x4_misc[0]=(((r).tx_x4_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_MISC.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MISCr,(_r._tx_x4_misc)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MISCr,(_r._tx_x4_misc))
#define BCMI_TSCD_XGXS_READLN_TX_X4_MISCr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_misc))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_MISCr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_misc))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_MISCr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_misc))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_MISCr BCMI_TSCD_XGXS_TX_X4_MISCr
#define TX_X4_MISCr_SIZE BCMI_TSCD_XGXS_TX_X4_MISCr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_MISCr_t TX_X4_MISCr_t;
#define TX_X4_MISCr_CLR BCMI_TSCD_XGXS_TX_X4_MISCr_CLR
#define TX_X4_MISCr_SET BCMI_TSCD_XGXS_TX_X4_MISCr_SET
#define TX_X4_MISCr_GET BCMI_TSCD_XGXS_TX_X4_MISCr_GET
#define TX_X4_MISCr_SCR_MODEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_SCR_MODEf_GET
#define TX_X4_MISCr_SCR_MODEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_SCR_MODEf_SET
#define TX_X4_MISCr_T_PMA_BTMX_MODEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_BTMX_MODEf_GET
#define TX_X4_MISCr_T_PMA_BTMX_MODEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_BTMX_MODEf_SET
#define TX_X4_MISCr_FEC_ENABLEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_FEC_ENABLEf_GET
#define TX_X4_MISCr_FEC_ENABLEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_FEC_ENABLEf_SET
#define TX_X4_MISCr_T_PMA_40B_MODEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_40B_MODEf_GET
#define TX_X4_MISCr_T_PMA_40B_MODEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_T_PMA_40B_MODEf_SET
#define TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LI_ENABLEf_SET
#define TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_LF_ENABLEf_SET
#define TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_GET
#define TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_CL49_TX_RF_ENABLEf_SET
#define TX_X4_MISCr_OS_MODEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_OS_MODEf_GET
#define TX_X4_MISCr_OS_MODEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_OS_MODEf_SET
#define TX_X4_MISCr_RSTB_TX_LANEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_GET
#define TX_X4_MISCr_RSTB_TX_LANEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_RSTB_TX_LANEf_SET
#define TX_X4_MISCr_ENABLE_TX_LANEf_GET BCMI_TSCD_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_GET
#define TX_X4_MISCr_ENABLE_TX_LANEf_SET BCMI_TSCD_XGXS_TX_X4_MISCr_ENABLE_TX_LANEf_SET
#define READ_TX_X4_MISCr BCMI_TSCD_XGXS_READ_TX_X4_MISCr
#define WRITE_TX_X4_MISCr BCMI_TSCD_XGXS_WRITE_TX_X4_MISCr
#define MODIFY_TX_X4_MISCr BCMI_TSCD_XGXS_MODIFY_TX_X4_MISCr
#define READLN_TX_X4_MISCr BCMI_TSCD_XGXS_READLN_TX_X4_MISCr
#define WRITELN_TX_X4_MISCr BCMI_TSCD_XGXS_WRITELN_TX_X4_MISCr
#define WRITEALL_TX_X4_MISCr BCMI_TSCD_XGXS_WRITEALL_TX_X4_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_MISCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_CL36_CTL
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc114
 * DESC:     CL36 TX control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36TX_EN        Per logical lane: cl36 TX pipeline: 1=enabled , 0=disabled
 *     CL36TX_LPI_EN    Support for transmit of /LI/ code: 1=enabled , 0=disabledIf disabled (0), LPIs are converted to IDLEs
 *     CL36TX_CATCH_ALL_8B10B_DIS The following logic implements the catch-all special code-group case indicatedin the IEEE Std 802.3-2005, Table 48-2. Basically, it states that any invalidcode-group NOT defined in either Table 36-2 Valid special code-groups, orTable 48-2 XGMII character to PCS code-group mapping, shall be mapped tospecial code-group K30.7 (i.e. 10'h1FE). An input mux muxes out the actualinput data[7:0] or the 10'h1FE onto the internal bus, data_int, which drivesthe orginal 8b10b logic. A control, named catch_all_8b10b_dis, is used to turn offthe catch-all; default is catch-all is ON.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr (0x0000c114 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_CL36_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_s {
	uint32_t v[1];
	uint32_t tx_x4_cl36_ctl[1];
	uint32_t _tx_x4_cl36_ctl;
} BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_t;

#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CLR(r) (r).tx_x4_cl36_ctl[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_SET(r,d) (r).tx_x4_cl36_ctl[0] = d
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_GET(r) (r).tx_x4_cl36_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_GET(r) ((((r).tx_x4_cl36_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_SET(r,f) (r).tx_x4_cl36_ctl[0]=(((r).tx_x4_cl36_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_LPI_ENf_GET(r) ((((r).tx_x4_cl36_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_LPI_ENf_SET(r,f) (r).tx_x4_cl36_ctl[0]=(((r).tx_x4_cl36_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_ENf_GET(r) (((r).tx_x4_cl36_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_ENf_SET(r,f) (r).tx_x4_cl36_ctl[0]=(((r).tx_x4_cl36_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_CL36_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_CL36_CTLr,(_r._tx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CL36_CTLr,(_r._tx_x4_cl36_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CL36_CTLr,(_r._tx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_READLN_TX_X4_CL36_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_CL36_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_CL36_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CL36_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_CL36_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_cl36_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_CL36_CTLr BCMI_TSCD_XGXS_TX_X4_CL36_CTLr
#define TX_X4_CL36_CTLr_SIZE BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_t TX_X4_CL36_CTLr_t;
#define TX_X4_CL36_CTLr_CLR BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CLR
#define TX_X4_CL36_CTLr_SET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_SET
#define TX_X4_CL36_CTLr_GET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_GET
#define TX_X4_CL36_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_GET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_GET
#define TX_X4_CL36_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_SET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_CATCH_ALL_8B10B_DISf_SET
#define TX_X4_CL36_CTLr_CL36TX_LPI_ENf_GET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_LPI_ENf_GET
#define TX_X4_CL36_CTLr_CL36TX_LPI_ENf_SET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_LPI_ENf_SET
#define TX_X4_CL36_CTLr_CL36TX_ENf_GET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_ENf_GET
#define TX_X4_CL36_CTLr_CL36TX_ENf_SET BCMI_TSCD_XGXS_TX_X4_CL36_CTLr_CL36TX_ENf_SET
#define READ_TX_X4_CL36_CTLr BCMI_TSCD_XGXS_READ_TX_X4_CL36_CTLr
#define WRITE_TX_X4_CL36_CTLr BCMI_TSCD_XGXS_WRITE_TX_X4_CL36_CTLr
#define MODIFY_TX_X4_CL36_CTLr BCMI_TSCD_XGXS_MODIFY_TX_X4_CL36_CTLr
#define READLN_TX_X4_CL36_CTLr BCMI_TSCD_XGXS_READLN_TX_X4_CL36_CTLr
#define WRITELN_TX_X4_CL36_CTLr BCMI_TSCD_XGXS_WRITELN_TX_X4_CL36_CTLr
#define WRITEALL_TX_X4_CL36_CTLr BCMI_TSCD_XGXS_WRITEALL_TX_X4_CL36_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_CL36_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_TX_CTL0
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc115
 * DESC:     TX control 0 register
 * RESETVAL: 0xb8 (184)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_CW_SCRAMBLE Indicates whether the CL91 codeword should be scrambled or not. It should be set to 1 in FC mode.
 *     FIVE_BIT_XOR_EN  1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     T_PMA_CL91_MUX_SEL T_PMA MUX CL91 select.
 *     T_PMA_WATERMARK  T_PMA FIFO watermark. In units of 66-bit blocks.
 *     T_PMA_BITMUX_DELAY T_PMA FIFO delay after watermark is reached (in units of cycles)
 *     CL91_FEC_MODE    
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r (0x0000c115 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_CTL0.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_ctl0[1];
	uint32_t _tx_x4_tx_ctl0;
} BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_t;

#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CLR(r) (r).tx_x4_tx_ctl0[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_SET(r,d) (r).tx_x4_tx_ctl0[0] = d
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_GET(r) (r).tx_x4_tx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_FEC_MODEf_GET(r) ((((r).tx_x4_tx_ctl0[0]) >> 9) & 0x7)
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_FEC_MODEf_SET(r,f) (r).tx_x4_tx_ctl0[0]=(((r).tx_x4_tx_ctl0[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_BITMUX_DELAYf_GET(r) ((((r).tx_x4_tx_ctl0[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_BITMUX_DELAYf_SET(r,f) (r).tx_x4_tx_ctl0[0]=(((r).tx_x4_tx_ctl0[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_WATERMARKf_GET(r) ((((r).tx_x4_tx_ctl0[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_WATERMARKf_SET(r,f) (r).tx_x4_tx_ctl0[0]=(((r).tx_x4_tx_ctl0[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_CL91_MUX_SELf_GET(r) ((((r).tx_x4_tx_ctl0[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_CL91_MUX_SELf_SET(r,f) (r).tx_x4_tx_ctl0[0]=(((r).tx_x4_tx_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_FIVE_BIT_XOR_ENf_GET(r) ((((r).tx_x4_tx_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_FIVE_BIT_XOR_ENf_SET(r,f) (r).tx_x4_tx_ctl0[0]=(((r).tx_x4_tx_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_CW_SCRAMBLEf_GET(r) (((r).tx_x4_tx_ctl0[0]) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_CW_SCRAMBLEf_SET(r,f) (r).tx_x4_tx_ctl0[0]=(((r).tx_x4_tx_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_TX_CTL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_TX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_CTL0r,(_r._tx_x4_tx_ctl0))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_CTL0r,(_r._tx_x4_tx_ctl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_CTL0r,(_r._tx_x4_tx_ctl0))
#define BCMI_TSCD_XGXS_READLN_TX_X4_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ctl0))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ctl0))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_CTL0r BCMI_TSCD_XGXS_TX_X4_TX_CTL0r
#define TX_X4_TX_CTL0r_SIZE BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_t TX_X4_TX_CTL0r_t;
#define TX_X4_TX_CTL0r_CLR BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CLR
#define TX_X4_TX_CTL0r_SET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_SET
#define TX_X4_TX_CTL0r_GET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_GET
#define TX_X4_TX_CTL0r_CL91_FEC_MODEf_GET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_FEC_MODEf_GET
#define TX_X4_TX_CTL0r_CL91_FEC_MODEf_SET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_FEC_MODEf_SET
#define TX_X4_TX_CTL0r_T_PMA_BITMUX_DELAYf_GET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_BITMUX_DELAYf_GET
#define TX_X4_TX_CTL0r_T_PMA_BITMUX_DELAYf_SET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_BITMUX_DELAYf_SET
#define TX_X4_TX_CTL0r_T_PMA_WATERMARKf_GET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_WATERMARKf_GET
#define TX_X4_TX_CTL0r_T_PMA_WATERMARKf_SET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_WATERMARKf_SET
#define TX_X4_TX_CTL0r_T_PMA_CL91_MUX_SELf_GET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_CL91_MUX_SELf_GET
#define TX_X4_TX_CTL0r_T_PMA_CL91_MUX_SELf_SET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_T_PMA_CL91_MUX_SELf_SET
#define TX_X4_TX_CTL0r_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_FIVE_BIT_XOR_ENf_GET
#define TX_X4_TX_CTL0r_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_FIVE_BIT_XOR_ENf_SET
#define TX_X4_TX_CTL0r_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_CW_SCRAMBLEf_GET
#define TX_X4_TX_CTL0r_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_TX_X4_TX_CTL0r_CL91_CW_SCRAMBLEf_SET
#define READ_TX_X4_TX_CTL0r BCMI_TSCD_XGXS_READ_TX_X4_TX_CTL0r
#define WRITE_TX_X4_TX_CTL0r BCMI_TSCD_XGXS_WRITE_TX_X4_TX_CTL0r
#define MODIFY_TX_X4_TX_CTL0r BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_CTL0r
#define READLN_TX_X4_TX_CTL0r BCMI_TSCD_XGXS_READLN_TX_X4_TX_CTL0r
#define WRITELN_TX_X4_TX_CTL0r BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_CTL0r
#define WRITEALL_TX_X4_TX_CTL0r BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_TX_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_TX_TS_POINT_CTL
 * BLOCKS:   TX_X4_CONTROL0
 * REGADDR:  0xc116
 * DESC:     Tx Timestamping Point Control Register
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_SFD_TIMESTAMP_EN Enabling SFD based timestamping of TS transmit packets0: Timestamp TS packets based on SOP byte.1: Timestamp TS packets based on SFD byte.
 *     TX_DA_TIMESTAMP_EN Enabling DA based timestamping of TS transmit packets0: Timestamp TS packets based on First Byte of DA is disabled.1: Timestamp TS packets based on First Byte of DA is enabled.Setting this bit to 0, enables SFD or SOP based tx_sfd_timestamp_enIf DA timestamp enable is active SFD timestamp enable (tx_sfd_timestamp_en) should 0
 *     OSTS_CRC_CALC_MODE CRC calcualtion mode used in one-step timestamping packets0 : Start CRC calculation from the 9th byte of the packet.To be used with IEEE speeds only".1 : Start CRC calculation from the 1st byte of the packet.SOP byte also included for CRC. To be used with Higig2 speeds only and no GMII speeds.tx_sfd_timestamp_en" should be set to 0, when this mode is enabled.2 : Start CRC calculation from the 2nd byte of the packet.SOP byte also excluded for CRC. To be used with Higig2 speeds only and no GMII speeds.tx_sfd_timestamp_en" should be set to 0, when this mode is enabled.3 : Reserved.
 *     REDUCED_PREAMBLE_EN 0: default 7 bytes of preamble.1: 3 bytes of preamble.
 *     TS_INT_EN        Two Step Timestamp Interrupt Enable1'b1 - Interrupt Enabled
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr (0x0000c116 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_TS_POINT_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_ts_point_ctl[1];
	uint32_t _tx_x4_tx_ts_point_ctl;
} BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_t;

#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_CLR(r) (r).tx_x4_tx_ts_point_ctl[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_SET(r,d) (r).tx_x4_tx_ts_point_ctl[0] = d
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_GET(r) (r).tx_x4_tx_ts_point_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TS_INT_ENf_GET(r) ((((r).tx_x4_tx_ts_point_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TS_INT_ENf_SET(r,f) (r).tx_x4_tx_ts_point_ctl[0]=(((r).tx_x4_tx_ts_point_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_REDUCED_PREAMBLE_ENf_GET(r) ((((r).tx_x4_tx_ts_point_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_REDUCED_PREAMBLE_ENf_SET(r,f) (r).tx_x4_tx_ts_point_ctl[0]=(((r).tx_x4_tx_ts_point_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_OSTS_CRC_CALC_MODEf_GET(r) ((((r).tx_x4_tx_ts_point_ctl[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_OSTS_CRC_CALC_MODEf_SET(r,f) (r).tx_x4_tx_ts_point_ctl[0]=(((r).tx_x4_tx_ts_point_ctl[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_DA_TIMESTAMP_ENf_GET(r) ((((r).tx_x4_tx_ts_point_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_DA_TIMESTAMP_ENf_SET(r,f) (r).tx_x4_tx_ts_point_ctl[0]=(((r).tx_x4_tx_ts_point_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_SFD_TIMESTAMP_ENf_GET(r) (((r).tx_x4_tx_ts_point_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_SFD_TIMESTAMP_ENf_SET(r,f) (r).tx_x4_tx_ts_point_ctl[0]=(((r).tx_x4_tx_ts_point_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_TX_TS_POINT_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_TX_TS_POINT_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr,(_r._tx_x4_tx_ts_point_ctl))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_TX_TS_POINT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr,(_r._tx_x4_tx_ts_point_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_TS_POINT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr,(_r._tx_x4_tx_ts_point_ctl))
#define BCMI_TSCD_XGXS_READLN_TX_X4_TX_TS_POINT_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ts_point_ctl))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_TS_POINT_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ts_point_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_TS_POINT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_ts_point_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_TS_POINT_CTLr BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr
#define TX_X4_TX_TS_POINT_CTLr_SIZE BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_t TX_X4_TX_TS_POINT_CTLr_t;
#define TX_X4_TX_TS_POINT_CTLr_CLR BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_CLR
#define TX_X4_TX_TS_POINT_CTLr_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_SET
#define TX_X4_TX_TS_POINT_CTLr_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_GET
#define TX_X4_TX_TS_POINT_CTLr_TS_INT_ENf_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TS_INT_ENf_GET
#define TX_X4_TX_TS_POINT_CTLr_TS_INT_ENf_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TS_INT_ENf_SET
#define TX_X4_TX_TS_POINT_CTLr_REDUCED_PREAMBLE_ENf_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_REDUCED_PREAMBLE_ENf_GET
#define TX_X4_TX_TS_POINT_CTLr_REDUCED_PREAMBLE_ENf_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_REDUCED_PREAMBLE_ENf_SET
#define TX_X4_TX_TS_POINT_CTLr_OSTS_CRC_CALC_MODEf_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_OSTS_CRC_CALC_MODEf_GET
#define TX_X4_TX_TS_POINT_CTLr_OSTS_CRC_CALC_MODEf_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_OSTS_CRC_CALC_MODEf_SET
#define TX_X4_TX_TS_POINT_CTLr_TX_DA_TIMESTAMP_ENf_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_DA_TIMESTAMP_ENf_GET
#define TX_X4_TX_TS_POINT_CTLr_TX_DA_TIMESTAMP_ENf_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_DA_TIMESTAMP_ENf_SET
#define TX_X4_TX_TS_POINT_CTLr_TX_SFD_TIMESTAMP_ENf_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_SFD_TIMESTAMP_ENf_GET
#define TX_X4_TX_TS_POINT_CTLr_TX_SFD_TIMESTAMP_ENf_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr_TX_SFD_TIMESTAMP_ENf_SET
#define READ_TX_X4_TX_TS_POINT_CTLr BCMI_TSCD_XGXS_READ_TX_X4_TX_TS_POINT_CTLr
#define WRITE_TX_X4_TX_TS_POINT_CTLr BCMI_TSCD_XGXS_WRITE_TX_X4_TX_TS_POINT_CTLr
#define MODIFY_TX_X4_TX_TS_POINT_CTLr BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_TS_POINT_CTLr
#define READLN_TX_X4_TX_TS_POINT_CTLr BCMI_TSCD_XGXS_READLN_TX_X4_TX_TS_POINT_CTLr
#define WRITELN_TX_X4_TX_TS_POINT_CTLr BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_TS_POINT_CTLr
#define WRITEALL_TX_X4_TX_TS_POINT_CTLr BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_TS_POINT_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_TX_TS_POINT_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_ENC_STS0
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc120
 * DESC:     Encode Status 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL49_TXSM_STATE  Transmit SM - current state
 *     CL49_T_TYPE_CODED Transmit SM - current t_type
 *     CL82_IDLE_DELETION_UNDERFLOW Not enough IPG between ||A|| in MLD mode and CL91 single lane mode.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r (0x0000c120 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENC_STS0.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_s {
	uint32_t v[1];
	uint32_t tx_x4_enc_sts0[1];
	uint32_t _tx_x4_enc_sts0;
} BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_t;

#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CLR(r) (r).tx_x4_enc_sts0[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_SET(r,d) (r).tx_x4_enc_sts0[0] = d
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_GET(r) (r).tx_x4_enc_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_GET(r) ((((r).tx_x4_enc_sts0[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_SET(r,f) (r).tx_x4_enc_sts0[0]=(((r).tx_x4_enc_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_GET(r) ((((r).tx_x4_enc_sts0[0]) >> 3) & 0xf)
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_SET(r,f) (r).tx_x4_enc_sts0[0]=(((r).tx_x4_enc_sts0[0] & ~((uint32_t)0xf << 3)) | ((((uint32_t)f) & 0xf) << 3)) | (15 << (16 + 3))
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_GET(r) (((r).tx_x4_enc_sts0[0]) & 0x7)
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_SET(r,f) (r).tx_x4_enc_sts0[0]=(((r).tx_x4_enc_sts0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access TX_X4_ENC_STS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS0r,(_r._tx_x4_enc_sts0))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS0r,(_r._tx_x4_enc_sts0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS0r,(_r._tx_x4_enc_sts0))
#define BCMI_TSCD_XGXS_READLN_TX_X4_ENC_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts0))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_ENC_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts0))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_ENC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_enc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENC_STS0r BCMI_TSCD_XGXS_TX_X4_ENC_STS0r
#define TX_X4_ENC_STS0r_SIZE BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_t TX_X4_ENC_STS0r_t;
#define TX_X4_ENC_STS0r_CLR BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CLR
#define TX_X4_ENC_STS0r_SET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_SET
#define TX_X4_ENC_STS0r_GET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_GET
#define TX_X4_ENC_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_GET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_GET
#define TX_X4_ENC_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_SET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL82_IDLE_DELETION_UNDERFLOWf_SET
#define TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_GET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_GET
#define TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_SET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_T_TYPE_CODEDf_SET
#define TX_X4_ENC_STS0r_CL49_TXSM_STATEf_GET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_GET
#define TX_X4_ENC_STS0r_CL49_TXSM_STATEf_SET BCMI_TSCD_XGXS_TX_X4_ENC_STS0r_CL49_TXSM_STATEf_SET
#define READ_TX_X4_ENC_STS0r BCMI_TSCD_XGXS_READ_TX_X4_ENC_STS0r
#define WRITE_TX_X4_ENC_STS0r BCMI_TSCD_XGXS_WRITE_TX_X4_ENC_STS0r
#define MODIFY_TX_X4_ENC_STS0r BCMI_TSCD_XGXS_MODIFY_TX_X4_ENC_STS0r
#define READLN_TX_X4_ENC_STS0r BCMI_TSCD_XGXS_READLN_TX_X4_ENC_STS0r
#define WRITELN_TX_X4_ENC_STS0r BCMI_TSCD_XGXS_WRITELN_TX_X4_ENC_STS0r
#define WRITEALL_TX_X4_ENC_STS0r BCMI_TSCD_XGXS_WRITEALL_TX_X4_ENC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_ENC_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_ENC_STS1
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc121
 * DESC:     Encode Status 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_LTXSM_STATE Transmit SM - latched states - latched on entry
 *     CL49_TX_FAULT_DET A latched status bit indicating that the cl49 encoder has a local or remote fault block.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r (0x0000c121 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_ENC_STS1.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_s {
	uint32_t v[1];
	uint32_t tx_x4_enc_sts1[1];
	uint32_t _tx_x4_enc_sts1;
} BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_t;

#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CLR(r) (r).tx_x4_enc_sts1[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_SET(r,d) (r).tx_x4_enc_sts1[0] = d
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_GET(r) (r).tx_x4_enc_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_GET(r) ((((r).tx_x4_enc_sts1[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_SET(r,f) (r).tx_x4_enc_sts1[0]=(((r).tx_x4_enc_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_GET(r) (((r).tx_x4_enc_sts1[0]) & 0xff)
#define BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_SET(r,f) (r).tx_x4_enc_sts1[0]=(((r).tx_x4_enc_sts1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access TX_X4_ENC_STS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_ENC_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS1r,(_r._tx_x4_enc_sts1))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_ENC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS1r,(_r._tx_x4_enc_sts1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_ENC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS1r,(_r._tx_x4_enc_sts1))
#define BCMI_TSCD_XGXS_READLN_TX_X4_ENC_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts1))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_ENC_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_enc_sts1))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_ENC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_ENC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_enc_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_ENC_STS1r BCMI_TSCD_XGXS_TX_X4_ENC_STS1r
#define TX_X4_ENC_STS1r_SIZE BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_t TX_X4_ENC_STS1r_t;
#define TX_X4_ENC_STS1r_CLR BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CLR
#define TX_X4_ENC_STS1r_SET BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_SET
#define TX_X4_ENC_STS1r_GET BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_GET
#define TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_GET BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_GET
#define TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_SET BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_TX_FAULT_DETf_SET
#define TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_GET BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_GET
#define TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_SET BCMI_TSCD_XGXS_TX_X4_ENC_STS1r_CL49_LTXSM_STATEf_SET
#define READ_TX_X4_ENC_STS1r BCMI_TSCD_XGXS_READ_TX_X4_ENC_STS1r
#define WRITE_TX_X4_ENC_STS1r BCMI_TSCD_XGXS_WRITE_TX_X4_ENC_STS1r
#define MODIFY_TX_X4_ENC_STS1r BCMI_TSCD_XGXS_MODIFY_TX_X4_ENC_STS1r
#define READLN_TX_X4_ENC_STS1r BCMI_TSCD_XGXS_READLN_TX_X4_ENC_STS1r
#define WRITELN_TX_X4_ENC_STS1r BCMI_TSCD_XGXS_WRITELN_TX_X4_ENC_STS1r
#define WRITEALL_TX_X4_ENC_STS1r BCMI_TSCD_XGXS_WRITEALL_TX_X4_ENC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_ENC_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_PCS_STS_LIVE
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc122
 * DESC:     Live Status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_LPI_RECEIVED  PER PORT: Live LPI (LOW POWER IDLE ) indicator
 *     TX_LINK_INTERRUPT PER PORT: Live LI (LINK INTERRUPT) indicator
 *     TX_REMOTE_FAULT  PER PORT: Live RF (REMOTE FAULT ) indicator
 *     TX_LOCAL_FAULT   PER PORT: Live LF (LOCAL FAULT ) indicator
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr (0x0000c122 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_STS_LIVE.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_sts_live[1];
	uint32_t _tx_x4_pcs_sts_live;
} BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_t;

#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_CLR(r) (r).tx_x4_pcs_sts_live[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_SET(r,d) (r).tx_x4_pcs_sts_live[0] = d
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_GET(r) (r).tx_x4_pcs_sts_live[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LOCAL_FAULTf_GET(r) ((((r).tx_x4_pcs_sts_live[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LOCAL_FAULTf_SET(r,f) (r).tx_x4_pcs_sts_live[0]=(((r).tx_x4_pcs_sts_live[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_REMOTE_FAULTf_GET(r) ((((r).tx_x4_pcs_sts_live[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_REMOTE_FAULTf_SET(r,f) (r).tx_x4_pcs_sts_live[0]=(((r).tx_x4_pcs_sts_live[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LINK_INTERRUPTf_GET(r) ((((r).tx_x4_pcs_sts_live[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LINK_INTERRUPTf_SET(r,f) (r).tx_x4_pcs_sts_live[0]=(((r).tx_x4_pcs_sts_live[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LPI_RECEIVEDf_GET(r) (((r).tx_x4_pcs_sts_live[0]) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LPI_RECEIVEDf_SET(r,f) (r).tx_x4_pcs_sts_live[0]=(((r).tx_x4_pcs_sts_live[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_PCS_STS_LIVE.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_PCS_STS_LIVEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr,(_r._tx_x4_pcs_sts_live))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_PCS_STS_LIVEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr,(_r._tx_x4_pcs_sts_live)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_PCS_STS_LIVEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr,(_r._tx_x4_pcs_sts_live))
#define BCMI_TSCD_XGXS_READLN_TX_X4_PCS_STS_LIVEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts_live))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_PCS_STS_LIVEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts_live))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_PCS_STS_LIVEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_pcs_sts_live))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_STS_LIVEr BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr
#define TX_X4_PCS_STS_LIVEr_SIZE BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_t TX_X4_PCS_STS_LIVEr_t;
#define TX_X4_PCS_STS_LIVEr_CLR BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_CLR
#define TX_X4_PCS_STS_LIVEr_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_SET
#define TX_X4_PCS_STS_LIVEr_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_GET
#define TX_X4_PCS_STS_LIVEr_TX_LOCAL_FAULTf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LOCAL_FAULTf_GET
#define TX_X4_PCS_STS_LIVEr_TX_LOCAL_FAULTf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LOCAL_FAULTf_SET
#define TX_X4_PCS_STS_LIVEr_TX_REMOTE_FAULTf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_REMOTE_FAULTf_GET
#define TX_X4_PCS_STS_LIVEr_TX_REMOTE_FAULTf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_REMOTE_FAULTf_SET
#define TX_X4_PCS_STS_LIVEr_TX_LINK_INTERRUPTf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LINK_INTERRUPTf_GET
#define TX_X4_PCS_STS_LIVEr_TX_LINK_INTERRUPTf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LINK_INTERRUPTf_SET
#define TX_X4_PCS_STS_LIVEr_TX_LPI_RECEIVEDf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LPI_RECEIVEDf_GET
#define TX_X4_PCS_STS_LIVEr_TX_LPI_RECEIVEDf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr_TX_LPI_RECEIVEDf_SET
#define READ_TX_X4_PCS_STS_LIVEr BCMI_TSCD_XGXS_READ_TX_X4_PCS_STS_LIVEr
#define WRITE_TX_X4_PCS_STS_LIVEr BCMI_TSCD_XGXS_WRITE_TX_X4_PCS_STS_LIVEr
#define MODIFY_TX_X4_PCS_STS_LIVEr BCMI_TSCD_XGXS_MODIFY_TX_X4_PCS_STS_LIVEr
#define READLN_TX_X4_PCS_STS_LIVEr BCMI_TSCD_XGXS_READLN_TX_X4_PCS_STS_LIVEr
#define WRITELN_TX_X4_PCS_STS_LIVEr BCMI_TSCD_XGXS_WRITELN_TX_X4_PCS_STS_LIVEr
#define WRITEALL_TX_X4_PCS_STS_LIVEr BCMI_TSCD_XGXS_WRITEALL_TX_X4_PCS_STS_LIVEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_PCS_STS_LIVEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_PCS_STS_LATCH
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc123
 * DESC:     Latched Status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LPI_RECEIVED_LH  PER PORT: Low Power Indicator (LPI) has transitioned high since last read.Clear on read
 *     REMOTE_FAULT_LH  PER PORT: Remote Fault (RF)  has transitioned high since last read.Clear on read
 *     LOCAL_FAULT_LH   PER PORT: Local Fault (LF) indicator has transitioned high since last read.Clear on read
 *     LINK_INTERRUPT_LH PER PORT: LI (LINK INTERRUPT) indicator has transitioned high since last read.Clear on read
 *     TWO_STEP_TS_FIFO_OVERFLOW_LH PER PORT: Indicates 1588 Two-step Timestamp FIFO Overflow has occured,since last read on this register. Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr (0x0000c123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PCS_STS_LATCH.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_s {
	uint32_t v[1];
	uint32_t tx_x4_pcs_sts_latch[1];
	uint32_t _tx_x4_pcs_sts_latch;
} BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_t;

#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_CLR(r) (r).tx_x4_pcs_sts_latch[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_SET(r,d) (r).tx_x4_pcs_sts_latch[0] = d
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_GET(r) (r).tx_x4_pcs_sts_latch[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_TWO_STEP_TS_FIFO_OVERFLOW_LHf_GET(r) ((((r).tx_x4_pcs_sts_latch[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_TWO_STEP_TS_FIFO_OVERFLOW_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_GET(r) ((((r).tx_x4_pcs_sts_latch[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_sts_latch[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_GET(r) ((((r).tx_x4_pcs_sts_latch[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_GET(r) (((r).tx_x4_pcs_sts_latch[0]) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_SET(r,f) (r).tx_x4_pcs_sts_latch[0]=(((r).tx_x4_pcs_sts_latch[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_X4_PCS_STS_LATCH.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr,(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr,(_r._tx_x4_pcs_sts_latch)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr,(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCD_XGXS_READLN_TX_X4_PCS_STS_LATCHr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_PCS_STS_LATCHr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pcs_sts_latch))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_PCS_STS_LATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_pcs_sts_latch))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PCS_STS_LATCHr BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr
#define TX_X4_PCS_STS_LATCHr_SIZE BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_t TX_X4_PCS_STS_LATCHr_t;
#define TX_X4_PCS_STS_LATCHr_CLR BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_CLR
#define TX_X4_PCS_STS_LATCHr_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_SET
#define TX_X4_PCS_STS_LATCHr_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_GET
#define TX_X4_PCS_STS_LATCHr_TWO_STEP_TS_FIFO_OVERFLOW_LHf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_TWO_STEP_TS_FIFO_OVERFLOW_LHf_GET
#define TX_X4_PCS_STS_LATCHr_TWO_STEP_TS_FIFO_OVERFLOW_LHf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_TWO_STEP_TS_FIFO_OVERFLOW_LHf_SET
#define TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_GET
#define TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LINK_INTERRUPT_LHf_SET
#define TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_GET
#define TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LOCAL_FAULT_LHf_SET
#define TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_GET
#define TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_REMOTE_FAULT_LHf_SET
#define TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_GET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_GET
#define TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_SET BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr_LPI_RECEIVED_LHf_SET
#define READ_TX_X4_PCS_STS_LATCHr BCMI_TSCD_XGXS_READ_TX_X4_PCS_STS_LATCHr
#define WRITE_TX_X4_PCS_STS_LATCHr BCMI_TSCD_XGXS_WRITE_TX_X4_PCS_STS_LATCHr
#define MODIFY_TX_X4_PCS_STS_LATCHr BCMI_TSCD_XGXS_MODIFY_TX_X4_PCS_STS_LATCHr
#define READLN_TX_X4_PCS_STS_LATCHr BCMI_TSCD_XGXS_READLN_TX_X4_PCS_STS_LATCHr
#define WRITELN_TX_X4_PCS_STS_LATCHr BCMI_TSCD_XGXS_WRITELN_TX_X4_PCS_STS_LATCHr
#define WRITEALL_TX_X4_PCS_STS_LATCHr BCMI_TSCD_XGXS_WRITEALL_TX_X4_PCS_STS_LATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_PCS_STS_LATCHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_PMA_STS
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc124
 * DESC:     PMA overflow underflow status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     T_TC_OUT_OVERFLOW Per logical lane t_tc_out fifo overflow status.
 *     T_TC_OUT_UNDERFLOW Per logical lane t_tc_out fifo underflow status.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr (0x0000c124 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_PMA_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_PMA_STSr_s {
	uint32_t v[1];
	uint32_t tx_x4_pma_sts[1];
	uint32_t _tx_x4_pma_sts;
} BCMI_TSCD_XGXS_TX_X4_PMA_STSr_t;

#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_CLR(r) (r).tx_x4_pma_sts[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_SET(r,d) (r).tx_x4_pma_sts[0] = d
#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_GET(r) (r).tx_x4_pma_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_UNDERFLOWf_GET(r) ((((r).tx_x4_pma_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_UNDERFLOWf_SET(r,f) (r).tx_x4_pma_sts[0]=(((r).tx_x4_pma_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_OVERFLOWf_GET(r) ((((r).tx_x4_pma_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_OVERFLOWf_SET(r,f) (r).tx_x4_pma_sts[0]=(((r).tx_x4_pma_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))

/*
 * These macros can be used to access TX_X4_PMA_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_PMA_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_PMA_STSr,(_r._tx_x4_pma_sts))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_PMA_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PMA_STSr,(_r._tx_x4_pma_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_PMA_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PMA_STSr,(_r._tx_x4_pma_sts))
#define BCMI_TSCD_XGXS_READLN_TX_X4_PMA_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_PMA_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pma_sts))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_PMA_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PMA_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_pma_sts))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_PMA_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_PMA_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_pma_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_PMA_STSr BCMI_TSCD_XGXS_TX_X4_PMA_STSr
#define TX_X4_PMA_STSr_SIZE BCMI_TSCD_XGXS_TX_X4_PMA_STSr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_PMA_STSr_t TX_X4_PMA_STSr_t;
#define TX_X4_PMA_STSr_CLR BCMI_TSCD_XGXS_TX_X4_PMA_STSr_CLR
#define TX_X4_PMA_STSr_SET BCMI_TSCD_XGXS_TX_X4_PMA_STSr_SET
#define TX_X4_PMA_STSr_GET BCMI_TSCD_XGXS_TX_X4_PMA_STSr_GET
#define TX_X4_PMA_STSr_T_TC_OUT_UNDERFLOWf_GET BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_UNDERFLOWf_GET
#define TX_X4_PMA_STSr_T_TC_OUT_UNDERFLOWf_SET BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_UNDERFLOWf_SET
#define TX_X4_PMA_STSr_T_TC_OUT_OVERFLOWf_GET BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_OVERFLOWf_GET
#define TX_X4_PMA_STSr_T_TC_OUT_OVERFLOWf_SET BCMI_TSCD_XGXS_TX_X4_PMA_STSr_T_TC_OUT_OVERFLOWf_SET
#define READ_TX_X4_PMA_STSr BCMI_TSCD_XGXS_READ_TX_X4_PMA_STSr
#define WRITE_TX_X4_PMA_STSr BCMI_TSCD_XGXS_WRITE_TX_X4_PMA_STSr
#define MODIFY_TX_X4_PMA_STSr BCMI_TSCD_XGXS_MODIFY_TX_X4_PMA_STSr
#define READLN_TX_X4_PMA_STSr BCMI_TSCD_XGXS_READLN_TX_X4_PMA_STSr
#define WRITELN_TX_X4_PMA_STSr BCMI_TSCD_XGXS_WRITELN_TX_X4_PMA_STSr
#define WRITEALL_TX_X4_PMA_STSr BCMI_TSCD_XGXS_WRITEALL_TX_X4_PMA_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_PMA_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_TX_1588_TIMESTAMP_STS
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc125
 * DESC:     Transmit 1588 Timestamp Status Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TS_SUB_NANO_FIELD Sub-nano second value of the top most two-step timestamp fifo entry indicated with 62.5ps of accuracyts_entry_valid bit qualifies the timestamp
 *     TS_ENTRY_VALID   valid two-step timestamp entry availablilty indicator
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr (0x0000c125 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_1588_TIMESTAMP_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_1588_timestamp_sts[1];
	uint32_t _tx_x4_tx_1588_timestamp_sts;
} BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_t;

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_CLR(r) (r).tx_x4_tx_1588_timestamp_sts[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SET(r,d) (r).tx_x4_tx_1588_timestamp_sts[0] = d
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_GET(r) (r).tx_x4_tx_1588_timestamp_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_GET(r) ((((r).tx_x4_tx_1588_timestamp_sts[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_SET(r,f) (r).tx_x4_tx_1588_timestamp_sts[0]=(((r).tx_x4_tx_1588_timestamp_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_SUB_NANO_FIELDf_GET(r) (((r).tx_x4_tx_1588_timestamp_sts[0]) & 0xf)
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_SUB_NANO_FIELDf_SET(r,f) (r).tx_x4_tx_1588_timestamp_sts[0]=(((r).tx_x4_tx_1588_timestamp_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TX_X4_TX_1588_TIMESTAMP_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr,(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr,(_r._tx_x4_tx_1588_timestamp_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr,(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_sts))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_1588_timestamp_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr
#define TX_X4_TX_1588_TIMESTAMP_STSr_SIZE BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_t TX_X4_TX_1588_TIMESTAMP_STSr_t;
#define TX_X4_TX_1588_TIMESTAMP_STSr_CLR BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_CLR
#define TX_X4_TX_1588_TIMESTAMP_STSr_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_SET
#define TX_X4_TX_1588_TIMESTAMP_STSr_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_GET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_GET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_ENTRY_VALIDf_SET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TS_SUB_NANO_FIELDf_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_SUB_NANO_FIELDf_GET
#define TX_X4_TX_1588_TIMESTAMP_STSr_TS_SUB_NANO_FIELDf_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr_TS_SUB_NANO_FIELDf_SET
#define READ_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_STSr
#define WRITE_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_STSr
#define MODIFY_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_STSr
#define READLN_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_STSr
#define WRITELN_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_STSr
#define WRITEALL_TX_X4_TX_1588_TIMESTAMP_STSr BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_TX_1588_TIMESTAMP_HI
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc126
 * DESC:     Transmit 1588 timestamp value Register(Upper 16-bits)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TS_VALUE_HI      Upper 16-bits of the two-step timestamp from the top entry of timestamp fifoIf ts_entry_valid is read 1, this register should be read just once to get accurate timestamp information
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr (0x0000c126 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_1588_TIMESTAMP_HI.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_1588_timestamp_hi[1];
	uint32_t _tx_x4_tx_1588_timestamp_hi;
} BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_t;

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_CLR(r) (r).tx_x4_tx_1588_timestamp_hi[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_SET(r,d) (r).tx_x4_tx_1588_timestamp_hi[0] = d
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_GET(r) (r).tx_x4_tx_1588_timestamp_hi[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_TS_VALUE_HIf_GET(r) (((r).tx_x4_tx_1588_timestamp_hi[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_TS_VALUE_HIf_SET(r,f) (r).tx_x4_tx_1588_timestamp_hi[0]=(((r).tx_x4_tx_1588_timestamp_hi[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X4_TX_1588_TIMESTAMP_HI.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_HIr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr,(_r._tx_x4_tx_1588_timestamp_hi))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr,(_r._tx_x4_tx_1588_timestamp_hi)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr,(_r._tx_x4_tx_1588_timestamp_hi))
#define BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_HIr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_hi))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_HIr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_hi))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_HIr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_1588_timestamp_hi))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_1588_TIMESTAMP_HIr BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr
#define TX_X4_TX_1588_TIMESTAMP_HIr_SIZE BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_t TX_X4_TX_1588_TIMESTAMP_HIr_t;
#define TX_X4_TX_1588_TIMESTAMP_HIr_CLR BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_CLR
#define TX_X4_TX_1588_TIMESTAMP_HIr_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_SET
#define TX_X4_TX_1588_TIMESTAMP_HIr_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_GET
#define TX_X4_TX_1588_TIMESTAMP_HIr_TS_VALUE_HIf_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_TS_VALUE_HIf_GET
#define TX_X4_TX_1588_TIMESTAMP_HIr_TS_VALUE_HIf_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr_TS_VALUE_HIf_SET
#define READ_TX_X4_TX_1588_TIMESTAMP_HIr BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_HIr
#define WRITE_TX_X4_TX_1588_TIMESTAMP_HIr BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_HIr
#define MODIFY_TX_X4_TX_1588_TIMESTAMP_HIr BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_HIr
#define READLN_TX_X4_TX_1588_TIMESTAMP_HIr BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_HIr
#define WRITELN_TX_X4_TX_1588_TIMESTAMP_HIr BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_HIr
#define WRITEALL_TX_X4_TX_1588_TIMESTAMP_HIr BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_HIr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_TX_1588_TIMESTAMP_MID
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc127
 * DESC:     Transmit 1588 timestamp value Register(MID 16-bits)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TS_VALUE_MID     Upper 16-bits of the two-step timestamp from the top entry of timestamp fifoIf ts_entry_valid is read 1, this register should be read just once to get accurate timestamp information
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr (0x0000c127 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_1588_TIMESTAMP_MID.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_1588_timestamp_mid[1];
	uint32_t _tx_x4_tx_1588_timestamp_mid;
} BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_t;

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_CLR(r) (r).tx_x4_tx_1588_timestamp_mid[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_SET(r,d) (r).tx_x4_tx_1588_timestamp_mid[0] = d
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_GET(r) (r).tx_x4_tx_1588_timestamp_mid[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_TS_VALUE_MIDf_GET(r) (((r).tx_x4_tx_1588_timestamp_mid[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_TS_VALUE_MIDf_SET(r,f) (r).tx_x4_tx_1588_timestamp_mid[0]=(((r).tx_x4_tx_1588_timestamp_mid[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X4_TX_1588_TIMESTAMP_MID.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_MIDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr,(_r._tx_x4_tx_1588_timestamp_mid))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_MIDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr,(_r._tx_x4_tx_1588_timestamp_mid)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_MIDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr,(_r._tx_x4_tx_1588_timestamp_mid))
#define BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_MIDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_mid))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_MIDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_mid))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_MIDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_1588_timestamp_mid))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_1588_TIMESTAMP_MIDr BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr
#define TX_X4_TX_1588_TIMESTAMP_MIDr_SIZE BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_t TX_X4_TX_1588_TIMESTAMP_MIDr_t;
#define TX_X4_TX_1588_TIMESTAMP_MIDr_CLR BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_CLR
#define TX_X4_TX_1588_TIMESTAMP_MIDr_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_SET
#define TX_X4_TX_1588_TIMESTAMP_MIDr_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_GET
#define TX_X4_TX_1588_TIMESTAMP_MIDr_TS_VALUE_MIDf_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_TS_VALUE_MIDf_GET
#define TX_X4_TX_1588_TIMESTAMP_MIDr_TS_VALUE_MIDf_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr_TS_VALUE_MIDf_SET
#define READ_TX_X4_TX_1588_TIMESTAMP_MIDr BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_MIDr
#define WRITE_TX_X4_TX_1588_TIMESTAMP_MIDr BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_MIDr
#define MODIFY_TX_X4_TX_1588_TIMESTAMP_MIDr BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_MIDr
#define READLN_TX_X4_TX_1588_TIMESTAMP_MIDr BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_MIDr
#define WRITELN_TX_X4_TX_1588_TIMESTAMP_MIDr BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_MIDr
#define WRITEALL_TX_X4_TX_1588_TIMESTAMP_MIDr BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_MIDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_MIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_TX_1588_TIMESTAMP_LO
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc128
 * DESC:     Transmit 1588 timestamp value Register(Lower 16-bits)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TS_VALUE_LO      Lower 16-bits of the two-step timestamp from the top entry of timestamp fifoIf ts_entry_valid is read 1, this register should be read just once to get accurate timestamp information
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr (0x0000c128 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_1588_TIMESTAMP_LO.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_1588_timestamp_lo[1];
	uint32_t _tx_x4_tx_1588_timestamp_lo;
} BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_t;

#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_CLR(r) (r).tx_x4_tx_1588_timestamp_lo[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_SET(r,d) (r).tx_x4_tx_1588_timestamp_lo[0] = d
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_GET(r) (r).tx_x4_tx_1588_timestamp_lo[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_TS_VALUE_LOf_GET(r) (((r).tx_x4_tx_1588_timestamp_lo[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_TS_VALUE_LOf_SET(r,f) (r).tx_x4_tx_1588_timestamp_lo[0]=(((r).tx_x4_tx_1588_timestamp_lo[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X4_TX_1588_TIMESTAMP_LO.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr,(_r._tx_x4_tx_1588_timestamp_lo))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr,(_r._tx_x4_tx_1588_timestamp_lo)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr,(_r._tx_x4_tx_1588_timestamp_lo))
#define BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_lo))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_1588_timestamp_lo))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_1588_timestamp_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_1588_TIMESTAMP_LOr BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr
#define TX_X4_TX_1588_TIMESTAMP_LOr_SIZE BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_t TX_X4_TX_1588_TIMESTAMP_LOr_t;
#define TX_X4_TX_1588_TIMESTAMP_LOr_CLR BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_CLR
#define TX_X4_TX_1588_TIMESTAMP_LOr_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_SET
#define TX_X4_TX_1588_TIMESTAMP_LOr_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_GET
#define TX_X4_TX_1588_TIMESTAMP_LOr_TS_VALUE_LOf_GET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_TS_VALUE_LOf_GET
#define TX_X4_TX_1588_TIMESTAMP_LOr_TS_VALUE_LOf_SET BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr_TS_VALUE_LOf_SET
#define READ_TX_X4_TX_1588_TIMESTAMP_LOr BCMI_TSCD_XGXS_READ_TX_X4_TX_1588_TIMESTAMP_LOr
#define WRITE_TX_X4_TX_1588_TIMESTAMP_LOr BCMI_TSCD_XGXS_WRITE_TX_X4_TX_1588_TIMESTAMP_LOr
#define MODIFY_TX_X4_TX_1588_TIMESTAMP_LOr BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_1588_TIMESTAMP_LOr
#define READLN_TX_X4_TX_1588_TIMESTAMP_LOr BCMI_TSCD_XGXS_READLN_TX_X4_TX_1588_TIMESTAMP_LOr
#define WRITELN_TX_X4_TX_1588_TIMESTAMP_LOr BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_1588_TIMESTAMP_LOr
#define WRITEALL_TX_X4_TX_1588_TIMESTAMP_LOr BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_1588_TIMESTAMP_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_TX_1588_TIMESTAMP_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  TX_X4_TX_TS_SEQ_ID
 * BLOCKS:   TX_X4_STATUS0
 * REGADDR:  0xc129
 * DESC:     1588 Timestamp packet Sequence ID value Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TS_SEQUENCE_ID   The sequence id corresponding to the top-most entry in the two-step timestamp fifoIf ts_entry_valid is read 1, this register should be read just once to get accurate sequence id information
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr (0x0000c129 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_SIZE 4

/*
 * This structure should be used to declare and program TX_X4_TX_TS_SEQ_ID.
 *
 */
typedef union BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_s {
	uint32_t v[1];
	uint32_t tx_x4_tx_ts_seq_id[1];
	uint32_t _tx_x4_tx_ts_seq_id;
} BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_t;

#define BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_CLR(r) (r).tx_x4_tx_ts_seq_id[0] = 0
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_SET(r,d) (r).tx_x4_tx_ts_seq_id[0] = d
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_GET(r) (r).tx_x4_tx_ts_seq_id[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_TS_SEQUENCE_IDf_GET(r) (((r).tx_x4_tx_ts_seq_id[0]) & 0xffff)
#define BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_TS_SEQUENCE_IDf_SET(r,f) (r).tx_x4_tx_ts_seq_id[0]=(((r).tx_x4_tx_ts_seq_id[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_X4_TX_TS_SEQ_ID.
 *
 */
#define BCMI_TSCD_XGXS_READ_TX_X4_TX_TS_SEQ_IDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr,(_r._tx_x4_tx_ts_seq_id))
#define BCMI_TSCD_XGXS_WRITE_TX_X4_TX_TS_SEQ_IDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr,(_r._tx_x4_tx_ts_seq_id)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_TS_SEQ_IDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr,(_r._tx_x4_tx_ts_seq_id))
#define BCMI_TSCD_XGXS_READLN_TX_X4_TX_TS_SEQ_IDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ts_seq_id))
#define BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_TS_SEQ_IDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_x4_tx_ts_seq_id))
#define BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_TS_SEQ_IDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_x4_tx_ts_seq_id))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_X4_TX_TS_SEQ_IDr BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr
#define TX_X4_TX_TS_SEQ_IDr_SIZE BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_SIZE
typedef BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_t TX_X4_TX_TS_SEQ_IDr_t;
#define TX_X4_TX_TS_SEQ_IDr_CLR BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_CLR
#define TX_X4_TX_TS_SEQ_IDr_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_SET
#define TX_X4_TX_TS_SEQ_IDr_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_GET
#define TX_X4_TX_TS_SEQ_IDr_TS_SEQUENCE_IDf_GET BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_TS_SEQUENCE_IDf_GET
#define TX_X4_TX_TS_SEQ_IDr_TS_SEQUENCE_IDf_SET BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr_TS_SEQUENCE_IDf_SET
#define READ_TX_X4_TX_TS_SEQ_IDr BCMI_TSCD_XGXS_READ_TX_X4_TX_TS_SEQ_IDr
#define WRITE_TX_X4_TX_TS_SEQ_IDr BCMI_TSCD_XGXS_WRITE_TX_X4_TX_TS_SEQ_IDr
#define MODIFY_TX_X4_TX_TS_SEQ_IDr BCMI_TSCD_XGXS_MODIFY_TX_X4_TX_TS_SEQ_IDr
#define READLN_TX_X4_TX_TS_SEQ_IDr BCMI_TSCD_XGXS_READLN_TX_X4_TX_TS_SEQ_IDr
#define WRITELN_TX_X4_TX_TS_SEQ_IDr BCMI_TSCD_XGXS_WRITELN_TX_X4_TX_TS_SEQ_IDr
#define WRITEALL_TX_X4_TX_TS_SEQ_IDr BCMI_TSCD_XGXS_WRITEALL_TX_X4_TX_TS_SEQ_IDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_TX_X4_TX_TS_SEQ_IDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PCS_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc130
 * DESC:     pcs control 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LPI_ENABLE       If off (0), LPIs are converted to IDLEs: In TX direction: If LPI_ENABLE=0 and MAC sends LPI, TX-PCS will convert that to 1FE.NOTE: LPI_ENABLE APPLIES TO BOTH TX AND RX pipelines.
 *     FEC_ENABLE       Indicates whether cl74 FEC is enabled or not
 *     CL91_FEC_MODE    
 *     BLOCK_NON_FC_BLK_TYPES Convert the following block types to errors - 0x87, 0x99, 0xAA, 0xCC, 0xD2, 0xE1
 *     DEC_FSM_MODE     
 *     DESKEW_MODE      
 *     DEC_TL_MODE      
 *     DESCR_MODE       
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r (0x0000c130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_CTL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_ctl0[1];
	uint32_t _rx_x4_pcs_ctl0;
} BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_CLR(r) (r).rx_x4_pcs_ctl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_SET(r,d) (r).rx_x4_pcs_ctl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_GET(r) (r).rx_x4_pcs_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESCR_MODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESCR_MODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_TL_MODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_TL_MODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESKEW_MODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESKEW_MODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_FSM_MODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_FSM_MODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_BLOCK_NON_FC_BLK_TYPESf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_BLOCK_NON_FC_BLK_TYPESf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_CL91_FEC_MODEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 2) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_CL91_FEC_MODEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_FEC_ENABLEf_GET(r) ((((r).rx_x4_pcs_ctl0[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_FEC_ENABLEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_GET(r) (((r).rx_x4_pcs_ctl0[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_SET(r,f) (r).rx_x4_pcs_ctl0[0]=(((r).rx_x4_pcs_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PCS_CTL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r,(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r,(_r._rx_x4_pcs_ctl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r,(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PCS_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_ctl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_CTL0r BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r
#define RX_X4_PCS_CTL0r_SIZE BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_t RX_X4_PCS_CTL0r_t;
#define RX_X4_PCS_CTL0r_CLR BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_CLR
#define RX_X4_PCS_CTL0r_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_SET
#define RX_X4_PCS_CTL0r_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_GET
#define RX_X4_PCS_CTL0r_DESCR_MODEf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESCR_MODEf_GET
#define RX_X4_PCS_CTL0r_DESCR_MODEf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESCR_MODEf_SET
#define RX_X4_PCS_CTL0r_DEC_TL_MODEf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_TL_MODEf_GET
#define RX_X4_PCS_CTL0r_DEC_TL_MODEf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_TL_MODEf_SET
#define RX_X4_PCS_CTL0r_DESKEW_MODEf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESKEW_MODEf_GET
#define RX_X4_PCS_CTL0r_DESKEW_MODEf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DESKEW_MODEf_SET
#define RX_X4_PCS_CTL0r_DEC_FSM_MODEf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_FSM_MODEf_GET
#define RX_X4_PCS_CTL0r_DEC_FSM_MODEf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_DEC_FSM_MODEf_SET
#define RX_X4_PCS_CTL0r_BLOCK_NON_FC_BLK_TYPESf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_BLOCK_NON_FC_BLK_TYPESf_GET
#define RX_X4_PCS_CTL0r_BLOCK_NON_FC_BLK_TYPESf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_BLOCK_NON_FC_BLK_TYPESf_SET
#define RX_X4_PCS_CTL0r_CL91_FEC_MODEf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_CL91_FEC_MODEf_GET
#define RX_X4_PCS_CTL0r_CL91_FEC_MODEf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_CL91_FEC_MODEf_SET
#define RX_X4_PCS_CTL0r_FEC_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_FEC_ENABLEf_GET
#define RX_X4_PCS_CTL0r_FEC_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_FEC_ENABLEf_SET
#define RX_X4_PCS_CTL0r_LPI_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_GET
#define RX_X4_PCS_CTL0r_LPI_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r_LPI_ENABLEf_SET
#define READ_RX_X4_PCS_CTL0r BCMI_TSCD_XGXS_READ_RX_X4_PCS_CTL0r
#define WRITE_RX_X4_PCS_CTL0r BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_CTL0r
#define MODIFY_RX_X4_PCS_CTL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_CTL0r
#define READLN_RX_X4_PCS_CTL0r BCMI_TSCD_XGXS_READLN_RX_X4_PCS_CTL0r
#define WRITELN_RX_X4_PCS_CTL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_CTL0r
#define WRITEALL_RX_X4_PCS_CTL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PCS_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_THR
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc131
 * DESC:     cl91 symbol error threshold count register
 * RESETVAL: 0x1a1 (417)
 * ACCESS:   R/W
 * FIELDS:
 *     SYMBOL_ERR_CNT_THRESHOLD When the number of symbol errors in a window of 8192 (or 128) code words exceed this value, all sync headers are corruptedIt is referred to as variable K in the IEEE spec.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_THRr (0x0000c131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_THR.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_THRr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_thr[1];
	uint32_t _rx_x4_cl91_thr;
} BCMI_TSCD_XGXS_RX_X4_CL91_THRr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_THRr_CLR(r) (r).rx_x4_cl91_thr[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SET(r,d) (r).rx_x4_cl91_thr[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_THRr_GET(r) (r).rx_x4_cl91_thr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SYMBOL_ERR_CNT_THRESHOLDf_GET(r) (((r).rx_x4_cl91_thr[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SYMBOL_ERR_CNT_THRESHOLDf_SET(r,f) (r).rx_x4_cl91_thr[0]=(((r).rx_x4_cl91_thr[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RX_X4_CL91_THR.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_THRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_THRr,(_r._rx_x4_cl91_thr))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_THRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_THRr,(_r._rx_x4_cl91_thr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_THRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_THRr,(_r._rx_x4_cl91_thr))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_THRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_THRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_thr))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_THRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_THRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_thr))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_THRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_THRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_thr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_THRr BCMI_TSCD_XGXS_RX_X4_CL91_THRr
#define RX_X4_CL91_THRr_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_THRr_t RX_X4_CL91_THRr_t;
#define RX_X4_CL91_THRr_CLR BCMI_TSCD_XGXS_RX_X4_CL91_THRr_CLR
#define RX_X4_CL91_THRr_SET BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SET
#define RX_X4_CL91_THRr_GET BCMI_TSCD_XGXS_RX_X4_CL91_THRr_GET
#define RX_X4_CL91_THRr_SYMBOL_ERR_CNT_THRESHOLDf_GET BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SYMBOL_ERR_CNT_THRESHOLDf_GET
#define RX_X4_CL91_THRr_SYMBOL_ERR_CNT_THRESHOLDf_SET BCMI_TSCD_XGXS_RX_X4_CL91_THRr_SYMBOL_ERR_CNT_THRESHOLDf_SET
#define READ_RX_X4_CL91_THRr BCMI_TSCD_XGXS_READ_RX_X4_CL91_THRr
#define WRITE_RX_X4_CL91_THRr BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_THRr
#define MODIFY_RX_X4_CL91_THRr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_THRr
#define READLN_RX_X4_CL91_THRr BCMI_TSCD_XGXS_READLN_RX_X4_CL91_THRr
#define WRITELN_RX_X4_CL91_THRr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_THRr
#define WRITEALL_RX_X4_CL91_THRr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_THRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_THRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_TMR
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc132
 * DESC:     cl91 symbol error timer period register
 * RESETVAL: 0xfa0 (4000)
 * ACCESS:   R/W
 * FIELDS:
 *     SYMBOL_ERROR_TMR_PERIOD Counter value upto which 15us ticks are counted.It should be programmed between 60-75ms as per IEEE.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_TMRr (0x0000c132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_TMR.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_tmr[1];
	uint32_t _rx_x4_cl91_tmr;
} BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_CLR(r) (r).rx_x4_cl91_tmr[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SET(r,d) (r).rx_x4_cl91_tmr[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_GET(r) (r).rx_x4_cl91_tmr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SYMBOL_ERROR_TMR_PERIODf_GET(r) (((r).rx_x4_cl91_tmr[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SYMBOL_ERROR_TMR_PERIODf_SET(r,f) (r).rx_x4_cl91_tmr[0]=(((r).rx_x4_cl91_tmr[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RX_X4_CL91_TMR.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_TMRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_TMRr,(_r._rx_x4_cl91_tmr))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_TMRr,(_r._rx_x4_cl91_tmr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_TMRr,(_r._rx_x4_cl91_tmr))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_TMRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_tmr))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_TMRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_TMRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_tmr))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_TMRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_TMRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_tmr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_TMRr BCMI_TSCD_XGXS_RX_X4_CL91_TMRr
#define RX_X4_CL91_TMRr_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_t RX_X4_CL91_TMRr_t;
#define RX_X4_CL91_TMRr_CLR BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_CLR
#define RX_X4_CL91_TMRr_SET BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SET
#define RX_X4_CL91_TMRr_GET BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_GET
#define RX_X4_CL91_TMRr_SYMBOL_ERROR_TMR_PERIODf_GET BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SYMBOL_ERROR_TMR_PERIODf_GET
#define RX_X4_CL91_TMRr_SYMBOL_ERROR_TMR_PERIODf_SET BCMI_TSCD_XGXS_RX_X4_CL91_TMRr_SYMBOL_ERROR_TMR_PERIODf_SET
#define READ_RX_X4_CL91_TMRr BCMI_TSCD_XGXS_READ_RX_X4_CL91_TMRr
#define WRITE_RX_X4_CL91_TMRr BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_TMRr
#define MODIFY_RX_X4_CL91_TMRr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_TMRr
#define READLN_RX_X4_CL91_TMRr BCMI_TSCD_XGXS_READLN_RX_X4_CL91_TMRr
#define WRITELN_RX_X4_CL91_TMRr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_TMRr
#define WRITEALL_RX_X4_CL91_TMRr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_TMRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_TMRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_RX_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc133
 * DESC:     cl91 control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_BLKSYNC_MODE 
 *     R_MERGE_MODE     
 *     CL91_CW_SCRAMBLE Indicates whether the CL91 codeword needs to be descrambled. Should be enabled for FC mode.
 *     R_TC_IN_MODE     Indicates whether CL91 is turned ON for the port or not.
 *     R_TC_MODE        
 *     FIVE_BIT_XOR_EN  1'b1 - XOR 4:0 with 12:8, 1'b0 - No XOR of the 5 bits
 *     R_TC_OUT_MODE    
 *     FEC_BYP_CORR_EN  1'b1 - Reed Solomon decoder performs error detection without error correction.1'b0 - Reed Solomon decoder also performs error correction.
 *     FEC_BYP_IND_EN   1'b1 - Disable error code word marking.1'b0 - Enable error code word marking.This bit shall have no effect if FEC bypass correction enable is set to 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r (0x0000c133 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_RX_CTL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_rx_ctl0[1];
	uint32_t _rx_x4_cl91_rx_ctl0;
} BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CLR(r) (r).rx_x4_cl91_rx_ctl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_SET(r,d) (r).rx_x4_cl91_rx_ctl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_GET(r) (r).rx_x4_cl91_rx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_IND_ENf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_IND_ENf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_CORR_ENf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_CORR_ENf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_OUT_MODEf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_OUT_MODEf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FIVE_BIT_XOR_ENf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FIVE_BIT_XOR_ENf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_MODEf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_MODEf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_IN_MODEf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_IN_MODEf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_CW_SCRAMBLEf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_CW_SCRAMBLEf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_MERGE_MODEf_GET(r) ((((r).rx_x4_cl91_rx_ctl0[0]) >> 3) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_MERGE_MODEf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_BLKSYNC_MODEf_GET(r) (((r).rx_x4_cl91_rx_ctl0[0]) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_BLKSYNC_MODEf_SET(r,f) (r).rx_x4_cl91_rx_ctl0[0]=(((r).rx_x4_cl91_rx_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_X4_CL91_RX_CTL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_RX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r,(_r._rx_x4_cl91_rx_ctl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r,(_r._rx_x4_cl91_rx_ctl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r,(_r._rx_x4_cl91_rx_ctl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_RX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_rx_ctl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_RX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_rx_ctl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_rx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_RX_CTL0r BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r
#define RX_X4_CL91_RX_CTL0r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_t RX_X4_CL91_RX_CTL0r_t;
#define RX_X4_CL91_RX_CTL0r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CLR
#define RX_X4_CL91_RX_CTL0r_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_SET
#define RX_X4_CL91_RX_CTL0r_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_GET
#define RX_X4_CL91_RX_CTL0r_FEC_BYP_IND_ENf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_IND_ENf_GET
#define RX_X4_CL91_RX_CTL0r_FEC_BYP_IND_ENf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_IND_ENf_SET
#define RX_X4_CL91_RX_CTL0r_FEC_BYP_CORR_ENf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_CORR_ENf_GET
#define RX_X4_CL91_RX_CTL0r_FEC_BYP_CORR_ENf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FEC_BYP_CORR_ENf_SET
#define RX_X4_CL91_RX_CTL0r_R_TC_OUT_MODEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_OUT_MODEf_GET
#define RX_X4_CL91_RX_CTL0r_R_TC_OUT_MODEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_OUT_MODEf_SET
#define RX_X4_CL91_RX_CTL0r_FIVE_BIT_XOR_ENf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FIVE_BIT_XOR_ENf_GET
#define RX_X4_CL91_RX_CTL0r_FIVE_BIT_XOR_ENf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_FIVE_BIT_XOR_ENf_SET
#define RX_X4_CL91_RX_CTL0r_R_TC_MODEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_MODEf_GET
#define RX_X4_CL91_RX_CTL0r_R_TC_MODEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_MODEf_SET
#define RX_X4_CL91_RX_CTL0r_R_TC_IN_MODEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_IN_MODEf_GET
#define RX_X4_CL91_RX_CTL0r_R_TC_IN_MODEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_TC_IN_MODEf_SET
#define RX_X4_CL91_RX_CTL0r_CL91_CW_SCRAMBLEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_CW_SCRAMBLEf_GET
#define RX_X4_CL91_RX_CTL0r_CL91_CW_SCRAMBLEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_CW_SCRAMBLEf_SET
#define RX_X4_CL91_RX_CTL0r_R_MERGE_MODEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_MERGE_MODEf_GET
#define RX_X4_CL91_RX_CTL0r_R_MERGE_MODEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_R_MERGE_MODEf_SET
#define RX_X4_CL91_RX_CTL0r_CL91_BLKSYNC_MODEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_BLKSYNC_MODEf_GET
#define RX_X4_CL91_RX_CTL0r_CL91_BLKSYNC_MODEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r_CL91_BLKSYNC_MODEf_SET
#define READ_RX_X4_CL91_RX_CTL0r BCMI_TSCD_XGXS_READ_RX_X4_CL91_RX_CTL0r
#define WRITE_RX_X4_CL91_RX_CTL0r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_RX_CTL0r
#define MODIFY_RX_X4_CL91_RX_CTL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_RX_CTL0r
#define READLN_RX_X4_CL91_RX_CTL0r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_RX_CTL0r
#define WRITELN_RX_X4_CL91_RX_CTL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_RX_CTL0r
#define WRITEALL_RX_X4_CL91_RX_CTL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_RX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_RX_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_DEC_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc134
 * DESC:     Decoder control 0 register
 * RESETVAL: 0x2270 (8816)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_RX_RF_ENABLE If this bit is a one, RFs are passed to the RS layer from the PCS.If this bit is a zero, RFs are replaced by IDLEs which are then passedto the RS layer.For CL49 only.
 *     CL49_RX_LF_ENABLE If this bit is a one, LFs are passed to the RS layer from the PCS.If this bit is a zero, LFs are replaced by IDLEs which are then passedto the RS layer.For CL49 only.
 *     CL49_RX_LI_ENABLE If this bit is a one, LIs (Link Interrupt) are passed thru to the PCS.If this bit is a zero, LIs (Link Interrupt) are replaced by IDLEs which are then passedto the PCS.For CL49 only.
 *     DIS_SCRAMBLER    Disable the RX scrambler
 *     DISABLE_CL49_BERMON Disable cl49 BER monitor state machine1 = Disable bermon fsm, force BER_MT_INIT state0 = Enable (default)
 *     HG2_CODEC        Enables HG2 extensions support for PCSSet this bit to enable HG2 messaging
 *     HG2_ENABLE       Enables HG2 support for PCS
 *     HG2_MESSAGE_INVALID_CODE_ENABLE Enables HG2 invalid message code support.
 *     R_TEST_MODE_CFG  Test Mode enable for both CL49 and CL82
 *     BYPASS_CL49RXSM  Bypass cl49 receive state machine1 = Bypass cl49 rxsm :- force RX_INIT state- pass the data from the table look-up decoder to the output0 = normal mode
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r (0x0000c134 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_CTL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_ctl0[1];
	uint32_t _rx_x4_dec_ctl0;
} BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CLR(r) (r).rx_x4_dec_ctl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_SET(r,d) (r).rx_x4_dec_ctl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_GET(r) (r).rx_x4_dec_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DIS_SCRAMBLERf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DIS_SCRAMBLERf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_GET(r) ((((r).rx_x4_dec_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_SET(r,f) (r).rx_x4_dec_ctl0[0]=(((r).rx_x4_dec_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))

/*
 * These macros can be used to access RX_X4_DEC_CTL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r,(_r._rx_x4_dec_ctl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_DEC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_ctl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_CTL0r BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r
#define RX_X4_DEC_CTL0r_SIZE BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_t RX_X4_DEC_CTL0r_t;
#define RX_X4_DEC_CTL0r_CLR BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CLR
#define RX_X4_DEC_CTL0r_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_SET
#define RX_X4_DEC_CTL0r_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_GET
#define RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_GET
#define RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_BYPASS_CL49RXSMf_SET
#define RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_GET
#define RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_R_TEST_MODE_CFGf_SET
#define RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_GET
#define RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_MESSAGE_INVALID_CODE_ENABLEf_SET
#define RX_X4_DEC_CTL0r_HG2_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_GET
#define RX_X4_DEC_CTL0r_HG2_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_ENABLEf_SET
#define RX_X4_DEC_CTL0r_HG2_CODECf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_GET
#define RX_X4_DEC_CTL0r_HG2_CODECf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_HG2_CODECf_SET
#define RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_GET
#define RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DISABLE_CL49_BERMONf_SET
#define RX_X4_DEC_CTL0r_DIS_SCRAMBLERf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DIS_SCRAMBLERf_GET
#define RX_X4_DEC_CTL0r_DIS_SCRAMBLERf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_DIS_SCRAMBLERf_SET
#define RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_GET
#define RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LI_ENABLEf_SET
#define RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_GET
#define RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_LF_ENABLEf_SET
#define RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_GET
#define RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r_CL49_RX_RF_ENABLEf_SET
#define READ_RX_X4_DEC_CTL0r BCMI_TSCD_XGXS_READ_RX_X4_DEC_CTL0r
#define WRITE_RX_X4_DEC_CTL0r BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_CTL0r
#define MODIFY_RX_X4_DEC_CTL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_CTL0r
#define READLN_RX_X4_DEC_CTL0r BCMI_TSCD_XGXS_READLN_RX_X4_DEC_CTL0r
#define WRITELN_RX_X4_DEC_CTL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_CTL0r
#define WRITEALL_RX_X4_DEC_CTL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_DEC_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BLKSYNC_CFG
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc135
 * DESC:     Block Sync Configuration register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BS_BTMX_MODE     Bit-mux mode: Indicates the format of incoming data on a physical lane.
 *     BS_DIST_MODE     Block to lane distribution mode.BS_DIST_MODE_5_LANE_TDM - 5 lane TDM. Each block distributed in turn over output pseudo-logical lanes 0-4BS_DIST_MODE_2_LANE_TDM_2_VLANE - 2 lane TDM for 2 virtual lanes.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.Virtual Lane 1 output is ping-ponged over pseudo-logical lanes 1,3.BS_DIST_MODE_2_LANE_TDM_1_VLANE - 2 lane TDM for 1 virtual lane.Virtual Lane 0 output is ping-ponged over pseudo-logical lanes 0,2.BS_DIST_MODE_NO_TDM - No TDM. Virtual Lane output is sent directly to corresponding pseudo-logical lane.
 *     BS_SYNC_EN       Enable block synchronization: If enabled, block sync sm will attempt to slip data until sync is achieved.
 *     BS_SM_SYNC_MODE  Block Sync Mode: When bs_sync_en==1, this bit indicates if cl49 or cl82 state machine operation is used.1'b0 - Clause 821'b1 - Clause 49
 *     BLK_LOCK_ON_CTRL If this bit is set the block lock for 64/66b modes will be achieved only on control sync headers (2'b01).Else, block lock can be achieved on both control or data sync headers.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr (0x0000c135 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_CFG.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_cfg[1];
	uint32_t _rx_x4_blksync_cfg;
} BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_t;

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_CLR(r) (r).rx_x4_blksync_cfg[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_SET(r,d) (r).rx_x4_blksync_cfg[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_GET(r) (r).rx_x4_blksync_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BLK_LOCK_ON_CTRLf_GET(r) ((((r).rx_x4_blksync_cfg[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BLK_LOCK_ON_CTRLf_SET(r,f) (r).rx_x4_blksync_cfg[0]=(((r).rx_x4_blksync_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SM_SYNC_MODEf_GET(r) ((((r).rx_x4_blksync_cfg[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SM_SYNC_MODEf_SET(r,f) (r).rx_x4_blksync_cfg[0]=(((r).rx_x4_blksync_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SYNC_ENf_GET(r) ((((r).rx_x4_blksync_cfg[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SYNC_ENf_SET(r,f) (r).rx_x4_blksync_cfg[0]=(((r).rx_x4_blksync_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_DIST_MODEf_GET(r) ((((r).rx_x4_blksync_cfg[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_DIST_MODEf_SET(r,f) (r).rx_x4_blksync_cfg[0]=(((r).rx_x4_blksync_cfg[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_BTMX_MODEf_GET(r) (((r).rx_x4_blksync_cfg[0]) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_BTMX_MODEf_SET(r,f) (r).rx_x4_blksync_cfg[0]=(((r).rx_x4_blksync_cfg[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_CFG.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr,(_r._rx_x4_blksync_cfg))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr,(_r._rx_x4_blksync_cfg)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr,(_r._rx_x4_blksync_cfg))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_cfg))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_cfg))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_CFGr BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr
#define RX_X4_BLKSYNC_CFGr_SIZE BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_t RX_X4_BLKSYNC_CFGr_t;
#define RX_X4_BLKSYNC_CFGr_CLR BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_CLR
#define RX_X4_BLKSYNC_CFGr_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_SET
#define RX_X4_BLKSYNC_CFGr_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_GET
#define RX_X4_BLKSYNC_CFGr_BLK_LOCK_ON_CTRLf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BLK_LOCK_ON_CTRLf_GET
#define RX_X4_BLKSYNC_CFGr_BLK_LOCK_ON_CTRLf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BLK_LOCK_ON_CTRLf_SET
#define RX_X4_BLKSYNC_CFGr_BS_SM_SYNC_MODEf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SM_SYNC_MODEf_GET
#define RX_X4_BLKSYNC_CFGr_BS_SM_SYNC_MODEf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SM_SYNC_MODEf_SET
#define RX_X4_BLKSYNC_CFGr_BS_SYNC_ENf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SYNC_ENf_GET
#define RX_X4_BLKSYNC_CFGr_BS_SYNC_ENf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_SYNC_ENf_SET
#define RX_X4_BLKSYNC_CFGr_BS_DIST_MODEf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_DIST_MODEf_GET
#define RX_X4_BLKSYNC_CFGr_BS_DIST_MODEf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_DIST_MODEf_SET
#define RX_X4_BLKSYNC_CFGr_BS_BTMX_MODEf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_BTMX_MODEf_GET
#define RX_X4_BLKSYNC_CFGr_BS_BTMX_MODEf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr_BS_BTMX_MODEf_SET
#define READ_RX_X4_BLKSYNC_CFGr BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_CFGr
#define WRITE_RX_X4_BLKSYNC_CFGr BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_CFGr
#define MODIFY_RX_X4_BLKSYNC_CFGr BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_CFGr
#define READLN_RX_X4_BLKSYNC_CFGr BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_CFGr
#define WRITELN_RX_X4_BLKSYNC_CFGr BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_CFGr
#define WRITEALL_RX_X4_BLKSYNC_CFGr BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BLKSYNC_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PMA_CTL0
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc137
 * DESC:     pma_control_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RSTB_LANE        Low activer per lane reset for RXP
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r (0x0000c137 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PMA_CTL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pma_ctl0[1];
	uint32_t _rx_x4_pma_ctl0;
} BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_CLR(r) (r).rx_x4_pma_ctl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_SET(r,d) (r).rx_x4_pma_ctl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_GET(r) (r).rx_x4_pma_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_GET(r) (((r).rx_x4_pma_ctl0[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_SET(r,f) (r).rx_x4_pma_ctl0[0]=(((r).rx_x4_pma_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PMA_CTL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r,(_r._rx_x4_pma_ctl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PMA_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pma_ctl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PMA_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pma_ctl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PMA_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pma_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PMA_CTL0r BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r
#define RX_X4_PMA_CTL0r_SIZE BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_t RX_X4_PMA_CTL0r_t;
#define RX_X4_PMA_CTL0r_CLR BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_CLR
#define RX_X4_PMA_CTL0r_SET BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_SET
#define RX_X4_PMA_CTL0r_GET BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_GET
#define RX_X4_PMA_CTL0r_RSTB_LANEf_GET BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_GET
#define RX_X4_PMA_CTL0r_RSTB_LANEf_SET BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r_RSTB_LANEf_SET
#define READ_RX_X4_PMA_CTL0r BCMI_TSCD_XGXS_READ_RX_X4_PMA_CTL0r
#define WRITE_RX_X4_PMA_CTL0r BCMI_TSCD_XGXS_WRITE_RX_X4_PMA_CTL0r
#define MODIFY_RX_X4_PMA_CTL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_PMA_CTL0r
#define READLN_RX_X4_PMA_CTL0r BCMI_TSCD_XGXS_READLN_RX_X4_PMA_CTL0r
#define WRITELN_RX_X4_PMA_CTL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_PMA_CTL0r
#define WRITEALL_RX_X4_PMA_CTL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_PMA_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PMA_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_LNK_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc139
 * DESC:     Link status control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LATCH_LINKDOWN_ENABLE Per port signal1'b1 - If the link status transitions from UP (1) to DOWN (0), this bit maintains the DOWN (0) value of the link status until the SW clears this bit.1'b0 - The link status information is passed directly from the PCS to the MAC and status registers without modification
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_LNK_CTLr (0x0000c139 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_LNK_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x4_lnk_ctl[1];
	uint32_t _rx_x4_lnk_ctl;
} BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_t;

#define BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_CLR(r) (r).rx_x4_lnk_ctl[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_SET(r,d) (r).rx_x4_lnk_ctl[0] = d
#define BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_GET(r) (r).rx_x4_lnk_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET(r) (((r).rx_x4_lnk_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET(r,f) (r).rx_x4_lnk_ctl[0]=(((r).rx_x4_lnk_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_LNK_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_LNK_CTLr,(_r._rx_x4_lnk_ctl))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_LNK_CTLr,(_r._rx_x4_lnk_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_LNK_CTLr,(_r._rx_x4_lnk_ctl))
#define BCMI_TSCD_XGXS_READLN_RX_X4_LNK_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_lnk_ctl))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_LNK_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_lnk_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_LNK_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_LNK_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_lnk_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_LNK_CTLr BCMI_TSCD_XGXS_RX_X4_LNK_CTLr
#define RX_X4_LNK_CTLr_SIZE BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_t RX_X4_LNK_CTLr_t;
#define RX_X4_LNK_CTLr_CLR BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_CLR
#define RX_X4_LNK_CTLr_SET BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_SET
#define RX_X4_LNK_CTLr_GET BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_GET
#define RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_GET
#define RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_LNK_CTLr_LATCH_LINKDOWN_ENABLEf_SET
#define READ_RX_X4_LNK_CTLr BCMI_TSCD_XGXS_READ_RX_X4_LNK_CTLr
#define WRITE_RX_X4_LNK_CTLr BCMI_TSCD_XGXS_WRITE_RX_X4_LNK_CTLr
#define MODIFY_RX_X4_LNK_CTLr BCMI_TSCD_XGXS_MODIFY_RX_X4_LNK_CTLr
#define READLN_RX_X4_LNK_CTLr BCMI_TSCD_XGXS_READLN_RX_X4_LNK_CTLr
#define WRITELN_RX_X4_LNK_CTLr BCMI_TSCD_XGXS_WRITELN_RX_X4_LNK_CTLr
#define WRITEALL_RX_X4_LNK_CTLr BCMI_TSCD_XGXS_WRITEALL_RX_X4_LNK_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_LNK_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL36_CTL
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc13c
 * DESC:     CL36 RX control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36RX_EN        Per logical lane: cl36 RX pipeline: 1=enabled , 0=disabled
 *     CL36RX_LPI_EN    If enabled (1), LPIs are recognized by CL36 RX decoder
 *     CL36RX_DISABLE_CARRIER_EXTEND Disable carrier extensions
 *     CL36RX_FORCE_COMMA_ALIGN_ENABLE Force comma alignment function, and over-ride CL36 Synchronization function
 *     CL36RX_BER_EN    Per logical lane: cl36 RX BER count: 1=enable , 0=disable
 *     CL36RX_10BIT_PMD_DATA_EN Per logical lane: Enables CL36 Rx Pipeline to use all 10-bits of PMD Rx data.This bit should be enabled in OS8.25 mode or 2.5G speed.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr (0x0000c13c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL36_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl36_ctl[1];
	uint32_t _rx_x4_cl36_ctl;
} BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CLR(r) (r).rx_x4_cl36_ctl[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_SET(r,d) (r).rx_x4_cl36_ctl[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_GET(r) (r).rx_x4_cl36_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_10BIT_PMD_DATA_ENf_GET(r) ((((r).rx_x4_cl36_ctl[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_10BIT_PMD_DATA_ENf_SET(r,f) (r).rx_x4_cl36_ctl[0]=(((r).rx_x4_cl36_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_BER_ENf_GET(r) ((((r).rx_x4_cl36_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_BER_ENf_SET(r,f) (r).rx_x4_cl36_ctl[0]=(((r).rx_x4_cl36_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_FORCE_COMMA_ALIGN_ENABLEf_GET(r) ((((r).rx_x4_cl36_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_FORCE_COMMA_ALIGN_ENABLEf_SET(r,f) (r).rx_x4_cl36_ctl[0]=(((r).rx_x4_cl36_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_DISABLE_CARRIER_EXTENDf_GET(r) ((((r).rx_x4_cl36_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_DISABLE_CARRIER_EXTENDf_SET(r,f) (r).rx_x4_cl36_ctl[0]=(((r).rx_x4_cl36_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_LPI_ENf_GET(r) ((((r).rx_x4_cl36_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_LPI_ENf_SET(r,f) (r).rx_x4_cl36_ctl[0]=(((r).rx_x4_cl36_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_ENf_GET(r) (((r).rx_x4_cl36_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_ENf_SET(r,f) (r).rx_x4_cl36_ctl[0]=(((r).rx_x4_cl36_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_CL36_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_CTLr,(_r._rx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_CTLr,(_r._rx_x4_cl36_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_CTLr,(_r._rx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL36_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl36_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL36_CTLr BCMI_TSCD_XGXS_RX_X4_CL36_CTLr
#define RX_X4_CL36_CTLr_SIZE BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_t RX_X4_CL36_CTLr_t;
#define RX_X4_CL36_CTLr_CLR BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CLR
#define RX_X4_CL36_CTLr_SET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_SET
#define RX_X4_CL36_CTLr_GET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_GET
#define RX_X4_CL36_CTLr_CL36RX_10BIT_PMD_DATA_ENf_GET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_10BIT_PMD_DATA_ENf_GET
#define RX_X4_CL36_CTLr_CL36RX_10BIT_PMD_DATA_ENf_SET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_10BIT_PMD_DATA_ENf_SET
#define RX_X4_CL36_CTLr_CL36RX_BER_ENf_GET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_BER_ENf_GET
#define RX_X4_CL36_CTLr_CL36RX_BER_ENf_SET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_BER_ENf_SET
#define RX_X4_CL36_CTLr_CL36RX_FORCE_COMMA_ALIGN_ENABLEf_GET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_FORCE_COMMA_ALIGN_ENABLEf_GET
#define RX_X4_CL36_CTLr_CL36RX_FORCE_COMMA_ALIGN_ENABLEf_SET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_FORCE_COMMA_ALIGN_ENABLEf_SET
#define RX_X4_CL36_CTLr_CL36RX_DISABLE_CARRIER_EXTENDf_GET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_DISABLE_CARRIER_EXTENDf_GET
#define RX_X4_CL36_CTLr_CL36RX_DISABLE_CARRIER_EXTENDf_SET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_DISABLE_CARRIER_EXTENDf_SET
#define RX_X4_CL36_CTLr_CL36RX_LPI_ENf_GET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_LPI_ENf_GET
#define RX_X4_CL36_CTLr_CL36RX_LPI_ENf_SET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_LPI_ENf_SET
#define RX_X4_CL36_CTLr_CL36RX_ENf_GET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_ENf_GET
#define RX_X4_CL36_CTLr_CL36RX_ENf_SET BCMI_TSCD_XGXS_RX_X4_CL36_CTLr_CL36RX_ENf_SET
#define READ_RX_X4_CL36_CTLr BCMI_TSCD_XGXS_READ_RX_X4_CL36_CTLr
#define WRITE_RX_X4_CL36_CTLr BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_CTLr
#define MODIFY_RX_X4_CL36_CTLr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_CTLr
#define READLN_RX_X4_CL36_CTLr BCMI_TSCD_XGXS_READLN_RX_X4_CL36_CTLr
#define WRITELN_RX_X4_CL36_CTLr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_CTLr
#define WRITEALL_RX_X4_CL36_CTLr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL36_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_SYNCE_FRACTIONAL_DIV
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc13d
 * DESC:     SyncE fractional divisor configuration
 * RESETVAL: 0x14a0 (5280)
 * ACCESS:   R/W
 * FIELDS:
 *     SYNCE_FRACTIONAL_DIVSOR_CFG Per physical lane:Program this register for different divider as the following table:f_cdr(Hz)      config divisor[15:0]  resulted fractional divider :Eagle         515,625,000     5280                  20.625546,875,000     5600                  21.875Falcon        644,531,250     6600                  25.78125683,593,750     7000                  27.34375515,625,000     5280                  20.625257,812,500     2640                  10.3125156,250,000     1600                  6.25515,625,000     5280                  20.625resulted fractional divider  =       config division[15:0]/256
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr (0x0000c13d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_SYNCE_FRACTIONAL_DIV.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_s {
	uint32_t v[1];
	uint32_t rx_x4_synce_fractional_div[1];
	uint32_t _rx_x4_synce_fractional_div;
} BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_t;

#define BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_CLR(r) (r).rx_x4_synce_fractional_div[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SET(r,d) (r).rx_x4_synce_fractional_div[0] = d
#define BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_GET(r) (r).rx_x4_synce_fractional_div[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_GET(r) (((r).rx_x4_synce_fractional_div[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_SET(r,f) (r).rx_x4_synce_fractional_div[0]=(((r).rx_x4_synce_fractional_div[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_SYNCE_FRACTIONAL_DIV.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_SYNCE_FRACTIONAL_DIVr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr,(_r._rx_x4_synce_fractional_div))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_SYNCE_FRACTIONAL_DIVr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr,(_r._rx_x4_synce_fractional_div)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_SYNCE_FRACTIONAL_DIVr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr,(_r._rx_x4_synce_fractional_div))
#define BCMI_TSCD_XGXS_READLN_RX_X4_SYNCE_FRACTIONAL_DIVr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_synce_fractional_div))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_SYNCE_FRACTIONAL_DIVr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_synce_fractional_div))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_SYNCE_FRACTIONAL_DIVr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_synce_fractional_div))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_SYNCE_FRACTIONAL_DIVr BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr
#define RX_X4_SYNCE_FRACTIONAL_DIVr_SIZE BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_t RX_X4_SYNCE_FRACTIONAL_DIVr_t;
#define RX_X4_SYNCE_FRACTIONAL_DIVr_CLR BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_CLR
#define RX_X4_SYNCE_FRACTIONAL_DIVr_SET BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SET
#define RX_X4_SYNCE_FRACTIONAL_DIVr_GET BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_GET
#define RX_X4_SYNCE_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_GET BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_GET
#define RX_X4_SYNCE_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_SET BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr_SYNCE_FRACTIONAL_DIVSOR_CFGf_SET
#define READ_RX_X4_SYNCE_FRACTIONAL_DIVr BCMI_TSCD_XGXS_READ_RX_X4_SYNCE_FRACTIONAL_DIVr
#define WRITE_RX_X4_SYNCE_FRACTIONAL_DIVr BCMI_TSCD_XGXS_WRITE_RX_X4_SYNCE_FRACTIONAL_DIVr
#define MODIFY_RX_X4_SYNCE_FRACTIONAL_DIVr BCMI_TSCD_XGXS_MODIFY_RX_X4_SYNCE_FRACTIONAL_DIVr
#define READLN_RX_X4_SYNCE_FRACTIONAL_DIVr BCMI_TSCD_XGXS_READLN_RX_X4_SYNCE_FRACTIONAL_DIVr
#define WRITELN_RX_X4_SYNCE_FRACTIONAL_DIVr BCMI_TSCD_XGXS_WRITELN_RX_X4_SYNCE_FRACTIONAL_DIVr
#define WRITEALL_RX_X4_SYNCE_FRACTIONAL_DIVr BCMI_TSCD_XGXS_WRITEALL_RX_X4_SYNCE_FRACTIONAL_DIVr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_SYNCE_FRACTIONAL_DIVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_IEEE_25G_PARLLEL_DET_CTR
 * BLOCKS:   RX_X4_CONTROL0
 * REGADDR:  0xc13e
 * DESC:     25G IEEE vs MSA detection control register
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     MSA_IEEE_DET_TIMEPERIOD Time which will be spent on MSA and IEEE detection.
 *     MSA_IEEE_DET_EN  MSA and IEEE device detection in FORCED speed mode. This should only be enabled in forced speed mode and never in AN (or SW-AN)
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr (0x0000c13e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_IEEE_25G_PARLLEL_DET_CTR.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_s {
	uint32_t v[1];
	uint32_t rx_x4_ieee_25g_parllel_det_ctr[1];
	uint32_t _rx_x4_ieee_25g_parllel_det_ctr;
} BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_t;

#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_CLR(r) (r).rx_x4_ieee_25g_parllel_det_ctr[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_SET(r,d) (r).rx_x4_ieee_25g_parllel_det_ctr[0] = d
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_GET(r) (r).rx_x4_ieee_25g_parllel_det_ctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_ENf_GET(r) ((((r).rx_x4_ieee_25g_parllel_det_ctr[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_ENf_SET(r,f) (r).rx_x4_ieee_25g_parllel_det_ctr[0]=(((r).rx_x4_ieee_25g_parllel_det_ctr[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_TIMEPERIODf_GET(r) (((r).rx_x4_ieee_25g_parllel_det_ctr[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_TIMEPERIODf_SET(r,f) (r).rx_x4_ieee_25g_parllel_det_ctr[0]=(((r).rx_x4_ieee_25g_parllel_det_ctr[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RX_X4_IEEE_25G_PARLLEL_DET_CTR.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_IEEE_25G_PARLLEL_DET_CTRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr,(_r._rx_x4_ieee_25g_parllel_det_ctr))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_IEEE_25G_PARLLEL_DET_CTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr,(_r._rx_x4_ieee_25g_parllel_det_ctr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_IEEE_25G_PARLLEL_DET_CTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr,(_r._rx_x4_ieee_25g_parllel_det_ctr))
#define BCMI_TSCD_XGXS_READLN_RX_X4_IEEE_25G_PARLLEL_DET_CTRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ieee_25g_parllel_det_ctr))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_IEEE_25G_PARLLEL_DET_CTRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ieee_25g_parllel_det_ctr))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_IEEE_25G_PARLLEL_DET_CTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ieee_25g_parllel_det_ctr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_SIZE BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_t RX_X4_IEEE_25G_PARLLEL_DET_CTRr_t;
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_CLR BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_CLR
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_SET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_SET
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_GET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_GET
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_ENf_GET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_ENf_GET
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_ENf_SET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_ENf_SET
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_TIMEPERIODf_GET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_TIMEPERIODf_GET
#define RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_TIMEPERIODf_SET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr_MSA_IEEE_DET_TIMEPERIODf_SET
#define READ_RX_X4_IEEE_25G_PARLLEL_DET_CTRr BCMI_TSCD_XGXS_READ_RX_X4_IEEE_25G_PARLLEL_DET_CTRr
#define WRITE_RX_X4_IEEE_25G_PARLLEL_DET_CTRr BCMI_TSCD_XGXS_WRITE_RX_X4_IEEE_25G_PARLLEL_DET_CTRr
#define MODIFY_RX_X4_IEEE_25G_PARLLEL_DET_CTRr BCMI_TSCD_XGXS_MODIFY_RX_X4_IEEE_25G_PARLLEL_DET_CTRr
#define READLN_RX_X4_IEEE_25G_PARLLEL_DET_CTRr BCMI_TSCD_XGXS_READLN_RX_X4_IEEE_25G_PARLLEL_DET_CTRr
#define WRITELN_RX_X4_IEEE_25G_PARLLEL_DET_CTRr BCMI_TSCD_XGXS_WRITELN_RX_X4_IEEE_25G_PARLLEL_DET_CTRr
#define WRITEALL_RX_X4_IEEE_25G_PARLLEL_DET_CTRr BCMI_TSCD_XGXS_WRITEALL_RX_X4_IEEE_25G_PARLLEL_DET_CTRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_CTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC0
 * BLOCKS:   RX_X4_FEC_CONTROL
 * REGADDR:  0xc140
 * DESC:     User FEC Control 0 register
 * RESETVAL: 0x442c (17452)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERR_MODE     debug readout only for uncorrectable errors
 *     BURST_ERR_STATUS_MODE collect error info only for uncorrectable errors0 - update on correctable and uncorrectable events1 - update on uncorrectable events only
 *     DEC_MAX_PM       maximum correctable burst pattern size
 *     INVALID_PARITY_CNT number of bad locks before unlocking
 *     GOOD_PARITY_CNT  number of good blocks before locking
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC0r (0x0000c140 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec0[1];
	uint32_t _rx_x4_fec0;
} BCMI_TSCD_XGXS_RX_X4_FEC0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC0r_CLR(r) (r).rx_x4_fec0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_SET(r,d) (r).rx_x4_fec0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_GET(r) (r).rx_x4_fec0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_GET(r) ((((r).rx_x4_fec0[0]) >> 12) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_GET(r) ((((r).rx_x4_fec0[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_GET(r) ((((r).rx_x4_fec0[0]) >> 2) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_GET(r) ((((r).rx_x4_fec0[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_GET(r) (((r).rx_x4_fec0[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_SET(r,f) (r).rx_x4_fec0[0]=(((r).rx_x4_fec0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_FEC0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC0r,(_r._rx_x4_fec0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC0r BCMI_TSCD_XGXS_RX_X4_FEC0r
#define RX_X4_FEC0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC0r_t RX_X4_FEC0r_t;
#define RX_X4_FEC0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC0r_CLR
#define RX_X4_FEC0r_SET BCMI_TSCD_XGXS_RX_X4_FEC0r_SET
#define RX_X4_FEC0r_GET BCMI_TSCD_XGXS_RX_X4_FEC0r_GET
#define RX_X4_FEC0r_GOOD_PARITY_CNTf_GET BCMI_TSCD_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_GET
#define RX_X4_FEC0r_GOOD_PARITY_CNTf_SET BCMI_TSCD_XGXS_RX_X4_FEC0r_GOOD_PARITY_CNTf_SET
#define RX_X4_FEC0r_INVALID_PARITY_CNTf_GET BCMI_TSCD_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_GET
#define RX_X4_FEC0r_INVALID_PARITY_CNTf_SET BCMI_TSCD_XGXS_RX_X4_FEC0r_INVALID_PARITY_CNTf_SET
#define RX_X4_FEC0r_DEC_MAX_PMf_GET BCMI_TSCD_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_GET
#define RX_X4_FEC0r_DEC_MAX_PMf_SET BCMI_TSCD_XGXS_RX_X4_FEC0r_DEC_MAX_PMf_SET
#define RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_GET BCMI_TSCD_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_GET
#define RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_SET BCMI_TSCD_XGXS_RX_X4_FEC0r_BURST_ERR_STATUS_MODEf_SET
#define RX_X4_FEC0r_DBG_ERR_MODEf_GET BCMI_TSCD_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_GET
#define RX_X4_FEC0r_DBG_ERR_MODEf_SET BCMI_TSCD_XGXS_RX_X4_FEC0r_DBG_ERR_MODEf_SET
#define READ_RX_X4_FEC0r BCMI_TSCD_XGXS_READ_RX_X4_FEC0r
#define WRITE_RX_X4_FEC0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC0r
#define MODIFY_RX_X4_FEC0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC0r
#define READLN_RX_X4_FEC0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC0r
#define WRITELN_RX_X4_FEC0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC0r
#define WRITEALL_RX_X4_FEC0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC1
 * BLOCKS:   RX_X4_FEC_CONTROL
 * REGADDR:  0xc141
 * DESC:     User FEC Control 1 register
 * RESETVAL: 0x28 (40)
 * ACCESS:   R/W
 * FIELDS:
 *     DEC_GAP_COUNT_MODE Gap counting mode0 = Counting zero method1 = Counting gap method
 *     DEC_17B_BURST_GAP_COUNT Gaps allowed in 17-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_18B_BURST_GAP_COUNT Gaps allowed in 18-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_19B_BURST_GAP_COUNT Gaps allowed in 19-bit bursts000 No gaps001 Single gap010-111 Multi gaps
 *     DEC_PM_MODE      Pattern Match Mode
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC1r (0x0000c141 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec1[1];
	uint32_t _rx_x4_fec1;
} BCMI_TSCD_XGXS_RX_X4_FEC1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC1r_CLR(r) (r).rx_x4_fec1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_SET(r,d) (r).rx_x4_fec1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_GET(r) (r).rx_x4_fec1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_GET(r) ((((r).rx_x4_fec1[0]) >> 11) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 8) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 5) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x7 << 5)) | ((((uint32_t)f) & 0x7) << 5)) | (7 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_GET(r) ((((r).rx_x4_fec1[0]) >> 2) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x7 << 2)) | ((((uint32_t)f) & 0x7) << 2)) | (7 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_GET(r) ((((r).rx_x4_fec1[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_SET(r,f) (r).rx_x4_fec1[0]=(((r).rx_x4_fec1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access RX_X4_FEC1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC1r,(_r._rx_x4_fec1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC1r BCMI_TSCD_XGXS_RX_X4_FEC1r
#define RX_X4_FEC1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC1r_t RX_X4_FEC1r_t;
#define RX_X4_FEC1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC1r_CLR
#define RX_X4_FEC1r_SET BCMI_TSCD_XGXS_RX_X4_FEC1r_SET
#define RX_X4_FEC1r_GET BCMI_TSCD_XGXS_RX_X4_FEC1r_GET
#define RX_X4_FEC1r_DEC_PM_MODEf_GET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_GET
#define RX_X4_FEC1r_DEC_PM_MODEf_SET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_PM_MODEf_SET
#define RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_GET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_SET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_19B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_GET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_SET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_18B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_GET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_GET
#define RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_SET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_17B_BURST_GAP_COUNTf_SET
#define RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_GET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_GET
#define RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_SET BCMI_TSCD_XGXS_RX_X4_FEC1r_DEC_GAP_COUNT_MODEf_SET
#define READ_RX_X4_FEC1r BCMI_TSCD_XGXS_READ_RX_X4_FEC1r
#define WRITE_RX_X4_FEC1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC1r
#define MODIFY_RX_X4_FEC1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC1r
#define READLN_RX_X4_FEC1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC1r
#define WRITELN_RX_X4_FEC1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC1r
#define WRITEALL_RX_X4_FEC1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC2
 * BLOCKS:   RX_X4_FEC_CONTROL
 * REGADDR:  0xc142
 * DESC:     User FEC Control 2 register
 * RESETVAL: 0x7c00 (31744)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_ERROR_CODE_ALL_PER_STREAM report errors thru all sync headersNow this functionality is controlled by Speed table so it is advisable NOT to TOUCH this register.
 *     DBG_ENABLE_PER_STREAM FEC debug enable
 *     FEC_ERR_ENABLE_PER_STREAM FEC error enable
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC2r (0x0000c142 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec2[1];
	uint32_t _rx_x4_fec2;
} BCMI_TSCD_XGXS_RX_X4_FEC2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC2r_CLR(r) (r).rx_x4_fec2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_SET(r,d) (r).rx_x4_fec2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_GET(r) (r).rx_x4_fec2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLE_PER_STREAMf_GET(r) ((((r).rx_x4_fec2[0]) >> 10) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLE_PER_STREAMf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_DBG_ENABLE_PER_STREAMf_GET(r) ((((r).rx_x4_fec2[0]) >> 5) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_DBG_ENABLE_PER_STREAMf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALL_PER_STREAMf_GET(r) (((r).rx_x4_fec2[0]) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALL_PER_STREAMf_SET(r,f) (r).rx_x4_fec2[0]=(((r).rx_x4_fec2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_FEC2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC2r,(_r._rx_x4_fec2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC2r BCMI_TSCD_XGXS_RX_X4_FEC2r
#define RX_X4_FEC2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC2r_t RX_X4_FEC2r_t;
#define RX_X4_FEC2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC2r_CLR
#define RX_X4_FEC2r_SET BCMI_TSCD_XGXS_RX_X4_FEC2r_SET
#define RX_X4_FEC2r_GET BCMI_TSCD_XGXS_RX_X4_FEC2r_GET
#define RX_X4_FEC2r_FEC_ERR_ENABLE_PER_STREAMf_GET BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLE_PER_STREAMf_GET
#define RX_X4_FEC2r_FEC_ERR_ENABLE_PER_STREAMf_SET BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERR_ENABLE_PER_STREAMf_SET
#define RX_X4_FEC2r_DBG_ENABLE_PER_STREAMf_GET BCMI_TSCD_XGXS_RX_X4_FEC2r_DBG_ENABLE_PER_STREAMf_GET
#define RX_X4_FEC2r_DBG_ENABLE_PER_STREAMf_SET BCMI_TSCD_XGXS_RX_X4_FEC2r_DBG_ENABLE_PER_STREAMf_SET
#define RX_X4_FEC2r_FEC_ERROR_CODE_ALL_PER_STREAMf_GET BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALL_PER_STREAMf_GET
#define RX_X4_FEC2r_FEC_ERROR_CODE_ALL_PER_STREAMf_SET BCMI_TSCD_XGXS_RX_X4_FEC2r_FEC_ERROR_CODE_ALL_PER_STREAMf_SET
#define READ_RX_X4_FEC2r BCMI_TSCD_XGXS_READ_RX_X4_FEC2r
#define WRITE_RX_X4_FEC2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC2r
#define MODIFY_RX_X4_FEC2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC2r
#define READLN_RX_X4_FEC2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC2r
#define WRITELN_RX_X4_FEC2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC2r
#define WRITEALL_RX_X4_FEC2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC3
 * BLOCKS:   RX_X4_FEC_CONTROL
 * REGADDR:  0xc143
 * DESC:     User FEC Control 3 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERROR_EN_OVR_PER_STREAM FEC error enable override control
 *     ERROR_EN_OVR_VAL_PER_STREAM FEC error enable override control value
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC3r (0x0000c143 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec3[1];
	uint32_t _rx_x4_fec3;
} BCMI_TSCD_XGXS_RX_X4_FEC3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC3r_CLR(r) (r).rx_x4_fec3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC3r_SET(r,d) (r).rx_x4_fec3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC3r_GET(r) (r).rx_x4_fec3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_VAL_PER_STREAMf_GET(r) ((((r).rx_x4_fec3[0]) >> 5) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_VAL_PER_STREAMf_SET(r,f) (r).rx_x4_fec3[0]=(((r).rx_x4_fec3[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_PER_STREAMf_GET(r) (((r).rx_x4_fec3[0]) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_PER_STREAMf_SET(r,f) (r).rx_x4_fec3[0]=(((r).rx_x4_fec3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_FEC3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC3r,(_r._rx_x4_fec3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC3r,(_r._rx_x4_fec3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC3r,(_r._rx_x4_fec3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC3r BCMI_TSCD_XGXS_RX_X4_FEC3r
#define RX_X4_FEC3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC3r_t RX_X4_FEC3r_t;
#define RX_X4_FEC3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC3r_CLR
#define RX_X4_FEC3r_SET BCMI_TSCD_XGXS_RX_X4_FEC3r_SET
#define RX_X4_FEC3r_GET BCMI_TSCD_XGXS_RX_X4_FEC3r_GET
#define RX_X4_FEC3r_ERROR_EN_OVR_VAL_PER_STREAMf_GET BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_VAL_PER_STREAMf_GET
#define RX_X4_FEC3r_ERROR_EN_OVR_VAL_PER_STREAMf_SET BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_VAL_PER_STREAMf_SET
#define RX_X4_FEC3r_ERROR_EN_OVR_PER_STREAMf_GET BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_PER_STREAMf_GET
#define RX_X4_FEC3r_ERROR_EN_OVR_PER_STREAMf_SET BCMI_TSCD_XGXS_RX_X4_FEC3r_ERROR_EN_OVR_PER_STREAMf_SET
#define READ_RX_X4_FEC3r BCMI_TSCD_XGXS_READ_RX_X4_FEC3r
#define WRITE_RX_X4_FEC3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC3r
#define MODIFY_RX_X4_FEC3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC3r
#define READLN_RX_X4_FEC3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC3r
#define WRITELN_RX_X4_FEC3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC3r
#define WRITEALL_RX_X4_FEC3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BLKSYNC_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc150
 * DESC:     block sync status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BS_STATUS        Block Lock: indicates that the lane has achieved block lock status.One bit per pseudo-logical (Bitmux output) lane.
 *     BS_PMD_LOCK      Indicates the pmd_lock value seen at the input to this lane.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr (0x0000c150 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_sts[1];
	uint32_t _rx_x4_blksync_sts;
} BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_t;

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_CLR(r) (r).rx_x4_blksync_sts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_SET(r,d) (r).rx_x4_blksync_sts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_GET(r) (r).rx_x4_blksync_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_GET(r) ((((r).rx_x4_blksync_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_SET(r,f) (r).rx_x4_blksync_sts[0]=(((r).rx_x4_blksync_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_GET(r) (((r).rx_x4_blksync_sts[0]) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_SET(r,f) (r).rx_x4_blksync_sts[0]=(((r).rx_x4_blksync_sts[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr,(_r._rx_x4_blksync_sts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr,(_r._rx_x4_blksync_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr,(_r._rx_x4_blksync_sts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_sts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_sts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_STSr BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr
#define RX_X4_BLKSYNC_STSr_SIZE BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_t RX_X4_BLKSYNC_STSr_t;
#define RX_X4_BLKSYNC_STSr_CLR BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_CLR
#define RX_X4_BLKSYNC_STSr_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_SET
#define RX_X4_BLKSYNC_STSr_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_GET
#define RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_GET
#define RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_PMD_LOCKf_SET
#define RX_X4_BLKSYNC_STSr_BS_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_GET
#define RX_X4_BLKSYNC_STSr_BS_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr_BS_STATUSf_SET
#define READ_RX_X4_BLKSYNC_STSr BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_STSr
#define WRITE_RX_X4_BLKSYNC_STSr BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_STSr
#define MODIFY_RX_X4_BLKSYNC_STSr BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_STSr
#define READLN_RX_X4_BLKSYNC_STSr BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_STSr
#define WRITELN_RX_X4_BLKSYNC_STSr BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_STSr
#define WRITEALL_RX_X4_BLKSYNC_STSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BLKSYNC_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BLKSYNC_DBG0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc151
 * DESC:     block sync state machine debug info
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE0_DEBUG_INFO Debug info for pseudo-logical lane 0 blocksync SM.See Table 7: Debug Info Bit Defs.
 *     LANE1_DEBUG_INFO Debug info for pseudo-logical lane 1 blocksync SM.See Table 7: Debug Info Bit Defs.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r (0x0000c151 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_DBG0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_dbg0[1];
	uint32_t _rx_x4_blksync_dbg0;
} BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_t;

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_CLR(r) (r).rx_x4_blksync_dbg0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_SET(r,d) (r).rx_x4_blksync_dbg0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_GET(r) (r).rx_x4_blksync_dbg0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_GET(r) ((((r).rx_x4_blksync_dbg0[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg0[0]=(((r).rx_x4_blksync_dbg0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_GET(r) (((r).rx_x4_blksync_dbg0[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg0[0]=(((r).rx_x4_blksync_dbg0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_DBG0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r,(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r,(_r._rx_x4_blksync_dbg0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r,(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_DBG0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_DBG0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_dbg0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_DBG0r BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r
#define RX_X4_BLKSYNC_DBG0r_SIZE BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_t RX_X4_BLKSYNC_DBG0r_t;
#define RX_X4_BLKSYNC_DBG0r_CLR BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_CLR
#define RX_X4_BLKSYNC_DBG0r_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_SET
#define RX_X4_BLKSYNC_DBG0r_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_GET
#define RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE1_DEBUG_INFOf_SET
#define RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r_LANE0_DEBUG_INFOf_SET
#define READ_RX_X4_BLKSYNC_DBG0r BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_DBG0r
#define WRITE_RX_X4_BLKSYNC_DBG0r BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_DBG0r
#define MODIFY_RX_X4_BLKSYNC_DBG0r BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_DBG0r
#define READLN_RX_X4_BLKSYNC_DBG0r BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_DBG0r
#define WRITELN_RX_X4_BLKSYNC_DBG0r BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_DBG0r
#define WRITEALL_RX_X4_BLKSYNC_DBG0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BLKSYNC_DBG1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc152
 * DESC:     block sync state machine debug info
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE2_DEBUG_INFO Debug info for pseudo-logical lane 2 blocksync SM.See Table 7: Debug Info Bit Defs.
 *     LANE3_DEBUG_INFO Debug info for pseudo-logical lane 3 blocksync SM.See Table 7: Debug Info Bit Defs.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r (0x0000c152 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_DBG1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_dbg1[1];
	uint32_t _rx_x4_blksync_dbg1;
} BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_t;

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_CLR(r) (r).rx_x4_blksync_dbg1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_SET(r,d) (r).rx_x4_blksync_dbg1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_GET(r) (r).rx_x4_blksync_dbg1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_GET(r) ((((r).rx_x4_blksync_dbg1[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg1[0]=(((r).rx_x4_blksync_dbg1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_GET(r) (((r).rx_x4_blksync_dbg1[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg1[0]=(((r).rx_x4_blksync_dbg1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_DBG1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r,(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r,(_r._rx_x4_blksync_dbg1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r,(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_DBG1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_DBG1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_dbg1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_DBG1r BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r
#define RX_X4_BLKSYNC_DBG1r_SIZE BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_t RX_X4_BLKSYNC_DBG1r_t;
#define RX_X4_BLKSYNC_DBG1r_CLR BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_CLR
#define RX_X4_BLKSYNC_DBG1r_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_SET
#define RX_X4_BLKSYNC_DBG1r_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_GET
#define RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE3_DEBUG_INFOf_SET
#define RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r_LANE2_DEBUG_INFOf_SET
#define READ_RX_X4_BLKSYNC_DBG1r BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_DBG1r
#define WRITE_RX_X4_BLKSYNC_DBG1r BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_DBG1r
#define MODIFY_RX_X4_BLKSYNC_DBG1r BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_DBG1r
#define READLN_RX_X4_BLKSYNC_DBG1r BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_DBG1r
#define WRITELN_RX_X4_BLKSYNC_DBG1r BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_DBG1r
#define WRITEALL_RX_X4_BLKSYNC_DBG1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BLKSYNC_DBG2
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc153
 * DESC:     block sync state machine debug info
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE4_DEBUG_INFO Debug info for pseudo-logical lane 4 blocksync SM.See Table 7: Debug Info Bit Defs.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r (0x0000c153 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLKSYNC_DBG2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_s {
	uint32_t v[1];
	uint32_t rx_x4_blksync_dbg2[1];
	uint32_t _rx_x4_blksync_dbg2;
} BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_t;

#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_CLR(r) (r).rx_x4_blksync_dbg2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_SET(r,d) (r).rx_x4_blksync_dbg2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_GET(r) (r).rx_x4_blksync_dbg2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_GET(r) (((r).rx_x4_blksync_dbg2[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_SET(r,f) (r).rx_x4_blksync_dbg2[0]=(((r).rx_x4_blksync_dbg2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BLKSYNC_DBG2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r,(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r,(_r._rx_x4_blksync_dbg2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r,(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_DBG2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_DBG2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blksync_dbg2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blksync_dbg2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLKSYNC_DBG2r BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r
#define RX_X4_BLKSYNC_DBG2r_SIZE BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_t RX_X4_BLKSYNC_DBG2r_t;
#define RX_X4_BLKSYNC_DBG2r_CLR BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_CLR
#define RX_X4_BLKSYNC_DBG2r_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_SET
#define RX_X4_BLKSYNC_DBG2r_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_GET
#define RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_GET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_GET
#define RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_SET BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r_LANE4_DEBUG_INFOf_SET
#define READ_RX_X4_BLKSYNC_DBG2r BCMI_TSCD_XGXS_READ_RX_X4_BLKSYNC_DBG2r
#define WRITE_RX_X4_BLKSYNC_DBG2r BCMI_TSCD_XGXS_WRITE_RX_X4_BLKSYNC_DBG2r
#define MODIFY_RX_X4_BLKSYNC_DBG2r BCMI_TSCD_XGXS_MODIFY_RX_X4_BLKSYNC_DBG2r
#define READLN_RX_X4_BLKSYNC_DBG2r BCMI_TSCD_XGXS_READLN_RX_X4_BLKSYNC_DBG2r
#define WRITELN_RX_X4_BLKSYNC_DBG2r BCMI_TSCD_XGXS_WRITELN_RX_X4_BLKSYNC_DBG2r
#define WRITEALL_RX_X4_BLKSYNC_DBG2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLKSYNC_DBG2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BLKSYNC_DBG2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BLK_LOCK_LATCH_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc154
 * DESC:     Latched status of PCS information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BLOCK_LOCK_LL_0  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 0).Clear on read
 *     BLOCK_LOCK_LH_0  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 0).Clear on read
 *     BLOCK_LOCK_LL_1  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 1).Clear on read
 *     BLOCK_LOCK_LH_1  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 1).Clear on read
 *     BLOCK_LOCK_LL_2  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 2).Clear on read
 *     BLOCK_LOCK_LH_2  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 2).Clear on read
 *     BLOCK_LOCK_LL_3  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 3).Clear on read
 *     BLOCK_LOCK_LH_3  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 3).Clear on read
 *     BLOCK_LOCK_LL_4  BLOCK Lock has transitioned low since last read (for Pseudo-logical lane 4).Clear on read
 *     BLOCK_LOCK_LH_4  BLOCK Lock has transitioned high since last read (for Pseudo-logical lane 4).Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr (0x0000c154 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BLK_LOCK_LATCH_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_blk_lock_latch_sts[1];
	uint32_t _rx_x4_blk_lock_latch_sts;
} BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_t;

#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_CLR(r) (r).rx_x4_blk_lock_latch_sts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SET(r,d) (r).rx_x4_blk_lock_latch_sts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_GET(r) (r).rx_x4_blk_lock_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_GET(r) ((((r).rx_x4_blk_lock_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_GET(r) (((r).rx_x4_blk_lock_latch_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_SET(r,f) (r).rx_x4_blk_lock_latch_sts[0]=(((r).rx_x4_blk_lock_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_BLK_LOCK_LATCH_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr,(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr,(_r._rx_x4_blk_lock_latch_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr,(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_blk_lock_latch_sts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLK_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_blk_lock_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr
#define RX_X4_BLK_LOCK_LATCH_STSr_SIZE BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_t RX_X4_BLK_LOCK_LATCH_STSr_t;
#define RX_X4_BLK_LOCK_LATCH_STSr_CLR BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_CLR
#define RX_X4_BLK_LOCK_LATCH_STSr_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_4f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_4f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_3f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_3f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_2f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_2f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_1f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_1f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LH_0f_SET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_GET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_GET
#define RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_SET BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr_BLOCK_LOCK_LL_0f_SET
#define READ_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCD_XGXS_READ_RX_X4_BLK_LOCK_LATCH_STSr
#define WRITE_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCD_XGXS_WRITE_RX_X4_BLK_LOCK_LATCH_STSr
#define MODIFY_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCD_XGXS_MODIFY_RX_X4_BLK_LOCK_LATCH_STSr
#define READLN_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCD_XGXS_READLN_RX_X4_BLK_LOCK_LATCH_STSr
#define WRITELN_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCD_XGXS_WRITELN_RX_X4_BLK_LOCK_LATCH_STSr
#define WRITEALL_RX_X4_BLK_LOCK_LATCH_STSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_BLK_LOCK_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BLK_LOCK_LATCH_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_AM_LOCK_LATCH_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc155
 * DESC:     Latched status of PCS information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_LL_0     AM Lock has transitioned low since last read (for Pseudo-logical lane 0).Clear on read
 *     AM_LOCK_LH_0     AM Lock has transitioned high since last read (for Pseudo-logical lane 0).Clear on read
 *     AM_LOCK_LL_1     AM Lock has transitioned low since last read (for Pseudo-logical lane 1).Clear on read
 *     AM_LOCK_LH_1     AM Lock has transitioned high since last read (for Pseudo-logical lane 1).Clear on read
 *     AM_LOCK_LL_2     AM Lock has transitioned low since last read (for Pseudo-logical lane 2).Clear on read
 *     AM_LOCK_LH_2     AM Lock has transitioned high since last read (for Pseudo-logical lane 2).Clear on read
 *     AM_LOCK_LL_3     AM Lock has transitioned low since last read (for Pseudo-logical lane 3).Clear on read
 *     AM_LOCK_LH_3     AM Lock has transitioned high since last read (for Pseudo-logical lane 3).Clear on read
 *     AM_LOCK_LL_4     AM Lock has transitioned low since last read (for Pseudo-logical lane 4).Clear on read
 *     AM_LOCK_LH_4     AM Lock has transitioned high since last read (for Pseudo-logical lane 4).Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr (0x0000c155 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_AM_LOCK_LATCH_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_am_lock_latch_sts[1];
	uint32_t _rx_x4_am_lock_latch_sts;
} BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_t;

#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_CLR(r) (r).rx_x4_am_lock_latch_sts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SET(r,d) (r).rx_x4_am_lock_latch_sts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_GET(r) (r).rx_x4_am_lock_latch_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_GET(r) ((((r).rx_x4_am_lock_latch_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_GET(r) (((r).rx_x4_am_lock_latch_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_SET(r,f) (r).rx_x4_am_lock_latch_sts[0]=(((r).rx_x4_am_lock_latch_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_AM_LOCK_LATCH_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr,(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr,(_r._rx_x4_am_lock_latch_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr,(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_AM_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_AM_LOCK_LATCH_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_am_lock_latch_sts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_AM_LOCK_LATCH_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_am_lock_latch_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr
#define RX_X4_AM_LOCK_LATCH_STSr_SIZE BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_t RX_X4_AM_LOCK_LATCH_STSr_t;
#define RX_X4_AM_LOCK_LATCH_STSr_CLR BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_CLR
#define RX_X4_AM_LOCK_LATCH_STSr_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_SET
#define RX_X4_AM_LOCK_LATCH_STSr_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_4f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_4f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_3f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_3f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_2f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_2f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_1f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_1f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LH_0f_SET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_GET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_GET
#define RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_SET BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr_AM_LOCK_LL_0f_SET
#define READ_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCD_XGXS_READ_RX_X4_AM_LOCK_LATCH_STSr
#define WRITE_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCD_XGXS_WRITE_RX_X4_AM_LOCK_LATCH_STSr
#define MODIFY_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCD_XGXS_MODIFY_RX_X4_AM_LOCK_LATCH_STSr
#define READLN_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCD_XGXS_READLN_RX_X4_AM_LOCK_LATCH_STSr
#define WRITELN_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCD_XGXS_WRITELN_RX_X4_AM_LOCK_LATCH_STSr
#define WRITEALL_RX_X4_AM_LOCK_LATCH_STSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_AM_LOCK_LATCH_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_AM_LOCK_LATCH_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PCS_LIVE_STS0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc156
 * DESC:     Live status of PCS information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_LOCK_0        AM Lock status for pseudo-logical lane 0
 *     AM_LOCK_1        AM Lock status for pseudo-logical lane 1
 *     AM_LOCK_2        AM Lock status for pseudo-logical lane 2
 *     AM_LOCK_3        AM Lock status for pseudo-logical lane 3
 *     AM_LOCK_4        AM Lock status for pseudo-logical lane 4
 *     BLOCK_LOCK_0     BLOCK Lock status for pseudo-logical lane 0
 *     BLOCK_LOCK_1     BLOCK Lock status for pseudo-logical lane 1
 *     BLOCK_LOCK_2     BLOCK Lock status for pseudo-logical lane 2
 *     BLOCK_LOCK_3     BLOCK Lock status for pseudo-logical lane 3
 *     BLOCK_LOCK_4     BLOCK Lock status for pseudo-logical lane 4
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r (0x0000c156 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LIVE_STS0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_live_sts0[1];
	uint32_t _rx_x4_pcs_live_sts0;
} BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_t;

#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_CLR(r) (r).rx_x4_pcs_live_sts0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_SET(r,d) (r).rx_x4_pcs_live_sts0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_GET(r) (r).rx_x4_pcs_live_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_4f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_4f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_3f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_3f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_2f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_2f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_1f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_1f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_0f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_0f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_4f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_4f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_3f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_3f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_2f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_2f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_1f_GET(r) ((((r).rx_x4_pcs_live_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_1f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_0f_GET(r) (((r).rx_x4_pcs_live_sts0[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_0f_SET(r,f) (r).rx_x4_pcs_live_sts0[0]=(((r).rx_x4_pcs_live_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PCS_LIVE_STS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PCS_LIVE_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r,(_r._rx_x4_pcs_live_sts0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_LIVE_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r,(_r._rx_x4_pcs_live_sts0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_LIVE_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r,(_r._rx_x4_pcs_live_sts0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PCS_LIVE_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_live_sts0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_LIVE_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_live_sts0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_LIVE_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_live_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LIVE_STS0r BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r
#define RX_X4_PCS_LIVE_STS0r_SIZE BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_t RX_X4_PCS_LIVE_STS0r_t;
#define RX_X4_PCS_LIVE_STS0r_CLR BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_CLR
#define RX_X4_PCS_LIVE_STS0r_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_SET
#define RX_X4_PCS_LIVE_STS0r_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_GET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_4f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_4f_GET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_4f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_4f_SET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_3f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_3f_GET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_3f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_3f_SET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_2f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_2f_GET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_2f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_2f_SET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_1f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_1f_GET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_1f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_1f_SET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_0f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_0f_GET
#define RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_0f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_BLOCK_LOCK_0f_SET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_4f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_4f_GET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_4f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_4f_SET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_3f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_3f_GET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_3f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_3f_SET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_2f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_2f_GET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_2f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_2f_SET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_1f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_1f_GET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_1f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_1f_SET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_0f_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_0f_GET
#define RX_X4_PCS_LIVE_STS0r_AM_LOCK_0f_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r_AM_LOCK_0f_SET
#define READ_RX_X4_PCS_LIVE_STS0r BCMI_TSCD_XGXS_READ_RX_X4_PCS_LIVE_STS0r
#define WRITE_RX_X4_PCS_LIVE_STS0r BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_LIVE_STS0r
#define MODIFY_RX_X4_PCS_LIVE_STS0r BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_LIVE_STS0r
#define READLN_RX_X4_PCS_LIVE_STS0r BCMI_TSCD_XGXS_READLN_RX_X4_PCS_LIVE_STS0r
#define WRITELN_RX_X4_PCS_LIVE_STS0r BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_LIVE_STS0r
#define WRITEALL_RX_X4_PCS_LIVE_STS0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_LIVE_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BIPCNT0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc157
 * DESC:     BIP error count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERROR_COUNT_0 CL82 BIP error count for pseudo-logical lane 0.Saturates at 8'hFF. Clear on read.
 *     BIP_ERROR_COUNT_1 CL82 BIP error count for pseudo-logical lane 1.Saturates at 8'hFF. Clear on read.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r (0x0000c157 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BIPCNT0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_s {
	uint32_t v[1];
	uint32_t rx_x4_bipcnt0[1];
	uint32_t _rx_x4_bipcnt0;
} BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_t;

#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_CLR(r) (r).rx_x4_bipcnt0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_SET(r,d) (r).rx_x4_bipcnt0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_GET(r) (r).rx_x4_bipcnt0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_GET(r) ((((r).rx_x4_bipcnt0[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_SET(r,f) (r).rx_x4_bipcnt0[0]=(((r).rx_x4_bipcnt0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_GET(r) (((r).rx_x4_bipcnt0[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_SET(r,f) (r).rx_x4_bipcnt0[0]=(((r).rx_x4_bipcnt0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BIPCNT0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BIPCNT0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT0r,(_r._rx_x4_bipcnt0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BIPCNT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT0r,(_r._rx_x4_bipcnt0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BIPCNT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT0r,(_r._rx_x4_bipcnt0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BIPCNT0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BIPCNT0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BIPCNT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_bipcnt0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BIPCNT0r BCMI_TSCD_XGXS_RX_X4_BIPCNT0r
#define RX_X4_BIPCNT0r_SIZE BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_t RX_X4_BIPCNT0r_t;
#define RX_X4_BIPCNT0r_CLR BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_CLR
#define RX_X4_BIPCNT0r_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_SET
#define RX_X4_BIPCNT0r_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_GET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_GET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_1f_SET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_GET
#define RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT0r_BIP_ERROR_COUNT_0f_SET
#define READ_RX_X4_BIPCNT0r BCMI_TSCD_XGXS_READ_RX_X4_BIPCNT0r
#define WRITE_RX_X4_BIPCNT0r BCMI_TSCD_XGXS_WRITE_RX_X4_BIPCNT0r
#define MODIFY_RX_X4_BIPCNT0r BCMI_TSCD_XGXS_MODIFY_RX_X4_BIPCNT0r
#define READLN_RX_X4_BIPCNT0r BCMI_TSCD_XGXS_READLN_RX_X4_BIPCNT0r
#define WRITELN_RX_X4_BIPCNT0r BCMI_TSCD_XGXS_WRITELN_RX_X4_BIPCNT0r
#define WRITEALL_RX_X4_BIPCNT0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_BIPCNT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BIPCNT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BIPCNT1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc158
 * DESC:     BIP error count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERROR_COUNT_2 CL82 BIP error count for pseudo-logical lane 2.Saturates at 8'hFF. Clear on read.
 *     BIP_ERROR_COUNT_3 CL82 BIP error count for pseudo-logical lane 3.Saturates at 8'hFF. Clear on read.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r (0x0000c158 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BIPCNT1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_s {
	uint32_t v[1];
	uint32_t rx_x4_bipcnt1[1];
	uint32_t _rx_x4_bipcnt1;
} BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_t;

#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_CLR(r) (r).rx_x4_bipcnt1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_SET(r,d) (r).rx_x4_bipcnt1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_GET(r) (r).rx_x4_bipcnt1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_GET(r) ((((r).rx_x4_bipcnt1[0]) >> 8) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_SET(r,f) (r).rx_x4_bipcnt1[0]=(((r).rx_x4_bipcnt1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_GET(r) (((r).rx_x4_bipcnt1[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_SET(r,f) (r).rx_x4_bipcnt1[0]=(((r).rx_x4_bipcnt1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BIPCNT1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BIPCNT1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT1r,(_r._rx_x4_bipcnt1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BIPCNT1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT1r,(_r._rx_x4_bipcnt1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BIPCNT1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT1r,(_r._rx_x4_bipcnt1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BIPCNT1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BIPCNT1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BIPCNT1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_bipcnt1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BIPCNT1r BCMI_TSCD_XGXS_RX_X4_BIPCNT1r
#define RX_X4_BIPCNT1r_SIZE BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_t RX_X4_BIPCNT1r_t;
#define RX_X4_BIPCNT1r_CLR BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_CLR
#define RX_X4_BIPCNT1r_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_SET
#define RX_X4_BIPCNT1r_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_GET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_GET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_3f_SET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_GET
#define RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT1r_BIP_ERROR_COUNT_2f_SET
#define READ_RX_X4_BIPCNT1r BCMI_TSCD_XGXS_READ_RX_X4_BIPCNT1r
#define WRITE_RX_X4_BIPCNT1r BCMI_TSCD_XGXS_WRITE_RX_X4_BIPCNT1r
#define MODIFY_RX_X4_BIPCNT1r BCMI_TSCD_XGXS_MODIFY_RX_X4_BIPCNT1r
#define READLN_RX_X4_BIPCNT1r BCMI_TSCD_XGXS_READLN_RX_X4_BIPCNT1r
#define WRITELN_RX_X4_BIPCNT1r BCMI_TSCD_XGXS_WRITELN_RX_X4_BIPCNT1r
#define WRITEALL_RX_X4_BIPCNT1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_BIPCNT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BIPCNT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_BIPCNT2
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc159
 * DESC:     BIP error count register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BIP_ERROR_COUNT_4 CL82 BIP error count for pseudo-logical lane 4.Saturates at 8'hFF. Clear on read.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT2r (0x0000c159 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_BIPCNT2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_s {
	uint32_t v[1];
	uint32_t rx_x4_bipcnt2[1];
	uint32_t _rx_x4_bipcnt2;
} BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_t;

#define BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_CLR(r) (r).rx_x4_bipcnt2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_SET(r,d) (r).rx_x4_bipcnt2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_GET(r) (r).rx_x4_bipcnt2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_GET(r) (((r).rx_x4_bipcnt2[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_SET(r,f) (r).rx_x4_bipcnt2[0]=(((r).rx_x4_bipcnt2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_BIPCNT2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_BIPCNT2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT2r,(_r._rx_x4_bipcnt2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_BIPCNT2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT2r,(_r._rx_x4_bipcnt2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_BIPCNT2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT2r,(_r._rx_x4_bipcnt2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_BIPCNT2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_BIPCNT2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_bipcnt2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_BIPCNT2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_BIPCNT2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_bipcnt2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_BIPCNT2r BCMI_TSCD_XGXS_RX_X4_BIPCNT2r
#define RX_X4_BIPCNT2r_SIZE BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_t RX_X4_BIPCNT2r_t;
#define RX_X4_BIPCNT2r_CLR BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_CLR
#define RX_X4_BIPCNT2r_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_SET
#define RX_X4_BIPCNT2r_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_GET
#define RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_GET BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_GET
#define RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_SET BCMI_TSCD_XGXS_RX_X4_BIPCNT2r_BIP_ERROR_COUNT_4f_SET
#define READ_RX_X4_BIPCNT2r BCMI_TSCD_XGXS_READ_RX_X4_BIPCNT2r
#define WRITE_RX_X4_BIPCNT2r BCMI_TSCD_XGXS_WRITE_RX_X4_BIPCNT2r
#define MODIFY_RX_X4_BIPCNT2r BCMI_TSCD_XGXS_MODIFY_RX_X4_BIPCNT2r
#define READLN_RX_X4_BIPCNT2r BCMI_TSCD_XGXS_READLN_RX_X4_BIPCNT2r
#define WRITELN_RX_X4_BIPCNT2r BCMI_TSCD_XGXS_WRITELN_RX_X4_BIPCNT2r
#define WRITEALL_RX_X4_BIPCNT2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_BIPCNT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_BIPCNT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PSLL_TO_VL_MAP0
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15a
 * DESC:     Pseudo-logical lane to virtual lane mapping
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PSLL0_TO_VL_MAPPING Pseudo-logical lane 0 to virtual lane mapping.
 *     PSLL1_TO_VL_MAPPING Pseudo-logical lane 1 to virtual lane mapping.
 *     PSLL2_TO_VL_MAPPING Pseudo-logical lane 2 to virtual lane mapping.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r (0x0000c15a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PSLL_TO_VL_MAP0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_s {
	uint32_t v[1];
	uint32_t rx_x4_psll_to_vl_map0[1];
	uint32_t _rx_x4_psll_to_vl_map0;
} BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_t;

#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_CLR(r) (r).rx_x4_psll_to_vl_map0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SET(r,d) (r).rx_x4_psll_to_vl_map0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_GET(r) (r).rx_x4_psll_to_vl_map0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_GET(r) ((((r).rx_x4_psll_to_vl_map0[0]) >> 10) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map0[0]=(((r).rx_x4_psll_to_vl_map0[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_GET(r) ((((r).rx_x4_psll_to_vl_map0[0]) >> 5) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map0[0]=(((r).rx_x4_psll_to_vl_map0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_GET(r) (((r).rx_x4_psll_to_vl_map0[0]) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map0[0]=(((r).rx_x4_psll_to_vl_map0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_PSLL_TO_VL_MAP0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r,(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r,(_r._rx_x4_psll_to_vl_map0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r,(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_psll_to_vl_map0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r
#define RX_X4_PSLL_TO_VL_MAP0r_SIZE BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_t RX_X4_PSLL_TO_VL_MAP0r_t;
#define RX_X4_PSLL_TO_VL_MAP0r_CLR BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_CLR
#define RX_X4_PSLL_TO_VL_MAP0r_SET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_SET
#define RX_X4_PSLL_TO_VL_MAP0r_GET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_GET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_SET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL2_TO_VL_MAPPINGf_SET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_GET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_SET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL1_TO_VL_MAPPINGf_SET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_GET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_SET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r_PSLL0_TO_VL_MAPPINGf_SET
#define READ_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCD_XGXS_READ_RX_X4_PSLL_TO_VL_MAP0r
#define WRITE_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCD_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP0r
#define MODIFY_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCD_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP0r
#define READLN_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCD_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP0r
#define WRITELN_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCD_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP0r
#define WRITEALL_RX_X4_PSLL_TO_VL_MAP0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PSLL_TO_VL_MAP1
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15b
 * DESC:     Pseudo-logical lane to virtual lane mapping
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PSLL3_TO_VL_MAPPING Pseudo-logical lane 3 to virtual lane mapping.
 *     PSLL4_TO_VL_MAPPING Pseudo-logical lane 4 to virtual lane mapping.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r (0x0000c15b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PSLL_TO_VL_MAP1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_s {
	uint32_t v[1];
	uint32_t rx_x4_psll_to_vl_map1[1];
	uint32_t _rx_x4_psll_to_vl_map1;
} BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_t;

#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_CLR(r) (r).rx_x4_psll_to_vl_map1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SET(r,d) (r).rx_x4_psll_to_vl_map1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_GET(r) (r).rx_x4_psll_to_vl_map1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_GET(r) ((((r).rx_x4_psll_to_vl_map1[0]) >> 5) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map1[0]=(((r).rx_x4_psll_to_vl_map1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_GET(r) (((r).rx_x4_psll_to_vl_map1[0]) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_SET(r,f) (r).rx_x4_psll_to_vl_map1[0]=(((r).rx_x4_psll_to_vl_map1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_PSLL_TO_VL_MAP1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r,(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r,(_r._rx_x4_psll_to_vl_map1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r,(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_psll_to_vl_map1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_psll_to_vl_map1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r
#define RX_X4_PSLL_TO_VL_MAP1r_SIZE BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_t RX_X4_PSLL_TO_VL_MAP1r_t;
#define RX_X4_PSLL_TO_VL_MAP1r_CLR BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_CLR
#define RX_X4_PSLL_TO_VL_MAP1r_SET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_SET
#define RX_X4_PSLL_TO_VL_MAP1r_GET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_GET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_GET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_SET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL4_TO_VL_MAPPINGf_SET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_GET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_GET
#define RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_SET BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r_PSLL3_TO_VL_MAPPINGf_SET
#define READ_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCD_XGXS_READ_RX_X4_PSLL_TO_VL_MAP1r
#define WRITE_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCD_XGXS_WRITE_RX_X4_PSLL_TO_VL_MAP1r
#define MODIFY_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCD_XGXS_MODIFY_RX_X4_PSLL_TO_VL_MAP1r
#define READLN_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCD_XGXS_READLN_RX_X4_PSLL_TO_VL_MAP1r
#define WRITELN_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCD_XGXS_WRITELN_RX_X4_PSLL_TO_VL_MAP1r
#define WRITEALL_RX_X4_PSLL_TO_VL_MAP1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_PSLL_TO_VL_MAP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PSLL_TO_VL_MAP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PRTPERRCTR
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15c
 * DESC:     PRTP Error Count Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRTP_ERR_COUNT   Pseudo Random Test Pattern block error count
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr (0x0000c15c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PRTPERRCTR.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_s {
	uint32_t v[1];
	uint32_t rx_x4_prtperrctr[1];
	uint32_t _rx_x4_prtperrctr;
} BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_t;

#define BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_CLR(r) (r).rx_x4_prtperrctr[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_SET(r,d) (r).rx_x4_prtperrctr[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_GET(r) (r).rx_x4_prtperrctr[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_GET(r) (((r).rx_x4_prtperrctr[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_SET(r,f) (r).rx_x4_prtperrctr[0]=(((r).rx_x4_prtperrctr[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_PRTPERRCTR.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr,(_r._rx_x4_prtperrctr))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr,(_r._rx_x4_prtperrctr)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr,(_r._rx_x4_prtperrctr))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PRTPERRCTRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtperrctr))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PRTPERRCTRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtperrctr))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PRTPERRCTRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_prtperrctr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PRTPERRCTRr BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr
#define RX_X4_PRTPERRCTRr_SIZE BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_t RX_X4_PRTPERRCTRr_t;
#define RX_X4_PRTPERRCTRr_CLR BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_CLR
#define RX_X4_PRTPERRCTRr_SET BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_SET
#define RX_X4_PRTPERRCTRr_GET BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_GET
#define RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_GET BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_GET
#define RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_SET BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr_PRTP_ERR_COUNTf_SET
#define READ_RX_X4_PRTPERRCTRr BCMI_TSCD_XGXS_READ_RX_X4_PRTPERRCTRr
#define WRITE_RX_X4_PRTPERRCTRr BCMI_TSCD_XGXS_WRITE_RX_X4_PRTPERRCTRr
#define MODIFY_RX_X4_PRTPERRCTRr BCMI_TSCD_XGXS_MODIFY_RX_X4_PRTPERRCTRr
#define READLN_RX_X4_PRTPERRCTRr BCMI_TSCD_XGXS_READLN_RX_X4_PRTPERRCTRr
#define WRITELN_RX_X4_PRTPERRCTRr BCMI_TSCD_XGXS_WRITELN_RX_X4_PRTPERRCTRr
#define WRITEALL_RX_X4_PRTPERRCTRr BCMI_TSCD_XGXS_WRITEALL_RX_X4_PRTPERRCTRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PRTPERRCTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PRTPSTS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15d
 * DESC:     PRTP Status Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRTP_LOCK        Pseudo Random Test Pattern (PRTP) is locked
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PRTPSTSr (0x0000c15d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PRTPSTS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_s {
	uint32_t v[1];
	uint32_t rx_x4_prtpsts[1];
	uint32_t _rx_x4_prtpsts;
} BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_t;

#define BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_CLR(r) (r).rx_x4_prtpsts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_SET(r,d) (r).rx_x4_prtpsts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_GET(r) (r).rx_x4_prtpsts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_GET(r) (((r).rx_x4_prtpsts[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_SET(r,f) (r).rx_x4_prtpsts[0]=(((r).rx_x4_prtpsts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PRTPSTS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PRTPSTSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPSTSr,(_r._rx_x4_prtpsts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PRTPSTSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPSTSr,(_r._rx_x4_prtpsts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PRTPSTSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPSTSr,(_r._rx_x4_prtpsts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PRTPSTSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPSTSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtpsts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PRTPSTSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPSTSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_prtpsts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PRTPSTSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PRTPSTSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_prtpsts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PRTPSTSr BCMI_TSCD_XGXS_RX_X4_PRTPSTSr
#define RX_X4_PRTPSTSr_SIZE BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_t RX_X4_PRTPSTSr_t;
#define RX_X4_PRTPSTSr_CLR BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_CLR
#define RX_X4_PRTPSTSr_SET BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_SET
#define RX_X4_PRTPSTSr_GET BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_GET
#define RX_X4_PRTPSTSr_PRTP_LOCKf_GET BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_GET
#define RX_X4_PRTPSTSr_PRTP_LOCKf_SET BCMI_TSCD_XGXS_RX_X4_PRTPSTSr_PRTP_LOCKf_SET
#define READ_RX_X4_PRTPSTSr BCMI_TSCD_XGXS_READ_RX_X4_PRTPSTSr
#define WRITE_RX_X4_PRTPSTSr BCMI_TSCD_XGXS_WRITE_RX_X4_PRTPSTSr
#define MODIFY_RX_X4_PRTPSTSr BCMI_TSCD_XGXS_MODIFY_RX_X4_PRTPSTSr
#define READLN_RX_X4_PRTPSTSr BCMI_TSCD_XGXS_READLN_RX_X4_PRTPSTSr
#define WRITELN_RX_X4_PRTPSTSr BCMI_TSCD_XGXS_WRITELN_RX_X4_PRTPSTSr
#define WRITEALL_RX_X4_PRTPSTSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_PRTPSTSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PRTPSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FC_STS
 * BLOCKS:   RX_X4_STATUS0
 * REGADDR:  0xc15e
 * DESC:     CL91 Fiber Channel Status Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FC_SYNC_LIVE_STATE Not valid for D5 TSCD: CL91 Fiber Channel alignment lock FSM state
 *     CL91_FC_SYNC_LATCHED_STATE Not valid for D5 TSCD: CL91 Fiber Channel alignment lock FSM state
 *     CL91_FC_CW_SYNC_LIVE CL91 Fiber Channel sync state live
 *     CL91_FC_CW_SYNC_LL CL91 Fiber Channel sync state latched low
 *     CL91_FC_CW_SYNC_LH CL91 Fiber Channel sync state latched high
 *     CL91_FC_CW_GOOD_CNT CL91 Fiber Channel align lock FSM good codeword count.
 *     CL91_FC_CW_BAD_CNT CL91 Fiber Channel align lock FSM bad codeword count.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr (0x0000c15e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FC_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fc_sts[1];
	uint32_t _rx_x4_cl91_fc_sts;
} BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CLR(r) (r).rx_x4_cl91_fc_sts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_SET(r,d) (r).rx_x4_cl91_fc_sts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_GET(r) (r).rx_x4_cl91_fc_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_BAD_CNTf_GET(r) ((((r).rx_x4_cl91_fc_sts[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_BAD_CNTf_SET(r,f) (r).rx_x4_cl91_fc_sts[0]=(((r).rx_x4_cl91_fc_sts[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_GOOD_CNTf_GET(r) ((((r).rx_x4_cl91_fc_sts[0]) >> 9) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_GOOD_CNTf_SET(r,f) (r).rx_x4_cl91_fc_sts[0]=(((r).rx_x4_cl91_fc_sts[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LHf_GET(r) ((((r).rx_x4_cl91_fc_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LHf_SET(r,f) (r).rx_x4_cl91_fc_sts[0]=(((r).rx_x4_cl91_fc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LLf_GET(r) ((((r).rx_x4_cl91_fc_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LLf_SET(r,f) (r).rx_x4_cl91_fc_sts[0]=(((r).rx_x4_cl91_fc_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LIVEf_GET(r) ((((r).rx_x4_cl91_fc_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LIVEf_SET(r,f) (r).rx_x4_cl91_fc_sts[0]=(((r).rx_x4_cl91_fc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LATCHED_STATEf_GET(r) ((((r).rx_x4_cl91_fc_sts[0]) >> 2) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LATCHED_STATEf_SET(r,f) (r).rx_x4_cl91_fc_sts[0]=(((r).rx_x4_cl91_fc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LIVE_STATEf_GET(r) (((r).rx_x4_cl91_fc_sts[0]) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LIVE_STATEf_SET(r,f) (r).rx_x4_cl91_fc_sts[0]=(((r).rx_x4_cl91_fc_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X4_CL91_FC_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FC_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr,(_r._rx_x4_cl91_fc_sts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr,(_r._rx_x4_cl91_fc_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr,(_r._rx_x4_cl91_fc_sts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FC_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fc_sts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FC_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fc_sts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fc_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FC_STSr BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr
#define RX_X4_CL91_FC_STSr_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_t RX_X4_CL91_FC_STSr_t;
#define RX_X4_CL91_FC_STSr_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CLR
#define RX_X4_CL91_FC_STSr_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_SET
#define RX_X4_CL91_FC_STSr_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_BAD_CNTf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_BAD_CNTf_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_BAD_CNTf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_BAD_CNTf_SET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_GOOD_CNTf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_GOOD_CNTf_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_GOOD_CNTf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_GOOD_CNTf_SET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LHf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LHf_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LHf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LHf_SET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LLf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LLf_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LLf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LLf_SET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LIVEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LIVEf_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LIVEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_CW_SYNC_LIVEf_SET
#define RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LATCHED_STATEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LATCHED_STATEf_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LATCHED_STATEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LATCHED_STATEf_SET
#define RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LIVE_STATEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LIVE_STATEf_GET
#define RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LIVE_STATEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr_CL91_FC_SYNC_LIVE_STATEf_SET
#define READ_RX_X4_CL91_FC_STSr BCMI_TSCD_XGXS_READ_RX_X4_CL91_FC_STSr
#define WRITE_RX_X4_CL91_FC_STSr BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FC_STSr
#define MODIFY_RX_X4_CL91_FC_STSr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FC_STSr
#define READLN_RX_X4_CL91_FC_STSr BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FC_STSr
#define WRITELN_RX_X4_CL91_FC_STSr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FC_STSr
#define WRITEALL_RX_X4_CL91_FC_STSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FC_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PCS_LATCH_STS1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc160
 * DESC:     Latched status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DESKEW_STATUS_LL Deskew status has transitioned low since last read.Deskew achieved (1), Deskew not achieved (0)Clear on read
 *     DESKEW_STATUS_LH Deskew status has transitioned high since last read.Deskew achieved (1), Deskew not achieved (0)Clear on read
 *     LINK_STATUS_LL   PER PORT: Link Status indicator has transitioned low since last readClear on read
 *     LINK_STATUS_LH   PER PORT: Link Status indicator has transitioned high since last readClear on read
 *     HI_BER_LL        HI_BER has transitioned low since last read.Clear on read
 *     HI_BER_LH        HI_BER has transitioned high since last read.Clear on read
 *     LPI_RECEIVED_LH  PER PORT: Low Power Indicator (LPI) has transitioned high since last read.Clear on read
 *     LINK_INTERRUPT_LH PER PORT: Link Interrupt (LI)  has transitioned high since last read.Clear on read
 *     REMOTE_FAULT_LH  PER PORT: Remote Fault (RF)  has transitioned high since last read.Clear on read
 *     LOCAL_FAULT_LH   PER PORT: Local Fault (LF) indicator has transitioned high since last read.Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r (0x0000c160 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LATCH_STS1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_latch_sts1[1];
	uint32_t _rx_x4_pcs_latch_sts1;
} BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_t;

#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_CLR(r) (r).rx_x4_pcs_latch_sts1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_SET(r,d) (r).rx_x4_pcs_latch_sts1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_GET(r) (r).rx_x4_pcs_latch_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_GET(r) ((((r).rx_x4_pcs_latch_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_GET(r) (((r).rx_x4_pcs_latch_sts1[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_SET(r,f) (r).rx_x4_pcs_latch_sts1[0]=(((r).rx_x4_pcs_latch_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PCS_LATCH_STS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r,(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PCS_LATCH_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_LATCH_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_latch_sts1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_latch_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LATCH_STS1r BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r
#define RX_X4_PCS_LATCH_STS1r_SIZE BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_t RX_X4_PCS_LATCH_STS1r_t;
#define RX_X4_PCS_LATCH_STS1r_CLR BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_CLR
#define RX_X4_PCS_LATCH_STS1r_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_SET
#define RX_X4_PCS_LATCH_STS1r_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_GET
#define RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LOCAL_FAULT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_REMOTE_FAULT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_INTERRUPT_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LPI_RECEIVED_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_GET
#define RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_HI_BER_LLf_SET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_GET
#define RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_LINK_STATUS_LLf_SET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_GET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LHf_SET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_GET
#define RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r_DESKEW_STATUS_LLf_SET
#define READ_RX_X4_PCS_LATCH_STS1r BCMI_TSCD_XGXS_READ_RX_X4_PCS_LATCH_STS1r
#define WRITE_RX_X4_PCS_LATCH_STS1r BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_LATCH_STS1r
#define MODIFY_RX_X4_PCS_LATCH_STS1r BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_LATCH_STS1r
#define READLN_RX_X4_PCS_LATCH_STS1r BCMI_TSCD_XGXS_READLN_RX_X4_PCS_LATCH_STS1r
#define WRITELN_RX_X4_PCS_LATCH_STS1r BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_LATCH_STS1r
#define WRITEALL_RX_X4_PCS_LATCH_STS1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_LATCH_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PCS_LATCH_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_PCS_LIVE_STS1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc161
 * DESC:     LiveLatched status of PCS Information
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DESKEW_STATUS    Deskew achieved (1), Deskew not achieved (0)
 *     LINK_STATUS      PER PORT: Live Link Status indicator
 *     HI_BER           HI_BER indicator
 *     LPI_RECEIVED     Live LPI indicator
 *     LINK_INTERRUPT   Live link interrupt indicator
 *     REMOTE_FAULT     Live remote fault indicator
 *     LOCAL_FAULT      Live local fault indicator
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r (0x0000c161 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_PCS_LIVE_STS1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_pcs_live_sts1[1];
	uint32_t _rx_x4_pcs_live_sts1;
} BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_t;

#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_CLR(r) (r).rx_x4_pcs_live_sts1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_SET(r,d) (r).rx_x4_pcs_live_sts1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_GET(r) (r).rx_x4_pcs_live_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LOCAL_FAULTf_GET(r) ((((r).rx_x4_pcs_live_sts1[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LOCAL_FAULTf_SET(r,f) (r).rx_x4_pcs_live_sts1[0]=(((r).rx_x4_pcs_live_sts1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_REMOTE_FAULTf_GET(r) ((((r).rx_x4_pcs_live_sts1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_REMOTE_FAULTf_SET(r,f) (r).rx_x4_pcs_live_sts1[0]=(((r).rx_x4_pcs_live_sts1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_INTERRUPTf_GET(r) ((((r).rx_x4_pcs_live_sts1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_INTERRUPTf_SET(r,f) (r).rx_x4_pcs_live_sts1[0]=(((r).rx_x4_pcs_live_sts1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LPI_RECEIVEDf_GET(r) ((((r).rx_x4_pcs_live_sts1[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LPI_RECEIVEDf_SET(r,f) (r).rx_x4_pcs_live_sts1[0]=(((r).rx_x4_pcs_live_sts1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_HI_BERf_GET(r) ((((r).rx_x4_pcs_live_sts1[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_HI_BERf_SET(r,f) (r).rx_x4_pcs_live_sts1[0]=(((r).rx_x4_pcs_live_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_STATUSf_GET(r) ((((r).rx_x4_pcs_live_sts1[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_STATUSf_SET(r,f) (r).rx_x4_pcs_live_sts1[0]=(((r).rx_x4_pcs_live_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_DESKEW_STATUSf_GET(r) (((r).rx_x4_pcs_live_sts1[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_DESKEW_STATUSf_SET(r,f) (r).rx_x4_pcs_live_sts1[0]=(((r).rx_x4_pcs_live_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_PCS_LIVE_STS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_PCS_LIVE_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r,(_r._rx_x4_pcs_live_sts1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_LIVE_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r,(_r._rx_x4_pcs_live_sts1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_LIVE_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r,(_r._rx_x4_pcs_live_sts1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_PCS_LIVE_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_live_sts1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_LIVE_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_pcs_live_sts1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_LIVE_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_pcs_live_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_PCS_LIVE_STS1r BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r
#define RX_X4_PCS_LIVE_STS1r_SIZE BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_t RX_X4_PCS_LIVE_STS1r_t;
#define RX_X4_PCS_LIVE_STS1r_CLR BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_CLR
#define RX_X4_PCS_LIVE_STS1r_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_SET
#define RX_X4_PCS_LIVE_STS1r_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_GET
#define RX_X4_PCS_LIVE_STS1r_LOCAL_FAULTf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LOCAL_FAULTf_GET
#define RX_X4_PCS_LIVE_STS1r_LOCAL_FAULTf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LOCAL_FAULTf_SET
#define RX_X4_PCS_LIVE_STS1r_REMOTE_FAULTf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_REMOTE_FAULTf_GET
#define RX_X4_PCS_LIVE_STS1r_REMOTE_FAULTf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_REMOTE_FAULTf_SET
#define RX_X4_PCS_LIVE_STS1r_LINK_INTERRUPTf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_INTERRUPTf_GET
#define RX_X4_PCS_LIVE_STS1r_LINK_INTERRUPTf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_INTERRUPTf_SET
#define RX_X4_PCS_LIVE_STS1r_LPI_RECEIVEDf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LPI_RECEIVEDf_GET
#define RX_X4_PCS_LIVE_STS1r_LPI_RECEIVEDf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LPI_RECEIVEDf_SET
#define RX_X4_PCS_LIVE_STS1r_HI_BERf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_HI_BERf_GET
#define RX_X4_PCS_LIVE_STS1r_HI_BERf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_HI_BERf_SET
#define RX_X4_PCS_LIVE_STS1r_LINK_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_STATUSf_GET
#define RX_X4_PCS_LIVE_STS1r_LINK_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_LINK_STATUSf_SET
#define RX_X4_PCS_LIVE_STS1r_DESKEW_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_DESKEW_STATUSf_GET
#define RX_X4_PCS_LIVE_STS1r_DESKEW_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r_DESKEW_STATUSf_SET
#define READ_RX_X4_PCS_LIVE_STS1r BCMI_TSCD_XGXS_READ_RX_X4_PCS_LIVE_STS1r
#define WRITE_RX_X4_PCS_LIVE_STS1r BCMI_TSCD_XGXS_WRITE_RX_X4_PCS_LIVE_STS1r
#define MODIFY_RX_X4_PCS_LIVE_STS1r BCMI_TSCD_XGXS_MODIFY_RX_X4_PCS_LIVE_STS1r
#define READLN_RX_X4_PCS_LIVE_STS1r BCMI_TSCD_XGXS_READLN_RX_X4_PCS_LIVE_STS1r
#define WRITELN_RX_X4_PCS_LIVE_STS1r BCMI_TSCD_XGXS_WRITELN_RX_X4_PCS_LIVE_STS1r
#define WRITEALL_RX_X4_PCS_LIVE_STS1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_PCS_LIVE_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_PCS_LIVE_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_DEC_STS0
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc162
 * DESC:     decode status 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BERMON_CURRENT_STATE BER Monitor fsm - current state
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS0r (0x0000c162 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts0[1];
	uint32_t _rx_x4_dec_sts0;
} BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_t;

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_CLR(r) (r).rx_x4_dec_sts0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_SET(r,d) (r).rx_x4_dec_sts0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_GET(r) (r).rx_x4_dec_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_BERMON_CURRENT_STATEf_GET(r) (((r).rx_x4_dec_sts0[0]) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_BERMON_CURRENT_STATEf_SET(r,f) (r).rx_x4_dec_sts0[0]=(((r).rx_x4_dec_sts0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS0r,(_r._rx_x4_dec_sts0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS0r,(_r._rx_x4_dec_sts0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS0r,(_r._rx_x4_dec_sts0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS0r BCMI_TSCD_XGXS_RX_X4_DEC_STS0r
#define RX_X4_DEC_STS0r_SIZE BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_t RX_X4_DEC_STS0r_t;
#define RX_X4_DEC_STS0r_CLR BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_CLR
#define RX_X4_DEC_STS0r_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_SET
#define RX_X4_DEC_STS0r_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_GET
#define RX_X4_DEC_STS0r_BERMON_CURRENT_STATEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_BERMON_CURRENT_STATEf_GET
#define RX_X4_DEC_STS0r_BERMON_CURRENT_STATEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS0r_BERMON_CURRENT_STATEf_SET
#define READ_RX_X4_DEC_STS0r BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS0r
#define WRITE_RX_X4_DEC_STS0r BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS0r
#define MODIFY_RX_X4_DEC_STS0r BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS0r
#define READLN_RX_X4_DEC_STS0r BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS0r
#define WRITELN_RX_X4_DEC_STS0r BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS0r
#define WRITEALL_RX_X4_DEC_STS0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_DEC_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_DEC_STS1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc163
 * DESC:     decode status 1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BERMON_HISTORY_STATE BER Monitor fsm - latched states - latched on entry
 *     CL49_RXSM_HISTORY_STATE Receive SM - latched states - latched on entry
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r (0x0000c163 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts1[1];
	uint32_t _rx_x4_dec_sts1;
} BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_t;

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_CLR(r) (r).rx_x4_dec_sts1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_SET(r,d) (r).rx_x4_dec_sts1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_GET(r) (r).rx_x4_dec_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_GET(r) ((((r).rx_x4_dec_sts1[0]) >> 5) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_SET(r,f) (r).rx_x4_dec_sts1[0]=(((r).rx_x4_dec_sts1[0] & ~((uint32_t)0xff << 5)) | ((((uint32_t)f) & 0xff) << 5)) | (255 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_GET(r) (((r).rx_x4_dec_sts1[0]) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_SET(r,f) (r).rx_x4_dec_sts1[0]=(((r).rx_x4_dec_sts1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS1r,(_r._rx_x4_dec_sts1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS1r BCMI_TSCD_XGXS_RX_X4_DEC_STS1r
#define RX_X4_DEC_STS1r_SIZE BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_t RX_X4_DEC_STS1r_t;
#define RX_X4_DEC_STS1r_CLR BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_CLR
#define RX_X4_DEC_STS1r_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_SET
#define RX_X4_DEC_STS1r_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_GET
#define RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_GET
#define RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_CL49_RXSM_HISTORY_STATEf_SET
#define RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_GET
#define RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS1r_BERMON_HISTORY_STATEf_SET
#define READ_RX_X4_DEC_STS1r BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS1r
#define WRITE_RX_X4_DEC_STS1r BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS1r
#define MODIFY_RX_X4_DEC_STS1r BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS1r
#define READLN_RX_X4_DEC_STS1r BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS1r
#define WRITELN_RX_X4_DEC_STS1r BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS1r
#define WRITEALL_RX_X4_DEC_STS1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_DEC_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_DEC_STS2
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc164
 * DESC:     decode status 2 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL49_RXSM_CURRENT_STATE Recieve SM - current state
 *     CL49_R_TYPE_CODED Receive SM - current r_type
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r (0x0000c164 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts2[1];
	uint32_t _rx_x4_dec_sts2;
} BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_t;

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CLR(r) (r).rx_x4_dec_sts2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_SET(r,d) (r).rx_x4_dec_sts2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_GET(r) (r).rx_x4_dec_sts2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_R_TYPE_CODEDf_GET(r) ((((r).rx_x4_dec_sts2[0]) >> 8) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_R_TYPE_CODEDf_SET(r,f) (r).rx_x4_dec_sts2[0]=(((r).rx_x4_dec_sts2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_RXSM_CURRENT_STATEf_GET(r) (((r).rx_x4_dec_sts2[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_RXSM_CURRENT_STATEf_SET(r,f) (r).rx_x4_dec_sts2[0]=(((r).rx_x4_dec_sts2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS2r,(_r._rx_x4_dec_sts2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS2r,(_r._rx_x4_dec_sts2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS2r,(_r._rx_x4_dec_sts2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS2r BCMI_TSCD_XGXS_RX_X4_DEC_STS2r
#define RX_X4_DEC_STS2r_SIZE BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_t RX_X4_DEC_STS2r_t;
#define RX_X4_DEC_STS2r_CLR BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CLR
#define RX_X4_DEC_STS2r_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_SET
#define RX_X4_DEC_STS2r_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_GET
#define RX_X4_DEC_STS2r_CL49_R_TYPE_CODEDf_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_R_TYPE_CODEDf_GET
#define RX_X4_DEC_STS2r_CL49_R_TYPE_CODEDf_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_R_TYPE_CODEDf_SET
#define RX_X4_DEC_STS2r_CL49_RXSM_CURRENT_STATEf_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_RXSM_CURRENT_STATEf_GET
#define RX_X4_DEC_STS2r_CL49_RXSM_CURRENT_STATEf_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS2r_CL49_RXSM_CURRENT_STATEf_SET
#define READ_RX_X4_DEC_STS2r BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS2r
#define WRITE_RX_X4_DEC_STS2r BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS2r
#define MODIFY_RX_X4_DEC_STS2r BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS2r
#define READLN_RX_X4_DEC_STS2r BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS2r
#define WRITELN_RX_X4_DEC_STS2r BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS2r
#define WRITEALL_RX_X4_DEC_STS2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_DEC_STS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_DEC_STS3
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc165
 * DESC:     decode status 3 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     IEEE_ERRORED_BLOCKS Contains the count of the errored blocks decoded by the cl49/cl82 decoders.For cl82, it contains the lower 8 bits of the 22 bit value. The upper 14 bits are present in the cl82_errored_blocks_ho register.
 *     CL49_BER_COUNT   For cl49 - This field is the 6 bit BER count.It counts the number of times BER_BAD_SH state is entered.The counter saturates at 6'h3F and clears on read.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r (0x0000c165 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_DEC_STS3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_s {
	uint32_t v[1];
	uint32_t rx_x4_dec_sts3[1];
	uint32_t _rx_x4_dec_sts3;
} BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_t;

#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_CLR(r) (r).rx_x4_dec_sts3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_SET(r,d) (r).rx_x4_dec_sts3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_GET(r) (r).rx_x4_dec_sts3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_GET(r) ((((r).rx_x4_dec_sts3[0]) >> 8) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_SET(r,f) (r).rx_x4_dec_sts3[0]=(((r).rx_x4_dec_sts3[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_GET(r) (((r).rx_x4_dec_sts3[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_SET(r,f) (r).rx_x4_dec_sts3[0]=(((r).rx_x4_dec_sts3[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_DEC_STS3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS3r,(_r._rx_x4_dec_sts3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_dec_sts3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_DEC_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_dec_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_DEC_STS3r BCMI_TSCD_XGXS_RX_X4_DEC_STS3r
#define RX_X4_DEC_STS3r_SIZE BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_t RX_X4_DEC_STS3r_t;
#define RX_X4_DEC_STS3r_CLR BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_CLR
#define RX_X4_DEC_STS3r_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_SET
#define RX_X4_DEC_STS3r_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_GET
#define RX_X4_DEC_STS3r_CL49_BER_COUNTf_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_GET
#define RX_X4_DEC_STS3r_CL49_BER_COUNTf_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_CL49_BER_COUNTf_SET
#define RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_GET BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_GET
#define RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_SET BCMI_TSCD_XGXS_RX_X4_DEC_STS3r_IEEE_ERRORED_BLOCKSf_SET
#define READ_RX_X4_DEC_STS3r BCMI_TSCD_XGXS_READ_RX_X4_DEC_STS3r
#define WRITE_RX_X4_DEC_STS3r BCMI_TSCD_XGXS_WRITE_RX_X4_DEC_STS3r
#define MODIFY_RX_X4_DEC_STS3r BCMI_TSCD_XGXS_MODIFY_RX_X4_DEC_STS3r
#define READLN_RX_X4_DEC_STS3r BCMI_TSCD_XGXS_READLN_RX_X4_DEC_STS3r
#define WRITELN_RX_X4_DEC_STS3r BCMI_TSCD_XGXS_WRITELN_RX_X4_DEC_STS3r
#define WRITEALL_RX_X4_DEC_STS3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_DEC_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_DEC_STS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL36_SYNCACQ_STS0
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc168
 * DESC:     cl36rx_syncacq_status_0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL36RX_SYNCACQ_STATE_CODED_PER_LN cl36 sync acquisition fsm - next state4'd0 - LOSS_OF_SYNC4'd1 - COMMA_DET_14'd2 - ACQ_SYNC_14'd3 - COMMA_DET_24'd4 - ACQ_SYNC_24'd5 - COMMA_DET_34'd6 - SYNC_ACQ_14'd7 - SYNC_ACQ_24'd8 - SYNC_ACQ_34'd9 - SYNC_ACQ_44'd10 - SYNC_ACQ_2A4'd11 - SYNC_ACQ_3A4'd12 - SYNC_ACQ_4A
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r (0x0000c168 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL36_SYNCACQ_STS0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl36_syncacq_sts0[1];
	uint32_t _rx_x4_cl36_syncacq_sts0;
} BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_CLR(r) (r).rx_x4_cl36_syncacq_sts0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_SET(r,d) (r).rx_x4_cl36_syncacq_sts0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_GET(r) (r).rx_x4_cl36_syncacq_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_CL36RX_SYNCACQ_STATE_CODED_PER_LNf_GET(r) (((r).rx_x4_cl36_syncacq_sts0[0]) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_CL36RX_SYNCACQ_STATE_CODED_PER_LNf_SET(r,f) (r).rx_x4_cl36_syncacq_sts0[0]=(((r).rx_x4_cl36_syncacq_sts0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_CL36_SYNCACQ_STS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL36_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r,(_r._rx_x4_cl36_syncacq_sts0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r,(_r._rx_x4_cl36_syncacq_sts0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r,(_r._rx_x4_cl36_syncacq_sts0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL36_SYNCACQ_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_syncacq_sts0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_SYNCACQ_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_syncacq_sts0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_SYNCACQ_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl36_syncacq_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL36_SYNCACQ_STS0r BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r
#define RX_X4_CL36_SYNCACQ_STS0r_SIZE BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_t RX_X4_CL36_SYNCACQ_STS0r_t;
#define RX_X4_CL36_SYNCACQ_STS0r_CLR BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_CLR
#define RX_X4_CL36_SYNCACQ_STS0r_SET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_SET
#define RX_X4_CL36_SYNCACQ_STS0r_GET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_GET
#define RX_X4_CL36_SYNCACQ_STS0r_CL36RX_SYNCACQ_STATE_CODED_PER_LNf_GET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_CL36RX_SYNCACQ_STATE_CODED_PER_LNf_GET
#define RX_X4_CL36_SYNCACQ_STS0r_CL36RX_SYNCACQ_STATE_CODED_PER_LNf_SET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r_CL36RX_SYNCACQ_STATE_CODED_PER_LNf_SET
#define READ_RX_X4_CL36_SYNCACQ_STS0r BCMI_TSCD_XGXS_READ_RX_X4_CL36_SYNCACQ_STS0r
#define WRITE_RX_X4_CL36_SYNCACQ_STS0r BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_SYNCACQ_STS0r
#define MODIFY_RX_X4_CL36_SYNCACQ_STS0r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_SYNCACQ_STS0r
#define READLN_RX_X4_CL36_SYNCACQ_STS0r BCMI_TSCD_XGXS_READLN_RX_X4_CL36_SYNCACQ_STS0r
#define WRITELN_RX_X4_CL36_SYNCACQ_STS0r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_SYNCACQ_STS0r
#define WRITEALL_RX_X4_CL36_SYNCACQ_STS0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_SYNCACQ_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL36_SYNCACQ_STS1
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc169
 * DESC:     cl36rx_syncacq_status_1 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36RX_SYNCACQ_HIS_STATE_PER_LN bit 0 - LOSS_OF_SYNCbit 1 - COMMA_DET_1bit 2 - ACQ_SYNC_1bit 3 - COMMA_DET_2bit 4 - ACQ_SYNC_2bit 5 - COMMA_DET_3bit 6 - SYNC_ACQ_1bit 7 - SYNC_ACQ_2bit 8 - SYNC_ACQ_3bit 9 - SYNC_ACQ_4bit 10 - SYNC_ACQ_2Abit 11 - SYNC_ACQ_3Abit 12 - SYNC_ACQ_4A
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r (0x0000c169 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL36_SYNCACQ_STS1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl36_syncacq_sts1[1];
	uint32_t _rx_x4_cl36_syncacq_sts1;
} BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_CLR(r) (r).rx_x4_cl36_syncacq_sts1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_SET(r,d) (r).rx_x4_cl36_syncacq_sts1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_GET(r) (r).rx_x4_cl36_syncacq_sts1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_CL36RX_SYNCACQ_HIS_STATE_PER_LNf_GET(r) (((r).rx_x4_cl36_syncacq_sts1[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_CL36RX_SYNCACQ_HIS_STATE_PER_LNf_SET(r,f) (r).rx_x4_cl36_syncacq_sts1[0]=(((r).rx_x4_cl36_syncacq_sts1[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access RX_X4_CL36_SYNCACQ_STS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL36_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r,(_r._rx_x4_cl36_syncacq_sts1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r,(_r._rx_x4_cl36_syncacq_sts1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r,(_r._rx_x4_cl36_syncacq_sts1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL36_SYNCACQ_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_syncacq_sts1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_SYNCACQ_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_syncacq_sts1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_SYNCACQ_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl36_syncacq_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL36_SYNCACQ_STS1r BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r
#define RX_X4_CL36_SYNCACQ_STS1r_SIZE BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_t RX_X4_CL36_SYNCACQ_STS1r_t;
#define RX_X4_CL36_SYNCACQ_STS1r_CLR BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_CLR
#define RX_X4_CL36_SYNCACQ_STS1r_SET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_SET
#define RX_X4_CL36_SYNCACQ_STS1r_GET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_GET
#define RX_X4_CL36_SYNCACQ_STS1r_CL36RX_SYNCACQ_HIS_STATE_PER_LNf_GET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_CL36RX_SYNCACQ_HIS_STATE_PER_LNf_GET
#define RX_X4_CL36_SYNCACQ_STS1r_CL36RX_SYNCACQ_HIS_STATE_PER_LNf_SET BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r_CL36RX_SYNCACQ_HIS_STATE_PER_LNf_SET
#define READ_RX_X4_CL36_SYNCACQ_STS1r BCMI_TSCD_XGXS_READ_RX_X4_CL36_SYNCACQ_STS1r
#define WRITE_RX_X4_CL36_SYNCACQ_STS1r BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_SYNCACQ_STS1r
#define MODIFY_RX_X4_CL36_SYNCACQ_STS1r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_SYNCACQ_STS1r
#define READLN_RX_X4_CL36_SYNCACQ_STS1r BCMI_TSCD_XGXS_READLN_RX_X4_CL36_SYNCACQ_STS1r
#define WRITELN_RX_X4_CL36_SYNCACQ_STS1r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_SYNCACQ_STS1r
#define WRITEALL_RX_X4_CL36_SYNCACQ_STS1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_SYNCACQ_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL36_SYNCACQ_STS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL36_BERCNT
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc16a
 * DESC:     cl36rx_bercount register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL36RX_BER_COUNT_PER_LN For cl36 - This field is the 8b/10b symbol error counter that increments1. upon detecting symbol error (due to invalid symbol or disparity error)2. when comma aligns on the wrong boundaryThe error conditions are detected only when cl36 sync_status is asserted.The counter saturates at 8'hFF and clears on read.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr (0x0000c16a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL36_BERCNT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl36_bercnt[1];
	uint32_t _rx_x4_cl36_bercnt;
} BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_CLR(r) (r).rx_x4_cl36_bercnt[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_SET(r,d) (r).rx_x4_cl36_bercnt[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_GET(r) (r).rx_x4_cl36_bercnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_CL36RX_BER_COUNT_PER_LNf_GET(r) (((r).rx_x4_cl36_bercnt[0]) & 0xff)
#define BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_CL36RX_BER_COUNT_PER_LNf_SET(r,f) (r).rx_x4_cl36_bercnt[0]=(((r).rx_x4_cl36_bercnt[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access RX_X4_CL36_BERCNT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL36_BERCNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr,(_r._rx_x4_cl36_bercnt))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_BERCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr,(_r._rx_x4_cl36_bercnt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_BERCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr,(_r._rx_x4_cl36_bercnt))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL36_BERCNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_bercnt))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_BERCNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl36_bercnt))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_BERCNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl36_bercnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL36_BERCNTr BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr
#define RX_X4_CL36_BERCNTr_SIZE BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_t RX_X4_CL36_BERCNTr_t;
#define RX_X4_CL36_BERCNTr_CLR BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_CLR
#define RX_X4_CL36_BERCNTr_SET BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_SET
#define RX_X4_CL36_BERCNTr_GET BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_GET
#define RX_X4_CL36_BERCNTr_CL36RX_BER_COUNT_PER_LNf_GET BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_CL36RX_BER_COUNT_PER_LNf_GET
#define RX_X4_CL36_BERCNTr_CL36RX_BER_COUNT_PER_LNf_SET BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr_CL36RX_BER_COUNT_PER_LNf_SET
#define READ_RX_X4_CL36_BERCNTr BCMI_TSCD_XGXS_READ_RX_X4_CL36_BERCNTr
#define WRITE_RX_X4_CL36_BERCNTr BCMI_TSCD_XGXS_WRITE_RX_X4_CL36_BERCNTr
#define MODIFY_RX_X4_CL36_BERCNTr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL36_BERCNTr
#define READLN_RX_X4_CL36_BERCNTr BCMI_TSCD_XGXS_READLN_RX_X4_CL36_BERCNTr
#define WRITELN_RX_X4_CL36_BERCNTr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL36_BERCNTr
#define WRITEALL_RX_X4_CL36_BERCNTr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL36_BERCNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL36_BERCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_IEEE_25G_PARLLEL_DET_STS
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc16b
 * DESC:     IEEE and MSA detction FSM live state
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MSA_IEEE_DET_STATE [0] : IEEE mode detection mode[1] : MSA mode detection mode[2] : Resolution is done see resolved bit to see what is resolved.
 *     RESOLVED_25_MODE 00: No resolution (either not enabled or still looking for lock)01: IEEE mode is resolved10: MSA mode is resolved11: Illegal value, It should never achieve this value.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr (0x0000c16b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_IEEE_25G_PARLLEL_DET_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_ieee_25g_parllel_det_sts[1];
	uint32_t _rx_x4_ieee_25g_parllel_det_sts;
} BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_t;

#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_CLR(r) (r).rx_x4_ieee_25g_parllel_det_sts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_SET(r,d) (r).rx_x4_ieee_25g_parllel_det_sts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_GET(r) (r).rx_x4_ieee_25g_parllel_det_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_RESOLVED_25_MODEf_GET(r) ((((r).rx_x4_ieee_25g_parllel_det_sts[0]) >> 3) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_RESOLVED_25_MODEf_SET(r,f) (r).rx_x4_ieee_25g_parllel_det_sts[0]=(((r).rx_x4_ieee_25g_parllel_det_sts[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_MSA_IEEE_DET_STATEf_GET(r) (((r).rx_x4_ieee_25g_parllel_det_sts[0]) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_MSA_IEEE_DET_STATEf_SET(r,f) (r).rx_x4_ieee_25g_parllel_det_sts[0]=(((r).rx_x4_ieee_25g_parllel_det_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_X4_IEEE_25G_PARLLEL_DET_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_IEEE_25G_PARLLEL_DET_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr,(_r._rx_x4_ieee_25g_parllel_det_sts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_IEEE_25G_PARLLEL_DET_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr,(_r._rx_x4_ieee_25g_parllel_det_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_IEEE_25G_PARLLEL_DET_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr,(_r._rx_x4_ieee_25g_parllel_det_sts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_IEEE_25G_PARLLEL_DET_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ieee_25g_parllel_det_sts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_IEEE_25G_PARLLEL_DET_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ieee_25g_parllel_det_sts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_IEEE_25G_PARLLEL_DET_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ieee_25g_parllel_det_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_IEEE_25G_PARLLEL_DET_STSr BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_SIZE BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_t RX_X4_IEEE_25G_PARLLEL_DET_STSr_t;
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_CLR BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_CLR
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_SET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_SET
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_GET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_GET
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_RESOLVED_25_MODEf_GET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_RESOLVED_25_MODEf_GET
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_RESOLVED_25_MODEf_SET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_RESOLVED_25_MODEf_SET
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_MSA_IEEE_DET_STATEf_GET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_MSA_IEEE_DET_STATEf_GET
#define RX_X4_IEEE_25G_PARLLEL_DET_STSr_MSA_IEEE_DET_STATEf_SET BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr_MSA_IEEE_DET_STATEf_SET
#define READ_RX_X4_IEEE_25G_PARLLEL_DET_STSr BCMI_TSCD_XGXS_READ_RX_X4_IEEE_25G_PARLLEL_DET_STSr
#define WRITE_RX_X4_IEEE_25G_PARLLEL_DET_STSr BCMI_TSCD_XGXS_WRITE_RX_X4_IEEE_25G_PARLLEL_DET_STSr
#define MODIFY_RX_X4_IEEE_25G_PARLLEL_DET_STSr BCMI_TSCD_XGXS_MODIFY_RX_X4_IEEE_25G_PARLLEL_DET_STSr
#define READLN_RX_X4_IEEE_25G_PARLLEL_DET_STSr BCMI_TSCD_XGXS_READLN_RX_X4_IEEE_25G_PARLLEL_DET_STSr
#define WRITELN_RX_X4_IEEE_25G_PARLLEL_DET_STSr BCMI_TSCD_XGXS_WRITELN_RX_X4_IEEE_25G_PARLLEL_DET_STSr
#define WRITEALL_RX_X4_IEEE_25G_PARLLEL_DET_STSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_IEEE_25G_PARLLEL_DET_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_IEEE_25G_PARLLEL_DET_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL49_SCRIDLE_TEST_ERR
 * BLOCKS:   RX_X4_STATUS1
 * REGADDR:  0xc16c
 * DESC:     CL49 Scrambled IDLE test Error register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL49_SCRIDLE_TEST_ERR CL49 Scrambled IDLE Test Error counter
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr (0x0000c16c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL49_SCRIDLE_TEST_ERR.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl49_scridle_test_err[1];
	uint32_t _rx_x4_cl49_scridle_test_err;
} BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CLR(r) (r).rx_x4_cl49_scridle_test_err[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SET(r,d) (r).rx_x4_cl49_scridle_test_err[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_GET(r) (r).rx_x4_cl49_scridle_test_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_GET(r) (((r).rx_x4_cl49_scridle_test_err[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_SET(r,f) (r).rx_x4_cl49_scridle_test_err[0]=(((r).rx_x4_cl49_scridle_test_err[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL49_SCRIDLE_TEST_ERR.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr,(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr,(_r._rx_x4_cl49_scridle_test_err)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr,(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl49_scridle_test_err))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL49_SCRIDLE_TEST_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl49_scridle_test_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_SIZE BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_t RX_X4_CL49_SCRIDLE_TEST_ERRr_t;
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_CLR BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CLR
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_SET BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_SET
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_GET BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_GET
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_GET BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_GET
#define RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_SET BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr_CL49_SCRIDLE_TEST_ERRf_SET
#define READ_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_READ_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define WRITE_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_WRITE_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define MODIFY_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define READLN_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_READLN_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define WRITELN_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL49_SCRIDLE_TEST_ERRr
#define WRITEALL_RX_X4_CL49_SCRIDLE_TEST_ERRr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL49_SCRIDLE_TEST_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL49_SCRIDLE_TEST_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL0
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc170
 * DESC:     AM FSM latched status for pseudo-logical lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_0 Alignment marker history states - per logical lane for psll 0clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0 align marker spacing error detected - per logical lane for psll 0clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r (0x0000c170 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll0[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll0;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll0[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll0[0]=(((r).rx_x4_cl82_am_latch_sts_psll0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll0[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll0[0]=(((r).rx_x4_cl82_am_latch_sts_psll0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r,(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r,(_r._rx_x4_cl82_am_latch_sts_psll0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r,(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_t RX_X4_CL82_AM_LATCH_STS_PSLL0r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_0f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r_AM_LOCK_HIS_STATE_PSLL_0f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL0r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL1
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc171
 * DESC:     AM FSM latched status for pseudo-logical lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_1 Alignment marker history states - per logical lane for psll 1clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1 align marker spacing error detected - per logical lane for psll 1clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r (0x0000c171 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll1[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll1;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll1[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll1[0]=(((r).rx_x4_cl82_am_latch_sts_psll1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll1[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll1[0]=(((r).rx_x4_cl82_am_latch_sts_psll1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r,(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r,(_r._rx_x4_cl82_am_latch_sts_psll1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r,(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_t RX_X4_CL82_AM_LATCH_STS_PSLL1r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_1f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r_AM_LOCK_HIS_STATE_PSLL_1f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL1r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL2
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc172
 * DESC:     AM FSM latched status for pseudo-logical lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_2 Alignment marker history states - per logical lane for psll 2clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2 align marker spacing error detected - per logical lane for psll 2clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r (0x0000c172 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll2[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll2;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll2[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll2[0]=(((r).rx_x4_cl82_am_latch_sts_psll2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll2[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll2[0]=(((r).rx_x4_cl82_am_latch_sts_psll2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r,(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r,(_r._rx_x4_cl82_am_latch_sts_psll2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r,(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_t RX_X4_CL82_AM_LATCH_STS_PSLL2r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_2f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r_AM_LOCK_HIS_STATE_PSLL_2f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL2r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL3
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc173
 * DESC:     AM FSM latched status for pseudo-logical lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_3 Alignment marker history states - per logical lane for psll 3clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3 align marker spacing error detected - per logical lane for psll 3clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r (0x0000c173 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll3[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll3;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll3[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll3[0]=(((r).rx_x4_cl82_am_latch_sts_psll3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll3[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll3[0]=(((r).rx_x4_cl82_am_latch_sts_psll3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r,(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r,(_r._rx_x4_cl82_am_latch_sts_psll3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r,(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_t RX_X4_CL82_AM_LATCH_STS_PSLL3r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_3f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r_AM_LOCK_HIS_STATE_PSLL_3f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL3r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LATCH_STS_PSLL4
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc174
 * DESC:     AM FSM latched status for pseudo-logical lane 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AM_LOCK_HIS_STATE_PSLL_4 Alignment marker history states - per logical lane for psll 4clear on read
 *     AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4 align marker spacing error detected - per logical lane for psll 4clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r (0x0000c174 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LATCH_STS_PSLL4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_latch_sts_psll4[1];
	uint32_t _rx_x4_cl82_am_latch_sts_psll4;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_CLR(r) (r).rx_x4_cl82_am_latch_sts_psll4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SET(r,d) (r).rx_x4_cl82_am_latch_sts_psll4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_GET(r) (r).rx_x4_cl82_am_latch_sts_psll4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_GET(r) ((((r).rx_x4_cl82_am_latch_sts_psll4[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll4[0]=(((r).rx_x4_cl82_am_latch_sts_psll4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_GET(r) (((r).rx_x4_cl82_am_latch_sts_psll4[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_SET(r,f) (r).rx_x4_cl82_am_latch_sts_psll4[0]=(((r).rx_x4_cl82_am_latch_sts_psll4[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LATCH_STS_PSLL4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r,(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r,(_r._rx_x4_cl82_am_latch_sts_psll4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r,(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_latch_sts_psll4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_latch_sts_psll4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_t RX_X4_CL82_AM_LATCH_STS_PSLL4r_t;
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_CLR
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AMRKR_SPACING_ERR_LATCH_MUX_PSLL_4f_SET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_GET
#define RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r_AM_LOCK_HIS_STATE_PSLL_4f_SET
#define READ_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define READLN_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LATCH_STS_PSLL4r
#define WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LATCH_STS_PSLL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LATCH_STS_PSLL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LIVE_STS_PSLL0
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc175
 * DESC:     AM FSM live status for pseudo-logical lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_LOCK_STATE_PSLL_0 Alignment marker current states - per logical lane for psll 0
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r (0x0000c175 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LIVE_STS_PSLL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_live_sts_psll0[1];
	uint32_t _rx_x4_cl82_am_live_sts_psll0;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_CLR(r) (r).rx_x4_cl82_am_live_sts_psll0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_SET(r,d) (r).rx_x4_cl82_am_live_sts_psll0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_GET(r) (r).rx_x4_cl82_am_live_sts_psll0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_AM_LOCK_STATE_PSLL_0f_GET(r) (((r).rx_x4_cl82_am_live_sts_psll0[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_AM_LOCK_STATE_PSLL_0f_SET(r,f) (r).rx_x4_cl82_am_live_sts_psll0[0]=(((r).rx_x4_cl82_am_live_sts_psll0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LIVE_STS_PSLL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r,(_r._rx_x4_cl82_am_live_sts_psll0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r,(_r._rx_x4_cl82_am_live_sts_psll0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r,(_r._rx_x4_cl82_am_live_sts_psll0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_live_sts_psll0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LIVE_STS_PSLL0r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r
#define RX_X4_CL82_AM_LIVE_STS_PSLL0r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_t RX_X4_CL82_AM_LIVE_STS_PSLL0r_t;
#define RX_X4_CL82_AM_LIVE_STS_PSLL0r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_CLR
#define RX_X4_CL82_AM_LIVE_STS_PSLL0r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_SET
#define RX_X4_CL82_AM_LIVE_STS_PSLL0r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL0r_AM_LOCK_STATE_PSLL_0f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_AM_LOCK_STATE_PSLL_0f_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL0r_AM_LOCK_STATE_PSLL_0f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r_AM_LOCK_STATE_PSLL_0f_SET
#define READ_RX_X4_CL82_AM_LIVE_STS_PSLL0r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL0r
#define WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL0r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL0r
#define MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL0r
#define READLN_RX_X4_CL82_AM_LIVE_STS_PSLL0r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL0r
#define WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL0r
#define WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LIVE_STS_PSLL1
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc176
 * DESC:     AM FSM live status for pseudo-logical lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_LOCK_STATE_PSLL_1 Alignment marker current states - per logical lane for psll 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r (0x0000c176 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LIVE_STS_PSLL1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_live_sts_psll1[1];
	uint32_t _rx_x4_cl82_am_live_sts_psll1;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_CLR(r) (r).rx_x4_cl82_am_live_sts_psll1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_SET(r,d) (r).rx_x4_cl82_am_live_sts_psll1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_GET(r) (r).rx_x4_cl82_am_live_sts_psll1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_AM_LOCK_STATE_PSLL_1f_GET(r) (((r).rx_x4_cl82_am_live_sts_psll1[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_AM_LOCK_STATE_PSLL_1f_SET(r,f) (r).rx_x4_cl82_am_live_sts_psll1[0]=(((r).rx_x4_cl82_am_live_sts_psll1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LIVE_STS_PSLL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r,(_r._rx_x4_cl82_am_live_sts_psll1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r,(_r._rx_x4_cl82_am_live_sts_psll1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r,(_r._rx_x4_cl82_am_live_sts_psll1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_live_sts_psll1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LIVE_STS_PSLL1r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r
#define RX_X4_CL82_AM_LIVE_STS_PSLL1r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_t RX_X4_CL82_AM_LIVE_STS_PSLL1r_t;
#define RX_X4_CL82_AM_LIVE_STS_PSLL1r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_CLR
#define RX_X4_CL82_AM_LIVE_STS_PSLL1r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_SET
#define RX_X4_CL82_AM_LIVE_STS_PSLL1r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL1r_AM_LOCK_STATE_PSLL_1f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_AM_LOCK_STATE_PSLL_1f_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL1r_AM_LOCK_STATE_PSLL_1f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r_AM_LOCK_STATE_PSLL_1f_SET
#define READ_RX_X4_CL82_AM_LIVE_STS_PSLL1r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL1r
#define WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL1r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL1r
#define MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL1r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL1r
#define READLN_RX_X4_CL82_AM_LIVE_STS_PSLL1r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL1r
#define WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL1r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL1r
#define WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LIVE_STS_PSLL2
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc177
 * DESC:     AM FSM live status for pseudo-logical lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_LOCK_STATE_PSLL_2 Alignment marker current states - per logical lane for psll 2
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r (0x0000c177 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LIVE_STS_PSLL2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_live_sts_psll2[1];
	uint32_t _rx_x4_cl82_am_live_sts_psll2;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_CLR(r) (r).rx_x4_cl82_am_live_sts_psll2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_SET(r,d) (r).rx_x4_cl82_am_live_sts_psll2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_GET(r) (r).rx_x4_cl82_am_live_sts_psll2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_AM_LOCK_STATE_PSLL_2f_GET(r) (((r).rx_x4_cl82_am_live_sts_psll2[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_AM_LOCK_STATE_PSLL_2f_SET(r,f) (r).rx_x4_cl82_am_live_sts_psll2[0]=(((r).rx_x4_cl82_am_live_sts_psll2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LIVE_STS_PSLL2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r,(_r._rx_x4_cl82_am_live_sts_psll2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r,(_r._rx_x4_cl82_am_live_sts_psll2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r,(_r._rx_x4_cl82_am_live_sts_psll2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_live_sts_psll2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LIVE_STS_PSLL2r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r
#define RX_X4_CL82_AM_LIVE_STS_PSLL2r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_t RX_X4_CL82_AM_LIVE_STS_PSLL2r_t;
#define RX_X4_CL82_AM_LIVE_STS_PSLL2r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_CLR
#define RX_X4_CL82_AM_LIVE_STS_PSLL2r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_SET
#define RX_X4_CL82_AM_LIVE_STS_PSLL2r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL2r_AM_LOCK_STATE_PSLL_2f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_AM_LOCK_STATE_PSLL_2f_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL2r_AM_LOCK_STATE_PSLL_2f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r_AM_LOCK_STATE_PSLL_2f_SET
#define READ_RX_X4_CL82_AM_LIVE_STS_PSLL2r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL2r
#define WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL2r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL2r
#define MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL2r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL2r
#define READLN_RX_X4_CL82_AM_LIVE_STS_PSLL2r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL2r
#define WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL2r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL2r
#define WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LIVE_STS_PSLL3
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc178
 * DESC:     AM FSM live status for pseudo-logical lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_LOCK_STATE_PSLL_3 Alignment marker current states - per logical lane for psll 3
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r (0x0000c178 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LIVE_STS_PSLL3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_live_sts_psll3[1];
	uint32_t _rx_x4_cl82_am_live_sts_psll3;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_CLR(r) (r).rx_x4_cl82_am_live_sts_psll3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_SET(r,d) (r).rx_x4_cl82_am_live_sts_psll3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_GET(r) (r).rx_x4_cl82_am_live_sts_psll3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_AM_LOCK_STATE_PSLL_3f_GET(r) (((r).rx_x4_cl82_am_live_sts_psll3[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_AM_LOCK_STATE_PSLL_3f_SET(r,f) (r).rx_x4_cl82_am_live_sts_psll3[0]=(((r).rx_x4_cl82_am_live_sts_psll3[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LIVE_STS_PSLL3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r,(_r._rx_x4_cl82_am_live_sts_psll3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r,(_r._rx_x4_cl82_am_live_sts_psll3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r,(_r._rx_x4_cl82_am_live_sts_psll3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_live_sts_psll3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LIVE_STS_PSLL3r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r
#define RX_X4_CL82_AM_LIVE_STS_PSLL3r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_t RX_X4_CL82_AM_LIVE_STS_PSLL3r_t;
#define RX_X4_CL82_AM_LIVE_STS_PSLL3r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_CLR
#define RX_X4_CL82_AM_LIVE_STS_PSLL3r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_SET
#define RX_X4_CL82_AM_LIVE_STS_PSLL3r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL3r_AM_LOCK_STATE_PSLL_3f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_AM_LOCK_STATE_PSLL_3f_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL3r_AM_LOCK_STATE_PSLL_3f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r_AM_LOCK_STATE_PSLL_3f_SET
#define READ_RX_X4_CL82_AM_LIVE_STS_PSLL3r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL3r
#define WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL3r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL3r
#define MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL3r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL3r
#define READLN_RX_X4_CL82_AM_LIVE_STS_PSLL3r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL3r
#define WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL3r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL3r
#define WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL82_AM_LIVE_STS_PSLL4
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc179
 * DESC:     AM FSM live status for pseudo-logical lane 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_LOCK_STATE_PSLL_4 Alignment marker current states - per logical lane for psll 4
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r (0x0000c179 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL82_AM_LIVE_STS_PSLL4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl82_am_live_sts_psll4[1];
	uint32_t _rx_x4_cl82_am_live_sts_psll4;
} BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_CLR(r) (r).rx_x4_cl82_am_live_sts_psll4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_SET(r,d) (r).rx_x4_cl82_am_live_sts_psll4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_GET(r) (r).rx_x4_cl82_am_live_sts_psll4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_AM_LOCK_STATE_PSLL_4f_GET(r) (((r).rx_x4_cl82_am_live_sts_psll4[0]) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_AM_LOCK_STATE_PSLL_4f_SET(r,f) (r).rx_x4_cl82_am_live_sts_psll4[0]=(((r).rx_x4_cl82_am_live_sts_psll4[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access RX_X4_CL82_AM_LIVE_STS_PSLL4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r,(_r._rx_x4_cl82_am_live_sts_psll4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r,(_r._rx_x4_cl82_am_live_sts_psll4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r,(_r._rx_x4_cl82_am_live_sts_psll4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl82_am_live_sts_psll4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl82_am_live_sts_psll4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL82_AM_LIVE_STS_PSLL4r BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r
#define RX_X4_CL82_AM_LIVE_STS_PSLL4r_SIZE BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_t RX_X4_CL82_AM_LIVE_STS_PSLL4r_t;
#define RX_X4_CL82_AM_LIVE_STS_PSLL4r_CLR BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_CLR
#define RX_X4_CL82_AM_LIVE_STS_PSLL4r_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_SET
#define RX_X4_CL82_AM_LIVE_STS_PSLL4r_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL4r_AM_LOCK_STATE_PSLL_4f_GET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_AM_LOCK_STATE_PSLL_4f_GET
#define RX_X4_CL82_AM_LIVE_STS_PSLL4r_AM_LOCK_STATE_PSLL_4f_SET BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r_AM_LOCK_STATE_PSLL_4f_SET
#define READ_RX_X4_CL82_AM_LIVE_STS_PSLL4r BCMI_TSCD_XGXS_READ_RX_X4_CL82_AM_LIVE_STS_PSLL4r
#define WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL4r BCMI_TSCD_XGXS_WRITE_RX_X4_CL82_AM_LIVE_STS_PSLL4r
#define MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL4r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL82_AM_LIVE_STS_PSLL4r
#define READLN_RX_X4_CL82_AM_LIVE_STS_PSLL4r BCMI_TSCD_XGXS_READLN_RX_X4_CL82_AM_LIVE_STS_PSLL4r
#define WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL4r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL82_AM_LIVE_STS_PSLL4r
#define WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL82_AM_LIVE_STS_PSLL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL82_AM_LIVE_STS_PSLL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_SYNC_STS
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc17a
 * DESC:     CL91 RXP per lane statuses
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_AMPS_LOCK_LIVE Boolean variable that is set when the receiver has detected the location of the alignment marker payload sequence for a given logical lane.
 *     CL91_AMPS_LOCK_LL Latched low version of cl91_amps_lock_live.
 *     CL91_AMPS_LOCK_LH Latched high version of cl91_amps_lock_live.
 *     CL91_FEC_LANE_MAP FEC lane ID per logical lane
 *     CL91_FEC_LANE_MAP_VALID Indicates that the FEC lane ID for the given logical lane is valid.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr (0x0000c17a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_SYNC_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_sync_sts[1];
	uint32_t _rx_x4_cl91_sync_sts;
} BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CLR(r) (r).rx_x4_cl91_sync_sts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_SET(r,d) (r).rx_x4_cl91_sync_sts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_GET(r) (r).rx_x4_cl91_sync_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAP_VALIDf_GET(r) ((((r).rx_x4_cl91_sync_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAP_VALIDf_SET(r,f) (r).rx_x4_cl91_sync_sts[0]=(((r).rx_x4_cl91_sync_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAPf_GET(r) ((((r).rx_x4_cl91_sync_sts[0]) >> 3) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAPf_SET(r,f) (r).rx_x4_cl91_sync_sts[0]=(((r).rx_x4_cl91_sync_sts[0] & ~((uint32_t)0x3 << 3)) | ((((uint32_t)f) & 0x3) << 3)) | (3 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LHf_GET(r) ((((r).rx_x4_cl91_sync_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LHf_SET(r,f) (r).rx_x4_cl91_sync_sts[0]=(((r).rx_x4_cl91_sync_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LLf_GET(r) ((((r).rx_x4_cl91_sync_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LLf_SET(r,f) (r).rx_x4_cl91_sync_sts[0]=(((r).rx_x4_cl91_sync_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LIVEf_GET(r) (((r).rx_x4_cl91_sync_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LIVEf_SET(r,f) (r).rx_x4_cl91_sync_sts[0]=(((r).rx_x4_cl91_sync_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_CL91_SYNC_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_SYNC_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr,(_r._rx_x4_cl91_sync_sts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_SYNC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr,(_r._rx_x4_cl91_sync_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_SYNC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr,(_r._rx_x4_cl91_sync_sts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_SYNC_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_sync_sts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_SYNC_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_sync_sts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_SYNC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_sync_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_SYNC_STSr BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr
#define RX_X4_CL91_SYNC_STSr_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_t RX_X4_CL91_SYNC_STSr_t;
#define RX_X4_CL91_SYNC_STSr_CLR BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CLR
#define RX_X4_CL91_SYNC_STSr_SET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_SET
#define RX_X4_CL91_SYNC_STSr_GET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_GET
#define RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAP_VALIDf_GET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAP_VALIDf_GET
#define RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAP_VALIDf_SET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAP_VALIDf_SET
#define RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAPf_GET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAPf_GET
#define RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAPf_SET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_FEC_LANE_MAPf_SET
#define RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LHf_GET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LHf_GET
#define RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LHf_SET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LHf_SET
#define RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LLf_GET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LLf_GET
#define RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LLf_SET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LLf_SET
#define RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LIVEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LIVEf_GET
#define RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LIVEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr_CL91_AMPS_LOCK_LIVEf_SET
#define READ_RX_X4_CL91_SYNC_STSr BCMI_TSCD_XGXS_READ_RX_X4_CL91_SYNC_STSr
#define WRITE_RX_X4_CL91_SYNC_STSr BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_SYNC_STSr
#define MODIFY_RX_X4_CL91_SYNC_STSr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_SYNC_STSr
#define READLN_RX_X4_CL91_SYNC_STSr BCMI_TSCD_XGXS_READLN_RX_X4_CL91_SYNC_STSr
#define WRITELN_RX_X4_CL91_SYNC_STSr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_SYNC_STSr
#define WRITEALL_RX_X4_CL91_SYNC_STSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_SYNC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_SYNC_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_SYNC_FSM_ST
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc17b
 * DESC:     block sync status
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_SYNC_FSM_LIVE_STATE FEC synchronization FSM current state
 *     CL91_FEC_SYNC_FSM_LATCHED_STATE FEC synchronization FSM latched stateEach bit represents a particular state. The bit positions for each state is shown belowThe register clears only when read. It is not cleared even on pipeline reset.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr (0x0000c17b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_SYNC_FSM_ST.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_sync_fsm_st[1];
	uint32_t _rx_x4_fec_sync_fsm_st;
} BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CLR(r) (r).rx_x4_fec_sync_fsm_st[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_SET(r,d) (r).rx_x4_fec_sync_fsm_st[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_GET(r) (r).rx_x4_fec_sync_fsm_st[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LATCHED_STATEf_GET(r) ((((r).rx_x4_fec_sync_fsm_st[0]) >> 3) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LATCHED_STATEf_SET(r,f) (r).rx_x4_fec_sync_fsm_st[0]=(((r).rx_x4_fec_sync_fsm_st[0] & ~((uint32_t)0x3f << 3)) | ((((uint32_t)f) & 0x3f) << 3)) | (63 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LIVE_STATEf_GET(r) (((r).rx_x4_fec_sync_fsm_st[0]) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LIVE_STATEf_SET(r,f) (r).rx_x4_fec_sync_fsm_st[0]=(((r).rx_x4_fec_sync_fsm_st[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_X4_FEC_SYNC_FSM_ST.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr,(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr,(_r._rx_x4_fec_sync_fsm_st)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr,(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_SYNC_FSM_STr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_SYNC_FSM_STr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_sync_fsm_st))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_SYNC_FSM_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_sync_fsm_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_SYNC_FSM_STr BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr
#define RX_X4_FEC_SYNC_FSM_STr_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_t RX_X4_FEC_SYNC_FSM_STr_t;
#define RX_X4_FEC_SYNC_FSM_STr_CLR BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CLR
#define RX_X4_FEC_SYNC_FSM_STr_SET BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_SET
#define RX_X4_FEC_SYNC_FSM_STr_GET BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_GET
#define RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LATCHED_STATEf_GET BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LATCHED_STATEf_GET
#define RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LATCHED_STATEf_SET BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LATCHED_STATEf_SET
#define RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LIVE_STATEf_GET BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LIVE_STATEf_GET
#define RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LIVE_STATEf_SET BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr_CL91_FEC_SYNC_FSM_LIVE_STATEf_SET
#define READ_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCD_XGXS_READ_RX_X4_FEC_SYNC_FSM_STr
#define WRITE_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_SYNC_FSM_STr
#define MODIFY_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_SYNC_FSM_STr
#define READLN_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCD_XGXS_READLN_RX_X4_FEC_SYNC_FSM_STr
#define WRITELN_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_SYNC_FSM_STr
#define WRITEALL_RX_X4_FEC_SYNC_FSM_STr BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_SYNC_FSM_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_SYNC_FSM_STr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FC_SLIP_CNT
 * BLOCKS:   RX_X4_STATUS2
 * REGADDR:  0xc17c
 * DESC:     CL91 FC CW sync slip count
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL91_FC_SLIP_CNT Slip count value for CL91 Fiber channel codeword sync.Live value used for debug.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr (0x0000c17c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FC_SLIP_CNT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fc_slip_cnt[1];
	uint32_t _rx_x4_cl91_fc_slip_cnt;
} BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_CLR(r) (r).rx_x4_cl91_fc_slip_cnt[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_SET(r,d) (r).rx_x4_cl91_fc_slip_cnt[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_GET(r) (r).rx_x4_cl91_fc_slip_cnt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_CL91_FC_SLIP_CNTf_GET(r) (((r).rx_x4_cl91_fc_slip_cnt[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_CL91_FC_SLIP_CNTf_SET(r,f) (r).rx_x4_cl91_fc_slip_cnt[0]=(((r).rx_x4_cl91_fc_slip_cnt[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FC_SLIP_CNT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FC_SLIP_CNTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr,(_r._rx_x4_cl91_fc_slip_cnt))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FC_SLIP_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr,(_r._rx_x4_cl91_fc_slip_cnt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FC_SLIP_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr,(_r._rx_x4_cl91_fc_slip_cnt))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FC_SLIP_CNTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fc_slip_cnt))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FC_SLIP_CNTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fc_slip_cnt))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FC_SLIP_CNTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fc_slip_cnt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FC_SLIP_CNTr BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr
#define RX_X4_CL91_FC_SLIP_CNTr_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_t RX_X4_CL91_FC_SLIP_CNTr_t;
#define RX_X4_CL91_FC_SLIP_CNTr_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_CLR
#define RX_X4_CL91_FC_SLIP_CNTr_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_SET
#define RX_X4_CL91_FC_SLIP_CNTr_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_GET
#define RX_X4_CL91_FC_SLIP_CNTr_CL91_FC_SLIP_CNTf_GET BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_CL91_FC_SLIP_CNTf_GET
#define RX_X4_CL91_FC_SLIP_CNTr_CL91_FC_SLIP_CNTf_SET BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr_CL91_FC_SLIP_CNTf_SET
#define READ_RX_X4_CL91_FC_SLIP_CNTr BCMI_TSCD_XGXS_READ_RX_X4_CL91_FC_SLIP_CNTr
#define WRITE_RX_X4_CL91_FC_SLIP_CNTr BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FC_SLIP_CNTr
#define MODIFY_RX_X4_CL91_FC_SLIP_CNTr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FC_SLIP_CNTr
#define READLN_RX_X4_CL91_FC_SLIP_CNTr BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FC_SLIP_CNTr
#define WRITELN_RX_X4_CL91_FC_SLIP_CNTr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FC_SLIP_CNTr
#define WRITEALL_RX_X4_CL91_FC_SLIP_CNTr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FC_SLIP_CNTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FC_SLIP_CNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL0
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc180
 * DESC:     User FEC debug read data for stream 0[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL_STREAM0 16 LSB of the FEC debug data for stream 0, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r (0x0000c180 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl0[1];
	uint32_t _rx_x4_fec_dbg_errl0;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_CLR(r) (r).rx_x4_fec_dbg_errl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_SET(r,d) (r).rx_x4_fec_dbg_errl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_GET(r) (r).rx_x4_fec_dbg_errl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_GET(r) (((r).rx_x4_fec_dbg_errl0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_SET(r,f) (r).rx_x4_fec_dbg_errl0[0]=(((r).rx_x4_fec_dbg_errl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r,(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r,(_r._rx_x4_fec_dbg_errl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r,(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRL0r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r
#define RX_X4_FEC_DBG_ERRL0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_t RX_X4_FEC_DBG_ERRL0r_t;
#define RX_X4_FEC_DBG_ERRL0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_CLR
#define RX_X4_FEC_DBG_ERRL0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_SET
#define RX_X4_FEC_DBG_ERRL0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_GET
#define RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_GET
#define RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r_DBG_ERRL_STREAM0f_SET
#define READ_RX_X4_FEC_DBG_ERRL0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL0r
#define WRITE_RX_X4_FEC_DBG_ERRL0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL0r
#define MODIFY_RX_X4_FEC_DBG_ERRL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL0r
#define READLN_RX_X4_FEC_DBG_ERRL0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL0r
#define WRITELN_RX_X4_FEC_DBG_ERRL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL0r
#define WRITEALL_RX_X4_FEC_DBG_ERRL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL1
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc181
 * DESC:     User FEC debug read data for stream 1[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL_STREAM1 16 LSB of the FEC debug data for stream 0, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r (0x0000c181 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl1[1];
	uint32_t _rx_x4_fec_dbg_errl1;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_CLR(r) (r).rx_x4_fec_dbg_errl1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_SET(r,d) (r).rx_x4_fec_dbg_errl1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_GET(r) (r).rx_x4_fec_dbg_errl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_DBG_ERRL_STREAM1f_GET(r) (((r).rx_x4_fec_dbg_errl1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_DBG_ERRL_STREAM1f_SET(r,f) (r).rx_x4_fec_dbg_errl1[0]=(((r).rx_x4_fec_dbg_errl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r,(_r._rx_x4_fec_dbg_errl1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r,(_r._rx_x4_fec_dbg_errl1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r,(_r._rx_x4_fec_dbg_errl1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRL1r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r
#define RX_X4_FEC_DBG_ERRL1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_t RX_X4_FEC_DBG_ERRL1r_t;
#define RX_X4_FEC_DBG_ERRL1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_CLR
#define RX_X4_FEC_DBG_ERRL1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_SET
#define RX_X4_FEC_DBG_ERRL1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_GET
#define RX_X4_FEC_DBG_ERRL1r_DBG_ERRL_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_DBG_ERRL_STREAM1f_GET
#define RX_X4_FEC_DBG_ERRL1r_DBG_ERRL_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r_DBG_ERRL_STREAM1f_SET
#define READ_RX_X4_FEC_DBG_ERRL1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL1r
#define WRITE_RX_X4_FEC_DBG_ERRL1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL1r
#define MODIFY_RX_X4_FEC_DBG_ERRL1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL1r
#define READLN_RX_X4_FEC_DBG_ERRL1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL1r
#define WRITELN_RX_X4_FEC_DBG_ERRL1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL1r
#define WRITEALL_RX_X4_FEC_DBG_ERRL1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL2
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc182
 * DESC:     User FEC debug read data for stream 2[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL_STREAM2 16 LSB of the FEC debug data for stream 2, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r (0x0000c182 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl2[1];
	uint32_t _rx_x4_fec_dbg_errl2;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_CLR(r) (r).rx_x4_fec_dbg_errl2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_SET(r,d) (r).rx_x4_fec_dbg_errl2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_GET(r) (r).rx_x4_fec_dbg_errl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_DBG_ERRL_STREAM2f_GET(r) (((r).rx_x4_fec_dbg_errl2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_DBG_ERRL_STREAM2f_SET(r,f) (r).rx_x4_fec_dbg_errl2[0]=(((r).rx_x4_fec_dbg_errl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r,(_r._rx_x4_fec_dbg_errl2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r,(_r._rx_x4_fec_dbg_errl2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r,(_r._rx_x4_fec_dbg_errl2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRL2r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r
#define RX_X4_FEC_DBG_ERRL2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_t RX_X4_FEC_DBG_ERRL2r_t;
#define RX_X4_FEC_DBG_ERRL2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_CLR
#define RX_X4_FEC_DBG_ERRL2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_SET
#define RX_X4_FEC_DBG_ERRL2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_GET
#define RX_X4_FEC_DBG_ERRL2r_DBG_ERRL_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_DBG_ERRL_STREAM2f_GET
#define RX_X4_FEC_DBG_ERRL2r_DBG_ERRL_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r_DBG_ERRL_STREAM2f_SET
#define READ_RX_X4_FEC_DBG_ERRL2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL2r
#define WRITE_RX_X4_FEC_DBG_ERRL2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL2r
#define MODIFY_RX_X4_FEC_DBG_ERRL2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL2r
#define READLN_RX_X4_FEC_DBG_ERRL2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL2r
#define WRITELN_RX_X4_FEC_DBG_ERRL2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL2r
#define WRITEALL_RX_X4_FEC_DBG_ERRL2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL3
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc183
 * DESC:     User FEC debug read data for stream 3[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL_STREAM3 16 LSB of the FEC debug data for stream 3, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r (0x0000c183 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl3[1];
	uint32_t _rx_x4_fec_dbg_errl3;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_CLR(r) (r).rx_x4_fec_dbg_errl3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_SET(r,d) (r).rx_x4_fec_dbg_errl3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_GET(r) (r).rx_x4_fec_dbg_errl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_DBG_ERRL_STREAM3f_GET(r) (((r).rx_x4_fec_dbg_errl3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_DBG_ERRL_STREAM3f_SET(r,f) (r).rx_x4_fec_dbg_errl3[0]=(((r).rx_x4_fec_dbg_errl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r,(_r._rx_x4_fec_dbg_errl3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r,(_r._rx_x4_fec_dbg_errl3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r,(_r._rx_x4_fec_dbg_errl3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRL3r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r
#define RX_X4_FEC_DBG_ERRL3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_t RX_X4_FEC_DBG_ERRL3r_t;
#define RX_X4_FEC_DBG_ERRL3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_CLR
#define RX_X4_FEC_DBG_ERRL3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_SET
#define RX_X4_FEC_DBG_ERRL3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_GET
#define RX_X4_FEC_DBG_ERRL3r_DBG_ERRL_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_DBG_ERRL_STREAM3f_GET
#define RX_X4_FEC_DBG_ERRL3r_DBG_ERRL_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r_DBG_ERRL_STREAM3f_SET
#define READ_RX_X4_FEC_DBG_ERRL3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL3r
#define WRITE_RX_X4_FEC_DBG_ERRL3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL3r
#define MODIFY_RX_X4_FEC_DBG_ERRL3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL3r
#define READLN_RX_X4_FEC_DBG_ERRL3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL3r
#define WRITELN_RX_X4_FEC_DBG_ERRL3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL3r
#define WRITEALL_RX_X4_FEC_DBG_ERRL3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRL4
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc184
 * DESC:     User FEC debug read data for stream 4[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRL_STREAM4 16 LSB of the FEC debug data for stream 4, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r (0x0000c184 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRL4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errl4[1];
	uint32_t _rx_x4_fec_dbg_errl4;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_CLR(r) (r).rx_x4_fec_dbg_errl4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_SET(r,d) (r).rx_x4_fec_dbg_errl4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_GET(r) (r).rx_x4_fec_dbg_errl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_DBG_ERRL_STREAM4f_GET(r) (((r).rx_x4_fec_dbg_errl4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_DBG_ERRL_STREAM4f_SET(r,f) (r).rx_x4_fec_dbg_errl4[0]=(((r).rx_x4_fec_dbg_errl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRL4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r,(_r._rx_x4_fec_dbg_errl4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r,(_r._rx_x4_fec_dbg_errl4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r,(_r._rx_x4_fec_dbg_errl4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errl4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRL4r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r
#define RX_X4_FEC_DBG_ERRL4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_t RX_X4_FEC_DBG_ERRL4r_t;
#define RX_X4_FEC_DBG_ERRL4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_CLR
#define RX_X4_FEC_DBG_ERRL4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_SET
#define RX_X4_FEC_DBG_ERRL4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_GET
#define RX_X4_FEC_DBG_ERRL4r_DBG_ERRL_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_DBG_ERRL_STREAM4f_GET
#define RX_X4_FEC_DBG_ERRL4r_DBG_ERRL_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r_DBG_ERRL_STREAM4f_SET
#define READ_RX_X4_FEC_DBG_ERRL4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRL4r
#define WRITE_RX_X4_FEC_DBG_ERRL4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRL4r
#define MODIFY_RX_X4_FEC_DBG_ERRL4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRL4r
#define READLN_RX_X4_FEC_DBG_ERRL4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRL4r
#define WRITELN_RX_X4_FEC_DBG_ERRL4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRL4r
#define WRITEALL_RX_X4_FEC_DBG_ERRL4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH0
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc185
 * DESC:     User FEC debug read data for stream 0[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH_STREAM0 16 MSB of the FEC debug data for stream 0, clear on readContents are latched upon read of Fecdbg_edataL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r (0x0000c185 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah0[1];
	uint32_t _rx_x4_fec_dbg_errah0;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_CLR(r) (r).rx_x4_fec_dbg_errah0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_SET(r,d) (r).rx_x4_fec_dbg_errah0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_GET(r) (r).rx_x4_fec_dbg_errah0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_GET(r) (((r).rx_x4_fec_dbg_errah0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_SET(r,f) (r).rx_x4_fec_dbg_errah0[0]=(((r).rx_x4_fec_dbg_errah0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r,(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r,(_r._rx_x4_fec_dbg_errah0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r,(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errah0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAH0r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r
#define RX_X4_FEC_DBG_ERRAH0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_t RX_X4_FEC_DBG_ERRAH0r_t;
#define RX_X4_FEC_DBG_ERRAH0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_CLR
#define RX_X4_FEC_DBG_ERRAH0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_SET
#define RX_X4_FEC_DBG_ERRAH0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_GET
#define RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_GET
#define RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r_DBG_ERRH_STREAM0f_SET
#define READ_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH0r
#define WRITE_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH0r
#define MODIFY_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH0r
#define READLN_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH0r
#define WRITELN_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH0r
#define WRITEALL_RX_X4_FEC_DBG_ERRAH0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH1
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc186
 * DESC:     User FEC debug read data for stream 1[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH_STREAM1 16 MSB of the FEC debug data for stream 1, clear on readContents are latched upon read of Fecdbg_edataL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r (0x0000c186 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah1[1];
	uint32_t _rx_x4_fec_dbg_errah1;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_CLR(r) (r).rx_x4_fec_dbg_errah1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_SET(r,d) (r).rx_x4_fec_dbg_errah1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_GET(r) (r).rx_x4_fec_dbg_errah1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_DBG_ERRH_STREAM1f_GET(r) (((r).rx_x4_fec_dbg_errah1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_DBG_ERRH_STREAM1f_SET(r,f) (r).rx_x4_fec_dbg_errah1[0]=(((r).rx_x4_fec_dbg_errah1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r,(_r._rx_x4_fec_dbg_errah1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r,(_r._rx_x4_fec_dbg_errah1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r,(_r._rx_x4_fec_dbg_errah1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errah1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAH1r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r
#define RX_X4_FEC_DBG_ERRAH1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_t RX_X4_FEC_DBG_ERRAH1r_t;
#define RX_X4_FEC_DBG_ERRAH1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_CLR
#define RX_X4_FEC_DBG_ERRAH1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_SET
#define RX_X4_FEC_DBG_ERRAH1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_GET
#define RX_X4_FEC_DBG_ERRAH1r_DBG_ERRH_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_DBG_ERRH_STREAM1f_GET
#define RX_X4_FEC_DBG_ERRAH1r_DBG_ERRH_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r_DBG_ERRH_STREAM1f_SET
#define READ_RX_X4_FEC_DBG_ERRAH1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH1r
#define WRITE_RX_X4_FEC_DBG_ERRAH1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH1r
#define MODIFY_RX_X4_FEC_DBG_ERRAH1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH1r
#define READLN_RX_X4_FEC_DBG_ERRAH1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH1r
#define WRITELN_RX_X4_FEC_DBG_ERRAH1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH1r
#define WRITEALL_RX_X4_FEC_DBG_ERRAH1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH2
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc187
 * DESC:     User FEC debug read data for stream 2[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH_STREAM2 16 MSB of the FEC debug data for stream 2, clear on readContents are latched upon read of Fecdbg_edataL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r (0x0000c187 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah2[1];
	uint32_t _rx_x4_fec_dbg_errah2;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_CLR(r) (r).rx_x4_fec_dbg_errah2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_SET(r,d) (r).rx_x4_fec_dbg_errah2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_GET(r) (r).rx_x4_fec_dbg_errah2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_DBG_ERRH_STREAM2f_GET(r) (((r).rx_x4_fec_dbg_errah2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_DBG_ERRH_STREAM2f_SET(r,f) (r).rx_x4_fec_dbg_errah2[0]=(((r).rx_x4_fec_dbg_errah2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r,(_r._rx_x4_fec_dbg_errah2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r,(_r._rx_x4_fec_dbg_errah2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r,(_r._rx_x4_fec_dbg_errah2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errah2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAH2r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r
#define RX_X4_FEC_DBG_ERRAH2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_t RX_X4_FEC_DBG_ERRAH2r_t;
#define RX_X4_FEC_DBG_ERRAH2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_CLR
#define RX_X4_FEC_DBG_ERRAH2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_SET
#define RX_X4_FEC_DBG_ERRAH2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_GET
#define RX_X4_FEC_DBG_ERRAH2r_DBG_ERRH_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_DBG_ERRH_STREAM2f_GET
#define RX_X4_FEC_DBG_ERRAH2r_DBG_ERRH_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r_DBG_ERRH_STREAM2f_SET
#define READ_RX_X4_FEC_DBG_ERRAH2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH2r
#define WRITE_RX_X4_FEC_DBG_ERRAH2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH2r
#define MODIFY_RX_X4_FEC_DBG_ERRAH2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH2r
#define READLN_RX_X4_FEC_DBG_ERRAH2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH2r
#define WRITELN_RX_X4_FEC_DBG_ERRAH2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH2r
#define WRITEALL_RX_X4_FEC_DBG_ERRAH2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH3
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc188
 * DESC:     User FEC debug read data for stream 8[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH_STREAM3 16 MSB of the FEC debug data for stream 3, clear on readContents are latched upon read of Fecdbg_edataL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r (0x0000c188 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah3[1];
	uint32_t _rx_x4_fec_dbg_errah3;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_CLR(r) (r).rx_x4_fec_dbg_errah3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_SET(r,d) (r).rx_x4_fec_dbg_errah3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_GET(r) (r).rx_x4_fec_dbg_errah3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_DBG_ERRH_STREAM3f_GET(r) (((r).rx_x4_fec_dbg_errah3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_DBG_ERRH_STREAM3f_SET(r,f) (r).rx_x4_fec_dbg_errah3[0]=(((r).rx_x4_fec_dbg_errah3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r,(_r._rx_x4_fec_dbg_errah3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r,(_r._rx_x4_fec_dbg_errah3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r,(_r._rx_x4_fec_dbg_errah3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errah3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAH3r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r
#define RX_X4_FEC_DBG_ERRAH3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_t RX_X4_FEC_DBG_ERRAH3r_t;
#define RX_X4_FEC_DBG_ERRAH3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_CLR
#define RX_X4_FEC_DBG_ERRAH3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_SET
#define RX_X4_FEC_DBG_ERRAH3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_GET
#define RX_X4_FEC_DBG_ERRAH3r_DBG_ERRH_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_DBG_ERRH_STREAM3f_GET
#define RX_X4_FEC_DBG_ERRAH3r_DBG_ERRH_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r_DBG_ERRH_STREAM3f_SET
#define READ_RX_X4_FEC_DBG_ERRAH3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH3r
#define WRITE_RX_X4_FEC_DBG_ERRAH3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH3r
#define MODIFY_RX_X4_FEC_DBG_ERRAH3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH3r
#define READLN_RX_X4_FEC_DBG_ERRAH3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH3r
#define WRITELN_RX_X4_FEC_DBG_ERRAH3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH3r
#define WRITEALL_RX_X4_FEC_DBG_ERRAH3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_DBG_ERRAH4
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc189
 * DESC:     User FEC debug read data for stream 4[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DBG_ERRH_STREAM4 16 MSB of the FEC debug data for stream 4, clear on readContents are latched upon read of Fecdbg_edataL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r (0x0000c189 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_DBG_ERRAH4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_dbg_errah4[1];
	uint32_t _rx_x4_fec_dbg_errah4;
} BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_CLR(r) (r).rx_x4_fec_dbg_errah4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_SET(r,d) (r).rx_x4_fec_dbg_errah4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_GET(r) (r).rx_x4_fec_dbg_errah4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_DBG_ERRH_STREAM4f_GET(r) (((r).rx_x4_fec_dbg_errah4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_DBG_ERRH_STREAM4f_SET(r,f) (r).rx_x4_fec_dbg_errah4[0]=(((r).rx_x4_fec_dbg_errah4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_DBG_ERRAH4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r,(_r._rx_x4_fec_dbg_errah4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r,(_r._rx_x4_fec_dbg_errah4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r,(_r._rx_x4_fec_dbg_errah4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_dbg_errah4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_dbg_errah4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_DBG_ERRAH4r BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r
#define RX_X4_FEC_DBG_ERRAH4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_t RX_X4_FEC_DBG_ERRAH4r_t;
#define RX_X4_FEC_DBG_ERRAH4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_CLR
#define RX_X4_FEC_DBG_ERRAH4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_SET
#define RX_X4_FEC_DBG_ERRAH4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_GET
#define RX_X4_FEC_DBG_ERRAH4r_DBG_ERRH_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_DBG_ERRH_STREAM4f_GET
#define RX_X4_FEC_DBG_ERRAH4r_DBG_ERRH_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r_DBG_ERRH_STREAM4f_SET
#define READ_RX_X4_FEC_DBG_ERRAH4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_DBG_ERRAH4r
#define WRITE_RX_X4_FEC_DBG_ERRAH4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_DBG_ERRAH4r
#define MODIFY_RX_X4_FEC_DBG_ERRAH4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_DBG_ERRAH4r
#define READLN_RX_X4_FEC_DBG_ERRAH4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_DBG_ERRAH4r
#define WRITELN_RX_X4_FEC_DBG_ERRAH4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_DBG_ERRAH4r
#define WRITEALL_RX_X4_FEC_DBG_ERRAH4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_DBG_ERRAH4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_DBG_ERRAH4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSL0
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc18a
 * DESC:     fec burst error status lower 16 bits for stream 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL_STREAM0 16 LSB of the fec_burst_err_status for stream 0bits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r (0x0000c18a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsl0[1];
	uint32_t _rx_x4_fec_burst_err_stsl0;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_CLR(r) (r).rx_x4_fec_burst_err_stsl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SET(r,d) (r).rx_x4_fec_burst_err_stsl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_GET(r) (r).rx_x4_fec_burst_err_stsl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_GET(r) (((r).rx_x4_fec_burst_err_stsl0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_SET(r,f) (r).rx_x4_fec_burst_err_stsl0[0]=(((r).rx_x4_fec_burst_err_stsl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r,(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r,(_r._rx_x4_fec_burst_err_stsl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r,(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r
#define RX_X4_FEC_BURST_ERR_STSL0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_t RX_X4_FEC_BURST_ERR_STSL0r_t;
#define RX_X4_FEC_BURST_ERR_STSL0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_CLR
#define RX_X4_FEC_BURST_ERR_STSL0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_SET
#define RX_X4_FEC_BURST_ERR_STSL0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_GET
#define RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_GET
#define RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r_BURST_ERR_STATUSL_STREAM0f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL0r
#define WRITE_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL0r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL0r
#define READLN_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL0r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL0r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSL1
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc18b
 * DESC:     fec burst error status lower 16 bits for stream 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL_STREAM1 16 LSB of the fec_burst_err_status for stream 1bits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r (0x0000c18b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSL1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsl1[1];
	uint32_t _rx_x4_fec_burst_err_stsl1;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_CLR(r) (r).rx_x4_fec_burst_err_stsl1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_SET(r,d) (r).rx_x4_fec_burst_err_stsl1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_GET(r) (r).rx_x4_fec_burst_err_stsl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_BURST_ERR_STATUSL_STREAM1f_GET(r) (((r).rx_x4_fec_burst_err_stsl1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_BURST_ERR_STATUSL_STREAM1f_SET(r,f) (r).rx_x4_fec_burst_err_stsl1[0]=(((r).rx_x4_fec_burst_err_stsl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r,(_r._rx_x4_fec_burst_err_stsl1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r,(_r._rx_x4_fec_burst_err_stsl1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r,(_r._rx_x4_fec_burst_err_stsl1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSL1r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r
#define RX_X4_FEC_BURST_ERR_STSL1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_t RX_X4_FEC_BURST_ERR_STSL1r_t;
#define RX_X4_FEC_BURST_ERR_STSL1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_CLR
#define RX_X4_FEC_BURST_ERR_STSL1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_SET
#define RX_X4_FEC_BURST_ERR_STSL1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_GET
#define RX_X4_FEC_BURST_ERR_STSL1r_BURST_ERR_STATUSL_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_BURST_ERR_STATUSL_STREAM1f_GET
#define RX_X4_FEC_BURST_ERR_STSL1r_BURST_ERR_STATUSL_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r_BURST_ERR_STATUSL_STREAM1f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSL1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL1r
#define WRITE_RX_X4_FEC_BURST_ERR_STSL1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL1r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSL1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL1r
#define READLN_RX_X4_FEC_BURST_ERR_STSL1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL1r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSL1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL1r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSL1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSL2
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc18c
 * DESC:     fec burst error status lower 16 bits for stream 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL_STREAM2 16 LSB of the fec_burst_err_status for stream 2bits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r (0x0000c18c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSL2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsl2[1];
	uint32_t _rx_x4_fec_burst_err_stsl2;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_CLR(r) (r).rx_x4_fec_burst_err_stsl2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_SET(r,d) (r).rx_x4_fec_burst_err_stsl2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_GET(r) (r).rx_x4_fec_burst_err_stsl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_BURST_ERR_STATUSL_STREAM2f_GET(r) (((r).rx_x4_fec_burst_err_stsl2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_BURST_ERR_STATUSL_STREAM2f_SET(r,f) (r).rx_x4_fec_burst_err_stsl2[0]=(((r).rx_x4_fec_burst_err_stsl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSL2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r,(_r._rx_x4_fec_burst_err_stsl2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r,(_r._rx_x4_fec_burst_err_stsl2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r,(_r._rx_x4_fec_burst_err_stsl2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSL2r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r
#define RX_X4_FEC_BURST_ERR_STSL2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_t RX_X4_FEC_BURST_ERR_STSL2r_t;
#define RX_X4_FEC_BURST_ERR_STSL2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_CLR
#define RX_X4_FEC_BURST_ERR_STSL2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_SET
#define RX_X4_FEC_BURST_ERR_STSL2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_GET
#define RX_X4_FEC_BURST_ERR_STSL2r_BURST_ERR_STATUSL_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_BURST_ERR_STATUSL_STREAM2f_GET
#define RX_X4_FEC_BURST_ERR_STSL2r_BURST_ERR_STATUSL_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r_BURST_ERR_STATUSL_STREAM2f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSL2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL2r
#define WRITE_RX_X4_FEC_BURST_ERR_STSL2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL2r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSL2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL2r
#define READLN_RX_X4_FEC_BURST_ERR_STSL2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL2r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSL2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL2r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSL2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSL3
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc18d
 * DESC:     fec burst error status lower 16 bits for stream 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL_STREAM3 16 LSB of the fec_burst_err_status for stream 3bits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r (0x0000c18d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSL3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsl3[1];
	uint32_t _rx_x4_fec_burst_err_stsl3;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_CLR(r) (r).rx_x4_fec_burst_err_stsl3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_SET(r,d) (r).rx_x4_fec_burst_err_stsl3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_GET(r) (r).rx_x4_fec_burst_err_stsl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_BURST_ERR_STATUSL_STREAM3f_GET(r) (((r).rx_x4_fec_burst_err_stsl3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_BURST_ERR_STATUSL_STREAM3f_SET(r,f) (r).rx_x4_fec_burst_err_stsl3[0]=(((r).rx_x4_fec_burst_err_stsl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSL3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r,(_r._rx_x4_fec_burst_err_stsl3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r,(_r._rx_x4_fec_burst_err_stsl3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r,(_r._rx_x4_fec_burst_err_stsl3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSL3r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r
#define RX_X4_FEC_BURST_ERR_STSL3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_t RX_X4_FEC_BURST_ERR_STSL3r_t;
#define RX_X4_FEC_BURST_ERR_STSL3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_CLR
#define RX_X4_FEC_BURST_ERR_STSL3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_SET
#define RX_X4_FEC_BURST_ERR_STSL3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_GET
#define RX_X4_FEC_BURST_ERR_STSL3r_BURST_ERR_STATUSL_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_BURST_ERR_STATUSL_STREAM3f_GET
#define RX_X4_FEC_BURST_ERR_STSL3r_BURST_ERR_STATUSL_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r_BURST_ERR_STATUSL_STREAM3f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSL3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL3r
#define WRITE_RX_X4_FEC_BURST_ERR_STSL3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL3r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSL3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL3r
#define READLN_RX_X4_FEC_BURST_ERR_STSL3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL3r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSL3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL3r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSL3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSL4
 * BLOCKS:   RX_X4_STATUS3
 * REGADDR:  0xc18e
 * DESC:     fec burst error status lower 16 bits for stream 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSL_STREAM4 16 LSB of the fec_burst_err_status for stream 4bits mapping :Bit [15:0] : b21[15:0]Note: Bit 15 of Fec_burst_err_statusH register clears upon reading this register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r (0x0000c18e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSL4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsl4[1];
	uint32_t _rx_x4_fec_burst_err_stsl4;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_CLR(r) (r).rx_x4_fec_burst_err_stsl4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_SET(r,d) (r).rx_x4_fec_burst_err_stsl4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_GET(r) (r).rx_x4_fec_burst_err_stsl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_BURST_ERR_STATUSL_STREAM4f_GET(r) (((r).rx_x4_fec_burst_err_stsl4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_BURST_ERR_STATUSL_STREAM4f_SET(r,f) (r).rx_x4_fec_burst_err_stsl4[0]=(((r).rx_x4_fec_burst_err_stsl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSL4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r,(_r._rx_x4_fec_burst_err_stsl4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r,(_r._rx_x4_fec_burst_err_stsl4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r,(_r._rx_x4_fec_burst_err_stsl4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsl4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSL4r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r
#define RX_X4_FEC_BURST_ERR_STSL4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_t RX_X4_FEC_BURST_ERR_STSL4r_t;
#define RX_X4_FEC_BURST_ERR_STSL4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_CLR
#define RX_X4_FEC_BURST_ERR_STSL4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_SET
#define RX_X4_FEC_BURST_ERR_STSL4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_GET
#define RX_X4_FEC_BURST_ERR_STSL4r_BURST_ERR_STATUSL_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_BURST_ERR_STATUSL_STREAM4f_GET
#define RX_X4_FEC_BURST_ERR_STSL4r_BURST_ERR_STATUSL_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r_BURST_ERR_STATUSL_STREAM4f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSL4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSL4r
#define WRITE_RX_X4_FEC_BURST_ERR_STSL4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSL4r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSL4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSL4r
#define READLN_RX_X4_FEC_BURST_ERR_STSL4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSL4r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSL4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSL4r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSL4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSH0
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc190
 * DESC:     fec burst error status lower 16 bits for stream 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH_STREAM0 Note: This register is only valid in case of Correctable Error scenario.In case of uncorrectable error case, This register may contain invalid data information.16 MSB of the fec_burst_err_status for stream 0bits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r (0x0000c190 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSH0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsh0[1];
	uint32_t _rx_x4_fec_burst_err_stsh0;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_CLR(r) (r).rx_x4_fec_burst_err_stsh0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SET(r,d) (r).rx_x4_fec_burst_err_stsh0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_GET(r) (r).rx_x4_fec_burst_err_stsh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_GET(r) (((r).rx_x4_fec_burst_err_stsh0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_SET(r,f) (r).rx_x4_fec_burst_err_stsh0[0]=(((r).rx_x4_fec_burst_err_stsh0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSH0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r,(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r,(_r._rx_x4_fec_burst_err_stsh0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r,(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsh0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r
#define RX_X4_FEC_BURST_ERR_STSH0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_t RX_X4_FEC_BURST_ERR_STSH0r_t;
#define RX_X4_FEC_BURST_ERR_STSH0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_CLR
#define RX_X4_FEC_BURST_ERR_STSH0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_SET
#define RX_X4_FEC_BURST_ERR_STSH0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_GET
#define RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_GET
#define RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r_BURST_ERR_STATUSH_STREAM0f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH0r
#define WRITE_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH0r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH0r
#define READLN_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH0r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH0r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSH0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSH1
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc191
 * DESC:     fec burst error status lower 16 bits for stream 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH_STREAM1 Note: This register is only valid in case of Correctable Error scenario.In case of uncorrectable error case, This register may contain invalid data information.16 MSB of the fec_burst_err_status for stream 1bits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r (0x0000c191 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSH1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsh1[1];
	uint32_t _rx_x4_fec_burst_err_stsh1;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_CLR(r) (r).rx_x4_fec_burst_err_stsh1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_SET(r,d) (r).rx_x4_fec_burst_err_stsh1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_GET(r) (r).rx_x4_fec_burst_err_stsh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_BURST_ERR_STATUSH_STREAM1f_GET(r) (((r).rx_x4_fec_burst_err_stsh1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_BURST_ERR_STATUSH_STREAM1f_SET(r,f) (r).rx_x4_fec_burst_err_stsh1[0]=(((r).rx_x4_fec_burst_err_stsh1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSH1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r,(_r._rx_x4_fec_burst_err_stsh1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r,(_r._rx_x4_fec_burst_err_stsh1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r,(_r._rx_x4_fec_burst_err_stsh1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsh1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSH1r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r
#define RX_X4_FEC_BURST_ERR_STSH1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_t RX_X4_FEC_BURST_ERR_STSH1r_t;
#define RX_X4_FEC_BURST_ERR_STSH1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_CLR
#define RX_X4_FEC_BURST_ERR_STSH1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_SET
#define RX_X4_FEC_BURST_ERR_STSH1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_GET
#define RX_X4_FEC_BURST_ERR_STSH1r_BURST_ERR_STATUSH_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_BURST_ERR_STATUSH_STREAM1f_GET
#define RX_X4_FEC_BURST_ERR_STSH1r_BURST_ERR_STATUSH_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r_BURST_ERR_STATUSH_STREAM1f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSH1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH1r
#define WRITE_RX_X4_FEC_BURST_ERR_STSH1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH1r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSH1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH1r
#define READLN_RX_X4_FEC_BURST_ERR_STSH1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH1r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSH1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH1r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSH1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSH2
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc192
 * DESC:     fec burst error status lower 16 bits for stream 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH_STREAM2 Note: This register is only valid in case of Correctable Error scenario.In case of uncorrectable error case, This register may contain invalid data information.16 MSB of the fec_burst_err_status for stream 2bits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r (0x0000c192 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSH2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsh2[1];
	uint32_t _rx_x4_fec_burst_err_stsh2;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_CLR(r) (r).rx_x4_fec_burst_err_stsh2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_SET(r,d) (r).rx_x4_fec_burst_err_stsh2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_GET(r) (r).rx_x4_fec_burst_err_stsh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_BURST_ERR_STATUSH_STREAM2f_GET(r) (((r).rx_x4_fec_burst_err_stsh2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_BURST_ERR_STATUSH_STREAM2f_SET(r,f) (r).rx_x4_fec_burst_err_stsh2[0]=(((r).rx_x4_fec_burst_err_stsh2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSH2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r,(_r._rx_x4_fec_burst_err_stsh2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r,(_r._rx_x4_fec_burst_err_stsh2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r,(_r._rx_x4_fec_burst_err_stsh2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsh2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSH2r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r
#define RX_X4_FEC_BURST_ERR_STSH2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_t RX_X4_FEC_BURST_ERR_STSH2r_t;
#define RX_X4_FEC_BURST_ERR_STSH2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_CLR
#define RX_X4_FEC_BURST_ERR_STSH2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_SET
#define RX_X4_FEC_BURST_ERR_STSH2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_GET
#define RX_X4_FEC_BURST_ERR_STSH2r_BURST_ERR_STATUSH_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_BURST_ERR_STATUSH_STREAM2f_GET
#define RX_X4_FEC_BURST_ERR_STSH2r_BURST_ERR_STATUSH_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r_BURST_ERR_STATUSH_STREAM2f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSH2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH2r
#define WRITE_RX_X4_FEC_BURST_ERR_STSH2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH2r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSH2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH2r
#define READLN_RX_X4_FEC_BURST_ERR_STSH2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH2r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSH2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH2r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSH2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSH3
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc193
 * DESC:     fec burst error status lower 16 bits for stream 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH_STREAM3 Note: This register is only valid in case of Correctable Error scenario.In case of uncorrectable error case, This register may contain invalid data information.16 MSB of the fec_burst_err_status for stream 3bits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r (0x0000c193 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSH3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsh3[1];
	uint32_t _rx_x4_fec_burst_err_stsh3;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_CLR(r) (r).rx_x4_fec_burst_err_stsh3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_SET(r,d) (r).rx_x4_fec_burst_err_stsh3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_GET(r) (r).rx_x4_fec_burst_err_stsh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_BURST_ERR_STATUSH_STREAM3f_GET(r) (((r).rx_x4_fec_burst_err_stsh3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_BURST_ERR_STATUSH_STREAM3f_SET(r,f) (r).rx_x4_fec_burst_err_stsh3[0]=(((r).rx_x4_fec_burst_err_stsh3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSH3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r,(_r._rx_x4_fec_burst_err_stsh3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r,(_r._rx_x4_fec_burst_err_stsh3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r,(_r._rx_x4_fec_burst_err_stsh3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsh3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSH3r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r
#define RX_X4_FEC_BURST_ERR_STSH3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_t RX_X4_FEC_BURST_ERR_STSH3r_t;
#define RX_X4_FEC_BURST_ERR_STSH3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_CLR
#define RX_X4_FEC_BURST_ERR_STSH3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_SET
#define RX_X4_FEC_BURST_ERR_STSH3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_GET
#define RX_X4_FEC_BURST_ERR_STSH3r_BURST_ERR_STATUSH_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_BURST_ERR_STATUSH_STREAM3f_GET
#define RX_X4_FEC_BURST_ERR_STSH3r_BURST_ERR_STATUSH_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r_BURST_ERR_STATUSH_STREAM3f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSH3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH3r
#define WRITE_RX_X4_FEC_BURST_ERR_STSH3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH3r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSH3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH3r
#define READLN_RX_X4_FEC_BURST_ERR_STSH3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH3r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSH3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH3r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSH3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BURST_ERR_STSH4
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc194
 * DESC:     fec burst error status lower 16 bits for stream 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BURST_ERR_STATUSH_STREAM4 Note: This register is only valid in case of Correctable Error scenario.In case of uncorrectable error case, This register may contain invalid data information.16 MSB of the fec_burst_err_status for stream 4bits mapping :Bit 15: status updatedBit 8: 21-bit burst detected, but location failed pattern searchBit 7: pattern match passedBit 6: Corrected alternate errorBit 5: Corrected errorBit [4:0] : b21[20:16]Note: Bit 15 clears upon reading Fec_burst_err_statusL register
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r (0x0000c194 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BURST_ERR_STSH4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_burst_err_stsh4[1];
	uint32_t _rx_x4_fec_burst_err_stsh4;
} BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_CLR(r) (r).rx_x4_fec_burst_err_stsh4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_SET(r,d) (r).rx_x4_fec_burst_err_stsh4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_GET(r) (r).rx_x4_fec_burst_err_stsh4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_BURST_ERR_STATUSH_STREAM4f_GET(r) (((r).rx_x4_fec_burst_err_stsh4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_BURST_ERR_STATUSH_STREAM4f_SET(r,f) (r).rx_x4_fec_burst_err_stsh4[0]=(((r).rx_x4_fec_burst_err_stsh4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BURST_ERR_STSH4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r,(_r._rx_x4_fec_burst_err_stsh4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r,(_r._rx_x4_fec_burst_err_stsh4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r,(_r._rx_x4_fec_burst_err_stsh4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_burst_err_stsh4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_burst_err_stsh4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BURST_ERR_STSH4r BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r
#define RX_X4_FEC_BURST_ERR_STSH4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_t RX_X4_FEC_BURST_ERR_STSH4r_t;
#define RX_X4_FEC_BURST_ERR_STSH4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_CLR
#define RX_X4_FEC_BURST_ERR_STSH4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_SET
#define RX_X4_FEC_BURST_ERR_STSH4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_GET
#define RX_X4_FEC_BURST_ERR_STSH4r_BURST_ERR_STATUSH_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_BURST_ERR_STATUSH_STREAM4f_GET
#define RX_X4_FEC_BURST_ERR_STSH4r_BURST_ERR_STATUSH_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r_BURST_ERR_STATUSH_STREAM4f_SET
#define READ_RX_X4_FEC_BURST_ERR_STSH4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BURST_ERR_STSH4r
#define WRITE_RX_X4_FEC_BURST_ERR_STSH4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BURST_ERR_STSH4r
#define MODIFY_RX_X4_FEC_BURST_ERR_STSH4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BURST_ERR_STSH4r
#define READLN_RX_X4_FEC_BURST_ERR_STSH4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BURST_ERR_STSH4r
#define WRITELN_RX_X4_FEC_BURST_ERR_STSH4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BURST_ERR_STSH4r
#define WRITEALL_RX_X4_FEC_BURST_ERR_STSH4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BURST_ERR_STSH4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BURST_ERR_STSH4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSL0
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc195
 * DESC:     FEC corrected blocks counter for stream 0 [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL_STREAM0 16 LSB of the corrected blocks count for stream 0, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r (0x0000c195 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksl0[1];
	uint32_t _rx_x4_fec_corrblksl0;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_CLR(r) (r).rx_x4_fec_corrblksl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_SET(r,d) (r).rx_x4_fec_corrblksl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_GET(r) (r).rx_x4_fec_corrblksl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_GET(r) (((r).rx_x4_fec_corrblksl0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_SET(r,f) (r).rx_x4_fec_corrblksl0[0]=(((r).rx_x4_fec_corrblksl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r,(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r,(_r._rx_x4_fec_corrblksl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r,(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSL0r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r
#define RX_X4_FEC_CORRBLKSL0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_t RX_X4_FEC_CORRBLKSL0r_t;
#define RX_X4_FEC_CORRBLKSL0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_CLR
#define RX_X4_FEC_CORRBLKSL0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_SET
#define RX_X4_FEC_CORRBLKSL0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_GET
#define RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_GET
#define RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r_CORCOUNTL_STREAM0f_SET
#define READ_RX_X4_FEC_CORRBLKSL0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL0r
#define WRITE_RX_X4_FEC_CORRBLKSL0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL0r
#define MODIFY_RX_X4_FEC_CORRBLKSL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL0r
#define READLN_RX_X4_FEC_CORRBLKSL0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL0r
#define WRITELN_RX_X4_FEC_CORRBLKSL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL0r
#define WRITEALL_RX_X4_FEC_CORRBLKSL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSL1
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc196
 * DESC:     FEC corrected blocks counter for stream 1 [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL_STREAM1 16 LSB of the corrected blocks count for stream 1, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r (0x0000c196 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSL1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksl1[1];
	uint32_t _rx_x4_fec_corrblksl1;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_CLR(r) (r).rx_x4_fec_corrblksl1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_SET(r,d) (r).rx_x4_fec_corrblksl1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_GET(r) (r).rx_x4_fec_corrblksl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_CORCOUNTL_STREAM1f_GET(r) (((r).rx_x4_fec_corrblksl1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_CORCOUNTL_STREAM1f_SET(r,f) (r).rx_x4_fec_corrblksl1[0]=(((r).rx_x4_fec_corrblksl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r,(_r._rx_x4_fec_corrblksl1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r,(_r._rx_x4_fec_corrblksl1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r,(_r._rx_x4_fec_corrblksl1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSL1r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r
#define RX_X4_FEC_CORRBLKSL1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_t RX_X4_FEC_CORRBLKSL1r_t;
#define RX_X4_FEC_CORRBLKSL1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_CLR
#define RX_X4_FEC_CORRBLKSL1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_SET
#define RX_X4_FEC_CORRBLKSL1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_GET
#define RX_X4_FEC_CORRBLKSL1r_CORCOUNTL_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_CORCOUNTL_STREAM1f_GET
#define RX_X4_FEC_CORRBLKSL1r_CORCOUNTL_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r_CORCOUNTL_STREAM1f_SET
#define READ_RX_X4_FEC_CORRBLKSL1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL1r
#define WRITE_RX_X4_FEC_CORRBLKSL1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL1r
#define MODIFY_RX_X4_FEC_CORRBLKSL1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL1r
#define READLN_RX_X4_FEC_CORRBLKSL1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL1r
#define WRITELN_RX_X4_FEC_CORRBLKSL1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL1r
#define WRITEALL_RX_X4_FEC_CORRBLKSL1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSL2
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc197
 * DESC:     FEC corrected blocks counter for stream 2 [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL_STREAM2 16 LSB of the corrected blocks count for stream 2, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r (0x0000c197 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSL2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksl2[1];
	uint32_t _rx_x4_fec_corrblksl2;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_CLR(r) (r).rx_x4_fec_corrblksl2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_SET(r,d) (r).rx_x4_fec_corrblksl2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_GET(r) (r).rx_x4_fec_corrblksl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_CORCOUNTL_STREAM2f_GET(r) (((r).rx_x4_fec_corrblksl2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_CORCOUNTL_STREAM2f_SET(r,f) (r).rx_x4_fec_corrblksl2[0]=(((r).rx_x4_fec_corrblksl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSL2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r,(_r._rx_x4_fec_corrblksl2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r,(_r._rx_x4_fec_corrblksl2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r,(_r._rx_x4_fec_corrblksl2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSL2r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r
#define RX_X4_FEC_CORRBLKSL2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_t RX_X4_FEC_CORRBLKSL2r_t;
#define RX_X4_FEC_CORRBLKSL2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_CLR
#define RX_X4_FEC_CORRBLKSL2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_SET
#define RX_X4_FEC_CORRBLKSL2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_GET
#define RX_X4_FEC_CORRBLKSL2r_CORCOUNTL_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_CORCOUNTL_STREAM2f_GET
#define RX_X4_FEC_CORRBLKSL2r_CORCOUNTL_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r_CORCOUNTL_STREAM2f_SET
#define READ_RX_X4_FEC_CORRBLKSL2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL2r
#define WRITE_RX_X4_FEC_CORRBLKSL2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL2r
#define MODIFY_RX_X4_FEC_CORRBLKSL2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL2r
#define READLN_RX_X4_FEC_CORRBLKSL2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL2r
#define WRITELN_RX_X4_FEC_CORRBLKSL2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL2r
#define WRITEALL_RX_X4_FEC_CORRBLKSL2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSL3
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc198
 * DESC:     FEC corrected blocks counter for stream 3 [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL_STREAM3 16 LSB of the corrected blocks count for stream 3, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r (0x0000c198 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSL3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksl3[1];
	uint32_t _rx_x4_fec_corrblksl3;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_CLR(r) (r).rx_x4_fec_corrblksl3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_SET(r,d) (r).rx_x4_fec_corrblksl3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_GET(r) (r).rx_x4_fec_corrblksl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_CORCOUNTL_STREAM3f_GET(r) (((r).rx_x4_fec_corrblksl3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_CORCOUNTL_STREAM3f_SET(r,f) (r).rx_x4_fec_corrblksl3[0]=(((r).rx_x4_fec_corrblksl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSL3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r,(_r._rx_x4_fec_corrblksl3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r,(_r._rx_x4_fec_corrblksl3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r,(_r._rx_x4_fec_corrblksl3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSL3r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r
#define RX_X4_FEC_CORRBLKSL3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_t RX_X4_FEC_CORRBLKSL3r_t;
#define RX_X4_FEC_CORRBLKSL3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_CLR
#define RX_X4_FEC_CORRBLKSL3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_SET
#define RX_X4_FEC_CORRBLKSL3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_GET
#define RX_X4_FEC_CORRBLKSL3r_CORCOUNTL_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_CORCOUNTL_STREAM3f_GET
#define RX_X4_FEC_CORRBLKSL3r_CORCOUNTL_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r_CORCOUNTL_STREAM3f_SET
#define READ_RX_X4_FEC_CORRBLKSL3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL3r
#define WRITE_RX_X4_FEC_CORRBLKSL3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL3r
#define MODIFY_RX_X4_FEC_CORRBLKSL3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL3r
#define READLN_RX_X4_FEC_CORRBLKSL3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL3r
#define WRITELN_RX_X4_FEC_CORRBLKSL3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL3r
#define WRITEALL_RX_X4_FEC_CORRBLKSL3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSL4
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc199
 * DESC:     FEC corrected blocks counter for stream 4 [15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTL_STREAM4 16 LSB of the corrected blocks count for stream 4, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r (0x0000c199 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSL4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksl4[1];
	uint32_t _rx_x4_fec_corrblksl4;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_CLR(r) (r).rx_x4_fec_corrblksl4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_SET(r,d) (r).rx_x4_fec_corrblksl4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_GET(r) (r).rx_x4_fec_corrblksl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_CORCOUNTL_STREAM4f_GET(r) (((r).rx_x4_fec_corrblksl4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_CORCOUNTL_STREAM4f_SET(r,f) (r).rx_x4_fec_corrblksl4[0]=(((r).rx_x4_fec_corrblksl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSL4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r,(_r._rx_x4_fec_corrblksl4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r,(_r._rx_x4_fec_corrblksl4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r,(_r._rx_x4_fec_corrblksl4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksl4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSL4r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r
#define RX_X4_FEC_CORRBLKSL4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_t RX_X4_FEC_CORRBLKSL4r_t;
#define RX_X4_FEC_CORRBLKSL4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_CLR
#define RX_X4_FEC_CORRBLKSL4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_SET
#define RX_X4_FEC_CORRBLKSL4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_GET
#define RX_X4_FEC_CORRBLKSL4r_CORCOUNTL_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_CORCOUNTL_STREAM4f_GET
#define RX_X4_FEC_CORRBLKSL4r_CORCOUNTL_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r_CORCOUNTL_STREAM4f_SET
#define READ_RX_X4_FEC_CORRBLKSL4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSL4r
#define WRITE_RX_X4_FEC_CORRBLKSL4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSL4r
#define MODIFY_RX_X4_FEC_CORRBLKSL4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSL4r
#define READLN_RX_X4_FEC_CORRBLKSL4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSL4r
#define WRITELN_RX_X4_FEC_CORRBLKSL4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSL4r
#define WRITEALL_RX_X4_FEC_CORRBLKSL4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSH0
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc19a
 * DESC:     FEC corrected blocks counter for stream 0 [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH_STREAM0 16 MSB of the corrected blocks count for stream 0, clear on readContents are latched upon read of corCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r (0x0000c19a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSH0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksh0[1];
	uint32_t _rx_x4_fec_corrblksh0;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_CLR(r) (r).rx_x4_fec_corrblksh0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_SET(r,d) (r).rx_x4_fec_corrblksh0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_GET(r) (r).rx_x4_fec_corrblksh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_GET(r) (((r).rx_x4_fec_corrblksh0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_SET(r,f) (r).rx_x4_fec_corrblksh0[0]=(((r).rx_x4_fec_corrblksh0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSH0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r,(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r,(_r._rx_x4_fec_corrblksh0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r,(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksh0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSH0r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r
#define RX_X4_FEC_CORRBLKSH0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_t RX_X4_FEC_CORRBLKSH0r_t;
#define RX_X4_FEC_CORRBLKSH0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_CLR
#define RX_X4_FEC_CORRBLKSH0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_SET
#define RX_X4_FEC_CORRBLKSH0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_GET
#define RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_GET
#define RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r_CORCOUNTH_STREAM0f_SET
#define READ_RX_X4_FEC_CORRBLKSH0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH0r
#define WRITE_RX_X4_FEC_CORRBLKSH0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH0r
#define MODIFY_RX_X4_FEC_CORRBLKSH0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH0r
#define READLN_RX_X4_FEC_CORRBLKSH0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH0r
#define WRITELN_RX_X4_FEC_CORRBLKSH0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH0r
#define WRITEALL_RX_X4_FEC_CORRBLKSH0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSH1
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc19b
 * DESC:     FEC corrected blocks counter for stream 1 [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH_STREAM1 16 MSB of the corrected blocks count for stream 1, clear on readContents are latched upon read of corCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r (0x0000c19b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSH1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksh1[1];
	uint32_t _rx_x4_fec_corrblksh1;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_CLR(r) (r).rx_x4_fec_corrblksh1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_SET(r,d) (r).rx_x4_fec_corrblksh1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_GET(r) (r).rx_x4_fec_corrblksh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_CORCOUNTH_STREAM1f_GET(r) (((r).rx_x4_fec_corrblksh1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_CORCOUNTH_STREAM1f_SET(r,f) (r).rx_x4_fec_corrblksh1[0]=(((r).rx_x4_fec_corrblksh1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSH1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r,(_r._rx_x4_fec_corrblksh1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r,(_r._rx_x4_fec_corrblksh1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r,(_r._rx_x4_fec_corrblksh1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksh1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSH1r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r
#define RX_X4_FEC_CORRBLKSH1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_t RX_X4_FEC_CORRBLKSH1r_t;
#define RX_X4_FEC_CORRBLKSH1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_CLR
#define RX_X4_FEC_CORRBLKSH1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_SET
#define RX_X4_FEC_CORRBLKSH1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_GET
#define RX_X4_FEC_CORRBLKSH1r_CORCOUNTH_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_CORCOUNTH_STREAM1f_GET
#define RX_X4_FEC_CORRBLKSH1r_CORCOUNTH_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r_CORCOUNTH_STREAM1f_SET
#define READ_RX_X4_FEC_CORRBLKSH1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH1r
#define WRITE_RX_X4_FEC_CORRBLKSH1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH1r
#define MODIFY_RX_X4_FEC_CORRBLKSH1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH1r
#define READLN_RX_X4_FEC_CORRBLKSH1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH1r
#define WRITELN_RX_X4_FEC_CORRBLKSH1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH1r
#define WRITEALL_RX_X4_FEC_CORRBLKSH1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSH2
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc19c
 * DESC:     FEC corrected blocks counter for stream 2 [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH_STREAM2 16 MSB of the corrected blocks count for stream 2, clear on readContents are latched upon read of corCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r (0x0000c19c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSH2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksh2[1];
	uint32_t _rx_x4_fec_corrblksh2;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_CLR(r) (r).rx_x4_fec_corrblksh2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_SET(r,d) (r).rx_x4_fec_corrblksh2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_GET(r) (r).rx_x4_fec_corrblksh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_CORCOUNTH_STREAM2f_GET(r) (((r).rx_x4_fec_corrblksh2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_CORCOUNTH_STREAM2f_SET(r,f) (r).rx_x4_fec_corrblksh2[0]=(((r).rx_x4_fec_corrblksh2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSH2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r,(_r._rx_x4_fec_corrblksh2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r,(_r._rx_x4_fec_corrblksh2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r,(_r._rx_x4_fec_corrblksh2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksh2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSH2r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r
#define RX_X4_FEC_CORRBLKSH2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_t RX_X4_FEC_CORRBLKSH2r_t;
#define RX_X4_FEC_CORRBLKSH2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_CLR
#define RX_X4_FEC_CORRBLKSH2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_SET
#define RX_X4_FEC_CORRBLKSH2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_GET
#define RX_X4_FEC_CORRBLKSH2r_CORCOUNTH_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_CORCOUNTH_STREAM2f_GET
#define RX_X4_FEC_CORRBLKSH2r_CORCOUNTH_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r_CORCOUNTH_STREAM2f_SET
#define READ_RX_X4_FEC_CORRBLKSH2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH2r
#define WRITE_RX_X4_FEC_CORRBLKSH2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH2r
#define MODIFY_RX_X4_FEC_CORRBLKSH2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH2r
#define READLN_RX_X4_FEC_CORRBLKSH2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH2r
#define WRITELN_RX_X4_FEC_CORRBLKSH2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH2r
#define WRITEALL_RX_X4_FEC_CORRBLKSH2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSH3
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc19d
 * DESC:     FEC corrected blocks counter for stream 3 [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH_STREAM3 16 MSB of the corrected blocks count for stream 3, clear on readContents are latched upon read of corCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r (0x0000c19d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSH3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksh3[1];
	uint32_t _rx_x4_fec_corrblksh3;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_CLR(r) (r).rx_x4_fec_corrblksh3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_SET(r,d) (r).rx_x4_fec_corrblksh3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_GET(r) (r).rx_x4_fec_corrblksh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_CORCOUNTH_STREAM3f_GET(r) (((r).rx_x4_fec_corrblksh3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_CORCOUNTH_STREAM3f_SET(r,f) (r).rx_x4_fec_corrblksh3[0]=(((r).rx_x4_fec_corrblksh3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSH3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r,(_r._rx_x4_fec_corrblksh3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r,(_r._rx_x4_fec_corrblksh3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r,(_r._rx_x4_fec_corrblksh3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksh3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSH3r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r
#define RX_X4_FEC_CORRBLKSH3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_t RX_X4_FEC_CORRBLKSH3r_t;
#define RX_X4_FEC_CORRBLKSH3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_CLR
#define RX_X4_FEC_CORRBLKSH3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_SET
#define RX_X4_FEC_CORRBLKSH3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_GET
#define RX_X4_FEC_CORRBLKSH3r_CORCOUNTH_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_CORCOUNTH_STREAM3f_GET
#define RX_X4_FEC_CORRBLKSH3r_CORCOUNTH_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r_CORCOUNTH_STREAM3f_SET
#define READ_RX_X4_FEC_CORRBLKSH3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH3r
#define WRITE_RX_X4_FEC_CORRBLKSH3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH3r
#define MODIFY_RX_X4_FEC_CORRBLKSH3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH3r
#define READLN_RX_X4_FEC_CORRBLKSH3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH3r
#define WRITELN_RX_X4_FEC_CORRBLKSH3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH3r
#define WRITEALL_RX_X4_FEC_CORRBLKSH3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORRBLKSH4
 * BLOCKS:   RX_X4_STATUS4
 * REGADDR:  0xc19e
 * DESC:     FEC corrected blocks counter for stream 4 [31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORCOUNTH_STREAM4 16 MSB of the corrected blocks count for stream 4, clear on readContents are latched upon read of corCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r (0x0000c19e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORRBLKSH4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corrblksh4[1];
	uint32_t _rx_x4_fec_corrblksh4;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_CLR(r) (r).rx_x4_fec_corrblksh4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_SET(r,d) (r).rx_x4_fec_corrblksh4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_GET(r) (r).rx_x4_fec_corrblksh4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_CORCOUNTH_STREAM4f_GET(r) (((r).rx_x4_fec_corrblksh4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_CORCOUNTH_STREAM4f_SET(r,f) (r).rx_x4_fec_corrblksh4[0]=(((r).rx_x4_fec_corrblksh4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORRBLKSH4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r,(_r._rx_x4_fec_corrblksh4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r,(_r._rx_x4_fec_corrblksh4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r,(_r._rx_x4_fec_corrblksh4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corrblksh4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corrblksh4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORRBLKSH4r BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r
#define RX_X4_FEC_CORRBLKSH4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_t RX_X4_FEC_CORRBLKSH4r_t;
#define RX_X4_FEC_CORRBLKSH4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_CLR
#define RX_X4_FEC_CORRBLKSH4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_SET
#define RX_X4_FEC_CORRBLKSH4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_GET
#define RX_X4_FEC_CORRBLKSH4r_CORCOUNTH_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_CORCOUNTH_STREAM4f_GET
#define RX_X4_FEC_CORRBLKSH4r_CORCOUNTH_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r_CORCOUNTH_STREAM4f_SET
#define READ_RX_X4_FEC_CORRBLKSH4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORRBLKSH4r
#define WRITE_RX_X4_FEC_CORRBLKSH4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORRBLKSH4r
#define MODIFY_RX_X4_FEC_CORRBLKSH4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORRBLKSH4r
#define READLN_RX_X4_FEC_CORRBLKSH4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORRBLKSH4r
#define WRITELN_RX_X4_FEC_CORRBLKSH4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORRBLKSH4r
#define WRITEALL_RX_X4_FEC_CORRBLKSH4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORRBLKSH4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORRBLKSH4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSL0
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a0
 * DESC:     FEC uncorrected blocks counter for stream 0[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL_STREAM0 16 LSB of the uncorrected blocks count for stream 0, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r (0x0000c1a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSL0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksl0[1];
	uint32_t _rx_x4_fec_uncorrblksl0;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_CLR(r) (r).rx_x4_fec_uncorrblksl0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SET(r,d) (r).rx_x4_fec_uncorrblksl0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_GET(r) (r).rx_x4_fec_uncorrblksl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_GET(r) (((r).rx_x4_fec_uncorrblksl0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_SET(r,f) (r).rx_x4_fec_uncorrblksl0[0]=(((r).rx_x4_fec_uncorrblksl0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r,(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r,(_r._rx_x4_fec_uncorrblksl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r,(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r
#define RX_X4_FEC_UNCORRBLKSL0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_t RX_X4_FEC_UNCORRBLKSL0r_t;
#define RX_X4_FEC_UNCORRBLKSL0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_CLR
#define RX_X4_FEC_UNCORRBLKSL0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_SET
#define RX_X4_FEC_UNCORRBLKSL0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_GET
#define RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_GET
#define RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r_UNCORCOUNTL_STREAM0f_SET
#define READ_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL0r
#define WRITE_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL0r
#define MODIFY_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL0r
#define READLN_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL0r
#define WRITELN_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL0r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSL0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSL1
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a1
 * DESC:     FEC uncorrected blocks counter for stream 1[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL_STREAM1 16 LSB of the uncorrected blocks count for stream 1, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r (0x0000c1a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSL1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksl1[1];
	uint32_t _rx_x4_fec_uncorrblksl1;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_CLR(r) (r).rx_x4_fec_uncorrblksl1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_SET(r,d) (r).rx_x4_fec_uncorrblksl1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_GET(r) (r).rx_x4_fec_uncorrblksl1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_UNCORCOUNTL_STREAM1f_GET(r) (((r).rx_x4_fec_uncorrblksl1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_UNCORCOUNTL_STREAM1f_SET(r,f) (r).rx_x4_fec_uncorrblksl1[0]=(((r).rx_x4_fec_uncorrblksl1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r,(_r._rx_x4_fec_uncorrblksl1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r,(_r._rx_x4_fec_uncorrblksl1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r,(_r._rx_x4_fec_uncorrblksl1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSL1r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r
#define RX_X4_FEC_UNCORRBLKSL1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_t RX_X4_FEC_UNCORRBLKSL1r_t;
#define RX_X4_FEC_UNCORRBLKSL1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_CLR
#define RX_X4_FEC_UNCORRBLKSL1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_SET
#define RX_X4_FEC_UNCORRBLKSL1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_GET
#define RX_X4_FEC_UNCORRBLKSL1r_UNCORCOUNTL_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_UNCORCOUNTL_STREAM1f_GET
#define RX_X4_FEC_UNCORRBLKSL1r_UNCORCOUNTL_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r_UNCORCOUNTL_STREAM1f_SET
#define READ_RX_X4_FEC_UNCORRBLKSL1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL1r
#define WRITE_RX_X4_FEC_UNCORRBLKSL1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL1r
#define MODIFY_RX_X4_FEC_UNCORRBLKSL1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL1r
#define READLN_RX_X4_FEC_UNCORRBLKSL1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL1r
#define WRITELN_RX_X4_FEC_UNCORRBLKSL1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL1r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSL1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSL2
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a2
 * DESC:     FEC uncorrected blocks counter for stream 2[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL_STREAM2 16 LSB of the uncorrected blocks count for stream 2, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r (0x0000c1a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSL2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksl2[1];
	uint32_t _rx_x4_fec_uncorrblksl2;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_CLR(r) (r).rx_x4_fec_uncorrblksl2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_SET(r,d) (r).rx_x4_fec_uncorrblksl2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_GET(r) (r).rx_x4_fec_uncorrblksl2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_UNCORCOUNTL_STREAM2f_GET(r) (((r).rx_x4_fec_uncorrblksl2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_UNCORCOUNTL_STREAM2f_SET(r,f) (r).rx_x4_fec_uncorrblksl2[0]=(((r).rx_x4_fec_uncorrblksl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSL2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r,(_r._rx_x4_fec_uncorrblksl2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r,(_r._rx_x4_fec_uncorrblksl2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r,(_r._rx_x4_fec_uncorrblksl2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSL2r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r
#define RX_X4_FEC_UNCORRBLKSL2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_t RX_X4_FEC_UNCORRBLKSL2r_t;
#define RX_X4_FEC_UNCORRBLKSL2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_CLR
#define RX_X4_FEC_UNCORRBLKSL2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_SET
#define RX_X4_FEC_UNCORRBLKSL2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_GET
#define RX_X4_FEC_UNCORRBLKSL2r_UNCORCOUNTL_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_UNCORCOUNTL_STREAM2f_GET
#define RX_X4_FEC_UNCORRBLKSL2r_UNCORCOUNTL_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r_UNCORCOUNTL_STREAM2f_SET
#define READ_RX_X4_FEC_UNCORRBLKSL2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL2r
#define WRITE_RX_X4_FEC_UNCORRBLKSL2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL2r
#define MODIFY_RX_X4_FEC_UNCORRBLKSL2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL2r
#define READLN_RX_X4_FEC_UNCORRBLKSL2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL2r
#define WRITELN_RX_X4_FEC_UNCORRBLKSL2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL2r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSL2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSL3
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a3
 * DESC:     FEC uncorrected blocks counter for stream 3[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL_STREAM3 16 LSB of the uncorrected blocks count for stream 3, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r (0x0000c1a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSL3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksl3[1];
	uint32_t _rx_x4_fec_uncorrblksl3;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_CLR(r) (r).rx_x4_fec_uncorrblksl3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_SET(r,d) (r).rx_x4_fec_uncorrblksl3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_GET(r) (r).rx_x4_fec_uncorrblksl3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_UNCORCOUNTL_STREAM3f_GET(r) (((r).rx_x4_fec_uncorrblksl3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_UNCORCOUNTL_STREAM3f_SET(r,f) (r).rx_x4_fec_uncorrblksl3[0]=(((r).rx_x4_fec_uncorrblksl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSL3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r,(_r._rx_x4_fec_uncorrblksl3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r,(_r._rx_x4_fec_uncorrblksl3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r,(_r._rx_x4_fec_uncorrblksl3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSL3r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r
#define RX_X4_FEC_UNCORRBLKSL3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_t RX_X4_FEC_UNCORRBLKSL3r_t;
#define RX_X4_FEC_UNCORRBLKSL3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_CLR
#define RX_X4_FEC_UNCORRBLKSL3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_SET
#define RX_X4_FEC_UNCORRBLKSL3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_GET
#define RX_X4_FEC_UNCORRBLKSL3r_UNCORCOUNTL_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_UNCORCOUNTL_STREAM3f_GET
#define RX_X4_FEC_UNCORRBLKSL3r_UNCORCOUNTL_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r_UNCORCOUNTL_STREAM3f_SET
#define READ_RX_X4_FEC_UNCORRBLKSL3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL3r
#define WRITE_RX_X4_FEC_UNCORRBLKSL3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL3r
#define MODIFY_RX_X4_FEC_UNCORRBLKSL3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL3r
#define READLN_RX_X4_FEC_UNCORRBLKSL3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL3r
#define WRITELN_RX_X4_FEC_UNCORRBLKSL3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL3r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSL3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSL4
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a4
 * DESC:     FEC uncorrected blocks counter for stream 4[15:0]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTL_STREAM4 16 LSB of the uncorrected blocks count for stream 4, clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r (0x0000c1a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSL4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksl4[1];
	uint32_t _rx_x4_fec_uncorrblksl4;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_CLR(r) (r).rx_x4_fec_uncorrblksl4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_SET(r,d) (r).rx_x4_fec_uncorrblksl4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_GET(r) (r).rx_x4_fec_uncorrblksl4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_UNCORCOUNTL_STREAM4f_GET(r) (((r).rx_x4_fec_uncorrblksl4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_UNCORCOUNTL_STREAM4f_SET(r,f) (r).rx_x4_fec_uncorrblksl4[0]=(((r).rx_x4_fec_uncorrblksl4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSL4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r,(_r._rx_x4_fec_uncorrblksl4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r,(_r._rx_x4_fec_uncorrblksl4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r,(_r._rx_x4_fec_uncorrblksl4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksl4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSL4r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r
#define RX_X4_FEC_UNCORRBLKSL4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_t RX_X4_FEC_UNCORRBLKSL4r_t;
#define RX_X4_FEC_UNCORRBLKSL4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_CLR
#define RX_X4_FEC_UNCORRBLKSL4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_SET
#define RX_X4_FEC_UNCORRBLKSL4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_GET
#define RX_X4_FEC_UNCORRBLKSL4r_UNCORCOUNTL_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_UNCORCOUNTL_STREAM4f_GET
#define RX_X4_FEC_UNCORRBLKSL4r_UNCORCOUNTL_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r_UNCORCOUNTL_STREAM4f_SET
#define READ_RX_X4_FEC_UNCORRBLKSL4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSL4r
#define WRITE_RX_X4_FEC_UNCORRBLKSL4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSL4r
#define MODIFY_RX_X4_FEC_UNCORRBLKSL4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSL4r
#define READLN_RX_X4_FEC_UNCORRBLKSL4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSL4r
#define WRITELN_RX_X4_FEC_UNCORRBLKSL4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSL4r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSL4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSH0
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a5
 * DESC:     FEC uncorrected blocks counter for stream 0[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH_STREAM0 16 MSB of the uncorrected blocks count for stream 0, clear on readContents are latched upon read of uncorCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r (0x0000c1a5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSH0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksh0[1];
	uint32_t _rx_x4_fec_uncorrblksh0;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_CLR(r) (r).rx_x4_fec_uncorrblksh0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SET(r,d) (r).rx_x4_fec_uncorrblksh0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_GET(r) (r).rx_x4_fec_uncorrblksh0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_GET(r) (((r).rx_x4_fec_uncorrblksh0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_SET(r,f) (r).rx_x4_fec_uncorrblksh0[0]=(((r).rx_x4_fec_uncorrblksh0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSH0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r,(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r,(_r._rx_x4_fec_uncorrblksh0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r,(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksh0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r
#define RX_X4_FEC_UNCORRBLKSH0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_t RX_X4_FEC_UNCORRBLKSH0r_t;
#define RX_X4_FEC_UNCORRBLKSH0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_CLR
#define RX_X4_FEC_UNCORRBLKSH0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_SET
#define RX_X4_FEC_UNCORRBLKSH0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_GET
#define RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_GET
#define RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r_UNCORCOUNTH_STREAM0f_SET
#define READ_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH0r
#define WRITE_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH0r
#define MODIFY_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH0r
#define READLN_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH0r
#define WRITELN_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH0r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSH0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSH1
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a6
 * DESC:     FEC uncorrected blocks counter for stream 1[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH_STREAM1 16 MSB of the uncorrected blocks count for stream 1, clear on readContents are latched upon read of uncorCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r (0x0000c1a6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSH1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksh1[1];
	uint32_t _rx_x4_fec_uncorrblksh1;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_CLR(r) (r).rx_x4_fec_uncorrblksh1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_SET(r,d) (r).rx_x4_fec_uncorrblksh1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_GET(r) (r).rx_x4_fec_uncorrblksh1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_UNCORCOUNTH_STREAM1f_GET(r) (((r).rx_x4_fec_uncorrblksh1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_UNCORCOUNTH_STREAM1f_SET(r,f) (r).rx_x4_fec_uncorrblksh1[0]=(((r).rx_x4_fec_uncorrblksh1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSH1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r,(_r._rx_x4_fec_uncorrblksh1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r,(_r._rx_x4_fec_uncorrblksh1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r,(_r._rx_x4_fec_uncorrblksh1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksh1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSH1r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r
#define RX_X4_FEC_UNCORRBLKSH1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_t RX_X4_FEC_UNCORRBLKSH1r_t;
#define RX_X4_FEC_UNCORRBLKSH1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_CLR
#define RX_X4_FEC_UNCORRBLKSH1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_SET
#define RX_X4_FEC_UNCORRBLKSH1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_GET
#define RX_X4_FEC_UNCORRBLKSH1r_UNCORCOUNTH_STREAM1f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_UNCORCOUNTH_STREAM1f_GET
#define RX_X4_FEC_UNCORRBLKSH1r_UNCORCOUNTH_STREAM1f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r_UNCORCOUNTH_STREAM1f_SET
#define READ_RX_X4_FEC_UNCORRBLKSH1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH1r
#define WRITE_RX_X4_FEC_UNCORRBLKSH1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH1r
#define MODIFY_RX_X4_FEC_UNCORRBLKSH1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH1r
#define READLN_RX_X4_FEC_UNCORRBLKSH1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH1r
#define WRITELN_RX_X4_FEC_UNCORRBLKSH1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH1r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSH1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSH2
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a7
 * DESC:     FEC uncorrected blocks counter for stream 2[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH_STREAM2 16 MSB of the uncorrected blocks count for stream 2, clear on readContents are latched upon read of uncorCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r (0x0000c1a7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSH2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksh2[1];
	uint32_t _rx_x4_fec_uncorrblksh2;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_CLR(r) (r).rx_x4_fec_uncorrblksh2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_SET(r,d) (r).rx_x4_fec_uncorrblksh2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_GET(r) (r).rx_x4_fec_uncorrblksh2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_UNCORCOUNTH_STREAM2f_GET(r) (((r).rx_x4_fec_uncorrblksh2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_UNCORCOUNTH_STREAM2f_SET(r,f) (r).rx_x4_fec_uncorrblksh2[0]=(((r).rx_x4_fec_uncorrblksh2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSH2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r,(_r._rx_x4_fec_uncorrblksh2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r,(_r._rx_x4_fec_uncorrblksh2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r,(_r._rx_x4_fec_uncorrblksh2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksh2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSH2r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r
#define RX_X4_FEC_UNCORRBLKSH2r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_t RX_X4_FEC_UNCORRBLKSH2r_t;
#define RX_X4_FEC_UNCORRBLKSH2r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_CLR
#define RX_X4_FEC_UNCORRBLKSH2r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_SET
#define RX_X4_FEC_UNCORRBLKSH2r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_GET
#define RX_X4_FEC_UNCORRBLKSH2r_UNCORCOUNTH_STREAM2f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_UNCORCOUNTH_STREAM2f_GET
#define RX_X4_FEC_UNCORRBLKSH2r_UNCORCOUNTH_STREAM2f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r_UNCORCOUNTH_STREAM2f_SET
#define READ_RX_X4_FEC_UNCORRBLKSH2r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH2r
#define WRITE_RX_X4_FEC_UNCORRBLKSH2r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH2r
#define MODIFY_RX_X4_FEC_UNCORRBLKSH2r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH2r
#define READLN_RX_X4_FEC_UNCORRBLKSH2r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH2r
#define WRITELN_RX_X4_FEC_UNCORRBLKSH2r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH2r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSH2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSH3
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a8
 * DESC:     FEC uncorrected blocks counter for stream 3[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH_STREAM3 16 MSB of the uncorrected blocks count for stream 3, clear on readContents are latched upon read of uncorCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r (0x0000c1a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSH3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksh3[1];
	uint32_t _rx_x4_fec_uncorrblksh3;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_CLR(r) (r).rx_x4_fec_uncorrblksh3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_SET(r,d) (r).rx_x4_fec_uncorrblksh3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_GET(r) (r).rx_x4_fec_uncorrblksh3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_UNCORCOUNTH_STREAM3f_GET(r) (((r).rx_x4_fec_uncorrblksh3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_UNCORCOUNTH_STREAM3f_SET(r,f) (r).rx_x4_fec_uncorrblksh3[0]=(((r).rx_x4_fec_uncorrblksh3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSH3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r,(_r._rx_x4_fec_uncorrblksh3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r,(_r._rx_x4_fec_uncorrblksh3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r,(_r._rx_x4_fec_uncorrblksh3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksh3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSH3r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r
#define RX_X4_FEC_UNCORRBLKSH3r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_t RX_X4_FEC_UNCORRBLKSH3r_t;
#define RX_X4_FEC_UNCORRBLKSH3r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_CLR
#define RX_X4_FEC_UNCORRBLKSH3r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_SET
#define RX_X4_FEC_UNCORRBLKSH3r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_GET
#define RX_X4_FEC_UNCORRBLKSH3r_UNCORCOUNTH_STREAM3f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_UNCORCOUNTH_STREAM3f_GET
#define RX_X4_FEC_UNCORRBLKSH3r_UNCORCOUNTH_STREAM3f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r_UNCORCOUNTH_STREAM3f_SET
#define READ_RX_X4_FEC_UNCORRBLKSH3r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH3r
#define WRITE_RX_X4_FEC_UNCORRBLKSH3r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH3r
#define MODIFY_RX_X4_FEC_UNCORRBLKSH3r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH3r
#define READLN_RX_X4_FEC_UNCORRBLKSH3r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH3r
#define WRITELN_RX_X4_FEC_UNCORRBLKSH3r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH3r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSH3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORRBLKSH4
 * BLOCKS:   RX_X4_STATUS5
 * REGADDR:  0xc1a9
 * DESC:     FEC uncorrected blocks counter for stream 4[31:16]
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UNCORCOUNTH_STREAM4 16 MSB of the uncorrected blocks count for stream 4, clear on readContents are latched upon read of uncorCountL
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r (0x0000c1a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORRBLKSH4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorrblksh4[1];
	uint32_t _rx_x4_fec_uncorrblksh4;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_CLR(r) (r).rx_x4_fec_uncorrblksh4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_SET(r,d) (r).rx_x4_fec_uncorrblksh4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_GET(r) (r).rx_x4_fec_uncorrblksh4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_UNCORCOUNTH_STREAM4f_GET(r) (((r).rx_x4_fec_uncorrblksh4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_UNCORCOUNTH_STREAM4f_SET(r,f) (r).rx_x4_fec_uncorrblksh4[0]=(((r).rx_x4_fec_uncorrblksh4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORRBLKSH4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r,(_r._rx_x4_fec_uncorrblksh4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r,(_r._rx_x4_fec_uncorrblksh4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r,(_r._rx_x4_fec_uncorrblksh4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorrblksh4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorrblksh4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORRBLKSH4r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r
#define RX_X4_FEC_UNCORRBLKSH4r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_t RX_X4_FEC_UNCORRBLKSH4r_t;
#define RX_X4_FEC_UNCORRBLKSH4r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_CLR
#define RX_X4_FEC_UNCORRBLKSH4r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_SET
#define RX_X4_FEC_UNCORRBLKSH4r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_GET
#define RX_X4_FEC_UNCORRBLKSH4r_UNCORCOUNTH_STREAM4f_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_UNCORCOUNTH_STREAM4f_GET
#define RX_X4_FEC_UNCORRBLKSH4r_UNCORCOUNTH_STREAM4f_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r_UNCORCOUNTH_STREAM4f_SET
#define READ_RX_X4_FEC_UNCORRBLKSH4r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORRBLKSH4r
#define WRITE_RX_X4_FEC_UNCORRBLKSH4r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORRBLKSH4r
#define MODIFY_RX_X4_FEC_UNCORRBLKSH4r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORRBLKSH4r
#define READLN_RX_X4_FEC_UNCORRBLKSH4r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORRBLKSH4r
#define WRITELN_RX_X4_FEC_UNCORRBLKSH4r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORRBLKSH4r
#define WRITEALL_RX_X4_FEC_UNCORRBLKSH4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORRBLKSH4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORRBLKSH4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_CL73_CFG
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c0
 * DESC:     CL73 Auto Neg Config Reg
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_AN_RESTART  CL73 Auto-Negotiation RestartA transition from zero to one on this bit will restart CL73 AN
 *     AD_TO_CL73_EN    When doing HP auto neg, if the other device is doing CL73 auto neg, then restart auto neg in CL73 mode.
 *     BAM_TO_HPAM_AD_EN Broadcom to Hewlett-Packard Auto-Detect EnableWhen doing Broadcom CL73 auto-negotioation, if the other device is doingHewlett-Packard auto-negotiation, then restart auto-negotiation in.Hewlett-Packard mode.
 *     CL73_NONCE_MATCH_VAL Clause 73 nonce match value
 *     CL73_NONCE_MATCH_OVER Clause 73 nonce match over-ride
 *     CL73_ENABLE      IEEE CL73 Auto-Negotiation Mode Enable
 *     CL73_HPAM_ENABLE Hewlett-Packard Auto-Negotiation Mode EnableIf both Broadcom CL73 and Hewlett Packard modes are enabled, then the local device will start in Broadcom CL73 mode.
 *     CL73_BAM_ENABLE  Broadcom CL73 Auto-Negotiation Mode Enable
 *     NUM_ADVERTISED_LANES Defines the number of lanes that are available via the advertised pagesSW must set this field before enabling AN0: one lane1: two lanes2: four lanes3: 10 lanes
 *     DISABLE_REMOTE_FAULT Disable the Remote Fault Reporting
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr (0x0000c1c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_CL73_CFG.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_s {
	uint32_t v[1];
	uint32_t an_x4_cl73_cfg[1];
	uint32_t _an_x4_cl73_cfg;
} BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_t;

#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CLR(r) (r).an_x4_cl73_cfg[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_SET(r,d) (r).an_x4_cl73_cfg[0] = d
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_GET(r) (r).an_x4_cl73_cfg[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 11) & 0x3)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_HPAM_ENABLEf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_HPAM_ENABLEf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_BAM_TO_HPAM_AD_ENf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_BAM_TO_HPAM_AD_ENf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_AD_TO_CL73_ENf_GET(r) ((((r).an_x4_cl73_cfg[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_AD_TO_CL73_ENf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_GET(r) (((r).an_x4_cl73_cfg[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_SET(r,f) (r).an_x4_cl73_cfg[0]=(((r).an_x4_cl73_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_CL73_CFG.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_CL73_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CFGr,(_r._an_x4_cl73_cfg))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_CL73_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CFGr,(_r._an_x4_cl73_cfg)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_CL73_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CFGr,(_r._an_x4_cl73_cfg))
#define BCMI_TSCD_XGXS_READLN_AN_X4_CL73_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_cfg))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_CL73_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_cfg))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_CL73_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_cl73_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_CL73_CFGr BCMI_TSCD_XGXS_AN_X4_CL73_CFGr
#define AN_X4_CL73_CFGr_SIZE BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_t AN_X4_CL73_CFGr_t;
#define AN_X4_CL73_CFGr_CLR BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CLR
#define AN_X4_CL73_CFGr_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_SET
#define AN_X4_CL73_CFGr_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_GET
#define AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_GET
#define AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_DISABLE_REMOTE_FAULTf_SET
#define AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_GET
#define AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_NUM_ADVERTISED_LANESf_SET
#define AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_GET
#define AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_BAM_ENABLEf_SET
#define AN_X4_CL73_CFGr_CL73_HPAM_ENABLEf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_HPAM_ENABLEf_GET
#define AN_X4_CL73_CFGr_CL73_HPAM_ENABLEf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_HPAM_ENABLEf_SET
#define AN_X4_CL73_CFGr_CL73_ENABLEf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_GET
#define AN_X4_CL73_CFGr_CL73_ENABLEf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_ENABLEf_SET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_GET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_OVERf_SET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_GET
#define AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_NONCE_MATCH_VALf_SET
#define AN_X4_CL73_CFGr_BAM_TO_HPAM_AD_ENf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_BAM_TO_HPAM_AD_ENf_GET
#define AN_X4_CL73_CFGr_BAM_TO_HPAM_AD_ENf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_BAM_TO_HPAM_AD_ENf_SET
#define AN_X4_CL73_CFGr_AD_TO_CL73_ENf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_AD_TO_CL73_ENf_GET
#define AN_X4_CL73_CFGr_AD_TO_CL73_ENf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_AD_TO_CL73_ENf_SET
#define AN_X4_CL73_CFGr_CL73_AN_RESTARTf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_GET
#define AN_X4_CL73_CFGr_CL73_AN_RESTARTf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CFGr_CL73_AN_RESTARTf_SET
#define READ_AN_X4_CL73_CFGr BCMI_TSCD_XGXS_READ_AN_X4_CL73_CFGr
#define WRITE_AN_X4_CL73_CFGr BCMI_TSCD_XGXS_WRITE_AN_X4_CL73_CFGr
#define MODIFY_AN_X4_CL73_CFGr BCMI_TSCD_XGXS_MODIFY_AN_X4_CL73_CFGr
#define READLN_AN_X4_CL73_CFGr BCMI_TSCD_XGXS_READLN_AN_X4_CL73_CFGr
#define WRITELN_AN_X4_CL73_CFGr BCMI_TSCD_XGXS_WRITELN_AN_X4_CL73_CFGr
#define WRITEALL_AN_X4_CL73_CFGr BCMI_TSCD_XGXS_WRITEALL_AN_X4_CL73_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_CL73_CFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_UP1_ABIL0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c1
 * DESC:     Local Device UP1 ABILITIES REG 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_20G_KR2      UP1 Page Bit 16
 *     BAM_20G_CR2      UP1 Page Bit 17
 *     BAM_40G_KR2      UP1 Page Bit 22
 *     BAM_40G_CR2      UP1 Page Bit 23
 *     BAM_50G_KR2      UP1 Page Bit 24
 *     BAM_50G_CR2      UP1 Page Bit 25
 *     BAM_50G_KR4      UP1 Page Bit 32
 *     BAM_50G_CR4      UP1 Page Bit 33
 *     BAM_HG2          Hi Gig Mode
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r (0x0000c1c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_UP1_ABIL0.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_up1_abil0[1];
	uint32_t _an_x4_ld_up1_abil0;
} BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_CLR(r) (r).an_x4_ld_up1_abil0[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_SET(r,d) (r).an_x4_ld_up1_abil0[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_GET(r) (r).an_x4_ld_up1_abil0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_HG2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_HG2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_GET(r) ((((r).an_x4_ld_up1_abil0[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_GET(r) (((r).an_x4_ld_up1_abil0[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_SET(r,f) (r).an_x4_ld_up1_abil0[0]=(((r).an_x4_ld_up1_abil0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_UP1_ABIL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r,(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r,(_r._an_x4_ld_up1_abil0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r,(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_UP1_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_UP1_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil0))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_up1_abil0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_UP1_ABIL0r BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r
#define AN_X4_LD_UP1_ABIL0r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_t AN_X4_LD_UP1_ABIL0r_t;
#define AN_X4_LD_UP1_ABIL0r_CLR BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_CLR
#define AN_X4_LD_UP1_ABIL0r_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_SET
#define AN_X4_LD_UP1_ABIL0r_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_HG2f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_HG2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_HG2f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_HG2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR4f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR4f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_CR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_50G_KR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_CR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_40G_KR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_CR2f_SET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_GET
#define AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r_BAM_20G_KR2f_SET
#define READ_AN_X4_LD_UP1_ABIL0r BCMI_TSCD_XGXS_READ_AN_X4_LD_UP1_ABIL0r
#define WRITE_AN_X4_LD_UP1_ABIL0r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_UP1_ABIL0r
#define MODIFY_AN_X4_LD_UP1_ABIL0r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_UP1_ABIL0r
#define READLN_AN_X4_LD_UP1_ABIL0r BCMI_TSCD_XGXS_READLN_AN_X4_LD_UP1_ABIL0r
#define WRITELN_AN_X4_LD_UP1_ABIL0r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_UP1_ABIL0r
#define WRITEALL_AN_X4_LD_UP1_ABIL0r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_UP1_ABIL1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c2
 * DESC:     Local Device UP1 ABILITIES REG 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BAM_20G_KR1      UP1 Page Bit 18
 *     BAM_20G_CR1      UP1 Page Bit 19
 *     BAM_25G_KR1      UP1 Page Bit 20
 *     BAM_25G_CR1      UP1 Page Bit 21
 *     CL91_REQ         UP1 Page Bit 43 and 40 for CL91 requested and enable for 25/50G upper bit is for request of CL91 and lower is to enable LD'c CL91
 *     CL74_REQ         UP1 Page Bit 44 and 41 for CL74 requested and enable for 25/50G upper bit is for request of CL74 and lower is to enable LD'c CL74
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r (0x0000c1c2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_UP1_ABIL1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_up1_abil1[1];
	uint32_t _an_x4_ld_up1_abil1;
} BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CLR(r) (r).an_x4_ld_up1_abil1[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_SET(r,d) (r).an_x4_ld_up1_abil1[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_GET(r) (r).an_x4_ld_up1_abil1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL91_REQf_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 12) & 0x3)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL91_REQf_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_GET(r) ((((r).an_x4_ld_up1_abil1[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_SET(r,f) (r).an_x4_ld_up1_abil1[0]=(((r).an_x4_ld_up1_abil1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access AN_X4_LD_UP1_ABIL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r,(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r,(_r._an_x4_ld_up1_abil1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r,(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_UP1_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_UP1_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_up1_abil1))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_up1_abil1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_UP1_ABIL1r BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r
#define AN_X4_LD_UP1_ABIL1r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_t AN_X4_LD_UP1_ABIL1r_t;
#define AN_X4_LD_UP1_ABIL1r_CLR BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CLR
#define AN_X4_LD_UP1_ABIL1r_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_SET
#define AN_X4_LD_UP1_ABIL1r_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_GET
#define AN_X4_LD_UP1_ABIL1r_CL74_REQf_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_GET
#define AN_X4_LD_UP1_ABIL1r_CL74_REQf_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL74_REQf_SET
#define AN_X4_LD_UP1_ABIL1r_CL91_REQf_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL91_REQf_GET
#define AN_X4_LD_UP1_ABIL1r_CL91_REQf_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_CL91_REQf_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_CR1f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_25G_KR1f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_CR1f_SET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_GET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_GET
#define AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_SET BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r_BAM_20G_KR1f_SET
#define READ_AN_X4_LD_UP1_ABIL1r BCMI_TSCD_XGXS_READ_AN_X4_LD_UP1_ABIL1r
#define WRITE_AN_X4_LD_UP1_ABIL1r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_UP1_ABIL1r
#define MODIFY_AN_X4_LD_UP1_ABIL1r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_UP1_ABIL1r
#define READLN_AN_X4_LD_UP1_ABIL1r BCMI_TSCD_XGXS_READLN_AN_X4_LD_UP1_ABIL1r
#define WRITELN_AN_X4_LD_UP1_ABIL1r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_UP1_ABIL1r
#define WRITEALL_AN_X4_LD_UP1_ABIL1r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_UP1_ABIL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_UP1_ABIL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c3
 * DESC:     Local Device BASE ABILITIES REG 0
 * RESETVAL: 0x2a1 (673)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_BASE_SELECTOR IEEE Annex 28A Message SelectorSent in CL73 base page.
 *     TX_NONCE         First CL73 nonce to be transmitted.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r (0x0000c1c3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL0.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil0[1];
	uint32_t _an_x4_ld_base_abil0;
} BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_CLR(r) (r).an_x4_ld_base_abil0[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_SET(r,d) (r).an_x4_ld_base_abil0[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_GET(r) (r).an_x4_ld_base_abil0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_GET(r) ((((r).an_x4_ld_base_abil0[0]) >> 5) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_SET(r,f) (r).an_x4_ld_base_abil0[0]=(((r).an_x4_ld_base_abil0[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_GET(r) (((r).an_x4_ld_base_abil0[0]) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_SET(r,f) (r).an_x4_ld_base_abil0[0]=(((r).an_x4_ld_base_abil0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r,(_r._an_x4_ld_base_abil0))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r,(_r._an_x4_ld_base_abil0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r,(_r._an_x4_ld_base_abil0))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil0))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil0))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL0r BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r
#define AN_X4_LD_BASE_ABIL0r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_t AN_X4_LD_BASE_ABIL0r_t;
#define AN_X4_LD_BASE_ABIL0r_CLR BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_CLR
#define AN_X4_LD_BASE_ABIL0r_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_SET
#define AN_X4_LD_BASE_ABIL0r_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_GET
#define AN_X4_LD_BASE_ABIL0r_TX_NONCEf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_GET
#define AN_X4_LD_BASE_ABIL0r_TX_NONCEf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_TX_NONCEf_SET
#define AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_GET
#define AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r_CL73_BASE_SELECTORf_SET
#define READ_AN_X4_LD_BASE_ABIL0r BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL0r
#define WRITE_AN_X4_LD_BASE_ABIL0r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL0r
#define MODIFY_AN_X4_LD_BASE_ABIL0r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL0r
#define READLN_AN_X4_LD_BASE_ABIL0r BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL0r
#define WRITELN_AN_X4_LD_BASE_ABIL0r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL0r
#define WRITEALL_AN_X4_LD_BASE_ABIL0r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c4
 * DESC:     Local Device BASE ABILITIES REG 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_10G_KR1     Base Page Bit A2
 *     BASE_40G_KR4     Base page Bit A3
 *     BASE_40G_CR4     Base Page Bit A4
 *     BASE_100G_KR4    Base Page Bit A7
 *     BASE_100G_CR4    Base Page Bit A8
 *     BASE_1G_KX1      Base Page Bit A0
 *     CL73_PAUSE       Pause Ability[7:6]
 *     FEC_REQ          Forward Error CorrectionIf neither device requests FEC, then FEC is not done.
 *     NEXT_PAGE        Next Page ability bit.
 *     CL73_REMOTE_FAULT CL73 AN Advertisement Register (7.16.13) Remote Fault field.Specifies whether the Remote Fault field should be set in the CL73 base pages that are transmitted.0 = no fault1 = fault
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r (0x0000c1c4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil1[1];
	uint32_t _an_x4_ld_base_abil1;
} BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CLR(r) (r).an_x4_ld_base_abil1[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_SET(r,d) (r).an_x4_ld_base_abil1[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_GET(r) (r).an_x4_ld_base_abil1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_1G_KX1f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_1G_KX1f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_GET(r) ((((r).an_x4_ld_base_abil1[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_GET(r) (((r).an_x4_ld_base_abil1[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_SET(r,f) (r).an_x4_ld_base_abil1[0]=(((r).an_x4_ld_base_abil1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r,(_r._an_x4_ld_base_abil1))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r,(_r._an_x4_ld_base_abil1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r,(_r._an_x4_ld_base_abil1))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil1))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil1))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL1r BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r
#define AN_X4_LD_BASE_ABIL1r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_t AN_X4_LD_BASE_ABIL1r_t;
#define AN_X4_LD_BASE_ABIL1r_CLR BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CLR
#define AN_X4_LD_BASE_ABIL1r_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_SET
#define AN_X4_LD_BASE_ABIL1r_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_GET
#define AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_GET
#define AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_REMOTE_FAULTf_SET
#define AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_GET
#define AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_NEXT_PAGEf_SET
#define AN_X4_LD_BASE_ABIL1r_FEC_REQf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_GET
#define AN_X4_LD_BASE_ABIL1r_FEC_REQf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_FEC_REQf_SET
#define AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_GET
#define AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_CL73_PAUSEf_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_1G_KX1f_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_1G_KX1f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_1G_KX1f_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_1G_KX1f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_CR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_100G_KR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_CR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_40G_KR4f_SET
#define AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_GET
#define AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r_BASE_10G_KR1f_SET
#define READ_AN_X4_LD_BASE_ABIL1r BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL1r
#define WRITE_AN_X4_LD_BASE_ABIL1r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL1r
#define MODIFY_AN_X4_LD_BASE_ABIL1r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL1r
#define READLN_AN_X4_LD_BASE_ABIL1r BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL1r
#define WRITELN_AN_X4_LD_BASE_ABIL1r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL1r
#define WRITEALL_AN_X4_LD_BASE_ABIL1r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_BAM_ABIL
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c5
 * DESC:     Local Device BAM ABILITIES
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL73_BAM_CODE    BAM code
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr (0x0000c1c5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BAM_ABIL.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_ld_bam_abil[1];
	uint32_t _an_x4_ld_bam_abil;
} BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_CLR(r) (r).an_x4_ld_bam_abil[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_SET(r,d) (r).an_x4_ld_bam_abil[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_GET(r) (r).an_x4_ld_bam_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_GET(r) (((r).an_x4_ld_bam_abil[0]) & 0x1ff)
#define BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_SET(r,f) (r).an_x4_ld_bam_abil[0]=(((r).an_x4_ld_bam_abil[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access AN_X4_LD_BAM_ABIL.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr,(_r._an_x4_ld_bam_abil))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr,(_r._an_x4_ld_bam_abil)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr,(_r._an_x4_ld_bam_abil))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_BAM_ABILr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_bam_abil))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BAM_ABILr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_bam_abil))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BAM_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_bam_abil))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BAM_ABILr BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr
#define AN_X4_LD_BAM_ABILr_SIZE BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_t AN_X4_LD_BAM_ABILr_t;
#define AN_X4_LD_BAM_ABILr_CLR BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_CLR
#define AN_X4_LD_BAM_ABILr_SET BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_SET
#define AN_X4_LD_BAM_ABILr_GET BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_GET
#define AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_GET BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_GET
#define AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_SET BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr_CL73_BAM_CODEf_SET
#define READ_AN_X4_LD_BAM_ABILr BCMI_TSCD_XGXS_READ_AN_X4_LD_BAM_ABILr
#define WRITE_AN_X4_LD_BAM_ABILr BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BAM_ABILr
#define MODIFY_AN_X4_LD_BAM_ABILr BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BAM_ABILr
#define READLN_AN_X4_LD_BAM_ABILr BCMI_TSCD_XGXS_READLN_AN_X4_LD_BAM_ABILr
#define WRITELN_AN_X4_LD_BAM_ABILr BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BAM_ABILr
#define WRITEALL_AN_X4_LD_BAM_ABILr BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BAM_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_BAM_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_CL73_CTLS
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c6
 * DESC:     CL73 AN MISC CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PD_2P5G_KX_EN    Setting this bit to 1 enables 2P5G KX Parallel Detect.
 *     PD_KX_EN         Setting this bit to 1 enables 1G KX Parallel Detect.
 *     AN_GOOD_TRAP     Trap the TLA_SEQUENCER in its AN_GOOD state.
 *     AN_GOOD_CHECK_TRAP Trap the TLA_SEQUENCER in its AN_GOOD_CHECK state.
 *     LINKFAILTIMER_DIS Ignore link_fail_inhibit timer.
 *     LINKFAILTIMERQUAL_EN Wait for long enough to link_fail_inhibit_timer to expire.
 *     AN_FAIL_COUNT_LIMIT Number of times AN may retry after AN failureIt indicates the max value of an_fail_count register
 *     AN_OUI_OVERRIDE_HPAM_DET bit 3: require programmable OUI to detect CL73 HP mode
 *     AN_OUI_OVERRIDE_HPAM_ADV bit 2: advertise programmable OUI for CL73 HP mode
 *     AN_OUI_OVERRIDE_BAM73_DET bit 1: require programmable OUI to detect CL73 BAM
 *     AN_OUI_OVERRIDE_BAM73_ADV bit 0: advertise programmable OUI in CL73 BAM
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr (0x0000c1c6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_CL73_CTLS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_s {
	uint32_t v[1];
	uint32_t an_x4_cl73_ctls[1];
	uint32_t _an_x4_cl73_ctls;
} BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_t;

#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_CLR(r) (r).an_x4_cl73_ctls[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_SET(r,d) (r).an_x4_cl73_ctls[0] = d
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_GET(r) (r).an_x4_cl73_ctls[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_ADVf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_ADVf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_DETf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_DETf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_ADVf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_ADVf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_DETf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_DETf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 6) & 0xf)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0xf << 6)) | ((((uint32_t)f) & 0xf) << 6)) | (15 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_KX_ENf_GET(r) ((((r).an_x4_cl73_ctls[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_KX_ENf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_2P5G_KX_ENf_GET(r) (((r).an_x4_cl73_ctls[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_2P5G_KX_ENf_SET(r,f) (r).an_x4_cl73_ctls[0]=(((r).an_x4_cl73_ctls[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_CL73_CTLS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_CL73_CTLSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr,(_r._an_x4_cl73_ctls))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_CL73_CTLSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr,(_r._an_x4_cl73_ctls)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_CL73_CTLSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr,(_r._an_x4_cl73_ctls))
#define BCMI_TSCD_XGXS_READLN_AN_X4_CL73_CTLSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_ctls))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_CL73_CTLSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_cl73_ctls))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_CL73_CTLSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_cl73_ctls))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_CL73_CTLSr BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr
#define AN_X4_CL73_CTLSr_SIZE BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_t AN_X4_CL73_CTLSr_t;
#define AN_X4_CL73_CTLSr_CLR BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_CLR
#define AN_X4_CL73_CTLSr_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_SET
#define AN_X4_CL73_CTLSr_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_GET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_ADVf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_ADVf_GET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_ADVf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_ADVf_SET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_DETf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_DETf_GET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_DETf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_BAM73_DETf_SET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_ADVf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_ADVf_GET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_ADVf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_ADVf_SET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_DETf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_DETf_GET
#define AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_DETf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_OUI_OVERRIDE_HPAM_DETf_SET
#define AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_GET
#define AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_FAIL_COUNT_LIMITf_SET
#define AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_GET
#define AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMERQUAL_ENf_SET
#define AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_GET
#define AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_LINKFAILTIMER_DISf_SET
#define AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_GET
#define AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_CHECK_TRAPf_SET
#define AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_GET
#define AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_AN_GOOD_TRAPf_SET
#define AN_X4_CL73_CTLSr_PD_KX_ENf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_KX_ENf_GET
#define AN_X4_CL73_CTLSr_PD_KX_ENf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_KX_ENf_SET
#define AN_X4_CL73_CTLSr_PD_2P5G_KX_ENf_GET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_2P5G_KX_ENf_GET
#define AN_X4_CL73_CTLSr_PD_2P5G_KX_ENf_SET BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr_PD_2P5G_KX_ENf_SET
#define READ_AN_X4_CL73_CTLSr BCMI_TSCD_XGXS_READ_AN_X4_CL73_CTLSr
#define WRITE_AN_X4_CL73_CTLSr BCMI_TSCD_XGXS_WRITE_AN_X4_CL73_CTLSr
#define MODIFY_AN_X4_CL73_CTLSr BCMI_TSCD_XGXS_MODIFY_AN_X4_CL73_CTLSr
#define READLN_AN_X4_CL73_CTLSr BCMI_TSCD_XGXS_READLN_AN_X4_CL73_CTLSr
#define WRITELN_AN_X4_CL73_CTLSr BCMI_TSCD_XGXS_WRITELN_AN_X4_CL73_CTLSr
#define WRITEALL_AN_X4_CL73_CTLSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_CL73_CTLSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_CL73_CTLSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL2
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c7
 * DESC:     Local Device BASE ABILITIES REG 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_50G_CR2_EN  Enable Base page 50G CR2 bit position
 *     BASE_50G_CR2_SEL Base page 50G CR2 bit position
 *     BASE_50G_KR2_EN  Enable Base page 50G KR2 bit position
 *     BASE_50G_KR2_SEL Base page 50G KR2 bit position
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r (0x0000c1c7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL2.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil2[1];
	uint32_t _an_x4_ld_base_abil2;
} BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_CLR(r) (r).an_x4_ld_base_abil2[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_SET(r,d) (r).an_x4_ld_base_abil2[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_GET(r) (r).an_x4_ld_base_abil2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_SELf_GET(r) ((((r).an_x4_ld_base_abil2[0]) >> 7) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_SELf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_ENf_GET(r) ((((r).an_x4_ld_base_abil2[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_ENf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_SELf_GET(r) ((((r).an_x4_ld_base_abil2[0]) >> 1) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_SELf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_ENf_GET(r) (((r).an_x4_ld_base_abil2[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_ENf_SET(r,f) (r).an_x4_ld_base_abil2[0]=(((r).an_x4_ld_base_abil2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL2.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r,(_r._an_x4_ld_base_abil2))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r,(_r._an_x4_ld_base_abil2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r,(_r._an_x4_ld_base_abil2))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil2))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil2))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL2r BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r
#define AN_X4_LD_BASE_ABIL2r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_t AN_X4_LD_BASE_ABIL2r_t;
#define AN_X4_LD_BASE_ABIL2r_CLR BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_CLR
#define AN_X4_LD_BASE_ABIL2r_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_SET
#define AN_X4_LD_BASE_ABIL2r_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_SELf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_SELf_SET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_ENf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_KR2_ENf_SET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_SELf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_SELf_SET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_ENf_GET
#define AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r_BASE_50G_CR2_ENf_SET
#define READ_AN_X4_LD_BASE_ABIL2r BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL2r
#define WRITE_AN_X4_LD_BASE_ABIL2r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL2r
#define MODIFY_AN_X4_LD_BASE_ABIL2r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL2r
#define READLN_AN_X4_LD_BASE_ABIL2r BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL2r
#define WRITELN_AN_X4_LD_BASE_ABIL2r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL2r
#define WRITEALL_AN_X4_LD_BASE_ABIL2r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL3
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c8
 * DESC:     Local Device BASE ABILITIES REG 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_25G_CR1_EN  Enable Base page 25G CR1 bit position
 *     BASE_25G_CR1_SEL Base page 25G CR1 bit position
 *     BASE_25G_KR1_EN  Enable Base page 25G KR1 bit position
 *     BASE_25G_KR1_SEL Base page 25G KR1 bit position
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r (0x0000c1c8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL3.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil3[1];
	uint32_t _an_x4_ld_base_abil3;
} BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_CLR(r) (r).an_x4_ld_base_abil3[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_SET(r,d) (r).an_x4_ld_base_abil3[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_GET(r) (r).an_x4_ld_base_abil3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_SELf_GET(r) ((((r).an_x4_ld_base_abil3[0]) >> 7) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_SELf_SET(r,f) (r).an_x4_ld_base_abil3[0]=(((r).an_x4_ld_base_abil3[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_ENf_GET(r) ((((r).an_x4_ld_base_abil3[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_ENf_SET(r,f) (r).an_x4_ld_base_abil3[0]=(((r).an_x4_ld_base_abil3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_SELf_GET(r) ((((r).an_x4_ld_base_abil3[0]) >> 1) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_SELf_SET(r,f) (r).an_x4_ld_base_abil3[0]=(((r).an_x4_ld_base_abil3[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_ENf_GET(r) (((r).an_x4_ld_base_abil3[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_ENf_SET(r,f) (r).an_x4_ld_base_abil3[0]=(((r).an_x4_ld_base_abil3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL3.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r,(_r._an_x4_ld_base_abil3))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r,(_r._an_x4_ld_base_abil3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r,(_r._an_x4_ld_base_abil3))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil3))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil3))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL3r BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r
#define AN_X4_LD_BASE_ABIL3r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_t AN_X4_LD_BASE_ABIL3r_t;
#define AN_X4_LD_BASE_ABIL3r_CLR BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_CLR
#define AN_X4_LD_BASE_ABIL3r_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_SET
#define AN_X4_LD_BASE_ABIL3r_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_SELf_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_SELf_SET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_ENf_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_KR1_ENf_SET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_SELf_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_SELf_SET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_ENf_GET
#define AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r_BASE_25G_CR1_ENf_SET
#define READ_AN_X4_LD_BASE_ABIL3r BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL3r
#define WRITE_AN_X4_LD_BASE_ABIL3r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL3r
#define MODIFY_AN_X4_LD_BASE_ABIL3r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL3r
#define READLN_AN_X4_LD_BASE_ABIL3r BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL3r
#define WRITELN_AN_X4_LD_BASE_ABIL3r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL3r
#define WRITEALL_AN_X4_LD_BASE_ABIL3r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL4
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1c9
 * DESC:     Local Device BASE ABILITIES REG 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_25G_CRS1_EN Enable Base page 25G CR1 bit position
 *     BASE_25G_CRS1_SEL Base page 25G CR1 bit position
 *     BASE_25G_KRS1_EN Enable Base page 25G KR1 bit position
 *     BASE_25G_KRS1_SEL Base page 25G KR1 bit position
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r (0x0000c1c9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL4.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil4[1];
	uint32_t _an_x4_ld_base_abil4;
} BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_CLR(r) (r).an_x4_ld_base_abil4[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_SET(r,d) (r).an_x4_ld_base_abil4[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_GET(r) (r).an_x4_ld_base_abil4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_SELf_GET(r) ((((r).an_x4_ld_base_abil4[0]) >> 7) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_SELf_SET(r,f) (r).an_x4_ld_base_abil4[0]=(((r).an_x4_ld_base_abil4[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_ENf_GET(r) ((((r).an_x4_ld_base_abil4[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_ENf_SET(r,f) (r).an_x4_ld_base_abil4[0]=(((r).an_x4_ld_base_abil4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_SELf_GET(r) ((((r).an_x4_ld_base_abil4[0]) >> 1) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_SELf_SET(r,f) (r).an_x4_ld_base_abil4[0]=(((r).an_x4_ld_base_abil4[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_ENf_GET(r) (((r).an_x4_ld_base_abil4[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_ENf_SET(r,f) (r).an_x4_ld_base_abil4[0]=(((r).an_x4_ld_base_abil4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL4.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r,(_r._an_x4_ld_base_abil4))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r,(_r._an_x4_ld_base_abil4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r,(_r._an_x4_ld_base_abil4))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil4))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil4))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL4r BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r
#define AN_X4_LD_BASE_ABIL4r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_t AN_X4_LD_BASE_ABIL4r_t;
#define AN_X4_LD_BASE_ABIL4r_CLR BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_CLR
#define AN_X4_LD_BASE_ABIL4r_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_SET
#define AN_X4_LD_BASE_ABIL4r_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_GET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_SELf_GET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_SELf_SET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_ENf_GET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_KRS1_ENf_SET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_SELf_GET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_SELf_SET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_ENf_GET
#define AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r_BASE_25G_CRS1_ENf_SET
#define READ_AN_X4_LD_BASE_ABIL4r BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL4r
#define WRITE_AN_X4_LD_BASE_ABIL4r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL4r
#define MODIFY_AN_X4_LD_BASE_ABIL4r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL4r
#define READLN_AN_X4_LD_BASE_ABIL4r BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL4r
#define WRITELN_AN_X4_LD_BASE_ABIL4r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL4r
#define WRITEALL_AN_X4_LD_BASE_ABIL4r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_BASE_ABIL5
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1ca
 * DESC:     Local Device BASE ABILITIES REG 5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     BASE_2P5G_EN     Enable Base page 2.5G bit position and detection from LP
 *     BASE_2P5G_SEL    Base page 2.5G bit position Valid values are 6 thru 24, one of the available bits in the CL73 Base Page Technology Ability FieldValue 6 corresponds to bit D27 and Value 24 corresponds to bit D45 of the CL73 Base Page
 *     BASE_5P0G_EN     Enable Base page 5.0G bit position and detection from LP
 *     BASE_5P0G_SEL    Base page 5.0G bit position.Valid values are 6 thru 24, one of the available bits in the CL73 Base Page Technology Ability FieldValue 6 corresponds to bit D27 and Value 24 corresponds to bit D45 of the CL73 Base Page
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r (0x0000c1ca | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_BASE_ABIL5.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_base_abil5[1];
	uint32_t _an_x4_ld_base_abil5;
} BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_CLR(r) (r).an_x4_ld_base_abil5[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_SET(r,d) (r).an_x4_ld_base_abil5[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_GET(r) (r).an_x4_ld_base_abil5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_SELf_GET(r) ((((r).an_x4_ld_base_abil5[0]) >> 7) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_SELf_SET(r,f) (r).an_x4_ld_base_abil5[0]=(((r).an_x4_ld_base_abil5[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_ENf_GET(r) ((((r).an_x4_ld_base_abil5[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_ENf_SET(r,f) (r).an_x4_ld_base_abil5[0]=(((r).an_x4_ld_base_abil5[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_SELf_GET(r) ((((r).an_x4_ld_base_abil5[0]) >> 1) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_SELf_SET(r,f) (r).an_x4_ld_base_abil5[0]=(((r).an_x4_ld_base_abil5[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_ENf_GET(r) (((r).an_x4_ld_base_abil5[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_ENf_SET(r,f) (r).an_x4_ld_base_abil5[0]=(((r).an_x4_ld_base_abil5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_BASE_ABIL5.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r,(_r._an_x4_ld_base_abil5))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r,(_r._an_x4_ld_base_abil5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r,(_r._an_x4_ld_base_abil5))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil5))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_base_abil5))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_base_abil5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_BASE_ABIL5r BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r
#define AN_X4_LD_BASE_ABIL5r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_t AN_X4_LD_BASE_ABIL5r_t;
#define AN_X4_LD_BASE_ABIL5r_CLR BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_CLR
#define AN_X4_LD_BASE_ABIL5r_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_SET
#define AN_X4_LD_BASE_ABIL5r_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_GET
#define AN_X4_LD_BASE_ABIL5r_BASE_5P0G_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_SELf_GET
#define AN_X4_LD_BASE_ABIL5r_BASE_5P0G_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_SELf_SET
#define AN_X4_LD_BASE_ABIL5r_BASE_5P0G_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_ENf_GET
#define AN_X4_LD_BASE_ABIL5r_BASE_5P0G_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_5P0G_ENf_SET
#define AN_X4_LD_BASE_ABIL5r_BASE_2P5G_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_SELf_GET
#define AN_X4_LD_BASE_ABIL5r_BASE_2P5G_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_SELf_SET
#define AN_X4_LD_BASE_ABIL5r_BASE_2P5G_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_ENf_GET
#define AN_X4_LD_BASE_ABIL5r_BASE_2P5G_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r_BASE_2P5G_ENf_SET
#define READ_AN_X4_LD_BASE_ABIL5r BCMI_TSCD_XGXS_READ_AN_X4_LD_BASE_ABIL5r
#define WRITE_AN_X4_LD_BASE_ABIL5r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_BASE_ABIL5r
#define MODIFY_AN_X4_LD_BASE_ABIL5r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_BASE_ABIL5r
#define READLN_AN_X4_LD_BASE_ABIL5r BCMI_TSCD_XGXS_READLN_AN_X4_LD_BASE_ABIL5r
#define WRITELN_AN_X4_LD_BASE_ABIL5r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_BASE_ABIL5r
#define WRITEALL_AN_X4_LD_BASE_ABIL5r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_BASE_ABIL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_BASE_ABIL5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_FEC_BASEPAGE_ABIL
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1cb
 * DESC:     Local Device BASE_RS FEC REQ Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RS_FEC_REQ_EN    Enable Advertisement of RS FEC Request (CL91) for 25G C(K)R(S). 0: Disable, 1: Enable
 *     RS_FEC_REQ_SEL   Advertised position bit in BASE PAGE for RS FEC REQ.AN will keep looking for RS_FEC request from LPif this field is Non-Zero. To stop AN to even look, SW MUSTset this field to 0.
 *     BASE_R_FEC_REQ_EN Enable Advertisement of BASE FEC Request (CL74) for 25G C(K)R(S). 0: Disable, 1: Enable
 *     BASE_R_FEC_REQ_SEL Advertised position bit in BASE PAGE for BASE R FEC REQ.AN will keep looking for BASE_R_FEC request from LPif this field is Non-Zero. To stop AN to even look, SW MUSTset this field to 0.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr (0x0000c1cb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_FEC_BASEPAGE_ABIL.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_s {
	uint32_t v[1];
	uint32_t an_x4_ld_fec_basepage_abil[1];
	uint32_t _an_x4_ld_fec_basepage_abil;
} BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_CLR(r) (r).an_x4_ld_fec_basepage_abil[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_SET(r,d) (r).an_x4_ld_fec_basepage_abil[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_GET(r) (r).an_x4_ld_fec_basepage_abil[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_SELf_GET(r) ((((r).an_x4_ld_fec_basepage_abil[0]) >> 7) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_SELf_SET(r,f) (r).an_x4_ld_fec_basepage_abil[0]=(((r).an_x4_ld_fec_basepage_abil[0] & ~((uint32_t)0x1f << 7)) | ((((uint32_t)f) & 0x1f) << 7)) | (31 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_ENf_GET(r) ((((r).an_x4_ld_fec_basepage_abil[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_ENf_SET(r,f) (r).an_x4_ld_fec_basepage_abil[0]=(((r).an_x4_ld_fec_basepage_abil[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_SELf_GET(r) ((((r).an_x4_ld_fec_basepage_abil[0]) >> 1) & 0x1f)
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_SELf_SET(r,f) (r).an_x4_ld_fec_basepage_abil[0]=(((r).an_x4_ld_fec_basepage_abil[0] & ~((uint32_t)0x1f << 1)) | ((((uint32_t)f) & 0x1f) << 1)) | (31 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_ENf_GET(r) (((r).an_x4_ld_fec_basepage_abil[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_ENf_SET(r,f) (r).an_x4_ld_fec_basepage_abil[0]=(((r).an_x4_ld_fec_basepage_abil[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_FEC_BASEPAGE_ABIL.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_FEC_BASEPAGE_ABILr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr,(_r._an_x4_ld_fec_basepage_abil))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_FEC_BASEPAGE_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr,(_r._an_x4_ld_fec_basepage_abil)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_FEC_BASEPAGE_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr,(_r._an_x4_ld_fec_basepage_abil))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_FEC_BASEPAGE_ABILr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_fec_basepage_abil))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_FEC_BASEPAGE_ABILr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_fec_basepage_abil))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_FEC_BASEPAGE_ABILr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_fec_basepage_abil))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_FEC_BASEPAGE_ABILr BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr
#define AN_X4_LD_FEC_BASEPAGE_ABILr_SIZE BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_t AN_X4_LD_FEC_BASEPAGE_ABILr_t;
#define AN_X4_LD_FEC_BASEPAGE_ABILr_CLR BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_CLR
#define AN_X4_LD_FEC_BASEPAGE_ABILr_SET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_SET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_GET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_GET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_SELf_GET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_SELf_SET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_ENf_GET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_BASE_R_FEC_REQ_ENf_SET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_SELf_GET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_SELf_GET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_SELf_SET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_SELf_SET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_ENf_GET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_ENf_GET
#define AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_ENf_SET BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr_RS_FEC_REQ_ENf_SET
#define READ_AN_X4_LD_FEC_BASEPAGE_ABILr BCMI_TSCD_XGXS_READ_AN_X4_LD_FEC_BASEPAGE_ABILr
#define WRITE_AN_X4_LD_FEC_BASEPAGE_ABILr BCMI_TSCD_XGXS_WRITE_AN_X4_LD_FEC_BASEPAGE_ABILr
#define MODIFY_AN_X4_LD_FEC_BASEPAGE_ABILr BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_FEC_BASEPAGE_ABILr
#define READLN_AN_X4_LD_FEC_BASEPAGE_ABILr BCMI_TSCD_XGXS_READLN_AN_X4_LD_FEC_BASEPAGE_ABILr
#define WRITELN_AN_X4_LD_FEC_BASEPAGE_ABILr BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_FEC_BASEPAGE_ABILr
#define WRITEALL_AN_X4_LD_FEC_BASEPAGE_ABILr BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_FEC_BASEPAGE_ABILr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_FEC_BASEPAGE_ABILr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_SW_AN_BASE_PAGE0
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1cc
 * DESC:     SW AN Base Page 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_AN_BP_0       LOCAL DEVICE PAGE 2 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r (0x0000c1cc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_AN_BASE_PAGE0.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_an_base_page0[1];
	uint32_t _an_x4_sw_an_base_page0;
} BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_t;

#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_CLR(r) (r).an_x4_sw_an_base_page0[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SET(r,d) (r).an_x4_sw_an_base_page0[0] = d
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_GET(r) (r).an_x4_sw_an_base_page0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_GET(r) (((r).an_x4_sw_an_base_page0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_SET(r,f) (r).an_x4_sw_an_base_page0[0]=(((r).an_x4_sw_an_base_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_SW_AN_BASE_PAGE0.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r,(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r,(_r._an_x4_sw_an_base_page0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r,(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCD_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page0))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_an_base_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r
#define AN_X4_SW_AN_BASE_PAGE0r_SIZE BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_t AN_X4_SW_AN_BASE_PAGE0r_t;
#define AN_X4_SW_AN_BASE_PAGE0r_CLR BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_CLR
#define AN_X4_SW_AN_BASE_PAGE0r_SET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SET
#define AN_X4_SW_AN_BASE_PAGE0r_GET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_GET
#define AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_GET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_GET
#define AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_SET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r_SW_AN_BP_0f_SET
#define READ_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCD_XGXS_READ_AN_X4_SW_AN_BASE_PAGE0r
#define WRITE_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCD_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE0r
#define MODIFY_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE0r
#define READLN_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCD_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE0r
#define WRITELN_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE0r
#define WRITEALL_AN_X4_SW_AN_BASE_PAGE0r BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_SW_AN_BASE_PAGE1
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1cd
 * DESC:     SW AN Base Page 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_AN_BP_1       LOCAL DEVICE PAGE 1 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r (0x0000c1cd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_AN_BASE_PAGE1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_an_base_page1[1];
	uint32_t _an_x4_sw_an_base_page1;
} BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_t;

#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_CLR(r) (r).an_x4_sw_an_base_page1[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SET(r,d) (r).an_x4_sw_an_base_page1[0] = d
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_GET(r) (r).an_x4_sw_an_base_page1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_GET(r) (((r).an_x4_sw_an_base_page1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_SET(r,f) (r).an_x4_sw_an_base_page1[0]=(((r).an_x4_sw_an_base_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_SW_AN_BASE_PAGE1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r,(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r,(_r._an_x4_sw_an_base_page1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r,(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCD_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page1))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_an_base_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r
#define AN_X4_SW_AN_BASE_PAGE1r_SIZE BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_t AN_X4_SW_AN_BASE_PAGE1r_t;
#define AN_X4_SW_AN_BASE_PAGE1r_CLR BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_CLR
#define AN_X4_SW_AN_BASE_PAGE1r_SET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SET
#define AN_X4_SW_AN_BASE_PAGE1r_GET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_GET
#define AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_GET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_GET
#define AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_SET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r_SW_AN_BP_1f_SET
#define READ_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCD_XGXS_READ_AN_X4_SW_AN_BASE_PAGE1r
#define WRITE_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCD_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE1r
#define MODIFY_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE1r
#define READLN_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCD_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE1r
#define WRITELN_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE1r
#define WRITEALL_AN_X4_SW_AN_BASE_PAGE1r BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_SW_AN_BASE_PAGE2
 * BLOCKS:   AN_X4_ABILITIES
 * REGADDR:  0xc1ce
 * DESC:     SW AN Base Page 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     SW_AN_BP_2       LOCAL DEVICE PAGE 0 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r (0x0000c1ce | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_AN_BASE_PAGE2.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_sw_an_base_page2[1];
	uint32_t _an_x4_sw_an_base_page2;
} BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_t;

#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_CLR(r) (r).an_x4_sw_an_base_page2[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SET(r,d) (r).an_x4_sw_an_base_page2[0] = d
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_GET(r) (r).an_x4_sw_an_base_page2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_GET(r) (((r).an_x4_sw_an_base_page2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_SET(r,f) (r).an_x4_sw_an_base_page2[0]=(((r).an_x4_sw_an_base_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_SW_AN_BASE_PAGE2.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r,(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r,(_r._an_x4_sw_an_base_page2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r,(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCD_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_an_base_page2))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_an_base_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r
#define AN_X4_SW_AN_BASE_PAGE2r_SIZE BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_t AN_X4_SW_AN_BASE_PAGE2r_t;
#define AN_X4_SW_AN_BASE_PAGE2r_CLR BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_CLR
#define AN_X4_SW_AN_BASE_PAGE2r_SET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SET
#define AN_X4_SW_AN_BASE_PAGE2r_GET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_GET
#define AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_GET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_GET
#define AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_SET BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r_SW_AN_BP_2f_SET
#define READ_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCD_XGXS_READ_AN_X4_SW_AN_BASE_PAGE2r
#define WRITE_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCD_XGXS_WRITE_AN_X4_SW_AN_BASE_PAGE2r
#define MODIFY_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_AN_BASE_PAGE2r
#define READLN_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCD_XGXS_READLN_AN_X4_SW_AN_BASE_PAGE2r
#define WRITELN_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_AN_BASE_PAGE2r
#define WRITEALL_AN_X4_SW_AN_BASE_PAGE2r BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_AN_BASE_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_SW_AN_BASE_PAGE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_R_CL73_STS
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d0
 * DESC:     R_CL73 Status 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DME_STATE        DME Receive State.
 *     DME_PAGE         Valid DME page received.
 *     DME_MV_PAIR      DME Delimiter detected.
 *     CLK_TRANS_MISS   Missing DME clock transition detected.
 *     PAGE_TOO_LONG    Too long DME page detected.
 *     PAGE_TOO_SHORT   Too short DME page detected.
 *     PULSE_TOO_LONG   Too long DME pulse detected.
 *     PULSE_TOO_MODERATE Too moderate DME pulse detected.
 *     PULSE_TOO_SHORT  Too short DME pulse detected.
 *     DME_LOCKED       Locked on DME signal.
 *     CL73_FIFO_FULL   CL73 Fifo Full.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr (0x0000c1d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_R_CL73_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_r_cl73_sts[1];
	uint32_t _an_x4_r_cl73_sts;
} BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_t;

#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CLR(r) (r).an_x4_r_cl73_sts[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_SET(r,d) (r).an_x4_r_cl73_sts[0] = d
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_GET(r) (r).an_x4_r_cl73_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_GET(r) ((((r).an_x4_r_cl73_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_GET(r) (((r).an_x4_r_cl73_sts[0]) & 0x3)
#define BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_SET(r,f) (r).an_x4_r_cl73_sts[0]=(((r).an_x4_r_cl73_sts[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AN_X4_R_CL73_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_R_CL73_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr,(_r._an_x4_r_cl73_sts))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_R_CL73_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr,(_r._an_x4_r_cl73_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_R_CL73_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr,(_r._an_x4_r_cl73_sts))
#define BCMI_TSCD_XGXS_READLN_AN_X4_R_CL73_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_r_cl73_sts))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_R_CL73_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_r_cl73_sts))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_R_CL73_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_r_cl73_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_R_CL73_STSr BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr
#define AN_X4_R_CL73_STSr_SIZE BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_t AN_X4_R_CL73_STSr_t;
#define AN_X4_R_CL73_STSr_CLR BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CLR
#define AN_X4_R_CL73_STSr_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_SET
#define AN_X4_R_CL73_STSr_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_GET
#define AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_GET
#define AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CL73_FIFO_FULLf_SET
#define AN_X4_R_CL73_STSr_DME_LOCKEDf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_GET
#define AN_X4_R_CL73_STSr_DME_LOCKEDf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_LOCKEDf_SET
#define AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_GET
#define AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_SHORTf_SET
#define AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_GET
#define AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_MODERATEf_SET
#define AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_GET
#define AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PULSE_TOO_LONGf_SET
#define AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_GET
#define AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_SHORTf_SET
#define AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_GET
#define AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_PAGE_TOO_LONGf_SET
#define AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_GET
#define AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_CLK_TRANS_MISSf_SET
#define AN_X4_R_CL73_STSr_DME_MV_PAIRf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_GET
#define AN_X4_R_CL73_STSr_DME_MV_PAIRf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_MV_PAIRf_SET
#define AN_X4_R_CL73_STSr_DME_PAGEf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_GET
#define AN_X4_R_CL73_STSr_DME_PAGEf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_PAGEf_SET
#define AN_X4_R_CL73_STSr_DME_STATEf_GET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_GET
#define AN_X4_R_CL73_STSr_DME_STATEf_SET BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr_DME_STATEf_SET
#define READ_AN_X4_R_CL73_STSr BCMI_TSCD_XGXS_READ_AN_X4_R_CL73_STSr
#define WRITE_AN_X4_R_CL73_STSr BCMI_TSCD_XGXS_WRITE_AN_X4_R_CL73_STSr
#define MODIFY_AN_X4_R_CL73_STSr BCMI_TSCD_XGXS_MODIFY_AN_X4_R_CL73_STSr
#define READLN_AN_X4_R_CL73_STSr BCMI_TSCD_XGXS_READLN_AN_X4_R_CL73_STSr
#define WRITELN_AN_X4_R_CL73_STSr BCMI_TSCD_XGXS_WRITELN_AN_X4_R_CL73_STSr
#define WRITEALL_AN_X4_R_CL73_STSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_R_CL73_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_R_CL73_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_PXNG_STS
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d1
 * DESC:     CL73_PXNG Status 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CONSISTENCY_MISMATCH PXNG mismatch detected.
 *     COMPLETE_ACK     PXNG COMPLETE_ACKNOWLEDGE state.
 *     ACK_DETECT       PXNG ACKNOWLEDGE_DETECT state.
 *     ABILITY_DETECT   PXNG ABILITY_DETECT state.
 *     AN_ENABLE        PXNG AN_ENABLE state.
 *     ERROR_STATE      PXNG ERROR state.
 *     TRANSMIT_DISABLE PXNG TRANSMIT_DISABLE state
 *     NEXT_PAGE_WAIT   PXNG NEXT_PAGE_WAIT state.
 *     AN_GOOD_CHECK    PXNG AN_GOOD_CHECK state.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr (0x0000c1d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_PXNG_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_pxng_sts[1];
	uint32_t _an_x4_pxng_sts;
} BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_t;

#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_CLR(r) (r).an_x4_pxng_sts[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_SET(r,d) (r).an_x4_pxng_sts[0] = d
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_GET(r) (r).an_x4_pxng_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_GET(r) ((((r).an_x4_pxng_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_GET(r) (((r).an_x4_pxng_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_SET(r,f) (r).an_x4_pxng_sts[0]=(((r).an_x4_pxng_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_PXNG_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_PXNG_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_PXNG_STSr,(_r._an_x4_pxng_sts))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_PXNG_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PXNG_STSr,(_r._an_x4_pxng_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_PXNG_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PXNG_STSr,(_r._an_x4_pxng_sts))
#define BCMI_TSCD_XGXS_READLN_AN_X4_PXNG_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_PXNG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pxng_sts))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_PXNG_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PXNG_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pxng_sts))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_PXNG_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PXNG_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_pxng_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_PXNG_STSr BCMI_TSCD_XGXS_AN_X4_PXNG_STSr
#define AN_X4_PXNG_STSr_SIZE BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_t AN_X4_PXNG_STSr_t;
#define AN_X4_PXNG_STSr_CLR BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_CLR
#define AN_X4_PXNG_STSr_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_SET
#define AN_X4_PXNG_STSr_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_GET
#define AN_X4_PXNG_STSr_AN_GOOD_CHECKf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_GET
#define AN_X4_PXNG_STSr_AN_GOOD_CHECKf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_GOOD_CHECKf_SET
#define AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_GET
#define AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_NEXT_PAGE_WAITf_SET
#define AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_GET
#define AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_TRANSMIT_DISABLEf_SET
#define AN_X4_PXNG_STSr_ERROR_STATEf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_GET
#define AN_X4_PXNG_STSr_ERROR_STATEf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ERROR_STATEf_SET
#define AN_X4_PXNG_STSr_AN_ENABLEf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_GET
#define AN_X4_PXNG_STSr_AN_ENABLEf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_AN_ENABLEf_SET
#define AN_X4_PXNG_STSr_ABILITY_DETECTf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_GET
#define AN_X4_PXNG_STSr_ABILITY_DETECTf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ABILITY_DETECTf_SET
#define AN_X4_PXNG_STSr_ACK_DETECTf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_GET
#define AN_X4_PXNG_STSr_ACK_DETECTf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_ACK_DETECTf_SET
#define AN_X4_PXNG_STSr_COMPLETE_ACKf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_GET
#define AN_X4_PXNG_STSr_COMPLETE_ACKf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_COMPLETE_ACKf_SET
#define AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_GET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_GET
#define AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_SET BCMI_TSCD_XGXS_AN_X4_PXNG_STSr_CONSISTENCY_MISMATCHf_SET
#define READ_AN_X4_PXNG_STSr BCMI_TSCD_XGXS_READ_AN_X4_PXNG_STSr
#define WRITE_AN_X4_PXNG_STSr BCMI_TSCD_XGXS_WRITE_AN_X4_PXNG_STSr
#define MODIFY_AN_X4_PXNG_STSr BCMI_TSCD_XGXS_MODIFY_AN_X4_PXNG_STSr
#define READLN_AN_X4_PXNG_STSr BCMI_TSCD_XGXS_READLN_AN_X4_PXNG_STSr
#define WRITELN_AN_X4_PXNG_STSr BCMI_TSCD_XGXS_WRITELN_AN_X4_PXNG_STSr
#define WRITEALL_AN_X4_PXNG_STSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_PXNG_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_PXNG_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_PSEQ_STS
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d2
 * DESC:     CL73_PSEQ Status 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     HP_MODE          PSEQ Entered Hewlett-Packard mode.
 *     RX_BP            PSEQ Received base page.
 *     RX_NP            PSEQ Received next page.
 *     RX_MP_NULL       PSEQ Received message page 1.
 *     RX_MP_OUI        PSEQ Received message page 5.
 *     RX_MP_MISMATCH   PSEQ Received mismatching message page.
 *     RX_UP_OUI_MISMATCH PSEQ Received MPS-5 OUI mismatch.
 *     RX_UP_OUI_MATCH  PSEQ Received MPS-5 OUI match.
 *     RX_INVALID_SEQ   PSEQ Received invalid page sequence.
 *     RX_NP_TOGGLE_ERR PSEQ Received NP without T toggling.
 *     CL73_AN_COMPLETE PSEQ CL73 auto-neg is complete.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr (0x0000c1d2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_PSEQ_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_pseq_sts[1];
	uint32_t _an_x4_pseq_sts;
} BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_t;

#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_CLR(r) (r).an_x4_pseq_sts[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_SET(r,d) (r).an_x4_pseq_sts[0] = d
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_GET(r) (r).an_x4_pseq_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NPf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NPf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_BPf_GET(r) ((((r).an_x4_pseq_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_BPf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_GET(r) (((r).an_x4_pseq_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_SET(r,f) (r).an_x4_pseq_sts[0]=(((r).an_x4_pseq_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_PSEQ_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_PSEQ_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr,(_r._an_x4_pseq_sts))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_PSEQ_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr,(_r._an_x4_pseq_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_PSEQ_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr,(_r._an_x4_pseq_sts))
#define BCMI_TSCD_XGXS_READLN_AN_X4_PSEQ_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pseq_sts))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_PSEQ_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pseq_sts))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_PSEQ_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_pseq_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_PSEQ_STSr BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr
#define AN_X4_PSEQ_STSr_SIZE BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_t AN_X4_PSEQ_STSr_t;
#define AN_X4_PSEQ_STSr_CLR BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_CLR
#define AN_X4_PSEQ_STSr_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_SET
#define AN_X4_PSEQ_STSr_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_GET
#define AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_GET
#define AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_CL73_AN_COMPLETEf_SET
#define AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_GET
#define AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NP_TOGGLE_ERRf_SET
#define AN_X4_PSEQ_STSr_RX_INVALID_SEQf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_GET
#define AN_X4_PSEQ_STSr_RX_INVALID_SEQf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_INVALID_SEQf_SET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_GET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MATCHf_SET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_GET
#define AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_UP_OUI_MISMATCHf_SET
#define AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_GET
#define AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_MISMATCHf_SET
#define AN_X4_PSEQ_STSr_RX_MP_OUIf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_GET
#define AN_X4_PSEQ_STSr_RX_MP_OUIf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_OUIf_SET
#define AN_X4_PSEQ_STSr_RX_MP_NULLf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_GET
#define AN_X4_PSEQ_STSr_RX_MP_NULLf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_MP_NULLf_SET
#define AN_X4_PSEQ_STSr_RX_NPf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NPf_GET
#define AN_X4_PSEQ_STSr_RX_NPf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_NPf_SET
#define AN_X4_PSEQ_STSr_RX_BPf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_BPf_GET
#define AN_X4_PSEQ_STSr_RX_BPf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_RX_BPf_SET
#define AN_X4_PSEQ_STSr_HP_MODEf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_GET
#define AN_X4_PSEQ_STSr_HP_MODEf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr_HP_MODEf_SET
#define READ_AN_X4_PSEQ_STSr BCMI_TSCD_XGXS_READ_AN_X4_PSEQ_STSr
#define WRITE_AN_X4_PSEQ_STSr BCMI_TSCD_XGXS_WRITE_AN_X4_PSEQ_STSr
#define MODIFY_AN_X4_PSEQ_STSr BCMI_TSCD_XGXS_MODIFY_AN_X4_PSEQ_STSr
#define READLN_AN_X4_PSEQ_STSr BCMI_TSCD_XGXS_READLN_AN_X4_PSEQ_STSr
#define WRITELN_AN_X4_PSEQ_STSr BCMI_TSCD_XGXS_WRITELN_AN_X4_PSEQ_STSr
#define WRITEALL_AN_X4_PSEQ_STSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_PSEQ_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_PSEQ_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_PSEQ_RF
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d3
 * DESC:     PSEQ Remote Fault Status 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     REMOTE_FAULT_SET PSEQ Received a remote fault indication.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr (0x0000c1d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_PSEQ_RF.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_s {
	uint32_t v[1];
	uint32_t an_x4_pseq_rf[1];
	uint32_t _an_x4_pseq_rf;
} BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_t;

#define BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_CLR(r) (r).an_x4_pseq_rf[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_SET(r,d) (r).an_x4_pseq_rf[0] = d
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_GET(r) (r).an_x4_pseq_rf[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_REMOTE_FAULT_SETf_GET(r) (((r).an_x4_pseq_rf[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_REMOTE_FAULT_SETf_SET(r,f) (r).an_x4_pseq_rf[0]=(((r).an_x4_pseq_rf[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_PSEQ_RF.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_PSEQ_RFr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr,(_r._an_x4_pseq_rf))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_PSEQ_RFr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr,(_r._an_x4_pseq_rf)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_PSEQ_RFr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr,(_r._an_x4_pseq_rf))
#define BCMI_TSCD_XGXS_READLN_AN_X4_PSEQ_RFr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pseq_rf))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_PSEQ_RFr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_pseq_rf))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_PSEQ_RFr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_pseq_rf))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_PSEQ_RFr BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr
#define AN_X4_PSEQ_RFr_SIZE BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_t AN_X4_PSEQ_RFr_t;
#define AN_X4_PSEQ_RFr_CLR BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_CLR
#define AN_X4_PSEQ_RFr_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_SET
#define AN_X4_PSEQ_RFr_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_GET
#define AN_X4_PSEQ_RFr_REMOTE_FAULT_SETf_GET BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_REMOTE_FAULT_SETf_GET
#define AN_X4_PSEQ_RFr_REMOTE_FAULT_SETf_SET BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr_REMOTE_FAULT_SETf_SET
#define READ_AN_X4_PSEQ_RFr BCMI_TSCD_XGXS_READ_AN_X4_PSEQ_RFr
#define WRITE_AN_X4_PSEQ_RFr BCMI_TSCD_XGXS_WRITE_AN_X4_PSEQ_RFr
#define MODIFY_AN_X4_PSEQ_RFr BCMI_TSCD_XGXS_MODIFY_AN_X4_PSEQ_RFr
#define READLN_AN_X4_PSEQ_RFr BCMI_TSCD_XGXS_READLN_AN_X4_PSEQ_RFr
#define WRITELN_AN_X4_PSEQ_RFr BCMI_TSCD_XGXS_WRITELN_AN_X4_PSEQ_RFr
#define WRITEALL_AN_X4_PSEQ_RFr BCMI_TSCD_XGXS_WRITEALL_AN_X4_PSEQ_RFr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_PSEQ_RFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_UNEXP_PAGE
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d4
 * DESC:     PSEQ Unexpected page 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_UNEXPECTED_PAGE PSEQ Unexpected page received.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr (0x0000c1d4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_UNEXP_PAGE.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_s {
	uint32_t v[1];
	uint32_t an_x4_unexp_page[1];
	uint32_t _an_x4_unexp_page;
} BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_t;

#define BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_CLR(r) (r).an_x4_unexp_page[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_SET(r,d) (r).an_x4_unexp_page[0] = d
#define BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_GET(r) (r).an_x4_unexp_page[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_RX_UNEXPECTED_PAGEf_GET(r) (((r).an_x4_unexp_page[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_RX_UNEXPECTED_PAGEf_SET(r,f) (r).an_x4_unexp_page[0]=(((r).an_x4_unexp_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_UNEXP_PAGE.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_UNEXP_PAGEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr,(_r._an_x4_unexp_page))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_UNEXP_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr,(_r._an_x4_unexp_page)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_UNEXP_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr,(_r._an_x4_unexp_page))
#define BCMI_TSCD_XGXS_READLN_AN_X4_UNEXP_PAGEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_unexp_page))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_UNEXP_PAGEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_unexp_page))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_UNEXP_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_unexp_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_UNEXP_PAGEr BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr
#define AN_X4_UNEXP_PAGEr_SIZE BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_t AN_X4_UNEXP_PAGEr_t;
#define AN_X4_UNEXP_PAGEr_CLR BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_CLR
#define AN_X4_UNEXP_PAGEr_SET BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_SET
#define AN_X4_UNEXP_PAGEr_GET BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_GET
#define AN_X4_UNEXP_PAGEr_RX_UNEXPECTED_PAGEf_GET BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_RX_UNEXPECTED_PAGEf_GET
#define AN_X4_UNEXP_PAGEr_RX_UNEXPECTED_PAGEf_SET BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr_RX_UNEXPECTED_PAGEf_SET
#define READ_AN_X4_UNEXP_PAGEr BCMI_TSCD_XGXS_READ_AN_X4_UNEXP_PAGEr
#define WRITE_AN_X4_UNEXP_PAGEr BCMI_TSCD_XGXS_WRITE_AN_X4_UNEXP_PAGEr
#define MODIFY_AN_X4_UNEXP_PAGEr BCMI_TSCD_XGXS_MODIFY_AN_X4_UNEXP_PAGEr
#define READLN_AN_X4_UNEXP_PAGEr BCMI_TSCD_XGXS_READLN_AN_X4_UNEXP_PAGEr
#define WRITELN_AN_X4_UNEXP_PAGEr BCMI_TSCD_XGXS_WRITELN_AN_X4_UNEXP_PAGEr
#define WRITEALL_AN_X4_UNEXP_PAGEr BCMI_TSCD_XGXS_WRITEALL_AN_X4_UNEXP_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_UNEXP_PAGEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_BASE1
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d5
 * DESC:     PSEQ LP Base page 1 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE1         PSEQ LP Base page 1.15 -- Next Page14 -- Acknowledge: Value always 0, writes ignored13 -- Remote Fault12 -- some PHY ability11 -- pause10 -- asm_dir09:05 -- echoed nonce04:00 -- S4 S3 S2 S1 S0 Selector description0 0 0 0 0 Reserved for future Auto-Negotiation development0 0 0 0 1 IEEE Std 802.30 0 0 1 0 IEEE Std 802.9 ISLAN-16T0 0 0 1 1 IEEE Std 802.50 0 1 0 0 IEEE Std 13940 0 1 0 1 Reserved for future Auto-Negotiation development0 0 1 1 X Reserved for future Auto-Negotiation development0 1 X X X Reserved for future Auto-Negotiation development1 X X X X Reserved for future Auto-Negotiation developmentFor up-to-date information on the allocation of Auto-Negotiation Selector Fields, visit www.ieee802.org/3/selectors/selectors.html
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE1r (0x0000c1d5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base1[1];
	uint32_t _an_x4_lp_base1;
} BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_CLR(r) (r).an_x4_lp_base1[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_SET(r,d) (r).an_x4_lp_base1[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_GET(r) (r).an_x4_lp_base1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_GET(r) (((r).an_x4_lp_base1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_SET(r,f) (r).an_x4_lp_base1[0]=(((r).an_x4_lp_base1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_BASE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE1r,(_r._an_x4_lp_base1))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_BASE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE1r,(_r._an_x4_lp_base1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_BASE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE1r,(_r._an_x4_lp_base1))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_BASE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base1))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_BASE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base1))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_BASE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE1r BCMI_TSCD_XGXS_AN_X4_LP_BASE1r
#define AN_X4_LP_BASE1r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_t AN_X4_LP_BASE1r_t;
#define AN_X4_LP_BASE1r_CLR BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_CLR
#define AN_X4_LP_BASE1r_SET BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_SET
#define AN_X4_LP_BASE1r_GET BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_GET
#define AN_X4_LP_BASE1r_LP_BASE1f_GET BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_GET
#define AN_X4_LP_BASE1r_LP_BASE1f_SET BCMI_TSCD_XGXS_AN_X4_LP_BASE1r_LP_BASE1f_SET
#define READ_AN_X4_LP_BASE1r BCMI_TSCD_XGXS_READ_AN_X4_LP_BASE1r
#define WRITE_AN_X4_LP_BASE1r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_BASE1r
#define MODIFY_AN_X4_LP_BASE1r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_BASE1r
#define READLN_AN_X4_LP_BASE1r BCMI_TSCD_XGXS_READLN_AN_X4_LP_BASE1r
#define WRITELN_AN_X4_LP_BASE1r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_BASE1r
#define WRITEALL_AN_X4_LP_BASE1r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_BASE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_BASE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_BASE2
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d6
 * DESC:     PSEQ LP Base page 2 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE2         PSEQ LP Base page 2.15:11 Reserved for future10 -- 100G CR109 -- 40G CR48 -- 40G KR47 -- 10G KR6 -- 10G KX45 -- 1G KX04:00 -- transmitted nonce
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE2r (0x0000c1d6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE2.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base2[1];
	uint32_t _an_x4_lp_base2;
} BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_CLR(r) (r).an_x4_lp_base2[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_SET(r,d) (r).an_x4_lp_base2[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_GET(r) (r).an_x4_lp_base2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_GET(r) (((r).an_x4_lp_base2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_SET(r,f) (r).an_x4_lp_base2[0]=(((r).an_x4_lp_base2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE2.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_BASE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE2r,(_r._an_x4_lp_base2))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_BASE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE2r,(_r._an_x4_lp_base2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_BASE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE2r,(_r._an_x4_lp_base2))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_BASE2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base2))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_BASE2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base2))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_BASE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE2r BCMI_TSCD_XGXS_AN_X4_LP_BASE2r
#define AN_X4_LP_BASE2r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_t AN_X4_LP_BASE2r_t;
#define AN_X4_LP_BASE2r_CLR BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_CLR
#define AN_X4_LP_BASE2r_SET BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_SET
#define AN_X4_LP_BASE2r_GET BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_GET
#define AN_X4_LP_BASE2r_LP_BASE2f_GET BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_GET
#define AN_X4_LP_BASE2r_LP_BASE2f_SET BCMI_TSCD_XGXS_AN_X4_LP_BASE2r_LP_BASE2f_SET
#define READ_AN_X4_LP_BASE2r BCMI_TSCD_XGXS_READ_AN_X4_LP_BASE2r
#define WRITE_AN_X4_LP_BASE2r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_BASE2r
#define MODIFY_AN_X4_LP_BASE2r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_BASE2r
#define READLN_AN_X4_LP_BASE2r BCMI_TSCD_XGXS_READLN_AN_X4_LP_BASE2r
#define WRITELN_AN_X4_LP_BASE2r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_BASE2r
#define WRITEALL_AN_X4_LP_BASE2r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_BASE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_BASE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_BASE3
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d7
 * DESC:     PSEQ LP Base page 3 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_BASE3         PSEQ LP Base page 3.15 -- FEC requested14 -- FEC ability13:00 -- Reserved bits must be written with 0. A read returns an unknown value.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE3r (0x0000c1d7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_BASE3.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_base3[1];
	uint32_t _an_x4_lp_base3;
} BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_CLR(r) (r).an_x4_lp_base3[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_SET(r,d) (r).an_x4_lp_base3[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_GET(r) (r).an_x4_lp_base3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_GET(r) (((r).an_x4_lp_base3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_SET(r,f) (r).an_x4_lp_base3[0]=(((r).an_x4_lp_base3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_BASE3.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_BASE3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE3r,(_r._an_x4_lp_base3))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_BASE3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE3r,(_r._an_x4_lp_base3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_BASE3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE3r,(_r._an_x4_lp_base3))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_BASE3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base3))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_BASE3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_base3))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_BASE3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_BASE3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_base3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_BASE3r BCMI_TSCD_XGXS_AN_X4_LP_BASE3r
#define AN_X4_LP_BASE3r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_t AN_X4_LP_BASE3r_t;
#define AN_X4_LP_BASE3r_CLR BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_CLR
#define AN_X4_LP_BASE3r_SET BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_SET
#define AN_X4_LP_BASE3r_GET BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_GET
#define AN_X4_LP_BASE3r_LP_BASE3f_GET BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_GET
#define AN_X4_LP_BASE3r_LP_BASE3f_SET BCMI_TSCD_XGXS_AN_X4_LP_BASE3r_LP_BASE3f_SET
#define READ_AN_X4_LP_BASE3r BCMI_TSCD_XGXS_READ_AN_X4_LP_BASE3r
#define WRITE_AN_X4_LP_BASE3r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_BASE3r
#define MODIFY_AN_X4_LP_BASE3r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_BASE3r
#define READLN_AN_X4_LP_BASE3r BCMI_TSCD_XGXS_READLN_AN_X4_LP_BASE3r
#define WRITELN_AN_X4_LP_BASE3r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_BASE3r
#define WRITEALL_AN_X4_LP_BASE3r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_BASE3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_BASE3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_OUI_UP1
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d8
 * DESC:     PSEQ LP OUI UP-1 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_OUI_UP1       10:0 -- OUI MP5 bits 23:1311 -- !(Toggle bit in MP5 page)12 -- Read as 013 -- Read as 014 -- Ack bit in MP5 page15 -- Read as 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r (0x0000c1d8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_OUI_UP1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_oui_up1[1];
	uint32_t _an_x4_lp_oui_up1;
} BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_CLR(r) (r).an_x4_lp_oui_up1[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_SET(r,d) (r).an_x4_lp_oui_up1[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_GET(r) (r).an_x4_lp_oui_up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_LP_OUI_UP1f_GET(r) (((r).an_x4_lp_oui_up1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_LP_OUI_UP1f_SET(r,f) (r).an_x4_lp_oui_up1[0]=(((r).an_x4_lp_oui_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_OUI_UP1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r,(_r._an_x4_lp_oui_up1))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r,(_r._an_x4_lp_oui_up1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r,(_r._an_x4_lp_oui_up1))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up1))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up1))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_oui_up1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_OUI_UP1r BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r
#define AN_X4_LP_OUI_UP1r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_t AN_X4_LP_OUI_UP1r_t;
#define AN_X4_LP_OUI_UP1r_CLR BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_CLR
#define AN_X4_LP_OUI_UP1r_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_SET
#define AN_X4_LP_OUI_UP1r_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_GET
#define AN_X4_LP_OUI_UP1r_LP_OUI_UP1f_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_LP_OUI_UP1f_GET
#define AN_X4_LP_OUI_UP1r_LP_OUI_UP1f_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r_LP_OUI_UP1f_SET
#define READ_AN_X4_LP_OUI_UP1r BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP1r
#define WRITE_AN_X4_LP_OUI_UP1r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP1r
#define MODIFY_AN_X4_LP_OUI_UP1r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP1r
#define READLN_AN_X4_LP_OUI_UP1r BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP1r
#define WRITELN_AN_X4_LP_OUI_UP1r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP1r
#define WRITEALL_AN_X4_LP_OUI_UP1r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_OUI_UP2
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1d9
 * DESC:     PSEQ LP OUI UP-2 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_OUI_UP2       10:0 -- OUI MP5 bits 12:211 -- (Toggle bit in MP5 page)12 -- Read as 013 -- Read as 014 -- Ack bit in MP5 page15 -- Read as 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r (0x0000c1d9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_OUI_UP2.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_oui_up2[1];
	uint32_t _an_x4_lp_oui_up2;
} BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_CLR(r) (r).an_x4_lp_oui_up2[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_SET(r,d) (r).an_x4_lp_oui_up2[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_GET(r) (r).an_x4_lp_oui_up2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_LP_OUI_UP2f_GET(r) (((r).an_x4_lp_oui_up2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_LP_OUI_UP2f_SET(r,f) (r).an_x4_lp_oui_up2[0]=(((r).an_x4_lp_oui_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_OUI_UP2.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r,(_r._an_x4_lp_oui_up2))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r,(_r._an_x4_lp_oui_up2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r,(_r._an_x4_lp_oui_up2))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up2))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up2))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_oui_up2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_OUI_UP2r BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r
#define AN_X4_LP_OUI_UP2r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_t AN_X4_LP_OUI_UP2r_t;
#define AN_X4_LP_OUI_UP2r_CLR BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_CLR
#define AN_X4_LP_OUI_UP2r_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_SET
#define AN_X4_LP_OUI_UP2r_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_GET
#define AN_X4_LP_OUI_UP2r_LP_OUI_UP2f_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_LP_OUI_UP2f_GET
#define AN_X4_LP_OUI_UP2r_LP_OUI_UP2f_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r_LP_OUI_UP2f_SET
#define READ_AN_X4_LP_OUI_UP2r BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP2r
#define WRITE_AN_X4_LP_OUI_UP2r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP2r
#define MODIFY_AN_X4_LP_OUI_UP2r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP2r
#define READLN_AN_X4_LP_OUI_UP2r BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP2r
#define WRITELN_AN_X4_LP_OUI_UP2r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP2r
#define WRITEALL_AN_X4_LP_OUI_UP2r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_OUI_UP3
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1da
 * DESC:     PSEQ LP OUI UP-3 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_OUI_UP3       PSEQ LP OUI UP-3.8:0 -- BAM Code10:9 -- OUI UP1 bits 1:011 -- Toggle bit in UP1 page13:12 -- Read as 014 -- Ack bit in UP1 page15 -- Read as 1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r (0x0000c1da | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_OUI_UP3.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_oui_up3[1];
	uint32_t _an_x4_lp_oui_up3;
} BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_CLR(r) (r).an_x4_lp_oui_up3[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_SET(r,d) (r).an_x4_lp_oui_up3[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_GET(r) (r).an_x4_lp_oui_up3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_LP_OUI_UP3f_GET(r) (((r).an_x4_lp_oui_up3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_LP_OUI_UP3f_SET(r,f) (r).an_x4_lp_oui_up3[0]=(((r).an_x4_lp_oui_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_OUI_UP3.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r,(_r._an_x4_lp_oui_up3))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r,(_r._an_x4_lp_oui_up3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r,(_r._an_x4_lp_oui_up3))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up3))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up3))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_oui_up3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_OUI_UP3r BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r
#define AN_X4_LP_OUI_UP3r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_t AN_X4_LP_OUI_UP3r_t;
#define AN_X4_LP_OUI_UP3r_CLR BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_CLR
#define AN_X4_LP_OUI_UP3r_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_SET
#define AN_X4_LP_OUI_UP3r_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_GET
#define AN_X4_LP_OUI_UP3r_LP_OUI_UP3f_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_LP_OUI_UP3f_GET
#define AN_X4_LP_OUI_UP3r_LP_OUI_UP3f_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r_LP_OUI_UP3f_SET
#define READ_AN_X4_LP_OUI_UP3r BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP3r
#define WRITE_AN_X4_LP_OUI_UP3r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP3r
#define MODIFY_AN_X4_LP_OUI_UP3r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP3r
#define READLN_AN_X4_LP_OUI_UP3r BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP3r
#define WRITELN_AN_X4_LP_OUI_UP3r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP3r
#define WRITEALL_AN_X4_LP_OUI_UP3r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_OUI_UP4
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1db
 * DESC:     PSEQ LP OUI UP-4 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_OUI_UP4       PSEQ LP OUI UP-4.10:0 -- User defined data; 26:16 bits in UP1 page10 -- 26 bits in UP1 page (Reserved)9 -- 25 bits in UP1 page which is SPEED_50G_CR2 in BAM8 -- 24 bits in UP1 page which is SPEED_50G_KR2 in BAM7 -- 23 bits in UP1 page which is SPEED_40G_CR2 in BAM6 -- 22 bits in UP1 page which is SPEED_40G_KR2 in BAM5 -- 21 bits in UP1 page which is SPEED_25G_CR2 in BAM4 -- 20 bits in UP1 page which is SPEED_25G_KR2 in BAM3 -- 19 bits in UP1 page which is SPEED_20G_CR1 in BAM2 -- 18 bits in UP1 page which is SPEED_20G_KR1 in BAM1 -- 17 bits in UP1 page which is SPEED_20G_CR2 in BAM0 -- 16 bits in UP1 page which is SPEED_20G_KR2 in BAM11 -- !(Toggle bit in UP1 page)13:12 -- Read as 014 -- Ack bit in UP1 page15 -- Next page in UP1 ; bit 15 in UP1 page
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r (0x0000c1db | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_OUI_UP4.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_oui_up4[1];
	uint32_t _an_x4_lp_oui_up4;
} BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_CLR(r) (r).an_x4_lp_oui_up4[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_SET(r,d) (r).an_x4_lp_oui_up4[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_GET(r) (r).an_x4_lp_oui_up4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_LP_OUI_UP4f_GET(r) (((r).an_x4_lp_oui_up4[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_LP_OUI_UP4f_SET(r,f) (r).an_x4_lp_oui_up4[0]=(((r).an_x4_lp_oui_up4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_OUI_UP4.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r,(_r._an_x4_lp_oui_up4))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r,(_r._an_x4_lp_oui_up4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r,(_r._an_x4_lp_oui_up4))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up4))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up4))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_oui_up4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_OUI_UP4r BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r
#define AN_X4_LP_OUI_UP4r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_t AN_X4_LP_OUI_UP4r_t;
#define AN_X4_LP_OUI_UP4r_CLR BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_CLR
#define AN_X4_LP_OUI_UP4r_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_SET
#define AN_X4_LP_OUI_UP4r_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_GET
#define AN_X4_LP_OUI_UP4r_LP_OUI_UP4f_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_LP_OUI_UP4f_GET
#define AN_X4_LP_OUI_UP4r_LP_OUI_UP4f_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r_LP_OUI_UP4f_SET
#define READ_AN_X4_LP_OUI_UP4r BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP4r
#define WRITE_AN_X4_LP_OUI_UP4r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP4r
#define MODIFY_AN_X4_LP_OUI_UP4r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP4r
#define READLN_AN_X4_LP_OUI_UP4r BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP4r
#define WRITELN_AN_X4_LP_OUI_UP4r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP4r
#define WRITEALL_AN_X4_LP_OUI_UP4r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_OUI_UP5
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1dc
 * DESC:     PSEQ LP OUI UP-5 
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_OUI_UP5       44:32 bits in UP1 page12 -- 44 bits in UP1 page which is CL74_FEC Request in BAM11 -- 43 bits in UP1 page which is CL91_FEC Request in BAM10 -- 42 bits in UP1 page which is HG2 Enabled in BAM9 --  41 bits in UP1 page which is CL74_FEC ability exist8 --  40 bits in UP1 page which is CL91_FEC ability exist7:2 --  39 to 34 bits in UP1 page which reserved1 --  33 bits in UP1 page which is SPEED_50G_CR4 in BAM0 --  32 bits in UP1 page which is SPEED_50G_KR4 in BAM
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r (0x0000c1dc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_OUI_UP5.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_oui_up5[1];
	uint32_t _an_x4_lp_oui_up5;
} BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_CLR(r) (r).an_x4_lp_oui_up5[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_SET(r,d) (r).an_x4_lp_oui_up5[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_GET(r) (r).an_x4_lp_oui_up5[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_LP_OUI_UP5f_GET(r) (((r).an_x4_lp_oui_up5[0]) & 0x1fff)
#define BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_LP_OUI_UP5f_SET(r,f) (r).an_x4_lp_oui_up5[0]=(((r).an_x4_lp_oui_up5[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access AN_X4_LP_OUI_UP5.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r,(_r._an_x4_lp_oui_up5))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r,(_r._an_x4_lp_oui_up5)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r,(_r._an_x4_lp_oui_up5))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up5))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_oui_up5))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_oui_up5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_OUI_UP5r BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r
#define AN_X4_LP_OUI_UP5r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_t AN_X4_LP_OUI_UP5r_t;
#define AN_X4_LP_OUI_UP5r_CLR BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_CLR
#define AN_X4_LP_OUI_UP5r_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_SET
#define AN_X4_LP_OUI_UP5r_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_GET
#define AN_X4_LP_OUI_UP5r_LP_OUI_UP5f_GET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_LP_OUI_UP5f_GET
#define AN_X4_LP_OUI_UP5r_LP_OUI_UP5f_SET BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r_LP_OUI_UP5f_SET
#define READ_AN_X4_LP_OUI_UP5r BCMI_TSCD_XGXS_READ_AN_X4_LP_OUI_UP5r
#define WRITE_AN_X4_LP_OUI_UP5r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_OUI_UP5r
#define MODIFY_AN_X4_LP_OUI_UP5r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_OUI_UP5r
#define READLN_AN_X4_LP_OUI_UP5r BCMI_TSCD_XGXS_READLN_AN_X4_LP_OUI_UP5r
#define WRITELN_AN_X4_LP_OUI_UP5r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_OUI_UP5r
#define WRITEALL_AN_X4_LP_OUI_UP5r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_OUI_UP5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_OUI_UP5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_RES_ERR
 * BLOCKS:   AN_X4_STATUS
 * REGADDR:  0xc1dd
 * DESC:     RES ERR
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESOLUTION_ERROR RES No common speed/mode.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_RES_ERRr (0x0000c1dd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_RES_ERRr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_RES_ERR.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_RES_ERRr_s {
	uint32_t v[1];
	uint32_t an_x4_res_err[1];
	uint32_t _an_x4_res_err;
} BCMI_TSCD_XGXS_AN_X4_RES_ERRr_t;

#define BCMI_TSCD_XGXS_AN_X4_RES_ERRr_CLR(r) (r).an_x4_res_err[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_RES_ERRr_SET(r,d) (r).an_x4_res_err[0] = d
#define BCMI_TSCD_XGXS_AN_X4_RES_ERRr_GET(r) (r).an_x4_res_err[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_GET(r) (((r).an_x4_res_err[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_SET(r,f) (r).an_x4_res_err[0]=(((r).an_x4_res_err[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_RES_ERR.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_RES_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_RES_ERRr,(_r._an_x4_res_err))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_RES_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_RES_ERRr,(_r._an_x4_res_err)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_RES_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_RES_ERRr,(_r._an_x4_res_err))
#define BCMI_TSCD_XGXS_READLN_AN_X4_RES_ERRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_RES_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_res_err))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_RES_ERRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_RES_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_res_err))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_RES_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_RES_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_res_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_RES_ERRr BCMI_TSCD_XGXS_AN_X4_RES_ERRr
#define AN_X4_RES_ERRr_SIZE BCMI_TSCD_XGXS_AN_X4_RES_ERRr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_RES_ERRr_t AN_X4_RES_ERRr_t;
#define AN_X4_RES_ERRr_CLR BCMI_TSCD_XGXS_AN_X4_RES_ERRr_CLR
#define AN_X4_RES_ERRr_SET BCMI_TSCD_XGXS_AN_X4_RES_ERRr_SET
#define AN_X4_RES_ERRr_GET BCMI_TSCD_XGXS_AN_X4_RES_ERRr_GET
#define AN_X4_RES_ERRr_RESOLUTION_ERRORf_GET BCMI_TSCD_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_GET
#define AN_X4_RES_ERRr_RESOLUTION_ERRORf_SET BCMI_TSCD_XGXS_AN_X4_RES_ERRr_RESOLUTION_ERRORf_SET
#define READ_AN_X4_RES_ERRr BCMI_TSCD_XGXS_READ_AN_X4_RES_ERRr
#define WRITE_AN_X4_RES_ERRr BCMI_TSCD_XGXS_WRITE_AN_X4_RES_ERRr
#define MODIFY_AN_X4_RES_ERRr BCMI_TSCD_XGXS_MODIFY_AN_X4_RES_ERRr
#define READLN_AN_X4_RES_ERRr BCMI_TSCD_XGXS_READLN_AN_X4_RES_ERRr
#define WRITELN_AN_X4_RES_ERRr BCMI_TSCD_XGXS_WRITELN_AN_X4_RES_ERRr
#define WRITEALL_AN_X4_RES_ERRr BCMI_TSCD_XGXS_WRITEALL_AN_X4_RES_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_RES_ERRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_PAGE2
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e0
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_2        LOCAL DEVICE PAGE 2 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r (0x0000c1e0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE2.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page2[1];
	uint32_t _an_x4_ld_page2;
} BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_CLR(r) (r).an_x4_ld_page2[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_SET(r,d) (r).an_x4_ld_page2[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_GET(r) (r).an_x4_ld_page2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_GET(r) (((r).an_x4_ld_page2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_SET(r,f) (r).an_x4_ld_page2[0]=(((r).an_x4_ld_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE2.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r,(_r._an_x4_ld_page2))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page2))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page2))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE2r BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r
#define AN_X4_LD_PAGE2r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_t AN_X4_LD_PAGE2r_t;
#define AN_X4_LD_PAGE2r_CLR BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_CLR
#define AN_X4_LD_PAGE2r_SET BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_SET
#define AN_X4_LD_PAGE2r_GET BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_GET
#define AN_X4_LD_PAGE2r_LD_PAGE_2f_GET BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_GET
#define AN_X4_LD_PAGE2r_LD_PAGE_2f_SET BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r_LD_PAGE_2f_SET
#define READ_AN_X4_LD_PAGE2r BCMI_TSCD_XGXS_READ_AN_X4_LD_PAGE2r
#define WRITE_AN_X4_LD_PAGE2r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_PAGE2r
#define MODIFY_AN_X4_LD_PAGE2r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_PAGE2r
#define READLN_AN_X4_LD_PAGE2r BCMI_TSCD_XGXS_READLN_AN_X4_LD_PAGE2r
#define WRITELN_AN_X4_LD_PAGE2r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_PAGE2r
#define WRITEALL_AN_X4_LD_PAGE2r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_PAGE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_PAGE1
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e1
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_1        LOCAL DEVICE PAGE 1 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r (0x0000c1e1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page1[1];
	uint32_t _an_x4_ld_page1;
} BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_CLR(r) (r).an_x4_ld_page1[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_SET(r,d) (r).an_x4_ld_page1[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_GET(r) (r).an_x4_ld_page1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_GET(r) (((r).an_x4_ld_page1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_SET(r,f) (r).an_x4_ld_page1[0]=(((r).an_x4_ld_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r,(_r._an_x4_ld_page1))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page1))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page1))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE1r BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r
#define AN_X4_LD_PAGE1r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_t AN_X4_LD_PAGE1r_t;
#define AN_X4_LD_PAGE1r_CLR BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_CLR
#define AN_X4_LD_PAGE1r_SET BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_SET
#define AN_X4_LD_PAGE1r_GET BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_GET
#define AN_X4_LD_PAGE1r_LD_PAGE_1f_GET BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_GET
#define AN_X4_LD_PAGE1r_LD_PAGE_1f_SET BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r_LD_PAGE_1f_SET
#define READ_AN_X4_LD_PAGE1r BCMI_TSCD_XGXS_READ_AN_X4_LD_PAGE1r
#define WRITE_AN_X4_LD_PAGE1r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_PAGE1r
#define MODIFY_AN_X4_LD_PAGE1r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_PAGE1r
#define READLN_AN_X4_LD_PAGE1r BCMI_TSCD_XGXS_READLN_AN_X4_LD_PAGE1r
#define WRITELN_AN_X4_LD_PAGE1r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_PAGE1r
#define WRITEALL_AN_X4_LD_PAGE1r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_PAGE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_PAGE0
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e2
 * DESC:     LOCAL DEVICE SW CONTROL PAGE 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LD_PAGE_0        LOCAL DEVICE PAGE 0 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r (0x0000c1e2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_PAGE0.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_ld_page0[1];
	uint32_t _an_x4_ld_page0;
} BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_CLR(r) (r).an_x4_ld_page0[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_SET(r,d) (r).an_x4_ld_page0[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_GET(r) (r).an_x4_ld_page0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_GET(r) (((r).an_x4_ld_page0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_SET(r,f) (r).an_x4_ld_page0[0]=(((r).an_x4_ld_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LD_PAGE0.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r,(_r._an_x4_ld_page0))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page0))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_page0))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_PAGE0r BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r
#define AN_X4_LD_PAGE0r_SIZE BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_t AN_X4_LD_PAGE0r_t;
#define AN_X4_LD_PAGE0r_CLR BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_CLR
#define AN_X4_LD_PAGE0r_SET BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_SET
#define AN_X4_LD_PAGE0r_GET BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_GET
#define AN_X4_LD_PAGE0r_LD_PAGE_0f_GET BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_GET
#define AN_X4_LD_PAGE0r_LD_PAGE_0f_SET BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r_LD_PAGE_0f_SET
#define READ_AN_X4_LD_PAGE0r BCMI_TSCD_XGXS_READ_AN_X4_LD_PAGE0r
#define WRITE_AN_X4_LD_PAGE0r BCMI_TSCD_XGXS_WRITE_AN_X4_LD_PAGE0r
#define MODIFY_AN_X4_LD_PAGE0r BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_PAGE0r
#define READLN_AN_X4_LD_PAGE0r BCMI_TSCD_XGXS_READLN_AN_X4_LD_PAGE0r
#define WRITELN_AN_X4_LD_PAGE0r BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_PAGE0r
#define WRITEALL_AN_X4_LD_PAGE0r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_PAGE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_PAGE2
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e3
 * DESC:     LINK PARNTER SW CONTROL PAGE 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_2        LINK PARTNER PAGE 2 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r (0x0000c1e3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE2.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page2[1];
	uint32_t _an_x4_lp_page2;
} BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_CLR(r) (r).an_x4_lp_page2[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_SET(r,d) (r).an_x4_lp_page2[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_GET(r) (r).an_x4_lp_page2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_GET(r) (((r).an_x4_lp_page2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_SET(r,f) (r).an_x4_lp_page2[0]=(((r).an_x4_lp_page2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE2.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r,(_r._an_x4_lp_page2))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page2))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_PAGE2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page2))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_PAGE2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE2r BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r
#define AN_X4_LP_PAGE2r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_t AN_X4_LP_PAGE2r_t;
#define AN_X4_LP_PAGE2r_CLR BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_CLR
#define AN_X4_LP_PAGE2r_SET BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_SET
#define AN_X4_LP_PAGE2r_GET BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_GET
#define AN_X4_LP_PAGE2r_LP_PAGE_2f_GET BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_GET
#define AN_X4_LP_PAGE2r_LP_PAGE_2f_SET BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r_LP_PAGE_2f_SET
#define READ_AN_X4_LP_PAGE2r BCMI_TSCD_XGXS_READ_AN_X4_LP_PAGE2r
#define WRITE_AN_X4_LP_PAGE2r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_PAGE2r
#define MODIFY_AN_X4_LP_PAGE2r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_PAGE2r
#define READLN_AN_X4_LP_PAGE2r BCMI_TSCD_XGXS_READLN_AN_X4_LP_PAGE2r
#define WRITELN_AN_X4_LP_PAGE2r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_PAGE2r
#define WRITEALL_AN_X4_LP_PAGE2r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_PAGE2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_PAGE2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_PAGE1
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e4
 * DESC:     LINK PARNTER SW CONTROL PAGE 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_1        LINK PARTNER PAGE 1 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r (0x0000c1e4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE1.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page1[1];
	uint32_t _an_x4_lp_page1;
} BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_CLR(r) (r).an_x4_lp_page1[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_SET(r,d) (r).an_x4_lp_page1[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_GET(r) (r).an_x4_lp_page1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_GET(r) (((r).an_x4_lp_page1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_SET(r,f) (r).an_x4_lp_page1[0]=(((r).an_x4_lp_page1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE1.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r,(_r._an_x4_lp_page1))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page1))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_PAGE1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page1))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_PAGE1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE1r BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r
#define AN_X4_LP_PAGE1r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_t AN_X4_LP_PAGE1r_t;
#define AN_X4_LP_PAGE1r_CLR BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_CLR
#define AN_X4_LP_PAGE1r_SET BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_SET
#define AN_X4_LP_PAGE1r_GET BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_GET
#define AN_X4_LP_PAGE1r_LP_PAGE_1f_GET BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_GET
#define AN_X4_LP_PAGE1r_LP_PAGE_1f_SET BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r_LP_PAGE_1f_SET
#define READ_AN_X4_LP_PAGE1r BCMI_TSCD_XGXS_READ_AN_X4_LP_PAGE1r
#define WRITE_AN_X4_LP_PAGE1r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_PAGE1r
#define MODIFY_AN_X4_LP_PAGE1r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_PAGE1r
#define READLN_AN_X4_LP_PAGE1r BCMI_TSCD_XGXS_READLN_AN_X4_LP_PAGE1r
#define WRITELN_AN_X4_LP_PAGE1r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_PAGE1r
#define WRITEALL_AN_X4_LP_PAGE1r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_PAGE1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_PAGE1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LP_PAGE0
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e5
 * DESC:     LINK PARNTER SW CONTROL PAGE 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     LP_PAGE_0        LINK PARTNER PAGE 0 FIELD
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r (0x0000c1e5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LP_PAGE0.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_s {
	uint32_t v[1];
	uint32_t an_x4_lp_page0[1];
	uint32_t _an_x4_lp_page0;
} BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_t;

#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_CLR(r) (r).an_x4_lp_page0[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_SET(r,d) (r).an_x4_lp_page0[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_GET(r) (r).an_x4_lp_page0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_GET(r) (((r).an_x4_lp_page0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_SET(r,f) (r).an_x4_lp_page0[0]=(((r).an_x4_lp_page0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_LP_PAGE0.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r,(_r._an_x4_lp_page0))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LP_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page0))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_PAGE0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_lp_page0))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_PAGE0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_lp_page0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LP_PAGE0r BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r
#define AN_X4_LP_PAGE0r_SIZE BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_t AN_X4_LP_PAGE0r_t;
#define AN_X4_LP_PAGE0r_CLR BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_CLR
#define AN_X4_LP_PAGE0r_SET BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_SET
#define AN_X4_LP_PAGE0r_GET BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_GET
#define AN_X4_LP_PAGE0r_LP_PAGE_0f_GET BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_GET
#define AN_X4_LP_PAGE0r_LP_PAGE_0f_SET BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r_LP_PAGE_0f_SET
#define READ_AN_X4_LP_PAGE0r BCMI_TSCD_XGXS_READ_AN_X4_LP_PAGE0r
#define WRITE_AN_X4_LP_PAGE0r BCMI_TSCD_XGXS_WRITE_AN_X4_LP_PAGE0r
#define MODIFY_AN_X4_LP_PAGE0r BCMI_TSCD_XGXS_MODIFY_AN_X4_LP_PAGE0r
#define READLN_AN_X4_LP_PAGE0r BCMI_TSCD_XGXS_READLN_AN_X4_LP_PAGE0r
#define WRITELN_AN_X4_LP_PAGE0r BCMI_TSCD_XGXS_WRITELN_AN_X4_LP_PAGE0r
#define WRITEALL_AN_X4_LP_PAGE0r BCMI_TSCD_XGXS_WRITEALL_AN_X4_LP_PAGE0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LP_PAGE0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_SW_CTL_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e6
 * DESC:     SW CONTROL STATUS INFORMATION
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TLA_LN_SEQUENCER_FSM_STATUS1 TLA Lane sequencer fsm latched status cont.
 *     PD_CL37_COMPLETED Parallel detect process has selected cl37 and it was completed.
 *     PD_SPEED_STATUS_1 Gen1 & Gen2 : Reserved.Gen3 : Speed status for PD attempt. Use this bit as MSBit of 2bit PD speed indication. LSBit is an_misc_status.pd_speed_status_02'b00: undefined, 2'b01: KX, 2'b10: 2p5G, 2'b11: undefined
 *     LD_SEQ_RESTART   Set by HW when the CL73 AN FSM enters the TX_DISABLE state.It indicates to SW that it has to restart the page sequence from the base page.Valid when ld_page_req is set.
 *     LP_PAGE_RDY      Set by HW, Clear on Read of lp_page_0
 *     LD_PAGE_REQ      Set by HW to indicate that is ready for page to be sent.
 *     LD_CONTROL_VALID Set by SW write to ld_page_0, Cleared when HW transfers the ld_page'sreflects internal status and used for debug
 *     AN_COMPLETED     All page exchanges have completed
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr (0x0000c1e6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_SW_CTL_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_sw_ctl_sts[1];
	uint32_t _an_x4_sw_ctl_sts;
} BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_t;

#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_CLR(r) (r).an_x4_sw_ctl_sts[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_SET(r,d) (r).an_x4_sw_ctl_sts[0] = d
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_GET(r) (r).an_x4_sw_ctl_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_PAGE_REQf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_PAGE_REQf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_SPEED_STATUS_1f_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_SPEED_STATUS_1f_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET(r) ((((r).an_x4_sw_ctl_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET(r) (((r).an_x4_sw_ctl_sts[0]) & 0xff)
#define BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET(r,f) (r).an_x4_sw_ctl_sts[0]=(((r).an_x4_sw_ctl_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access AN_X4_SW_CTL_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr,(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCD_XGXS_READLN_AN_X4_SW_CTL_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_CTL_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_sw_ctl_sts))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_CTL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_sw_ctl_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_SW_CTL_STSr BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr
#define AN_X4_SW_CTL_STSr_SIZE BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_t AN_X4_SW_CTL_STSr_t;
#define AN_X4_SW_CTL_STSr_CLR BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_CLR
#define AN_X4_SW_CTL_STSr_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_SET
#define AN_X4_SW_CTL_STSr_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_GET
#define AN_X4_SW_CTL_STSr_AN_COMPLETEDf_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_GET
#define AN_X4_SW_CTL_STSr_AN_COMPLETEDf_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_AN_COMPLETEDf_SET
#define AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_GET
#define AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_CONTROL_VALIDf_SET
#define AN_X4_SW_CTL_STSr_LD_PAGE_REQf_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_PAGE_REQf_GET
#define AN_X4_SW_CTL_STSr_LD_PAGE_REQf_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_PAGE_REQf_SET
#define AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_GET
#define AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LP_PAGE_RDYf_SET
#define AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_GET
#define AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_LD_SEQ_RESTARTf_SET
#define AN_X4_SW_CTL_STSr_PD_SPEED_STATUS_1f_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_SPEED_STATUS_1f_GET
#define AN_X4_SW_CTL_STSr_PD_SPEED_STATUS_1f_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_SPEED_STATUS_1f_SET
#define AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_GET
#define AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_PD_CL37_COMPLETEDf_SET
#define AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_GET
#define AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr_TLA_LN_SEQUENCER_FSM_STATUS1f_SET
#define READ_AN_X4_SW_CTL_STSr BCMI_TSCD_XGXS_READ_AN_X4_SW_CTL_STSr
#define WRITE_AN_X4_SW_CTL_STSr BCMI_TSCD_XGXS_WRITE_AN_X4_SW_CTL_STSr
#define MODIFY_AN_X4_SW_CTL_STSr BCMI_TSCD_XGXS_MODIFY_AN_X4_SW_CTL_STSr
#define READLN_AN_X4_SW_CTL_STSr BCMI_TSCD_XGXS_READLN_AN_X4_SW_CTL_STSr
#define WRITELN_AN_X4_SW_CTL_STSr BCMI_TSCD_XGXS_WRITELN_AN_X4_SW_CTL_STSr
#define WRITEALL_AN_X4_SW_CTL_STSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_SW_CTL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_SW_CTL_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_LD_CTL
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e7
 * DESC:     LOCAL DEVICE CONTROLS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AN_HCD_RES_DISABLE Indicates HW does not perform HCD
 *     AN_TYPE_SW       Indicates SW managed AN
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr (0x0000c1e7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_LD_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_LD_CTLr_s {
	uint32_t v[1];
	uint32_t an_x4_ld_ctl[1];
	uint32_t _an_x4_ld_ctl;
} BCMI_TSCD_XGXS_AN_X4_LD_CTLr_t;

#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_CLR(r) (r).an_x4_ld_ctl[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_SET(r,d) (r).an_x4_ld_ctl[0] = d
#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_GET(r) (r).an_x4_ld_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_GET(r) ((((r).an_x4_ld_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_SET(r,f) (r).an_x4_ld_ctl[0]=(((r).an_x4_ld_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_GET(r) (((r).an_x4_ld_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_SET(r,f) (r).an_x4_ld_ctl[0]=(((r).an_x4_ld_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_LD_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_CTLr,(_r._an_x4_ld_ctl))
#define BCMI_TSCD_XGXS_READLN_AN_X4_LD_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_ctl))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_ld_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_LD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_ld_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_LD_CTLr BCMI_TSCD_XGXS_AN_X4_LD_CTLr
#define AN_X4_LD_CTLr_SIZE BCMI_TSCD_XGXS_AN_X4_LD_CTLr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_LD_CTLr_t AN_X4_LD_CTLr_t;
#define AN_X4_LD_CTLr_CLR BCMI_TSCD_XGXS_AN_X4_LD_CTLr_CLR
#define AN_X4_LD_CTLr_SET BCMI_TSCD_XGXS_AN_X4_LD_CTLr_SET
#define AN_X4_LD_CTLr_GET BCMI_TSCD_XGXS_AN_X4_LD_CTLr_GET
#define AN_X4_LD_CTLr_AN_TYPE_SWf_GET BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_GET
#define AN_X4_LD_CTLr_AN_TYPE_SWf_SET BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_TYPE_SWf_SET
#define AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_GET BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_GET
#define AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_SET BCMI_TSCD_XGXS_AN_X4_LD_CTLr_AN_HCD_RES_DISABLEf_SET
#define READ_AN_X4_LD_CTLr BCMI_TSCD_XGXS_READ_AN_X4_LD_CTLr
#define WRITE_AN_X4_LD_CTLr BCMI_TSCD_XGXS_WRITE_AN_X4_LD_CTLr
#define MODIFY_AN_X4_LD_CTLr BCMI_TSCD_XGXS_MODIFY_AN_X4_LD_CTLr
#define READLN_AN_X4_LD_CTLr BCMI_TSCD_XGXS_READLN_AN_X4_LD_CTLr
#define WRITELN_AN_X4_LD_CTLr BCMI_TSCD_XGXS_WRITELN_AN_X4_LD_CTLr
#define WRITEALL_AN_X4_LD_CTLr BCMI_TSCD_XGXS_WRITEALL_AN_X4_LD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_LD_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_AN_ABIL_RESOLUTION_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e8
 * DESC:     AN ABILITY RESOLUTION INFORMATION
 * RESETVAL: 0x120 (288)
 * ACCESS:   R/O
 * FIELDS:
 *     AN_HCD_CL72      HCD training ability
 *     AN_HCD_FEC       HCD forward-error correction ability
 *     AN_HCD_SPEED     HCD speedSPEED_10G_KR1       8'h01SPEED_10G_HG2_KR1   8'h05SPEED_20G_CR1       8'h08SPEED_20G_HG2_CR1   8'h0cSPEED_20G_KR1       8'h09SPEED_20G_HG2_KR1   8'h0dSPEED_25G_CR1       8'h10SPEED_25G_HG2_CR1   8'h14SPEED_25G_KR1       8'h11SPEED_25G_HG2_KR1   8'h15SPEED_20G_CR2       8'h18SPEED_20G_HG2_CR2   8'h1cSPEED_20G_KR2       8'h19SPEED_20G_HG2_KR2   8'h1dSPEED_40G_CR2       8'h20SPEED_40G_HG2_CR2   8'h24SPEED_40G_KR2       8'h21SPEED_40G_HG2_KR2   8'h25SPEED_40G_CR4       8'h28SPEED_40G_HG2_CR4   8'h2cSPEED_40G_KR4       8'h29SPEED_40G_HG2_KR4   8'h2dSPEED_50G_CR2       8'h30SPEED_50G_HG2_CR2   8'h34SPEED_50G_KR2       8'h31SPEED_50G_HG2_KR2   8'h35SPEED_50G_CR4       8'h38SPEED_50G_HG2_CR4   8'h3cSPEED_50G_KR4       8'h39SPEED_50G_HG2_KR4   8'h3DSPEED_100G_CR4      8'h40SPEED_100G_HG2_CR4  8'h44SPEED_100G_KR4      8'h41SPEED_100G_HG2_KR4  8'h45SPEED_CL73_20GVCO   8'h48SPEED_CL73_25GVCO   8'h50SPEED_1G_20GVCO     8'h58SPEED_1G_25GVCO     8'h60SPEED_2P5G_KX1      8'h62SPEED_5G_KR1        8'h63SPEED_25G_CR_IEEE   8'h70SPEED_25G_CRS_IEEE  8'h71SPEED_25G_KR_IEEE   8'h72SPEED_25G_KRS_IEEE  8'h73
 *     AN_HCD_PAUSE     HCD Pause Ability[11:10]00 - None01 - TX (from LD to LP)10 - RX (from LP to LD)11 - TX/RX (symmetrical)
 *     AN_HCD_DUPLEX    HCD full-duplex ability
 *     HCD_CL91_EN      Resolved HCD CL91 ability for 25G/50G
 *     HCD_DBG_CL74_UP_EN Resolved HCD CL74 ability for 25G/50G VIA USER PAGE
 *     HCD_DBG_CL74_BASE_EN Resolved HCD CL74 ability for 25G/50G VIA BASE PAGE
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr (0x0000c1e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_ABIL_RESOLUTION_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_abil_resolution_sts[1];
	uint32_t _an_x4_an_abil_resolution_sts;
} BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_t;

#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_CLR(r) (r).an_x4_an_abil_resolution_sts[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SET(r,d) (r).an_x4_an_abil_resolution_sts[0] = d
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_GET(r) (r).an_x4_an_abil_resolution_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_BASE_ENf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_BASE_ENf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_UP_ENf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_UP_ENf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_CL91_ENf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_CL91_ENf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 10) & 0x3)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 2) & 0xff)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0xff << 2)) | ((((uint32_t)f) & 0xff) << 2)) | (255 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET(r) ((((r).an_x4_an_abil_resolution_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET(r) (((r).an_x4_an_abil_resolution_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET(r,f) (r).an_x4_an_abil_resolution_sts[0]=(((r).an_x4_an_abil_resolution_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_AN_ABIL_RESOLUTION_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr,(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCD_XGXS_READLN_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_abil_resolution_sts))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_abil_resolution_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr
#define AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_t AN_X4_AN_ABIL_RESOLUTION_STSr_t;
#define AN_X4_AN_ABIL_RESOLUTION_STSr_CLR BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_CLR
#define AN_X4_AN_ABIL_RESOLUTION_STSr_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_BASE_ENf_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_BASE_ENf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_BASE_ENf_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_BASE_ENf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_UP_ENf_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_UP_ENf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_UP_ENf_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_DBG_CL74_UP_ENf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_CL91_ENf_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_CL91_ENf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_CL91_ENf_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_HCD_CL91_ENf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_DUPLEXf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_PAUSEf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_SPEEDf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_FECf_SET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_GET
#define AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr_AN_HCD_CL72f_SET
#define READ_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCD_XGXS_READ_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCD_XGXS_WRITE_AN_X4_AN_ABIL_RESOLUTION_STSr
#define MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCD_XGXS_MODIFY_AN_X4_AN_ABIL_RESOLUTION_STSr
#define READLN_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCD_XGXS_READLN_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCD_XGXS_WRITELN_AN_X4_AN_ABIL_RESOLUTION_STSr
#define WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_AN_ABIL_RESOLUTION_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_AN_ABIL_RESOLUTION_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_AN_MISC_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1e9
 * DESC:     MISCILLANEOUS AN STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PD_SPEED_STATUS_0 Gen1 & Gen2 : ReservedGen3 : LSBit of Speed status for PD attempt. MSBit is sw_control_status.pd_speed_status_12'b00: undefined, 2'b01: KX, 2'b10: 2p5G, 2'b11: undefined
 *     PD_IN_PROGRESS   Currently Parallel detect is active
 *     AN_FAIL_COUNT    Number of AN retries due to AN failureSaturate, Clear on Read
 *     AN_ACTIVE        Auto-neg in progress
 *     PD_COMPLETED     Parallel detect process is
 *     SPEED_FORCE      Speed Force by AN_SEQ
 *     AN_RETRY_COUNT   Number of AN retried for any reason while performing HW-AN or SW_ANSaturate, Clear on Read
 *     AN_COMPLETE      AN Sequencer has completed Auto Neg
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr (0x0000c1e9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_AN_MISC_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_an_misc_sts[1];
	uint32_t _an_x4_an_misc_sts;
} BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_t;

#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_CLR(r) (r).an_x4_an_misc_sts[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SET(r,d) (r).an_x4_an_misc_sts[0] = d
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_GET(r) (r).an_x4_an_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 9) & 0x3f)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x3f << 9)) | ((((uint32_t)f) & 0x3f) << 9)) | (63 << (16 + 9))
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SPEED_FORCEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SPEED_FORCEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 2) & 0xf)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0xf << 2)) | ((((uint32_t)f) & 0xf) << 2)) | (15 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_GET(r) ((((r).an_x4_an_misc_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_SPEED_STATUS_0f_GET(r) (((r).an_x4_an_misc_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_SPEED_STATUS_0f_SET(r,f) (r).an_x4_an_misc_sts[0]=(((r).an_x4_an_misc_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_AN_MISC_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr,(_r._an_x4_an_misc_sts))
#define BCMI_TSCD_XGXS_READLN_AN_X4_AN_MISC_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_misc_sts))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_AN_MISC_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_an_misc_sts))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_AN_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_an_misc_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_AN_MISC_STSr BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr
#define AN_X4_AN_MISC_STSr_SIZE BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_t AN_X4_AN_MISC_STSr_t;
#define AN_X4_AN_MISC_STSr_CLR BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_CLR
#define AN_X4_AN_MISC_STSr_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SET
#define AN_X4_AN_MISC_STSr_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_GET
#define AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_GET
#define AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_COMPLETEf_SET
#define AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_GET
#define AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_RETRY_COUNTf_SET
#define AN_X4_AN_MISC_STSr_SPEED_FORCEf_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SPEED_FORCEf_GET
#define AN_X4_AN_MISC_STSr_SPEED_FORCEf_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_SPEED_FORCEf_SET
#define AN_X4_AN_MISC_STSr_PD_COMPLETEDf_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_GET
#define AN_X4_AN_MISC_STSr_PD_COMPLETEDf_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_COMPLETEDf_SET
#define AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_GET
#define AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_ACTIVEf_SET
#define AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_GET
#define AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_AN_FAIL_COUNTf_SET
#define AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_GET
#define AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_IN_PROGRESSf_SET
#define AN_X4_AN_MISC_STSr_PD_SPEED_STATUS_0f_GET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_SPEED_STATUS_0f_GET
#define AN_X4_AN_MISC_STSr_PD_SPEED_STATUS_0f_SET BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr_PD_SPEED_STATUS_0f_SET
#define READ_AN_X4_AN_MISC_STSr BCMI_TSCD_XGXS_READ_AN_X4_AN_MISC_STSr
#define WRITE_AN_X4_AN_MISC_STSr BCMI_TSCD_XGXS_WRITE_AN_X4_AN_MISC_STSr
#define MODIFY_AN_X4_AN_MISC_STSr BCMI_TSCD_XGXS_MODIFY_AN_X4_AN_MISC_STSr
#define READLN_AN_X4_AN_MISC_STSr BCMI_TSCD_XGXS_READLN_AN_X4_AN_MISC_STSr
#define WRITELN_AN_X4_AN_MISC_STSr BCMI_TSCD_XGXS_WRITELN_AN_X4_AN_MISC_STSr
#define WRITEALL_AN_X4_AN_MISC_STSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_AN_MISC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_AN_MISC_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_TLA_SEQUENCER_STS
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1ea
 * DESC:     TLA SEQUENCER STATUS
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     TLA_SEQ_FSM_STATUS TLA Lane sequencer fsm latched statusClear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr (0x0000c1ea | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_TLA_SEQUENCER_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_s {
	uint32_t v[1];
	uint32_t an_x4_tla_sequencer_sts[1];
	uint32_t _an_x4_tla_sequencer_sts;
} BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_t;

#define BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_CLR(r) (r).an_x4_tla_sequencer_sts[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_SET(r,d) (r).an_x4_tla_sequencer_sts[0] = d
#define BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_GET(r) (r).an_x4_tla_sequencer_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_GET(r) (((r).an_x4_tla_sequencer_sts[0]) & 0xffff)
#define BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_SET(r,f) (r).an_x4_tla_sequencer_sts[0]=(((r).an_x4_tla_sequencer_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AN_X4_TLA_SEQUENCER_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr,(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCD_XGXS_READLN_AN_X4_TLA_SEQUENCER_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_TLA_SEQUENCER_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_tla_sequencer_sts))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_TLA_SEQUENCER_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_tla_sequencer_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_TLA_SEQUENCER_STSr BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr
#define AN_X4_TLA_SEQUENCER_STSr_SIZE BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_t AN_X4_TLA_SEQUENCER_STSr_t;
#define AN_X4_TLA_SEQUENCER_STSr_CLR BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_CLR
#define AN_X4_TLA_SEQUENCER_STSr_SET BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_SET
#define AN_X4_TLA_SEQUENCER_STSr_GET BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_GET
#define AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_GET BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_GET
#define AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_SET BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr_TLA_SEQ_FSM_STATUSf_SET
#define READ_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCD_XGXS_READ_AN_X4_TLA_SEQUENCER_STSr
#define WRITE_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCD_XGXS_WRITE_AN_X4_TLA_SEQUENCER_STSr
#define MODIFY_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCD_XGXS_MODIFY_AN_X4_TLA_SEQUENCER_STSr
#define READLN_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCD_XGXS_READLN_AN_X4_TLA_SEQUENCER_STSr
#define WRITELN_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCD_XGXS_WRITELN_AN_X4_TLA_SEQUENCER_STSr
#define WRITEALL_AN_X4_TLA_SEQUENCER_STSr BCMI_TSCD_XGXS_WRITEALL_AN_X4_TLA_SEQUENCER_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_TLA_SEQUENCER_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_INT
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1eb
 * DESC:     SW AN and retimer Interrupt
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LP_PAGE_RDY_INT  Link partner's page has been receivedClear on read
 *     LD_PAGE_REQ_INT  Local device is requesting a new page for transmitClear on read
 *     AN_COMPLETED_SW_INT S/W AN page exchange completed indicationClear on read
 *     AN_GOOD_CHK_INT  Entry of port in AN Good check state.Clear on read
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_INTr (0x0000c1eb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_INTr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_INT.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_INTr_s {
	uint32_t v[1];
	uint32_t an_x4_int[1];
	uint32_t _an_x4_int;
} BCMI_TSCD_XGXS_AN_X4_INTr_t;

#define BCMI_TSCD_XGXS_AN_X4_INTr_CLR(r) (r).an_x4_int[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_INTr_SET(r,d) (r).an_x4_int[0] = d
#define BCMI_TSCD_XGXS_AN_X4_INTr_GET(r) (r).an_x4_int[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_GET(r) ((((r).an_x4_int[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_SET(r,f) (r).an_x4_int[0]=(((r).an_x4_int[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_GET(r) ((((r).an_x4_int[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_SET(r,f) (r).an_x4_int[0]=(((r).an_x4_int[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_INTr_LD_PAGE_REQ_INTf_GET(r) ((((r).an_x4_int[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INTr_LD_PAGE_REQ_INTf_SET(r,f) (r).an_x4_int[0]=(((r).an_x4_int[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_GET(r) (((r).an_x4_int[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_SET(r,f) (r).an_x4_int[0]=(((r).an_x4_int[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_INT.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_INTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_INTr,(_r._an_x4_int))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INTr,(_r._an_x4_int)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INTr,(_r._an_x4_int))
#define BCMI_TSCD_XGXS_READLN_AN_X4_INTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_INTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_INTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_int))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_INTr BCMI_TSCD_XGXS_AN_X4_INTr
#define AN_X4_INTr_SIZE BCMI_TSCD_XGXS_AN_X4_INTr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_INTr_t AN_X4_INTr_t;
#define AN_X4_INTr_CLR BCMI_TSCD_XGXS_AN_X4_INTr_CLR
#define AN_X4_INTr_SET BCMI_TSCD_XGXS_AN_X4_INTr_SET
#define AN_X4_INTr_GET BCMI_TSCD_XGXS_AN_X4_INTr_GET
#define AN_X4_INTr_AN_GOOD_CHK_INTf_GET BCMI_TSCD_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_GET
#define AN_X4_INTr_AN_GOOD_CHK_INTf_SET BCMI_TSCD_XGXS_AN_X4_INTr_AN_GOOD_CHK_INTf_SET
#define AN_X4_INTr_AN_COMPLETED_SW_INTf_GET BCMI_TSCD_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_GET
#define AN_X4_INTr_AN_COMPLETED_SW_INTf_SET BCMI_TSCD_XGXS_AN_X4_INTr_AN_COMPLETED_SW_INTf_SET
#define AN_X4_INTr_LD_PAGE_REQ_INTf_GET BCMI_TSCD_XGXS_AN_X4_INTr_LD_PAGE_REQ_INTf_GET
#define AN_X4_INTr_LD_PAGE_REQ_INTf_SET BCMI_TSCD_XGXS_AN_X4_INTr_LD_PAGE_REQ_INTf_SET
#define AN_X4_INTr_LP_PAGE_RDY_INTf_GET BCMI_TSCD_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_GET
#define AN_X4_INTr_LP_PAGE_RDY_INTf_SET BCMI_TSCD_XGXS_AN_X4_INTr_LP_PAGE_RDY_INTf_SET
#define READ_AN_X4_INTr BCMI_TSCD_XGXS_READ_AN_X4_INTr
#define WRITE_AN_X4_INTr BCMI_TSCD_XGXS_WRITE_AN_X4_INTr
#define MODIFY_AN_X4_INTr BCMI_TSCD_XGXS_MODIFY_AN_X4_INTr
#define READLN_AN_X4_INTr BCMI_TSCD_XGXS_READLN_AN_X4_INTr
#define WRITELN_AN_X4_INTr BCMI_TSCD_XGXS_WRITELN_AN_X4_INTr
#define WRITEALL_AN_X4_INTr BCMI_TSCD_XGXS_WRITEALL_AN_X4_INTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_INTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_INT_EN
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1ec
 * DESC:     SW AN and retimer Interrupt Enable
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LP_PAGE_RDY_EN   Enable Link partner's page has been receivedWriting 1 will enable this interrupt and interrupt is disable by default.
 *     LD_PAGE_REQ_EN   Enable Local device is requesting a new page for transmitWriting 1 will enable this interrupt and interrupt is disable by default.
 *     AN_COMPLETED_SW_EN Enable S/W AN page exchange completed indicationWriting 1 will enable this interrupt and interrupt is disable by default.
 *     AN_GOOD_CHK_EN   Enable interrupt when AN enters into AN Good check state.Writing 1 will enable this interrupt and interrupt is disable by default.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr (0x0000c1ec | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_INT_EN.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_INT_ENr_s {
	uint32_t v[1];
	uint32_t an_x4_int_en[1];
	uint32_t _an_x4_int_en;
} BCMI_TSCD_XGXS_AN_X4_INT_ENr_t;

#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_CLR(r) (r).an_x4_int_en[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_SET(r,d) (r).an_x4_int_en[0] = d
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_GET(r) (r).an_x4_int_en[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_GET(r) ((((r).an_x4_int_en[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_SET(r,f) (r).an_x4_int_en[0]=(((r).an_x4_int_en[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_GET(r) ((((r).an_x4_int_en[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_SET(r,f) (r).an_x4_int_en[0]=(((r).an_x4_int_en[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_LD_PAGE_REQ_ENf_GET(r) ((((r).an_x4_int_en[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_LD_PAGE_REQ_ENf_SET(r,f) (r).an_x4_int_en[0]=(((r).an_x4_int_en[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_GET(r) (((r).an_x4_int_en[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_SET(r,f) (r).an_x4_int_en[0]=(((r).an_x4_int_en[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_INT_EN.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_INT_ENr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_INT_ENr,(_r._an_x4_int_en))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_INT_ENr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INT_ENr,(_r._an_x4_int_en)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_INT_ENr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INT_ENr,(_r._an_x4_int_en))
#define BCMI_TSCD_XGXS_READLN_AN_X4_INT_ENr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_INT_ENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int_en))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_INT_ENr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INT_ENr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_int_en))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_INT_ENr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_INT_ENr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_int_en))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_INT_ENr BCMI_TSCD_XGXS_AN_X4_INT_ENr
#define AN_X4_INT_ENr_SIZE BCMI_TSCD_XGXS_AN_X4_INT_ENr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_INT_ENr_t AN_X4_INT_ENr_t;
#define AN_X4_INT_ENr_CLR BCMI_TSCD_XGXS_AN_X4_INT_ENr_CLR
#define AN_X4_INT_ENr_SET BCMI_TSCD_XGXS_AN_X4_INT_ENr_SET
#define AN_X4_INT_ENr_GET BCMI_TSCD_XGXS_AN_X4_INT_ENr_GET
#define AN_X4_INT_ENr_AN_GOOD_CHK_ENf_GET BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_GET
#define AN_X4_INT_ENr_AN_GOOD_CHK_ENf_SET BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_GOOD_CHK_ENf_SET
#define AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_GET BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_GET
#define AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_SET BCMI_TSCD_XGXS_AN_X4_INT_ENr_AN_COMPLETED_SW_ENf_SET
#define AN_X4_INT_ENr_LD_PAGE_REQ_ENf_GET BCMI_TSCD_XGXS_AN_X4_INT_ENr_LD_PAGE_REQ_ENf_GET
#define AN_X4_INT_ENr_LD_PAGE_REQ_ENf_SET BCMI_TSCD_XGXS_AN_X4_INT_ENr_LD_PAGE_REQ_ENf_SET
#define AN_X4_INT_ENr_LP_PAGE_RDY_ENf_GET BCMI_TSCD_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_GET
#define AN_X4_INT_ENr_LP_PAGE_RDY_ENf_SET BCMI_TSCD_XGXS_AN_X4_INT_ENr_LP_PAGE_RDY_ENf_SET
#define READ_AN_X4_INT_ENr BCMI_TSCD_XGXS_READ_AN_X4_INT_ENr
#define WRITE_AN_X4_INT_ENr BCMI_TSCD_XGXS_WRITE_AN_X4_INT_ENr
#define MODIFY_AN_X4_INT_ENr BCMI_TSCD_XGXS_MODIFY_AN_X4_INT_ENr
#define READLN_AN_X4_INT_ENr BCMI_TSCD_XGXS_READLN_AN_X4_INT_ENr
#define WRITELN_AN_X4_INT_ENr BCMI_TSCD_XGXS_WRITELN_AN_X4_INT_ENr
#define WRITEALL_AN_X4_INT_ENr BCMI_TSCD_XGXS_WRITEALL_AN_X4_INT_ENr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_INT_ENr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  AN_X4_WAIT_ACK_COMPLETE
 * BLOCKS:   AN_X4_SW_MGMT
 * REGADDR:  0xc1ed
 * DESC:     Wait for ACK register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     WAIT_FOR_ACK_EN  If this bit is set, then FSM will wait for the send_ack bit to be set by SW.
 *     SEND_ACK         Now send ACK for the last page. this is set by SW cleared by HW
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr (0x0000c1ed | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SIZE 4

/*
 * This structure should be used to declare and program AN_X4_WAIT_ACK_COMPLETE.
 *
 */
typedef union BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_s {
	uint32_t v[1];
	uint32_t an_x4_wait_ack_complete[1];
	uint32_t _an_x4_wait_ack_complete;
} BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_t;

#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_CLR(r) (r).an_x4_wait_ack_complete[0] = 0
#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SET(r,d) (r).an_x4_wait_ack_complete[0] = d
#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_GET(r) (r).an_x4_wait_ack_complete[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_GET(r) ((((r).an_x4_wait_ack_complete[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_SET(r,f) (r).an_x4_wait_ack_complete[0]=(((r).an_x4_wait_ack_complete[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_GET(r) (((r).an_x4_wait_ack_complete[0]) & 0x1)
#define BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_SET(r,f) (r).an_x4_wait_ack_complete[0]=(((r).an_x4_wait_ack_complete[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AN_X4_WAIT_ACK_COMPLETE.
 *
 */
#define BCMI_TSCD_XGXS_READ_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr,(_r._an_x4_wait_ack_complete))
#define BCMI_TSCD_XGXS_WRITE_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr,(_r._an_x4_wait_ack_complete)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr,(_r._an_x4_wait_ack_complete))
#define BCMI_TSCD_XGXS_READLN_AN_X4_WAIT_ACK_COMPLETEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_wait_ack_complete))
#define BCMI_TSCD_XGXS_WRITELN_AN_X4_WAIT_ACK_COMPLETEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._an_x4_wait_ack_complete))
#define BCMI_TSCD_XGXS_WRITEALL_AN_X4_WAIT_ACK_COMPLETEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._an_x4_wait_ack_complete))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr
#define AN_X4_WAIT_ACK_COMPLETEr_SIZE BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SIZE
typedef BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_t AN_X4_WAIT_ACK_COMPLETEr_t;
#define AN_X4_WAIT_ACK_COMPLETEr_CLR BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_CLR
#define AN_X4_WAIT_ACK_COMPLETEr_SET BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SET
#define AN_X4_WAIT_ACK_COMPLETEr_GET BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_GET
#define AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_GET BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_GET
#define AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_SET BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_SEND_ACKf_SET
#define AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_GET BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_GET
#define AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_SET BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr_WAIT_FOR_ACK_ENf_SET
#define READ_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCD_XGXS_READ_AN_X4_WAIT_ACK_COMPLETEr
#define WRITE_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCD_XGXS_WRITE_AN_X4_WAIT_ACK_COMPLETEr
#define MODIFY_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCD_XGXS_MODIFY_AN_X4_WAIT_ACK_COMPLETEr
#define READLN_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCD_XGXS_READLN_AN_X4_WAIT_ACK_COMPLETEr
#define WRITELN_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCD_XGXS_WRITELN_AN_X4_WAIT_ACK_COMPLETEr
#define WRITEALL_AN_X4_WAIT_ACK_COMPLETEr BCMI_TSCD_XGXS_WRITEALL_AN_X4_WAIT_ACK_COMPLETEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_AN_X4_WAIT_ACK_COMPLETEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RXP_1588_SFD_TS_CTL
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f0
 * DESC:     SFD timestamping control
 * RESETVAL: 0x6 (6)
 * ACCESS:   R/W
 * FIELDS:
 *     CAPTURE_AM_TS    Enables the capture of AM timestamps for all the virtual lanes of CL82 based port.This feature can be enabled for Port0 or Port2 only.To restart the Rx AM timestamp capture, SW must write 0 to this bit and then write 1.
 *     RX_CL36_SOP_ADJ_10UI Only applicable to CL36If set to 1, HW will adjust SOP timestamp by -10ui when SOP-to-SFD separation is 60UIIf set to 1, HW will NOT adjust SOP timestamp when SOP-to-SFD separation is 70UIIf set to 0, HW will NOT adjust SOP timestampMust be set to 1, when HW SFD timestamping is enabledOptionally set to 1, when HW SOP timestamping is enabled
 *     SFD_TS_EN        Enables SFD timestamping, by default.Setting this bit to 0 enables SOP timestamping. HG ports are expected to use SOP timestamping.
 *     DA_TS_EN         Enables First Byte of DA timestamping.Set this bit to 0 when SOP/SFD timestamping is enabled..if DA timestamping is enabled SFD_TS_EN should be disabled..
 *     REDUCED_PREAMBLE_EN 0: default 7 bytes of preamble.1: 3 bytes of preamble.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr (0x0000c1f0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RXP_1588_SFD_TS_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_s {
	uint32_t v[1];
	uint32_t rx_x4_rxp_1588_sfd_ts_ctl[1];
	uint32_t _rx_x4_rxp_1588_sfd_ts_ctl;
} BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_t;

#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_CLR(r) (r).rx_x4_rxp_1588_sfd_ts_ctl[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SET(r,d) (r).rx_x4_rxp_1588_sfd_ts_ctl[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_GET(r) (r).rx_x4_rxp_1588_sfd_ts_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_REDUCED_PREAMBLE_ENf_GET(r) ((((r).rx_x4_rxp_1588_sfd_ts_ctl[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_REDUCED_PREAMBLE_ENf_SET(r,f) (r).rx_x4_rxp_1588_sfd_ts_ctl[0]=(((r).rx_x4_rxp_1588_sfd_ts_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_DA_TS_ENf_GET(r) ((((r).rx_x4_rxp_1588_sfd_ts_ctl[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_DA_TS_ENf_SET(r,f) (r).rx_x4_rxp_1588_sfd_ts_ctl[0]=(((r).rx_x4_rxp_1588_sfd_ts_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SFD_TS_ENf_GET(r) ((((r).rx_x4_rxp_1588_sfd_ts_ctl[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SFD_TS_ENf_SET(r,f) (r).rx_x4_rxp_1588_sfd_ts_ctl[0]=(((r).rx_x4_rxp_1588_sfd_ts_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_RX_CL36_SOP_ADJ_10UIf_GET(r) ((((r).rx_x4_rxp_1588_sfd_ts_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_RX_CL36_SOP_ADJ_10UIf_SET(r,f) (r).rx_x4_rxp_1588_sfd_ts_ctl[0]=(((r).rx_x4_rxp_1588_sfd_ts_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_CAPTURE_AM_TSf_GET(r) (((r).rx_x4_rxp_1588_sfd_ts_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_CAPTURE_AM_TSf_SET(r,f) (r).rx_x4_rxp_1588_sfd_ts_ctl[0]=(((r).rx_x4_rxp_1588_sfd_ts_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_RXP_1588_SFD_TS_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RXP_1588_SFD_TS_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr,(_r._rx_x4_rxp_1588_sfd_ts_ctl))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RXP_1588_SFD_TS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr,(_r._rx_x4_rxp_1588_sfd_ts_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RXP_1588_SFD_TS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr,(_r._rx_x4_rxp_1588_sfd_ts_ctl))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RXP_1588_SFD_TS_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rxp_1588_sfd_ts_ctl))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RXP_1588_SFD_TS_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rxp_1588_sfd_ts_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RXP_1588_SFD_TS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rxp_1588_sfd_ts_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RXP_1588_SFD_TS_CTLr BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr
#define RX_X4_RXP_1588_SFD_TS_CTLr_SIZE BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_t RX_X4_RXP_1588_SFD_TS_CTLr_t;
#define RX_X4_RXP_1588_SFD_TS_CTLr_CLR BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_CLR
#define RX_X4_RXP_1588_SFD_TS_CTLr_SET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SET
#define RX_X4_RXP_1588_SFD_TS_CTLr_GET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_GET
#define RX_X4_RXP_1588_SFD_TS_CTLr_REDUCED_PREAMBLE_ENf_GET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_REDUCED_PREAMBLE_ENf_GET
#define RX_X4_RXP_1588_SFD_TS_CTLr_REDUCED_PREAMBLE_ENf_SET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_REDUCED_PREAMBLE_ENf_SET
#define RX_X4_RXP_1588_SFD_TS_CTLr_DA_TS_ENf_GET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_DA_TS_ENf_GET
#define RX_X4_RXP_1588_SFD_TS_CTLr_DA_TS_ENf_SET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_DA_TS_ENf_SET
#define RX_X4_RXP_1588_SFD_TS_CTLr_SFD_TS_ENf_GET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SFD_TS_ENf_GET
#define RX_X4_RXP_1588_SFD_TS_CTLr_SFD_TS_ENf_SET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_SFD_TS_ENf_SET
#define RX_X4_RXP_1588_SFD_TS_CTLr_RX_CL36_SOP_ADJ_10UIf_GET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_RX_CL36_SOP_ADJ_10UIf_GET
#define RX_X4_RXP_1588_SFD_TS_CTLr_RX_CL36_SOP_ADJ_10UIf_SET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_RX_CL36_SOP_ADJ_10UIf_SET
#define RX_X4_RXP_1588_SFD_TS_CTLr_CAPTURE_AM_TSf_GET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_CAPTURE_AM_TSf_GET
#define RX_X4_RXP_1588_SFD_TS_CTLr_CAPTURE_AM_TSf_SET BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr_CAPTURE_AM_TSf_SET
#define READ_RX_X4_RXP_1588_SFD_TS_CTLr BCMI_TSCD_XGXS_READ_RX_X4_RXP_1588_SFD_TS_CTLr
#define WRITE_RX_X4_RXP_1588_SFD_TS_CTLr BCMI_TSCD_XGXS_WRITE_RX_X4_RXP_1588_SFD_TS_CTLr
#define MODIFY_RX_X4_RXP_1588_SFD_TS_CTLr BCMI_TSCD_XGXS_MODIFY_RX_X4_RXP_1588_SFD_TS_CTLr
#define READLN_RX_X4_RXP_1588_SFD_TS_CTLr BCMI_TSCD_XGXS_READLN_RX_X4_RXP_1588_SFD_TS_CTLr
#define WRITELN_RX_X4_RXP_1588_SFD_TS_CTLr BCMI_TSCD_XGXS_WRITELN_RX_X4_RXP_1588_SFD_TS_CTLr
#define WRITEALL_RX_X4_RXP_1588_SFD_TS_CTLr BCMI_TSCD_XGXS_WRITEALL_RX_X4_RXP_1588_SFD_TS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RXP_1588_SFD_TS_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_INT0
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f1
 * DESC:     RX deskew Adjustment0 Integer nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_INT_NS_0  PMD RX deskew adjustment in nanoseconds. Signed 2s complement value. Indexed by Logical Lane.This field represents the Integral Part of Deskew adjustment for Virtual Lanes as explained below.In 100G MLD mode(Port0) - VL0/VL5/VL10/VL15In 40G MLD mode over 2 lanes(Port0 or Port2) - VL0/VL2In 40G MLD mode over 4 lanes(Port0) - VL0/VL1/VL2/VL3In 20G MLD mode over 2 lanes(Port0 or Port2) - VL0/VL1Programmed by SW. HW will sign-extend to 48 bits.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r (0x0000c1f1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_INT0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_int0[1];
	uint32_t _rx_x4_rx_deskew_adj_int0;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_CLR(r) (r).rx_x4_rx_deskew_adj_int0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_SET(r,d) (r).rx_x4_rx_deskew_adj_int0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_GET(r) (r).rx_x4_rx_deskew_adj_int0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_TAB_DS_INT_NS_0f_GET(r) (((r).rx_x4_rx_deskew_adj_int0[0]) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_TAB_DS_INT_NS_0f_SET(r,f) (r).rx_x4_rx_deskew_adj_int0[0]=(((r).rx_x4_rx_deskew_adj_int0[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_INT0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r,(_r._rx_x4_rx_deskew_adj_int0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r,(_r._rx_x4_rx_deskew_adj_int0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r,(_r._rx_x4_rx_deskew_adj_int0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_int0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_INT0r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r
#define RX_X4_RX_DESKEW_ADJ_INT0r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_t RX_X4_RX_DESKEW_ADJ_INT0r_t;
#define RX_X4_RX_DESKEW_ADJ_INT0r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_CLR
#define RX_X4_RX_DESKEW_ADJ_INT0r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_SET
#define RX_X4_RX_DESKEW_ADJ_INT0r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_GET
#define RX_X4_RX_DESKEW_ADJ_INT0r_TAB_DS_INT_NS_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_TAB_DS_INT_NS_0f_GET
#define RX_X4_RX_DESKEW_ADJ_INT0r_TAB_DS_INT_NS_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r_TAB_DS_INT_NS_0f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_INT0r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT0r
#define WRITE_RX_X4_RX_DESKEW_ADJ_INT0r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT0r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_INT0r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT0r
#define READLN_RX_X4_RX_DESKEW_ADJ_INT0r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT0r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_INT0r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT0r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_INT0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_FRAC0
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f2
 * DESC:     RX deskew Adjustment0 Fractional nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_FRAC_NS_0 PMD RX deskew adjustment in fractional nanoseconds. Signed 2s complement value as an extension of tab_ds_int_ns.Indexed by Logical Lane.This field represents the Fractional Part of Deskew adjustment for Virtual Lanes as explained below.In 100G MLD mode(Port0) - VL0/VL5/VL10/VL15In 40G MLD mode over 2 lanes(Port0 or Port2) - VL0/VL2In 40G MLD mode over 4 lanes(Port0) - VL0/VL1/VL2/VL3In 20G MLD mode over 2 lanes(Port0 or Port2) - VL0/VL1
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r (0x0000c1f2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_FRAC0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_frac0[1];
	uint32_t _rx_x4_rx_deskew_adj_frac0;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_CLR(r) (r).rx_x4_rx_deskew_adj_frac0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_SET(r,d) (r).rx_x4_rx_deskew_adj_frac0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_GET(r) (r).rx_x4_rx_deskew_adj_frac0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_TAB_DS_FRAC_NS_0f_GET(r) ((((r).rx_x4_rx_deskew_adj_frac0[0]) >> 6) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_TAB_DS_FRAC_NS_0f_SET(r,f) (r).rx_x4_rx_deskew_adj_frac0[0]=(((r).rx_x4_rx_deskew_adj_frac0[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_FRAC0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r,(_r._rx_x4_rx_deskew_adj_frac0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r,(_r._rx_x4_rx_deskew_adj_frac0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r,(_r._rx_x4_rx_deskew_adj_frac0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_frac0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_FRAC0r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r
#define RX_X4_RX_DESKEW_ADJ_FRAC0r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_t RX_X4_RX_DESKEW_ADJ_FRAC0r_t;
#define RX_X4_RX_DESKEW_ADJ_FRAC0r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_CLR
#define RX_X4_RX_DESKEW_ADJ_FRAC0r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_SET
#define RX_X4_RX_DESKEW_ADJ_FRAC0r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC0r_TAB_DS_FRAC_NS_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_TAB_DS_FRAC_NS_0f_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC0r_TAB_DS_FRAC_NS_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r_TAB_DS_FRAC_NS_0f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_FRAC0r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC0r
#define WRITE_RX_X4_RX_DESKEW_ADJ_FRAC0r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC0r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC0r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC0r
#define READLN_RX_X4_RX_DESKEW_ADJ_FRAC0r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC0r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC0r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC0r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_INT1
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f3
 * DESC:     RX deskew Adjustment1 Integer nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_INT_NS_1  PMD RX deskew adjustment in nanoseconds. Signed 2s complement value. Indexed by Logical Lane.This field represents the Integral Part of Deskew adjustment for Virtual Lanes as explained below.In 100G MLD mode(Port0) - VL1/VL6/VL11/VL16In 40G MLD mode over 2 lanes(Port0 or Port2) - VL1/VL3Programmed by SW. HW will sign-extend to 48 bits.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r (0x0000c1f3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_INT1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_int1[1];
	uint32_t _rx_x4_rx_deskew_adj_int1;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_CLR(r) (r).rx_x4_rx_deskew_adj_int1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_SET(r,d) (r).rx_x4_rx_deskew_adj_int1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_GET(r) (r).rx_x4_rx_deskew_adj_int1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_TAB_DS_INT_NS_1f_GET(r) (((r).rx_x4_rx_deskew_adj_int1[0]) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_TAB_DS_INT_NS_1f_SET(r,f) (r).rx_x4_rx_deskew_adj_int1[0]=(((r).rx_x4_rx_deskew_adj_int1[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_INT1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r,(_r._rx_x4_rx_deskew_adj_int1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r,(_r._rx_x4_rx_deskew_adj_int1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r,(_r._rx_x4_rx_deskew_adj_int1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_int1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_INT1r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r
#define RX_X4_RX_DESKEW_ADJ_INT1r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_t RX_X4_RX_DESKEW_ADJ_INT1r_t;
#define RX_X4_RX_DESKEW_ADJ_INT1r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_CLR
#define RX_X4_RX_DESKEW_ADJ_INT1r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_SET
#define RX_X4_RX_DESKEW_ADJ_INT1r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_GET
#define RX_X4_RX_DESKEW_ADJ_INT1r_TAB_DS_INT_NS_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_TAB_DS_INT_NS_1f_GET
#define RX_X4_RX_DESKEW_ADJ_INT1r_TAB_DS_INT_NS_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r_TAB_DS_INT_NS_1f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_INT1r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT1r
#define WRITE_RX_X4_RX_DESKEW_ADJ_INT1r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT1r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_INT1r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT1r
#define READLN_RX_X4_RX_DESKEW_ADJ_INT1r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT1r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_INT1r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT1r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_INT1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_FRAC1
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f4
 * DESC:     RX deskew Adjustment1 Fractional nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_FRAC_NS_1 PMD RX deskew adjustment in fractional nanoseconds. Signed 2s complement value as an extension of tab_ds_int_ns.Indexed by Logical Lane.This field represents the Fractional Part of Deskew adjustment for Virtual Lanes as explained below.In 100G MLD mode(Port0) - VL1/VL6/VL11/VL16In 40G MLD mode over 2 lanes(Port0 or Port2) - VL1/VL3
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r (0x0000c1f4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_FRAC1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_frac1[1];
	uint32_t _rx_x4_rx_deskew_adj_frac1;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_CLR(r) (r).rx_x4_rx_deskew_adj_frac1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_SET(r,d) (r).rx_x4_rx_deskew_adj_frac1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_GET(r) (r).rx_x4_rx_deskew_adj_frac1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_TAB_DS_FRAC_NS_1f_GET(r) ((((r).rx_x4_rx_deskew_adj_frac1[0]) >> 6) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_TAB_DS_FRAC_NS_1f_SET(r,f) (r).rx_x4_rx_deskew_adj_frac1[0]=(((r).rx_x4_rx_deskew_adj_frac1[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_FRAC1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r,(_r._rx_x4_rx_deskew_adj_frac1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r,(_r._rx_x4_rx_deskew_adj_frac1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r,(_r._rx_x4_rx_deskew_adj_frac1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_frac1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_FRAC1r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r
#define RX_X4_RX_DESKEW_ADJ_FRAC1r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_t RX_X4_RX_DESKEW_ADJ_FRAC1r_t;
#define RX_X4_RX_DESKEW_ADJ_FRAC1r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_CLR
#define RX_X4_RX_DESKEW_ADJ_FRAC1r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_SET
#define RX_X4_RX_DESKEW_ADJ_FRAC1r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC1r_TAB_DS_FRAC_NS_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_TAB_DS_FRAC_NS_1f_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC1r_TAB_DS_FRAC_NS_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r_TAB_DS_FRAC_NS_1f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_FRAC1r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC1r
#define WRITE_RX_X4_RX_DESKEW_ADJ_FRAC1r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC1r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC1r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC1r
#define READLN_RX_X4_RX_DESKEW_ADJ_FRAC1r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC1r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC1r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC1r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_INT2
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f5
 * DESC:     RX deskew Adjustment2 Integer nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_INT_NS_2  PMD RX deskew adjustment in nanoseconds. Signed 2s complement value. Indexed by Logical Lane.This field represents the Integral Part of Deskew adjustment for Virtual Lanes VL2 or VL7 or VL12 or VL17 in 100G MLD mode.Programmed by SW. HW will sign-extend to 48 bits.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r (0x0000c1f5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_INT2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_int2[1];
	uint32_t _rx_x4_rx_deskew_adj_int2;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_CLR(r) (r).rx_x4_rx_deskew_adj_int2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_SET(r,d) (r).rx_x4_rx_deskew_adj_int2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_GET(r) (r).rx_x4_rx_deskew_adj_int2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_TAB_DS_INT_NS_2f_GET(r) (((r).rx_x4_rx_deskew_adj_int2[0]) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_TAB_DS_INT_NS_2f_SET(r,f) (r).rx_x4_rx_deskew_adj_int2[0]=(((r).rx_x4_rx_deskew_adj_int2[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_INT2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r,(_r._rx_x4_rx_deskew_adj_int2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r,(_r._rx_x4_rx_deskew_adj_int2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r,(_r._rx_x4_rx_deskew_adj_int2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_int2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_INT2r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r
#define RX_X4_RX_DESKEW_ADJ_INT2r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_t RX_X4_RX_DESKEW_ADJ_INT2r_t;
#define RX_X4_RX_DESKEW_ADJ_INT2r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_CLR
#define RX_X4_RX_DESKEW_ADJ_INT2r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_SET
#define RX_X4_RX_DESKEW_ADJ_INT2r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_GET
#define RX_X4_RX_DESKEW_ADJ_INT2r_TAB_DS_INT_NS_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_TAB_DS_INT_NS_2f_GET
#define RX_X4_RX_DESKEW_ADJ_INT2r_TAB_DS_INT_NS_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r_TAB_DS_INT_NS_2f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_INT2r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT2r
#define WRITE_RX_X4_RX_DESKEW_ADJ_INT2r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT2r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_INT2r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT2r
#define READLN_RX_X4_RX_DESKEW_ADJ_INT2r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT2r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_INT2r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT2r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_INT2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_FRAC2
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f6
 * DESC:     RX deskew Adjustment2 Fractional nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_FRAC_NS_2 PMD RX deskew adjustment in fractional nanoseconds. Signed 2s complement value as an extension of tab_ds_int_ns.Indexed by Logical Lane.This field represents the Fractional Part of Deskew adjustment for Virtual Lanes VL2 or VL7 or VL12 or VL17 in 100G MLD mode.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r (0x0000c1f6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_FRAC2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_frac2[1];
	uint32_t _rx_x4_rx_deskew_adj_frac2;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_CLR(r) (r).rx_x4_rx_deskew_adj_frac2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_SET(r,d) (r).rx_x4_rx_deskew_adj_frac2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_GET(r) (r).rx_x4_rx_deskew_adj_frac2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_TAB_DS_FRAC_NS_2f_GET(r) ((((r).rx_x4_rx_deskew_adj_frac2[0]) >> 6) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_TAB_DS_FRAC_NS_2f_SET(r,f) (r).rx_x4_rx_deskew_adj_frac2[0]=(((r).rx_x4_rx_deskew_adj_frac2[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_FRAC2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r,(_r._rx_x4_rx_deskew_adj_frac2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r,(_r._rx_x4_rx_deskew_adj_frac2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r,(_r._rx_x4_rx_deskew_adj_frac2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_frac2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_FRAC2r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r
#define RX_X4_RX_DESKEW_ADJ_FRAC2r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_t RX_X4_RX_DESKEW_ADJ_FRAC2r_t;
#define RX_X4_RX_DESKEW_ADJ_FRAC2r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_CLR
#define RX_X4_RX_DESKEW_ADJ_FRAC2r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_SET
#define RX_X4_RX_DESKEW_ADJ_FRAC2r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC2r_TAB_DS_FRAC_NS_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_TAB_DS_FRAC_NS_2f_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC2r_TAB_DS_FRAC_NS_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r_TAB_DS_FRAC_NS_2f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_FRAC2r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC2r
#define WRITE_RX_X4_RX_DESKEW_ADJ_FRAC2r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC2r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC2r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC2r
#define READLN_RX_X4_RX_DESKEW_ADJ_FRAC2r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC2r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC2r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC2r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_INT3
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f7
 * DESC:     RX deskew Adjustment3 Integer nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_INT_NS_3  PMD RX deskew adjustment in nanoseconds. Signed 2s complement value. Indexed by Logical Lane.This field represents the Integral Part of Deskew adjustment for Virtual Lanes VL3 or VL8 or VL13 or VL18 in 100G MLD mode.Programmed by SW. HW will sign-extend to 48 bits.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r (0x0000c1f7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_INT3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_int3[1];
	uint32_t _rx_x4_rx_deskew_adj_int3;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_CLR(r) (r).rx_x4_rx_deskew_adj_int3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_SET(r,d) (r).rx_x4_rx_deskew_adj_int3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_GET(r) (r).rx_x4_rx_deskew_adj_int3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_TAB_DS_INT_NS_3f_GET(r) (((r).rx_x4_rx_deskew_adj_int3[0]) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_TAB_DS_INT_NS_3f_SET(r,f) (r).rx_x4_rx_deskew_adj_int3[0]=(((r).rx_x4_rx_deskew_adj_int3[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_INT3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r,(_r._rx_x4_rx_deskew_adj_int3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r,(_r._rx_x4_rx_deskew_adj_int3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r,(_r._rx_x4_rx_deskew_adj_int3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_int3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_INT3r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r
#define RX_X4_RX_DESKEW_ADJ_INT3r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_t RX_X4_RX_DESKEW_ADJ_INT3r_t;
#define RX_X4_RX_DESKEW_ADJ_INT3r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_CLR
#define RX_X4_RX_DESKEW_ADJ_INT3r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_SET
#define RX_X4_RX_DESKEW_ADJ_INT3r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_GET
#define RX_X4_RX_DESKEW_ADJ_INT3r_TAB_DS_INT_NS_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_TAB_DS_INT_NS_3f_GET
#define RX_X4_RX_DESKEW_ADJ_INT3r_TAB_DS_INT_NS_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r_TAB_DS_INT_NS_3f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_INT3r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT3r
#define WRITE_RX_X4_RX_DESKEW_ADJ_INT3r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT3r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_INT3r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT3r
#define READLN_RX_X4_RX_DESKEW_ADJ_INT3r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT3r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_INT3r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT3r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_INT3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_FRAC3
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f8
 * DESC:     RX deskew Adjustment3 Fractional nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_FRAC_NS_3 PMD RX deskew adjustment in fractional nanoseconds. Signed 2s complement value as an extension of tab_ds_int_ns.Indexed by Logical Lane.This field represents the Fractional Part of Deskew adjustment for Virtual Lanes VL3 or VL8 or VL13 or VL18 in 100G MLD mode.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r (0x0000c1f8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_FRAC3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_frac3[1];
	uint32_t _rx_x4_rx_deskew_adj_frac3;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_CLR(r) (r).rx_x4_rx_deskew_adj_frac3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_SET(r,d) (r).rx_x4_rx_deskew_adj_frac3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_GET(r) (r).rx_x4_rx_deskew_adj_frac3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_TAB_DS_FRAC_NS_3f_GET(r) ((((r).rx_x4_rx_deskew_adj_frac3[0]) >> 6) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_TAB_DS_FRAC_NS_3f_SET(r,f) (r).rx_x4_rx_deskew_adj_frac3[0]=(((r).rx_x4_rx_deskew_adj_frac3[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_FRAC3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r,(_r._rx_x4_rx_deskew_adj_frac3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r,(_r._rx_x4_rx_deskew_adj_frac3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r,(_r._rx_x4_rx_deskew_adj_frac3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_frac3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_FRAC3r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r
#define RX_X4_RX_DESKEW_ADJ_FRAC3r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_t RX_X4_RX_DESKEW_ADJ_FRAC3r_t;
#define RX_X4_RX_DESKEW_ADJ_FRAC3r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_CLR
#define RX_X4_RX_DESKEW_ADJ_FRAC3r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_SET
#define RX_X4_RX_DESKEW_ADJ_FRAC3r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC3r_TAB_DS_FRAC_NS_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_TAB_DS_FRAC_NS_3f_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC3r_TAB_DS_FRAC_NS_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r_TAB_DS_FRAC_NS_3f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_FRAC3r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC3r
#define WRITE_RX_X4_RX_DESKEW_ADJ_FRAC3r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC3r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC3r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC3r
#define READLN_RX_X4_RX_DESKEW_ADJ_FRAC3r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC3r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC3r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC3r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_INT4
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1f9
 * DESC:     RX deskew Adjustment4 Integer nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_INT_NS_4  PMD RX deskew adjustment in nanoseconds. Signed 2s complement value. Indexed by Logical Lane.This field represents the Integral Part of Deskew adjustment for Virtual Lanes VL4 or VL9 or VL14 or VL19 in 100G MLD mode.Programmed by SW. HW will sign-extend to 48 bits.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r (0x0000c1f9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_INT4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_int4[1];
	uint32_t _rx_x4_rx_deskew_adj_int4;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_CLR(r) (r).rx_x4_rx_deskew_adj_int4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_SET(r,d) (r).rx_x4_rx_deskew_adj_int4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_GET(r) (r).rx_x4_rx_deskew_adj_int4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_TAB_DS_INT_NS_4f_GET(r) (((r).rx_x4_rx_deskew_adj_int4[0]) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_TAB_DS_INT_NS_4f_SET(r,f) (r).rx_x4_rx_deskew_adj_int4[0]=(((r).rx_x4_rx_deskew_adj_int4[0] & ~((uint32_t)0xfff)) | (((uint32_t)f) & 0xfff)) | (0xfff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_INT4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r,(_r._rx_x4_rx_deskew_adj_int4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r,(_r._rx_x4_rx_deskew_adj_int4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r,(_r._rx_x4_rx_deskew_adj_int4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_int4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_int4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_INT4r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r
#define RX_X4_RX_DESKEW_ADJ_INT4r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_t RX_X4_RX_DESKEW_ADJ_INT4r_t;
#define RX_X4_RX_DESKEW_ADJ_INT4r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_CLR
#define RX_X4_RX_DESKEW_ADJ_INT4r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_SET
#define RX_X4_RX_DESKEW_ADJ_INT4r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_GET
#define RX_X4_RX_DESKEW_ADJ_INT4r_TAB_DS_INT_NS_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_TAB_DS_INT_NS_4f_GET
#define RX_X4_RX_DESKEW_ADJ_INT4r_TAB_DS_INT_NS_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r_TAB_DS_INT_NS_4f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_INT4r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_INT4r
#define WRITE_RX_X4_RX_DESKEW_ADJ_INT4r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_INT4r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_INT4r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_INT4r
#define READLN_RX_X4_RX_DESKEW_ADJ_INT4r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_INT4r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_INT4r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_INT4r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_INT4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_INT4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_INT4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_ADJ_FRAC4
 * BLOCKS:   RX_X4_CONTROL1
 * REGADDR:  0xc1fa
 * DESC:     RX deskew Adjustment4 Fractional nanoseconds(Virtual lane based)
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TAB_DS_FRAC_NS_4 PMD RX deskew adjustment in fractional nanoseconds. Signed 2s complement value as an extension of tab_ds_int_ns.Indexed by Logical Lane.This field represents the Fractional Part of Deskew adjustment for Virtual Lanes VL4 or VL9 or VL14 or VL19 in 100G MLD mode.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r (0x0000c1fa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_ADJ_FRAC4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_adj_frac4[1];
	uint32_t _rx_x4_rx_deskew_adj_frac4;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_CLR(r) (r).rx_x4_rx_deskew_adj_frac4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_SET(r,d) (r).rx_x4_rx_deskew_adj_frac4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_GET(r) (r).rx_x4_rx_deskew_adj_frac4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_TAB_DS_FRAC_NS_4f_GET(r) ((((r).rx_x4_rx_deskew_adj_frac4[0]) >> 6) & 0x3ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_TAB_DS_FRAC_NS_4f_SET(r,f) (r).rx_x4_rx_deskew_adj_frac4[0]=(((r).rx_x4_rx_deskew_adj_frac4[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access RX_X4_RX_DESKEW_ADJ_FRAC4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r,(_r._rx_x4_rx_deskew_adj_frac4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r,(_r._rx_x4_rx_deskew_adj_frac4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r,(_r._rx_x4_rx_deskew_adj_frac4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_adj_frac4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_adj_frac4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_ADJ_FRAC4r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r
#define RX_X4_RX_DESKEW_ADJ_FRAC4r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_t RX_X4_RX_DESKEW_ADJ_FRAC4r_t;
#define RX_X4_RX_DESKEW_ADJ_FRAC4r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_CLR
#define RX_X4_RX_DESKEW_ADJ_FRAC4r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_SET
#define RX_X4_RX_DESKEW_ADJ_FRAC4r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC4r_TAB_DS_FRAC_NS_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_TAB_DS_FRAC_NS_4f_GET
#define RX_X4_RX_DESKEW_ADJ_FRAC4r_TAB_DS_FRAC_NS_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r_TAB_DS_FRAC_NS_4f_SET
#define READ_RX_X4_RX_DESKEW_ADJ_FRAC4r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_ADJ_FRAC4r
#define WRITE_RX_X4_RX_DESKEW_ADJ_FRAC4r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_ADJ_FRAC4r
#define MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC4r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_ADJ_FRAC4r
#define READLN_RX_X4_RX_DESKEW_ADJ_FRAC4r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_ADJ_FRAC4r
#define WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC4r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_ADJ_FRAC4r
#define WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_ADJ_FRAC4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_ADJ_FRAC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  ILKN_CTL0
 * BLOCKS:   ILKN_X4_CONTROL0
 * REGADDR:  0xc330
 * DESC:     ilkn control 0 register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     WM               Watermark to reach before data from bypass interface is sent on egress data pathWatermark applies to the egress path onlyThe optimal setting of the watermark is between 2 and 6Watermark level of 2 is set for any configuration value of less than 2Watermark level of 6 is set for any configuration value of greater than 6
 *     ILKN_SEL         1 = enable ingress and egress data paths through ilkn bypass logicWhen 0, data paths are connected to the PCS interface
 *     INV_TX_ORDER     1 = when tx20_sel is 1, bit[39:20] from bypass interface is first sent on the egress data path0 = when tx20_sel is 1, bit[19:0] from bypass interface is first sent on the egress data path
 *     INV_RX_ORDER     1 = when rx20_sel is 1, ingress data from serdes is first packed into bit[39:20] of the bypass interface0 = when rx20_sel is 1, ingress data from serdes is first packed into bit[19:0] of the bypass interface
 *     SOFT_RST_TX      1 = reset tx path logic, other register setting is not changed; set bit to 0 for normal operation
 *     SOFT_RST_RX      1 = reset rx path logic, other register setting is not changed; set bit to 0 for normal operation
 *     CREDIT_EN        1 = enable credit generation to bypass interface on the egress pathWhen 0, no credit is issued for the egress path of the bypass interface
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_ILKN_CTL0r (0x0000c330 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_ILKN_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program ILKN_CTL0.
 *
 */
typedef union BCMI_TSCD_XGXS_ILKN_CTL0r_s {
	uint32_t v[1];
	uint32_t ilkn_ctl0[1];
	uint32_t _ilkn_ctl0;
} BCMI_TSCD_XGXS_ILKN_CTL0r_t;

#define BCMI_TSCD_XGXS_ILKN_CTL0r_CLR(r) (r).ilkn_ctl0[0] = 0
#define BCMI_TSCD_XGXS_ILKN_CTL0r_SET(r,d) (r).ilkn_ctl0[0] = d
#define BCMI_TSCD_XGXS_ILKN_CTL0r_GET(r) (r).ilkn_ctl0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_ILKN_CTL0r_CREDIT_ENf_GET(r) ((((r).ilkn_ctl0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_CTL0r_CREDIT_ENf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_RXf_GET(r) ((((r).ilkn_ctl0[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_RXf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_TXf_GET(r) ((((r).ilkn_ctl0[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_TXf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_ILKN_CTL0r_INV_RX_ORDERf_GET(r) ((((r).ilkn_ctl0[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_CTL0r_INV_RX_ORDERf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_ILKN_CTL0r_INV_TX_ORDERf_GET(r) ((((r).ilkn_ctl0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_CTL0r_INV_TX_ORDERf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_ILKN_CTL0r_ILKN_SELf_GET(r) ((((r).ilkn_ctl0[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_CTL0r_ILKN_SELf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_ILKN_CTL0r_WMf_GET(r) (((r).ilkn_ctl0[0]) & 0xf)
#define BCMI_TSCD_XGXS_ILKN_CTL0r_WMf_SET(r,f) (r).ilkn_ctl0[0]=(((r).ilkn_ctl0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access ILKN_CTL0.
 *
 */
#define BCMI_TSCD_XGXS_READ_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_ILKN_CTL0r,(_r._ilkn_ctl0))
#define BCMI_TSCD_XGXS_WRITE_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_CTL0r,(_r._ilkn_ctl0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_CTL0r,(_r._ilkn_ctl0))
#define BCMI_TSCD_XGXS_READLN_ILKN_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_ILKN_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_ctl0))
#define BCMI_TSCD_XGXS_WRITELN_ILKN_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_ctl0))
#define BCMI_TSCD_XGXS_WRITEALL_ILKN_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ilkn_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ILKN_CTL0r BCMI_TSCD_XGXS_ILKN_CTL0r
#define ILKN_CTL0r_SIZE BCMI_TSCD_XGXS_ILKN_CTL0r_SIZE
typedef BCMI_TSCD_XGXS_ILKN_CTL0r_t ILKN_CTL0r_t;
#define ILKN_CTL0r_CLR BCMI_TSCD_XGXS_ILKN_CTL0r_CLR
#define ILKN_CTL0r_SET BCMI_TSCD_XGXS_ILKN_CTL0r_SET
#define ILKN_CTL0r_GET BCMI_TSCD_XGXS_ILKN_CTL0r_GET
#define ILKN_CTL0r_CREDIT_ENf_GET BCMI_TSCD_XGXS_ILKN_CTL0r_CREDIT_ENf_GET
#define ILKN_CTL0r_CREDIT_ENf_SET BCMI_TSCD_XGXS_ILKN_CTL0r_CREDIT_ENf_SET
#define ILKN_CTL0r_SOFT_RST_RXf_GET BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_RXf_GET
#define ILKN_CTL0r_SOFT_RST_RXf_SET BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_RXf_SET
#define ILKN_CTL0r_SOFT_RST_TXf_GET BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_TXf_GET
#define ILKN_CTL0r_SOFT_RST_TXf_SET BCMI_TSCD_XGXS_ILKN_CTL0r_SOFT_RST_TXf_SET
#define ILKN_CTL0r_INV_RX_ORDERf_GET BCMI_TSCD_XGXS_ILKN_CTL0r_INV_RX_ORDERf_GET
#define ILKN_CTL0r_INV_RX_ORDERf_SET BCMI_TSCD_XGXS_ILKN_CTL0r_INV_RX_ORDERf_SET
#define ILKN_CTL0r_INV_TX_ORDERf_GET BCMI_TSCD_XGXS_ILKN_CTL0r_INV_TX_ORDERf_GET
#define ILKN_CTL0r_INV_TX_ORDERf_SET BCMI_TSCD_XGXS_ILKN_CTL0r_INV_TX_ORDERf_SET
#define ILKN_CTL0r_ILKN_SELf_GET BCMI_TSCD_XGXS_ILKN_CTL0r_ILKN_SELf_GET
#define ILKN_CTL0r_ILKN_SELf_SET BCMI_TSCD_XGXS_ILKN_CTL0r_ILKN_SELf_SET
#define ILKN_CTL0r_WMf_GET BCMI_TSCD_XGXS_ILKN_CTL0r_WMf_GET
#define ILKN_CTL0r_WMf_SET BCMI_TSCD_XGXS_ILKN_CTL0r_WMf_SET
#define READ_ILKN_CTL0r BCMI_TSCD_XGXS_READ_ILKN_CTL0r
#define WRITE_ILKN_CTL0r BCMI_TSCD_XGXS_WRITE_ILKN_CTL0r
#define MODIFY_ILKN_CTL0r BCMI_TSCD_XGXS_MODIFY_ILKN_CTL0r
#define READLN_ILKN_CTL0r BCMI_TSCD_XGXS_READLN_ILKN_CTL0r
#define WRITELN_ILKN_CTL0r BCMI_TSCD_XGXS_WRITELN_ILKN_CTL0r
#define WRITEALL_ILKN_CTL0r BCMI_TSCD_XGXS_WRITEALL_ILKN_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_ILKN_CTL0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  ILKN_STS0
 * BLOCKS:   ILKN_X4_STATUS0
 * REGADDR:  0xc340
 * DESC:     ilkn status 0 register
 * RESETVAL: 0x11 (17)
 * ACCESS:   R/W
 * FIELDS:
 *     RXFIFO_EMPTY     rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in bypass rxclk domain; rxfifo is empty
 *     RXFIFO_FULL      rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in serdes rxclk domain; rxfifo is full
 *     RXFIFO_OVERRUN   rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in bypass rxclk domain; rxfifo is being written when full
 *     RXFIFO_UNDERRUN  rxfifo status  - mainly for simulatin and debug purposesreal time rxfifo status in bypass rxclk domain; rxfifo is being read when empty
 *     TXFIFO_EMPTY     txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in serdes txwclk domain; txfifo is empty
 *     TXFIFO_FULL      txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in bypass txclk domain; txfifo is full
 *     TXFIFO_OVERRUN   txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in serdes txwclk domain; txfifo is being written when full
 *     TXFIFO_UNDERRUN  txfifo status  - mainly for simulatin and debug purposesreal time txfifo status in serdes txwclk domain; txfifo is being read when empty
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_ILKN_STS0r (0x0000c340 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_ILKN_STS0r_SIZE 4

/*
 * This structure should be used to declare and program ILKN_STS0.
 *
 */
typedef union BCMI_TSCD_XGXS_ILKN_STS0r_s {
	uint32_t v[1];
	uint32_t ilkn_sts0[1];
	uint32_t _ilkn_sts0;
} BCMI_TSCD_XGXS_ILKN_STS0r_t;

#define BCMI_TSCD_XGXS_ILKN_STS0r_CLR(r) (r).ilkn_sts0[0] = 0
#define BCMI_TSCD_XGXS_ILKN_STS0r_SET(r,d) (r).ilkn_sts0[0] = d
#define BCMI_TSCD_XGXS_ILKN_STS0r_GET(r) (r).ilkn_sts0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_FULLf_GET(r) ((((r).ilkn_sts0[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_FULLf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_GET(r) ((((r).ilkn_sts0[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_GET(r) ((((r).ilkn_sts0[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_FULLf_GET(r) ((((r).ilkn_sts0[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_FULLf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_GET(r) (((r).ilkn_sts0[0]) & 0x1)
#define BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_SET(r,f) (r).ilkn_sts0[0]=(((r).ilkn_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access ILKN_STS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_ILKN_STS0r,(_r._ilkn_sts0))
#define BCMI_TSCD_XGXS_WRITE_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_STS0r,(_r._ilkn_sts0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_STS0r,(_r._ilkn_sts0))
#define BCMI_TSCD_XGXS_READLN_ILKN_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_ILKN_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_sts0))
#define BCMI_TSCD_XGXS_WRITELN_ILKN_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ilkn_sts0))
#define BCMI_TSCD_XGXS_WRITEALL_ILKN_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_ILKN_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ilkn_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ILKN_STS0r BCMI_TSCD_XGXS_ILKN_STS0r
#define ILKN_STS0r_SIZE BCMI_TSCD_XGXS_ILKN_STS0r_SIZE
typedef BCMI_TSCD_XGXS_ILKN_STS0r_t ILKN_STS0r_t;
#define ILKN_STS0r_CLR BCMI_TSCD_XGXS_ILKN_STS0r_CLR
#define ILKN_STS0r_SET BCMI_TSCD_XGXS_ILKN_STS0r_SET
#define ILKN_STS0r_GET BCMI_TSCD_XGXS_ILKN_STS0r_GET
#define ILKN_STS0r_TXFIFO_UNDERRUNf_GET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_GET
#define ILKN_STS0r_TXFIFO_UNDERRUNf_SET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_UNDERRUNf_SET
#define ILKN_STS0r_TXFIFO_OVERRUNf_GET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_GET
#define ILKN_STS0r_TXFIFO_OVERRUNf_SET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_OVERRUNf_SET
#define ILKN_STS0r_TXFIFO_FULLf_GET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_FULLf_GET
#define ILKN_STS0r_TXFIFO_FULLf_SET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_FULLf_SET
#define ILKN_STS0r_TXFIFO_EMPTYf_GET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_GET
#define ILKN_STS0r_TXFIFO_EMPTYf_SET BCMI_TSCD_XGXS_ILKN_STS0r_TXFIFO_EMPTYf_SET
#define ILKN_STS0r_RXFIFO_UNDERRUNf_GET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_GET
#define ILKN_STS0r_RXFIFO_UNDERRUNf_SET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_UNDERRUNf_SET
#define ILKN_STS0r_RXFIFO_OVERRUNf_GET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_GET
#define ILKN_STS0r_RXFIFO_OVERRUNf_SET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_OVERRUNf_SET
#define ILKN_STS0r_RXFIFO_FULLf_GET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_FULLf_GET
#define ILKN_STS0r_RXFIFO_FULLf_SET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_FULLf_SET
#define ILKN_STS0r_RXFIFO_EMPTYf_GET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_GET
#define ILKN_STS0r_RXFIFO_EMPTYf_SET BCMI_TSCD_XGXS_ILKN_STS0r_RXFIFO_EMPTYf_SET
#define READ_ILKN_STS0r BCMI_TSCD_XGXS_READ_ILKN_STS0r
#define WRITE_ILKN_STS0r BCMI_TSCD_XGXS_WRITE_ILKN_STS0r
#define MODIFY_ILKN_STS0r BCMI_TSCD_XGXS_MODIFY_ILKN_STS0r
#define READLN_ILKN_STS0r BCMI_TSCD_XGXS_READLN_ILKN_STS0r
#define WRITELN_ILKN_STS0r BCMI_TSCD_XGXS_WRITELN_ILKN_STS0r
#define WRITEALL_ILKN_STS0r BCMI_TSCD_XGXS_WRITEALL_ILKN_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_ILKN_STS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_ALGN_FSM_ST
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc350
 * DESC:     fec alignment status
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_ALGN_FSM_LIVE_STATE FEC alignment FSM current state
 *     CL91_FEC_ALGN_FSM_LATCHED_STATE FEC alignment FSM latched stateEach bit represents a particular state. The bit positions for each state is shown belowThe register clears only when read. It is not cleared even on pipeline reset.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr (0x0000c350 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_ALGN_FSM_ST.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_algn_fsm_st[1];
	uint32_t _rx_x4_fec_algn_fsm_st;
} BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CLR(r) (r).rx_x4_fec_algn_fsm_st[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_SET(r,d) (r).rx_x4_fec_algn_fsm_st[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_GET(r) (r).rx_x4_fec_algn_fsm_st[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LATCHED_STATEf_GET(r) ((((r).rx_x4_fec_algn_fsm_st[0]) >> 3) & 0x7f)
#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LATCHED_STATEf_SET(r,f) (r).rx_x4_fec_algn_fsm_st[0]=(((r).rx_x4_fec_algn_fsm_st[0] & ~((uint32_t)0x7f << 3)) | ((((uint32_t)f) & 0x7f) << 3)) | (127 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LIVE_STATEf_GET(r) (((r).rx_x4_fec_algn_fsm_st[0]) & 0x7)
#define BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LIVE_STATEf_SET(r,f) (r).rx_x4_fec_algn_fsm_st[0]=(((r).rx_x4_fec_algn_fsm_st[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access RX_X4_FEC_ALGN_FSM_ST.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_ALGN_FSM_STr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr,(_r._rx_x4_fec_algn_fsm_st))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_ALGN_FSM_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr,(_r._rx_x4_fec_algn_fsm_st)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_ALGN_FSM_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr,(_r._rx_x4_fec_algn_fsm_st))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_ALGN_FSM_STr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_algn_fsm_st))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_ALGN_FSM_STr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_algn_fsm_st))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_ALGN_FSM_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_algn_fsm_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_ALGN_FSM_STr BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr
#define RX_X4_FEC_ALGN_FSM_STr_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_t RX_X4_FEC_ALGN_FSM_STr_t;
#define RX_X4_FEC_ALGN_FSM_STr_CLR BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CLR
#define RX_X4_FEC_ALGN_FSM_STr_SET BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_SET
#define RX_X4_FEC_ALGN_FSM_STr_GET BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_GET
#define RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LATCHED_STATEf_GET BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LATCHED_STATEf_GET
#define RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LATCHED_STATEf_SET BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LATCHED_STATEf_SET
#define RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LIVE_STATEf_GET BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LIVE_STATEf_GET
#define RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LIVE_STATEf_SET BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr_CL91_FEC_ALGN_FSM_LIVE_STATEf_SET
#define READ_RX_X4_FEC_ALGN_FSM_STr BCMI_TSCD_XGXS_READ_RX_X4_FEC_ALGN_FSM_STr
#define WRITE_RX_X4_FEC_ALGN_FSM_STr BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_ALGN_FSM_STr
#define MODIFY_RX_X4_FEC_ALGN_FSM_STr BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_ALGN_FSM_STr
#define READLN_RX_X4_FEC_ALGN_FSM_STr BCMI_TSCD_XGXS_READLN_RX_X4_FEC_ALGN_FSM_STr
#define WRITELN_RX_X4_FEC_ALGN_FSM_STr BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_ALGN_FSM_STr
#define WRITEALL_RX_X4_FEC_ALGN_FSM_STr BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_ALGN_FSM_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_ALGN_FSM_STr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_RXP_STS
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc351
 * DESC:     cl91 rxp status indicators
 * RESETVAL: 0x600 (1536)
 * ACCESS:   R/W
 * FIELDS:
 *     RESTART_LOCK_LIVE Set by the FEC alignment FSM in the deskew stage to reset the synchronization process on all FEC lanes
 *     RESTART_LOCK_LL  Latched low version of restart_lock_live
 *     RESTART_LOCK_LH  Latched high version of restart_lock_live
 *     FEC_ALIGN_STATUS_LIVE Set when deskew is achieved successfully.
 *     FEC_ALIGN_STATUS_LL Latched low version of fec_align_status_live
 *     FEC_ALIGN_STATUS_LH Latched high version of fec_align_status_live
 *     HI_SER_LIVE      When FEC_bypass_indication_enable is set, this bit is set to 1 if the number of RS-FEC symbol errors in a window of 8192 (or 128) codewords exceeds the threshold (K) and is set to 0 otherwise.
 *     HI_SER_LL        Latched low version of hi_ser_live
 *     HI_SER_LH        Latched high version of hi_ser_live
 *     FEC_BYP_CORR_ABILITY Indicates the ability to perform error detection without error correction.
 *     FEC_BYP_IND_ABILITY Indicates the ability to bypass the error indication function.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr (0x0000c351 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_RXP_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_rxp_sts[1];
	uint32_t _rx_x4_cl91_rxp_sts;
} BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_CLR(r) (r).rx_x4_cl91_rxp_sts[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_SET(r,d) (r).rx_x4_cl91_rxp_sts[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_GET(r) (r).rx_x4_cl91_rxp_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_IND_ABILITYf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_IND_ABILITYf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_CORR_ABILITYf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_CORR_ABILITYf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LHf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LHf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LLf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 7) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LLf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LIVEf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 6) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LIVEf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LHf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LHf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LLf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LLf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LHf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LHf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LLf_GET(r) ((((r).rx_x4_cl91_rxp_sts[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LLf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LIVEf_GET(r) (((r).rx_x4_cl91_rxp_sts[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LIVEf_SET(r,f) (r).rx_x4_cl91_rxp_sts[0]=(((r).rx_x4_cl91_rxp_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_CL91_RXP_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_RXP_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr,(_r._rx_x4_cl91_rxp_sts))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_RXP_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr,(_r._rx_x4_cl91_rxp_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_RXP_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr,(_r._rx_x4_cl91_rxp_sts))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_RXP_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_rxp_sts))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_RXP_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_rxp_sts))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_RXP_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_rxp_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_RXP_STSr BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr
#define RX_X4_CL91_RXP_STSr_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_t RX_X4_CL91_RXP_STSr_t;
#define RX_X4_CL91_RXP_STSr_CLR BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_CLR
#define RX_X4_CL91_RXP_STSr_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_SET
#define RX_X4_CL91_RXP_STSr_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_GET
#define RX_X4_CL91_RXP_STSr_FEC_BYP_IND_ABILITYf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_IND_ABILITYf_GET
#define RX_X4_CL91_RXP_STSr_FEC_BYP_IND_ABILITYf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_IND_ABILITYf_SET
#define RX_X4_CL91_RXP_STSr_FEC_BYP_CORR_ABILITYf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_CORR_ABILITYf_GET
#define RX_X4_CL91_RXP_STSr_FEC_BYP_CORR_ABILITYf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_BYP_CORR_ABILITYf_SET
#define RX_X4_CL91_RXP_STSr_HI_SER_LHf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LHf_GET
#define RX_X4_CL91_RXP_STSr_HI_SER_LHf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LHf_SET
#define RX_X4_CL91_RXP_STSr_HI_SER_LLf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LLf_GET
#define RX_X4_CL91_RXP_STSr_HI_SER_LLf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LLf_SET
#define RX_X4_CL91_RXP_STSr_HI_SER_LIVEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LIVEf_GET
#define RX_X4_CL91_RXP_STSr_HI_SER_LIVEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_HI_SER_LIVEf_SET
#define RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LHf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LHf_GET
#define RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LHf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LHf_SET
#define RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LLf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LLf_GET
#define RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LLf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LLf_SET
#define RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_GET
#define RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_FEC_ALIGN_STATUS_LIVEf_SET
#define RX_X4_CL91_RXP_STSr_RESTART_LOCK_LHf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LHf_GET
#define RX_X4_CL91_RXP_STSr_RESTART_LOCK_LHf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LHf_SET
#define RX_X4_CL91_RXP_STSr_RESTART_LOCK_LLf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LLf_GET
#define RX_X4_CL91_RXP_STSr_RESTART_LOCK_LLf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LLf_SET
#define RX_X4_CL91_RXP_STSr_RESTART_LOCK_LIVEf_GET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LIVEf_GET
#define RX_X4_CL91_RXP_STSr_RESTART_LOCK_LIVEf_SET BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr_RESTART_LOCK_LIVEf_SET
#define READ_RX_X4_CL91_RXP_STSr BCMI_TSCD_XGXS_READ_RX_X4_CL91_RXP_STSr
#define WRITE_RX_X4_CL91_RXP_STSr BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_RXP_STSr
#define MODIFY_RX_X4_CL91_RXP_STSr BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_RXP_STSr
#define READLN_RX_X4_CL91_RXP_STSr BCMI_TSCD_XGXS_READLN_RX_X4_CL91_RXP_STSr
#define WRITELN_RX_X4_CL91_RXP_STSr BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_RXP_STSr
#define WRITEALL_RX_X4_CL91_RXP_STSr BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_RXP_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_RXP_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORR_CTR0
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc352
 * DESC:     Lower 16 bits of FEC corrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_CORR_CW_CNTR_LOWER Lower 16 bits of the CL91 FEC corrected code word counter.Counts once for each corrected FEC codeword processed when fec_align_status is true.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r (0x0000c352 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORR_CTR0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corr_ctr0[1];
	uint32_t _rx_x4_fec_corr_ctr0;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_CLR(r) (r).rx_x4_fec_corr_ctr0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_SET(r,d) (r).rx_x4_fec_corr_ctr0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_GET(r) (r).rx_x4_fec_corr_ctr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_CL91_FEC_CORR_CW_CNTR_LOWERf_GET(r) (((r).rx_x4_fec_corr_ctr0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_CL91_FEC_CORR_CW_CNTR_LOWERf_SET(r,f) (r).rx_x4_fec_corr_ctr0[0]=(((r).rx_x4_fec_corr_ctr0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORR_CTR0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r,(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r,(_r._rx_x4_fec_corr_ctr0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r,(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORR_CTR0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORR_CTR0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corr_ctr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORR_CTR0r BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r
#define RX_X4_FEC_CORR_CTR0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_t RX_X4_FEC_CORR_CTR0r_t;
#define RX_X4_FEC_CORR_CTR0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_CLR
#define RX_X4_FEC_CORR_CTR0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_SET
#define RX_X4_FEC_CORR_CTR0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_GET
#define RX_X4_FEC_CORR_CTR0r_CL91_FEC_CORR_CW_CNTR_LOWERf_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_CL91_FEC_CORR_CW_CNTR_LOWERf_GET
#define RX_X4_FEC_CORR_CTR0r_CL91_FEC_CORR_CW_CNTR_LOWERf_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r_CL91_FEC_CORR_CW_CNTR_LOWERf_SET
#define READ_RX_X4_FEC_CORR_CTR0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORR_CTR0r
#define WRITE_RX_X4_FEC_CORR_CTR0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORR_CTR0r
#define MODIFY_RX_X4_FEC_CORR_CTR0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORR_CTR0r
#define READLN_RX_X4_FEC_CORR_CTR0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORR_CTR0r
#define WRITELN_RX_X4_FEC_CORR_CTR0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORR_CTR0r
#define WRITEALL_RX_X4_FEC_CORR_CTR0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_CORR_CTR1
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc353
 * DESC:     Upper 16 bits of FEC corrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_CORR_CW_CNTR_UPPER Upper 16 bits of the CL91 FEC corrected code word counter.Read the lower 16 bits firstSaturates on overflow
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r (0x0000c353 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_CORR_CTR1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_corr_ctr1[1];
	uint32_t _rx_x4_fec_corr_ctr1;
} BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_CLR(r) (r).rx_x4_fec_corr_ctr1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_SET(r,d) (r).rx_x4_fec_corr_ctr1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_GET(r) (r).rx_x4_fec_corr_ctr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_CL91_FEC_CORR_CW_CNTR_UPPERf_GET(r) (((r).rx_x4_fec_corr_ctr1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_CL91_FEC_CORR_CW_CNTR_UPPERf_SET(r,f) (r).rx_x4_fec_corr_ctr1[0]=(((r).rx_x4_fec_corr_ctr1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_CORR_CTR1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r,(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r,(_r._rx_x4_fec_corr_ctr1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r,(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORR_CTR1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORR_CTR1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_corr_ctr1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_corr_ctr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_CORR_CTR1r BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r
#define RX_X4_FEC_CORR_CTR1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_t RX_X4_FEC_CORR_CTR1r_t;
#define RX_X4_FEC_CORR_CTR1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_CLR
#define RX_X4_FEC_CORR_CTR1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_SET
#define RX_X4_FEC_CORR_CTR1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_GET
#define RX_X4_FEC_CORR_CTR1r_CL91_FEC_CORR_CW_CNTR_UPPERf_GET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_CL91_FEC_CORR_CW_CNTR_UPPERf_GET
#define RX_X4_FEC_CORR_CTR1r_CL91_FEC_CORR_CW_CNTR_UPPERf_SET BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r_CL91_FEC_CORR_CW_CNTR_UPPERf_SET
#define READ_RX_X4_FEC_CORR_CTR1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_CORR_CTR1r
#define WRITE_RX_X4_FEC_CORR_CTR1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_CORR_CTR1r
#define MODIFY_RX_X4_FEC_CORR_CTR1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_CORR_CTR1r
#define READLN_RX_X4_FEC_CORR_CTR1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_CORR_CTR1r
#define WRITELN_RX_X4_FEC_CORR_CTR1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_CORR_CTR1r
#define WRITEALL_RX_X4_FEC_CORR_CTR1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_CORR_CTR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_CORR_CTR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORR_CTR0
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc354
 * DESC:     Lower 16 bits of FEC uncorrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_UNCORR_CW_CNTR_LOWER Lower 16 bits of the CL91 FEC uncorrected code word counter.Counts once for each uncorrected FEC codeword processed when fec_align_status is true.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r (0x0000c354 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORR_CTR0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorr_ctr0[1];
	uint32_t _rx_x4_fec_uncorr_ctr0;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_CLR(r) (r).rx_x4_fec_uncorr_ctr0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_SET(r,d) (r).rx_x4_fec_uncorr_ctr0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_GET(r) (r).rx_x4_fec_uncorr_ctr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_CL91_FEC_UNCORR_CW_CNTR_LOWERf_GET(r) (((r).rx_x4_fec_uncorr_ctr0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_CL91_FEC_UNCORR_CW_CNTR_LOWERf_SET(r,f) (r).rx_x4_fec_uncorr_ctr0[0]=(((r).rx_x4_fec_uncorr_ctr0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORR_CTR0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r,(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r,(_r._rx_x4_fec_uncorr_ctr0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r,(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORR_CTR0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorr_ctr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORR_CTR0r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r
#define RX_X4_FEC_UNCORR_CTR0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_t RX_X4_FEC_UNCORR_CTR0r_t;
#define RX_X4_FEC_UNCORR_CTR0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_CLR
#define RX_X4_FEC_UNCORR_CTR0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_SET
#define RX_X4_FEC_UNCORR_CTR0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_GET
#define RX_X4_FEC_UNCORR_CTR0r_CL91_FEC_UNCORR_CW_CNTR_LOWERf_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_CL91_FEC_UNCORR_CW_CNTR_LOWERf_GET
#define RX_X4_FEC_UNCORR_CTR0r_CL91_FEC_UNCORR_CW_CNTR_LOWERf_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r_CL91_FEC_UNCORR_CW_CNTR_LOWERf_SET
#define READ_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORR_CTR0r
#define WRITE_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR0r
#define MODIFY_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR0r
#define READLN_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORR_CTR0r
#define WRITELN_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR0r
#define WRITEALL_RX_X4_FEC_UNCORR_CTR0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_UNCORR_CTR1
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc355
 * DESC:     Upper 16 bits of FEC uncorrected codeword counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_UNCORR_CW_CNTR_UPPER Upper 16 bits of the CL91 FEC uncorrected code word counter.Read the lower 16 bits firstSaturates on overflow
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r (0x0000c355 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_UNCORR_CTR1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_uncorr_ctr1[1];
	uint32_t _rx_x4_fec_uncorr_ctr1;
} BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_CLR(r) (r).rx_x4_fec_uncorr_ctr1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_SET(r,d) (r).rx_x4_fec_uncorr_ctr1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_GET(r) (r).rx_x4_fec_uncorr_ctr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_CL91_FEC_UNCORR_CW_CNTR_UPPERf_GET(r) (((r).rx_x4_fec_uncorr_ctr1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_CL91_FEC_UNCORR_CW_CNTR_UPPERf_SET(r,f) (r).rx_x4_fec_uncorr_ctr1[0]=(((r).rx_x4_fec_uncorr_ctr1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_UNCORR_CTR1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r,(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r,(_r._rx_x4_fec_uncorr_ctr1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r,(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORR_CTR1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_uncorr_ctr1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_uncorr_ctr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_UNCORR_CTR1r BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r
#define RX_X4_FEC_UNCORR_CTR1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_t RX_X4_FEC_UNCORR_CTR1r_t;
#define RX_X4_FEC_UNCORR_CTR1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_CLR
#define RX_X4_FEC_UNCORR_CTR1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_SET
#define RX_X4_FEC_UNCORR_CTR1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_GET
#define RX_X4_FEC_UNCORR_CTR1r_CL91_FEC_UNCORR_CW_CNTR_UPPERf_GET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_CL91_FEC_UNCORR_CW_CNTR_UPPERf_GET
#define RX_X4_FEC_UNCORR_CTR1r_CL91_FEC_UNCORR_CW_CNTR_UPPERf_SET BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r_CL91_FEC_UNCORR_CW_CNTR_UPPERf_SET
#define READ_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_UNCORR_CTR1r
#define WRITE_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_UNCORR_CTR1r
#define MODIFY_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_UNCORR_CTR1r
#define READLN_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_UNCORR_CTR1r
#define WRITELN_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_UNCORR_CTR1r
#define WRITEALL_RX_X4_FEC_UNCORR_CTR1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_UNCORR_CTR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_UNCORR_CTR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BIT_ERR_CTR0
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc356
 * DESC:     Lower 16 bits of FEC bit error counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_CORR_BIT_CNTR_LOWER Counts corrected bits. Accurate only when no uncorrectable errors are present and doesnt count parity bits errors.  Lower 16 bits of the counter.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r (0x0000c356 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BIT_ERR_CTR0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_bit_err_ctr0[1];
	uint32_t _rx_x4_fec_bit_err_ctr0;
} BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CLR(r) (r).rx_x4_fec_bit_err_ctr0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SET(r,d) (r).rx_x4_fec_bit_err_ctr0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_GET(r) (r).rx_x4_fec_bit_err_ctr0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CL91_FEC_CORR_BIT_CNTR_LOWERf_GET(r) (((r).rx_x4_fec_bit_err_ctr0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CL91_FEC_CORR_BIT_CNTR_LOWERf_SET(r,f) (r).rx_x4_fec_bit_err_ctr0[0]=(((r).rx_x4_fec_bit_err_ctr0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BIT_ERR_CTR0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r,(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r,(_r._rx_x4_fec_bit_err_ctr0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r,(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_bit_err_ctr0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r
#define RX_X4_FEC_BIT_ERR_CTR0r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_t RX_X4_FEC_BIT_ERR_CTR0r_t;
#define RX_X4_FEC_BIT_ERR_CTR0r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CLR
#define RX_X4_FEC_BIT_ERR_CTR0r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_SET
#define RX_X4_FEC_BIT_ERR_CTR0r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_GET
#define RX_X4_FEC_BIT_ERR_CTR0r_CL91_FEC_CORR_BIT_CNTR_LOWERf_GET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CL91_FEC_CORR_BIT_CNTR_LOWERf_GET
#define RX_X4_FEC_BIT_ERR_CTR0r_CL91_FEC_CORR_BIT_CNTR_LOWERf_SET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r_CL91_FEC_CORR_BIT_CNTR_LOWERf_SET
#define READ_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR0r
#define WRITE_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR0r
#define MODIFY_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR0r
#define READLN_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR0r
#define WRITELN_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR0r
#define WRITEALL_RX_X4_FEC_BIT_ERR_CTR0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_FEC_BIT_ERR_CTR1
 * BLOCKS:   RX_X4_CL91_STATUS0
 * REGADDR:  0xc357
 * DESC:     Upper 16 bits of FEC bit error counter
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_FEC_CORR_BIT_CNTR_UPPER Upper 16 bits of the CL91 FEC error bit counter.Read the lower 16 bits firstSaturates on overflow
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r (0x0000c357 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_FEC_BIT_ERR_CTR1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_s {
	uint32_t v[1];
	uint32_t rx_x4_fec_bit_err_ctr1[1];
	uint32_t _rx_x4_fec_bit_err_ctr1;
} BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_t;

#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CLR(r) (r).rx_x4_fec_bit_err_ctr1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SET(r,d) (r).rx_x4_fec_bit_err_ctr1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_GET(r) (r).rx_x4_fec_bit_err_ctr1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CL91_FEC_CORR_BIT_CNTR_UPPERf_GET(r) (((r).rx_x4_fec_bit_err_ctr1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CL91_FEC_CORR_BIT_CNTR_UPPERf_SET(r,f) (r).rx_x4_fec_bit_err_ctr1[0]=(((r).rx_x4_fec_bit_err_ctr1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_FEC_BIT_ERR_CTR1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r,(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r,(_r._rx_x4_fec_bit_err_ctr1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r,(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_fec_bit_err_ctr1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_fec_bit_err_ctr1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r
#define RX_X4_FEC_BIT_ERR_CTR1r_SIZE BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_t RX_X4_FEC_BIT_ERR_CTR1r_t;
#define RX_X4_FEC_BIT_ERR_CTR1r_CLR BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CLR
#define RX_X4_FEC_BIT_ERR_CTR1r_SET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_SET
#define RX_X4_FEC_BIT_ERR_CTR1r_GET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_GET
#define RX_X4_FEC_BIT_ERR_CTR1r_CL91_FEC_CORR_BIT_CNTR_UPPERf_GET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CL91_FEC_CORR_BIT_CNTR_UPPERf_GET
#define RX_X4_FEC_BIT_ERR_CTR1r_CL91_FEC_CORR_BIT_CNTR_UPPERf_SET BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r_CL91_FEC_CORR_BIT_CNTR_UPPERf_SET
#define READ_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCD_XGXS_READ_RX_X4_FEC_BIT_ERR_CTR1r
#define WRITE_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCD_XGXS_WRITE_RX_X4_FEC_BIT_ERR_CTR1r
#define MODIFY_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCD_XGXS_MODIFY_RX_X4_FEC_BIT_ERR_CTR1r
#define READLN_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCD_XGXS_READLN_RX_X4_FEC_BIT_ERR_CTR1r
#define WRITELN_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCD_XGXS_WRITELN_RX_X4_FEC_BIT_ERR_CTR1r
#define WRITEALL_RX_X4_FEC_BIT_ERR_CTR1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_FEC_BIT_ERR_CTR1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_FEC_BIT_ERR_CTR1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc360
 * DESC:     CL91 FEC symbol error counter lower 16 bits of FEC lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_0 Lower 16 bits of the FEC symbol error counter for FEC lane 0.Counts once for each 10-bit symbol corrected.Per FEC lane counter.If we have a 100G port, the 4 symbol error counters for port 0 represent the counter values per FEC lane.If we have a 25G port, add the 4 symbol error counter values of a port for the symbol error counter value for the FEC lane 0 for that port.If we have a 50G port, add the counter value of 0 and 2 for FEC lane 0 and counter value of 1 and 3 for FEC lane 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r (0x0000c360 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_low0[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_low0;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_low0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_low0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_low0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_low0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_low0[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_low0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r,(_r._rx_x4_cl91_fec_sym_err_ctr_low0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r,(_r._rx_x4_cl91_fec_sym_err_ctr_low0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r,(_r._rx_x4_cl91_fec_sym_err_ctr_low0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_low0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_t RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r_FEC_SYMBOL_ERROR_COUNTER_LOWER_0f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_UP0
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc361
 * DESC:     CL91 FEC symbol error counter upper 16 bits of FEC lane 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_0 Upper 16 bits of the FEC symbol error counter for FEC lane 0.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r (0x0000c361 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_UP0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_up0[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_up0;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_up0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_up0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_up0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_up0[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_up0[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_up0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_UP0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r,(_r._rx_x4_cl91_fec_sym_err_ctr_up0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r,(_r._rx_x4_cl91_fec_sym_err_ctr_up0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r,(_r._rx_x4_cl91_fec_sym_err_ctr_up0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_up0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_t RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r_FEC_SYMBOL_ERROR_COUNTER_UPPER_0f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc362
 * DESC:     CL91 FEC symbol error counter lower 16 bits of FEC lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_1 Lower 16 bits of the FEC symbol error counter for FEC lane 1.Counts once for each 10-bit symbol corrected.Per FEC lane counter.If we have a 100G port, the 4 symbol error counters for port 0 represent the counter values per FEC lane.If we have a 25G port, add the 4 symbol error counter values of a port for the symbol error counter value for the FEC lane 0 for that port.If we have a 50G port, add the counter value of 0 and 2 for FEC lane 0 and counter value of 1 and 3 for FEC lane 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r (0x0000c362 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_low1[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_low1;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_low1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_low1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_low1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_low1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_low1[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_low1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r,(_r._rx_x4_cl91_fec_sym_err_ctr_low1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r,(_r._rx_x4_cl91_fec_sym_err_ctr_low1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r,(_r._rx_x4_cl91_fec_sym_err_ctr_low1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_low1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_t RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r_FEC_SYMBOL_ERROR_COUNTER_LOWER_1f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_UP1
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc363
 * DESC:     CL91 FEC symbol error counter upper 16 bits of FEC lane 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_1 Upper 16 bits of the FEC symbol error counter for FEC lane 1.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r (0x0000c363 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_UP1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_up1[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_up1;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_up1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_up1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_up1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_up1[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_up1[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_up1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_UP1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r,(_r._rx_x4_cl91_fec_sym_err_ctr_up1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r,(_r._rx_x4_cl91_fec_sym_err_ctr_up1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r,(_r._rx_x4_cl91_fec_sym_err_ctr_up1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_up1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_t RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r_FEC_SYMBOL_ERROR_COUNTER_UPPER_1f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc364
 * DESC:     CL91 FEC symbol error counter lower 16 bits of FEC lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_2 Lower 16 bits of the FEC symbol error counter for FEC lane 2.Counts once for each 10-bit symbol corrected.Per FEC lane counter.If we have a 100G port, the 4 symbol error counters for port 0 represent the counter values per FEC lane.If we have a 25G port, add the 4 symbol error counter values of a port for the symbol error counter value for the FEC lane 0 for that port.If we have a 50G port, add the counter value of 0 and 2 for FEC lane 0 and counter value of 1 and 3 for FEC lane 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r (0x0000c364 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_low2[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_low2;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_low2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_low2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_low2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_low2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_low2[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_low2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r,(_r._rx_x4_cl91_fec_sym_err_ctr_low2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r,(_r._rx_x4_cl91_fec_sym_err_ctr_low2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r,(_r._rx_x4_cl91_fec_sym_err_ctr_low2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_low2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_t RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r_FEC_SYMBOL_ERROR_COUNTER_LOWER_2f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_UP2
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc365
 * DESC:     CL91 FEC symbol error counter upper 16 bits of FEC lane 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_2 Upper 16 bits of the FEC symbol error counter for FEC lane 2.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r (0x0000c365 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_UP2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_up2[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_up2;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_up2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_up2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_up2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_up2[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_up2[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_up2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_UP2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r,(_r._rx_x4_cl91_fec_sym_err_ctr_up2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r,(_r._rx_x4_cl91_fec_sym_err_ctr_up2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r,(_r._rx_x4_cl91_fec_sym_err_ctr_up2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_up2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_t RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r_FEC_SYMBOL_ERROR_COUNTER_UPPER_2f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc366
 * DESC:     CL91 FEC symbol error counter lower 16 bits of FEC lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_LOWER_3 Lower 16 bits of the FEC symbol error counter for FEC lane 3.Counts once for each 10-bit symbol corrected.Per FEC lane counter.If we have a 100G port, the 4 symbol error counters for port 0 represent the counter values per FEC lane.If we have a 25G port, add the 4 symbol error counter values of a port for the symbol error counter value for the FEC lane 0 for that port.If we have a 50G port, add the counter value of 0 and 2 for FEC lane 0 and counter value of 1 and 3 for FEC lane 1.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r (0x0000c366 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_low3[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_low3;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_low3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_low3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_low3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_low3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_low3[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_low3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r,(_r._rx_x4_cl91_fec_sym_err_ctr_low3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r,(_r._rx_x4_cl91_fec_sym_err_ctr_low3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r,(_r._rx_x4_cl91_fec_sym_err_ctr_low3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_low3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_low3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_t RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r_FEC_SYMBOL_ERROR_COUNTER_LOWER_3f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_LOW3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_CL91_FEC_SYM_ERR_CTR_UP3
 * BLOCKS:   RX_X4_CL91_STATUS1
 * REGADDR:  0xc367
 * DESC:     CL91 FEC symbol error counter upper 16 bits of FEC lane 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FEC_SYMBOL_ERROR_COUNTER_UPPER_3 Upper 16 bits of the FEC symbol error counter for FEC lane 3.Counts once for each 10-bit symbol corrected.Per FEC lane counter.Saturates on overflow.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r (0x0000c367 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_CL91_FEC_SYM_ERR_CTR_UP3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_s {
	uint32_t v[1];
	uint32_t rx_x4_cl91_fec_sym_err_ctr_up3[1];
	uint32_t _rx_x4_cl91_fec_sym_err_ctr_up3;
} BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_t;

#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_CLR(r) (r).rx_x4_cl91_fec_sym_err_ctr_up3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_SET(r,d) (r).rx_x4_cl91_fec_sym_err_ctr_up3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_GET(r) (r).rx_x4_cl91_fec_sym_err_ctr_up3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_GET(r) (((r).rx_x4_cl91_fec_sym_err_ctr_up3[0]) & 0xffff)
#define BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_SET(r,f) (r).rx_x4_cl91_fec_sym_err_ctr_up3[0]=(((r).rx_x4_cl91_fec_sym_err_ctr_up3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access RX_X4_CL91_FEC_SYM_ERR_CTR_UP3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r,(_r._rx_x4_cl91_fec_sym_err_ctr_up3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r,(_r._rx_x4_cl91_fec_sym_err_ctr_up3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r,(_r._rx_x4_cl91_fec_sym_err_ctr_up3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_cl91_fec_sym_err_ctr_up3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_cl91_fec_sym_err_ctr_up3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_SIZE BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_t RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_t;
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_CLR BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_CLR
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_SET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_GET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_GET
#define RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_SET BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r_FEC_SYMBOL_ERROR_COUNTER_UPPER_3f_SET
#define READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r BCMI_TSCD_XGXS_READ_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r
#define WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r BCMI_TSCD_XGXS_WRITE_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r
#define MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r BCMI_TSCD_XGXS_MODIFY_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r
#define READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r BCMI_TSCD_XGXS_READLN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r
#define WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r BCMI_TSCD_XGXS_WRITELN_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r
#define WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_CL91_FEC_SYM_ERR_CTR_UP3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_STS_CL91_BUFFER_BLK0
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc380
 * DESC:     ECC status register for CL91 buffer block 0 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_0 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_0 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_0 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r (0x0000c380 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_STS_CL91_BUFFER_BLK0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_sts_cl91_buffer_blk0[1];
	uint32_t _rx_x4_ecc_sts_cl91_buffer_blk0;
} BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_CLR(r) (r).rx_x4_ecc_sts_cl91_buffer_blk0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_SET(r,d) (r).rx_x4_ecc_sts_cl91_buffer_blk0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_GET(r) (r).rx_x4_ecc_sts_cl91_buffer_blk0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_GET(r) ((((r).rx_x4_ecc_sts_cl91_buffer_blk0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk0[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_GET(r) ((((r).rx_x4_ecc_sts_cl91_buffer_blk0[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk0[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_0f_GET(r) (((r).rx_x4_ecc_sts_cl91_buffer_blk0[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_0f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk0[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_ECC_STS_CL91_BUFFER_BLK0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_CL91_BUFFER_BLK0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r,(_r._rx_x4_ecc_sts_cl91_buffer_blk0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r,(_r._rx_x4_ecc_sts_cl91_buffer_blk0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r,(_r._rx_x4_ecc_sts_cl91_buffer_blk0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_cl91_buffer_blk0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_cl91_buffer_blk0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_sts_cl91_buffer_blk0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_t RX_X4_ECC_STS_CL91_BUFFER_BLK0r_t;
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_CLR BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_CLR
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_0f_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_0f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_0f_SET
#define READ_RX_X4_ECC_STS_CL91_BUFFER_BLK0r BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_CL91_BUFFER_BLK0r
#define WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK0r BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK0r
#define MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK0r BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK0r
#define READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK0r BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK0r
#define WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK0r BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK0r
#define WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_STS_CL91_BUFFER_BLK1
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc381
 * DESC:     ECC status register for CL91 buffer block 1 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_1 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_1 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_1 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r (0x0000c381 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_STS_CL91_BUFFER_BLK1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_sts_cl91_buffer_blk1[1];
	uint32_t _rx_x4_ecc_sts_cl91_buffer_blk1;
} BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_CLR(r) (r).rx_x4_ecc_sts_cl91_buffer_blk1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_SET(r,d) (r).rx_x4_ecc_sts_cl91_buffer_blk1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_GET(r) (r).rx_x4_ecc_sts_cl91_buffer_blk1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_GET(r) ((((r).rx_x4_ecc_sts_cl91_buffer_blk1[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk1[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_GET(r) ((((r).rx_x4_ecc_sts_cl91_buffer_blk1[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk1[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_1f_GET(r) (((r).rx_x4_ecc_sts_cl91_buffer_blk1[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_1f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk1[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_ECC_STS_CL91_BUFFER_BLK1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_CL91_BUFFER_BLK1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r,(_r._rx_x4_ecc_sts_cl91_buffer_blk1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r,(_r._rx_x4_ecc_sts_cl91_buffer_blk1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r,(_r._rx_x4_ecc_sts_cl91_buffer_blk1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_cl91_buffer_blk1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_cl91_buffer_blk1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_sts_cl91_buffer_blk1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_t RX_X4_ECC_STS_CL91_BUFFER_BLK1r_t;
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_CLR BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_CLR
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_1f_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_1f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_1f_SET
#define READ_RX_X4_ECC_STS_CL91_BUFFER_BLK1r BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_CL91_BUFFER_BLK1r
#define WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK1r BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK1r
#define MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK1r BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK1r
#define READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK1r BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK1r
#define WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK1r BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK1r
#define WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_STS_CL91_BUFFER_BLK2
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc382
 * DESC:     ECC status register for CL91 buffer block 2 memory
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_2 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_2 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_2 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r (0x0000c382 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_STS_CL91_BUFFER_BLK2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_sts_cl91_buffer_blk2[1];
	uint32_t _rx_x4_ecc_sts_cl91_buffer_blk2;
} BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_CLR(r) (r).rx_x4_ecc_sts_cl91_buffer_blk2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_SET(r,d) (r).rx_x4_ecc_sts_cl91_buffer_blk2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_GET(r) (r).rx_x4_ecc_sts_cl91_buffer_blk2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_GET(r) ((((r).rx_x4_ecc_sts_cl91_buffer_blk2[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk2[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_GET(r) ((((r).rx_x4_ecc_sts_cl91_buffer_blk2[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk2[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_2f_GET(r) (((r).rx_x4_ecc_sts_cl91_buffer_blk2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_2f_SET(r,f) (r).rx_x4_ecc_sts_cl91_buffer_blk2[0]=(((r).rx_x4_ecc_sts_cl91_buffer_blk2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_ECC_STS_CL91_BUFFER_BLK2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_CL91_BUFFER_BLK2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r,(_r._rx_x4_ecc_sts_cl91_buffer_blk2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r,(_r._rx_x4_ecc_sts_cl91_buffer_blk2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r,(_r._rx_x4_ecc_sts_cl91_buffer_blk2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_cl91_buffer_blk2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_cl91_buffer_blk2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_sts_cl91_buffer_blk2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_t RX_X4_ECC_STS_CL91_BUFFER_BLK2r_t;
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_CLR BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_CLR
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_TWO_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ONE_BIT_ERR_EVENT_CL91_BUFFER_BLK_2f_SET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_2f_GET
#define RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r_ERR_EVENT_ADDRESS_CL91_BUFFER_BLK_2f_SET
#define READ_RX_X4_ECC_STS_CL91_BUFFER_BLK2r BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_CL91_BUFFER_BLK2r
#define WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK2r BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_CL91_BUFFER_BLK2r
#define MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK2r BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_CL91_BUFFER_BLK2r
#define READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK2r BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_CL91_BUFFER_BLK2r
#define WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK2r BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_CL91_BUFFER_BLK2r
#define WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_CL91_BUFFER_BLK2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_STS_CL91_BUFFER_BLK2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_STS_DESKEW_MEM0
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc383
 * DESC:     ECC status register for MEM0 per physical lane
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_DESKEW_0 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_DESKEW_0 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_DESKEW_0 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r (0x0000c383 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_STS_DESKEW_MEM0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_sts_deskew_mem0[1];
	uint32_t _rx_x4_ecc_sts_deskew_mem0;
} BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_CLR(r) (r).rx_x4_ecc_sts_deskew_mem0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_SET(r,d) (r).rx_x4_ecc_sts_deskew_mem0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_GET(r) (r).rx_x4_ecc_sts_deskew_mem0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_TWO_BIT_ERR_EVENT_DESKEW_0f_GET(r) ((((r).rx_x4_ecc_sts_deskew_mem0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_TWO_BIT_ERR_EVENT_DESKEW_0f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem0[0]=(((r).rx_x4_ecc_sts_deskew_mem0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ONE_BIT_ERR_EVENT_DESKEW_0f_GET(r) ((((r).rx_x4_ecc_sts_deskew_mem0[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ONE_BIT_ERR_EVENT_DESKEW_0f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem0[0]=(((r).rx_x4_ecc_sts_deskew_mem0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ERR_EVENT_ADDRESS_DESKEW_0f_GET(r) (((r).rx_x4_ecc_sts_deskew_mem0[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ERR_EVENT_ADDRESS_DESKEW_0f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem0[0]=(((r).rx_x4_ecc_sts_deskew_mem0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_ECC_STS_DESKEW_MEM0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_DESKEW_MEM0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r,(_r._rx_x4_ecc_sts_deskew_mem0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_DESKEW_MEM0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r,(_r._rx_x4_ecc_sts_deskew_mem0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_DESKEW_MEM0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r,(_r._rx_x4_ecc_sts_deskew_mem0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_DESKEW_MEM0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_deskew_mem0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_DESKEW_MEM0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_deskew_mem0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_DESKEW_MEM0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_sts_deskew_mem0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_STS_DESKEW_MEM0r BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r
#define RX_X4_ECC_STS_DESKEW_MEM0r_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_t RX_X4_ECC_STS_DESKEW_MEM0r_t;
#define RX_X4_ECC_STS_DESKEW_MEM0r_CLR BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_CLR
#define RX_X4_ECC_STS_DESKEW_MEM0r_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_SET
#define RX_X4_ECC_STS_DESKEW_MEM0r_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_GET
#define RX_X4_ECC_STS_DESKEW_MEM0r_TWO_BIT_ERR_EVENT_DESKEW_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_TWO_BIT_ERR_EVENT_DESKEW_0f_GET
#define RX_X4_ECC_STS_DESKEW_MEM0r_TWO_BIT_ERR_EVENT_DESKEW_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_TWO_BIT_ERR_EVENT_DESKEW_0f_SET
#define RX_X4_ECC_STS_DESKEW_MEM0r_ONE_BIT_ERR_EVENT_DESKEW_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ONE_BIT_ERR_EVENT_DESKEW_0f_GET
#define RX_X4_ECC_STS_DESKEW_MEM0r_ONE_BIT_ERR_EVENT_DESKEW_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ONE_BIT_ERR_EVENT_DESKEW_0f_SET
#define RX_X4_ECC_STS_DESKEW_MEM0r_ERR_EVENT_ADDRESS_DESKEW_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ERR_EVENT_ADDRESS_DESKEW_0f_GET
#define RX_X4_ECC_STS_DESKEW_MEM0r_ERR_EVENT_ADDRESS_DESKEW_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r_ERR_EVENT_ADDRESS_DESKEW_0f_SET
#define READ_RX_X4_ECC_STS_DESKEW_MEM0r BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_DESKEW_MEM0r
#define WRITE_RX_X4_ECC_STS_DESKEW_MEM0r BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_DESKEW_MEM0r
#define MODIFY_RX_X4_ECC_STS_DESKEW_MEM0r BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_DESKEW_MEM0r
#define READLN_RX_X4_ECC_STS_DESKEW_MEM0r BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_DESKEW_MEM0r
#define WRITELN_RX_X4_ECC_STS_DESKEW_MEM0r BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_DESKEW_MEM0r
#define WRITEALL_RX_X4_ECC_STS_DESKEW_MEM0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_DESKEW_MEM0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_STS_DESKEW_MEM1
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc384
 * DESC:     ECC status register for MEM1 per physical lane
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_DESKEW_1 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_DESKEW_1 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_DESKEW_1 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r (0x0000c384 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_STS_DESKEW_MEM1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_sts_deskew_mem1[1];
	uint32_t _rx_x4_ecc_sts_deskew_mem1;
} BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_CLR(r) (r).rx_x4_ecc_sts_deskew_mem1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_SET(r,d) (r).rx_x4_ecc_sts_deskew_mem1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_GET(r) (r).rx_x4_ecc_sts_deskew_mem1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_TWO_BIT_ERR_EVENT_DESKEW_1f_GET(r) ((((r).rx_x4_ecc_sts_deskew_mem1[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_TWO_BIT_ERR_EVENT_DESKEW_1f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem1[0]=(((r).rx_x4_ecc_sts_deskew_mem1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ONE_BIT_ERR_EVENT_DESKEW_1f_GET(r) ((((r).rx_x4_ecc_sts_deskew_mem1[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ONE_BIT_ERR_EVENT_DESKEW_1f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem1[0]=(((r).rx_x4_ecc_sts_deskew_mem1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ERR_EVENT_ADDRESS_DESKEW_1f_GET(r) (((r).rx_x4_ecc_sts_deskew_mem1[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ERR_EVENT_ADDRESS_DESKEW_1f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem1[0]=(((r).rx_x4_ecc_sts_deskew_mem1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_ECC_STS_DESKEW_MEM1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_DESKEW_MEM1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r,(_r._rx_x4_ecc_sts_deskew_mem1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_DESKEW_MEM1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r,(_r._rx_x4_ecc_sts_deskew_mem1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_DESKEW_MEM1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r,(_r._rx_x4_ecc_sts_deskew_mem1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_DESKEW_MEM1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_deskew_mem1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_DESKEW_MEM1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_deskew_mem1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_DESKEW_MEM1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_sts_deskew_mem1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_STS_DESKEW_MEM1r BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r
#define RX_X4_ECC_STS_DESKEW_MEM1r_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_t RX_X4_ECC_STS_DESKEW_MEM1r_t;
#define RX_X4_ECC_STS_DESKEW_MEM1r_CLR BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_CLR
#define RX_X4_ECC_STS_DESKEW_MEM1r_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_SET
#define RX_X4_ECC_STS_DESKEW_MEM1r_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_GET
#define RX_X4_ECC_STS_DESKEW_MEM1r_TWO_BIT_ERR_EVENT_DESKEW_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_TWO_BIT_ERR_EVENT_DESKEW_1f_GET
#define RX_X4_ECC_STS_DESKEW_MEM1r_TWO_BIT_ERR_EVENT_DESKEW_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_TWO_BIT_ERR_EVENT_DESKEW_1f_SET
#define RX_X4_ECC_STS_DESKEW_MEM1r_ONE_BIT_ERR_EVENT_DESKEW_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ONE_BIT_ERR_EVENT_DESKEW_1f_GET
#define RX_X4_ECC_STS_DESKEW_MEM1r_ONE_BIT_ERR_EVENT_DESKEW_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ONE_BIT_ERR_EVENT_DESKEW_1f_SET
#define RX_X4_ECC_STS_DESKEW_MEM1r_ERR_EVENT_ADDRESS_DESKEW_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ERR_EVENT_ADDRESS_DESKEW_1f_GET
#define RX_X4_ECC_STS_DESKEW_MEM1r_ERR_EVENT_ADDRESS_DESKEW_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r_ERR_EVENT_ADDRESS_DESKEW_1f_SET
#define READ_RX_X4_ECC_STS_DESKEW_MEM1r BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_DESKEW_MEM1r
#define WRITE_RX_X4_ECC_STS_DESKEW_MEM1r BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_DESKEW_MEM1r
#define MODIFY_RX_X4_ECC_STS_DESKEW_MEM1r BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_DESKEW_MEM1r
#define READLN_RX_X4_ECC_STS_DESKEW_MEM1r BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_DESKEW_MEM1r
#define WRITELN_RX_X4_ECC_STS_DESKEW_MEM1r BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_DESKEW_MEM1r
#define WRITEALL_RX_X4_ECC_STS_DESKEW_MEM1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_DESKEW_MEM1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_STS_DESKEW_MEM2
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc385
 * DESC:     ECC status register for MEM2 per physical lane
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ERR_EVENT_ADDRESS_DESKEW_2 ECC error location, valid only if 1-bit or 2-bit error bit is set
 *     ONE_BIT_ERR_EVENT_DESKEW_2 1-bit ECC error detected
 *     TWO_BIT_ERR_EVENT_DESKEW_2 2-bit ECC error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r (0x0000c385 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_STS_DESKEW_MEM2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_sts_deskew_mem2[1];
	uint32_t _rx_x4_ecc_sts_deskew_mem2;
} BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_CLR(r) (r).rx_x4_ecc_sts_deskew_mem2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_SET(r,d) (r).rx_x4_ecc_sts_deskew_mem2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_GET(r) (r).rx_x4_ecc_sts_deskew_mem2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_TWO_BIT_ERR_EVENT_DESKEW_2f_GET(r) ((((r).rx_x4_ecc_sts_deskew_mem2[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_TWO_BIT_ERR_EVENT_DESKEW_2f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem2[0]=(((r).rx_x4_ecc_sts_deskew_mem2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ONE_BIT_ERR_EVENT_DESKEW_2f_GET(r) ((((r).rx_x4_ecc_sts_deskew_mem2[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ONE_BIT_ERR_EVENT_DESKEW_2f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem2[0]=(((r).rx_x4_ecc_sts_deskew_mem2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ERR_EVENT_ADDRESS_DESKEW_2f_GET(r) (((r).rx_x4_ecc_sts_deskew_mem2[0]) & 0x3fff)
#define BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ERR_EVENT_ADDRESS_DESKEW_2f_SET(r,f) (r).rx_x4_ecc_sts_deskew_mem2[0]=(((r).rx_x4_ecc_sts_deskew_mem2[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access RX_X4_ECC_STS_DESKEW_MEM2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_DESKEW_MEM2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r,(_r._rx_x4_ecc_sts_deskew_mem2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_DESKEW_MEM2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r,(_r._rx_x4_ecc_sts_deskew_mem2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_DESKEW_MEM2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r,(_r._rx_x4_ecc_sts_deskew_mem2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_DESKEW_MEM2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_deskew_mem2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_DESKEW_MEM2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_sts_deskew_mem2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_DESKEW_MEM2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_sts_deskew_mem2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_STS_DESKEW_MEM2r BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r
#define RX_X4_ECC_STS_DESKEW_MEM2r_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_t RX_X4_ECC_STS_DESKEW_MEM2r_t;
#define RX_X4_ECC_STS_DESKEW_MEM2r_CLR BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_CLR
#define RX_X4_ECC_STS_DESKEW_MEM2r_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_SET
#define RX_X4_ECC_STS_DESKEW_MEM2r_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_GET
#define RX_X4_ECC_STS_DESKEW_MEM2r_TWO_BIT_ERR_EVENT_DESKEW_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_TWO_BIT_ERR_EVENT_DESKEW_2f_GET
#define RX_X4_ECC_STS_DESKEW_MEM2r_TWO_BIT_ERR_EVENT_DESKEW_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_TWO_BIT_ERR_EVENT_DESKEW_2f_SET
#define RX_X4_ECC_STS_DESKEW_MEM2r_ONE_BIT_ERR_EVENT_DESKEW_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ONE_BIT_ERR_EVENT_DESKEW_2f_GET
#define RX_X4_ECC_STS_DESKEW_MEM2r_ONE_BIT_ERR_EVENT_DESKEW_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ONE_BIT_ERR_EVENT_DESKEW_2f_SET
#define RX_X4_ECC_STS_DESKEW_MEM2r_ERR_EVENT_ADDRESS_DESKEW_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ERR_EVENT_ADDRESS_DESKEW_2f_GET
#define RX_X4_ECC_STS_DESKEW_MEM2r_ERR_EVENT_ADDRESS_DESKEW_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r_ERR_EVENT_ADDRESS_DESKEW_2f_SET
#define READ_RX_X4_ECC_STS_DESKEW_MEM2r BCMI_TSCD_XGXS_READ_RX_X4_ECC_STS_DESKEW_MEM2r
#define WRITE_RX_X4_ECC_STS_DESKEW_MEM2r BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_STS_DESKEW_MEM2r
#define MODIFY_RX_X4_ECC_STS_DESKEW_MEM2r BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_STS_DESKEW_MEM2r
#define READLN_RX_X4_ECC_STS_DESKEW_MEM2r BCMI_TSCD_XGXS_READLN_RX_X4_ECC_STS_DESKEW_MEM2r
#define WRITELN_RX_X4_ECC_STS_DESKEW_MEM2r BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_STS_DESKEW_MEM2r
#define WRITEALL_RX_X4_ECC_STS_DESKEW_MEM2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_STS_DESKEW_MEM2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_STS_DESKEW_MEM2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_INTR_STS_1BIT
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc386
 * DESC:     ECC 1-bit interrupt status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL91_BUFFER_BLK0_1BIT_INT_STATUS Single bit, correctable error detected
 *     CL91_BUFFER_BLK1_1BIT_INT_STATUS Single bit, correctable error detected
 *     CL91_BUFFER_BLK2_1BIT_INT_STATUS Single bit, correctable error detected
 *     DESKEW_MEM_0_1BIT_INT_STATUS Single bit, correctable error detected
 *     DESKEW_MEM_1_1BIT_INT_STATUS Single bit, correctable error detected
 *     DESKEW_MEM_2_1BIT_INT_STATUS Single bit, correctable error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr (0x0000c386 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_INTR_STS_1BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_intr_sts_1bit[1];
	uint32_t _rx_x4_ecc_intr_sts_1bit;
} BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CLR(r) (r).rx_x4_ecc_intr_sts_1bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_SET(r,d) (r).rx_x4_ecc_intr_sts_1bit[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_GET(r) (r).rx_x4_ecc_intr_sts_1bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_2_1BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_1bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_2_1BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_1bit[0]=(((r).rx_x4_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_1_1BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_1bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_1_1BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_1bit[0]=(((r).rx_x4_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_0_1BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_1bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_0_1BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_1bit[0]=(((r).rx_x4_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK2_1BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_1bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK2_1BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_1bit[0]=(((r).rx_x4_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK1_1BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_1bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK1_1BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_1bit[0]=(((r).rx_x4_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK0_1BIT_INT_STATUSf_GET(r) (((r).rx_x4_ecc_intr_sts_1bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK0_1BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_1bit[0]=(((r).rx_x4_ecc_intr_sts_1bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_ECC_INTR_STS_1BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_STS_1BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr,(_r._rx_x4_ecc_intr_sts_1bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_STS_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr,(_r._rx_x4_ecc_intr_sts_1bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_STS_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr,(_r._rx_x4_ecc_intr_sts_1bit))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_STS_1BITr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_sts_1bit))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_STS_1BITr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_sts_1bit))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_STS_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_intr_sts_1bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr
#define RX_X4_ECC_INTR_STS_1BITr_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_t RX_X4_ECC_INTR_STS_1BITr_t;
#define RX_X4_ECC_INTR_STS_1BITr_CLR BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CLR
#define RX_X4_ECC_INTR_STS_1BITr_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_SET
#define RX_X4_ECC_INTR_STS_1BITr_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_GET
#define RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_2_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_2_1BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_2_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_2_1BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_1_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_1_1BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_1_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_1_1BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_0_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_0_1BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_0_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_DESKEW_MEM_0_1BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK2_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK2_1BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK2_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK2_1BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK1_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK1_1BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK1_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK1_1BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK0_1BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK0_1BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK0_1BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr_CL91_BUFFER_BLK0_1BIT_INT_STATUSf_SET
#define READ_RX_X4_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_STS_1BITr
#define WRITE_RX_X4_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_STS_1BITr
#define MODIFY_RX_X4_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_STS_1BITr
#define READLN_RX_X4_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_STS_1BITr
#define WRITELN_RX_X4_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_STS_1BITr
#define WRITEALL_RX_X4_ECC_INTR_STS_1BITr BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_STS_1BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_1BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_INTR_STS_2BIT
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc387
 * DESC:     ECC 2-bit interrupt status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL91_BUFFER_BLK0_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     CL91_BUFFER_BLK1_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     CL91_BUFFER_BLK2_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     DESKEW_MEM_0_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     DESKEW_MEM_1_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *     DESKEW_MEM_2_2BIT_INT_STATUS Two bit, uncorrectable error detected
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr (0x0000c387 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_INTR_STS_2BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_intr_sts_2bit[1];
	uint32_t _rx_x4_ecc_intr_sts_2bit;
} BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CLR(r) (r).rx_x4_ecc_intr_sts_2bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_SET(r,d) (r).rx_x4_ecc_intr_sts_2bit[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_GET(r) (r).rx_x4_ecc_intr_sts_2bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_2_2BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_2bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_2_2BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_2bit[0]=(((r).rx_x4_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_1_2BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_2bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_1_2BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_2bit[0]=(((r).rx_x4_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_0_2BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_2bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_0_2BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_2bit[0]=(((r).rx_x4_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK2_2BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_2bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK2_2BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_2bit[0]=(((r).rx_x4_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK1_2BIT_INT_STATUSf_GET(r) ((((r).rx_x4_ecc_intr_sts_2bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK1_2BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_2bit[0]=(((r).rx_x4_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK0_2BIT_INT_STATUSf_GET(r) (((r).rx_x4_ecc_intr_sts_2bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK0_2BIT_INT_STATUSf_SET(r,f) (r).rx_x4_ecc_intr_sts_2bit[0]=(((r).rx_x4_ecc_intr_sts_2bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_ECC_INTR_STS_2BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_STS_2BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr,(_r._rx_x4_ecc_intr_sts_2bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_STS_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr,(_r._rx_x4_ecc_intr_sts_2bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_STS_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr,(_r._rx_x4_ecc_intr_sts_2bit))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_STS_2BITr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_sts_2bit))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_STS_2BITr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_sts_2bit))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_STS_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_intr_sts_2bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr
#define RX_X4_ECC_INTR_STS_2BITr_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_t RX_X4_ECC_INTR_STS_2BITr_t;
#define RX_X4_ECC_INTR_STS_2BITr_CLR BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CLR
#define RX_X4_ECC_INTR_STS_2BITr_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_SET
#define RX_X4_ECC_INTR_STS_2BITr_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_GET
#define RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_2_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_2_2BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_2_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_2_2BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_1_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_1_2BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_1_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_1_2BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_0_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_0_2BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_0_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_DESKEW_MEM_0_2BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK2_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK2_2BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK2_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK2_2BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK1_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK1_2BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK1_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK1_2BIT_INT_STATUSf_SET
#define RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK0_2BIT_INT_STATUSf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK0_2BIT_INT_STATUSf_GET
#define RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK0_2BIT_INT_STATUSf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr_CL91_BUFFER_BLK0_2BIT_INT_STATUSf_SET
#define READ_RX_X4_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_STS_2BITr
#define WRITE_RX_X4_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_STS_2BITr
#define MODIFY_RX_X4_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_STS_2BITr
#define READLN_RX_X4_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_STS_2BITr
#define WRITELN_RX_X4_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_STS_2BITr
#define WRITEALL_RX_X4_ECC_INTR_STS_2BITr BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_STS_2BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_INTR_STS_2BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_INTR_EN_1BIT
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc388
 * DESC:     ECC 1-bit interrupt enable register
 * RESETVAL: 0x3f (63)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_BUFFER_BLK0_1BIT_INT_EN Enable for correctable error interrupt
 *     CL91_BUFFER_BLK1_1BIT_INT_EN Enable for correctable error interrupt
 *     CL91_BUFFER_BLK2_1BIT_INT_EN Enable for correctable error interrupt
 *     DESKEW_MEM_0_1BIT_INT_EN Enable for correctable error interrupt
 *     DESKEW_MEM_1_1BIT_INT_EN Enable for correctable error interrupt
 *     DESKEW_MEM_2_1BIT_INT_EN Enable for correctable error interrupt
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr (0x0000c388 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_INTR_EN_1BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_intr_en_1bit[1];
	uint32_t _rx_x4_ecc_intr_en_1bit;
} BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CLR(r) (r).rx_x4_ecc_intr_en_1bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_SET(r,d) (r).rx_x4_ecc_intr_en_1bit[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_GET(r) (r).rx_x4_ecc_intr_en_1bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_2_1BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_1bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_2_1BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_1bit[0]=(((r).rx_x4_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_1_1BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_1bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_1_1BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_1bit[0]=(((r).rx_x4_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_0_1BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_1bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_0_1BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_1bit[0]=(((r).rx_x4_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK2_1BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_1bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK2_1BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_1bit[0]=(((r).rx_x4_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK1_1BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_1bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK1_1BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_1bit[0]=(((r).rx_x4_ecc_intr_en_1bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK0_1BIT_INT_ENf_GET(r) (((r).rx_x4_ecc_intr_en_1bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK0_1BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_1bit[0]=(((r).rx_x4_ecc_intr_en_1bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_ECC_INTR_EN_1BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_EN_1BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr,(_r._rx_x4_ecc_intr_en_1bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_EN_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr,(_r._rx_x4_ecc_intr_en_1bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_EN_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr,(_r._rx_x4_ecc_intr_en_1bit))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_EN_1BITr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_en_1bit))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_EN_1BITr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_en_1bit))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_EN_1BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_intr_en_1bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr
#define RX_X4_ECC_INTR_EN_1BITr_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_t RX_X4_ECC_INTR_EN_1BITr_t;
#define RX_X4_ECC_INTR_EN_1BITr_CLR BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CLR
#define RX_X4_ECC_INTR_EN_1BITr_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_SET
#define RX_X4_ECC_INTR_EN_1BITr_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_GET
#define RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_2_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_2_1BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_2_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_2_1BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_1_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_1_1BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_1_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_1_1BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_0_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_0_1BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_0_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_DESKEW_MEM_0_1BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK2_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK2_1BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK2_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK2_1BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK1_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK1_1BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK1_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK1_1BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK0_1BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK0_1BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK0_1BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr_CL91_BUFFER_BLK0_1BIT_INT_ENf_SET
#define READ_RX_X4_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_EN_1BITr
#define WRITE_RX_X4_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_EN_1BITr
#define MODIFY_RX_X4_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_EN_1BITr
#define READLN_RX_X4_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_EN_1BITr
#define WRITELN_RX_X4_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_EN_1BITr
#define WRITEALL_RX_X4_ECC_INTR_EN_1BITr BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_EN_1BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_1BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_INTR_EN_2BIT
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc389
 * DESC:     ECC 2-bit interrupt enable register
 * RESETVAL: 0x3f (63)
 * ACCESS:   R/W
 * FIELDS:
 *     CL91_BUFFER_BLK0_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     CL91_BUFFER_BLK1_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     CL91_BUFFER_BLK2_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     DESKEW_MEM_0_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     DESKEW_MEM_1_2BIT_INT_EN Enable for uncorrectable error interrupt
 *     DESKEW_MEM_2_2BIT_INT_EN Enable for uncorrectable error interrupt
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr (0x0000c389 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_INTR_EN_2BIT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_intr_en_2bit[1];
	uint32_t _rx_x4_ecc_intr_en_2bit;
} BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CLR(r) (r).rx_x4_ecc_intr_en_2bit[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_SET(r,d) (r).rx_x4_ecc_intr_en_2bit[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_GET(r) (r).rx_x4_ecc_intr_en_2bit[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_2_2BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_2bit[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_2_2BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_2bit[0]=(((r).rx_x4_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_1_2BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_2bit[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_1_2BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_2bit[0]=(((r).rx_x4_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_0_2BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_2bit[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_0_2BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_2bit[0]=(((r).rx_x4_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK2_2BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_2bit[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK2_2BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_2bit[0]=(((r).rx_x4_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK1_2BIT_INT_ENf_GET(r) ((((r).rx_x4_ecc_intr_en_2bit[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK1_2BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_2bit[0]=(((r).rx_x4_ecc_intr_en_2bit[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK0_2BIT_INT_ENf_GET(r) (((r).rx_x4_ecc_intr_en_2bit[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK0_2BIT_INT_ENf_SET(r,f) (r).rx_x4_ecc_intr_en_2bit[0]=(((r).rx_x4_ecc_intr_en_2bit[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_ECC_INTR_EN_2BIT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_EN_2BITr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr,(_r._rx_x4_ecc_intr_en_2bit))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_EN_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr,(_r._rx_x4_ecc_intr_en_2bit)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_EN_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr,(_r._rx_x4_ecc_intr_en_2bit))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_EN_2BITr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_en_2bit))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_EN_2BITr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_intr_en_2bit))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_EN_2BITr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_intr_en_2bit))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr
#define RX_X4_ECC_INTR_EN_2BITr_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_t RX_X4_ECC_INTR_EN_2BITr_t;
#define RX_X4_ECC_INTR_EN_2BITr_CLR BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CLR
#define RX_X4_ECC_INTR_EN_2BITr_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_SET
#define RX_X4_ECC_INTR_EN_2BITr_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_GET
#define RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_2_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_2_2BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_2_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_2_2BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_1_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_1_2BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_1_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_1_2BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_0_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_0_2BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_0_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_DESKEW_MEM_0_2BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK2_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK2_2BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK2_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK2_2BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK1_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK1_2BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK1_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK1_2BIT_INT_ENf_SET
#define RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK0_2BIT_INT_ENf_GET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK0_2BIT_INT_ENf_GET
#define RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK0_2BIT_INT_ENf_SET BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr_CL91_BUFFER_BLK0_2BIT_INT_ENf_SET
#define READ_RX_X4_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_READ_RX_X4_ECC_INTR_EN_2BITr
#define WRITE_RX_X4_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_INTR_EN_2BITr
#define MODIFY_RX_X4_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_INTR_EN_2BITr
#define READLN_RX_X4_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_READLN_RX_X4_ECC_INTR_EN_2BITr
#define WRITELN_RX_X4_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_INTR_EN_2BITr
#define WRITEALL_RX_X4_ECC_INTR_EN_2BITr BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_INTR_EN_2BITr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_INTR_EN_2BITr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_DIS_ECC_MEM
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc38a
 * DESC:     Disable ECC register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DISABLE_ECC_CL91_BUFFER_BLK0 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_CL91_BUFFER_BLK1 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_CL91_BUFFER_BLK2 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_DESKEW_MEM_0 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_DESKEW_MEM_1 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *     DISABLE_ECC_DESKEW_MEM_2 disable ECC check/generationThis bit should not be changed from 1 to 0 in the middle of the test
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr (0x0000c38a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_DIS_ECC_MEM.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_dis_ecc_mem[1];
	uint32_t _rx_x4_ecc_dis_ecc_mem;
} BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_CLR(r) (r).rx_x4_ecc_dis_ecc_mem[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_SET(r,d) (r).rx_x4_ecc_dis_ecc_mem[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_GET(r) (r).rx_x4_ecc_dis_ecc_mem[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_2f_GET(r) ((((r).rx_x4_ecc_dis_ecc_mem[0]) >> 5) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_2f_SET(r,f) (r).rx_x4_ecc_dis_ecc_mem[0]=(((r).rx_x4_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_1f_GET(r) ((((r).rx_x4_ecc_dis_ecc_mem[0]) >> 4) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_1f_SET(r,f) (r).rx_x4_ecc_dis_ecc_mem[0]=(((r).rx_x4_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_0f_GET(r) ((((r).rx_x4_ecc_dis_ecc_mem[0]) >> 3) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_0f_SET(r,f) (r).rx_x4_ecc_dis_ecc_mem[0]=(((r).rx_x4_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK2f_GET(r) ((((r).rx_x4_ecc_dis_ecc_mem[0]) >> 2) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK2f_SET(r,f) (r).rx_x4_ecc_dis_ecc_mem[0]=(((r).rx_x4_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK1f_GET(r) ((((r).rx_x4_ecc_dis_ecc_mem[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK1f_SET(r,f) (r).rx_x4_ecc_dis_ecc_mem[0]=(((r).rx_x4_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK0f_GET(r) (((r).rx_x4_ecc_dis_ecc_mem[0]) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK0f_SET(r,f) (r).rx_x4_ecc_dis_ecc_mem[0]=(((r).rx_x4_ecc_dis_ecc_mem[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access RX_X4_ECC_DIS_ECC_MEM.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_DIS_ECC_MEMr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr,(_r._rx_x4_ecc_dis_ecc_mem))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_DIS_ECC_MEMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr,(_r._rx_x4_ecc_dis_ecc_mem)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_DIS_ECC_MEMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr,(_r._rx_x4_ecc_dis_ecc_mem))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_DIS_ECC_MEMr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_dis_ecc_mem))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_DIS_ECC_MEMr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_dis_ecc_mem))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_DIS_ECC_MEMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_dis_ecc_mem))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr
#define RX_X4_ECC_DIS_ECC_MEMr_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_t RX_X4_ECC_DIS_ECC_MEMr_t;
#define RX_X4_ECC_DIS_ECC_MEMr_CLR BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_CLR
#define RX_X4_ECC_DIS_ECC_MEMr_SET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_SET
#define RX_X4_ECC_DIS_ECC_MEMr_GET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_GET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_2f_GET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_2f_SET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_1f_GET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_1f_SET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_0f_GET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_DESKEW_MEM_0f_SET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK2f_GET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK2f_SET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK1f_GET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK1f_SET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK0f_GET
#define RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr_DISABLE_ECC_CL91_BUFFER_BLK0f_SET
#define READ_RX_X4_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_READ_RX_X4_ECC_DIS_ECC_MEMr
#define WRITE_RX_X4_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_DIS_ECC_MEMr
#define MODIFY_RX_X4_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_DIS_ECC_MEMr
#define READLN_RX_X4_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_READLN_RX_X4_ECC_DIS_ECC_MEMr
#define WRITELN_RX_X4_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_DIS_ECC_MEMr
#define WRITEALL_RX_X4_ECC_DIS_ECC_MEMr BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_DIS_ECC_MEMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_DIS_ECC_MEMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_ECC_CORRUPT
 * BLOCKS:   RX_X4_ECC
 * REGADDR:  0xc38b
 * DESC:     Corrupt ECC register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORRUPT_ECC_CL91_BUFFER_BLK0 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_CL91_BUFFER_BLK1 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_CL91_BUFFER_BLK2 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_DESKEW_MEM_0 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_DESKEW_MEM_1 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *     CORRUPT_ECC_DESKEW_MEM_2 ECC error injection2'b01 - Inject 2-bit error on write data2'b10 - Inject 1-bit error on read data2'b11 - Inject 2-bit error on read data
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr (0x0000c38b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_ECC_CORRUPT.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_s {
	uint32_t v[1];
	uint32_t rx_x4_ecc_corrupt[1];
	uint32_t _rx_x4_ecc_corrupt;
} BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_t;

#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CLR(r) (r).rx_x4_ecc_corrupt[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_SET(r,d) (r).rx_x4_ecc_corrupt[0] = d
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_GET(r) (r).rx_x4_ecc_corrupt[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_2f_GET(r) ((((r).rx_x4_ecc_corrupt[0]) >> 10) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_2f_SET(r,f) (r).rx_x4_ecc_corrupt[0]=(((r).rx_x4_ecc_corrupt[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_1f_GET(r) ((((r).rx_x4_ecc_corrupt[0]) >> 8) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_1f_SET(r,f) (r).rx_x4_ecc_corrupt[0]=(((r).rx_x4_ecc_corrupt[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_0f_GET(r) ((((r).rx_x4_ecc_corrupt[0]) >> 6) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_0f_SET(r,f) (r).rx_x4_ecc_corrupt[0]=(((r).rx_x4_ecc_corrupt[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK2f_GET(r) ((((r).rx_x4_ecc_corrupt[0]) >> 4) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK2f_SET(r,f) (r).rx_x4_ecc_corrupt[0]=(((r).rx_x4_ecc_corrupt[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK1f_GET(r) ((((r).rx_x4_ecc_corrupt[0]) >> 2) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK1f_SET(r,f) (r).rx_x4_ecc_corrupt[0]=(((r).rx_x4_ecc_corrupt[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK0f_GET(r) (((r).rx_x4_ecc_corrupt[0]) & 0x3)
#define BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK0f_SET(r,f) (r).rx_x4_ecc_corrupt[0]=(((r).rx_x4_ecc_corrupt[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access RX_X4_ECC_CORRUPT.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr,(_r._rx_x4_ecc_corrupt))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr,(_r._rx_x4_ecc_corrupt)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr,(_r._rx_x4_ecc_corrupt))
#define BCMI_TSCD_XGXS_READLN_RX_X4_ECC_CORRUPTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_corrupt))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_CORRUPTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_ecc_corrupt))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_CORRUPTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_ecc_corrupt))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_ECC_CORRUPTr BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr
#define RX_X4_ECC_CORRUPTr_SIZE BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_t RX_X4_ECC_CORRUPTr_t;
#define RX_X4_ECC_CORRUPTr_CLR BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CLR
#define RX_X4_ECC_CORRUPTr_SET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_SET
#define RX_X4_ECC_CORRUPTr_GET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_GET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_2f_GET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_2f_SET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_1f_GET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_1f_SET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_0f_GET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_DESKEW_MEM_0f_SET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK2f_GET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK2f_GET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK2f_SET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK2f_SET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK1f_GET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK1f_GET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK1f_SET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK1f_SET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK0f_GET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK0f_GET
#define RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK0f_SET BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr_CORRUPT_ECC_CL91_BUFFER_BLK0f_SET
#define READ_RX_X4_ECC_CORRUPTr BCMI_TSCD_XGXS_READ_RX_X4_ECC_CORRUPTr
#define WRITE_RX_X4_ECC_CORRUPTr BCMI_TSCD_XGXS_WRITE_RX_X4_ECC_CORRUPTr
#define MODIFY_RX_X4_ECC_CORRUPTr BCMI_TSCD_XGXS_MODIFY_RX_X4_ECC_CORRUPTr
#define READLN_RX_X4_ECC_CORRUPTr BCMI_TSCD_XGXS_READLN_RX_X4_ECC_CORRUPTr
#define WRITELN_RX_X4_ECC_CORRUPTr BCMI_TSCD_XGXS_WRITELN_RX_X4_ECC_CORRUPTr
#define WRITEALL_RX_X4_ECC_CORRUPTr BCMI_TSCD_XGXS_WRITEALL_RX_X4_ECC_CORRUPTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_ECC_CORRUPTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_CALC0
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc390
 * DESC:     Rx Base Timestamp status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_0 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL0(1st copy)/VL5(2nd copy)/VL10(3rd copy)/VL15(4th copy)In 40G MLD mode over 2 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)In 40G MLD mode over 2 lanes(Port2) - VL0(3rd copy)/VL1(4th copy)In 40G MLD mode over 4 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)/VL2(3rd copy)/VL3(4th copy)In 20G MLD mode over 2 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)In 20G MLD mode over 2 lanes(Port2) - VL0(3rd copy)/VL1(4th copy)
 *     BASE_TS_NS_0     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r (0x0000c390 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_CALC0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_calc0[1];
	uint32_t _rx_x4_rx_deskew_base_ts_calc0;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_CLR(r) (r).rx_x4_rx_deskew_base_ts_calc0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_calc0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_GET(r) (r).rx_x4_rx_deskew_base_ts_calc0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_NS_0f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_calc0[0]) >> 4) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_NS_0f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc0[0]=(((r).rx_x4_rx_deskew_base_ts_calc0[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_SUB_NS_0f_GET(r) (((r).rx_x4_rx_deskew_base_ts_calc0[0]) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_SUB_NS_0f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc0[0]=(((r).rx_x4_rx_deskew_base_ts_calc0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_CALC0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r,(_r._rx_x4_rx_deskew_base_ts_calc0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r,(_r._rx_x4_rx_deskew_base_ts_calc0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r,(_r._rx_x4_rx_deskew_base_ts_calc0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_calc0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_CALC0r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_t RX_X4_RX_DESKEW_BASE_TS_CALC0r_t;
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_NS_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_NS_0f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_NS_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_NS_0f_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_SUB_NS_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_SUB_NS_0f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_SUB_NS_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r_BASE_TS_SUB_NS_0f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_CALC0r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC0r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC0r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC0r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC0r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC0r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_CALC0r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC0r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC0r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC0r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_ADJ0
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc391
 * DESC:     Rx Base Timestamp Adjust status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BIT_POS_ADJ_0    Indicates the Bit Position Adjustment that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.This field is represented as a 2's complement value, as the bit position adjustment can be negativeOn Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL0(1st copy)/VL5(2nd copy)/VL10(3rd copy)/VL15(4th copy)In 40G MLD mode over 2 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)In 40G MLD mode over 2 lanes(Port2) - VL0(3rd copy)/VL1(4th copy)In 40G MLD mode over 4 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)/VL2(3rd copy)/VL3(4th copy)In 20G MLD mode over 2 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)In 20G MLD mode over 2 lanes(Port2) - VL0(3rd copy)/VL1(4th copy)
 *     BASE_TS_FCLK_ADJ_0 Indicates the Glas Adjustment or FCLK Adjust that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r (0x0000c391 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_ADJ0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_adj0[1];
	uint32_t _rx_x4_rx_deskew_base_ts_adj0;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_CLR(r) (r).rx_x4_rx_deskew_base_ts_adj0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_adj0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_GET(r) (r).rx_x4_rx_deskew_base_ts_adj0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BASE_TS_FCLK_ADJ_0f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_adj0[0]) >> 9) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BASE_TS_FCLK_ADJ_0f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj0[0]=(((r).rx_x4_rx_deskew_base_ts_adj0[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BIT_POS_ADJ_0f_GET(r) (((r).rx_x4_rx_deskew_base_ts_adj0[0]) & 0x1ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BIT_POS_ADJ_0f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj0[0]=(((r).rx_x4_rx_deskew_base_ts_adj0[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_ADJ0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r,(_r._rx_x4_rx_deskew_base_ts_adj0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r,(_r._rx_x4_rx_deskew_base_ts_adj0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r,(_r._rx_x4_rx_deskew_base_ts_adj0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_adj0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_t RX_X4_RX_DESKEW_BASE_TS_ADJ0r_t;
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BASE_TS_FCLK_ADJ_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BASE_TS_FCLK_ADJ_0f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BASE_TS_FCLK_ADJ_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BASE_TS_FCLK_ADJ_0f_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BIT_POS_ADJ_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BIT_POS_ADJ_0f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BIT_POS_ADJ_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r_BIT_POS_ADJ_0f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_ADJ0r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ0r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ0r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ0r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ0r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ0r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ0r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ0r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ0r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ0r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_AM_OFFS0
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc392
 * DESC:     Rx AM Block Offset status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_BLOCK_OFFSET_0 Indicates the block offset from the block that carries the Rx base timestamp to the AM block.The block size is 66bits for CL82 ports that run with or without CL74 FEC.The block size is 60 for CL82 ports that run with CL91.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL0(1st copy)/VL5(2nd copy)/VL10(3rd copy)/VL15(4th copy)In 40G MLD mode over 2 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)In 40G MLD mode over 2 lanes(Port2) - VL0(3rd copy)/VL1(4th copy)In 40G MLD mode over 4 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)/VL2(3rd copy)/VL3(4th copy)In 20G MLD mode over 2 lanes(Port0) - VL0(1st copy)/VL1(2nd copy)In 20G MLD mode over 2 lanes(Port2) - VL0(3rd copy)/VL1(4th copy)After DESKEW event, The final timestamp of the AM on each virtual lane is calculated as followsAM_timestamp_vl[n]  = Rx_base_timestamp{ns, sub_ns}+/- ((Bit_position_offset - bit_muxed_psl_lane_num)*num_bit_muxed_lanes*mod_ui_value)+ (bit_muxed_psl_lane_num*mod_ui_value)+ (Fclk_adjust*fclk_period)+ (AM_block_offset * block_size * num_bit_muxed_lanes*mod_ui_value)-	(Cl74_fec_block_number * num_bit_muxed_lanes*mod_ui_value) (applicable only for CL74)Where Num_bit_muxed_lanes =  1/2/5 based on the number of pseudo logical lanes bit-muxed onto 1 physical lanebit_muxed_psl_lane_num = Lane number of the pseudo logical lane within a bit muxed physical laneMod_ui_value = vco_clk_period * os_mode
 *     CL74_FEC_BLOCK_NUM_0 Indicates the CL74 FEC block number of the AM block within the CL74 codeword. Need to be used only for ports that employ CL74
 *     AM_TIMESTAMP_INFO_VALID_0 When set, it indicates that AM timestamp information is valid for the virtual lane. SW can use the information for deskewadjustment calculations.Once set, this bit will continue to remain asserted until Rx AM timestamp capture is restarted.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r (0x0000c392 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_AM_OFFS0.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_am_offs0[1];
	uint32_t _rx_x4_rx_deskew_am_offs0;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_CLR(r) (r).rx_x4_rx_deskew_am_offs0[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_SET(r,d) (r).rx_x4_rx_deskew_am_offs0[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_GET(r) (r).rx_x4_rx_deskew_am_offs0[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_TIMESTAMP_INFO_VALID_0f_GET(r) ((((r).rx_x4_rx_deskew_am_offs0[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_TIMESTAMP_INFO_VALID_0f_SET(r,f) (r).rx_x4_rx_deskew_am_offs0[0]=(((r).rx_x4_rx_deskew_am_offs0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_CL74_FEC_BLOCK_NUM_0f_GET(r) ((((r).rx_x4_rx_deskew_am_offs0[0]) >> 6) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_CL74_FEC_BLOCK_NUM_0f_SET(r,f) (r).rx_x4_rx_deskew_am_offs0[0]=(((r).rx_x4_rx_deskew_am_offs0[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_BLOCK_OFFSET_0f_GET(r) (((r).rx_x4_rx_deskew_am_offs0[0]) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_BLOCK_OFFSET_0f_SET(r,f) (r).rx_x4_rx_deskew_am_offs0[0]=(((r).rx_x4_rx_deskew_am_offs0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_AM_OFFS0.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r,(_r._rx_x4_rx_deskew_am_offs0))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r,(_r._rx_x4_rx_deskew_am_offs0)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r,(_r._rx_x4_rx_deskew_am_offs0))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs0))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs0))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_am_offs0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_AM_OFFS0r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r
#define RX_X4_RX_DESKEW_AM_OFFS0r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_t RX_X4_RX_DESKEW_AM_OFFS0r_t;
#define RX_X4_RX_DESKEW_AM_OFFS0r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_CLR
#define RX_X4_RX_DESKEW_AM_OFFS0r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_SET
#define RX_X4_RX_DESKEW_AM_OFFS0r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_GET
#define RX_X4_RX_DESKEW_AM_OFFS0r_AM_TIMESTAMP_INFO_VALID_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_TIMESTAMP_INFO_VALID_0f_GET
#define RX_X4_RX_DESKEW_AM_OFFS0r_AM_TIMESTAMP_INFO_VALID_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_TIMESTAMP_INFO_VALID_0f_SET
#define RX_X4_RX_DESKEW_AM_OFFS0r_CL74_FEC_BLOCK_NUM_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_CL74_FEC_BLOCK_NUM_0f_GET
#define RX_X4_RX_DESKEW_AM_OFFS0r_CL74_FEC_BLOCK_NUM_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_CL74_FEC_BLOCK_NUM_0f_SET
#define RX_X4_RX_DESKEW_AM_OFFS0r_AM_BLOCK_OFFSET_0f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_BLOCK_OFFSET_0f_GET
#define RX_X4_RX_DESKEW_AM_OFFS0r_AM_BLOCK_OFFSET_0f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r_AM_BLOCK_OFFSET_0f_SET
#define READ_RX_X4_RX_DESKEW_AM_OFFS0r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS0r
#define WRITE_RX_X4_RX_DESKEW_AM_OFFS0r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS0r
#define MODIFY_RX_X4_RX_DESKEW_AM_OFFS0r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS0r
#define READLN_RX_X4_RX_DESKEW_AM_OFFS0r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS0r
#define WRITELN_RX_X4_RX_DESKEW_AM_OFFS0r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS0r
#define WRITEALL_RX_X4_RX_DESKEW_AM_OFFS0r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_CALC1
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc393
 * DESC:     Rx Base Timestamp status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_1 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL1(1st copy)/VL6(2nd copy)/VL11(3rd copy)/VL16(4th copy)In 40G MLD mode over 2 lanes(Port0) - VL2(1st copy)/VL3(2nd copy)In 40G MLD mode over 2 lanes(Port2) - VL2(3rd copy)/VL3(4th copy)
 *     BASE_TS_NS_1     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r (0x0000c393 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_CALC1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_calc1[1];
	uint32_t _rx_x4_rx_deskew_base_ts_calc1;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_CLR(r) (r).rx_x4_rx_deskew_base_ts_calc1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_calc1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_GET(r) (r).rx_x4_rx_deskew_base_ts_calc1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_NS_1f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_calc1[0]) >> 4) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_NS_1f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc1[0]=(((r).rx_x4_rx_deskew_base_ts_calc1[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_SUB_NS_1f_GET(r) (((r).rx_x4_rx_deskew_base_ts_calc1[0]) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_SUB_NS_1f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc1[0]=(((r).rx_x4_rx_deskew_base_ts_calc1[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_CALC1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r,(_r._rx_x4_rx_deskew_base_ts_calc1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r,(_r._rx_x4_rx_deskew_base_ts_calc1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r,(_r._rx_x4_rx_deskew_base_ts_calc1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_calc1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_CALC1r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_t RX_X4_RX_DESKEW_BASE_TS_CALC1r_t;
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_NS_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_NS_1f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_NS_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_NS_1f_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_SUB_NS_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_SUB_NS_1f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_SUB_NS_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r_BASE_TS_SUB_NS_1f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_CALC1r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC1r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC1r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC1r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC1r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC1r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_CALC1r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC1r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC1r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC1r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_ADJ1
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc394
 * DESC:     Rx Base Timestamp Adjust status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BIT_POS_ADJ_1    Indicates the Bit Position Adjustment that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.This field is represented as a 2's complement value, as the bit position adjustment can be negativeOn Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL1(1st copy)/VL6(2nd copy)/VL11(3rd copy)/VL16(4th copy)In 40G MLD mode over 2 lanes(Port0) - VL2(1st copy)/VL3(2nd copy)In 40G MLD mode over 2 lanes(Port2) - VL2(3rd copy)/VL3(4th copy)
 *     BASE_TS_FCLK_ADJ_1 Indicates the Glas Adjustment or FCLK Adjust that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r (0x0000c394 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_ADJ1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_adj1[1];
	uint32_t _rx_x4_rx_deskew_base_ts_adj1;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_CLR(r) (r).rx_x4_rx_deskew_base_ts_adj1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_adj1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_GET(r) (r).rx_x4_rx_deskew_base_ts_adj1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BASE_TS_FCLK_ADJ_1f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_adj1[0]) >> 9) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BASE_TS_FCLK_ADJ_1f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj1[0]=(((r).rx_x4_rx_deskew_base_ts_adj1[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BIT_POS_ADJ_1f_GET(r) (((r).rx_x4_rx_deskew_base_ts_adj1[0]) & 0x1ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BIT_POS_ADJ_1f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj1[0]=(((r).rx_x4_rx_deskew_base_ts_adj1[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_ADJ1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r,(_r._rx_x4_rx_deskew_base_ts_adj1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r,(_r._rx_x4_rx_deskew_base_ts_adj1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r,(_r._rx_x4_rx_deskew_base_ts_adj1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_adj1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_t RX_X4_RX_DESKEW_BASE_TS_ADJ1r_t;
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BASE_TS_FCLK_ADJ_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BASE_TS_FCLK_ADJ_1f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BASE_TS_FCLK_ADJ_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BASE_TS_FCLK_ADJ_1f_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BIT_POS_ADJ_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BIT_POS_ADJ_1f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BIT_POS_ADJ_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r_BIT_POS_ADJ_1f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_ADJ1r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ1r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ1r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ1r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ1r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ1r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ1r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ1r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ1r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ1r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_AM_OFFS1
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc395
 * DESC:     Rx AM Block Offset status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_BLOCK_OFFSET_1 Indicates the block offset from the block that carries the Rx base timestamp to the AM block.The block size is 66bits for CL82 ports that run with or without CL74 FEC.The block size is 60 for CL82 ports that run with CL91.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL1(1st copy)/VL6(2nd copy)/VL11(3rd copy)/VL16(4th copy)In 40G MLD mode over 2 lanes(Port0) - VL2(1st copy)/VL3(2nd copy)In 40G MLD mode over 2 lanes(Port2) - VL2(3rd copy)/VL3(4th copy)
 *     CL74_FEC_BLOCK_NUM_1 Indicates the CL74 FEC block number of the AM block within the CL74 codeword. Need to be used only for ports that employ CL74
 *     AM_TIMESTAMP_INFO_VALID_1 When set, it indicates that AM timestamp information is valid for the virtual lane. SW can use the information for deskewadjustment calculations.Once set, this bit will continue to remain asserted until Rx AM timestamp capture is restarted.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r (0x0000c395 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_AM_OFFS1.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_am_offs1[1];
	uint32_t _rx_x4_rx_deskew_am_offs1;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_CLR(r) (r).rx_x4_rx_deskew_am_offs1[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_SET(r,d) (r).rx_x4_rx_deskew_am_offs1[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_GET(r) (r).rx_x4_rx_deskew_am_offs1[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_TIMESTAMP_INFO_VALID_1f_GET(r) ((((r).rx_x4_rx_deskew_am_offs1[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_TIMESTAMP_INFO_VALID_1f_SET(r,f) (r).rx_x4_rx_deskew_am_offs1[0]=(((r).rx_x4_rx_deskew_am_offs1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_CL74_FEC_BLOCK_NUM_1f_GET(r) ((((r).rx_x4_rx_deskew_am_offs1[0]) >> 6) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_CL74_FEC_BLOCK_NUM_1f_SET(r,f) (r).rx_x4_rx_deskew_am_offs1[0]=(((r).rx_x4_rx_deskew_am_offs1[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_BLOCK_OFFSET_1f_GET(r) (((r).rx_x4_rx_deskew_am_offs1[0]) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_BLOCK_OFFSET_1f_SET(r,f) (r).rx_x4_rx_deskew_am_offs1[0]=(((r).rx_x4_rx_deskew_am_offs1[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_AM_OFFS1.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r,(_r._rx_x4_rx_deskew_am_offs1))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r,(_r._rx_x4_rx_deskew_am_offs1)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r,(_r._rx_x4_rx_deskew_am_offs1))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs1))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs1))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_am_offs1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_AM_OFFS1r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r
#define RX_X4_RX_DESKEW_AM_OFFS1r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_t RX_X4_RX_DESKEW_AM_OFFS1r_t;
#define RX_X4_RX_DESKEW_AM_OFFS1r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_CLR
#define RX_X4_RX_DESKEW_AM_OFFS1r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_SET
#define RX_X4_RX_DESKEW_AM_OFFS1r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_GET
#define RX_X4_RX_DESKEW_AM_OFFS1r_AM_TIMESTAMP_INFO_VALID_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_TIMESTAMP_INFO_VALID_1f_GET
#define RX_X4_RX_DESKEW_AM_OFFS1r_AM_TIMESTAMP_INFO_VALID_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_TIMESTAMP_INFO_VALID_1f_SET
#define RX_X4_RX_DESKEW_AM_OFFS1r_CL74_FEC_BLOCK_NUM_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_CL74_FEC_BLOCK_NUM_1f_GET
#define RX_X4_RX_DESKEW_AM_OFFS1r_CL74_FEC_BLOCK_NUM_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_CL74_FEC_BLOCK_NUM_1f_SET
#define RX_X4_RX_DESKEW_AM_OFFS1r_AM_BLOCK_OFFSET_1f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_BLOCK_OFFSET_1f_GET
#define RX_X4_RX_DESKEW_AM_OFFS1r_AM_BLOCK_OFFSET_1f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r_AM_BLOCK_OFFSET_1f_SET
#define READ_RX_X4_RX_DESKEW_AM_OFFS1r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS1r
#define WRITE_RX_X4_RX_DESKEW_AM_OFFS1r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS1r
#define MODIFY_RX_X4_RX_DESKEW_AM_OFFS1r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS1r
#define READLN_RX_X4_RX_DESKEW_AM_OFFS1r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS1r
#define WRITELN_RX_X4_RX_DESKEW_AM_OFFS1r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS1r
#define WRITEALL_RX_X4_RX_DESKEW_AM_OFFS1r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_CALC2
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc396
 * DESC:     Rx Base Timestamp status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_2 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL2(1st copy)/VL7(2nd copy)/VL12(3rd copy)/VL17(4th copy)
 *     BASE_TS_NS_2     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r (0x0000c396 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_CALC2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_calc2[1];
	uint32_t _rx_x4_rx_deskew_base_ts_calc2;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_CLR(r) (r).rx_x4_rx_deskew_base_ts_calc2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_calc2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_GET(r) (r).rx_x4_rx_deskew_base_ts_calc2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_NS_2f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_calc2[0]) >> 4) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_NS_2f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc2[0]=(((r).rx_x4_rx_deskew_base_ts_calc2[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_SUB_NS_2f_GET(r) (((r).rx_x4_rx_deskew_base_ts_calc2[0]) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_SUB_NS_2f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc2[0]=(((r).rx_x4_rx_deskew_base_ts_calc2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_CALC2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r,(_r._rx_x4_rx_deskew_base_ts_calc2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r,(_r._rx_x4_rx_deskew_base_ts_calc2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r,(_r._rx_x4_rx_deskew_base_ts_calc2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_calc2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_CALC2r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_t RX_X4_RX_DESKEW_BASE_TS_CALC2r_t;
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_NS_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_NS_2f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_NS_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_NS_2f_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_SUB_NS_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_SUB_NS_2f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_SUB_NS_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r_BASE_TS_SUB_NS_2f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_CALC2r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC2r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC2r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC2r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC2r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC2r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_CALC2r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC2r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC2r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC2r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_ADJ2
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc397
 * DESC:     Rx Base Timestamp Adjust status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BIT_POS_ADJ_2    Indicates the Bit Position Adjustment that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.This field is represented as a 2's complement value, as the bit position adjustment can be negativeOn Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL2(1st copy)/VL7(2nd copy)/VL12(3rd copy)/VL17(4th copy)
 *     BASE_TS_FCLK_ADJ_2 Indicates the Glas Adjustment or FCLK Adjust that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r (0x0000c397 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_ADJ2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_adj2[1];
	uint32_t _rx_x4_rx_deskew_base_ts_adj2;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_CLR(r) (r).rx_x4_rx_deskew_base_ts_adj2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_adj2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_GET(r) (r).rx_x4_rx_deskew_base_ts_adj2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BASE_TS_FCLK_ADJ_2f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_adj2[0]) >> 9) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BASE_TS_FCLK_ADJ_2f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj2[0]=(((r).rx_x4_rx_deskew_base_ts_adj2[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BIT_POS_ADJ_2f_GET(r) (((r).rx_x4_rx_deskew_base_ts_adj2[0]) & 0x1ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BIT_POS_ADJ_2f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj2[0]=(((r).rx_x4_rx_deskew_base_ts_adj2[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_ADJ2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r,(_r._rx_x4_rx_deskew_base_ts_adj2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r,(_r._rx_x4_rx_deskew_base_ts_adj2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r,(_r._rx_x4_rx_deskew_base_ts_adj2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_adj2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_t RX_X4_RX_DESKEW_BASE_TS_ADJ2r_t;
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BASE_TS_FCLK_ADJ_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BASE_TS_FCLK_ADJ_2f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BASE_TS_FCLK_ADJ_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BASE_TS_FCLK_ADJ_2f_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BIT_POS_ADJ_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BIT_POS_ADJ_2f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BIT_POS_ADJ_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r_BIT_POS_ADJ_2f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_ADJ2r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ2r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ2r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ2r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ2r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ2r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ2r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ2r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ2r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ2r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_AM_OFFS2
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc398
 * DESC:     Rx AM Block Offset status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_BLOCK_OFFSET_2 Indicates the block offset from the block that carries the Rx base timestamp to the AM block.The block size is 66bits for CL82 ports that run with or without CL74 FEC.The block size is 60 for CL82 ports that run with CL91.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL2(1st copy)/VL7(2nd copy)/VL12(3rd copy)/VL17(4th copy)
 *     CL74_FEC_BLOCK_NUM_2 Indicates the CL74 FEC block number of the AM block within the CL74 codeword. Need to be used only for ports that employ CL74
 *     AM_TIMESTAMP_INFO_VALID_2 When set, it indicates that AM timestamp information is valid for the virtual lane. SW can use the information for deskewadjustment calculations.Once set, this bit will continue to remain asserted until Rx AM timestamp capture is restarted.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r (0x0000c398 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_AM_OFFS2.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_am_offs2[1];
	uint32_t _rx_x4_rx_deskew_am_offs2;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_CLR(r) (r).rx_x4_rx_deskew_am_offs2[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_SET(r,d) (r).rx_x4_rx_deskew_am_offs2[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_GET(r) (r).rx_x4_rx_deskew_am_offs2[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_TIMESTAMP_INFO_VALID_2f_GET(r) ((((r).rx_x4_rx_deskew_am_offs2[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_TIMESTAMP_INFO_VALID_2f_SET(r,f) (r).rx_x4_rx_deskew_am_offs2[0]=(((r).rx_x4_rx_deskew_am_offs2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_CL74_FEC_BLOCK_NUM_2f_GET(r) ((((r).rx_x4_rx_deskew_am_offs2[0]) >> 6) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_CL74_FEC_BLOCK_NUM_2f_SET(r,f) (r).rx_x4_rx_deskew_am_offs2[0]=(((r).rx_x4_rx_deskew_am_offs2[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_BLOCK_OFFSET_2f_GET(r) (((r).rx_x4_rx_deskew_am_offs2[0]) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_BLOCK_OFFSET_2f_SET(r,f) (r).rx_x4_rx_deskew_am_offs2[0]=(((r).rx_x4_rx_deskew_am_offs2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_AM_OFFS2.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r,(_r._rx_x4_rx_deskew_am_offs2))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r,(_r._rx_x4_rx_deskew_am_offs2)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r,(_r._rx_x4_rx_deskew_am_offs2))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs2))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs2))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_am_offs2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_AM_OFFS2r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r
#define RX_X4_RX_DESKEW_AM_OFFS2r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_t RX_X4_RX_DESKEW_AM_OFFS2r_t;
#define RX_X4_RX_DESKEW_AM_OFFS2r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_CLR
#define RX_X4_RX_DESKEW_AM_OFFS2r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_SET
#define RX_X4_RX_DESKEW_AM_OFFS2r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_GET
#define RX_X4_RX_DESKEW_AM_OFFS2r_AM_TIMESTAMP_INFO_VALID_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_TIMESTAMP_INFO_VALID_2f_GET
#define RX_X4_RX_DESKEW_AM_OFFS2r_AM_TIMESTAMP_INFO_VALID_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_TIMESTAMP_INFO_VALID_2f_SET
#define RX_X4_RX_DESKEW_AM_OFFS2r_CL74_FEC_BLOCK_NUM_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_CL74_FEC_BLOCK_NUM_2f_GET
#define RX_X4_RX_DESKEW_AM_OFFS2r_CL74_FEC_BLOCK_NUM_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_CL74_FEC_BLOCK_NUM_2f_SET
#define RX_X4_RX_DESKEW_AM_OFFS2r_AM_BLOCK_OFFSET_2f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_BLOCK_OFFSET_2f_GET
#define RX_X4_RX_DESKEW_AM_OFFS2r_AM_BLOCK_OFFSET_2f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r_AM_BLOCK_OFFSET_2f_SET
#define READ_RX_X4_RX_DESKEW_AM_OFFS2r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS2r
#define WRITE_RX_X4_RX_DESKEW_AM_OFFS2r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS2r
#define MODIFY_RX_X4_RX_DESKEW_AM_OFFS2r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS2r
#define READLN_RX_X4_RX_DESKEW_AM_OFFS2r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS2r
#define WRITELN_RX_X4_RX_DESKEW_AM_OFFS2r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS2r
#define WRITEALL_RX_X4_RX_DESKEW_AM_OFFS2r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_CALC3
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc399
 * DESC:     Rx Base Timestamp status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_3 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL3(1st copy)/VL8(2nd copy)/VL13(3rd copy)/VL18(4th copy)
 *     BASE_TS_NS_3     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r (0x0000c399 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_CALC3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_calc3[1];
	uint32_t _rx_x4_rx_deskew_base_ts_calc3;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_CLR(r) (r).rx_x4_rx_deskew_base_ts_calc3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_calc3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_GET(r) (r).rx_x4_rx_deskew_base_ts_calc3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_NS_3f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_calc3[0]) >> 4) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_NS_3f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc3[0]=(((r).rx_x4_rx_deskew_base_ts_calc3[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_SUB_NS_3f_GET(r) (((r).rx_x4_rx_deskew_base_ts_calc3[0]) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_SUB_NS_3f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc3[0]=(((r).rx_x4_rx_deskew_base_ts_calc3[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_CALC3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r,(_r._rx_x4_rx_deskew_base_ts_calc3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r,(_r._rx_x4_rx_deskew_base_ts_calc3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r,(_r._rx_x4_rx_deskew_base_ts_calc3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_calc3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_CALC3r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_t RX_X4_RX_DESKEW_BASE_TS_CALC3r_t;
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_NS_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_NS_3f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_NS_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_NS_3f_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_SUB_NS_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_SUB_NS_3f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_SUB_NS_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r_BASE_TS_SUB_NS_3f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_CALC3r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC3r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC3r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC3r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC3r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC3r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_CALC3r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC3r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC3r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC3r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_ADJ3
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc39a
 * DESC:     Rx Base Timestamp Adjust status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BIT_POS_ADJ_3    Indicates the Bit Position Adjustment that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.This field is represented as a 2's complement value, as the bit position adjustment can be negativeOn Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL3(1st copy)/VL8(2nd copy)/VL13(3rd copy)/VL18(4th copy)
 *     BASE_TS_FCLK_ADJ_3 Indicates the Glas Adjustment or FCLK Adjust that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r (0x0000c39a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_ADJ3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_adj3[1];
	uint32_t _rx_x4_rx_deskew_base_ts_adj3;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_CLR(r) (r).rx_x4_rx_deskew_base_ts_adj3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_adj3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_GET(r) (r).rx_x4_rx_deskew_base_ts_adj3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BASE_TS_FCLK_ADJ_3f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_adj3[0]) >> 9) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BASE_TS_FCLK_ADJ_3f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj3[0]=(((r).rx_x4_rx_deskew_base_ts_adj3[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BIT_POS_ADJ_3f_GET(r) (((r).rx_x4_rx_deskew_base_ts_adj3[0]) & 0x1ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BIT_POS_ADJ_3f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj3[0]=(((r).rx_x4_rx_deskew_base_ts_adj3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_ADJ3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r,(_r._rx_x4_rx_deskew_base_ts_adj3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r,(_r._rx_x4_rx_deskew_base_ts_adj3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r,(_r._rx_x4_rx_deskew_base_ts_adj3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_adj3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_t RX_X4_RX_DESKEW_BASE_TS_ADJ3r_t;
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BASE_TS_FCLK_ADJ_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BASE_TS_FCLK_ADJ_3f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BASE_TS_FCLK_ADJ_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BASE_TS_FCLK_ADJ_3f_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BIT_POS_ADJ_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BIT_POS_ADJ_3f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BIT_POS_ADJ_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r_BIT_POS_ADJ_3f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_ADJ3r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ3r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ3r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ3r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ3r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ3r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ3r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ3r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ3r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ3r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_AM_OFFS3
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc39b
 * DESC:     Rx AM Block Offset status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_BLOCK_OFFSET_3 Indicates the block offset from the block that carries the Rx base timestamp to the AM block.The block size is 66bits for CL82 ports that run with or without CL74 FEC.The block size is 60 for CL82 ports that run with CL91.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL3(1st copy)/VL8(2nd copy)/VL13(3rd copy)/VL18(4th copy)
 *     CL74_FEC_BLOCK_NUM_3 Indicates the CL74 FEC block number of the AM block within the CL74 codeword. Need to be used only for ports that employ CL74
 *     AM_TIMESTAMP_INFO_VALID_3 When set, it indicates that AM timestamp information is valid for the virtual lane. SW can use the information for deskewadjustment calculations.Once set, this bit will continue to remain asserted until Rx AM timestamp capture is restarted.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r (0x0000c39b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_AM_OFFS3.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_am_offs3[1];
	uint32_t _rx_x4_rx_deskew_am_offs3;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_CLR(r) (r).rx_x4_rx_deskew_am_offs3[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_SET(r,d) (r).rx_x4_rx_deskew_am_offs3[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_GET(r) (r).rx_x4_rx_deskew_am_offs3[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_TIMESTAMP_INFO_VALID_3f_GET(r) ((((r).rx_x4_rx_deskew_am_offs3[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_TIMESTAMP_INFO_VALID_3f_SET(r,f) (r).rx_x4_rx_deskew_am_offs3[0]=(((r).rx_x4_rx_deskew_am_offs3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_CL74_FEC_BLOCK_NUM_3f_GET(r) ((((r).rx_x4_rx_deskew_am_offs3[0]) >> 6) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_CL74_FEC_BLOCK_NUM_3f_SET(r,f) (r).rx_x4_rx_deskew_am_offs3[0]=(((r).rx_x4_rx_deskew_am_offs3[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_BLOCK_OFFSET_3f_GET(r) (((r).rx_x4_rx_deskew_am_offs3[0]) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_BLOCK_OFFSET_3f_SET(r,f) (r).rx_x4_rx_deskew_am_offs3[0]=(((r).rx_x4_rx_deskew_am_offs3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_AM_OFFS3.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r,(_r._rx_x4_rx_deskew_am_offs3))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r,(_r._rx_x4_rx_deskew_am_offs3)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r,(_r._rx_x4_rx_deskew_am_offs3))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs3))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs3))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_am_offs3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_AM_OFFS3r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r
#define RX_X4_RX_DESKEW_AM_OFFS3r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_t RX_X4_RX_DESKEW_AM_OFFS3r_t;
#define RX_X4_RX_DESKEW_AM_OFFS3r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_CLR
#define RX_X4_RX_DESKEW_AM_OFFS3r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_SET
#define RX_X4_RX_DESKEW_AM_OFFS3r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_GET
#define RX_X4_RX_DESKEW_AM_OFFS3r_AM_TIMESTAMP_INFO_VALID_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_TIMESTAMP_INFO_VALID_3f_GET
#define RX_X4_RX_DESKEW_AM_OFFS3r_AM_TIMESTAMP_INFO_VALID_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_TIMESTAMP_INFO_VALID_3f_SET
#define RX_X4_RX_DESKEW_AM_OFFS3r_CL74_FEC_BLOCK_NUM_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_CL74_FEC_BLOCK_NUM_3f_GET
#define RX_X4_RX_DESKEW_AM_OFFS3r_CL74_FEC_BLOCK_NUM_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_CL74_FEC_BLOCK_NUM_3f_SET
#define RX_X4_RX_DESKEW_AM_OFFS3r_AM_BLOCK_OFFSET_3f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_BLOCK_OFFSET_3f_GET
#define RX_X4_RX_DESKEW_AM_OFFS3r_AM_BLOCK_OFFSET_3f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r_AM_BLOCK_OFFSET_3f_SET
#define READ_RX_X4_RX_DESKEW_AM_OFFS3r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS3r
#define WRITE_RX_X4_RX_DESKEW_AM_OFFS3r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS3r
#define MODIFY_RX_X4_RX_DESKEW_AM_OFFS3r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS3r
#define READLN_RX_X4_RX_DESKEW_AM_OFFS3r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS3r
#define WRITELN_RX_X4_RX_DESKEW_AM_OFFS3r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS3r
#define WRITEALL_RX_X4_RX_DESKEW_AM_OFFS3r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_CALC4
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc39c
 * DESC:     Rx Base Timestamp status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BASE_TS_SUB_NS_4 Indicates the sub-nano part of the Rx base timestamp used for AM timestamp calculation.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL4(1st copy)/VL9(2nd copy)/VL14(3rd copy)/VL19(4th copy)
 *     BASE_TS_NS_4     Indicates the Rx base timestamp(in nano seconds) for AM timestamp calculation.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r (0x0000c39c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_CALC4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_calc4[1];
	uint32_t _rx_x4_rx_deskew_base_ts_calc4;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_CLR(r) (r).rx_x4_rx_deskew_base_ts_calc4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_calc4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_GET(r) (r).rx_x4_rx_deskew_base_ts_calc4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_NS_4f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_calc4[0]) >> 4) & 0xfff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_NS_4f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc4[0]=(((r).rx_x4_rx_deskew_base_ts_calc4[0] & ~((uint32_t)0xfff << 4)) | ((((uint32_t)f) & 0xfff) << 4)) | (4095 << (16 + 4))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_SUB_NS_4f_GET(r) (((r).rx_x4_rx_deskew_base_ts_calc4[0]) & 0xf)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_SUB_NS_4f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_calc4[0]=(((r).rx_x4_rx_deskew_base_ts_calc4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_CALC4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r,(_r._rx_x4_rx_deskew_base_ts_calc4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r,(_r._rx_x4_rx_deskew_base_ts_calc4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r,(_r._rx_x4_rx_deskew_base_ts_calc4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_calc4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_calc4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_CALC4r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_t RX_X4_RX_DESKEW_BASE_TS_CALC4r_t;
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_NS_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_NS_4f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_NS_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_NS_4f_SET
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_SUB_NS_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_SUB_NS_4f_GET
#define RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_SUB_NS_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r_BASE_TS_SUB_NS_4f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_CALC4r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_CALC4r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC4r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_CALC4r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC4r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_CALC4r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_CALC4r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_CALC4r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC4r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_CALC4r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_CALC4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_CALC4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_BASE_TS_ADJ4
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc39d
 * DESC:     Rx Base Timestamp Adjust status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     BIT_POS_ADJ_4    Indicates the Bit Position Adjustment that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.This field is represented as a 2's complement value, as the bit position adjustment can be negativeOn Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL4(1st copy)/VL9(2nd copy)/VL14(3rd copy)/VL19(4th copy)
 *     BASE_TS_FCLK_ADJ_4 Indicates the Glas Adjustment or FCLK Adjust that needs to be applied to the Rx base timestamp to extrapolate the AM Marker timestamp.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r (0x0000c39d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_BASE_TS_ADJ4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_base_ts_adj4[1];
	uint32_t _rx_x4_rx_deskew_base_ts_adj4;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_CLR(r) (r).rx_x4_rx_deskew_base_ts_adj4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_SET(r,d) (r).rx_x4_rx_deskew_base_ts_adj4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_GET(r) (r).rx_x4_rx_deskew_base_ts_adj4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BASE_TS_FCLK_ADJ_4f_GET(r) ((((r).rx_x4_rx_deskew_base_ts_adj4[0]) >> 9) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BASE_TS_FCLK_ADJ_4f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj4[0]=(((r).rx_x4_rx_deskew_base_ts_adj4[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BIT_POS_ADJ_4f_GET(r) (((r).rx_x4_rx_deskew_base_ts_adj4[0]) & 0x1ff)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BIT_POS_ADJ_4f_SET(r,f) (r).rx_x4_rx_deskew_base_ts_adj4[0]=(((r).rx_x4_rx_deskew_base_ts_adj4[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_BASE_TS_ADJ4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r,(_r._rx_x4_rx_deskew_base_ts_adj4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r,(_r._rx_x4_rx_deskew_base_ts_adj4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r,(_r._rx_x4_rx_deskew_base_ts_adj4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_base_ts_adj4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_base_ts_adj4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_t RX_X4_RX_DESKEW_BASE_TS_ADJ4r_t;
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_CLR
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BASE_TS_FCLK_ADJ_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BASE_TS_FCLK_ADJ_4f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BASE_TS_FCLK_ADJ_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BASE_TS_FCLK_ADJ_4f_SET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BIT_POS_ADJ_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BIT_POS_ADJ_4f_GET
#define RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BIT_POS_ADJ_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r_BIT_POS_ADJ_4f_SET
#define READ_RX_X4_RX_DESKEW_BASE_TS_ADJ4r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_BASE_TS_ADJ4r
#define WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ4r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_BASE_TS_ADJ4r
#define MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ4r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_BASE_TS_ADJ4r
#define READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ4r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_BASE_TS_ADJ4r
#define WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ4r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_BASE_TS_ADJ4r
#define WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_BASE_TS_ADJ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_BASE_TS_ADJ4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  RX_X4_RX_DESKEW_AM_OFFS4
 * BLOCKS:   RX_X4_STATUS6
 * REGADDR:  0xc39e
 * DESC:     Rx AM Block Offset status(Per Virtual lane) for Deskew
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     AM_BLOCK_OFFSET_4 Indicates the block offset from the block that carries the Rx base timestamp to the AM block.The block size is 66bits for CL82 ports that run with or without CL74 FEC.The block size is 60 for CL82 ports that run with CL91.On Deskew event, this deskew status information is provided for each Virtual Lane using multiple copies of this register as follows,In 100G MLD mode(Port0) - VL4(1st copy)/VL9(2nd copy)/VL14(3rd copy)/VL19(4th copy)
 *     CL74_FEC_BLOCK_NUM_4 Indicates the CL74 FEC block number of the AM block within the CL74 codeword. Need to be used only for ports that employ CL74
 *     AM_TIMESTAMP_INFO_VALID_4 When set, it indicates that AM timestamp information is valid for the virtual lane. SW can use the information for deskewadjustment calculations.Once set, this bit will continue to remain asserted until Rx AM timestamp capture is restarted.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r (0x0000c39e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_SIZE 4

/*
 * This structure should be used to declare and program RX_X4_RX_DESKEW_AM_OFFS4.
 *
 */
typedef union BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_s {
	uint32_t v[1];
	uint32_t rx_x4_rx_deskew_am_offs4[1];
	uint32_t _rx_x4_rx_deskew_am_offs4;
} BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_t;

#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_CLR(r) (r).rx_x4_rx_deskew_am_offs4[0] = 0
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_SET(r,d) (r).rx_x4_rx_deskew_am_offs4[0] = d
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_GET(r) (r).rx_x4_rx_deskew_am_offs4[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_TIMESTAMP_INFO_VALID_4f_GET(r) ((((r).rx_x4_rx_deskew_am_offs4[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_TIMESTAMP_INFO_VALID_4f_SET(r,f) (r).rx_x4_rx_deskew_am_offs4[0]=(((r).rx_x4_rx_deskew_am_offs4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_CL74_FEC_BLOCK_NUM_4f_GET(r) ((((r).rx_x4_rx_deskew_am_offs4[0]) >> 6) & 0x1f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_CL74_FEC_BLOCK_NUM_4f_SET(r,f) (r).rx_x4_rx_deskew_am_offs4[0]=(((r).rx_x4_rx_deskew_am_offs4[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_BLOCK_OFFSET_4f_GET(r) (((r).rx_x4_rx_deskew_am_offs4[0]) & 0x3f)
#define BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_BLOCK_OFFSET_4f_SET(r,f) (r).rx_x4_rx_deskew_am_offs4[0]=(((r).rx_x4_rx_deskew_am_offs4[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access RX_X4_RX_DESKEW_AM_OFFS4.
 *
 */
#define BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r,(_r._rx_x4_rx_deskew_am_offs4))
#define BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r,(_r._rx_x4_rx_deskew_am_offs4)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r,(_r._rx_x4_rx_deskew_am_offs4))
#define BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs4))
#define BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._rx_x4_rx_deskew_am_offs4))
#define BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._rx_x4_rx_deskew_am_offs4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define RX_X4_RX_DESKEW_AM_OFFS4r BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r
#define RX_X4_RX_DESKEW_AM_OFFS4r_SIZE BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_SIZE
typedef BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_t RX_X4_RX_DESKEW_AM_OFFS4r_t;
#define RX_X4_RX_DESKEW_AM_OFFS4r_CLR BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_CLR
#define RX_X4_RX_DESKEW_AM_OFFS4r_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_SET
#define RX_X4_RX_DESKEW_AM_OFFS4r_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_GET
#define RX_X4_RX_DESKEW_AM_OFFS4r_AM_TIMESTAMP_INFO_VALID_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_TIMESTAMP_INFO_VALID_4f_GET
#define RX_X4_RX_DESKEW_AM_OFFS4r_AM_TIMESTAMP_INFO_VALID_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_TIMESTAMP_INFO_VALID_4f_SET
#define RX_X4_RX_DESKEW_AM_OFFS4r_CL74_FEC_BLOCK_NUM_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_CL74_FEC_BLOCK_NUM_4f_GET
#define RX_X4_RX_DESKEW_AM_OFFS4r_CL74_FEC_BLOCK_NUM_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_CL74_FEC_BLOCK_NUM_4f_SET
#define RX_X4_RX_DESKEW_AM_OFFS4r_AM_BLOCK_OFFSET_4f_GET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_BLOCK_OFFSET_4f_GET
#define RX_X4_RX_DESKEW_AM_OFFS4r_AM_BLOCK_OFFSET_4f_SET BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r_AM_BLOCK_OFFSET_4f_SET
#define READ_RX_X4_RX_DESKEW_AM_OFFS4r BCMI_TSCD_XGXS_READ_RX_X4_RX_DESKEW_AM_OFFS4r
#define WRITE_RX_X4_RX_DESKEW_AM_OFFS4r BCMI_TSCD_XGXS_WRITE_RX_X4_RX_DESKEW_AM_OFFS4r
#define MODIFY_RX_X4_RX_DESKEW_AM_OFFS4r BCMI_TSCD_XGXS_MODIFY_RX_X4_RX_DESKEW_AM_OFFS4r
#define READLN_RX_X4_RX_DESKEW_AM_OFFS4r BCMI_TSCD_XGXS_READLN_RX_X4_RX_DESKEW_AM_OFFS4r
#define WRITELN_RX_X4_RX_DESKEW_AM_OFFS4r BCMI_TSCD_XGXS_WRITELN_RX_X4_RX_DESKEW_AM_OFFS4r
#define WRITEALL_RX_X4_RX_DESKEW_AM_OFFS4r BCMI_TSCD_XGXS_WRITEALL_RX_X4_RX_DESKEW_AM_OFFS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_RX_X4_RX_DESKEW_AM_OFFS4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  D5_MISC_CTL
 * BLOCKS:   PMD_D5_X4
 * REGADDR:  0xc3a0
 * DESC:     D5 PMD misc controls
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     BC_TRAIN_STOP    D5 PMD training stop
 *     FOM_START        Check channel figure of merit
 *     RX_LOSVREF       Loss of signal VREF for each channel
 *     C2C_ENA          Chip to Chip, also known as short channel mode
 *     RX_INVERT        Invert the RX input
 *     TX_INVERT        Invert the TX output
 *     TX_50OHM_IDLE    PMD TX 50ohm idle
 *     TX_IDLE          PMD TX idle
 *     TX_SSC_ENA       Spread Spectrum enable for TX
 *     MASTER_PLL       Indicates this lane is Master lane in aggregated modes. Default each lane is master
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_D5_MISC_CTLr (0x0000c3a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_D5_MISC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program D5_MISC_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_D5_MISC_CTLr_s {
	uint32_t v[1];
	uint32_t d5_misc_ctl[1];
	uint32_t _d5_misc_ctl;
} BCMI_TSCD_XGXS_D5_MISC_CTLr_t;

#define BCMI_TSCD_XGXS_D5_MISC_CTLr_CLR(r) (r).d5_misc_ctl[0] = 0
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_SET(r,d) (r).d5_misc_ctl[0] = d
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_GET(r) (r).d5_misc_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_MASTER_PLLf_GET(r) ((((r).d5_misc_ctl[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_MASTER_PLLf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_SSC_ENAf_GET(r) ((((r).d5_misc_ctl[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_SSC_ENAf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_IDLEf_GET(r) ((((r).d5_misc_ctl[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_IDLEf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_50OHM_IDLEf_GET(r) ((((r).d5_misc_ctl[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_50OHM_IDLEf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_INVERTf_GET(r) ((((r).d5_misc_ctl[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_INVERTf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_INVERTf_GET(r) ((((r).d5_misc_ctl[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_INVERTf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_C2C_ENAf_GET(r) ((((r).d5_misc_ctl[0]) >> 7) & 0x3)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_C2C_ENAf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x3 << 7)) | ((((uint32_t)f) & 0x3) << 7)) | (3 << (16 + 7))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_LOSVREFf_GET(r) ((((r).d5_misc_ctl[0]) >> 2) & 0x1f)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_LOSVREFf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1f << 2)) | ((((uint32_t)f) & 0x1f) << 2)) | (31 << (16 + 2))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_FOM_STARTf_GET(r) ((((r).d5_misc_ctl[0]) >> 1) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_FOM_STARTf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_BC_TRAIN_STOPf_GET(r) (((r).d5_misc_ctl[0]) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_CTLr_BC_TRAIN_STOPf_SET(r,f) (r).d5_misc_ctl[0]=(((r).d5_misc_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access D5_MISC_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_D5_MISC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC_CTLr,(_r._d5_misc_ctl))
#define BCMI_TSCD_XGXS_WRITE_D5_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_CTLr,(_r._d5_misc_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_D5_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_CTLr,(_r._d5_misc_ctl))
#define BCMI_TSCD_XGXS_READLN_D5_MISC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc_ctl))
#define BCMI_TSCD_XGXS_WRITELN_D5_MISC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_D5_MISC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._d5_misc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define D5_MISC_CTLr BCMI_TSCD_XGXS_D5_MISC_CTLr
#define D5_MISC_CTLr_SIZE BCMI_TSCD_XGXS_D5_MISC_CTLr_SIZE
typedef BCMI_TSCD_XGXS_D5_MISC_CTLr_t D5_MISC_CTLr_t;
#define D5_MISC_CTLr_CLR BCMI_TSCD_XGXS_D5_MISC_CTLr_CLR
#define D5_MISC_CTLr_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_SET
#define D5_MISC_CTLr_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_GET
#define D5_MISC_CTLr_MASTER_PLLf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_MASTER_PLLf_GET
#define D5_MISC_CTLr_MASTER_PLLf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_MASTER_PLLf_SET
#define D5_MISC_CTLr_TX_SSC_ENAf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_SSC_ENAf_GET
#define D5_MISC_CTLr_TX_SSC_ENAf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_SSC_ENAf_SET
#define D5_MISC_CTLr_TX_IDLEf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_IDLEf_GET
#define D5_MISC_CTLr_TX_IDLEf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_IDLEf_SET
#define D5_MISC_CTLr_TX_50OHM_IDLEf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_50OHM_IDLEf_GET
#define D5_MISC_CTLr_TX_50OHM_IDLEf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_50OHM_IDLEf_SET
#define D5_MISC_CTLr_TX_INVERTf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_INVERTf_GET
#define D5_MISC_CTLr_TX_INVERTf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_TX_INVERTf_SET
#define D5_MISC_CTLr_RX_INVERTf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_INVERTf_GET
#define D5_MISC_CTLr_RX_INVERTf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_INVERTf_SET
#define D5_MISC_CTLr_C2C_ENAf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_C2C_ENAf_GET
#define D5_MISC_CTLr_C2C_ENAf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_C2C_ENAf_SET
#define D5_MISC_CTLr_RX_LOSVREFf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_LOSVREFf_GET
#define D5_MISC_CTLr_RX_LOSVREFf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_RX_LOSVREFf_SET
#define D5_MISC_CTLr_FOM_STARTf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_FOM_STARTf_GET
#define D5_MISC_CTLr_FOM_STARTf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_FOM_STARTf_SET
#define D5_MISC_CTLr_BC_TRAIN_STOPf_GET BCMI_TSCD_XGXS_D5_MISC_CTLr_BC_TRAIN_STOPf_GET
#define D5_MISC_CTLr_BC_TRAIN_STOPf_SET BCMI_TSCD_XGXS_D5_MISC_CTLr_BC_TRAIN_STOPf_SET
#define READ_D5_MISC_CTLr BCMI_TSCD_XGXS_READ_D5_MISC_CTLr
#define WRITE_D5_MISC_CTLr BCMI_TSCD_XGXS_WRITE_D5_MISC_CTLr
#define MODIFY_D5_MISC_CTLr BCMI_TSCD_XGXS_MODIFY_D5_MISC_CTLr
#define READLN_D5_MISC_CTLr BCMI_TSCD_XGXS_READLN_D5_MISC_CTLr
#define WRITELN_D5_MISC_CTLr BCMI_TSCD_XGXS_WRITELN_D5_MISC_CTLr
#define WRITEALL_D5_MISC_CTLr BCMI_TSCD_XGXS_WRITEALL_D5_MISC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_D5_MISC_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  D5_MISC1_CTL
 * BLOCKS:   PMD_D5_X4
 * REGADDR:  0xc3a1
 * DESC:     D5 PMD misc controls
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_AMP           Select TX amplitude
 *     MISC1_RESERVED   Reserved for future use.
 *     TX_REFCLK_SELECT Select TX clock from 3 available choices, secmos0,1,2
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr (0x0000c3a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_SIZE 4

/*
 * This structure should be used to declare and program D5_MISC1_CTL.
 *
 */
typedef union BCMI_TSCD_XGXS_D5_MISC1_CTLr_s {
	uint32_t v[1];
	uint32_t d5_misc1_ctl[1];
	uint32_t _d5_misc1_ctl;
} BCMI_TSCD_XGXS_D5_MISC1_CTLr_t;

#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_CLR(r) (r).d5_misc1_ctl[0] = 0
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_SET(r,d) (r).d5_misc1_ctl[0] = d
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_GET(r) (r).d5_misc1_ctl[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_REFCLK_SELECTf_GET(r) ((((r).d5_misc1_ctl[0]) >> 14) & 0x3)
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_REFCLK_SELECTf_SET(r,f) (r).d5_misc1_ctl[0]=(((r).d5_misc1_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_MISC1_RESERVEDf_GET(r) ((((r).d5_misc1_ctl[0]) >> 4) & 0x3ff)
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_MISC1_RESERVEDf_SET(r,f) (r).d5_misc1_ctl[0]=(((r).d5_misc1_ctl[0] & ~((uint32_t)0x3ff << 4)) | ((((uint32_t)f) & 0x3ff) << 4)) | (1023 << (16 + 4))
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_AMPf_GET(r) (((r).d5_misc1_ctl[0]) & 0xf)
#define BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_AMPf_SET(r,f) (r).d5_misc1_ctl[0]=(((r).d5_misc1_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access D5_MISC1_CTL.
 *
 */
#define BCMI_TSCD_XGXS_READ_D5_MISC1_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC1_CTLr,(_r._d5_misc1_ctl))
#define BCMI_TSCD_XGXS_WRITE_D5_MISC1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_CTLr,(_r._d5_misc1_ctl)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_D5_MISC1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_CTLr,(_r._d5_misc1_ctl))
#define BCMI_TSCD_XGXS_READLN_D5_MISC1_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc1_ctl))
#define BCMI_TSCD_XGXS_WRITELN_D5_MISC1_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc1_ctl))
#define BCMI_TSCD_XGXS_WRITEALL_D5_MISC1_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._d5_misc1_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define D5_MISC1_CTLr BCMI_TSCD_XGXS_D5_MISC1_CTLr
#define D5_MISC1_CTLr_SIZE BCMI_TSCD_XGXS_D5_MISC1_CTLr_SIZE
typedef BCMI_TSCD_XGXS_D5_MISC1_CTLr_t D5_MISC1_CTLr_t;
#define D5_MISC1_CTLr_CLR BCMI_TSCD_XGXS_D5_MISC1_CTLr_CLR
#define D5_MISC1_CTLr_SET BCMI_TSCD_XGXS_D5_MISC1_CTLr_SET
#define D5_MISC1_CTLr_GET BCMI_TSCD_XGXS_D5_MISC1_CTLr_GET
#define D5_MISC1_CTLr_TX_REFCLK_SELECTf_GET BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_REFCLK_SELECTf_GET
#define D5_MISC1_CTLr_TX_REFCLK_SELECTf_SET BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_REFCLK_SELECTf_SET
#define D5_MISC1_CTLr_MISC1_RESERVEDf_GET BCMI_TSCD_XGXS_D5_MISC1_CTLr_MISC1_RESERVEDf_GET
#define D5_MISC1_CTLr_MISC1_RESERVEDf_SET BCMI_TSCD_XGXS_D5_MISC1_CTLr_MISC1_RESERVEDf_SET
#define D5_MISC1_CTLr_TX_AMPf_GET BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_AMPf_GET
#define D5_MISC1_CTLr_TX_AMPf_SET BCMI_TSCD_XGXS_D5_MISC1_CTLr_TX_AMPf_SET
#define READ_D5_MISC1_CTLr BCMI_TSCD_XGXS_READ_D5_MISC1_CTLr
#define WRITE_D5_MISC1_CTLr BCMI_TSCD_XGXS_WRITE_D5_MISC1_CTLr
#define MODIFY_D5_MISC1_CTLr BCMI_TSCD_XGXS_MODIFY_D5_MISC1_CTLr
#define READLN_D5_MISC1_CTLr BCMI_TSCD_XGXS_READLN_D5_MISC1_CTLr
#define WRITELN_D5_MISC1_CTLr BCMI_TSCD_XGXS_WRITELN_D5_MISC1_CTLr
#define WRITEALL_D5_MISC1_CTLr BCMI_TSCD_XGXS_WRITEALL_D5_MISC1_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_D5_MISC1_CTLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  D5_MISC_STS
 * BLOCKS:   PMD_D5_X4
 * REGADDR:  0xc3a3
 * DESC:     D5 PMD misc status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     FOM_QUALITY      Channel Figure of Merit Quality
 *     FOM_DONE         Channel Figure of Merit done.
 *     RX_PHYREADY      Receive PHY is ready, based on rate/mode etc.,.
 *     TX_PHYREADY      Transmit PHY is ready, based on rate/mode etc.,.
 *     RX_SYNCDET       Receive sync detected.
 *     ALLOW_VDDA_OFF   Allow VDDA off.
 *     ALLOW_VDDH_OFF   Allow VDDh off.
 *     STATUS0_ALT      Reserved bit .
 *     STATUS1_ALT      Reserved bit .
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_D5_MISC_STSr (0x0000c3a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_D5_MISC_STSr_SIZE 4

/*
 * This structure should be used to declare and program D5_MISC_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_D5_MISC_STSr_s {
	uint32_t v[1];
	uint32_t d5_misc_sts[1];
	uint32_t _d5_misc_sts;
} BCMI_TSCD_XGXS_D5_MISC_STSr_t;

#define BCMI_TSCD_XGXS_D5_MISC_STSr_CLR(r) (r).d5_misc_sts[0] = 0
#define BCMI_TSCD_XGXS_D5_MISC_STSr_SET(r,d) (r).d5_misc_sts[0] = d
#define BCMI_TSCD_XGXS_D5_MISC_STSr_GET(r) (r).d5_misc_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS1_ALTf_GET(r) ((((r).d5_misc_sts[0]) >> 15) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS1_ALTf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS0_ALTf_GET(r) ((((r).d5_misc_sts[0]) >> 14) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS0_ALTf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDH_OFFf_GET(r) ((((r).d5_misc_sts[0]) >> 13) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDH_OFFf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDA_OFFf_GET(r) ((((r).d5_misc_sts[0]) >> 12) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDA_OFFf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_RX_SYNCDETf_GET(r) ((((r).d5_misc_sts[0]) >> 11) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_RX_SYNCDETf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_TX_PHYREADYf_GET(r) ((((r).d5_misc_sts[0]) >> 10) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_TX_PHYREADYf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_RX_PHYREADYf_GET(r) ((((r).d5_misc_sts[0]) >> 9) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_RX_PHYREADYf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_DONEf_GET(r) ((((r).d5_misc_sts[0]) >> 8) & 0x1)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_DONEf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_QUALITYf_GET(r) (((r).d5_misc_sts[0]) & 0xff)
#define BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_QUALITYf_SET(r,f) (r).d5_misc_sts[0]=(((r).d5_misc_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access D5_MISC_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_D5_MISC_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC_STSr,(_r._d5_misc_sts))
#define BCMI_TSCD_XGXS_WRITE_D5_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_STSr,(_r._d5_misc_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_D5_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_STSr,(_r._d5_misc_sts))
#define BCMI_TSCD_XGXS_READLN_D5_MISC_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc_sts))
#define BCMI_TSCD_XGXS_WRITELN_D5_MISC_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc_sts))
#define BCMI_TSCD_XGXS_WRITEALL_D5_MISC_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._d5_misc_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define D5_MISC_STSr BCMI_TSCD_XGXS_D5_MISC_STSr
#define D5_MISC_STSr_SIZE BCMI_TSCD_XGXS_D5_MISC_STSr_SIZE
typedef BCMI_TSCD_XGXS_D5_MISC_STSr_t D5_MISC_STSr_t;
#define D5_MISC_STSr_CLR BCMI_TSCD_XGXS_D5_MISC_STSr_CLR
#define D5_MISC_STSr_SET BCMI_TSCD_XGXS_D5_MISC_STSr_SET
#define D5_MISC_STSr_GET BCMI_TSCD_XGXS_D5_MISC_STSr_GET
#define D5_MISC_STSr_STATUS1_ALTf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS1_ALTf_GET
#define D5_MISC_STSr_STATUS1_ALTf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS1_ALTf_SET
#define D5_MISC_STSr_STATUS0_ALTf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS0_ALTf_GET
#define D5_MISC_STSr_STATUS0_ALTf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_STATUS0_ALTf_SET
#define D5_MISC_STSr_ALLOW_VDDH_OFFf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDH_OFFf_GET
#define D5_MISC_STSr_ALLOW_VDDH_OFFf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDH_OFFf_SET
#define D5_MISC_STSr_ALLOW_VDDA_OFFf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDA_OFFf_GET
#define D5_MISC_STSr_ALLOW_VDDA_OFFf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_ALLOW_VDDA_OFFf_SET
#define D5_MISC_STSr_RX_SYNCDETf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_RX_SYNCDETf_GET
#define D5_MISC_STSr_RX_SYNCDETf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_RX_SYNCDETf_SET
#define D5_MISC_STSr_TX_PHYREADYf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_TX_PHYREADYf_GET
#define D5_MISC_STSr_TX_PHYREADYf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_TX_PHYREADYf_SET
#define D5_MISC_STSr_RX_PHYREADYf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_RX_PHYREADYf_GET
#define D5_MISC_STSr_RX_PHYREADYf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_RX_PHYREADYf_SET
#define D5_MISC_STSr_FOM_DONEf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_DONEf_GET
#define D5_MISC_STSr_FOM_DONEf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_DONEf_SET
#define D5_MISC_STSr_FOM_QUALITYf_GET BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_QUALITYf_GET
#define D5_MISC_STSr_FOM_QUALITYf_SET BCMI_TSCD_XGXS_D5_MISC_STSr_FOM_QUALITYf_SET
#define READ_D5_MISC_STSr BCMI_TSCD_XGXS_READ_D5_MISC_STSr
#define WRITE_D5_MISC_STSr BCMI_TSCD_XGXS_WRITE_D5_MISC_STSr
#define MODIFY_D5_MISC_STSr BCMI_TSCD_XGXS_MODIFY_D5_MISC_STSr
#define READLN_D5_MISC_STSr BCMI_TSCD_XGXS_READLN_D5_MISC_STSr
#define WRITELN_D5_MISC_STSr BCMI_TSCD_XGXS_WRITELN_D5_MISC_STSr
#define WRITEALL_D5_MISC_STSr BCMI_TSCD_XGXS_WRITEALL_D5_MISC_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_D5_MISC_STSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  BCMI_TSCD_XGXS
 * REGISTER:  D5_MISC1_STS
 * BLOCKS:   PMD_D5_X4
 * REGADDR:  0xc3a4
 * DESC:     D5 PMD misc1 status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     D5_SERDES_DEBUG_BUS D5 Serdes debug bus.
 *
 ******************************************************************************/
#define BCMI_TSCD_XGXS_D5_MISC1_STSr (0x0000c3a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_TSCD_XGXS_D5_MISC1_STSr_SIZE 4

/*
 * This structure should be used to declare and program D5_MISC1_STS.
 *
 */
typedef union BCMI_TSCD_XGXS_D5_MISC1_STSr_s {
	uint32_t v[1];
	uint32_t d5_misc1_sts[1];
	uint32_t _d5_misc1_sts;
} BCMI_TSCD_XGXS_D5_MISC1_STSr_t;

#define BCMI_TSCD_XGXS_D5_MISC1_STSr_CLR(r) (r).d5_misc1_sts[0] = 0
#define BCMI_TSCD_XGXS_D5_MISC1_STSr_SET(r,d) (r).d5_misc1_sts[0] = d
#define BCMI_TSCD_XGXS_D5_MISC1_STSr_GET(r) (r).d5_misc1_sts[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define BCMI_TSCD_XGXS_D5_MISC1_STSr_D5_SERDES_DEBUG_BUSf_GET(r) (((r).d5_misc1_sts[0]) & 0xffff)
#define BCMI_TSCD_XGXS_D5_MISC1_STSr_D5_SERDES_DEBUG_BUSf_SET(r,f) (r).d5_misc1_sts[0]=(((r).d5_misc1_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access D5_MISC1_STS.
 *
 */
#define BCMI_TSCD_XGXS_READ_D5_MISC1_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC1_STSr,(_r._d5_misc1_sts))
#define BCMI_TSCD_XGXS_WRITE_D5_MISC1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_STSr,(_r._d5_misc1_sts)&0xffff)
#define BCMI_TSCD_XGXS_MODIFY_D5_MISC1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_STSr,(_r._d5_misc1_sts))
#define BCMI_TSCD_XGXS_READLN_D5_MISC1_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_TSCD_XGXS_D5_MISC1_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc1_sts))
#define BCMI_TSCD_XGXS_WRITELN_D5_MISC1_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._d5_misc1_sts))
#define BCMI_TSCD_XGXS_WRITEALL_D5_MISC1_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_TSCD_XGXS_D5_MISC1_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._d5_misc1_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 *
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define D5_MISC1_STSr BCMI_TSCD_XGXS_D5_MISC1_STSr
#define D5_MISC1_STSr_SIZE BCMI_TSCD_XGXS_D5_MISC1_STSr_SIZE
typedef BCMI_TSCD_XGXS_D5_MISC1_STSr_t D5_MISC1_STSr_t;
#define D5_MISC1_STSr_CLR BCMI_TSCD_XGXS_D5_MISC1_STSr_CLR
#define D5_MISC1_STSr_SET BCMI_TSCD_XGXS_D5_MISC1_STSr_SET
#define D5_MISC1_STSr_GET BCMI_TSCD_XGXS_D5_MISC1_STSr_GET
#define D5_MISC1_STSr_D5_SERDES_DEBUG_BUSf_GET BCMI_TSCD_XGXS_D5_MISC1_STSr_D5_SERDES_DEBUG_BUSf_GET
#define D5_MISC1_STSr_D5_SERDES_DEBUG_BUSf_SET BCMI_TSCD_XGXS_D5_MISC1_STSr_D5_SERDES_DEBUG_BUSf_SET
#define READ_D5_MISC1_STSr BCMI_TSCD_XGXS_READ_D5_MISC1_STSr
#define WRITE_D5_MISC1_STSr BCMI_TSCD_XGXS_WRITE_D5_MISC1_STSr
#define MODIFY_D5_MISC1_STSr BCMI_TSCD_XGXS_MODIFY_D5_MISC1_STSr
#define READLN_D5_MISC1_STSr BCMI_TSCD_XGXS_READLN_D5_MISC1_STSr
#define WRITELN_D5_MISC1_STSr BCMI_TSCD_XGXS_WRITELN_D5_MISC1_STSr
#define WRITEALL_D5_MISC1_STSr BCMI_TSCD_XGXS_WRITEALL_D5_MISC1_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_TSCD_XGXS_D5_MISC1_STSr'
 ******************************************************************************/




#endif /* __BCMI_TSCD_XGXS_DEFS_H__ */
